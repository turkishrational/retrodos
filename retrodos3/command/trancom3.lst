     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 20/10/2018
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res 0000000B>          .DIR_NAME:	RESB  11	; file name
   309 0000000B <res 00000001>          .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C <res 00000002>          .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E <res 00000002>          .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 <res 00000001>          .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 <res 00000005>          .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 <res 00000002>          .DIR_TIME:	RESW  1		; time of last write
   315 00000018 <res 00000002>          .DIR_DATE:	RESW  1		; date of last write
   316 0000001A <res 00000002>          .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C <res 00000002>          .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E <res 00000002>          .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 <res 00000004>          .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 <res 00000002>          .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 <res 00000002>          .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 <res 00000002>          .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A <res 00000008>          .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 <res 00000001>          .ISDIR:		RESB	1
   623 00000001 <res 00000001>          .SIZ:		RESB	1
   624 00000002 <res 00000002>          .TTAIL:		RESW	1
   625 00000004 <res 00000001>          .INFO:		RESB	1
   626 00000005 <res 00000057>          .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 <res 00000001>          .BatType:	RESB	1		; signature
   660 00000001 <res 00000001>          .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 <res 00000002>          .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 <res 00000002>          .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 <res 00000001>          .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 <res 00000004>          .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 00000014>          .BatParm:	RESW	10		; pointers to parameters
   667 0000001F <res 00000001>          .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 <res 00000002>          .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 <res 00000001>          .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 <res 00000002>          .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 <res 00000002>          .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 <res 00000002>          .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 <res 00000002>          .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 000002C0>          .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 <res 00000002>          .argvcnt:	RESW	1		; number of arguments
   691 000002C2 <res 00000002>          .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 00000200>          .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 00000080>          .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 <res 00000001>          .DRIVE:	    resb 1	; drive of search
   735 00000001 <res 0000000B>          .NAME:	    resb 11	; formatted name
   736 0000000C <res 00000001>          .SATTR:	    resb 1	; attribute of search
   737 0000000D <res 00000002>          .LASTENT:   resw 1	; LastEnt
   738 0000000F <res 00000002>          .DIRSTART:  resw 1	; DirStart
   739 00000011 <res 00000004>          .NETID:	    resb 4	; Reserved for NET
   740 00000015 <res 00000001>          .ATTR:	    resb 1	; attribute found
   741 00000016 <res 00000002>          .TIMR:	    resw 1	; time
   742 00000018 <res 00000002>          .DATE:	    resw 1	; date
   743 0000001A <res 00000002>          .SIZE_L:    resw 1	; low(size)
   744 0000001C <res 00000002>          .SIZE_H:    resw 1	; high(size)
   745 0000001E <res 0000000D>          .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 <res 00000002>          .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 <res 00000002>          .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 <res 00000001>                          resb 1
   766 00000005 <res 00000005>          .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A <res 00000004>          .EXIT:		resd 1		; pointer to exit routine
   768 0000000E <res 00000004>          .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 <res 00000004>          .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 <res 00000002>          .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 00000014>          .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C <res 00000002>          .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E <res 00000004>          .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 <res 00000002>          .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 <res 00000004>          .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 <res 00000004>          .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C <res 00000001>          .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D <res 00000001>          .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E <res 00000002>          .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 <res 00000002>          .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res 0000000E>          .PAD1:		resb 14 ; 0Eh
   782 00000050 <res 00000005>          .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 <res 00000007>          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 00000010>          .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 00000010>          .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C <res 00000004>          .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 00000080>          .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 <res 00000002>          .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 <res 00000005>          .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 <res 00000002>          .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 <res 00000002>          .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B <res 00000002>          .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D <res 00000002>          .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F <res 00000001>          .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 <res 00000001>          .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 <res 00000001>          .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 <res 00000002>          .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 <res 00000002>                            RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 <res 00000002>          .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 <res 00000001>            .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 <res 00000002>            .owner:	resw 1		; owner of arena item
   917 00000003 <res 00000002>            .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  LODCOM1	   equ	0318h	; 13/10/2018
   962                                  
   963                                  ; EXEC call adressses in resident portion for calling from transient portion
   964                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   965                                  
   966                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   967                                  PUTBACKDRV equ  0A21h	; 14/10/2018
   968                                  
   969                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   970                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   971                                  
   972                                  ; Resident portion stack address  
   973                                  RSTACK	   equ  083Ch
   974                                  
   975                                  RETRABASE  equ  0B86h ; 13/10/2018 (Base address for following common params.)	
   976                                  
   977                                  ; RESGROUP       [RESSEG]
   978                                  ; DATA		  offset
   979                                  ; --------     	------------
   980                                  PARENT	  equ	RETRABASE+6	; 0B8Ch
   981                                  OLDTERM	  equ	RETRABASE+8	; 0B9Eh
   982                                  BATCH	  equ	RETRABASE+17	; 0B97h
   983                                  COMSPEC	  equ	RETRABASE+19	; 0B99h
   984                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD9h
   985                                  COMSPEC_END equ	RETRABASE+85	; 0BDBh
   986                                  IN_BATCH  equ	RETRABASE+92	; 0BE2h
   987                                  BATCH_ABORT equ	RETRABASE+93	; 0BE3h
   988                                  COMDRV	  equ	RETRABASE+94	; 0BE4h
   989                                  EXTCOM	  equ	RETRABASE+99	; 0BE9h
   990                                  RETCODE	  equ	RETRABASE+100	; 0BEAh
   991                                  ECHOFLAG  equ	RETRABASE+103	; 0BEDh
   992                                  SUPPRESS  equ	RETRABASE+104	; 0BEEh
   993                                  IO_SAVE	  equ	RETRABASE+105	; 0BEFh
   994                                  RESTDIR	  equ	RETRABASE+107	; 0BF1h
   995                                  PERMCOM	  equ	RETRABASE+108	; 0BF2h
   996                                  SINGLECOM equ	RETRABASE+109	; 0BF3h
   997                                  VERVAL	  equ	RETRABASE+111	; 0BF5h
   998                                  IFFLAG	  equ	RETRABASE+114	; 0BF8h	
   999                                  FORFLAG	  equ	RETRABASE+115	; 0BF9h
  1000                                  FORPTR	  equ	RETRABASE+116	; 0BFAh 	
  1001                                  NEST	  equ	RETRABASE+118	; 0BFCh
  1002                                  CALL_FLAG equ	RETRABASE+120	; 0BFEh
  1003                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFFh
  1004                                  NEXT_BATCH equ	RETRABASE+122 	; 0C00h
  1005                                  NULLFLAG  equ	RETRABASE+124	; 0C02h
  1006                                  UPPERCASETBL equ RETRABASE+126	; 0C04h
  1007                                  RE_OUT_APP equ	RETRABASE+130	; 0C08h
  1008                                  RE_OUTSTR equ	RETRABASE+131	; 0C09h
  1009                                  INITFLAG  equ	RETRABASE+211	; 0C59h	
  1010                                  PIPEFLAG  equ	RETRABASE+212	; 0C5Ah
  1011                                  PIPEFILES equ	RETRABASE+213	; 0C5Bh
  1012                                  PIPE1	  equ	RETRABASE+214	; 0C5Ch	
  1013                                  PIPE2	  equ	RETRABASE+230	; 0C6Ch
  1014                                  PIPEPTR	  equ	RETRABASE+246	; 0C7Ch
  1015                                  PIPESTR	  equ	RETRABASE+248	; 0C7Eh
  1016                                  INPIPEPTR equ	RETRABASE+377	; 0CFFh
  1017                                  OUTPIPEPTR equ	RETRABASE+379	; 0D01h
  1018                                  ENVIRSEG  equ	RETRABASE+381	; 0D03h
  1019                                  EXEC_BLOCK equ	RETRABASE+381 	; 0D03h  ; ENVIRSEG
  1020                                  LTPA	  equ	RETRABASE+399	; 0D15h
  1021                                  RES_TPA	  equ	RETRABASE+413	; 0D23h
  1022                                  
  1023                                  ;=============================================================================
  1024                                  					
  1025                                  ; (command3.s -> offset TRANGOUP)
  1026                                  
  1027                                  TRANGROUP:
  1028                                  
  1029                                  ; ----------------------------------------------------------------------------
  1030                                  ; START OF TRANSIENT PORTION
  1031                                  ; ----------------------------------------------------------------------------
  1032                                  ; SEGMENT - TRANSCODE
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; 13/10/2018 - Retro DOS v3.0
  1035                                  
  1036                                  ;[BITS 16]
  1037                                  ;[ORG 0]
  1038 00000000 00<rept>                		times 256 db 0
  1039                                  
  1040                                  ;============================================================================
  1041                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1042                                  ;============================================================================
  1043                                  ; 12/10/2018 - Retro DOS v3.0
  1044                                  
  1045                                  ;[ORG 100h]
  1046                                  
  1047                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1048                                  
  1049                                  ; ---------------------------------------------------------------------------
  1050                                  
  1051                                  SETDRV:					; Allow for 100H parameter area
  1052 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1053 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1054                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1055                                  				; Return: AL = number of logical drives
  1056                                  
  1057                                  ; ---------------------------------------------------------------------------
  1058                                  
  1059                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1060                                  ; No registers (CS:IP) no flags, nothing.
  1061                                  
  1062                                  TCOMMAND:
  1063 00000104 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  1064 00000109 B8FFFF                  		mov	ax,-1
  1065 0000010C 8706F50B                		xchg	ax,word [VERVAL]
  1066 00000110 83F8FF                  		cmp	ax,-1
  1067 00000113 7404                    		jz	short NOSETVER2
  1068 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1069 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1070                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1071                                  NOSETVER2:
  1072 00000119 2EFF1E[6F42]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1073 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1074 00000120 833EF30BFF              		cmp	word [SINGLECOM],-1
  1075 00000125 7505                    		jnz	short COMMAND
  1076                                  _$EXITPREP:
  1077 00000127 0E                      		push	cs
  1078 00000128 1F                      		pop	ds
  1079 00000129 E92415                  		jmp	_$EXIT		; Have finished the single command
  1080                                  
  1081                                  ; ---------------------------------------------------------------------------
  1082                                  ;
  1083                                  ; Main entry point from resident portion.
  1084                                  ;
  1085                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1086                                  ;   just beginning the processing of another command.
  1087                                  ;
  1088                                  ; ---------------------------------------------------------------------------
  1089                                  
  1090                                  ; We are not always sure of the state of the world at this time. We presume
  1091                                  ; worst case and initialize the relevant registers: segments and stack.
  1092                                  
  1093                                  COMMAND:
  1094 0000012C FC                      		cld
  1095 0000012D 8CC8                    		mov	ax,cs
  1096 0000012F FA                      		cli
  1097 00000130 8ED0                    		mov	ss,ax
  1098                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1099 00000132 BC[F84C]                		mov	sp,STACK
  1100 00000135 FB                      		sti
  1101                                  		
  1102 00000136 8EC0                    		MOV	ES,AX
  1103                                  		
  1104                                  		; MSDOS 6.0
  1105                                  		;MOV	DS,AX		;AN000; set DS to transient
  1106                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1107                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1108                                  		;mov	append_exec,0	;AN041; set internal append state off
  1109                                  
  1110                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1111 00000138 368E1E[7142]            		mov	ds,[ss:RESSEG]
  1112 0000013D 36C606[4D40]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1113 00000143 36C606[D040]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1114                                  
  1115                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1116                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1117                                  ; I guess not:  the only circumstances in which we reload the command processor
  1118                                  ; is after a transient program execution. In this case, we let the current
  1119                                  ; directory lie where it may.
  1120                                  
  1121 00000149 09ED                    		or	bp,bp		; See if just read
  1122 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1123 0000014D 36C706[4E40]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1124 00000154 EB17                    		jmp	short NOSETBUF
  1125                                  TESTRDIR:
  1126 00000156 803EF10B00              		cmp	byte [RESTDIR],0
  1127 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1128 0000015D 1E                      		push	ds
  1129                                  
  1130                                  ; We have an unusual situation to handle. The user *may* have changed his
  1131                                  ; directory as a result of an internal command that got aborted. Restoring it
  1132                                  ; twice may not help us: the problem may never go away. We just attempt it
  1133                                  ; once and give up.
  1134                                  
  1135 0000015E C606F10B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1136                                  
  1137                                  		; Restore users directory
  1138 00000163 0E                      		push	cs
  1139 00000164 1F                      		pop	ds
  1140 00000165 BA[5341]                		mov	dx,USERDIR1
  1141 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1142 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1143                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1144 0000016C 1F                      		pop	ds
  1145                                  NOSETBUF:
  1146 0000016D 803E5B0C00              		cmp	byte [PIPEFILES],0
  1147 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1148 00000174 803E5A0C00              		cmp	byte [PIPEFLAG],0
  1149 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1150 0000017B E89A1D                  		call	PIPEDEL
  1151                                  NOPCLOSE:
  1152                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1153 0000017E C606E90B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1154 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1155 00000185 8ED8                    		mov	ds,ax
  1156 00000187 50                      		push	ax
  1157 00000188 BA[F84C]                		mov	dx,INTERNATVARS
  1158 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1159 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1160                                  				; get current-country info
  1161                                  				; DS:DX	-> buffer for returned info
  1162 00000190 58                      		pop	ax
  1163 00000191 2B06[7342]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1164 00000195 53                      		push	bx
  1165 00000196 BB1000                  		mov	bx,16
  1166 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1167 0000019B 5B                      		pop	bx
  1168 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1169 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1170 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1171                                  SAVSIZ:
  1172                                  
  1173                                  ; AX is the number of bytes free in the buffer between the resident and the
  1174                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1175                                  
  1176 000001A3 3D0002                  		cmp	ax,512
  1177 000001A6 7603                    		jbe	short GOTSIZE
  1178                                  		;and	ax,~1FFh
  1179 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1180                                  GOTSIZE:
  1181 000001AB A3[9242]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1182 000001AE 8E1E[7142]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1183                                  
  1184 000001B2 F606ED0B01              		test	byte [ECHOFLAG],1 
  1185 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1186 000001B9 E83B1D                  		call	SINGLETEST
  1187 000001BC 7219                    		jb	short GETCOM
  1188 000001BE F6065A0CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1189 000001C3 7512                    		jnz	short GETCOM
  1190                                  					; G  Don't print prompt in FOR
  1191 000001C5 F606F90BFF              		test	byte [FORFLAG],0FFh ; -1
  1192 000001CA 750B                    		jnz	short GETCOM
  1193                                  					; G  Don't print prompt if in batch
  1194 000001CC F706970BFFFF            		test	word [BATCH],0FFFFh ; -1
  1195 000001D2 7503                    		jnz	short GETCOM
  1196 000001D4 E89717                  		call	CRLF2
  1197                                  GETCOM:
  1198 000001D7 C606FE0B00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1199 000001DC C606FF0B00              		mov	byte [CALL_BATCH_FLAG],0
  1200 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1201 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1202 000001E5 36A2[8542]              		mov	[ss:CURDRV],al
  1203 000001E9 F6065A0CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1204 000001EE 7403                    		jz	short NOPIPE
  1205 000001F0 E9C71D                  		jmp	PIPEPROC	; Continue the pipeline
  1206                                  NOPIPE:
  1207 000001F3 F606ED0B01              		test	byte [ECHOFLAG],1
  1208 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1209 000001FA E8FA1C                  		call	SINGLETEST
  1210 000001FD 7212                    		jb	short NOPDRV
  1211 000001FF F606F90BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1212 00000204 750B                    		jnz	short NOPDRV
  1213 00000206 F706970BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1214 0000020C 750D                    		jnz	short TESTFORBAT
  1215 0000020E E87911                  		call	PRINT_PROMPT	; Prompt the user
  1216                                  NOPDRV:
  1217 00000211 F606F90BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1218 00000216 7403                    		jz	short TESTFORBAT
  1219 00000218 E9FE09                  		jmp	FORPROC		; Continue the FOR
  1220                                  
  1221                                  TESTFORBAT:
  1222 0000021B 36C606[1C42]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1223 00000221 C606090C00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1224 00000226 C606080C00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1225 0000022B C606F80B00              		mov	byte [IFFLAG],0	; no more ifs...
  1226 00000230 F706970BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1227 00000236 7429                    		jz	short ISNOBAT
  1228                                  
  1229                                  		; MSDOS 6.0
  1230                                  
  1231                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1232                                  
  1233                                  		;push	es			;AN000; save ES
  1234                                  		;push	ds			;AN000; save DS
  1235                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1236                                  		;mov	es,[batch]		;AN000; get batch segment
  1237                                  		;mov	di,batfile		;AN000; get batch file name
  1238                                  		;push	cs			;AN000; get local segment to DS
  1239                                  		;pop	ds			;AN000;
  1240                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1241                                  		;int	2fh			;AN000; call the shell
  1242                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1243                                  		;pop	ds			;AN000; restore DS
  1244                                  		;pop	es			;AN000; restore ES
  1245                                  		;jz	jdocom1 		;AN000; yes - go process command
  1246                                  
  1247                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1248 00000238 1E                      		push	ds
  1249 00000239 E8BC02                  		call	READBAT			; Continue BATCH
  1250 0000023C 1F                      		pop	ds
  1251 0000023D C606020C00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1252 00000242 F706970BFFFF            		test	word [BATCH],0FFFFh
  1253 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1254 0000024A 8B1E000C                		mov	bx,word [NEXT_BATCH]
  1255 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1256 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1257 00000253 891E970B                		mov	word [BATCH],bx		;G get segment of next batch file
  1258 00000257 C706000C0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1259                                  JDOCOM1:
  1260 0000025D 0E                      		push	cs
  1261 0000025E 1F                      		pop	ds
  1262 0000025F EB4C                    		jmp	short DOCOM1
  1263                                  
  1264 00000261 833EF30B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1265 00000266 741C                    		jz	short REGCOM
  1266                                  		;MOV	SI,[SEMIPERMCOM] ;  MSDOS 6.0
  1267 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1268 0000026B 8736F30B                		xchg	si,word [SINGLECOM]
  1269 0000026F BF[D240]                		mov	di,COMBUF+2
  1270 00000272 31C9                    		xor	cx,cx
  1271                                  SINGLELOOP:
  1272 00000274 AC                      		lodsb
  1273 00000275 AA                      		stosb
  1274 00000276 41                      		inc	cx
  1275 00000277 3C0D                    		cmp	al,0Dh
  1276 00000279 75F9                    		jnz	short SINGLELOOP
  1277 0000027B 49                      		dec	cx
  1278 0000027C 0E                      		push	cs
  1279 0000027D 1F                      		pop	ds
  1280 0000027E 880E[D140]              		mov	[COMBUF+1],cl
  1281                                  
  1282                                  ; do NOT issue a trailing CRLF...
  1283                                  
  1284 00000282 EB29                    		jmp	short DOCOM1
  1285                                  
  1286                                  		;nop
  1287                                  
  1288                                  ; We have a normal command.  
  1289                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1290                                  ; sometimes they aren't. At this point, we automatically close all spool
  1291                                  ; files and turn on truncation mode.
  1292                                  
  1293                                  REGCOM:
  1294                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1295                                  		;mov	ax,5D09h
  1296 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1297 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1299                                  		;mov	ax,5D08h
  1300 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1301 0000028C B201                    		mov	dl,1
  1302 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1303                                  				; DL = 00h redirected output is	combined
  1304                                  				;      01h redirected output placed in separate	jobs
  1305                                  				; start	new print job now
  1306 00000290 0E                      		push	cs
  1307 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1308 00000292 BA[4D40]                		mov	dx,UCOMBUF
  1309                                  
  1310                                  		; MSDOS 6.0
  1311                                  ;	Try to read interactive command line via DOSKey.
  1312                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1313                                  
  1314                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1315                                  		;int	2fh
  1316                                  		;or	ax,ax
  1317                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1318                                  
  1319                                  		;mov	ah,0Ah
  1320 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1321 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1322                                  				; DS:DX	-> buffer
  1323                                  ;GOTCOM:
  1324 00000299 8A0E[4D40]              		mov	cl,[UCOMBUF]
  1325 0000029D 30ED                    		xor	ch,ch
  1326 0000029F 83C103                  		add	cx,3
  1327 000002A2 BE[4D40]                		mov	si,UCOMBUF
  1328 000002A5 BF[D040]                		mov	di,COMBUF
  1329 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1330                                  DOCOM:
  1331 000002AA E8C116                  		call	CRLF2
  1332                                  DOCOM1:
  1333 000002AD E88119                  		call	PRESCAN		; Cook the input buffer
  1334 000002B0 7406                    		jz	short NOPIPEPROC
  1335 000002B2 E9AD1C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1336                                  
  1337                                  NULLCOMJ:
  1338 000002B5 E9FA00                  		jmp	NULLCOM
  1339                                  
  1340                                  NOPIPEPROC:
  1341 000002B8 E8F520                  		call	PARSELINE
  1342 000002BB 730B                    		jnb	short OKPARSE	; user error?  or maybe we goofed?
  1343                                  BADPARSE:
  1344 000002BD 0E                      		push	cs
  1345 000002BE 1F                      		pop	ds
  1346 000002BF BA[BB37]                		mov	dx,BADNAMPTR
  1347 000002C2 E80532                  		call	STD_EPRINTF
  1348 000002C5 E93CFE                  		jmp	TCOMMAND
  1349                                  
  1350                                  OKPARSE:
  1351                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1352 000002C8 F606[AB45]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1353 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1354                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1355 000002CF 833E[6948]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1356 000002D4 74DF                    		jz	short NULLCOMJ
  1357                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1358 000002D6 833E[AE45]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1359 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1360                                  
  1361 000002DD BE[D240]                		mov	si,COMBUF+2
  1362 000002E0 BF[EB42]                		mov	di,IDLEN
  1363                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1364                                  					; Make FCB with blank scan-off
  1365 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1366                                  		;mov	ax,2901h
  1367 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1368                                  				; DS:SI	-> string to parse
  1369                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1370                                  				; AL = bit mask	to control parsing
  1371                                  		;mov	bx,[ARG_ARGV]
  1372 000002E8 8B1E[A945]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1373 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1374 000002F0 751C                    		jne	short DRVGD	; no, use default of zero...
  1375 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1376                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1377                                  		;and	dl,~20h
  1378 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1379 000002F7 2A16[F03E]              		sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1380 000002FB 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1381 000002FD 740C                    		jz	short DRVBADJ	; It was invalid.
  1382                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1383 000002FF 8B3E[AC45]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1384 00000303 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1385 00000306 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1386 00000308 E9F5FD                  		jmp	SETDRV		; and set drive to new drive spec
  1387                                  DRVBADJ:
  1388 0000030B E9CC17                  		jmp	DRVBAD
  1389                                  DRVGD:
  1390 0000030E 8A05                    		mov	al,[di]
  1391 00000310 A2[9142]                		mov	[SPECDRV],al
  1392 00000313 B020                    		mov	al,' '
  1393 00000315 B90900                  		mov	cx,9
  1394 00000318 47                      		inc	di
  1395 00000319 F2AE                    		repne scasb		; Count number of letters in command name
  1396 0000031B B008                    		mov	al,8
  1397 0000031D 28C8                    		sub	al,cl
  1398 0000031F A2[EB42]                		mov	[IDLEN],al	; IDLEN is truly the length
  1399 00000322 BF8100                  		mov	di,81h
  1400 00000325 56                      		push	si
  1401 00000326 BE[D240]                		mov	si,COMBUF+2	; Skip over all leading delims
  1402 00000329 E84F16                  		call	SCANOFF
  1403                                  
  1404                                  		; MSDOS 6.0
  1405                                  ;SR;
  1406                                  ; We are going to skip over the first char always. The logic is that the
  1407                                  ;command tail can never start from the first character. The code below is 
  1408                                  ;trying to figure out the command tail and copy it to the command line 
  1409                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1410                                  ;character and the user given command line is a full 128 bytes, we try to
  1411                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1412                                  ;char overwrites the code and leads to a crash on future commands.
  1413                                  ;
  1414                                  		;inc	si ;  MSDOS 6.0
  1415                                  DO_SKIPCOM:
  1416 0000032C AC                      		lodsb			; move command line pointer over
  1417 0000032D E85316                  		call	DELIM		; pathname -- have to do it ourselves
  1418 00000330 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1419 00000332 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1420 00000334 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1421 00000336 3A06[7542]              		cmp	al,[SWITCHAR]	; specified command string
  1422 0000033A 75F0                    		jnz	short DO_SKIPCOM 
  1423                                  DO_SKIPPED:
  1424 0000033C 4E                      		dec	si
  1425 0000033D 31C9                    		xor	cx,cx
  1426                                  COMTAIL:
  1427 0000033F AC                      		lodsb
  1428 00000340 AA                      		stosb			; Move command tail to 80h
  1429 00000341 3C0D                    		cmp	al,0Dh
  1430 00000343 E0FA                    		loopne	COMTAIL
  1431 00000345 4F                      		dec	di
  1432 00000346 89FD                    		mov	bp,di
  1433 00000348 F6D1                    		not	cl
  1434 0000034A 880E8000                		mov	[80h],cl
  1435 0000034E 5E                      		pop	si
  1436                                  ;-----
  1437                                  ; Some of these comments are sadly at odds with this brave new code.
  1438                                  ;-----
  1439                                  ; If the command has 0 parameters must check here for
  1440                                  ; any switches that might be present.
  1441                                  ; SI -> first character after the command.
  1442                                  
  1443                                  		;mov	di, arg.argv[0].argsw_word
  1444                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1445 0000034F 8B3E[B045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1446 00000353 893E[8842]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1447                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1448                                  					; s = argv[1];
  1449                                  		;mov	si,[ARGV1_ARGPOINTER]
  1450 00000357 8B36[B445]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1451 0000035B 09F6                    		or	si,si		;   if (s == NULL)
  1452 0000035D 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1453 0000035F 89EE                    		mov	si,bp
  1454                                  DOPARSE:
  1455 00000361 BF5C00                  		mov	di,FCB ; 5Ch
  1456                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1457                                  		;mov	ax,2901h
  1458 00000364 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1459 00000367 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1460                                  				; DS:SI	-> string to parse
  1461                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1462                                  				; AL = bit mask	to control parsing
  1463 00000369 A2[8642]                		mov	[PARM1],al	; Save result of parse
  1464                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1465                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1466 0000036C 8B3E[BB45]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1467 00000370 893E[8A42]              		mov	[ARG1S],di
  1468                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1469                                  					; s = argv[2];
  1470                                  		;mov	si,[ARGV2_ARGPOINTER]
  1471 00000374 8B36[BF45]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1472 00000378 09F6                    		or	si,si		;   if (s == NULL)
  1473 0000037A 7502                    		jnz	short DOPARSE2
  1474 0000037C 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1475                                  DOPARSE2:			
  1476 0000037E BF6C00                  		mov	di,FCB+10H ; 6Ch
  1477                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1478                                  		;mov	ax,2901h
  1479 00000381 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1480 00000384 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1481                                  				; DS:SI	-> string to parse
  1482                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1483                                  				; AL = bit mask	to control parsing
  1484 00000386 A2[8742]                		mov	[PARM2],al	; Save result
  1485                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1486                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1487 00000389 8B3E[C645]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1488 0000038D 893E[8C42]              		mov	[ARG2S],di
  1489                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1490                                  		;mov	di,arg.argv[0].argsw_word
  1491 00000391 8B3E[B045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1492 00000395 F7D7                    		not	di		; ARGTS doesn't include the flags
  1493                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1494                                  		;and	di,arg.argswinfo	
  1495 00000397 233E[6B48]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1496 0000039B 893E[8E42]              		mov	[ARGTS],di
  1497                                  
  1498 0000039F A0[EB42]                		mov	al,[IDLEN]
  1499 000003A2 8A16[9142]              		mov	dl,[SPECDRV]
  1500 000003A6 08D2                    		or	dl,dl		; if a drive was specified...
  1501 000003A8 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1502 000003AA FEC8                    		dec	al		; (I don't know why -- old code did it)
  1503 000003AC E93417                  		jmp	FNDCOM		; otherwise, check internal com table
  1504                                  EXTERNALJ1:
  1505 000003AF E9E217                  		jmp	EXTERNAL
  1506                                  NULLCOM:
  1507 000003B2 8E1E[7142]              		mov	ds,[RESSEG]
  1508 000003B6 F706970BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1509 000003BC 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1510                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1511 000003BE C606020C01              		mov	byte [NULLFLAG],nullcommand ; 1
  1512                                  NOSETFLAG:
  1513 000003C3 833EF30BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1514 000003C8 7403                    		jz	short EXITJ
  1515 000003CA E90AFE                  		jmp	GETCOM
  1516                                  EXITJ:
  1517 000003CD E957FD                  		jmp	_$EXITPREP
  1518                                  
  1519                                  ;============================================================================
  1520                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1521                                  ;============================================================================
  1522                                  ; 12/10/2018 - Retro DOS v3.0
  1523                                  
  1524                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1525                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1526                                  ;   there is a header that describes a block of rom program.  This header
  1527                                  ;   contains information needed to initialize a module and to provide PCDOS
  1528                                  ;   with a set of reserved names for execution.
  1529                                  ;
  1530                                  ;   This header has the following format:
  1531                                  ;
  1532                                  ;   rom_header	STRUC
  1533                                  ;	Signature1  DB	55h
  1534                                  ;	Signature2  DB	AAh
  1535                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1536                                  ;	init_jmp    DB	3 dup (?)
  1537                                  ;	name_list   name_struc <>
  1538                                  ;   rom_header	ENDS
  1539                                  ;
  1540                                  ;   name_struc	STRUC
  1541                                  ;	name_len    DB	?
  1542                                  ;	name_text   DB	? DUP (?)
  1543                                  ;	name_jmp    DB	3 DUP (?)
  1544                                  ;   name_struc	ENDS
  1545                                  ;
  1546                                  ;   The name list is a list of names that are reserved by a particular section
  1547                                  ;   of a module.  This list of names is terminated by a null name (length
  1548                                  ;   is zero).
  1549                                  ;
  1550                                  ;   Consider now, the PCDOS action when a user enters a command:
  1551                                  ;
  1552                                  ;	COMMAND.COM has control.
  1553                                  ;	o   If location FFFFEh has FDh then
  1554                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1555                                  ;		    by AAh, stop scan if we get above or = F0000H
  1556                                  ;	o	When we've found one, compare the name entered by the user
  1557                                  ;		    with the one found in the rom.  If we have a match, then
  1558                                  ;		    set up the environment for execution and do a long jump
  1559                                  ;		    to the near jump after the found name.
  1560                                  ;	o	If no more names in the list, then continue scanning the module
  1561                                  ;		    for more 55h followed by AAh.
  1562                                  ;	o   We get to this point only if there is no matching name in the
  1563                                  ;		rom.  We now look on disk for the command.
  1564                                  ;
  1565                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1566                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1567                                  ;   want to be invisible to the DOS should not have any names in their lists
  1568                                  ;   (i.e. they have a single null name).
  1569                                  ;
  1570                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1571                                  ;   Clearly this version will be available on disk.  How does a user actually
  1572                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1573                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1574                                  ;   solution:
  1575                                  ;
  1576                                  ;   o	Keep things consistent and force the user to have his software named
  1577                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1578                                  
  1579                                  struc ROM_HEADER
  1580 00000000 <res 00000001>              .signature1: resb 1
  1581 00000001 <res 00000001>              .signature2: resb 1
  1582 00000002 <res 00000001>              .rom_length: resb 1
  1583 00000003 <res 00000003>              .init_jmp:	 resb 3
  1584 00000006 <res 00000001>              .name_list:	 resb 1
  1585                                      .size:
  1586                                  endstruc
  1587                                  
  1588                                  struc NAME_STRUC
  1589 00000000 <res 00000001>              .name_len:	resb 1
  1590 00000001 <res 00000001>              .name_text:	resb 1
  1591 00000002 <res 00000003>              .name_jmp:	resb 3
  1592                                      .size:	
  1593                                  endstruc
  1594                                  
  1595                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1596                                  
  1597                                  ; =============== S U B	R O U T	I N E =======================================
  1598                                  
  1599                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1600                                  
  1601                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1602                                  
  1603                                  ROM_SCAN:
  1604 000003D0 06                      		push	es
  1605 000003D1 56                      		push	si
  1606 000003D2 57                      		push	di
  1607 000003D3 51                      		push	cx
  1608 000003D4 50                      		push	ax
  1609 000003D5 53                      		push	bx
  1610                                  
  1611                                  		; check for PC Jr signature in rom
  1612                                  
  1613 000003D6 B800F0                  		mov	ax,0F000h
  1614 000003D9 8EC0                    		mov	es,ax
  1615 000003DB 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1616 000003E1 7408                    		je	short SCAN_IT
  1617                                  NO_ROM:
  1618 000003E3 F8                      		clc
  1619                                  ROM_RET:
  1620 000003E4 5B                      		pop	bx
  1621 000003E5 58                      		pop	ax
  1622 000003E6 59                      		pop	cx
  1623 000003E7 5F                      		pop	di
  1624 000003E8 5E                      		pop	si
  1625 000003E9 07                      		pop	es
  1626 000003EA C3                      		retn
  1627                                  
  1628                                  SCAN_IT:	; start scanning at C000h
  1629                                  
  1630 000003EB B800C0                  		mov	ax,0C000h
  1631                                  SCAN_ONE:
  1632 000003EE 8EC0                    		mov	es,ax
  1633 000003F0 31FF                    		xor	di,di
  1634                                  
  1635                                  SCAN_MODULE:	; check for a valid header
  1636                                  
  1637 000003F2 26813D55AA              		cmp	word [es:di],0AA55h
  1638 000003F7 740A                    		jz	short SCAN_LIST
  1639 000003F9 058000                  		add	ax,80h
  1640                                  SCAN_END:
  1641 000003FC 3D00F0                  		cmp	ax,0F000h
  1642 000003FF 72ED                    		jb	short SCAN_ONE
  1643 00000401 EBE0                    		jmp	short NO_ROM
  1644                                  
  1645                                  		; trundle down list of names
  1646                                  SCAN_LIST:
  1647                                  		;mov	bl,[es:di+2]
  1648                                  					; number of 512-byte jobbers
  1649 00000403 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1650 00000407 30FF                    		xor	bh,bh		; nothing in the high byte
  1651 00000409 D1E3                    		shl	bx,1
  1652 0000040B D1E3                    		shl	bx,1		; number of paragraphs
  1653 0000040D 83C37F                  		add	bx,7Fh
  1654 00000410 83E380                  		and	bx,0FF80h	; round to 2k	
  1655                                  		;mov	di,6
  1656 00000413 BF0200                  		mov	di,ROM_HEADER.rom_length
  1657                                  
  1658                                  		;nop
  1659                                  SCAN_NAME:
  1660 00000416 268A0D                  		mov	cl,[es:di]	; length of name
  1661 00000419 47                      		inc	di		; point to name
  1662 0000041A 30ED                    		xor	ch,ch
  1663 0000041C 09C9                    		or	cx,cx		; zero length name
  1664 0000041E 7504                    		jnz	short SCAN_TEST	; nope... compare
  1665 00000420 01D8                    		add	ax,bx		; yep, skip to next block
  1666 00000422 EBD8                    		jmp	short SCAN_END
  1667                                  
  1668                                  SCAN_TEST:	; compare a single name
  1669                                  
  1670 00000424 89D6                    		mov	si,dx
  1671 00000426 46                      		inc	si
  1672 00000427 F3A6                    		repe cmpsb		 ; compare name
  1673 00000429 7407                    		jz	short SCAN_FOUND ; success!
  1674                                  SCAN_NEXT:
  1675 0000042B 01CF                    		add	di,cx		; failure, next name piece
  1676 0000042D 83C703                  		add	di,3
  1677 00000430 EBE4                    		jmp	short SCAN_NAME
  1678                                  
  1679                                  SCAN_FOUND:	; found a name. save entry location
  1680                                  
  1681 00000432 803C3F                  		cmp	byte [si],'?'
  1682 00000435 7405                    		jz	short SCAN_SAVE
  1683 00000437 803C20                  		cmp	byte [si],' '
  1684 0000043A 75EF                    		jnz	short SCAN_NEXT
  1685                                  SCAN_SAVE:
  1686 0000043C 2E8C06[6A44]            		mov	[cs:ROM_CS],es
  1687 00000441 2E893E[6844]            		mov	[cs:ROM_IP],di
  1688 00000446 F9                      		stc
  1689 00000447 EB9B                    		jmp	short ROM_RET
  1690                                  
  1691                                  ; ---------------------------------------------------------------------------
  1692                                  
  1693                                  ; execute a rom-placed body of code. allocate largest block
  1694                                  
  1695                                  ROM_EXEC:
  1696 00000449 BBFFFF                  		mov	bx,0FFFFh
  1697 0000044C B448                    		mov	ah,ALLOC ; 48h
  1698 0000044E CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1699                                  				; BX = number of 16-byte paragraphs desired
  1700 00000450 B448                    		mov	ah,ALLOC ; 48h
  1701 00000452 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1702                                  				; BX = number of 16-byte paragraphs desired
  1703 00000454 53                      		push	bx
  1704 00000455 50                      		push	ax
  1705                                  
  1706                                  		; set terminate addresses
  1707                                  
  1708                                  		;mov	ax,2522h
  1709                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1710 00000456 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1711 00000459 1E                      		push	ds
  1712 0000045A 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  1713                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1714                                  		;mov	dx,131h ; MSDOS 3.3
  1715 0000045F BA3101                  		mov	dx,EXEC_WAIT
  1716 00000462 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1717                                  				; AL = interrupt number
  1718                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1719 00000464 8CDA                    		mov	dx,ds
  1720 00000466 8EC2                    		mov	es,dx
  1721 00000468 1F                      		pop	ds
  1722                                  		
  1723                                  		; and create program header and dup all jfn's
  1724                                  
  1725 00000469 5A                      		pop	dx
  1726 0000046A B455                    		mov	ah,DUP_PDB ; 55h
  1727 0000046C CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1728                                  				; DX = segment number at which to set up PSP
  1729                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1730                                  		
  1731                                  		; set up dma address
  1732                                  
  1733 0000046E 8EDA                    		mov	ds,dx
  1734 00000470 BA8000                  		mov	dx,80h
  1735 00000473 B41A                    		mov	ah,SET_DMA ; 1Ah
  1736 00000475 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1737                                  				; DS:DX	-> disk	transfer buffer
  1738                                  
  1739                                  		; copy in environment info
  1740                                  
  1741 00000477 26A1030D                		mov	ax,word [es:ENVIRSEG]
  1742 0000047B A32C00                  		mov	[PDB.ENVIRON],	ax
  1743                                  
  1744                                  		; set up correct size of block
  1745                                  
  1746 0000047E 5B                      		pop	bx		; BX has size, DS has segment
  1747 0000047F 8CDA                    		mov	dx,ds
  1748 00000481 01DA                    		add	dx,bx
  1749                                  		;mov	[2],dx
  1750 00000483 89160200                		mov	word [PDB.BLOCK_LEN],dx
  1751                                  
  1752                                  		; change ownership of block
  1753                                  
  1754 00000487 8CDA                    		mov	dx,ds
  1755 00000489 4A                      		dec	dx
  1756 0000048A 8EDA                    		mov	ds,dx
  1757 0000048C 42                      		inc	dx	
  1758                                  		;mov	[1],dx
  1759 0000048D 89160100                		mov	word [ARENA.owner],dx
  1760 00000491 8EDA                    		mov	ds,dx
  1761                                  
  1762                                  		; set up correct stack
  1763                                  
  1764 00000493 81FB0010                		cmp	bx,1000h
  1765 00000497 7202                    		jb	short GOT_STACK
  1766 00000499 31DB                    		xor	bx,bx
  1767                                  GOT_STACK:
  1768 0000049B B104                    		mov	cl,4
  1769 0000049D D3E3                    		shl	bx,cl
  1770 0000049F 8CDA                    		mov	dx,ds
  1771 000004A1 8ED2                    		mov	ss,dx
  1772 000004A3 89DC                    		mov	sp,bx
  1773 000004A5 31C0                    		xor	ax,ax
  1774 000004A7 50                      		push	ax
  1775                                  
  1776                                  		; set up initial registers and go to the guy
  1777                                  
  1778 000004A8 F7D0                    		not	ax
  1779 000004AA 2EFF36[6A44]            		push	word [cs:ROM_CS]
  1780 000004AF 2EFF36[6844]            		push	word [cs:ROM_IP]
  1781 000004B4 8EC2                    		mov	es,dx
  1782 000004B6 CB                      		retf	; far return
  1783                                  
  1784                                  ;============================================================================
  1785                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1786                                  ;============================================================================
  1787                                  ; 12/10/2018 - Retro DOS v3.0
  1788                                  
  1789                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1790                                  
  1791                                  ; =============== S U B	R O U T	I N E =======================================
  1792                                  
  1793                                  ;Break	<PromptBat - Open or wait for batch file>
  1794                                  
  1795                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1796                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1797                                  ; file. Leave segment registers alone.
  1798                                  
  1799                                  PROMPTBAT:
  1800 000004B7 E8EF06                  		call	BATOPEN
  1801 000004BA 7201                    		jc	short PROMPTBAT1
  1802 000004BC C3                      		retn
  1803                                  PROMPTBAT1:
  1804                                  		; MSDOS 6.0 COMMAND.COM
  1805                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1806                                  		;jz	Bat_Remcheck		;AN022;
  1807                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1808                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1809                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1810                                  		;jmp	short BatDie		;AN022;
  1811                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1812                                  		;call	[RCH_ADDR]		; DX has error number
  1813                                  		;jz	AskForBat		; Media is removable
  1814                                  
  1815                                  		; MSDOS 3.3 COMMAND.COM
  1816 000004BD 81FA[1D38]              		cmp	dx,ACCDENPTR
  1817 000004C1 7413                    		jz	short BATDIE
  1818                                  
  1819                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1820                                  BAT_REMCHECK:				; Go see if media is removable
  1821 000004C3 2EFF1E[7B42]            		call	far [cs:RCH_ADDR] ; DX has error number
  1822 000004C8 7417                    		jz	short ASKFORBAT	; Media is removable
  1823                                  
  1824                                  ; The media is not changeable. Turn everything off.
  1825                                  
  1826 000004CA E8CE09                  		call	FOROFF
  1827 000004CD E8BE1E                  		call	PIPEOFF
  1828 000004D0 A2F80B                  		mov	byte [IFFLAG],al ; No If in progress.	
  1829 000004D3 BA[5E37]                		mov	dx,BADPATHPTR
  1830                                  BATDIE:
  1831 000004D6 E84F03                  		call	BATCHOFF
  1832 000004D9 0E                      		push	cs
  1833 000004DA 1F                      		pop	ds
  1834                                  		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
  1835 000004DB E8F52F                  		call	STD_PRINTF	; MSDOS 3.3
  1836                                  
  1837                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1838                                  
  1839 000004DE E923FC                  		jmp	TCOMMAND
  1840                                  
  1841                                  ; Ask the user to reinsert the batch file
  1842                                  
  1843                                  ASKFORBAT:
  1844 000004E1 1E                      		push	ds
  1845 000004E2 0E                      		push	cs
  1846 000004E3 1F                      		pop	ds
  1847                                  
  1848                                  		; MSDOS 6.0
  1849                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1850                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1851                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1852                                  		;;invoke std_eprintf		;AN000; get second part of message
  1853                                  						;AN000; print it to stderr
  1854                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1855 000004E4 E8E32F                  		call	STD_EPRINTF
  1856 000004E7 E80300                  		call	GETKEYSTROKE
  1857 000004EA 1F                      		pop	ds
  1858 000004EB EBCA                    		jmp	short PROMPTBAT
  1859                                  
  1860                                  
  1861                                  ; MSDOS 6.0
  1862                                  ;****************************************************************
  1863                                  ;*
  1864                                  ;* ROUTINE:	Output_batch_name
  1865                                  ;*
  1866                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1867                                  ;*
  1868                                  ;* INPUT:	DX - extended error number
  1869                                  ;*
  1870                                  ;* OUTPUT:	Ready to call print routine
  1871                                  ;*
  1872                                  ;****************************************************************
  1873                                  ;
  1874                                  ;public	output_batch_name			;AN022;
  1875                                  ;
  1876                                  ;Output_batch_name    proc near			;AN022;
  1877                                  ;
  1878                                  ;		push	ds			;AN022; save resident segment
  1879                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1880                                  ;	assume	DS:nothing			;AN022;
  1881                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1882                                  ;		invoke	dstrlen 		;AN022; get length of string
  1883                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1884                                  ;		rep	movsb			;AN022; move the name
  1885                                  ;
  1886                                  ;		push	cs			;AN022; get local segment
  1887                                  ;		pop	ds			;AN022;
  1888                                  ;	assume	DS:trangroup			;AN022;
  1889                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1890                                  ;		mov	msg_disp_class,ext_msg_class
  1891                                  ;						;AN022; set up extended error msg class
  1892                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1893                                  ;						;AN022; get extended message pointer
  1894                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1895                                  ;						;AN022; point to substitution
  1896                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1897                                  ;		pop	ds			;AN022; restore data segment
  1898                                  ;
  1899                                  ;		ret				;AN022; return
  1900                                  ;
  1901                                  ;Output_batch_name    endp			;AN022;
  1902                                  
  1903                                  
  1904                                  ; =============== S U B	R O U T	I N E =======================================
  1905                                  
  1906                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1907                                  
  1908                                  ; Read the next keystroke. Since there may be several characters in the queue
  1909                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1910                                  ; AFTER waiting.
  1911                                  
  1912                                  GETKEYSTROKE:
  1913                                  		; MSDOS 3.3
  1914                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1915                                  		;mov	ax,0C08h
  1916 000004ED B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1917 000004F0 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1918                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1919                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1920                                  		;mov	ax,0C00h
  1921 000004F2 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1922 000004F5 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1923                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1924 000004F7 C3                      		retn
  1925                                  
  1926                                  		; MSDOS 6.0
  1927                                  		;PUSH	DX				;AN000;  3/3/KK
  1928                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1929                                  		;INT	21h				;AN000;  3/3/KK
  1930                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1931                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1932                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1933                                  		;INT	21h				;AN000;  3/3/KK
  1934                                  		;
  1935                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1936                                  		;INT	21h		; Get character with KB buffer flush
  1937                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1938                                  		;INT	21h
  1939                                  		;
  1940                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1941                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1942                                  		;INT	21h				;AN000;  3/3/KK
  1943                                  		;POP	DX				;AN000;  3/3/KK
  1944                                  		;
  1945                                  		;return
  1946                                  
  1947                                  ; =============== S U B	R O U T	I N E =======================================
  1948                                  
  1949                                  ; Break	<ReadBat - read 1 line from batch file>
  1950                                  
  1951                                  ; ReadBat - read a single line from the batch file. 
  1952                                  ; Perform all substitutions as appropriate.
  1953                                  
  1954                                  READBAT:
  1955                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1956                                  		
  1957                                  		;mov	byte [SUPPRESS],1
  1958                                  					; initialize line suppress status
  1959 000004F8 C606EE0B01              		mov	byte [SUPPRESS],YES_ECHO 
  1960 000004FD F606E30BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1961 00000502 7508                    		jnz	short TRYING_TO_ABORT
  1962 00000504 C606E20B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1963                                  
  1964                                  		; MSDOS 6.0
  1965                                  ;
  1966                                  ;M037; Start of changes
  1967                                  ; We check here if we have set the flag indicating that the batchfile is at
  1968                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1969                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1970                                  ;batch file gets closed etc. and then return as if everything is done.
  1971                                  ;
  1972                                  		;push	ds
  1973                                  		;mov	ds,Batch
  1974                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1975                                  		;pop	ds
  1976                                  		;jz	contbat		; no, continue normal processing
  1977                                  		;invoke	GetBatByt	; frees up batchseg
  1978                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1979                                  		;			; as a dummy command
  1980                                  		;invoke CrLf2		; print a CR-LF
  1981                                  		;return			; done batch processing
  1982                                  
  1983                                  ;M037; End of changes
  1984                                  		
  1985                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1986                                  CONTBAT:
  1987 00000509 E8ABFF                  		call	PROMPTBAT
  1988                                  
  1989                                  TRYING_TO_ABORT:
  1990 0000050C BF[D240]                		mov	di,COMBUF+2
  1991                                  
  1992                                  ; Save position and try to scan for first non delimiter.
  1993                                  
  1994                                  TESTNOP:
  1995 0000050F 8CD8                    		mov	ax,ds
  1996 00000511 8E1E970B                		mov	ds,word [BATCH]
  1997 00000515 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  1998 00000519 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  1999 0000051D 8ED8                    		mov	ds,ax
  2000 0000051F E88105                  		call	SKIPDELIM	; skip to first non-delim
  2001                                  
  2002                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2003                                  ; beginning and read the line.
  2004                                  
  2005 00000522 3C3A                    		cmp	al,':'		; is it a label?
  2006 00000524 59                      		pop	cx
  2007 00000525 5A                      		pop	dx		; restore position in bat file
  2008 00000526 7431                    		jz	short NOPLINE	; yes, resync everything.
  2009 00000528 F706970BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2010 0000052E 7438                    		jz	short RDBAT	; no, go read batch file
  2011                                  
  2012                                  		;cmp	al,'@'
  2013 00000530 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2014 00000532 7507                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2015                                  		;mov	byte [SUPPRESS],0
  2016 00000534 C606EE0B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2017 00000539 EB2D                    		jmp	short RDBAT	; go read batch file
  2018                                  
  2019                                  		;nop
  2020                                  SET_BAT_POS:
  2021 0000053B 1E                      		push	ds
  2022 0000053C 8E1E970B                		mov	ds,word [BATCH]
  2023 00000540 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2024 00000544 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2025 00000548 1F                      		pop	ds
  2026                                  		;MOV	AX,(LSEEK SHL 8) + 0
  2027 00000549 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2028 0000054C CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2029                                  				; AL = method: offset from beginning of	file
  2030                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2031 0000054E 2EC706[184D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2032 00000555 31C9                    		xor	cx,cx		; Initialize line length to zero
  2033 00000557 EB0F                    		jmp	short RDBAT
  2034                                  
  2035                                  		;nop
  2036                                  
  2037                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2038                                  ; We eat characters until a CR is seen.
  2039                                  
  2040                                  NOPLINE:
  2041 00000559 E8F400                  		call	SKIPTOEOL
  2042 0000055C E82E03                  		call	GETBATBYT	; eat trailing LF
  2043                                  		;test	word [BATCH],0FFFFh
  2044 0000055F F706970BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2045 00000565 75A8                    		jnz	short TESTNOP	; no, go get another line
  2046                                  READBAT_RETN:				; Hit EOF			
  2047 00000567 C3                      		retn
  2048                                  
  2049                                  ; ---------------------------------------------------------------------------
  2050                                  
  2051                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2052                                  ; input, we are to consider two special cases:
  2053                                  ;
  2054                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2055                                  ;   %sym%	This is a symbol from the environment
  2056                                  
  2057                                  RDBAT:
  2058 00000568 E82203                  		call	GETBATBYT
  2059 0000056B 41                      		inc	cx		; Inc the line length
  2060                                  RDBAT1:
  2061 0000056C 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2062 00000570 7344                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2063                                  
  2064                                  ; See if we have a parameter character.
  2065                                  
  2066 00000572 3C25                    		cmp	al,'%'		; Check for parameter
  2067 00000574 744A                    		jz	short NEEDPARM
  2068                                  
  2069                                  ; no parameter character. Store it as usual and see if we are done.
  2070                                  
  2071                                  SAVBATBYT:
  2072 00000576 AA                      		stosb			; End of line found?
  2073 00000577 3C0D                    		cmp	al,0Dh
  2074 00000579 75ED                    		jnz	short RDBAT	; no, go for more
  2075                                  
  2076                                  ; We have read in an entire line. 
  2077                                  ; Decide whether we should echo the command line or not.
  2078                                  
  2079                                  FOUND_EOL:
  2080 0000057B 81EF[D340]              		sub	di,COMBUF+3
  2081 0000057F 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2082 00000581 26A2[D140]              		mov	[es:COMBUF+1],al ; Set length of line
  2083 00000585 E80503                  		call	GETBATBYT	; Eat linefeed
  2084 00000588 E80A06                  		call	BATCLOSE
  2085 0000058B 803EEE0B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2086 00000590 7407                    		jz	short RESET
  2087 00000592 F606ED0B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2088 00000597 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2089                                  RESET:
  2090 00000599 0E                      		push	cs
  2091 0000059A 1F                      		pop	ds		; Go back to local segment
  2092 0000059B 74CA                    		jz	short READBAT_RETN ; no echoing here...
  2093                                  TRY_NEXTFLAG:
  2094 0000059D 803E020C01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2095                                  					;G was there a command last time?
  2096 000005A2 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2097 000005A4 E8C713                  		call	CRLF2		;G  Print out prompt
  2098                                  NO_CRLF_PRINT:
  2099 000005A7 E8E00D                  		call	PRINT_PROMPT
  2100 000005AA 0E                      		push	cs		;G change data segment
  2101 000005AB 1F                      		pop	ds
  2102 000005AC BA[D240]                		mov	dx,COMBUF+2	; get command line for echoing
  2103 000005AF E81A14                  		call	CRPRINT
  2104 000005B2 E8B913                  		call	CRLF2
  2105 000005B5 C3                      		retn
  2106                                  
  2107                                  ; The line was too long. Eat remainder of input text up until the CR
  2108                                  
  2109                                  TOOLONG:
  2110 000005B6 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2111 000005B8 7403                    		jz	short LTLCONT	; Yes, continue
  2112 000005BA E89300                  		call	SKIPTOEOL	; Eat remainder of line	
  2113                                  LTLCONT:
  2114 000005BD AA                      		stosb			; Terminate the command
  2115 000005BE EBBB                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2116                                  
  2117                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2118                                  
  2119                                  NEEDPARM:
  2120 000005C0 E8CA02                  		call	GETBATBYT	; get next character
  2121 000005C3 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2122 000005C5 74AF                    		jz	short SAVBATBYT	; if so, replace with a single %
  2123 000005C7 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2124 000005C9 74AB                    		jz	short SAVBATBYT	; yes, treat it normally
  2125                                  
  2126                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2127                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2128                                  ; see if the <something> has a terminating % and then look up the contents
  2129                                  ; in the environment.
  2130                                  
  2131                                  PAROK:
  2132 000005CB 2C30                    		sub	al,'0'
  2133 000005CD 7239                    		jb	short NEEDENV	; look for parameter in the environment
  2134 000005CF 3C09                    		cmp	al,9
  2135 000005D1 7735                    		ja	short NEEDENV
  2136                                  
  2137                                  ; We have found %<number>. This is taken from the parameters in the
  2138                                  ; allocated batch area.
  2139                                  
  2140 000005D3 98                      		cbw
  2141 000005D4 89C3                    		mov	bx,ax		; move index into AX
  2142 000005D6 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2143 000005D8 06                      		push	es
  2144 000005D9 8E06970B                		mov	es,word [BATCH]
  2145                                  ;
  2146                                  ; The structure of the batch area is:
  2147                                  ;
  2148                                  ;   BYTE    type of segment
  2149                                  ;   DWORD   offset for next line
  2150                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2151                                  ;   ASCIZ   file name (with . and ..)
  2152                                  ;   BYTES   CR-terminated parameters
  2153                                  ;   BYTE    0 flag to indicate end of parameters
  2154                                  ;
  2155                                  ; Get pointer to BX'th argument
  2156                                  ;
  2157                                  		;mov	si,[es:bx+0Bh]
  2158 000005DD 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2159 000005E1 07                      		pop	es
  2160                                  
  2161                                  ; Is there a parameter here?
  2162                                  
  2163 000005E2 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2164 000005E5 7503                    		jnz	short YES_THERE_IS ; Yes go get it
  2165 000005E7 E97EFF                  		jmp	RDBAT		; Ignore if it doesn't
  2166                                  
  2167                                  ; Copy in the found parameter from batch segment
  2168                                  
  2169                                  YES_THERE_IS:
  2170 000005EA 1E                      		push	ds
  2171 000005EB 8E1E970B                		mov	ds,word [BATCH]
  2172 000005EF 49                      		dec	cx		; Don't count '%' in line length
  2173                                  COPYPARM:
  2174 000005F0 AC                      		lodsb			; From resident segment
  2175 000005F1 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2176 000005F3 740F                    		jz	short ENDPARAM
  2177 000005F5 41                      		inc	cx		; Inc the line length
  2178 000005F6 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2179 000005FA 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2180 000005FC AA                      		stosb
  2181 000005FD EBF1                    		jmp	short COPYPARM
  2182                                  
  2183                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2184                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2185                                  ; believing that we are at EOL. Clobber AL too.
  2186                                  
  2187                                  LINETOOL:
  2188 000005FF 30C0                    		xor	al,al
  2189 00000601 1F                      		pop	ds
  2190 00000602 EBB2                    		jmp	short TOOLONG
  2191                                  
  2192                                  ; We have copied in an entire parameter. Go back for more
  2193                                  
  2194                                  ENDPARAM:
  2195 00000604 1F                      		pop	ds
  2196 00000605 E960FF                  		jmp	RDBAT
  2197                                  
  2198                                  ; We have found % followed by something other than 0-9. We presume that there
  2199                                  ; will be a following % character. In between is an environment variable that
  2200                                  ; we will fetch and replace in the batch line with its value.
  2201                                  
  2202                                  NEEDENV:
  2203                                  		; MSDOS 6.0 COMMAND.COM 
  2204                                  		;dec     cx 		;AN070; Don't count "%"
  2205                                  
  2206                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2207 00000608 1E                      		push	ds
  2208 00000609 57                      		push	di
  2209                                  					; temp spot for name
  2210 0000060A BF[EC42]                		mov	di,ID
  2211 0000060D 0430                    		add	al,'0'		; reconvert character
  2212 0000060F AA                      		stosb			; store it in appropriate place
  2213                                  
  2214                                  ; loop getting characters until the next % is found or until EOL
  2215                                  
  2216                                  GETENV1:
  2217 00000610 E87A02                  		call	GETBATBYT	; get the byte
  2218 00000613 AA                      		stosb			; store it
  2219 00000614 3C0D                    		cmp	al,0Dh		; EOL?
  2220 00000616 7513                    		jnz	short GETENV15	; no, see if it the term char
  2221                                  
  2222                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2223                                  
  2224 00000618 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2225 0000061D BE[EC42]                		mov	si,ID 		; point to buffer
  2226 00000620 5F                      		pop	di		; point to line buffer
  2227 00000621 0E                      		push	cs
  2228 00000622 1F                      		pop	ds
  2229 00000623 E85E02                  		call	STRCPY
  2230                                  		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
  2231 00000626 4F                      		dec	di  		;  MSDOS 3.3 COMMAND.COM	
  2232 00000627 1F                      		pop	ds
  2233 00000628 E94BFF                  		jmp	SAVBATBYT
  2234                                  GETENV15:
  2235 0000062B 3C25                    		cmp	al,'%'		; terminating %?
  2236 0000062D 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2237                                  
  2238                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2239                                  ; This was the source of bug #1.
  2240                                  ;		dec	cx		;AN070; Don't count "%"
  2241                                  
  2242 0000062F B03D                    		mov	al,'='		; terminate  with =
  2243 00000631 268845FF                		mov	[es:di-1],al
  2244                                  
  2245                                  ; ID now either has a =-terminated string which we are to find in the
  2246                                  ; environment or a non =-terminated string which will not be found in the
  2247                                  ; environment.
  2248                                  
  2249                                  GETENV2:
  2250 00000635 BE[EC42]                		mov	si,ID
  2251 00000638 0E                      		push	cs
  2252 00000639 1F                      		pop	ds		; DS:SI points to name
  2253 0000063A 51                      		push	cx
  2254 0000063B E85911                  		call	FIND_NAME_IN_ENVIRONMENT
  2255 0000063E 59                      		pop	cx
  2256 0000063F 06                      		push	es
  2257 00000640 1F                      		pop	ds
  2258 00000641 0E                      		push	cs
  2259 00000642 07                      		pop	es
  2260 00000643 89FE                    		mov	si,di
  2261 00000645 5F                      		pop	di		; get back pointer to command line
  2262                                  
  2263                                  ; If the parameter was not found, there is no need to perform any replacement.
  2264                                  ; We merely pretend that we've copied the parameter.
  2265                                  
  2266 00000646 7204                    		jc	short GETENV6
  2267                                  
  2268                                  ; ES:DI points to command line being built
  2269                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2270                                  
  2271 00000648 E83902                  		call	STRCPY		; (let RdBat handle overflow)
  2272 0000064B 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2273                                  GETENV6:
  2274 0000064C 1F                      		pop	ds
  2275 0000064D E918FF                  		jmp	RDBAT		; go back to batch file
  2276                                  
  2277                                  ; =============== S U B	R O U T	I N E =======================================
  2278                                  
  2279                                  ;   SkipToEOL - read from batch file until end of line
  2280                                  
  2281                                  SKIPTOEOL:
  2282 00000650 F706970BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2283                                  		
  2284                                  		;jnz	short SKIPTOEOL1  	
  2285                                  		;retn			; no batch file in effect
  2286                                  		
  2287 00000656 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2288                                  SKIPTOEOL1:
  2289 00000658 E83202                  		call	GETBATBYT
  2290 0000065B 3C0D                    		cmp	al,0Dh		; eol character?
  2291 0000065D 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2292                                  SKIPTOEOL2:
  2293 0000065F C3                      		retn
  2294                                  
  2295                                  ; =============== S U B	R O U T	I N E =======================================
  2296                                  
  2297                                  ;Break	<Allocate and deallocate the transient portion>
  2298                                  
  2299                                  ; Free Transient. Modify ES,AX,flags
  2300                                  
  2301                                  FREE_TPA:
  2302 00000660 06                      		push	es
  2303 00000661 8E06[7142]              		mov	es,[RESSEG]
  2304 00000665 268E06230D              		mov	es,word [es:RES_TPA]
  2305 0000066A B449                    		mov	ah,DEALLOC ; 49h
  2306 0000066C CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2307                                  				; ES = segment address of area to be freed
  2308 0000066E 07                      		pop	es
  2309 0000066F C3                      		retn
  2310                                  
  2311                                  ; =============== S U B	R O U T	I N E =======================================
  2312                                  
  2313                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2314                                  
  2315                                  ALLOC_TPA:
  2316 00000670 06                      		push	es
  2317 00000671 8E06[7142]              		mov	es,[RESSEG]
  2318 00000675 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2319 00000678 B448                    		mov	ah,ALLOC ; 48h
  2320 0000067A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2321                                  				; BX = number of 16-byte paragraphs desired
  2322 0000067C 53                      		push	bx	  	; Save size of block
  2323 0000067D B448                    		mov	ah,ALLOC ; 48h
  2324 0000067F CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2325                                  				; BX = number of 16-byte paragraphs desired
  2326                                  
  2327                                  ; Attempt to align TPA on 64K boundary
  2328                                  
  2329 00000681 5B                      		pop	bx		; Restore size of block
  2330 00000682 26A3230D                		mov	word [es:RES_TPA],ax ; Save segment to beginning of block
  2331 00000686 A3[8142]                		mov	[TRAN_TPA],ax
  2332                                  
  2333                                  ; Is the segment already aligned on a 64K boundary
  2334                                  
  2335 00000689 89C2                    		mov	dx,ax		; Save segment
  2336 0000068B 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2337 0000068E 7507                    		jnz	short CALC_TPA
  2338 00000690 89D0                    		mov	ax,dx
  2339 00000692 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2340 00000695 7523                    		jnz	short NOROUND
  2341                                  CALC_TPA:
  2342 00000697 89D0                    		mov	ax,dx
  2343 00000699 2500F0                  		and	ax,0F000h
  2344 0000069C 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2345 0000069F 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2346                                  
  2347                                  ; Make sure that new boundary is within allocated range
  2348                                  
  2349 000006A1 268B16230D              		mov	dx,word [es:RES_TPA]
  2350 000006A6 01DA                    		add	dx,bx		; Compute maximum address
  2351 000006A8 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2352 000006AA 720E                    		jb	short NOROUND
  2353                                  
  2354                                  ; Make sure that we won't overwrite the transient
  2355                                  
  2356 000006AC 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2357 000006AE 39C3                    		cmp	bx,ax
  2358 000006B0 7208                    		jb	short NOROUND
  2359                                  
  2360                                  ; The area from the 64K boundary to the beginning of the transient must
  2361                                  ; be at least 64K.
  2362                                  
  2363 000006B2 29C3                    		sub	bx,ax
  2364                                  		;cmp	bx,4096
  2365 000006B4 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2366 000006B8 7304                    		jnb	short ROUNDDONE
  2367                                  NOROUND:
  2368 000006BA 26A1230D                		mov	ax,word [es:RES_TPA]
  2369                                  ROUNDDONE:
  2370 000006BE 26A3150D                		mov	word [es:LTPA],ax ; Re-compute everything
  2371 000006C2 A3[7342]                		mov	[TPA],ax
  2372 000006C5 89C3                    		mov	bx,ax
  2373 000006C7 8CC8                    		mov	ax,cs
  2374 000006C9 29D8                    		sub	ax,bx
  2375 000006CB 53                      		push	bx
  2376 000006CC BB1000                  		mov	bx,16
  2377 000006CF F7E3                    		mul	bx
  2378 000006D1 5B                      		pop	bx
  2379 000006D2 09D2                    		or	dx,dx
  2380 000006D4 7403                    		jz	short SAVSIZ2
  2381 000006D6 B8FFFF                  		mov	ax,-1
  2382                                  SAVSIZ2:
  2383                                  
  2384                                  ; AX is the number of bytes free in the buffer between the resident and the
  2385                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2386                                  
  2387 000006D9 3D0002                  		cmp	ax,512
  2388 000006DC 7603                    		jbe	short GOTSIZE2
  2389                                  		;and	ax,~1FFh
  2390 000006DE 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2391                                  GOTSIZE2:
  2392 000006E1 A3[9242]                		mov	[BYTCNT],ax
  2393 000006E4 07                      		pop	es
  2394 000006E5 C3                      		retn
  2395                                  
  2396                                  ; =============== S U B	R O U T	I N E =======================================
  2397                                  
  2398                                  ;Break	<BatCom - enter a batch file>
  2399                                  
  2400                                  ; The exec search has determined that the user has requested a batch file for
  2401                                  ; execution. We parse the arguments, create the batch segment, and signal
  2402                                  ; batch processing.
  2403                                  
  2404                                  BATCOM:	
  2405                                  
  2406                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2407                                  
  2408                                  ; Batch parameters are read with ES set to segment of resident part
  2409                                  
  2410                                  		; MSDOS 6.0
  2411                                  		;mov	es,[RESSEG]
  2412                                  		;ASSUME	ES:RESGROUP
  2413                                  		;cmp	es:[call_batch_flag],call_in_progress
  2414                                  		;				;AN043; If in CALL,
  2415                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2416                                  		;invoke	IOSET			; Set up any redirection
  2417                                  ;skip_ioset:					;AN043;
  2418                                  		;call	FREE_TPA		; G
  2419                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2420                                  		;jz	getecho 		; G if we're in a call, don't execute
  2421                                  
  2422                                  		; MSDOS 3.3
  2423 000006E6 E81E17                  		call	IOSET
  2424 000006E9 8E06[7142]              		mov	es,[RESSEG]
  2425 000006ED E870FF                  		call	FREE_TPA
  2426                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2427 000006F0 26803EFF0B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2428 000006F6 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2429                                  
  2430                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2431                                  
  2432                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2433                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2434                                  ; Don't execute if in call
  2435                                  
  2436 000006F8 E8A007                  		call	FOROFF
  2437                                  GETECHO:
  2438 000006FB E8901C                  		call	PIPEOFF
  2439 000006FE 26A0ED0B                		mov	al,byte [es:ECHOFLAG] ; preserve echo state for chaining
  2440 00000702 2401                    		and	al,1		; Save current echo state
  2441                                  
  2442 00000704 50                      		push	ax
  2443 00000705 31C0                    		xor	ax,ax
  2444 00000707 26F706970BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2445 0000070E 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2446 00000710 26A1970B                		mov	ax,word [es:BATCH] ; Get current batch segment
  2447                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2448 00000714 26803EFF0B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2449 0000071A 7408                    		jz	short LEAVEBAT
  2450                                  
  2451                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2452                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2453                                  
  2454 0000071C 06                      		push	es
  2455 0000071D 8EC0                    		mov	es,ax		; Get current batch segment
  2456                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2457                                  					; Get previous batch segment
  2458 0000071F 26A10200                		mov	ax,word [es:BATCHSEGMENT.BatLast]
  2459 00000723 07                      		pop	es
  2460                                  LEAVEBAT:
  2461 00000724 50                      		push	ax		; Keep segment until new one created
  2462 00000725 26803EFF0B01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2463 0000072B 7403                    		jz	short STARTBAT
  2464 0000072D E8F800                  		call	BATCHOFF
  2465                                  
  2466                                  ; Find length of batch file
  2467                                  
  2468                                  STARTBAT:
  2469 00000730 26C606FF0B00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2470 00000736 BE[9941]                		mov	si,EXECPATH
  2471                                  
  2472                                  		; MSDOS 6.0
  2473                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2474                                  		;int	2fh		;AN042;    was found with APPEND
  2475                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2476                                  		;mov	dx,si		;AN042; Get the string
  2477                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2478                                  		;int	21h		;AN042;
  2479                                  
  2480                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2481 00000739 E88217                  		call	DSTRLEN
  2482                                  ;
  2483                                  ; Allocate batch area:
  2484                                  ;   BYTE    type of segment
  2485                                  ;   WORD    segment of last batch file
  2486                                  ;   WORD    segment for FOR command
  2487                                  ;   BYTE    FOR flag state on entry to batch file
  2488                                  ;   DWORD   offset for next line
  2489                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2490                                  ;   ASCIZ   file name (with . and ..)
  2491                                  ;   BYTES   CR-terminated parameters
  2492                                  ;   BYTE    0 flag to indicate end of parameters
  2493                                  ;
  2494                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2495                                  ; later when we've squeezed out the extra
  2496                                  ;
  2497 0000073C 89CB                    		mov	bx,cx		; length of file name.
  2498                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2499 0000073E 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2500                                  					; structure + max len + round up
  2501 00000742 51                      		push	cx
  2502 00000743 B104                    		mov	cl,4
  2503 00000745 D3EB                    		shr	bx,cl		; convert to paragraphs
  2504 00000747 53                      		push	bx		; Save size of batch segment
  2505 00000748 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2506 0000074A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2507                                  				; BX = number of 16-byte paragraphs desired
  2508 0000074C 5B                      		pop	bx		; Get size of batch segment
  2509                                  
  2510                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2511                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2512                                  ; G This error will occur with nesting of batch files. We also need to
  2513                                  ; G make sure that we don't overlay the transient.
  2514                                  
  2515 0000074D 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2516                                  
  2517 0000074F 50                      		push	ax		;G save batch segment
  2518 00000750 01D8                    		add	ax,bx		;G get end of batch segment
  2519 00000752 83C020                  		add	ax,20h		;G add some tpa work area
  2520 00000755 8CCB                    		mov	bx,cs		;G get the transient segment
  2521                                  
  2522                                  		; MSDOS 6.0
  2523                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2524                                  ; M006; batchseg is always above the transient. We need to change this code
  2525                                  ; M006; to only check for an overlap
  2526                                  ;
  2527                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2528                                  		;add	dx,15		;round up para; M006
  2529                                  		;shr	dx,cl		;para size of transient; M006
  2530                                  		;add	dx,bx		;dx = top of transient; M006
  2531                                  
  2532                                  		;cmp	ax,bx		; M006
  2533                                  		;jb	enough_mem	; Batchseg below transient
  2534                                  					; enough memory ; M006
  2535                                  		;cmp	ax,dx		; M006
  2536                                  		;ja	enough_mem	; Batchseg above transient
  2537                                  					; enough memory ; M006
  2538                                  ;
  2539                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2540                                  ;
  2541                                  		;pop	ax		; restore ax; M006
  2542                                  
  2543                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2544                                  ;M006;		pop	ax		;G get batch segment back
  2545                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2546                                  
  2547                                  		; MSDOS 3.3
  2548 00000757 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2549 00000759 58                      		pop	ax		; get batch segment back
  2550 0000075A 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2551                                  
  2552                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2553 0000075C 06                      		push	es		;G no we're hitting the transient
  2554 0000075D 8EC0                    		mov	es,ax
  2555 0000075F B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2556 00000762 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2557                                  				; ES = segment address of area to be freed
  2558 00000764 07                      		pop	es
  2559                                  MEM_ERROR:
  2560 00000765 E9B400                  		jmp	NO_MEMORY	;G Set up for message and exit
  2561                                  
  2562                                  ENOUGH_MEM:
  2563                                  		; MSDOS 6.0
  2564                                  		;pop	ax		; restore ax; M006
  2565                                  
  2566                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2567 00000768 26A3970B                		mov	word [es:BATCH],ax
  2568 0000076C E801FF                  		call	ALLOC_TPA
  2569                                  
  2570                                  ; Initialize batch segment
  2571                                  
  2572 0000076F 5A                      		pop	dx		; length of name
  2573 00000770 58                      		pop	ax		;G get saved batch segment back
  2574 00000771 26FF06FC0B              		inc	word [es:NEST]	;G increment # batch files in progress
  2575 00000776 06                      		push	es
  2576 00000777 268E06970B              		mov	es,word [es:BATCH]
  2577                                  		;mov	byte [ES:0],0
  2578                                  					; signal batch file type
  2579 0000077C 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2580                                  		;mov	byte [ES:2],ax ; MSDOS 3.3
  2581                                  					;G save segment of last batch file
  2582 00000782 26A30200                		mov	word [es:BATCHSEGMENT.BatLast],ax
  2583 00000786 1E                      		push	ds
  2584 00000787 8E1E[7142]              		mov	ds,[RESSEG]	;G set to resident data
  2585                                  
  2586 0000078B 31C0                    		xor	ax,ax
  2587 0000078D 8A1EF90B                		mov	bl,byte [FORFLAG] ;G get the current FOR state
  2588                                  		;mov	[es:6],bl ;  MSDOS 3.3
  2589                                  					;G save it in the batch segment
  2590 00000791 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2591 00000796 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2592 00000799 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2593 0000079B A1FA0B                  		mov	ax,word [FORPTR] ;G yes, get current FOR segment	
  2594 0000079E C606F90B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2595                                  FOR_NOT_ON:
  2596                                  		;mov	[es:4],ax ; MSDOS 3.3
  2597                                  					;G save FOR segment in batch segment
  2598 000007A3 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2599 000007A7 31C0                    		xor	ax,ax
  2600 000007A9 A3FA0B                  		mov	word [FORPTR],ax ;G make sure for segment is not active
  2601 000007AC 8A1EED0B                		mov	bl,byte [ECHOFLAG]
  2602 000007B0 1F                      		pop	ds
  2603                                  		;mov	[es:1],bl 
  2604                                  					 ;G save echo state of parent
  2605 000007B1 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2606                                  ;SR;
  2607                                  ; Initialize the new BatchEOF flag we have added to 0
  2608                                  ;
  2609                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2610                                  
  2611 000007B6 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2612 000007BA 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2613                                  
  2614                                  ; Initialize pointers
  2615                                  
  2616 000007BE 48                      		dec	ax		; put -1 into AX
  2617                                  		;mov	di,0Bh  ; MSDOS 3.3
  2618                                  					; point to parm area
  2619 000007BF BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2620 000007C2 89FB                    		mov	bx,di
  2621 000007C4 B90A00                  		mov	cx,10
  2622 000007C7 F3AB                    		rep stosw		; Init to no parms
  2623                                  
  2624                                  ; Move in batch file name
  2625                                  
  2626 000007C9 89D1                    		mov	cx,dx
  2627 000007CB F3A4                    		rep movsb
  2628                                  
  2629                                  ; Now copy the command line into batch segment, parsing the arguments along
  2630                                  ; the way. Segment will look like this:
  2631                                  ;
  2632                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2633                                  ;
  2634                                  ; or, in the case of fewer arguments:
  2635                                  ;
  2636                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2637                                  ;
  2638 000007CD BE[D240]                		mov	si,COMBUF+2
  2639 000007D0 B90A00                  		mov	cx,10		; at most 10 arguments
  2640                                  EACHPARM:
  2641 000007D3 E8A511                  		call	SCANOFF		; skip to argument
  2642                                  
  2643                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2644                                  
  2645 000007D6 3C0D                    		cmp	al,0Dh		; end of road?
  2646 000007D8 741D                    		jz	short HAVPARM	; yes, no more arguments
  2647                                  
  2648                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2649                                  
  2650 000007DA E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2651                                  
  2652                                  ; Go into allocated piece and stick in new argument pointer.
  2653                                  
  2654 000007DC 26893F                  		mov	[es:bx],di	; store batch pointer
  2655 000007DF 83C302                  		add	bx,2		; advance arg counter
  2656                                  
  2657                                  ; Move the parameter into batch segment
  2658                                  
  2659                                  MOVPARM:
  2660 000007E2 AC                      		lodsb			; get byte
  2661 000007E3 E89D11                  		call	DELIM		; if delimiter
  2662 000007E6 7407                    		jz	short ENDPARM	; then done with parm
  2663 000007E8 AA                      		stosb			; store byte
  2664 000007E9 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2665 000007EB 740A                    		jz	short HAVPARM	; but end of parm list, finish
  2666 000007ED EBF3                    		jmp	short MOVPARM
  2667                                  
  2668                                  ; We have copied a parameter up until the first separator.
  2669                                  ; Terminate it with CR.
  2670                                  
  2671                                  ENDPARM:
  2672 000007EF B00D                    		mov	al,0Dh
  2673 000007F1 AA                      		stosb
  2674 000007F2 E3DF                    		jcxz	EACHPARM	; if no parameters, don't dec
  2675 000007F4 49                      		dec	cx		; remember that we've seen one.	
  2676 000007F5 EBDC                    		jmp	short EACHPARM
  2677                                  
  2678                                  ; We have parsed the entire line. Terminate the arg list
  2679                                  
  2680                                  HAVPARM:
  2681 000007F7 30C0                    		xor	al,al		; Nul terminate the parms
  2682 000007F9 AA                      		stosb
  2683                                  
  2684                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2685                                  ; into paragraphs and setblock to the appropriate size
  2686                                  
  2687 000007FA 8D5D0F                  		lea	bx,[di+15]
  2688 000007FD B104                    		mov	cl,4
  2689 000007FF D3EB                    		shr	bx,cl
  2690 00000801 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2691 00000803 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2692                                  				; ES = segment address of block	to change
  2693                                  				; BX = new size	in paragraphs
  2694 00000805 07                      		pop	es
  2695 00000806 06                      		push	es
  2696 00000807 1F                      		pop	ds		; Simply batch FCB setup
  2697 00000808 833EF30BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2698 0000080D 7506                    		jnz	short NOBATSING
  2699 0000080F C706F30BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2700                                  NOBATSING:
  2701                                  
  2702                                  ; Enter the batch file with the current echo state
  2703                                  
  2704 00000815 58                      		pop	ax		; Get original echo state
  2705 00000816 A2ED0B                  		mov	byte [ECHOFLAG],al ; restore it
  2706 00000819 E9E8F8                  		jmp	TCOMMAND
  2707                                  
  2708                                  ; The following is executed if there isn't enough memory for batch segment
  2709                                  
  2710                                  NO_MEMORY:
  2711 0000081C 5A                      		pop	dx		; even up our stack 
  2712 0000081D 58                      		pop	ax
  2713 0000081E 58                      		pop	ax
  2714 0000081F E84EFE                  		call	ALLOC_TPA	; reallocate memory
  2715                                  
  2716                                  		; MSDOS 3.3
  2717 00000822 BA[AA3C]                		mov	dx,INSFMEMMESPTR
  2718 00000825 E90314                  		jmp	CERROR
  2719                                  
  2720                                  		; MSDOS 6.0
  2721                                  		;mov	msg_disp_class,ext_msg_class
  2722                                  		;			;AN000; set up extended error msg class
  2723                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2724                                  		;			;AC000; get extended message pointer
  2725                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2726                                  		;			;AN000; get message number in control block
  2727                                  		;jmp	cerror		;g print error message and go...
  2728                                  
  2729                                  ; =============== S U B	R O U T	I N E =======================================
  2730                                  
  2731                                  BATCHOFF:
  2732 00000828 50                      		push	ax
  2733 00000829 06                      		push	es
  2734 0000082A 1E                      		push	ds
  2735 0000082B 53                      		push	bx
  2736                                  
  2737 0000082C 2E8E06[7142]            		mov	es,[cs:RESSEG]
  2738 00000831 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  2739 00000836 A1970B                  		mov	ax,word [BATCH]	; Free the batch segment
  2740 00000839 09C0                    		or	ax,ax
  2741 0000083B 7442                    		jz	short NOTFREE
  2742                                  
  2743 0000083D 06                      		push	es
  2744 0000083E 8EC0                    		mov	es,ax
  2745 00000840 F606ED0B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2746 00000845 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2747                                  		;mov	byte [SUPPRESS],0
  2748 00000847 C606EE0B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2749                                  ECHO_LAST_LINE:
  2750                                  		;mov	bl,[es:1]
  2751 0000084C 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2752 00000851 881EED0B                		mov	byte [ECHOFLAG],bl		 ; G and restore it
  2753                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2754 00000855 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2755 0000085A 891EFA0B                		mov	word [FORPTR],bx		;G  and restore it
  2756                                  		;mov	bl,[es:6]
  2757 0000085E 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2758 00000863 881EF90B                		mov	byte [FORFLAG],bl		;G  and restore it
  2759                                  		;mov	bx,word [es:2] ; MSDOS 3.3
  2760 00000867 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment
  2761                                  
  2762 0000086C B449                    		mov	ah,DEALLOC ; 49h
  2763 0000086E CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2764                                  				; ES = segment address of area to be freed
  2765 00000870 07                      		pop	es
  2766 00000871 891E000C                		mov	word [NEXT_BATCH],bx ;G  reset batch segment	
  2767 00000875 26FF0EFC0B              		dec	word [es:NEST]
  2768 0000087A 31C0                    		xor	ax,ax
  2769 0000087C A3970B                  		mov	word [BATCH],ax	; No batch in progress
  2770                                  NOTFREE:
  2771 0000087F 5B                      		pop	bx
  2772 00000880 1F                      		pop	ds
  2773 00000881 07                      		pop	es
  2774 00000882 58                      		pop	ax
  2775 00000883 C3                      		retn
  2776                                  
  2777                                  ; =============== S U B	R O U T	I N E =======================================
  2778                                  
  2779                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2780                                  ;	Entry : DS:SI ==> source string
  2781                                  ;		ES:DI ==> destination string
  2782                                  ;		CX = current length of destination string
  2783                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2784                                  
  2785                                  		; MSDOS 3.3
  2786                                  STRCPY:
  2787 00000884 50                      		push	ax
  2788                                  CCYCLE:
  2789 00000885 AC                      		lodsb
  2790 00000886 AA                      		stosb
  2791 00000887 08C0                    		or	al,al
  2792 00000889 75FA                    		jnz	short CCYCLE
  2793 0000088B 58                      		pop	ax
  2794 0000088C C3                      		retn
  2795                                  
  2796                                  		; MSDOS 6.0
  2797                                  ;Procedure StrCpy,NEAR
  2798                                  		;push	ax
  2799                                  ;ccycle:
  2800                                  		;lodsb
  2801                                  		;inc	cx
  2802                                  		;cmp	cx,COMBUFLEN
  2803                                  		;jb	ccopy
  2804                                  		;stc			; set carry to signal error
  2805                                  		;jmp	short ccend
  2806                                  ;ccopy:
  2807                                  		;stosb
  2808                                  		;or	al,al
  2809                                  		;jnz	ccycle
  2810                                  ;ccend:
  2811                                  		;dec	cx		; discount extra byte
  2812                                  		;dec	di		; back up pointer
  2813                                  		;pop	ax
  2814                                  		;return			; return carry clear
  2815                                  ;EndProc StrCpy
  2816                                  
  2817                                  ;============================================================================
  2818                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2819                                  ;============================================================================
  2820                                  ; 12/10/2018 - Retro DOS v3.0
  2821                                  
  2822                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2823                                  
  2824                                  ; =============== S U B	R O U T	I N E =======================================
  2825                                  
  2826                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2827                                  
  2828                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2829                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2830                                  ; AH, DX destroyed.
  2831                                  
  2832                                  GETBATBYT:
  2833 0000088D 53                      		push	bx
  2834 0000088E 51                      		push	cx
  2835 0000088F 1E                      		push	ds
  2836 00000890 F606E30BFF              		test	byte [BATCH_ABORT],-1
  2837 00000895 755E                    		jnz	short BATEOF
  2838 00000897 F706970BFFFF            		test	word [BATCH],-1
  2839 0000089D 7456                    		jz	short BATEOF
  2840 0000089F 06                      		push	es
  2841 000008A0 8E06970B                		mov	es,word [BATCH]
  2842                                  
  2843                                  		; MSDOS 6.0
  2844                                  ;M020;
  2845                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2846                                  ;try to read from the batchfile again.
  2847                                  ;
  2848                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2849                                  		;jz	not_eof		;no, read batch file	;M020
  2850                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2851                                  ;not_eof:							;M020
  2852                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2853 000008A4 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2854 000008AA 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2855 000008B0 07                      		pop	es
  2856                                  
  2857                                  ; See if we have bytes buffered...
  2858                                  
  2859 000008B1 8CC8                    		mov	ax,cs
  2860 000008B3 8ED8                    		mov	ds,ax
  2861 000008B5 8B1E[184D]              		mov	bx,[BATBUFPOS]
  2862 000008B9 83FBFF                  		cmp	bx,-1
  2863 000008BC 751D                    		jnz	short UNBUF
  2864                                  
  2865                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2866                                  
  2867 000008BE BA[1A4D]                		mov	dx,BATBUF
  2868 000008C1 8B0E[223F]              		mov	cx,[BATBUFLEN] ; max to read.
  2869 000008C5 8B1E[9545]              		mov	bx,[BATHAND]
  2870 000008C9 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2871 000008CB CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2872                                  				; BX = file handle,CX = number	of bytes to read
  2873                                  				; DS:DX	-> buffer
  2874                                  		; MSDOS 6.0
  2875                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2876                                  		;invoke	get_ext_error_number	;AN022; get the error
  2877                                  		;push	ds			;AN022; save local segment
  2878                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2879                                  		;assume ds:resgroup		;AN022;
  2880                                  		;mov	dx,ax			;AN022; put error in DX
  2881                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2882                                  		;pop	ds			;AN022;
  2883                                  		;assume	ds:trangroup		;AN022;
  2884                                  		;invoke	std_eprintf		;AN022; print out the error
  2885                                  		;mov	byte ptr combuf+2,end_of_line_in
  2886                                  		;				;AN022; terminate the batch line for parsing
  2887                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2888                                  		;				;AN022; terminate the batch line for output
  2889                                  ;M020;
  2890                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2891                                  ;error is never hit (and it shouldn't be)
  2892                                  ;
  2893                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2894                                  		;
  2895                                  		;jmp	short bateof		;AN022; terminate the batch file
  2896                                  ;bat_read_ok:					;AN022;
  2897                                  
  2898                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2899 000008CD 89C1                    		mov	cx,ax
  2900 000008CF E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2901                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2902 000008D1 890E[3A4D]              		mov	[BATBUFEND],cx
  2903 000008D5 31DB                    		xor	bx,bx
  2904 000008D7 891E[184D]              		mov	[BATBUFPOS],bx
  2905                                  
  2906                                  ; Buffered bytes!
  2907                                  
  2908                                  UNBUF:
  2909 000008DB 8A87[1A4D]              		mov	al,[BATBUF+bx]		; get next byte
  2910 000008DF 43                      		inc	bx
  2911 000008E0 3B1E[3A4D]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2912 000008E4 7203                    		jb	short SETBUFPOS
  2913 000008E6 BBFFFF                  		mov	bx,-1
  2914                                  SETBUFPOS:
  2915 000008E9 891E[184D]              		mov	[BATBUFPOS],bx
  2916 000008ED 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2917 000008EF 7533                    		jnz	short GETBYTEDONE
  2918                                  
  2919                                  ;We get here only when we hit an EOF
  2920                                  		
  2921                                  		; MSDOS 6.0
  2922                                  ;BatEOFDS:
  2923                                  ;SR;
  2924                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2925                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2926                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2927                                  ;batch processing is turned off before the last line is processed and so 
  2928                                  ;this line would never be executed. 
  2929                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2930                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2931                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2932                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2933                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2934                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2935                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2936                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2937                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2938                                  ;another redundant CR-LF. There is no work-around I can think of.
  2939                                  ; 	I would love to restructure this entire routine and its caller to
  2940                                  ;make the flow really easy to understand but I guess this will have to wait.
  2941                                  ;
  2942                                  		;push	es
  2943                                  		;mov	es,ResSeg
  2944                                  ;SR;
  2945                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2946                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2947                                  ;
  2948                                  		;mov	es,es:Batch
  2949                                  		;cmp	es:BatchEOF,0
  2950                                  		;jnz	crpresent
  2951                                  
  2952                                  		;inc	es:BatchEOF		;match the dec following
  2953                                  		;mov	bx,BatBufEnd
  2954                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2955                                  		;je	crpresent		;yes, no need to fake it
  2956                                  
  2957                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2958                                  
  2959                                  ;crpresent:
  2960                                  ;;;		;pop	es
  2961                                  
  2962                                  		;ASSUME	DS:TranGroup
  2963                                  		;MOV	DS,ResSeg
  2964                                  		;ASSUME	DS:ResGroup
  2965                                  
  2966                                  ;SR;
  2967                                  ; The shift operation is done here to replace the decrement. This is because
  2968                                  ;we can jump to this label directly from above when bogus calls are made to
  2969                                  ;this routine even after batch processing is turned off. The shift ensures
  2970                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  2971                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  2972                                  ;calls.
  2973                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  2974                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  2975                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  2976                                  ;turning batch processing off.
  2977                                  
  2978                                  ;At_EOF:						;new label added ;M020
  2979                                  		;shr	es:BatchEOF,1		;decrement the flag
  2980                                  		;jz	turn_off		;zero,turn batch off
  2981                                  		;cmp	es:BatchEOF,1				
  2982                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  2983                                  ;
  2984                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  2985                                  ;
  2986                                  		;mov	al,0dh			;return fake CR.
  2987                                  		;pop	es
  2988                                  		;jmp	short GetByteDone
  2989                                  ;ret_lf:
  2990                                  		;mov	al,0ah			;return fake LF
  2991                                  		;pop	es
  2992                                  		;jmp	short	GetByteDone			
  2993                                  ;turn_off:
  2994                                  		;pop	es
  2995                                  
  2996                                  ;BATEOF:
  2997                                  
  2998                                  		; MSDOS 3.3
  2999                                  TURN_OFF:
  3000 000008F1 8E1E[7142]              		mov	ds,[RESSEG]
  3001                                  
  3002                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3003                                  BATEOF:
  3004 000008F5 E830FF                  		call	BATCHOFF
  3005 000008F8 E89A02                  		call	BATCLOSE
  3006                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3007                                  
  3008                                  ;SR; BugBug
  3009                                  ; There is a good reason why this carriage return is being returned here. 
  3010                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3011                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3012                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3013                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3014                                  ;the batchfile already had a CR-LF. 
  3015                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3016                                  ;the end-of-line. This CR is to mark the end-of-file.
  3017                                  
  3018 000008FB B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3019 000008FD F606E30BFF              		test	byte [BATCH_ABORT],-1
  3020 00000902 C606E30B00              		mov	byte [BATCH_ABORT],0
  3021 00000907 7407                    		jz	short CONT_GET_BYT
  3022 00000909 BF[D240]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3023 0000090C 31C9                    		xor	cx,cx		; zero line length
  3024 0000090E EB14                    		jmp	short GETBYTEDONE
  3025                                  CONT_GET_BYT:
  3026 00000910 833EF30BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3027 00000915 750D                    		jnz	short GETBYTEDONE
  3028 00000917 833EFC0B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3029 0000091C 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3030 0000091E C706F30BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3031                                  GETBYTEDONE:
  3032 00000924 1F                      		pop	ds
  3033 00000925 59                      		pop	cx
  3034 00000926 5B                      		pop	bx
  3035 00000927 C3                      		retn
  3036                                  
  3037                                  ; ---------------------------------------------------------------------------
  3038                                  
  3039                                  ;break	<$If - conditional execution>
  3040                                  
  3041                                  IFERRORP:
  3042 00000928 58                      		pop	ax
  3043                                  IFERROR:
  3044                                  FORERROR:
  3045 00000929 BA[783C]                		mov	dx,SYNTMESPTR
  3046 0000092C E9FC12                  		jmp	CERROR
  3047                                  
  3048                                  ; ---------------------------------------------------------------------------
  3049                                  
  3050                                  _$IF:
  3051                                  		; MSDOS 6.0
  3052                                  ; Turn off any pipes in progress.
  3053                                  		;push	ds			;AN004; save local DS
  3054                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3055                                  		;assume	ds:resgroup		;AN004;
  3056                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3057                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3058                                  		;invoke	PipeDel 		;AN004; turn off piping
  3059                                  ;IFNoPipe:					;AN004;
  3060                                  		;pop	ds			;AN004; get local DS back
  3061                                  		;assume	ds:trangroup		;AN004;
  3062                                  
  3063                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3064 0000092F C606[8442]00            		mov	byte [IFNOTFLAG],0
  3065 00000934 C706[F54B]0000          		mov	word [IF_NOT_COUNT],0
  3066 0000093A BE8100                  		mov	si,81h
  3067                                  IFREENT:
  3068 0000093D E83B10                  		call	SCANOFF
  3069 00000940 3C0D                    		cmp	al,0Dh
  3070 00000942 74E5                    		jz	short IFERROR
  3071 00000944 89F5                    		mov	bp,si
  3072 00000946 BF[C73D]                		mov	di,IFTAB	; Prepare to search if table	
  3073 00000949 B500                    		mov	ch,0
  3074                                  IFINDCOM:
  3075 0000094B 89EE                    		mov	si,bp
  3076 0000094D 8A0D                    		mov	cl,[di]
  3077 0000094F 47                      		inc	di
  3078 00000950 E337                    		jcxz	IFSTRING
  3079 00000952 EB02                    		jmp	short FIRSTCOMP
  3080                                  
  3081                                  IFCOMP:
  3082 00000954 7510                    		jnz	short IF_DIF
  3083                                  FIRSTCOMP:
  3084 00000956 AC                      		lodsb
  3085 00000957 268A25                  		mov	ah,[es:di]
  3086 0000095A 47                      		inc	di
  3087 0000095B 38E0                    		cmp	al,ah
  3088 0000095D 7405                    		jz	short IFLP
  3089 0000095F 80CC20                  		or	ah,20h		; Try lower case
  3090 00000962 38E0                    		cmp	al,ah
  3091                                  IFLP:
  3092 00000964 E2EE                    		loop	IFCOMP
  3093                                  IF_DIF:
  3094 00000966 9F                      		lahf
  3095 00000967 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3096 00000969 8B1D                    		mov	bx,[di]		; Get handler address
  3097 0000096B 47                      		inc	di
  3098 0000096C 47                      		inc	di
  3099 0000096D 9E                      		sahf
  3100 0000096E 75DB                    		jnz	short IFINDCOM
  3101 00000970 AC                      		lodsb
  3102 00000971 3C0D                    		cmp	al,0Dh
  3103                                  IFERRJ:
  3104 00000973 74B4                    		jz	short IFERROR
  3105 00000975 E80B10                  		call	DELIM
  3106 00000978 75D1                    		jnz	short IFINDCOM
  3107 0000097A E8FE0F                  		call	SCANOFF
  3108 0000097D FFE3                    		jmp	bx
  3109                                  
  3110                                  IFNOT:
  3111 0000097F F616[8442]              		not	byte [IFNOTFLAG]
  3112 00000983 FF06[F54B]              		inc	word [IF_NOT_COUNT]
  3113 00000987 EBB4                    		jmp	short IFREENT
  3114                                  
  3115                                  ; We are comparing two strings for equality. First, find the end of the
  3116                                  ; first string.
  3117                                  
  3118                                  IFSTRING:
  3119 00000989 56                      		push	si		; save away pointer for later compare
  3120 0000098A 31C9                    		xor	cx,cx		; count of chars in first string
  3121                                  FIRST_STRING:
  3122 0000098C AC                      		lodsb			; get character
  3123 0000098D 3C0D                    		cmp	al,0Dh		; end of line?
  3124 0000098F 7497                    		jz	short IFERRORP	; yes => error
  3125 00000991 E8EF0F                  		call	DELIM		; is it a delimiter?
  3126 00000994 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3127 00000996 41                      		inc	cx		; remember 1 byte for the length
  3128 00000997 EBF3                    		jmp	short FIRST_STRING ; go back for more
  3129                                  EQUAL_CHECK:
  3130 00000999 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3131 0000099B 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3132 0000099D 3C0D                    		cmp	al,0Dh		; end of line?
  3133 0000099F 7487                    		jz	short IFERRORP	; yes, syntax error
  3134 000009A1 AC                      		lodsb			; get next char
  3135 000009A2 EBF5                    		jmp	short EQUAL_CHECK
  3136                                  
  3137                                  ; The first = has been found. The next char had better be an = too.
  3138                                  
  3139                                  EQUAL_CHECK2:
  3140 000009A4 AC                      		lodsb			; get potential = char
  3141 000009A5 3C3D                    		cmp	al,'='		; is it good?	
  3142 000009A7 7520                    		jnz	short IFERRPJ	; no, error
  3143                                  
  3144                                  ; Find beginning of second string.
  3145                                  
  3146 000009A9 E8CF0F                  		call	SCANOFF
  3147 000009AC 3C0D                    		cmp	al,0Dh
  3148 000009AE 7419                    		jz	short IFERRPJ
  3149 000009B0 5F                      		pop	di
  3150                                  
  3151                                  ; DS:SI points to second string
  3152                                  ; CX has number of chars in first string
  3153                                  ; ES:DI points to first string
  3154                                  
  3155 000009B1 F3A6                    		repe cmpsb
  3156 000009B3 7417                    		jz	short MATCH	; match found!
  3157                                  
  3158                                  ; No match.  Let's find out what was wrong. The character that did not match
  3159                                  ; has been advanced over. Let's back up to it.
  3160                                  
  3161 000009B5 4E                      		dec	si
  3162                                  
  3163                                  ; If it is EOL, then syntax error
  3164                                  
  3165 000009B6 803C0D                  		cmp	byte [si],0Dh
  3166 000009B9 74B8                    		jz	short IFERRJ
  3167                                  
  3168                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3169                                  
  3170                                  SKIPSTRINGEND:
  3171 000009BB AC                      		lodsb
  3172                                  NOTMATCH:
  3173 000009BC 3C0D                    		cmp	al,0Dh
  3174                                  IFERRORJ2:
  3175 000009BE 74B3                    		jz	short IFERRJ
  3176 000009C0 E8C00F                  		call	DELIM
  3177 000009C3 75F6                    		jnz	short SKIPSTRINGEND
  3178                                  
  3179                                  ; Signal that we did NOT have a match
  3180                                  
  3181 000009C5 B0FF                    		mov	al,-1
  3182 000009C7 EB3A                    		jmp	short IFRET
  3183                                  IFERRPJ:
  3184 000009C9 E95CFF                  		jmp	IFERRORP
  3185                                  
  3186                                  ; The compare succeeded. Was the second string longer than the first?
  3187                                  ; We do this by seeing if the next char is a delimiter.
  3188                                  
  3189                                  MATCH:
  3190 000009CC AC                      		lodsb
  3191 000009CD E8B30F                  		call	DELIM
  3192 000009D0 75EA                    		jnz	short NOTMATCH ; not same.
  3193 000009D2 30C0                    		xor	al,al
  3194 000009D4 EB2D                    		jmp	short IFRET
  3195                                  
  3196                                  ; ---------------------------------------------------------------------------
  3197                                  
  3198                                  IFEXISTS:
  3199                                  
  3200                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3201                                  
  3202                                  ;MOREDELIM:
  3203 000009D6 AC                      		lodsb
  3204 000009D7 E8A90F                  		call	DELIM
  3205 000009DA 75FA                    		jnz	short IFEXISTS
  3206                                  		;jnz	short MOREDELIM
  3207                                  
  3208 000009DC BA[6A43]                		mov	dx,DIRBUF
  3209 000009DF B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3210 000009E2 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3211                                  				; DS:DX	-> disk	transfer buffer
  3212 000009E4 BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3213 000009E7 031E[F54B]              		add	bx,[IF_NOT_COUNT]
  3214                                  		;mov	ax,ARG_ARGV
  3215                                  		;mov	ax,ARG+ARG_UNIT.argv
  3216 000009EB B8[A945]                		mov	ax,ARG
  3217 000009EE E8E91A                  		call	ARGV_CALC	; convert arg index to pointer
  3218 000009F1 8B17                    		mov	dx,[bx]
  3219                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3220                                  		;mov	cx,6
  3221 000009F3 B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3222 000009F6 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3223 000009F9 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3224                                  				; CX = search attributes
  3225                                  				; DS:DX	-> ASCIZ filespec
  3226                                  				; (drive,path, and wildcards allowed)
  3227 000009FB 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3228 000009FD 30C0                    		xor	al,al
  3229 000009FF EB02                    		jmp	short IFRET
  3230                                  
  3231                                  		;nop
  3232                                  IF_EX_C:
  3233 00000A01 B0FF                    		mov	al,-1		; false 'n' fall through...
  3234                                  IFRET:
  3235 00000A03 F606[8442]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3236 00000A08 7402                    		jz	short REALTEST
  3237 00000A0A F6D0                    		not	al
  3238                                  REALTEST:
  3239 00000A0C 08C0                    		or	al,al
  3240 00000A0E 7403                    		jz	short IFTRUE
  3241 00000A10 E9F1F6                  		jmp	TCOMMAND
  3242                                  
  3243                                  IFTRUE:
  3244 00000A13 E8650F                  		call	SCANOFF
  3245 00000A16 89F1                    		mov	cx,si
  3246 00000A18 81E98100                		sub	cx,81h
  3247 00000A1C 280E8000                		sub	[80h],cl
  3248 00000A20 8A0E8000                		mov	cl,[80h]
  3249 00000A24 880E[D140]              		mov	[COMBUF+1],cl
  3250 00000A28 BF[D240]                		mov	di,COMBUF+2
  3251 00000A2B FC                      		cld
  3252 00000A2C F3A4                    		rep movsb
  3253 00000A2E B00D                    		mov	al,0Dh
  3254 00000A30 AA                      		stosb
  3255                                  
  3256                                  ; Signal that an IF was done. 
  3257                                  ; This prevents the redirections from getting lost.
  3258                                  
  3259 00000A31 1E                      		push	ds
  3260 00000A32 8E1E[7142]              		mov	ds,[RESSEG]
  3261 00000A36 C606F80BFF              		mov	byte [IFFLAG],-1
  3262 00000A3B 1F                      		pop	ds
  3263                                  
  3264                                  ; Go do the command
  3265                                  
  3266 00000A3C E96EF8                  		jmp	DOCOM1
  3267                                  
  3268                                  ; ---------------------------------------------------------------------------
  3269                                  
  3270                                  IFERRORJ3:
  3271 00000A3F E97CFF                  		jmp	IFERRORJ2
  3272                                  
  3273                                  IFERLEV:
  3274 00000A42 B70A                    		mov	bh,10
  3275 00000A44 30DB                    		xor	bl,bl
  3276                                  GETNUMLP:
  3277 00000A46 AC                      		lodsb
  3278 00000A47 3C0D                    		cmp	al,0Dh
  3279 00000A49 74F4                    		jz	short IFERRORJ3
  3280 00000A4B E8350F                  		call	DELIM
  3281 00000A4E 740C                    		jz	short GOTNUM
  3282 00000A50 2C30                    		sub	al,'0'
  3283 00000A52 86C3                    		xchg	al,bl
  3284 00000A54 F6E7                    		mul	bh
  3285 00000A56 00D8                    		add	al,bl
  3286 00000A58 86C3                    		xchg	al,bl
  3287 00000A5A EBEA                    		jmp	short GETNUMLP
  3288                                  GOTNUM:
  3289 00000A5C 1E                      		push	ds
  3290 00000A5D 8E1E[7142]              		mov	ds,[RESSEG]
  3291 00000A61 8A26EA0B                		mov	ah,byte [RETCODE]  ; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3292 00000A65 1F                      		pop	ds
  3293 00000A66 30C0                    		xor	al,al
  3294 00000A68 38DC                    		cmp	ah,bl
  3295 00000A6A 7397                    		jnb	short IFRET
  3296 00000A6C FEC8                    		dec	al
  3297 00000A6E EB93                    		jmp	short IFRET
  3298                                  
  3299                                  ; ---------------------------------------------------------------------------
  3300                                  
  3301                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3302                                  ; This is a NOP if no batch in progress.
  3303                                  
  3304                                  SHIFT:
  3305 00000A70 8E1E[7142]              		mov	ds,[RESSEG]
  3306 00000A74 A1970B                  		mov	ax,word [BATCH]	; get batch pointer
  3307 00000A77 09C0                    		or	ax,ax		; in batch mode?
  3308 00000A79 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3309                                  SHIFT_RETN:				; no, done.
  3310 00000A7B C3                      		retn
  3311                                  SHIFT1:
  3312 00000A7C 8EC0                    		mov	es,ax
  3313 00000A7E 8ED8                    		mov	ds,ax
  3314                                  
  3315                                  ; Now move the batch args down by 1 word
  3316                                  
  3317                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3318 00000A80 BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3319 00000A83 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3320 00000A86 B90900                  		mov	cx,9		; move 9 parameters
  3321 00000A89 F3A5                    		rep movsw		; SHIFT down
  3322                                  
  3323                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3324                                  ; We have copied it into the previous position.
  3325                                  
  3326 00000A8B 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3327 00000A8E 74EB                    		jz	short SHIFT_RETN ; No new parm
  3328                                  
  3329                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3330                                  ; Assume, first, that there is no next argument.
  3331                                   
  3332 00000A90 8B35                    		mov	si,[di]
  3333 00000A92 C705FFFF                		mov	word [di],-1	; Assume no parm
  3334                                  
  3335                                  ; The parameters are CR separated. Scan for end of this parm.
  3336                                  
  3337                                  SKIPCRLP:
  3338 00000A96 AC                      		lodsb
  3339 00000A97 3C0D                    		cmp	al,0Dh
  3340 00000A99 75FB                    		jnz	short SKIPCRLP
  3341                                  
  3342                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3343                                  ; are finished. There are no more parms and the pointer has been previously
  3344                                  ; initialized to indicate it.
  3345                                  
  3346 00000A9B 803C00                  		cmp	byte [si],0
  3347 00000A9E 74DB                    		jz	short SHIFT_RETN ; End of parms
  3348 00000AA0 8935                    		mov	[di],si		; Pointer to next parm as %9
  3349 00000AA2 C3                      		retn
  3350                                  
  3351                                  ; =============== S U B	R O U T	I N E =======================================
  3352                                  
  3353                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3354                                  ; returns char in AL, carry set -> eof
  3355                                  
  3356                                  SKIPDELIM:
  3357 00000AA3 F706970BFFFF            		test	word [BATCH],-1	; batch file empty.  OOPS!
  3358 00000AA9 740A                    		jz	short SKIPERR
  3359 00000AAB E8DFFD                  		call	GETBATBYT	; get a char
  3360 00000AAE E8D20E                  		call	DELIM		; check for ignoreable chars
  3361 00000AB1 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3362 00000AB3 F8                      		clc
  3363 00000AB4 C3                      		retn
  3364                                  SKIPERR:
  3365 00000AB5 F9                      		stc
  3366                                  GOTO_RETN:
  3367 00000AB6 C3                      		retn
  3368                                  
  3369                                  ; ---------------------------------------------------------------------------
  3370                                  
  3371                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3372                                  ;  .com file. This routine strips the CALL off the command line, sets
  3373                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3374                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3375                                  ;  being CALLed.
  3376                                  
  3377                                  _$CALL:
  3378                                  
  3379                                  ;  strip off CALL from command line
  3380                                  
  3381                                  		;ASSUME DS:trangroup,ES:trangroup
  3382                                  
  3383 00000AB7 56                      		push	si
  3384 00000AB8 57                      		push	di
  3385 00000AB9 50                      		push	ax
  3386 00000ABA 51                      		push	cx
  3387 00000ABB BE[D240]                		mov	si,COMBUF+2
  3388 00000ABE E8BA0E                  		call	SCANOFF		;get to first non-delimeter
  3389                                  		;add	si,4
  3390 00000AC1 83C604                  		add	si,length_call	;point to char past CALL
  3391 00000AC4 BF[D240]                		mov	di,COMBUF+2
  3392                                  		;mov	cx,124		
  3393 00000AC7 B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3394 00000ACA F3A4                    		rep movsb		;move it
  3395 00000ACC 59                      		pop	cx
  3396 00000ACD 58                      		pop	ax
  3397 00000ACE 5F                      		pop	di
  3398 00000ACF 5E                      		pop	si
  3399                                  
  3400                                  ;  set call flag to indicate call in progress
  3401                                  
  3402 00000AD0 1E                      		push	ds
  3403 00000AD1 8E1E[7142]              		mov	ds,[RESSEG]
  3404 00000AD5 C606FE0B01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3405 00000ADA C606FF0B01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3406                                  
  3407                                  ; Turn off any pipes in progress.
  3408                                  
  3409 00000ADF 803E5B0C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3410 00000AE4 7403                    		jz	short _NOPIPE
  3411 00000AE6 E82F14                  		call	PIPEDEL
  3412                                  _NOPIPE:
  3413 00000AE9 1F                      		pop	ds
  3414 00000AEA C3                      		retn
  3415                                  
  3416                                  ; ---------------------------------------------------------------------------
  3417                                  
  3418                                  GOTO:
  3419 00000AEB 8E1E[7142]              		mov	ds,[RESSEG]
  3420 00000AEF F706970BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3421 00000AF5 74BF                    		jz	short GOTO_RETN
  3422 00000AF7 31D2                    		xor	dx,dx
  3423 00000AF9 1E                      		push	ds
  3424 00000AFA 8E1E970B                		mov	ds,word [BATCH]
  3425 00000AFE 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3426 00000B02 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3427                                  
  3428                                  		; MSDOS 6.0
  3429                                  ;M037
  3430                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3431                                  ;
  3432                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3433                                  
  3434                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3435                                  
  3436 00000B06 1F                      		pop	ds
  3437                                  GOTOOPEN:
  3438 00000B07 E8ADF9                  		call	PROMPTBAT
  3439                                  		;mov	di,5Dh
  3440 00000B0A BF5D00                  		mov	di,FCB+1	; Get the label
  3441 00000B0D B90B00                  		mov	cx,11
  3442 00000B10 B020                    		mov	al,' '
  3443 00000B12 F2AE                    		repne scasb
  3444 00000B14 7501                    		jnz	short NOINC
  3445 00000B16 41                      		inc	cx
  3446                                  NOINC:
  3447 00000B17 83E90B                  		sub	cx,11
  3448 00000B1A F7D9                    		neg	cx
  3449 00000B1C 2E890E[6A43]            		mov	[cs:GOTOLEN],cx
  3450                                  
  3451                                  ; At beginning of file. Skip to first non-delimiter char
  3452                                  
  3453 00000B21 E87FFF                  		call	SKIPDELIM
  3454 00000B24 721C                    		jb	short BADGOTO
  3455 00000B26 3C3A                    		cmp	al,':'
  3456 00000B28 7423                    		jz	short CHKLABEL
  3457                                  LABLKLP:				; Look for the label
  3458 00000B2A E860FD                  		call	GETBATBYT
  3459 00000B2D 3C0A                    		cmp	al,0Ah
  3460 00000B2F 7509                    		jnz	short LABLKTST
  3461                                  
  3462                                  ; At beginning of line.  Skip to first non-delimiter char
  3463                                  
  3464 00000B31 E86FFF                  		call	SKIPDELIM
  3465 00000B34 720C                    		jb	short BADGOTO
  3466 00000B36 3C3A                    		cmp	al,':'
  3467 00000B38 7413                    		jz	short CHKLABEL
  3468                                  LABLKTST:
  3469 00000B3A F706970BFFFF            		test	word [BATCH],0FFFFh ; -1
  3470 00000B40 75E8                    		jnz	short LABLKLP
  3471                                  BADGOTO:
  3472 00000B42 E85000                  		call	BATCLOSE
  3473                                  
  3474                                  		; MSDOS 6.0
  3475                                  ;SR;
  3476                                  ; At this point we are terminating without freeing up any nested batch 
  3477                                  ;segments i.e if the error occurred within a called batch file. This routine
  3478                                  ;will traverse the linked list of batch segments and free all of them.
  3479                                  ;
  3480                                  		;call	free_batch	;free up nested batch segments
  3481                                  
  3482                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3483 00000B45 0E                      		push	cs
  3484 00000B46 1F                      		pop	ds
  3485 00000B47 BA[673C]                		mov	dx,BADLABPTR
  3486 00000B4A E9DE10                  		jmp	CERROR
  3487                                  
  3488                                  ; Found the :.	Skip to first non-delimiter char
  3489                                  
  3490                                  CHKLABEL:
  3491 00000B4D E853FF                  		call	SKIPDELIM
  3492 00000B50 72F0                    		jb	short BADGOTO
  3493 00000B52 BF5D00                  		mov	di,FCB+1 ; 5Dh
  3494 00000B55 2E8B0E[6A43]            		mov	cx,[cs:GOTOLEN]
  3495 00000B5A EB05                    		jmp	short GOTBYTE
  3496                                  
  3497                                  NEXTCHRLP:
  3498 00000B5C 51                      		push	cx
  3499 00000B5D E82DFD                  		call	GETBATBYT
  3500 00000B60 59                      		pop	cx
  3501                                  GOTBYTE:
  3502 00000B61 0C20                    		or	al,20h
  3503 00000B63 263A05                  		cmp	al,[es:di]
  3504 00000B66 7502                    		jnz	short TRYUPPER
  3505 00000B68 EB07                    		jmp	short NEXTLABCHR
  3506                                  TRYUPPER:
  3507 00000B6A 2C20                    		sub	al,20h
  3508 00000B6C 263A05                  		cmp	al,[es:di]
  3509 00000B6F 75C9                    		jnz	short LABLKTST
  3510                                  NEXTLABCHR:
  3511 00000B71 47                      		inc	di
  3512 00000B72 E2E8                    		loop	NEXTCHRLP
  3513 00000B74 E816FD                  		call	GETBATBYT
  3514 00000B77 2E833E[6A43]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3515 00000B7D 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3516 00000B7F 3C20                    		cmp	al,' '
  3517 00000B81 77B7                    		ja	short LABLKTST
  3518                                  GOTOCONT:
  3519 00000B83 3C0D                    		cmp	al,0Dh
  3520 00000B85 7407                    		jz	short SKIPLFEED
  3521                                  TONEXTBATLIN:
  3522 00000B87 E803FD                  		call	GETBATBYT
  3523 00000B8A 3C0D                    		cmp	al,0Dh
  3524 00000B8C 75F9                    		jnz	short TONEXTBATLIN
  3525                                  SKIPLFEED:
  3526 00000B8E E8FCFC                  		call	GETBATBYT
  3527                                  
  3528                                  		; MSDOS 6.0
  3529                                  ;SR;
  3530                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3531                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3532                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3533                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3534                                  ;all other cases, EOF will be hit while trying to read the next line and
  3535                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3536                                  ;
  3537                                  		;push	es
  3538                                  		;mov	es,Batch
  3539                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3540                                  		;pop	es
  3541                                  
  3542                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3543 00000B91 E80100                  		call	BATCLOSE
  3544 00000B94 C3                      		retn
  3545                                  
  3546                                  ; =============== S U B	R O U T	I N E =======================================
  3547                                  
  3548                                  BATCLOSE:
  3549 00000B95 2E8B1E[9545]            		mov	bx,[cs:BATHAND]
  3550 00000B9A 83FB05                  		cmp	bx,5
  3551 00000B9D 7204                    		jb	short CLOSERETURN
  3552 00000B9F B43E                    		mov	ah,CLOSE ; 3Eh
  3553 00000BA1 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3554                                  				; BX = file handle
  3555                                  CLOSERETURN:
  3556 00000BA3 C606E20B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3557 00000BA8 C3                      		retn
  3558                                  
  3559                                  ; =============== S U B	R O U T	I N E =======================================
  3560                                  
  3561                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3562                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3563                                  
  3564                                  BATOPEN:
  3565 00000BA9 1E                      		push	ds
  3566 00000BAA 8E1E970B                		mov	ds,word [BATCH]
  3567                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3568 00000BAE BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3569 00000BB1 B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3570 00000BB4 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3571                                  				; DS:DX	-> ASCIZ filename
  3572                                  				; AL = access mode
  3573                                  				; 0 - read
  3574 00000BB6 721C                    		jb	short SETERRDL
  3575 00000BB8 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3576 00000BBC 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3577 00000BC0 1F                      		pop	ds
  3578 00000BC1 2EA3[9545]              		mov	[cs:BATHAND],ax
  3579 00000BC5 89C3                    		mov	bx,ax
  3580 00000BC7 B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3581 00000BCA CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3582                                  				; AL = method: offset from beginning of	file
  3583                                  
  3584 00000BCC 2EC706[184D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3585                                  BATOPEN_RETN:
  3586 00000BD3 C3                      		retn
  3587                                  
  3588                                  SETERRDL:
  3589 00000BD4 89D3                    		mov	bx,dx
  3590                                  		; MSDOS 6.0
  3591                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3592                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3593                                  
  3594                                  		; MSDOS 3.3
  3595 00000BD6 BA[9E37]                		mov	dx,INSERTDSKPTR
  3596 00000BD9 E8F012                  		call	GET_EXT_ERR_NUMBER
  3597                                  
  3598                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3599 00000BDC 8A07                    		mov	al,[bx]		; Get drive spec
  3600 00000BDE 2C40                    		sub	al,'@'		; A = 1
  3601 00000BE0 1F                      		pop	ds
  3602 00000BE1 F9                      		stc			; SUB mucked over carry
  3603 00000BE2 C3                      		retn
  3604                                  
  3605                                  ;============================================================================
  3606                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3607                                  ;============================================================================
  3608                                  ; 10/10/2018 - Retro DOS v3.0
  3609                                  
  3610                                  ; All batch proccessing has DS set to segment of resident portion
  3611                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3612                                  
  3613                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3614                                  
  3615                                  ; ---------------------------------------------------------------------------
  3616                                  
  3617                                  FORTERM:
  3618                                  		; MSDOS 6.0
  3619                                  		;push	cs		;AN037; Get local segment into
  3620                                  		;pop	ds		;AN037;    DS, ES
  3621                                  		;push	cs		;AN037;
  3622                                  		;pop	es		;AN037;
  3623                                  
  3624                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3625 00000BE3 E8B502                  		call	FOROFF
  3626 00000BE6 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  3627 00000BEB 813EF30B00FF            		cmp	word [SINGLECOM],0FF00h
  3628 00000BF1 750F                    		jne	short BAT_CRLF
  3629 00000BF3 833EFC0B00              		cmp	word [NEST],0	;See if we have nested batch files
  3630 00000BF8 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3631 00000BFA C706F30BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3632 00000C00 EB12                    		jmp	short NOFORP2
  3633                                  BAT_CRLF:
  3634 00000C02 F606ED0B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3635 00000C07 740B                    		jz	short NOFORP2	; no - exit
  3636 00000C09 F706970BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3637 00000C0F 7403                    		jz	short NOFORP2
  3638 00000C11 E85A0D                  		call	CRLF2
  3639                                  NOFORP2:
  3640 00000C14 E9EDF4                  		jmp	TCOMMAND
  3641                                  
  3642                                  ; ---------------------------------------------------------------------------
  3643                                  
  3644                                  ;------
  3645                                  ;   For-loop processing.  For loops are of the form:
  3646                                  ;	    for %<loop-variable> in (<list>) do <command>
  3647                                  ; where <command> may contain references of the form %<variable>, which are
  3648                                  ; later substituted with the items in <list>. The for-loop structure is
  3649                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3650                                  ; <command> once for each item in <list>. All of the information needed for
  3651                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3652                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3653                                  ; a complete copy of the original command-line structure as parsed by
  3654                                  ; 'parseline', loop control variables, and a dma buffer for the
  3655                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3656                                  ; processing has completed, this chunk of memory is returned to the system.
  3657                                  ;
  3658                                  ;   All of the previously defined variables, in 'datares', used for loop
  3659                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3660                                  ;
  3661                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3662                                  ; containing all of the other error messages.
  3663                                  ;
  3664                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3665                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3666                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3667                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3668                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3669                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3670                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3671                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3672                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3673                                  ; instead of
  3674                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3675                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3676                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3677                                  ; doesn't matter whether we put brackets around the location or not -- the
  3678                                  ; assembler is "smart" enough to know that we want an address instead of the
  3679                                  ; contents of that location.
  3680                                  ;
  3681                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3682                                  ; One method would be to have a link field in each for-structure pointing to
  3683                                  ; its parent.  Variable references that couldn't be resolved in the local
  3684                                  ; frame would cause a search of prior frames. For-structures would still be
  3685                                  ; allocated and released in exactly the same fashion. The only limit on the
  3686                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3687                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3688                                  ; maintained in the resident data area. This structure would be an array of
  3689                                  ; control-variable names and pointers to for-structure blocks. This would
  3690                                  ; greatly speed up the resolution of non-local variable references. However,
  3691                                  ; since space in the resident is precious, we would have to compromise on a
  3692                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3693                                  ; allocation and de-allocation would have to be modified slightly to take this
  3694                                  ; new structure into account.
  3695                                  ;
  3696                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3697                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3698                                  ; it may be easier to allocate it as part of 'for_segment'.
  3699                                  ;------
  3700                                  
  3701                                  		; include fordata.asm
  3702                                  
  3703                                  ; Data structure definitions included by tfor.asm
  3704                                  
  3705                                  struc FOR_INFO
  3706 00000000 <res 00000544>            .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3707 00000544 <res 00000001>            .FOR_COM_START: resb  1		; beginning of <command>
  3708 00000545 <res 00000002>            .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3709 00000547 <res 00000002>            .FOR_MINARG:	  resw  1		; beginning of <list>
  3710 00000549 <res 00000002>            .FOR_MAXARG:	  resw  1		; end of <list>
  3711 0000054B <res 00000080>            .FORBUF:	  resw  64		; temporary buffer
  3712 000005CB <res 00000080>            .FORDMA:	  resw  64		; FindFirst/Next buffer
  3713 0000064B <res 00000001>            .FOR_VAR:	  resb  1		; loop control variable
  3714                                    .size:
  3715                                  endstruc
  3716                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3717                                  
  3718                                  _$FOR_EXIT:
  3719 00000C17 EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3720                                  
  3721                                  ; ---------------------------------------------------------------------------
  3722                                  
  3723                                  FORPROC:
  3724 00000C19 A1FA0B                  		mov	ax,word [FORPTR]
  3725 00000C1C 8ED8                    		mov	ds,ax
  3726 00000C1E 8EC0                    		mov	es,ax		; operate in for-info area
  3727 00000C20 BACB05                  		mov	dx,FOR_INFO.FORDMA
  3728 00000C23 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3729 00000C26 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3730                                  				; DS:DX	-> disk	transfer buffer
  3731                                  FOR_BEGIN:
  3732 00000C28 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3733 00000C2D 7404                    		jz	short FOR_BEGIN1
  3734                                  					; non-zero for_expand equals FALSE
  3735 00000C2F FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3736                                  
  3737                                  FOR_BEGIN1:
  3738 00000C33 8B1E4705                		mov	bx,word [FOR_INFO.FOR_MINARG]
  3739                                  					; current item in <list> to examine
  3740 00000C37 3B1E4905                		cmp	bx,word [FOR_INFO.FOR_MAXARG]	; [549h]
  3741 00000C3B 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3742                                  		;mov	ax,0
  3743 00000C3D B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3744 00000C40 E89718                  		call	ARGV_CALC	; compute argv[x] address
  3745                                  		;mov	cx,[bx+3]
  3746 00000C43 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3747 00000C46 8B17                    		mov	dx,[bx]
  3748                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3749                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3750 00000C48 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3751 00000C4C 7516                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3752 00000C4E 8B37                    		mov	si,[bx]
  3753                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3754                                  
  3755 00000C50 2EA0[F53E]              		mov	al,[cs:LPAREN]
  3756 00000C54 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3757 00000C57 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3758 00000C59 41                      		inc	cx		;  the opening paren as its first char,
  3759                                  					;  the argstartel ptr needs to be
  3760                                  					;  advanced passed it before the prefix
  3761                                  					;  length is computed.
  3762 00000C5A B03A                    		mov	al,':'
  3763 00000C5C 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3764 00000C5F 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3765 00000C61 83C102                  		add	cx,2		;  rest of the prefix as well.
  3766                                  FORSUB:
  3767 00000C64 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3768 00000C66 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3769 00000C6B 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3770                                  		;test	byte [bx+2],2
  3771 00000C6D F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3772 00000C71 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3773                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3774 00000C73 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3775 00000C76 EB1F                    		jmp	short FOR_SMOOSH
  3776                                  
  3777                                  		;nop
  3778                                  FOR_FIND_FIRST:
  3779 00000C78 51                      		push	cx
  3780 00000C79 31C9                    		xor	cx,cx
  3781 00000C7B B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3782 00000C7E CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3783                                  				; CX = search attributes
  3784                                  				; DS:DX	-> ASCIZ filespec
  3785                                  				; (drive,path, and wildcards allowed)
  3786 00000C80 59                      		pop	cx
  3787 00000C81 EB05                    		jmp	short FOR_RESULT
  3788                                  
  3789                                  		;nop
  3790                                  FOR_FIND_NEXT:
  3791 00000C83 B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3792 00000C86 CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3793                                  				; [DTA]	= data block from
  3794                                  				; last AH = 4Eh/4Fh call
  3795                                  FOR_RESULT:
  3796 00000C88 B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3797 00000C8B 7203                    		jc	short FOR_CHECK
  3798 00000C8D B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3799                                  FOR_CHECK:				; record success of findfirst/next
  3800 00000C90 A34505                  		mov	word [FOR_INFO.FOR_EXPAND],ax
  3801 00000C93 09C0                    		or	ax,ax	; anything out there?
  3802 00000C95 7591                    		jnz	short FOR_BEGIN	; if not, try next arg
  3803                                  FOR_SMOOSH:
  3804                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3805 00000C97 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3806 00000C99 BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3807 00000C9C F3A4                    		rep movsb		; arg, some days just the path prefix
  3808                                  					
  3809 00000C9E 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3810                                  					; if we're not expanding, we can
  3811 00000CA3 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3812                                  
  3813                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3814 00000CA5 BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3815                                  FOR_MORE:
  3816 00000CA8 803C00                  		cmp	byte [si],0	; tack on matching filename
  3817 00000CAB 7403                    		jz	short FOR_MAKE_COM
  3818 00000CAD A4                      		movsb
  3819 00000CAE 75F8                    		jnz	short FOR_MORE
  3820                                  FOR_MAKE_COM:
  3821 00000CB0 30C0                    		xor	al,al		; tack a null byte onto the end
  3822 00000CB2 AA                      		stosb			; of the substitute string
  3823 00000CB3 31C9                    		xor	cx,cx		; character count for command line
  3824 00000CB5 F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3825 00000CB7 31DB                    		xor	bx,bx		; argpointer
  3826 00000CB9 BF[D240]                		mov	di,COMBUF+2
  3827 00000CBC 8A1E4405                		mov	bl,byte [FOR_INFO.FOR_COM_START] ; argindex
  3828 00000CC0 8A364B06                		mov	dh,byte [FOR_INFO.FOR_VAR] 
  3829                                  					; %<for-var> is replaced by [forbuf]
  3830 00000CC4 0E                      		push	cs		; time to form the <command> string
  3831 00000CC5 07                      		pop	es
  3832                                  		;assume ES:trangroup
  3833                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3834 00000CC6 B80000                  		mov	ax,0		; translate offset to pointer
  3835 00000CC9 E80E18                  		call	ARGV_CALC
  3836                                  		;mov	si,[bx+9]
  3837 00000CCC 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3838                                  					; mov ptr passed beginning space
  3839 00000CCF 46                      		inc	si
  3840                                  FOR_MAKE_LOOP:
  3841 00000CD0 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3842 00000CD2 46                      		inc	si
  3843 00000CD3 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3844 00000CD5 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3845 00000CD7 3834                    		cmp	[si],dh		; got the right <variable>?
  3846 00000CD9 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3847 00000CDB 46                      		inc	si		; skip over <for-variable>
  3848                                  
  3849 00000CDC 56                      		push	si
  3850 00000CDD BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3851                                  					; to make a final <command> to execute
  3852                                  SLOOP:					
  3853 00000CE0 AC                      		lodsb			; grab all those <item> bytes, and
  3854 00000CE1 AA                      		stosb			; add 'em to the <command> string,
  3855 00000CE2 08C0                    		or	al,al		; until we run into a null
  3856 00000CE4 E0FA                    		loopne	SLOOP
  3857 00000CE6 4F                      		dec	di		; adjust length and <command> pointer
  3858 00000CE7 41                      		inc	cx		; so we can overwrite the null
  3859 00000CE8 5E                      		pop	si
  3860 00000CE9 EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3861                                  
  3862                                  FOR_STOSB:
  3863 00000CEB AA                      		stosb			; take a byte from the <command> arg
  3864 00000CEC 49                      		dec	cx		; and put it into the <command> to be
  3865                                  					; executed (and note length, too)
  3866 00000CED 3C0D                    		cmp	al,0Dh		
  3867 00000CEF 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3868                                  FOR_MADE_COM:
  3869 00000CF1 F6D1                    		not	cl
  3870 00000CF3 2E880E[D140]            		mov	[cs:COMBUF+1],cl
  3871                                  
  3872 00000CF8 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  3873                                  		;assume DS:resgroup
  3874 00000CFD F606ED0B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3875 00000D02 742F                    		jz	short NOECHO3
  3876                                  		;cmp	byte [NULLFLAG],nullcommand
  3877 00000D04 803E020C01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3878 00000D09 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3879                                  
  3880 00000D0B E8600C                  		call	CRLF2		  ;G  Print out prompt
  3881                                  NO_CRLF_PR:
  3882 00000D0E C606020C00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3883 00000D13 0E                      		push	cs
  3884 00000D14 1F                      		pop	ds
  3885 00000D15 57                      		push	di
  3886 00000D16 E87106                  		call	PRINT_PROMPT	  ;G Prompt the user
  3887 00000D19 5F                      		pop	di
  3888                                  
  3889 00000D1A 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3890 00000D1F C706[4E44][D240]        		mov	word [STRING_PTR_2],COMBUF+2
  3891 00000D25 BA[3F37]                		mov	dx,STRINGBUF2PTR
  3892 00000D28 E8A827                  		call	STD_PRINTF
  3893 00000D2B 26C645FF0D              		mov	byte [es:di-1],0Dh
  3894 00000D30 E977F5                  		jmp	DOCOM		  ; run silent, run deep...
  3895                                  NOECHO3:
  3896 00000D33 C606020C00              		mov	byte [NULLFLAG],0
  3897 00000D38 0E                      		push	cs
  3898 00000D39 1F                      		pop	ds
  3899 00000D3A E970F5                  		jmp	DOCOM1
  3900                                  
  3901                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3902 00000D3D E85B01                  		call	FOROFF
  3903 00000D40 E93E01                  		jmp	FORNESTERR
  3904                                  
  3905                                  ; ---------------------------------------------------------------------------
  3906                                  
  3907                                  FORERRORJ:
  3908 00000D43 E9E3FB                  		jmp	FORERROR
  3909                                  
  3910                                  ; ---------------------------------------------------------------------------
  3911                                  
  3912                                  _$FOR:
  3913 00000D46 8E06[7142]              		mov	es,[RESSEG]
  3914 00000D4A 26803EF90B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3915 00000D50 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3916                                  
  3917                                  ; Turn off any pipes in progress.
  3918                                  
  3919 00000D52 26803E5B0C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3920 00000D58 7403                    		jz	short NO_PIPE
  3921 00000D5A E8BB11                  		call	PIPEDEL
  3922                                  NO_PIPE:
  3923 00000D5D 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3924 00000D5F E80901                  		call	NEXTARG		; move to next argv[n]
  3925 00000D62 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3926 00000D64 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3927 00000D66 75DB                    		jnz	short FORERRORJ
  3928 00000D68 89C5                    		mov	bp,ax		; save forloop variable
  3929 00000D6A AC                      		lodsb
  3930 00000D6B 08C0                    		or	al,al		; and MUST end immediately...
  3931 00000D6D 75D4                    		jnz	short FORERRORJ
  3932 00000D6F E8F900                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3933 00000D72 72CF                    		jb	short FORERRORJ
  3934                                  		;and	ax,0DFDFh
  3935 00000D74 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3936 00000D77 3B06[F93E]              		cmp	ax,word [IN_WORD]
  3937 00000D7B 75C6                    		jnz	short FORERRORJ
  3938 00000D7D AC                      		lodsb
  3939                                  
  3940                                  		; MSDOS 3.3
  3941 00000D7E 08C0                    		or	al,al		; it, too, must end right away
  3942 00000D80 7416                    		jz	short CHECKLPAREN
  3943 00000D82 3A06[F53E]              		cmp	al,[LPAREN]
  3944 00000D86 75BB                    		jnz	short FORERRORJ
  3945                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3946 00000D88 830702                  		add	word [bx],2
  3947                                  		;add	word [bx+9],2
  3948 00000D8B 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3949                                  		;sub	word [bx+5],2
  3950 00000D8F 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3951 00000D93 8B44FF                  		mov	ax,[si-1]
  3952 00000D96 EB05                    		jmp	short LPCHECK
  3953                                  
  3954                                  		; MSDOS 6.0
  3955                                  ;; Compaq bug fix -- exit from this loop on error
  3956                                  ;
  3957                                  ;		or	al,al
  3958                                  ;		jne	forerrorj	; jump on error
  3959                                  ;
  3960                                  ;;;		je	CheckLParen
  3961                                  ;;
  3962                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  3963                                  ;;   FOR %i in(foo bar...
  3964                                  ;; Check for the Lparen here
  3965                                  ;;
  3966                                  ;;;		CMP	AL,lparen
  3967                                  ;;;		JNZ	forerrorj
  3968                                  ;;
  3969                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  3970                                  ;; being there in the first place.
  3971                                  ;;
  3972                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  3973                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  3974                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  3975                                  ;;
  3976                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  3977                                  ;; current value.
  3978                                  ;;
  3979                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  3980                                  ;;;		jmp	short lpcheck
  3981                                  ;;
  3982                                  ;; end of Compaq bug fix
  3983                                  
  3984                                  ; ---------------------------------------------------------------------------
  3985                                  
  3986                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3987                                  CHECKLPAREN:
  3988 00000D98 E8D000                  		call	NEXTARG		; lparen delimits beginning of <list>
  3989 00000D9B 72A6                    		jc	short FORERRORJ
  3990                                  LPCHECK:
  3991 00000D9D 3A06[F53E]              		cmp	al,[LPAREN]
  3992 00000DA1 75A0                    		jne	short FORERRORJ
  3993 00000DA3 80FC00                  		cmp	ah,0
  3994 00000DA6 7411                    		je	short FOR_PAREN_TOKEN
  3995 00000DA8 3A26[F63E]              		cmp	ah,byte [RPAREN] ; special case:  null list	
  3996 00000DAC 7503                    		jne	short FOR_LIST_NOT_EMPTY
  3997 00000DAE E932FE                  		jmp	FORTERM
  3998                                  FOR_LIST_NOT_EMPTY:
  3999                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4000 00000DB1 FF07                    		inc	word [bx]	; Advance ptr past "("
  4001                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4002 00000DB3 FF4F05                  		dec	word [bx+ARGV_ELE.arglen] 	;  to agree.
  4003 00000DB6 46                      		inc	si		; Inc si so check for ")" works
  4004 00000DB7 EB11                    		jmp	short FOR_LIST
  4005                                  
  4006                                  		;nop
  4007                                  FOR_PAREN_TOKEN:
  4008 00000DB9 E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4009 00000DBC 7285                    		jc	short FORERRORJ
  4010                                  		;cmp	ax,[RPAREN+1]	
  4011 00000DBE 3B06[F73E]              		cmp	ax,[NULLRPAREN]	; special case:  null list
  4012 00000DC2 7506                    		jne	short FOR_LIST
  4013 00000DC4 E91CFE                  		jmp	FORTERM
  4014                                  
  4015                                  FORERORJJ:
  4016 00000DC7 E95FFB                  		jmp	FORERROR
  4017                                  
  4018                                  FOR_LIST:				; skip over rest of <list>
  4019 00000DCA 89D1                    		mov	cx,dx		; first arg of <list>
  4020                                  
  4021                                  SKIP_LIST:
  4022                                  		;add	si,[bx+5]
  4023 00000DCC 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4024 00000DCF 83EE03                  		sub	si,3		; si = ptr to last char of token
  4025 00000DD2 A0[F63E]                		mov	al,byte [RPAREN]
  4026 00000DD5 3804                    		cmp	[si],al		; Is this the last element in <list>
  4027 00000DD7 7407                    		je	short FOR_END_LIST ; Yes, exit loop.
  4028 00000DD9 E88F00                  		call	NEXTARG		; No, get next arg <list>
  4029 00000DDC 72E9                    		jc	short FORERORJJ	; If no more and no rparen, error.
  4030 00000DDE EBEC                    		jmp	short SKIP_LIST
  4031                                  
  4032                                  FOR_END_LIST:
  4033 00000DE0 89D7                    		mov	di,dx		; record position of last arg in <list>
  4034 00000DE2 C60400                  		mov	byte [si],0	; Zap the rparen
  4035                                  		;cmp	ax,[RPAREN+1]	
  4036 00000DE5 3B06[F73E]              		cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4037 00000DE9 7401                    		je	short FOR_DO	; Yes, continue
  4038 00000DEB 47                      		inc	di		; No, inc position of last arg
  4039                                  FOR_DO:
  4040 00000DEC E87C00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4041 00000DEF 72D6                    		jc	short FORERORJJ
  4042                                  		;and	ax,0DFDFh	
  4043 00000DF1 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4044 00000DF4 3B06[FB3E]              		cmp	ax,word [DO_WORD]
  4045 00000DF8 75CD                    		jne	short FORERORJJ
  4046 00000DFA AC                      		lodsb
  4047 00000DFB 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4048 00000DFD 75C8                    		jnz	short FORERORJJ
  4049                                  		
  4050 00000DFF E86900                  		call	NEXTARG		; on to the beginning of <command>
  4051 00000E02 72C3                    		jc	short FORERORJJ	; null <command> not legal
  4052                                  
  4053 00000E04 50                      		push	ax
  4054 00000E05 53                      		push	bx
  4055 00000E06 51                      		push	cx
  4056 00000E07 52                      		push	dx		; preserve registers against disaster
  4057 00000E08 57                      		push	di
  4058 00000E09 56                      		push	si
  4059 00000E0A 55                      		push	bp
  4060 00000E0B E852F8                  		call	FREE_TPA	; need to make free memory, first
  4061 00000E0E E88A00                  		call	FOROFF
  4062                                  		;mov	bx,264
  4063 00000E11 BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4064 00000E14 E8A519                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4065 00000E17 9C                      		pushf
  4066 00000E18 26A3FA0B                		mov	word [es:FORPTR],ax
  4067 00000E1C E851F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4068 00000E1F 9D                      		popf
  4069 00000E20 5D                      		pop	bp
  4070 00000E21 5E                      		pop	si
  4071 00000E22 5F                      		pop	di
  4072 00000E23 5A                      		pop	dx
  4073 00000E24 59                      		pop	cx
  4074 00000E25 5B                      		pop	bx
  4075 00000E26 58                      		pop	ax
  4076 00000E27 723C                    		jc	short FOR_ALLOC_ERR
  4077                                  
  4078 00000E29 06                      		push	es		; save resgroup seg...
  4079 00000E2A 26FF36FA0B              		push	word [es:FORPTR]
  4080 00000E2F 07                      		pop	es
  4081                                  		;assume ES:for_segment	
  4082 00000E30 49                      		dec	cx		; forproc wants min pointing before
  4083 00000E31 4F                      		dec	di		; first arg, max right at last one
  4084 00000E32 26890E4705              		mov	word [es:FOR_INFO.FOR_MINARG],cx
  4085 00000E37 26893E4905              		mov	word [es:FOR_INFO.FOR_MAXARG],di
  4086 00000E3C 2688164405              		mov	byte [es:FOR_INFO.FOR_COM_START],dl
  4087 00000E41 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4088 00000E48 89E8                    		mov	ax,bp
  4089 00000E4A 2688264B06              		mov	byte [es:FOR_INFO.FOR_VAR],ah
  4090 00000E4F 07                      		pop	es
  4091                                  		;assume ES:resgroup	
  4092 00000E50 26FE06F90B              		inc	byte [es:FORFLAG]
  4093 00000E55 26833EF30BFF            		cmp	word [es:SINGLECOM],-1
  4094 00000E5B 7507                    		jne	short FOR_RET
  4095 00000E5D 26C706F30B00FF          		mov	word [es:SINGLECOM],0FF00h
  4096                                  FOR_RET:
  4097 00000E64 C3                      		retn
  4098                                  
  4099                                  FOR_ALLOC_ERR:
  4100                                  		; MSDOS 3.0
  4101 00000E65 BA[AA3C]                		mov	dx,INSFMEMMESPTR
  4102 00000E68 E9C00D                  		jmp	CERROR
  4103                                  
  4104                                  		; MSDOS 6.0
  4105                                  		;mov	msg_disp_class,ext_msg_class	
  4106                                  		;			;AN000; set up extended error msg class
  4107                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4108                                  		;			;AC000; get extended message pointer
  4109                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4110                                  		;			;AN000; get message number in control block
  4111                                  		;jmp	cerror
  4112                                  
  4113                                  
  4114                                  ; =============== S U B	R O U T	I N E =======================================
  4115                                  
  4116                                  NEXTARG:
  4117 00000E6B 42                      		inc	dx		; next argv[n]
  4118                                  		;cmp	dx,[ARG_ARGVCNT]
  4119 00000E6C 3B16[6948]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4120 00000E70 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4121 00000E72 89D3                    		mov	bx,dx
  4122                                  		;mov	ax,ARG_ARGV
  4123                                  		;mov	ax,ARG+ARG_UNIT.argv
  4124 00000E74 B8[A945]                		mov	ax,ARG
  4125 00000E77 E86016                  		call	ARGV_CALC	; convert array index to pointer
  4126 00000E7A 8B37                    		mov	si,[bx]		; load pointer to argstring
  4127                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4128 00000E7C AD                      		lodsw			; and load first two chars
  4129 00000E7D F8                      		clc
  4130 00000E7E C3                      		retn
  4131                                  NEXTARG_ERR:
  4132 00000E7F F9                      		stc
  4133 00000E80 C3                      		retn
  4134                                  
  4135                                  ; ---------------------------------------------------------------------------
  4136                                  
  4137                                  FORNESTERR:
  4138 00000E81 1E                      		push	ds
  4139 00000E82 8E1E[7142]              		mov	ds,[RESSEG]
  4140                                  		;ASSUME DS:RESGROUP
  4141 00000E86 BA[923C]                		mov	dx,FORNESTMESTR
  4142 00000E89 813EF30B00FF            		cmp	word [SINGLECOM],0FF00h
  4143 00000E8F 7506                    		jnz	short NOFORP3
  4144 00000E91 C706F30BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4145                                  NOFORP3:
  4146 00000E97 1F                      		pop	ds
  4147 00000E98 E9900D                  		jmp	CERROR
  4148                                  
  4149                                  ; =============== S U B	R O U T	I N E =======================================
  4150                                  
  4151                                  ; General routine called to free the for segment. We also clear the forflag
  4152                                  ; too. Change no registers.
  4153                                  
  4154                                  FOROFF:
  4155 00000E9B 50                      		push	ax
  4156 00000E9C 06                      		push	es
  4157 00000E9D 2E8E06[7142]            		mov	es,[cs:RESSEG]
  4158 00000EA2 26A1FA0B                		mov	ax,word [es:FORPTR]
  4159 00000EA6 09C0                    		or	ax,ax
  4160 00000EA8 7408                    		jz	short FREEDONE
  4161 00000EAA 06                      		push	es
  4162 00000EAB 8EC0                    		mov	es,ax
  4163 00000EAD B449                    		mov	ah,DEALLOC ; 49h
  4164 00000EAF CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4165                                  				; ES = segment address of area to be freed
  4166 00000EB1 07                      		pop	es
  4167                                  FREEDONE:
  4168 00000EB2 26C706FA0B0000          		mov	word [es:FORPTR],0
  4169 00000EB9 26C606F90B00            		mov	byte [es:FORFLAG],0
  4170 00000EBF 07                      		pop	es
  4171 00000EC0 58                      		pop	ax
  4172 00000EC1 C3                      		retn
  4173                                  
  4174                                  ;============================================================================
  4175                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4176                                  ;============================================================================
  4177                                  ; 09/10/2018 - Retro DOS v3.0
  4178                                  
  4179                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4180                                  
  4181                                  ; ---------------------------------------------------------------------------
  4182                                  
  4183                                  ; The DIR command displays the contents of a directory.
  4184                                  ;
  4185                                  ; ****************************************************************
  4186                                  ; *
  4187                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4188                                  ; *
  4189                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4190                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4191                                  ; *		 If an error occurs issue and error message and
  4192                                  ; *		 transfer control to CERROR.
  4193                                  ; *
  4194                                  ; * INPUT:	 command line at offset 81H
  4195                                  ; *
  4196                                  ; * OUTPUT:	 none
  4197                                  ; *
  4198                                  ; ****************************************************************
  4199                                  
  4200                                  CATALOG:
  4201                                  		; MSDOS 3.3
  4202                                  
  4203                                  		;mov	ax,ARG_ARGV
  4204                                  		;mov	ax,ARG+ARG_UNIT.argv
  4205 00000EC2 B8[A945]                		mov	ax,ARG
  4206 00000EC5 BAFFFF                  		mov	dx,0FFFFh
  4207 00000EC8 31C9                    		xor	cx,cx
  4208 00000ECA 31F6                    		xor	si,si
  4209                                  
  4210                                  DIR1:
  4211                                  		;cmp	cx,[ARG_ARGVCNT]
  4212 00000ECC 3B0E[6948]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4213 00000ED0 733F                    		jnb	short DIR6 ; No more arguments
  4214 00000ED2 89CB                    		mov	bx,cx
  4215 00000ED4 E80316                  		call	ARGV_CALC
  4216                                  		;or	si,[bx+7]
  4217 00000ED7 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4218 00000EDA F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4219 00000EDE 7508                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4220                                  		;test	byte [bx+2],1
  4221 00000EE0 F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4222 00000EE4 7408                    		jz	short DIR3
  4223 00000EE6 EB26                    		jmp	short DIR5
  4224                                  DIR2:
  4225 00000EE8 BA[223A]                		mov	dx,BADPARMPTR
  4226 00000EEB E93D0D                  		jmp	CERROR
  4227                                  DIR3:
  4228 00000EEE 09C9                    		or	cx,cx
  4229 00000EF0 7515                    		jnz	short DIR4	
  4230                                  		;cmp	word [bx+5],3
  4231 00000EF2 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4232 00000EF6 7416                    		jz	short DIR5
  4233                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4234 00000EF8 830703                  		add	word [bx],3
  4235                                  		;add	word [bx+9],3
  4236 00000EFB 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4237                                  		;add	word [bx+3],3
  4238 00000EFF 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4239                                  		;sub	word [bx+5],3
  4240 00000F03 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4241                                  DIR4:
  4242 00000F07 83FAFF                  		cmp	dx,0FFFFh
  4243 00000F0A 75DC                    		jnz	short DIR2
  4244 00000F0C 89DA                    		mov	dx,bx
  4245                                  
  4246 00000F0E 41                      DIR5:		inc	cx
  4247 00000F0F EBBB                    		jmp	short DIR1
  4248                                  DIR6:
  4249 00000F11 8936[8842]              		mov	[COMSW],si
  4250 00000F15 52                      		push	dx
  4251 00000F16 30C0                    		xor	al,al
  4252 00000F18 83FAFF                  		cmp	dx,0FFFFh
  4253 00000F1B 7410                    		jz	short DIR7
  4254 00000F1D 89D3                    		mov	bx,dx
  4255                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4256 00000F1F 8B3F                    		mov	di,[bx]
  4257 00000F21 807D013A                		cmp	byte [di+1],':'
  4258 00000F25 7506                    		jnz	short DIR7
  4259 00000F27 8A05                    		mov	al,[di]
  4260 00000F29 0C20                    		or	al,20h		; Lowercase drive name	
  4261 00000F2B 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4262                                  DIR7:
  4263                                  		;mov	[5CH],al
  4264 00000F2D A25C00                  		mov	[FCB],al
  4265 00000F30 E80A04                  		call	OKVOLARG
  4266 00000F33 B03F                    		mov	al,'?'		; *.* is default file spec.
  4267                                  		;mov	di,5Dh
  4268 00000F35 BF5D00                  		mov	di,FCB+1
  4269 00000F38 B90B00                  		mov	cx,11
  4270 00000F3B F3AA                    		rep stosb
  4271                                  
  4272                                  ; Begin by processing any switches that may have been specified.
  4273                                  ; BITS will contain any information about switches that was
  4274                                  ; found when the command line was parsed.
  4275                                  
  4276 00000F3D A1[8842]                		mov	ax,[COMSW]	; Get switches from command
  4277 00000F40 A3[BC43]                		mov	word [_BITS],ax	; initialize switches
  4278 00000F43 C706[8842]0000          		mov	word [COMSW],0	; initialize flags
  4279 00000F49 C606[C443]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4280                                  		;test	al,1
  4281 00000F4E A801                    		test	al,SWITCHW	; /W ?
  4282                                  		;mov	al,1
  4283 00000F50 B001                    		mov	al,NORMPERLIN
  4284 00000F52 7402                    		jz	short DIR8
  4285                                  		;mov	al,5
  4286 00000F54 B005                    		mov	al,WIDEPERLIN
  4287                                  DIR8:
  4288 00000F56 A2[9842]                		mov	[LINLEN],al	; Set number of entries per line
  4289 00000F59 A2[9742]                		mov	[LINCNT],al
  4290 00000F5C C706[9942]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4291 00000F62 BA[6A43]                		mov	dx,DIRBUF
  4292 00000F65 B41A                    		mov	ah,SET_DMA ; 1Ah
  4293 00000F67 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4294                                  				; DS:DX	-> disk	transfer buffer
  4295                                  		;mov	dl,[5Ch]
  4296 00000F69 8A165C00                		mov	dl,[FCB]
  4297 00000F6D E8D809                  		call	SAVUDIR
  4298 00000F70 5B                      		pop	bx
  4299 00000F71 83FBFF                  		cmp	bx,0FFFFh
  4300 00000F74 7415                    		jz	short DIR9
  4301                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4302 00000F76 8B17                    		mov	dx,[bx]
  4303                                  
  4304                                  ; The user may have specified a device. Search for the path and see if the
  4305                                  ; attributes indicate a device.
  4306                                  
  4307 00000F78 B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4308 00000F7A CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4309                                  				; CX = search attributes
  4310                                  				; DS:DX	-> ASCIZ filespec
  4311                                  				; (drive,path, and wildcards allowed)
  4312 00000F7C 720F                    		jc	short DIR10
  4313                                  				; Check device atrribute..
  4314                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4315                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4316                                  		; 14/10/2018
  4317                                  		;test	byte [DIRBUF+21],40h
  4318 00000F7E F606[7F43]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4319 00000F83 7408                    		jz	short DIR10	; no, go do normal operation
  4320 00000F85 C706[8842]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4321                                  DIR9:
  4322 00000F8B EB7B                    		jmp	short DOHEADER
  4323                                  DIR10:
  4324                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4325 00000F8D 8B17                    		mov	dx,[bx]
  4326 00000F8F B43B                    		mov	ah,CHDIR ; 3Bh
  4327 00000F91 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4328                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4329 00000F93 7373                    		jnc	short DOHEADER
  4330                                  		;mov	si,[bx+3]
  4331 00000F95 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4332 00000F98 39F2                    		cmp	dx,si
  4333 00000F9A 7449                    		jz	short DIR_NO_DRIVE
  4334 00000F9C 30C9                    		xor	cl,cl
  4335 00000F9E 860C                    		xchg	cl,[si]
  4336 00000FA0 B43B                    		mov	ah,CHDIR ; 3Bh
  4337 00000FA2 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4338                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4339 00000FA4 860C                    		xchg	cl,[si]
  4340 00000FA6 733D                    		jnc	short DIR_NO_DRIVE
  4341 00000FA8 8A44FF                  		mov	al,[si-1]
  4342 00000FAB E8600A                  		call	PATHCHRCMP
  4343 00000FAE 7514                    		jnz	short DIR11
  4344 00000FB0 8A44FE                  		mov	al,[si-2]
  4345 00000FB3 E8580A                  		call	PATHCHRCMP
  4346 00000FB6 741E                    		jz	short DIR12
  4347 00000FB8 864CFF                  		xchg	cl,[si-1]
  4348 00000FBB B43B                    		mov	ah,CHDIR ; 3Bh
  4349 00000FBD CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4350                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4351 00000FBF 864CFF                  		xchg	cl,[si-1]
  4352 00000FC2 7321                    		jnc	short DIR_NO_DRIVE
  4353                                  DIR11:
  4354 00000FC4 B53A                    		mov	ch,':'
  4355 00000FC6 3A6CFF                  		cmp	ch,[si-1]
  4356 00000FC9 750B                    		jnz	short DIR12
  4357                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4358 00000FCB 8B0F                    		mov	cx,[bx]
  4359 00000FCD 87CE                    		xchg	cx,si
  4360 00000FCF 29F1                    		sub	cx,si
  4361 00000FD1 83F902                  		cmp	cx,2
  4362 00000FD4 740F                    		jz	short DIR_NO_DRIVE
  4363                                  DIR12:
  4364 00000FD6 BA[763B]                		mov	dx,BADCDPTR
  4365                                  		;test	byte [bx+2],4
  4366 00000FD9 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4367 00000FDD 7503                    		jnz	short DIRERROR
  4368                                  DIRNF:
  4369 00000FDF BA[F837]                		mov	dx,FNOTFOUNDPTR
  4370                                  DIRERROR:
  4371 00000FE2 E9460C                  		jmp	CERROR
  4372                                  DIR_NO_DRIVE:
  4373 00000FE5 813C2E2E                		cmp	word [si],'..'
  4374 00000FE9 750C                    		jnz	short DOREALPARSE
  4375 00000FEB 807C0200                		cmp	byte [si+2],0
  4376 00000FEF 7506                    		jnz	short DOREALPARSE
  4377 00000FF1 FF06[8842]              		inc	word [COMSW]
  4378 00000FF5 EB11                    		jmp	short DOHEADER
  4379                                  DOREALPARSE:
  4380 00000FF7 BF5C00                  		mov	di,FCB ; 5Ch	
  4381                                  		;mov	ax,290Eh
  4382 00000FFA B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4383 00000FFD CD21                    		int	21h	; DOS -	PARSE FILENAME
  4384                                  				; DS:SI	-> string to parse
  4385                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4386                                  				; AL = bit mask	to control parsing
  4387 00000FFF 803C00                  		cmp	byte [si],0
  4388 00001002 7404                    		jz	short DOHEADER
  4389 00001004 FF0E[8842]              		dec	word [COMSW]
  4390                                  DOHEADER:
  4391                                  
  4392                                  ; Display the header
  4393                                  
  4394 00001008 53                      		push	bx
  4395 00001009 E84804                  		call	BUILD_DIR_STRING
  4396 0000100C BA[6A43]                		mov	dx,DIRBUF
  4397 0000100F 8916[6544]              		mov	[VOL_DIR],dx
  4398 00001013 BA[FF3B]                		mov	dx,DIRHEADPTR
  4399 00001016 E8AA24                  		call	PRINTF_CRLF
  4400 00001019 5B                      		pop	bx
  4401 0000101A 83FBFF                  		cmp	bx,0FFFFh
  4402 0000101D 7417                    		jz	short DOSEARCH
  4403                                  
  4404                                  ; If there were chars left after parse or device, then invalid file name
  4405                                  
  4406 0000101F 833E[8842]00            		cmp	word [COMSW],0
  4407 00001024 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4408 00001026 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4409 00001028 E87208                  		call	RESTUDIR
  4410 0000102B BA[763B]                		mov	dx,BADCDPTR
  4411 0000102E E9FA0B                  		jmp	CERROR		; was .. => error directory not found
  4412                                  DIRNFFIX:
  4413 00001031 E86908                  		call	RESTUDIR
  4414 00001034 EBA9                    		jmp	short DIRNF
  4415                                  
  4416                                  ; We are assured that everything is correct. Let's go and search. Use
  4417                                  ; attributes that will include finding directories. Perform the first search
  4418                                  ; and reset our directory afterward.
  4419                                  
  4420                                  DOSEARCH:
  4421                                  		;mov	byte [55h],0FFh
  4422 00001036 C6065500FF              		mov	byte [FCB-7],0FFh
  4423                                  		;mov	byte [5Bh],10h
  4424 0000103B C6065B0010              		mov	byte [FCB-1],10h
  4425                                  
  4426                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4427                                  ; the directory information as an extended FCB. We must bias all fetches into
  4428                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4429                                  
  4430 00001040 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4431 00001042 BA5500                  		mov	dx,FCB-7 ; 55h
  4432 00001045 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4433                                  				; DS:DX	-> FCB
  4434                                  
  4435                                  ; Restore the user's directory. We preserve, though, the return from the
  4436                                  ; previous system call for later checking.
  4437                                  
  4438                                  FOUND_FIRST_FILE:
  4439 00001047 50                      		push	ax		; save return state
  4440 00001048 E85208                  		call	RESTUDIR	; restore user's dir	
  4441 0000104B 58                      		pop	ax		; get return state back
  4442                                  
  4443                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4444                                  ; no more.
  4445                                  
  4446                                  DIRSTART:
  4447 0000104C FEC0                    		inc	al		; 0FFh = file not found
  4448 0000104E 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4449 00001050 E9D200                  		jmp	CHKCNT
  4450                                  DISPLAY:
  4451 00001053 FF06[9942]              		inc	word [FILECNT]	; Keep track of how many we find
  4452 00001057 BE[7243]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4453                                  		;call	SHONAME
  4454 0000105A E80C01                  		call	DISPLAYNAME
  4455                                  		;test	byte [_BITS],1
  4456 0000105D F606[BC43]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4457 00001062 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4458 00001064 E98800                  		jmp	NEXENT
  4459                                  DIRTEST:
  4460                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4461                                  		; 14/10/2018
  4462                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4463                                  		;test	byte [DIRBUF+19],10h
  4464 00001067 F606[7D43]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4465 0000106C 7408                    		jz	short FILEENT
  4466 0000106E BA[F83A]                		mov	dx,DMESPTR
  4467 00001071 E85F24                  		call	STD_PRINTF
  4468 00001074 EB16                    		jmp	short NOFSIZ
  4469                                  FILEENT:
  4470                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4471                                  		;mov	dx,[DIRBUF+36]
  4472 00001076 8B16[8E43]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4473 0000107A 8916[4A44]              		mov	[FILESIZE_L],dx
  4474                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4475                                  		;mov	dx,[DIRBUF+38]
  4476 0000107E 8B16[9043]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4477 00001082 8916[4C44]              		mov	[FILESIZE_H],dx
  4478 00001086 BA[3637]                		mov	dx,FSIZEMESPTR
  4479 00001089 E84724                  		call	STD_PRINTF	; Print size of file
  4480                                  NOFSIZ:
  4481                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4482                                  		;mov	ax,[DIRBUF+32]
  4483 0000108C A1[8A43]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4484 0000108F 09C0                    		or	ax,ax
  4485 00001091 745C                    		jz	short NEXENT	; Skip if no date
  4486 00001093 BF[9B42]                		mov	di,CHARBUF
  4487 00001096 50                      		push	ax
  4488 00001097 B82020                  		mov	ax,'  '
  4489 0000109A AB                      		stosw
  4490 0000109B 58                      		pop	ax
  4491 0000109C 89C3                    		mov	bx,ax
  4492 0000109E 83E01F                  		and	ax,1Fh		; Get day
  4493 000010A1 88C2                    		mov	dl,al
  4494 000010A3 89D8                    		mov	ax,bx
  4495 000010A5 B105                    		mov	cl,5
  4496 000010A7 D3E8                    		shr	ax,cl		; Align month
  4497 000010A9 240F                    		and	al,0Fh		; Get month
  4498 000010AB 88C6                    		mov	dh,al
  4499 000010AD 88F9                    		mov	cl,bh
  4500 000010AF D0E9                    		shr	cl,1		; Align year
  4501 000010B1 30ED                    		xor	ch,ch
  4502 000010B3 83C150                  		add	cx,80		; Relative 1980
  4503 000010B6 80F964                  		cmp	cl,100
  4504 000010B9 7203                    		jb	short MILLENIUM
  4505 000010BB 80E964                  		sub	cl,100
  4506                                  MILLENIUM:
  4507 000010BE E8DD0F                  		call	DATE_CXDX
  4508                                  		;mov	cx,[DIRBUF_FTIME]
  4509                                  		;mov	cx,[DIRBUF+30]
  4510 000010C1 8B0E[8843]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4511 000010C5 E318                    		jcxz	PRBUF		; Time field present?
  4512 000010C7 B82020                  		mov	ax,2020h
  4513 000010CA AB                      		stosw
  4514 000010CB D1E9                    		shr	cx,1
  4515 000010CD D1E9                    		shr	cx,1
  4516 000010CF D1E9                    		shr	cx,1
  4517 000010D1 D0E9                    		shr	cl,1
  4518 000010D3 D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4519 000010D5 8A1E[094D]              		mov	bl,[TIME_24]
  4520 000010D9 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4521 000010DC E87211                  		call	P_TIME		; Don't care about DX, never used with DIR
  4522                                  PRBUF:
  4523 000010DF 31C0                    		xor	ax,ax
  4524 000010E1 AA                      		stosb
  4525 000010E2 BA[9B42]                		mov	dx,CHARBUF
  4526 000010E5 8916[4E44]              		mov	[STRING_PTR_2],dx
  4527 000010E9 BA[3F37]                		mov	dx,STRINGBUF2PTR
  4528 000010EC E8E423                  		call	STD_PRINTF
  4529                                  NEXENT:
  4530 000010EF FE0E[9742]              		dec	byte [LINCNT]
  4531 000010F3 7520                    		jnz	short SAMLIN
  4532                                  NEXLIN:
  4533 000010F5 A0[9842]                		mov	al,[LINLEN]
  4534 000010F8 A2[9742]                		mov	[LINCNT],al
  4535 000010FB E87008                  		call	CRLF2
  4536 000010FE FE0E[C443]              		dec	byte [LINPERPAG]
  4537 00001102 7517                    		jnz	short SCROLL
  4538                                  		;test	byte [_BITS],2
  4539 00001104 F606[BC43]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4540 00001109 7410                    		jz	short SCROLL	; If not, just continue
  4541 0000110B C606[C443]17            		mov	byte [LINPERPAG],23
  4542 00001110 E87900                  		call	PAUSE
  4543 00001113 EB06                    		jmp	short SCROLL
  4544                                  SAMLIN:
  4545 00001115 BA[4537]                		mov	dx,TABPTR	; Output a tab
  4546 00001118 E8B823                  		call	STD_PRINTF
  4547                                  SCROLL:
  4548 0000111B B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4549                                  		;mov	dx,55h
  4550 0000111D BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4551 00001120 CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4552                                  				; DS:DX	-> FCB
  4553                                  				; Return: AL = status
  4554 00001122 E927FF                  		jmp	DIRSTART
  4555                                  CHKCNT:
  4556 00001125 F706[9942]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4557 0000112B 7503                    		jnz	short TRAILER
  4558 0000112D E9AFFE                  		jmp	DIRNF
  4559                                  TRAILER:
  4560 00001130 A0[9842]                		mov	al,[LINLEN]
  4561 00001133 3A06[9742]              		cmp	al,[LINCNT]
  4562 00001137 7403                    		jz	short MMESSAGE
  4563 00001139 E83208                  		call	CRLF2
  4564                                  MMESSAGE:
  4565 0000113C BA[0F39]                		mov	dx,DIRMESPTR
  4566 0000113F 8B36[9942]              		mov	si,[FILECNT]
  4567 00001143 8936[5744]              		mov	[DIR_NUM],si
  4568 00001147 E88923                  		call	STD_PRINTF
  4569                                  DTFREE:
  4570 0000114A B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4571                                  		;mov	dl,[5Ch]
  4572 0000114C 8A165C00                		mov	dl,[FCB]
  4573 00001150 CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4574                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4575 00001152 83F8FF                  		cmp	ax,-1
  4576 00001155 7501                    		jnz	short DTFREE1
  4577                                  DTRET:
  4578 00001157 C3                      		retn
  4579                                  DTFREE1:
  4580 00001158 F7E1                    		mul	cx
  4581 0000115A F7E3                    		mul	bx
  4582 0000115C A3[5944]                		mov	[BYTES_FREE],ax
  4583 0000115F 8916[5B44]              		mov	[BYTES_FREE+2],dx
  4584 00001163 BA[2539]                		mov	dx,BYTEMESPTR
  4585 00001166 E96A23                  		jmp	STD_PRINTF
  4586                                  
  4587                                  
  4588                                  	; MSDOS 6.0
  4589                                  ;CATALOG:
  4590                                  
  4591                                  ;;
  4592                                  ;; Set up DTA for dir search firsts
  4593                                  ;;
  4594                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4595                                  ;	mov	ah,Set_DMA			;AC000;
  4596                                  ;	int	int_command			;AC000;
  4597                                  ;;
  4598                                  ;; Set up defaults for switches and parse the command line.
  4599                                  ;;
  4600                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4601                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4602                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4603                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4604                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4605                                  ;	stosb					;AN000;
  4606                                  ;	mov	al,end_of_line_in		;AN000;
  4607                                  ;	stosb					;AN000;
  4608                                  ;	mov	si,81H				;AN000; Get command line
  4609                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
  4610                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4611                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4612                                  ;	mov	bits,cx 			;AC000; initialize switches
  4613                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4614                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4615                                  ;	mov	lincnt,normperlin		;AC000;
  4616                                  ;
  4617                                  ;dirscan:
  4618                                  ;	xor	dx,dx				;AN000;
  4619                                  ;	invoke	parse_with_msg			;AC018; call parser
  4620                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4621                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4622                                  ;	jmp	scandone			;AN000; yes - go process
  4623                                  ;
  4624                                  ;dirscan_cont:
  4625                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4626                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4627                                  ;	jmp	badparm 			;AN000; yes - exit
  4628                                  ;
  4629                                  ;dirscan_cont2:
  4630                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4631                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4632                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4633                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4634                                  ;;
  4635                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4636                                  ;;
  4637                                  ;	push	si				;AC000; save position in line
  4638                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4639                                  ;	push	si				;AN000; save address
  4640                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4641                                  ;	pop	dx				;AC000; get address in DX
  4642                                  ;
  4643                                  ;;
  4644                                  ;; The user may have specified a device. Search for the path and see if the
  4645                                  ;; attributes indicate a device.
  4646                                  ;;
  4647                                  ;	mov	ah,Find_First			;AC000; find the file
  4648                                  ;	int	int_command			;AC000;
  4649                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4650                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4651                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4652                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4653                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4654                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4655                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4656                                  ;
  4657                                  ;dir_check_device:				;AN022;
  4658                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4659                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4660                                  ;	mov	ComSw,-2			;AC000; signal device
  4661                                  ;
  4662                                  ;dir_fspec_end:
  4663                                  ;	pop	si				;AC000; restore position in line
  4664                                  ;	jmp	short dirscan			;AC000; keep parsing
  4665                                  ;
  4666                                  ;set_dir_width:
  4667                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4668                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4669                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4670                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4671                                  ;	jmp	badparm 			;AN018; exit
  4672                                  ;
  4673                                  ;ok_set_width:
  4674                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4675                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4676                                  ;	mov	lincnt,wideperlin		;AC000;
  4677                                  ;	jmp	short dirscan			;AC000; keep parsing
  4678                                  ;
  4679                                  ;set_dir_pause:
  4680                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4681                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4682                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4683                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4684                                  ;	jmp	badparm 			;AN018; exit
  4685                                  ;
  4686                                  ;ok_set_pause:
  4687                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4688                                  ;	push	cx				;AN000; save necessary registers
  4689                                  ;	push	si				;AN000;
  4690                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4691                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4692                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4693                                  ;	mov	cl,get_generic			;AN000; get information
  4694                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4695                                  ;	int	int_command			;AN000;
  4696                                  ;
  4697                                  ;lines_set:
  4698                                  ;	dec	linperpag			;AN000; lines per actual page should
  4699                                  ;	dec	linperpag			;AN000;     two less than the max
  4700                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4701                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4702                                  ;	pop	si				;AN000; restore registers
  4703                                  ;	pop	cx				;AN000;
  4704                                  ;	jmp	dirscan 			;AC000; keep parsing
  4705                                  ;
  4706                                  ;;
  4707                                  ;; The syntax is incorrect. Report only message we can.
  4708                                  ;;
  4709                                  ;BadParm:
  4710                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4711                                  ;
  4712                                  ;ScanDone:
  4713                                  ;
  4714                                  ;;
  4715                                  ;; Find and display the volume ID on the drive.
  4716                                  ;;
  4717                                  ;
  4718                                  ;	invoke	okvolarg			;AC000;
  4719                                  ;;
  4720                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4721                                  ;; in the HeadFix routine, after we're done.
  4722                                  ;;
  4723                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4724                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4725                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4726                                  ;
  4727                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4728                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4729                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4730                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4731                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4732                                  ;	mov	si,[desttail]			;AN015; get filename back
  4733                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4734                                  ;
  4735                                  ;DirCheckPath:
  4736                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4737                                  ;	cmp	ax,0				;AN022; Is there a message?
  4738                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4739                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4740                                  ;	jz	doparse 			;AC000; no - no problem
  4741                                  ;	inc	comsw				;AC000; indicate error
  4742                                  ;	jmp	short doheader			;AC000; go print header
  4743                                  ;
  4744                                  ;DirNF:
  4745                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4746                                  ;
  4747                                  ;dir_err_setup:
  4748                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4749                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4750                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4751                                  ;
  4752                                  ;DirError:
  4753                                  ;	jmp	Cerror
  4754                                  ;
  4755                                  ;;
  4756                                  ;; We have changed to something. We also have a file. Parse it into a
  4757                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4758                                  ;; filename alone. We need to special case ... If we are at the root, the
  4759                                  ;; parse will fail and it will give us a file not found instead of file not
  4760                                  ;; found.
  4761                                  ;;
  4762                                  ;DoParse:
  4763                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4764                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4765                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4766                                  ;	lodsw					;AN000; bypass drive
  4767                                  ;
  4768                                  ;dir_no_drive:
  4769                                  ;	cmp	[si],".."
  4770                                  ;	jnz	DoRealParse
  4771                                  ;	cmp	byte ptr [si+2],0
  4772                                  ;	jnz	DoRealParse
  4773                                  ;	inc	ComSw
  4774                                  ;	jmp	short DoHeader
  4775                                  ;
  4776                                  ;DoRealParse:
  4777                                  ;	mov	di,FCB			; where to put the file name
  4778                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4779                                  ;	int	int_command
  4780                                  ;
  4781                                  ;;
  4782                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4783                                  ;; off.	This will be reset in the HEADFIX routine
  4784                                  ;;
  4785                                  ;
  4786                                  ;DoHeader:
  4787                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4788                                  ;
  4789                                  ;;
  4790                                  ;; Display the header
  4791                                  ;;
  4792                                  ;
  4793                                  ;DoHeaderCont:
  4794                                  ;	mov	al,blank			;AN051; Print out a blank
  4795                                  ;	invoke	print_char			;AN051;   before DIR header
  4796                                  ;	invoke	build_dir_string		; get current dir string
  4797                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4798                                  ;	invoke	printf_crlf			; bang!
  4799                                  ;
  4800                                  ;;
  4801                                  ;; If there were chars left after parse or device, then invalid file name
  4802                                  ;;
  4803                                  ;	cmp	ComSw,0
  4804                                  ;	jz	DoSearch			; nothing left; good parse
  4805                                  ;	jl	DirNFFix			; not .. => error file not found
  4806                                  ;	invoke	RestUDir
  4807                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4808                                  ;	jmp	Cerror				; was .. => error directory not found
  4809                                  ;DirNFFix:
  4810                                  ;	invoke	RestUDir
  4811                                  ;	jmp	DirNF
  4812                                  ;;
  4813                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4814                                  ;; attributes that will include finding directories.  perform the first search
  4815                                  ;; and reset our directory afterward.
  4816                                  ;;
  4817                                  ;DoSearch:
  4818                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4819                                  ;	mov	byte ptr DS:[FCB-1],010H
  4820                                  ;;
  4821                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4822                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4823                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4824                                  ;;
  4825                                  ;	mov	ah,Dir_Search_First
  4826                                  ;	mov	dx,FCB-7
  4827                                  ;	int	int_command
  4828                                  ;
  4829                                  ;	push	ax				;AN022; save return state
  4830                                  ;	inc	al				;AN022; did an error occur?
  4831                                  ;	pop	ax				;AN022; get return state back
  4832                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4833                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4834                                  ;	push	dx				;AN022; save message
  4835                                  ;	invoke	restudir			;AN022; restore user's dir
  4836                                  ;	pop	dx				;AN022; restore message
  4837                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4838                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4839                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4840                                  ;
  4841                                  ;DirCerrorJ:					;AN022;
  4842                                  ;	jmp	Cerror				;AN022; exit
  4843                                  ;
  4844                                  ;;
  4845                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4846                                  ;; previous system call for later checking.
  4847                                  ;;
  4848                                  ;
  4849                                  ;found_first_file:
  4850                                  ;	push	ax
  4851                                  ;	invoke	restudir
  4852                                  ;	pop	ax
  4853                                  ;;
  4854                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4855                                  ;; no more.
  4856                                  ;;
  4857                                  ;DIRSTART:
  4858                                  ;	inc	al				; FF = file not found
  4859                                  ;	jnz	Display
  4860                                  ;	jmp	DirDone 			; Either an error or we are finished
  4861                                  ;;
  4862                                  ;; Note that we've seen a file and display the found file.
  4863                                  ;;
  4864                                  ;
  4865                                  ;Display:
  4866                                  ;	inc	[filecnt]			; Keep track of how many we find
  4867                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4868                                  ;	call	shoname
  4869                                  ;;
  4870                                  ;; If we are displaying in wide mode, do not output the file info
  4871                                  ;;
  4872                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4873                                  ;	jz	DirTest
  4874                                  ;	jmp	nexent				; If so, no size, date, or time
  4875                                  ;
  4876                                  ;;
  4877                                  ;; Test for directory.
  4878                                  ;;
  4879                                  ;DirTest:
  4880                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4881                                  ;	jz	fileent
  4882                                  ;;
  4883                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4884                                  ;;
  4885                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4886                                  ;	call	std_printf
  4887                                  ;	jmp	short nofsiz
  4888                                  ;;
  4889                                  ;; We have a file.  Display the file size
  4890                                  ;;
  4891                                  ;fileent:
  4892                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4893                                  ;	mov	file_size_low,dx
  4894                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4895                                  ;	mov	file_size_high,dx
  4896                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4897                                  ;	call	std_printf
  4898                                  ;;
  4899                                  ;; Display time and date of last modification
  4900                                  ;;
  4901                                  ;nofsiz:
  4902                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4903                                  ;;
  4904                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4905                                  ;; date/time fields as 1.x did not have them.
  4906                                  ;;
  4907                                  ;	or	ax,ax
  4908                                  ;	jz	nexent				; Skip if no date
  4909                                  ;	mov	bx,ax
  4910                                  ;	and	ax,1FH				; get day
  4911                                  ;	mov	dl,al
  4912                                  ;	mov	ax,bx
  4913                                  ;	mov	cl,5
  4914                                  ;	shr	ax,cl				; Align month
  4915                                  ;	and	al,0FH				; Get month
  4916                                  ;	mov	dh,al
  4917                                  ;	mov	cl,bh
  4918                                  ;	shr	cl,1				; Align year
  4919                                  ;	xor	ch,ch
  4920                                  ;	add	cx,80				; Relative 1980
  4921                                  ;	cmp	cl,100
  4922                                  ;	jb	millenium
  4923                                  ;	sub	cl,100
  4924                                  ;
  4925                                  ;millenium:
  4926                                  ;	xchg	dh,dl				;AN000; switch month & day
  4927                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  4928                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  4929                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  4930                                  ;	jcxz	prbuf				; Time field present?
  4931                                  ;	shr	cx,1
  4932                                  ;	shr	cx,1
  4933                                  ;	shr	cx,1
  4934                                  ;	shr	cl,1
  4935                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  4936                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  4937                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  4938                                  ;
  4939                                  ;prbuf:
  4940                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  4941                                  ;	call	std_printf
  4942                                  ;	invoke	crlf2				;AC066;end the line
  4943                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  4944                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  4945                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  4946                                  ;	endif04:				;AN066;
  4947                                  ;	jmp	scroll				; If not, just continue
  4948                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  4949                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  4950                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  4951                                  ;;
  4952                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  4953                                  ;; is only for /W case.
  4954                                  ;;
  4955                                  ;nexent:
  4956                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  4957                                  ;	dec	[lincnt]			      ;count this entry on the line
  4958                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  4959                                  ;	   mov	   al,[linlen]
  4960                                  ;	   mov	   [lincnt],al
  4961                                  ;	   invoke  crlf2
  4962                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  4963                                  ;	   jnz	   endif02			;AN066;
  4964                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  4965                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  4966                                  ;	   jmp	   short endif01		;AN066;
  4967                                  ;	else01: 				;AN066;ELSE since screen not full
  4968                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  4969                                  ;	   jne	   endif03			;	     count the line
  4970                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  4971                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  4972                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  4973                                  ;	   call    std_printf
  4974                                  ;	endif01:				;AX066;
  4975                                  ;;
  4976                                  ;; All we need to do now is to get the next directory entry.
  4977                                  ;;
  4978                                  ;scroll:
  4979                                  ;	mov	ah,Dir_Search_Next
  4980                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  4981                                  ;	int	int_command			; Search for a file to match FCB
  4982                                  ;	jmp	DirStart
  4983                                  ;;
  4984                                  ;; If no files have been found, display a not-found message
  4985                                  ;;
  4986                                  ;DirDone:
  4987                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  4988                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  4989                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  4990                                  ;	test	[filecnt],-1
  4991                                  ;	jnz	Trailer
  4992                                  ;	mov	ax,error_file_not_found 	;AN022;
  4993                                  ;
  4994                                  ;dir_err_setup_jmp:				;AN022;
  4995                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  4996                                  ;;
  4997                                  ;; If we have printed the maximum number of files per line, terminate it with
  4998                                  ;; CRLF.
  4999                                  ;;
  5000                                  ;Trailer:
  5001                                  ;	mov	al,[linlen]
  5002                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5003                                  ;	jz	mmessage
  5004                                  ;	invoke	crlf2
  5005                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5006                                  ;	jnz	endif06 			;AN066;   pause before going on
  5007                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5008                                  ;	endif06:				;AN066;   displays
  5009                                  ;
  5010                                  ;mmessage:
  5011                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5012                                  ;	mov	si,[filecnt]
  5013                                  ;	mov	dir_num,si
  5014                                  ;	call	std_printf
  5015                                  ;	mov	ah,Get_Drive_Freespace
  5016                                  ;	mov	dl,byte ptr DS:[FCB]
  5017                                  ;	int	int_command
  5018                                  ;	cmp	ax,-1
  5019                                  ;	retz
  5020                                  ;	mul	cx				; AX is bytes per cluster
  5021                                  ;	mul	bx
  5022                                  ;	mov	bytes_free,ax			;AC000;
  5023                                  ;	mov	bytes_free+2,dx 		;AC000;
  5024                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5025                                  ;	jmp	std_printf
  5026                                  ;
  5027                                  ;shoname:
  5028                                  ;	mov	di,offset trangroup:charbuf
  5029                                  ;	mov	cx,8
  5030                                  ;	rep	movsb
  5031                                  ;	mov	al,' '
  5032                                  ;	stosb
  5033                                  ;	mov	cx,3
  5034                                  ;	rep	movsb
  5035                                  ;	xor	ax,ax
  5036                                  ;	stosb
  5037                                  ;	push	dx
  5038                                  ;	mov	dx,offset trangroup:charbuf
  5039                                  ;	mov	string_ptr_2,dx
  5040                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5041                                  ;	call	std_printf
  5042                                  ;	pop	DX
  5043                                  ;	return
  5044                                  ;
  5045                                  ;check_for_P    PROC  NEAR		;AN066;
  5046                                  ;
  5047                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5048                                  ;	jz	endif05 		;AN066;
  5049                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5050                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5051                                  ;   	invoke  Pause
  5052                                  ;endif05:
  5053                                  ;	ret				;AN066;
  5054                                  ;
  5055                                  ;check_for_P    ENDP			;AN066;
  5056                                  
  5057                                  ; =============== S U B	R O U T	I N E =======================================
  5058                                  
  5059                                  SHONAME:
  5060                                  DISPLAYNAME:
  5061                                  		; MSDOS 3.3
  5062 00001169 BF[9B42]                		mov	di,CHARBUF
  5063 0000116C B90800                  		mov	cx,8
  5064 0000116F F3A4                    		rep movsb
  5065 00001171 B020                    		mov	al,' '
  5066 00001173 AA                      		stosb
  5067 00001174 B90300                  		mov	cx,3
  5068 00001177 F3A4                    		rep movsb
  5069 00001179 31C0                    		xor	ax,ax
  5070 0000117B AA                      		stosb
  5071 0000117C 52                      		push	dx
  5072 0000117D BA[9B42]                		mov	dx,CHARBUF
  5073 00001180 8916[4E44]              		mov	[STRING_PTR_2],dx
  5074 00001184 BA[3F37]                		mov	dx,STRINGBUF2PTR
  5075 00001187 E84923                  		call	STD_PRINTF
  5076 0000118A 5A                      		pop	dx
  5077 0000118B C3                      		retn
  5078                                  
  5079                                  ;============================================================================
  5080                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5081                                  ;============================================================================
  5082                                  ; 09/10/2018 - Retro DOS v3.0
  5083                                  
  5084                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5085                                  
  5086                                  
  5087                                  ; =============== S U B	R O U T	I N E =======================================
  5088                                  
  5089                                  PAUSE:
  5090 0000118C BA[0C3A]                		mov	dx,PAUSEMESPTR
  5091 0000118F E84123                  		call	STD_PRINTF
  5092 00001192 E858F3                  		call	GETKEYSTROKE
  5093 00001195 E8D607                  		call	CRLF2
  5094 00001198 C3                      		retn
  5095                                  
  5096                                  ; ---------------------------------------------------------------------------
  5097                                  
  5098                                  ;****************************************************************
  5099                                  ;*
  5100                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5101                                  ;*
  5102                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5103                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5104                                  ;*		up an error message and transfer control to CERROR.
  5105                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5106                                  ;*		entered or SLASHP_ERASE if /P entered.
  5107                                  ;*
  5108                                  ;* INPUT:	command line at offset 81H
  5109                                  ;*
  5110                                  ;* OUTPUT:	if no error:
  5111                                  ;*		FCB at 5ch set up with filename(s) entered
  5112                                  ;*		Current directory set to entered directory
  5113                                  ;*
  5114                                  ;****************************************************************
  5115                                  
  5116                                  ERASE:
  5117                                  		; MSDOS 6.0
  5118                                  
  5119                                  ;assume	ds:trangroup,es:trangroup
  5120                                  
  5121                                  ;		mov	si,81H		;AC000; get command line
  5122                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5123                                  ;		mov	di,offset trangroup:parse_erase
  5124                                  ;					;AN000; Get adderss of PARSE_erase
  5125                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5126                                  ;
  5127                                  ;erase_scan:
  5128                                  ;		xor	dx,dx		;AN000;
  5129                                  ;		invoke	parse_with_msg	;AC018; call parser
  5130                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5131                                  ;		jz	good_line	;AN000; yes - done parsing
  5132                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5133                                  ;		jnz	errj2		;AC000; yes exit
  5134                                  ;
  5135                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5136                                  ;					;AN000; was /P entered?
  5137                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5138                                  ;
  5139                                  ;;
  5140                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5141                                  ;;
  5142                                  ;		push	si		;AC000; save position in line
  5143                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5144                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5145                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5146                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5147                                  ;					;AC000; was only drive entered?
  5148                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5149                                  ;		mov	ax,error_file_not_found 
  5150                                  ;					;AN022; get message number in control block
  5151                                  ;		jmp	short extend_setup ;AC000; exit
  5152                                  ;
  5153                                  ;erase_drive_ok:
  5154                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5155                                  ;		pop	si		;AC000; get position back
  5156                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5157                                  ;
  5158                                  ;set_erase_prompt:
  5159                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5160                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5161                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5162                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5163                                  ;		jmp	short errj2	;AN018; exit
  5164                                  ;
  5165                                  ;ok_to_set_erase_prompt: 		;AN018;
  5166                                  ;		inc	comsw		;AN000; indicate /p specified
  5167                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5168                                  ;
  5169                                  ;good_line:				;G  We know line is good
  5170                                  ;		invoke	pathcrunch
  5171                                  ;		jnc	checkdr
  5172                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5173                                  ;		cmp	ax,0		;AN022; was message flag set?
  5174                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5175                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5176                                  ;		jnz	badpath_err	;AC022; see if they should have
  5177                                  ;
  5178                                  ;checkdr:
  5179                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5180                                  ;		jz	notest2j	;AN000; no - go to notest2
  5181                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5182                                  ;
  5183                                  ;notest2j:
  5184                                  ;		jmp	notest2
  5185                                  ;
  5186                                  ;badpath_err:				;AN022; "Path not found" message
  5187                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5188                                  ;
  5189                                  ;extend_setup:				;AN022;
  5190                                  ;		mov	msg_disp_class,ext_msg_class
  5191                                  ;					;AN022; set up extended error msg class
  5192                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5193                                  ;					;AC022; get extended message pointer
  5194                                  ;		mov	Extend_Buf_ptr,ax
  5195                                  ;					;AN022; get message number in control block
  5196                                  ;errj2:					;AC022; exit jump
  5197                                  ;		jmp	Cerror		;AN022;
  5198                                  
  5199                                  		; MSDOS 3.3
  5200 00001199 BA[6D3D]                		mov	dx,BADARGSPTR
  5201 0000119C BE8000                  		mov	si,80h
  5202 0000119F AC                      		lodsb
  5203 000011A0 08C0                    		or	al,al
  5204 000011A2 743E                    		jz	short ERRJ2
  5205 000011A4 E8D407                  		call	SCANOFF
  5206 000011A7 3C0D                    		cmp	al,0Dh		; Return key
  5207 000011A9 7437                    		jz	short ERRJ2	; If so no parameters specified
  5208 000011AB 52                      		push	dx
  5209 000011AC 56                      		push	si
  5210 000011AD BA[F837]                		mov	dx,FNOTFOUNDPTR
  5211                                  ERASE_SCAN:
  5212 000011B0 AC                      		lodsb
  5213 000011B1 E8CF07                  		call	DELIM
  5214 000011B4 7406                    		jz	short ERASE_CHKDELIMCHR
  5215 000011B6 3C0D                    		cmp	al,0Dh
  5216 000011B8 7415                    		jz	short GOOD_LINE
  5217 000011BA EBF4                    		jmp	short ERASE_SCAN
  5218                                  ERASE_CHKDELIMCHR:
  5219 000011BC 3C20                    		cmp	al,20h
  5220 000011BE 7F22                    		jg	short ERRJ2
  5221 000011C0 AC                      		lodsb
  5222 000011C1 E8BF07                  		call	DELIM
  5223 000011C4 74F6                    		jz	short ERASE_CHKDELIMCHR
  5224 000011C6 3C0D                    		cmp	al,0Dh
  5225 000011C8 7405                    		jz	short GOOD_LINE
  5226 000011CA BA[6D3D]                		mov	dx,BADARGSPTR
  5227 000011CD EB13                    		jmp	short ERRJ2
  5228                                  GOOD_LINE:
  5229 000011CF 5E                      		pop	si
  5230 000011D0 5A                      		pop	dx
  5231 000011D1 56                      		push	si
  5232 000011D2 E84A08                  		call	PATHCRUNCH
  5233 000011D5 730E                    		jnc	short CHECKDR
  5234 000011D7 803E[6C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5235 000011DC 7407                    		jz	short CHECKDR	   ; see if they should have
  5236                                  BADCDERR:
  5237 000011DE 5E                      		pop	si
  5238 000011DF BA[763B]                		mov	dx,BADCDPTR
  5239                                  ERRJ2:
  5240 000011E2 E9460A                  		jmp	CERROR
  5241                                  CHECKDR:
  5242 000011E5 BA[F837]                		mov	dx,FNOTFOUNDPTR
  5243 000011E8 59                      		pop	cx
  5244 000011E9 B020                    		mov	al,' '
  5245                                  		;cmp	[5Dh],al
  5246 000011EB 38065D00                		cmp	[FCB+1],al
  5247 000011EF 74F1                    		jz	short ERRJ2
  5248 000011F1 83C103                  		add	cx,3
  5249 000011F4 39CE                    		cmp	si,cx
  5250 000011F6 7507                    		jnz	short NOTEST2J
  5251 000011F8 B03A                    		mov	al,':'
  5252 000011FA 3844FE                  		cmp	[si-2],al
  5253 000011FD 74E3                    		jz	short ERRJ2
  5254                                  NOTEST2J:
  5255 000011FF E92116                  		jmp	NOTEST2
  5256                                  
  5257                                  ; ---------------------------------------------------------------------------
  5258                                  
  5259                                  ; ****************************************************************
  5260                                  ; *
  5261                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5262                                  ; *
  5263                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5264                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5265                                  ; *		 Make sure the second filespec only contains a
  5266                                  ; *		 filename.  If both openands are valid, attempt
  5267                                  ; *		 to rename the file.
  5268                                  ; *
  5269                                  ; * INPUT:	 command line at offset 81H
  5270                                  ; *
  5271                                  ; * OUTPUT:	 none
  5272                                  ; *
  5273                                  ; ****************************************************************
  5274                                  
  5275                                  CRENAME:
  5276                                  		; MSDOS 6.0
  5277                                  		;assume	ds:trangroup,es:trangroup
  5278                                  ;
  5279                                  ;		mov	si,81H		;AC000; Point to command line
  5280                                  ;		mov	di,offset trangroup:parse_rename
  5281                                  ;					;AN000; Get adderss of PARSE_RENAME
  5282                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5283                                  ;		xor	dx,dx		;AN000;
  5284                                  ;		invoke	parse_with_msg	;AC018; call parser
  5285                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5286                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5287                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5288                                  ;;
  5289                                  ;;  Get first file name returned from parse into our buffer
  5290                                  ;;
  5291                                  ;crename_no_parse_error:
  5292                                  ;		push	si		;AN000; save position in line
  5293                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5294                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5295                                  ;		pop	si		;AN000; restore position in line
  5296                                  ;
  5297                                  ;		xor	dx,dx		;AN000; clear dx
  5298                                  ;		invoke	parse_with_msg	;AC018; call parser
  5299                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5300                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5301                                  ;;
  5302                                  ;;  Check the second file name for drive letter colon
  5303                                  ;;
  5304                                  ;		push	si		;AN000; save position in line
  5305                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5306                                  ;
  5307                                  ;		mov	al,':'		;AC000;
  5308                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5309                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5310                                  ;		mov	msg_disp_class,parse_msg_class
  5311                                  ;					;AN000; set up parse error msg class
  5312                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5313                                  ;					;AC000; get extended message pointer
  5314                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5315                                  ;					;AN000; get "Invalid parameter" message number
  5316                                  ;		pop	si		;AN000;
  5317                                  ;crename_parse_error:			;AC022;
  5318                                  ;		jmp	short errj	;AC000;
  5319                                  ;
  5320                                  ;;  Get second file name returned from parse into the fCB. Save
  5321                                  ;;  character after file name so we can later check to make sure it
  5322                                  ;;  isn't a path character.
  5323                                  ;
  5324                                  ;
  5325                                  ;ren_no_drive:
  5326                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5327                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5328                                  ;		int	21h		;AC000; do the function
  5329                                  ;		lodsb			;AC000; Load char after filename
  5330                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5331                                  ;		pop	si		;AN000; get line position back
  5332                                  ;
  5333                                  ;;
  5334                                  ;; We have source and target.  See if any args beyond.
  5335                                  ;;
  5336                                  ;
  5337                                  ;		mov	di,offset trangroup:parse_rename
  5338                                  ;					;AC000; get address of parse_rename
  5339                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5340                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5341                                  ;
  5342                                  ;		invoke	pathcrunch
  5343                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5344                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5345                                  ;		jnc	notest3
  5346                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5347                                  ;		cmp	ax,0		;AN022; was message flag set?
  5348                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5349                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5350                                  ;		jz	notest3 	; see if they should have
  5351                                  ;		Jmp	badpath_err	;AC022; set up error
  5352                                  ;
  5353                                  ;notest3:
  5354                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5355                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5356                                  ;					; Load invalid fname error ptr
  5357                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5358                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5359                                  ;					;  filename only.
  5360                                  ;		mov	ah,FCB_Rename
  5361                                  ;		mov	dx,FCB
  5362                                  ;		int	21h
  5363                                  ;		cmp	al, 0FFH	; Did an error occur??
  5364                                  ;		jnz	renameok
  5365                                  ;
  5366                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5367                                  ;		SaveReg <AX>		;AC022; Save results
  5368                                  ;		mov	al, 0FFH	; Restore original error state
  5369                                  ;
  5370                                  ;renameok:
  5371                                  ;		push	ax
  5372                                  ;		invoke	restudir
  5373                                  ;		pop	ax
  5374                                  ;		inc	al
  5375                                  ;		retnz
  5376                                  ;
  5377                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5378                                  ;		cmp	ax,error_file_not_found 
  5379                                  ;					;AN022; error file not found?
  5380                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5381                                  ;		cmp	ax,error_access_denied
  5382                                  ;					;AN022; error file not found?
  5383                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5384                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5385                                  ;
  5386                                  ;use_renerr:
  5387                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5388                                  ;ERRJ:
  5389                                  ;		jmp	Cerror
  5390                                  ;
  5391                                  ;ret56:		ret
  5392                                  
  5393                                  		; MSDOS 3.3
  5394 00001202 BA[6D3D]                		mov	dx,BADARGSPTR
  5395 00001205 E87307                  		call	SCANOFF
  5396 00001208 3C0D                    		cmp	al,0Dh
  5397 0000120A 74D6                    		jz	short ERRJ2
  5398 0000120C E81008                  		call	PATHCRUNCH
  5399 0000120F BA[4C3D]                		mov	dx,BADCPMESPTR
  5400 00001212 74CE                    		jz	short ERRJ2
  5401 00001214 7309                    		jnb	short CRENAME_NO_PARSE_ERROR
  5402 00001216 803E[6C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5403 0000121B 7402                    		jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5404 0000121D EBBF                    		jmp	short BADCDERR
  5405                                  
  5406                                  ;  Get first file name returned from parse into our buffer
  5407                                  
  5408                                  CRENAME_NO_PARSE_ERROR:
  5409 0000121F 8B36[C043]              		mov	si,[PATHPOS]
  5410 00001223 E85507                  		call	SCANOFF
  5411 00001226 3C0D                    		cmp	al,0Dh
  5412 00001228 BA[6D3D]                		mov	dx,BADARGSPTR
  5413 0000122B 7443                    		jz	short ERRJ
  5414 0000122D B03A                    		mov	al,':'
  5415 0000122F BA[223A]                		mov	dx,BADPARMPTR
  5416 00001232 384401                  		cmp	[si+1],al
  5417 00001235 7439                    		jz	short ERRJ
  5418                                  
  5419                                  ;  Get second file name returned from parse into the FCB. Save
  5420                                  ;  character after file name so we can later check to make sure it
  5421                                  ;  isn't a path character.
  5422                                  
  5423                                  REN_NO_DRIVE:
  5424                                  		;mov	di,6Ch
  5425 00001237 BF6C00                  		mov	di,FCB+10h
  5426 0000123A B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5427 0000123D CD21                    		int	21h	; DOS -	PARSE FILENAME
  5428                                  				; DS:SI	-> string to parse
  5429                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5430                                  				; AL = bit mask	to control parsing
  5431 0000123F B020                    		mov	al,' '
  5432                                  		;cmp	[6Dh],al
  5433 00001241 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5434 00001245 7429                    		jz	short ERRJ	; Error if missing parameter
  5435 00001247 AC                      		lodsb
  5436 00001248 BA[E738]                		mov	dx,INORNOTPTR
  5437 0000124B E8C007                  		call	PATHCHRCMP
  5438 0000124E 7420                    		jz	short ERRJ
  5439 00001250 B417                    		mov	ah,FCB_RENAME ; 17h
  5440 00001252 BA5C00                  		mov	dx,FCB ; 5Ch
  5441 00001255 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5442                                  				; DS:DX	-> FCB
  5443                                  				; FCB contains new name	starting at byte 17h.
  5444 00001257 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5445 00001259 750A                    		jnz	short RENAMEOK
  5446 0000125B F9                      		stc
  5447 0000125C BA[E537]                		mov	dx,RENERRPTR
  5448 0000125F E86A0C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5449 00001262 52                      		push	dx
  5450 00001263 B0FF                    		mov	al,0FFh		; Restore original error state
  5451                                  RENAMEOK:
  5452 00001265 50                      		push	ax
  5453 00001266 E83406                  		call	RESTUDIR
  5454 00001269 58                      		pop	ax
  5455 0000126A FEC0                    		inc	al
  5456 0000126C 7401                    		jz	short RENAME_ERR
  5457                                  RENAME_RETN:
  5458                                  TYPELP_RET:
  5459 0000126E C3                      		retn
  5460                                  RENAME_ERR:
  5461 0000126F 5A                      		pop	dx
  5462                                  ERRJ:					; Retro DOS v3.0
  5463 00001270 E85722                  		call	STD_EPRINTF
  5464 00001273 E98EEE                  		jmp	TCOMMAND
  5465                                  
  5466                                  ; ---------------------------------------------------------------------------
  5467                                  
  5468                                  ;ERRJ:
  5469                                  ;		jmp	CERROR
  5470                                  
  5471                                  ; ---------------------------------------------------------------------------
  5472                                  
  5473                                  ;TYPELP_RET:
  5474                                  ;		retn
  5475                                  
  5476                                  ; ---------------------------------------------------------------------------
  5477                                  
  5478                                  ;****************************************************************
  5479                                  ;*
  5480                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5481                                  ;*		standard output device
  5482                                  ;*
  5483                                  ;* SYNTAX:	TYPE filespec
  5484                                  ;*
  5485                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5486                                  ;*		1Ah and display the contents to STDOUT.
  5487                                  ;*
  5488                                  ;* INPUT:	command line at offset 81H
  5489                                  ;*
  5490                                  ;* OUTPUT:	none
  5491                                  ;*
  5492                                  ;****************************************************************
  5493                                  
  5494                                  TYPEFIL:
  5495                                  		; MSDOS 6.0	
  5496                                  		;assume	ds:trangroup,es:trangroup
  5497                                  
  5498                                  ;		mov	si,81H
  5499                                  ;		mov	di,offset trangroup:parse_mrdir 
  5500                                  ;					;AN000; Get adderss of PARSE_MRDIR
  5501                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5502                                  ;		xor	dx,dx		;AN000;
  5503                                  ;		invoke	parse_with_msg	;AC018; call parser
  5504                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5505                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5506                                  ;
  5507                                  ;		push	si		;AC000; save position in line
  5508                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5509                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5510                                  ;		pop	si		;AC000; get position back
  5511                                  ;		mov	di,offset trangroup:parse_mrdir 
  5512                                  ;					;AC000; get address of parse_mrdir
  5513                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5514                                  ;		jz	gottarg 	;AC000; yes - continue
  5515                                  ;
  5516                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5517                                  ;		jmp	Cerror
  5518                                  ;
  5519                                  ;gottarg:
  5520                                  ;		invoke	setpath
  5521                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5522                                  ;		jz	nowilds 	; No, continue processing
  5523                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5524                                  ;		jmp	Cerror
  5525                                  ;nowilds:
  5526                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5527                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5528                                  ;		xor	cx,cx		;AN000; no special files
  5529                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5530                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5531                                  ;		int	21h
  5532                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5533                                  ;
  5534                                  ;Typerr: 				;AN022;
  5535                                  ;		push	cs		;AN022; make sure we have local segment
  5536                                  ;		pop	ds		;AN022;
  5537                                  ;		invoke	set_ext_error_msg ;AN022;
  5538                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5539                                  ;					;AC022; get address of failed string
  5540                                  ;		mov	Extend_buf_sub,one_subst
  5541                                  ;					;AC022; put number of subst in control block
  5542                                  ;		jmp	cerror		;AC022; exit
  5543                                  ;
  5544                                  ;typecont:
  5545                                  ;		mov	bx,ax		;AC000; get  Handle
  5546                                  ;;M043
  5547                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5548                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5549                                  ;;indicate it is a device.
  5550                                  ;;
  5551                                  ;		mov	ax,(IOCTL shl 8) or 0
  5552                                  ;		int	21h
  5553                                  ;
  5554                                  ;		test	dl,80h		;is it a device?
  5555                                  ;		jz	not_device	;no, a file
  5556                                  ;
  5557                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5558                                  ;		jmp	short dotype
  5559                                  ;not_device:
  5560                                  ;
  5561                                  ;;SR;
  5562                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5563                                  ;;start of file
  5564                                  ;;
  5565                                  ;		mov	ax,(LSEEK shl 8) or 2
  5566                                  ;		xor	dx,dx
  5567                                  ;		mov	cx,dx		;seek  to end of file
  5568                                  ;		int	21h
  5569                                  ;
  5570                                  ;		mov	word ptr TypeFilSiz,ax
  5571                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5572                                  ;
  5573                                  ;		mov	ax,(LSEEK shl 8) or 0
  5574                                  ;		xor	dx,dx
  5575                                  ;		int	21h	        ;reset file pointer to start
  5576                                  ;dotype:					;M043
  5577                                  ;		mov	zflag,0 	; Reset ^Z flag
  5578                                  ;		mov	ds,[TPA]
  5579                                  ;		xor	dx,dx
  5580                                  ;		;ASSUME	DS:NOTHING
  5581                                  ;
  5582                                  ;typelp:
  5583                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5584                                  ;		retnz			; Yes, return
  5585                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5586                                  ;;
  5587                                  ;;Update the filesize left to read
  5588                                  ;;
  5589                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5590                                  ;		je	typ_read	;yes, just read from it; M043
  5591                                  ;
  5592                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5593                                  ;		jz	lt64k		;no, do word subtraction
  5594                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5595                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5596                                  ;      		jmp	short typ_read	;do the read
  5597                                  ;lt64k:
  5598                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5599                                  ;		jbe	gtbuf		; yes, just update readsize
  5600                                  ;;
  5601                                  ;;Buffer size is larger than bytes to read
  5602                                  ;;
  5603                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5604                                  ;		jcxz	typelp_ret
  5605                                  ;		mov	word ptr cs:TypeFilSiz,0
  5606                                  ;		jmp	short typ_read
  5607                                  ;gtbuf:
  5608                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5609                                  ;typ_read:
  5610                                  ;		mov	ah,read
  5611                                  ;		int	21h		
  5612                                  ;		jnc	@f		;M043
  5613                                  ;		jmp	typerr		;M043
  5614                                  ;@@:					;M043
  5615                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5616                                  ;
  5617                                  ;		mov	cx,ax
  5618                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5619                                  ;		push	ds
  5620                                  ;		pop	es		; Check to see if a ^Z was read.
  5621                                  ;		;assume es:nothing
  5622                                  ;		xor	di,di
  5623                                  ;		push	ax
  5624                                  ;		mov	al,1ah
  5625                                  ;		repnz	scasb
  5626                                  ;		pop	ax
  5627                                  ;		xchg	ax,cx
  5628                                  ;		cmp	ax,0
  5629                                  ;		jnz	foundz		; Yes, handle it
  5630                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5631                                  ;		jnz	typecont2	; No ^Z, continue
  5632                                  ;
  5633                                  ;foundz:
  5634                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5635                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5636                                  ;		push	cs		;  will be typed.
  5637                                  ;		pop	es
  5638                                  ;		;assume es:trangroup
  5639                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5640                                  ;typecont2:				;  will quit after this write.
  5641                                  ;		push	bx
  5642                                  ;		mov	bx,1
  5643                                  ;		mov	ah,write
  5644                                  ;		int	21h
  5645                                  ;		pop	bx
  5646                                  ;		jc	Error_outputj
  5647                                  ;		cmp	ax,cx
  5648                                  ;		jnz	@f		;M043
  5649                                  ;		jmp	typelp		;M043
  5650                                  ;@@:					;M043
  5651                                  ;;M043;		jz	typelp
  5652                                  ;		dec	cx
  5653                                  ;		cmp	ax,cx
  5654                                  ;		retz			; One less byte OK (^Z)
  5655                                  ;Error_outputj:
  5656                                  ;		mov	bx,1
  5657                                  ;		mov	ax,IOCTL SHL 8
  5658                                  ;		int	21h
  5659                                  ;		test	dl,devid_ISDEV
  5660                                  ;		retnz			; If device, no error message
  5661                                  ;		jmp	error_output
  5662                                  ;typelp_ret:
  5663                                  ;		ret
  5664                                  
  5665                                  		; MSDOS 3.3
  5666 00001276 BE8100                  		mov	si,81h
  5667 00001279 E8FF06                  		call	SCANOFF		; Skip to first non-delim
  5668 0000127C 3C0D                    		cmp	al,0Dh
  5669 0000127E 7505                    		jnz	short GOTTARG
  5670 00001280 BA[6D3D]                		mov	dx,BADARGSPTR
  5671                                  
  5672                                  		;jmp	CERROR
  5673 00001283 EBEB                    		jmp	short ERRJ	; No args
  5674                                  GOTTARG:
  5675 00001285 E8F10A                  		call	SETPATH
  5676 00001288 F606[7044]02            		test	byte [DESTINFO],2
  5677 0000128D 7405                    		jz	short NOWILDS
  5678 0000128F BA[E738]                		mov	dx,INORNOTPTR
  5679                                  
  5680                                  		;jmp	CERROR
  5681 00001292 EBDC                    		jmp	short ERRJ
  5682                                  NOWILDS:
  5683 00001294 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5684 00001297 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5685                                  				; DS:DX	-> ASCIZ filename
  5686                                  				; AL = access mode
  5687                                  				; 0 - read
  5688 00001299 7311                    		jnc	short TYPECONT
  5689 0000129B BA[F837]                		mov	dx,FNOTFOUNDPTR
  5690 0000129E 83F802                  		cmp	ax,2
  5691 000012A1 74CD                    		jz	short ERRJ
  5692 000012A3 BA[4C3D]                		mov	dx,BADCPMESPTR
  5693 000012A6 F9                      		stc
  5694 000012A7 E8220C                  		call	GET_EXT_ERR_NUMBER
  5695                                  
  5696                                  		;jmp	CERROR
  5697 000012AA EBC4                    		jmp	short ERRJ
  5698                                  TYPECONT:
  5699 000012AC C606[F74B]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5700 000012B1 89C3                    		mov	bx,ax		; Handle
  5701 000012B3 8E1E[7342]              		mov	ds,[TPA]
  5702 000012B7 31D2                    		xor	dx,dx
  5703                                  TYPELP:
  5704 000012B9 2E803E[F74B]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5705 000012BF 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5706 000012C1 2E8B0E[9242]            		mov	cx,[cs:BYTCNT]	; No, continue
  5707 000012C6 B43F                    		mov	ah,READ ; 3Fh
  5708 000012C8 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5709                                  				; BX = file handle,CX = number	of bytes to read
  5710                                  				; DS:DX	-> buffer
  5711 000012CA 89C1                    		mov	cx,ax
  5712 000012CC E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5713                                  					; Check to see if a ^Z was read.
  5714 000012CE 1E                      		push	ds
  5715 000012CF 07                      		pop	es		
  5716 000012D0 31FF                    		xor	di,di
  5717 000012D2 50                      		push	ax
  5718 000012D3 B01A                    		mov	al,1Ah
  5719 000012D5 F2AE                    		repne scasb
  5720 000012D7 58                      		pop	ax
  5721 000012D8 91                      		xchg	ax,cx
  5722 000012D9 83F800                  		cmp	ax,0
  5723 000012DC 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5724 000012DE 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5725 000012E2 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5726                                  FOUNDZ:
  5727 000012E4 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5728 000012E6 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5729 000012E7 0E                      		push	cs		;  will be typed.
  5730 000012E8 07                      		pop	es
  5731 000012E9 2EF616[F74B]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5732                                  					;  will quit after this write.
  5733                                  TYPECONT2:
  5734 000012EE 53                      		push	bx
  5735 000012EF BB0100                  		mov	bx,1
  5736 000012F2 B440                    		mov	ah,WRITE ; 40h
  5737 000012F4 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5738                                  				; BX = file handle, CX = number of bytes to write,
  5739                                  				; DS:DX -> buffer
  5740 000012F6 5B                      		pop	bx
  5741 000012F7 720A                    		jc	short ERROR_OUTPUTJ
  5742 000012F9 39C8                    		cmp	ax,cx
  5743 000012FB 74BC                    		jz	short TYPELP
  5744 000012FD 49                      		dec	cx
  5745 000012FE 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5746 00001300 7501                    		jnz	short ERROR_OUTPUTJ
  5747                                  TYPEFIL_RETN:
  5748 00001302 C3                      		retn
  5749                                  ERROR_OUTPUTJ:
  5750 00001303 BB0100                  		mov	bx,1
  5751 00001306 B80044                  		mov	ax,IOCTL*256 ; 4400h
  5752 00001309 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5753                                  				; BX = file or device handle
  5754                                  		;test	dl,devid_ISDEV
  5755 0000130B F6C280                  		test	dl,80h
  5756 0000130E 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5757 00001310 E9E106                  		jmp	ERROR_OUTPUT
  5758                                  
  5759                                  ; ---------------------------------------------------------------------------
  5760                                  
  5761                                  ; VOLUME command displays the volume ID on the specified drive
  5762                                  
  5763                                  VOLUME:
  5764                                  		; MSDOS 6.0
  5765                                  		;mov	si,81H
  5766                                  		;mov	di,offset trangroup:parse_vol
  5767                                  		;			;AN000; Get adderss of PARSE_VOL
  5768                                  		;xor	cx,cx		;AN000; clear cx,dx
  5769                                  		;xor	dx,dx		;AN000;
  5770                                  		;invoke	parse_with_msg	;AC018; call parser
  5771                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5772                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5773                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5774                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5775                                  
  5776                                  ; We have parsed off the drive. See if there are any more chars left
  5777                                  
  5778                                  		;mov	di,offset trangroup:parse_vol	
  5779                                  					;AC000; get address of parse_vol
  5780                                  		;xor	dx,dx		;AC000;
  5781                                  		;invoke	parse_check_eol ;AC000; call parser
  5782                                  		;jz	OkVolArg	;AC000; yes, end of road
  5783                                  
  5784                                  ; The line was not interpretable. Report an error.
  5785                                  
  5786                                  ;badvolarg:
  5787                                  		;jmp	Cerror
  5788                                  
  5789                                  		; MSDOS 3.3
  5790 00001313 BE8100                  		mov	si,81h
  5791 00001316 E86206                  		call	SCANOFF		; Skip to first non-delim
  5792                                  		;mov	ah,[5Ch]
  5793 00001319 8A265C00                		mov	ah,[FCB]
  5794                                  		;mov	byte [5Ch],0
  5795 0000131D C6065C0000              		mov	byte [FCB],0
  5796 00001322 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5797 00001324 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5798                                  		;mov	[5Ch],ah
  5799 00001326 88265C00                		mov	[FCB],ah
  5800 0000132A AC                      		lodsb
  5801 0000132B AC                      		lodsb
  5802 0000132C 3C3A                    		cmp	al,':'
  5803 0000132E 7507                    		jnz	short VOLUME_ERR
  5804 00001330 E84806                  		call	SCANOFF
  5805 00001333 3C0D                    		cmp	al,0Dh
  5806 00001335 7406                    		jz	short OKVOLARG
  5807                                  VOLUME_ERR:
  5808 00001337 BA[4939]                		mov	dx,BADDRVPTR
  5809 0000133A E9EE08                  		jmp	CERROR
  5810                                  
  5811                                  ; ---------------------------------------------------------------------------
  5812                                  
  5813                                  OKVOLARG:
  5814 0000133D E82E06                  		call	CRLF2
  5815 00001340 1E                      		push	ds
  5816 00001341 07                      		pop	es
  5817                                  		;mov	di,55h
  5818 00001342 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5819 00001345 B0FF                    		mov	al,-1
  5820 00001347 AA                      		stosb
  5821 00001348 31C0                    		xor	ax,ax
  5822 0000134A AB                      		stosw
  5823 0000134B AB                      		stosw
  5824 0000134C AA                      		stosb
  5825 0000134D B008                    		mov	al,8		; Look for volume label
  5826 0000134F AA                      		stosb
  5827 00001350 47                      		inc	di		; Skip drive byte
  5828 00001351 B90B00                  		mov	cx,11
  5829 00001354 B03F                    		mov	al,'?'
  5830 00001356 F3AA                    		rep stosb
  5831 00001358 BA[6A43]                		mov	dx,DIRBUF
  5832 0000135B B41A                    		mov	ah,SET_DMA ; 1Ah
  5833 0000135D CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5834                                  				; DS:DX	-> disk	transfer buffer
  5835                                  		;mov	dx,55h
  5836 0000135F BA5500                  		mov	dx,FCB-7
  5837 00001362 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5838 00001364 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5839                                  				; DS:DX	-> FCB
  5840 00001366 E9F915                  		jmp	PRINTVOL
  5841                                  
  5842                                  ;============================================================================
  5843                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5844                                  ;============================================================================
  5845                                  ; 08/10/2018 - Retro DOS v3.0
  5846                                  
  5847                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5848                                  
  5849                                  ; ---------------------------------------------------------------------------
  5850                                  
  5851                                  ; MSDOS 6.0
  5852                                  ;***	Version - display DOS version
  5853                                  ;
  5854                                  ;	SYNTAX	ver [/debug]
  5855                                  ;
  5856                                  ;		/debug - display additional DOS configuration info
  5857                                  ;
  5858                                  ;	ENTRY	command-line tail is in PSP
  5859                                  ;
  5860                                  ;	EXIT	if successful, nothing
  5861                                  ;		if parse fails,
  5862                                  ;		  parse error message is set up (for Std_EPrintf)
  5863                                  ;		    AX = system parser error code
  5864                                  ;		    DX = ptr to message block
  5865                                  ;		  we jump to CError
  5866                                  ;
  5867                                  ;	EFFECTS
  5868                                  ;	  If parse fails, a parse error message is displayed.
  5869                                  ;	  Otherwise, version message is displayed.
  5870                                  ;	  If /debug is specified, additional DOS info is displayed.
  5871                                  
  5872                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5873                                  ;
  5874                                  ;;	Parse command line for /debug switch.
  5875                                  ;
  5876                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5877                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5878                                  ;	xor	cx,cx				; CX = # positional param's found
  5879                                  ;	invoke	Parse_With_Msg
  5880                                  ;
  5881                                  ;	mov	bl,1			; BL = flag = /debug present
  5882                                  ;	cmp	ax,RESULT_NO_ERROR
  5883                                  ;	je	verPrintVer		; something parsed - must be /debug
  5884                                  ;	dec	bl			; BL = flag = no /debug present
  5885                                  ;	cmp	ax,END_OF_LINE
  5886                                  ;	je	verPrintVer		; reached end of line - ok
  5887                                  ;
  5888                                  ;;	The parse failed.  Error message has been set up.
  5889                                  ;
  5890                                  ;	jmp	CError
  5891                                  ;
  5892                                  ;verPrintVer:
  5893                                  ;	push	bx			; save /debug flag
  5894                                  ;	call	Crlf2
  5895                                  ;	call	Print_Version
  5896                                  ;	call	Crlf2
  5897                                  ;	pop	bx   			; BL = /debug flag
  5898                                  ;	or	bl,bl
  5899                                  ;	jz	verDone			; /debug is false - we're done
  5900                                  ;
  5901                                  ;;*	For /debug, display DOS internal revision and DOS location
  5902                                  ;;	(low memory, HMA, or ROM).
  5903                                  ;
  5904                                  ;;	Bugbug:	use symbols for bitmasks below.
  5905                                  ;
  5906                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5907                                  ;	int	21h
  5908                                  ;	mov	al,dl			;revision number in dl; M013
  5909                                  ;	mov	bh,dh			;flags in dh now; M013
  5910                                  ;;M032	and	al,7			; AL = DOS internal revision
  5911                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5912                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5913                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5914                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5915                                  ;	mov	One_Char_Val,al
  5916                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5917                                  ;	invoke	Std_Printf		; print DOS internal revision
  5918                                  ;
  5919                                  ;	mov	cl,4
  5920                                  ;	shr	bh,cl			; CY = DOS in ROM
  5921                                  ;	jc	verRom
  5922                                  ;	shr	bh,1			; CY = DOS in HMA
  5923                                  ;	jc	verHma
  5924                                  ;
  5925                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  5926                                  ;
  5927                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  5928                                  ;	jmp	short verPrintLoc
  5929                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  5930                                  ;	jmp	short verPrintLoc
  5931                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  5932                                  ;verPrintLoc:
  5933                                  ;	invoke	Std_Printf
  5934                                  ;verDone:
  5935                                  ;	jmp	Crlf2
  5936                                  
  5937                                  		; MSDOS 3.3
  5938                                  VERSION:
  5939 00001369 E80206                  		call	CRLF2
  5940 0000136C E80300                  		call	PRINT_VERSION
  5941 0000136F E9FC05                  		jmp	CRLF2
  5942                                  
  5943                                  ; =============== S U B	R O U T	I N E =======================================
  5944                                  
  5945                                  PRINT_VERSION:
  5946 00001372 B430                    		mov	ah,GET_VERSION ; 30h
  5947 00001374 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  5948                                  				; Return: AL = major version number (00h for DOS 1.x)
  5949 00001376 50                      		push	ax
  5950 00001377 30E4                    		xor	ah,ah
  5951 00001379 A3[5D44]                		mov	[MAJOR_VER_NUM],ax
  5952 0000137C 58                      		pop	ax
  5953 0000137D 86E0                    		xchg	ah,al
  5954 0000137F 30E4                    		xor	ah,ah
  5955 00001381 A3[5F44]                		mov	[MINOR_VER_NUM],ax
  5956 00001384 BA[273B]                		mov	dx,VERMESPTR
  5957 00001387 E94921                  		jmp	STD_PRINTF
  5958                                  
  5959                                  ; =============== S U B	R O U T	I N E =======================================
  5960                                  
  5961                                  PRINT_PROMPT:
  5962 0000138A 1E                      		push	ds
  5963 0000138B 0E                      		push	cs
  5964 0000138C 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  5965 0000138D 06                      		push	es
  5966 0000138E E80304                  		call	FIND_PROMPT	; Look for prompt string
  5967 00001391 7206                    		jc	short PP0	; Can't find one	
  5968 00001393 26803D00                		cmp	byte [es:di],0
  5969 00001397 750A                    		jnz	short PP1
  5970                                  PP0:					; Use default prompt
  5971 00001399 E87200                  		call	PRINT_DRIVE
  5972                                  		;mov	al,'>'
  5973 0000139C B03E                    		mov	al,SYM
  5974 0000139E E85A00                  		call	PRINT_CHAR
  5975 000013A1 EB3A                    		jmp	short PP5
  5976                                  PP1:
  5977 000013A3 268A05                  		mov	al,[es:di]	; Get a char
  5978 000013A6 47                      		inc	di
  5979 000013A7 08C0                    		or	al,al
  5980 000013A9 7432                    		jz	short PP5	; Nul terminated
  5981 000013AB 3A06[F43E]              		cmp	al,[DOLLAR]	; Meta character
  5982 000013AF 7405                    		jz	short PP2	; Nope
  5983 000013B1 E84700                  		call	PRINT_CHAR
  5984 000013B4 EBED                    		jmp	short PP1
  5985                                  PP2:
  5986 000013B6 268A05                  		mov	al,[es:di]
  5987 000013B9 47                      		inc	di
  5988                                  		;mov	bx,CLSSTRING+2	; "[2J"
  5989 000013BA BB[9C3D]                		mov	bx,PROMPT_TABLE-3
  5990 000013BD 08C0                    		or	al,al
  5991 000013BF 741C                    		jz	short PP5
  5992                                  PP3:
  5993 000013C1 83C303                  		add	bx,3
  5994                                  		;call	UPCONV
  5995 000013C4 E85904                  		call	UPCONV_MAPCALL
  5996 000013C7 3A07                    		cmp	al,[bx]
  5997 000013C9 7407                    		jz	short PP4
  5998 000013CB 803F00                  		cmp	byte [bx],0
  5999 000013CE 75F1                    		jnz	short PP3
  6000 000013D0 EBD1                    		jmp	short PP1
  6001                                  PP4:
  6002 000013D2 06                      		push	es
  6003 000013D3 57                      		push	di
  6004 000013D4 0E                      		push	cs
  6005 000013D5 07                      		pop	es
  6006 000013D6 FF5701                  		call	word [bx+1]
  6007 000013D9 5F                      		pop	di
  6008 000013DA 07                      		pop	es
  6009 000013DB EBC6                    		jmp	short PP1
  6010                                  PP5:
  6011 000013DD 07                      		pop	es		; Restore segments
  6012 000013DE 1F                      		pop	ds
  6013 000013DF C3                      		retn
  6014                                  
  6015                                  ; ---------------------------------------------------------------------------
  6016                                  
  6017                                  PRINT_BACK:
  6018 000013E0 BA[943D]                		mov	dx,DBACKPTR
  6019 000013E3 E9ED20                  		jmp	STD_PRINTF
  6020                                  
  6021                                  ; ---------------------------------------------------------------------------
  6022                                  
  6023                                  PRINT_EQ:
  6024 000013E6 B03D                    		mov	al,'='
  6025 000013E8 EB11                    		jmp	short PRINT_CHAR
  6026                                  
  6027                                  ; ---------------------------------------------------------------------------
  6028                                  
  6029                                  PRINT_ESC:
  6030 000013EA B01B                    		mov	al,1Bh
  6031 000013EC EB0D                    		jmp	short PRINT_CHAR
  6032                                  
  6033                                  ; ---------------------------------------------------------------------------
  6034                                  
  6035                                  PRINT_G:
  6036 000013EE A0[F33E]                		mov	al,[RABRACKET]
  6037 000013F1 EB08                    		jmp	short PRINT_CHAR
  6038                                  
  6039                                  ; ---------------------------------------------------------------------------
  6040                                  
  6041                                  PRINT_L:
  6042 000013F3 A0[F23E]                		mov	al,[LABRACKET]
  6043 000013F6 EB03                    		jmp	short PRINT_CHAR
  6044                                  
  6045                                  ; ---------------------------------------------------------------------------
  6046                                  
  6047                                  PRINT_B:
  6048 000013F8 A0[F13E]                		mov	al,[VBAR]
  6049                                  
  6050                                  ; =============== S U B	R O U T	I N E =======================================
  6051                                  
  6052                                  PRINT_CHAR:
  6053                                  		; MSDOS 6.0
  6054                                  
  6055                                  ;	Bugbug:	Why bother with ds,es here?
  6056                                  		
  6057                                  		;push	es
  6058                                  		;push	ds
  6059                                  		;pop	es
  6060                                  		;push	di
  6061                                  		;push	dx
  6062                                  		;mov	dl,al		;AC000; Get char into al
  6063                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6064                                  		;int	21h		;AC000;
  6065                                  		;pop	dx
  6066                                  		;pop	di
  6067                                  		;pop	es
  6068                                  		;retn
  6069                                  
  6070                                  		; MSDOS 3.3
  6071 000013FB 06                      		push	es
  6072 000013FC 1E                      		push	ds
  6073 000013FD 07                      		pop	es
  6074 000013FE 57                      		push	di
  6075 000013FF 52                      		push	dx
  6076 00001400 BF[6144]                		mov	di,ONE_CHAR_VAL	
  6077 00001403 AA                      		stosb
  6078 00001404 BA[303B]                		mov	dx,ONECHRVALPTR
  6079 00001407 E8C920                  		call	STD_PRINTF
  6080 0000140A 5A                      		pop	dx
  6081 0000140B 5F                      		pop	di
  6082 0000140C 07                      		pop	es
  6083 0000140D C3                      		retn
  6084                                  
  6085                                  ; ---------------------------------------------------------------------------
  6086                                  
  6087                                  PRINT_DRIVE:
  6088 0000140E B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6089 00001410 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6090                                  		;add	al,'A'
  6091 00001412 0206[F03E]              		add	al,[CAPITAL_A]
  6092 00001416 E8E2FF                  		call	PRINT_CHAR
  6093 00001419 C3                      		retn
  6094                                  
  6095                                  ; ---------------------------------------------------------------------------
  6096                                  
  6097                                  BUILD_DIR_FOR_PROMPT:
  6098 0000141A 30D2                    		xor	dl,dl
  6099 0000141C BE[6A43]                		mov	si,BWDBUF
  6100 0000141F 89F7                    		mov	di,si
  6101 00001421 A0[8542]                		mov	al,[CURDRV]
  6102 00001424 0441                    		add	al,'A'
  6103 00001426 B43A                    		mov	ah,':'
  6104 00001428 AB                      		stosw
  6105 00001429 A0[7642]                		mov	al,[DIRCHAR]
  6106 0000142C AA                      		stosb
  6107 0000142D 87F7                    		xchg	si,di
  6108 0000142F 893E[4E44]              		mov	[STRING_PTR_2],di
  6109 00001433 B447                    		mov	ah,CURRENT_DIR ; 47h
  6110 00001435 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6111                                  				; DL = drive (0=default,1=A,etc.)
  6112                                  				; DS:SI	points to 64-byte buffer area
  6113 00001437 BA[3F37]                		mov	dx,STRINGBUF2PTR
  6114 0000143A 7303                    		jnc	short DOPRINT
  6115 0000143C BA[EB39]                		mov	dx,BADCURDRVPTR
  6116                                  DOPRINT:
  6117 0000143F E89120                  		call	STD_PRINTF
  6118 00001442 C3                      		retn
  6119                                  
  6120                                  ; =============== S U B	R O U T	I N E =======================================
  6121                                  
  6122                                  BUILD_DIR_FOR_CHDIR:
  6123 00001443 E80E00                  		call	BUILD_DIR_STRING
  6124 00001446 BA[6A43]                		mov	dx,DIRBUF
  6125 00001449 8916[4E44]              		mov	[STRING_PTR_2],dx
  6126                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6127 0000144D BA[3F37]                		mov	dx,STRINGBUF2PTR
  6128 00001450 E88020                  		call	STD_PRINTF
  6129 00001453 C3                      		retn
  6130                                  
  6131                                  
  6132                                  ; =============== S U B	R O U T	I N E =======================================
  6133                                  
  6134                                  BUILD_DIR_STRING:
  6135 00001454 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6136 00001458 88D0                    		mov	al,dl
  6137 0000145A 0440                    		add	al,'@'
  6138 0000145C 3C40                    		cmp	al,'@'
  6139 0000145E 7506                    		jnz	short GOTDRIVE
  6140 00001460 0206[8542]              		add	al,[CURDRV]
  6141 00001464 FEC0                    		inc	al
  6142                                  GOTDRIVE:
  6143 00001466 50                      		push	ax
  6144 00001467 BE[6D43]                		mov	si,BWDBUF+3
  6145 0000146A B447                    		mov	ah,CURRENT_DIR ; 47h
  6146 0000146C CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6147                                  				; DL = drive (0=default,1=A,etc.)
  6148                                  				; DS:SI	points to 64-byte buffer area
  6149 0000146E 7305                    		jnc	short DPBISOK
  6150 00001470 0E                      		push	cs
  6151 00001471 1F                      		pop	ds
  6152 00001472 E96506                  		jmp	DRVBAD
  6153                                  DPBISOK:
  6154 00001475 BF[6A43]                		mov	di,BWDBUF
  6155 00001478 89FA                    		mov	dx,di
  6156 0000147A 58                      		pop	ax
  6157 0000147B B43A                    		mov	ah,':'
  6158 0000147D AB                      		stosw
  6159 0000147E A0[7642]                		mov	al,[DIRCHAR]
  6160 00001481 AA                      		stosb
  6161 00001482 C3                      		retn
  6162                                  
  6163                                  ; ---------------------------------------------------------------------------
  6164                                  
  6165                                  PATH:
  6166                                  		; MSDOS 6.0
  6167                                  		;xor	al,al		;AN049; Set up holding buffer
  6168                                  		;mov	di,offset Trangroup:srcxname
  6169                                  					;AN049;   for PATH while parsing
  6170                                  		;stosb				;AN049; Initialize PATH to null
  6171                                  		;dec	di			;AN049; point to the start of buffer
  6172                                  		;invoke	PGetarg 		; Pre scan for arguments
  6173                                  		;jz	disppath		; Print the current path
  6174                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6175                                  		;jnz	pathslp 		;AC049;
  6176                                  		;inc	si			;AN049; point past semicolon
  6177                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6178                                  ;pathslp:					; Get the user specified path
  6179                                  		;lodsb				; Get a character
  6180                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6181                                  		;jz	path_eol		;AC049; yes - end of command
  6182                                  		;invoke	testkanj		;See if DBCS
  6183                                  		;jz	notkanj2		;No - continue
  6184                                  		;stosb				;AC049; Yes - store the first byte
  6185                                  		;lodsb				;skip second byte of DBCS
  6186                                  ;path_hold:					;AN049;
  6187                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6188                                  		;jmp	short pathslp		;continue parsing
  6189                                  ;notkanj2:
  6190                                  		;invoke	upconv			;upper case the character
  6191                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6192                                  		;jz	path_hold		;AC049; go store it
  6193                                  		;invoke	delim			;delimiter?
  6194                                  		;jnz	path_hold		;AC049; no - go store character
  6195                                  ;scan_white:					;AN049; make sure were at EOL
  6196                                  		;lodsb				;AN049; get a character
  6197                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6198                                  		;jz	path_eol		;AN049; yes - go set path
  6199                                  		;cmp	al,blank		;AN049; whitespace?
  6200                                  		;jz	scan_white		;AN049; yes - continue scanning
  6201                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6202                                  		;jz	scan_white		;AN049; yes - continue scanning
  6203                                  
  6204                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6205                                  						;AN049; no - set up error message
  6206                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6207                                  						;AN049; get "Too many parameters" message number
  6208                                  		;mov	msg_disp_class,parse_msg_class
  6209                                  						;AN049; set up parse error msg class
  6210                                  		;jmp	cerror			;AN049;
  6211                                  ;path_eol:					;AN049; Parsing was clean
  6212                                  		;xor	al,al			;AN049; null terminate the PATH
  6213                                  		;stosb				;AN049;    buffer
  6214                                  		;invoke	find_path		;AN049; Find PATH in environment
  6215                                  		;invoke	delete_path		;AC049; Delete any offending name
  6216                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6217                                  		;invoke	move_name		;AC049; move in PATH=
  6218                                  		;mov	si,offset Trangroup:srcxname	
  6219                                  						;AN049; Set up source as PATH buffer
  6220                                  ;store_path:					;AN049; Store the PATH in the environment
  6221                                  		;lodsb				;AN049; Get a character
  6222                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6223                                  		;jz	got_paths		;AN049; yes - exit
  6224                                  		;invoke	store_char		;AN049; no - store character
  6225                                  		;jmp	short store_path	;AN049; continue
  6226                                  ;got_paths:					;AN049; we're finished
  6227                                  		;xor	ax,ax			;	null terminate the PATH in
  6228                                  		;stosw				;    	the environment
  6229                                  		;return
  6230                                  ;disppath:
  6231                                  		;invoke	find_path		;AN049;
  6232                                  		;call	print_path
  6233                                  		;call	crlf2
  6234                                  		;retn
  6235                                  
  6236                                  		; MSDOS 3.3
  6237 00001483 E80903                  		call	FIND_PATH		; Find PATH in environment
  6238 00001486 E86409                  		call	PGETARG			; Pre scan for arguments
  6239 00001489 742A                    		jz	short DISPPATH		; Print the current path
  6240 0000148B E8DF02                  		call	DELETE_PATH		; Delete any offending name
  6241 0000148E E86D03                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6242 00001491 E84B03                  		call	MOVE_NAME		; Move in PATH=
  6243 00001494 E85609                  		call	PGETARG
  6244 00001497 3C3B                    		cmp	al,';'
  6245 00001499 7416                    		jz	short GOTPATHS
  6246                                  PATHSLP:
  6247 0000149B AC                      		lodsb
  6248 0000149C 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6249 0000149E 7411                    		jz	short GOTPATHS		; yes - exit
  6250                                  		;call	UPCONV
  6251 000014A0 E87D03                  		call	UPCONV_MAPCALL		; convert to uppercase
  6252 000014A3 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6253 000014A5 7405                    		jz	short NOTDELIM		; go set path
  6254 000014A7 E8D904                  		call	DELIM			; is it delim/null char ?
  6255 000014AA 7405                    		jz	short GOTPATHS		; yes - exit
  6256                                  NOTDELIM:
  6257 000014AC E88503                  		call	STORE_CHAR		; no - store character
  6258 000014AF EBEA                    		jmp	short PATHSLP
  6259                                  GOTPATHS:
  6260 000014B1 31C0                    		xor	ax,ax			; null terminate the PATH
  6261 000014B3 AB                      		stosw				; in the environment
  6262 000014B4 C3                      		retn
  6263                                  DISPPATH:
  6264 000014B5 E80400                  		call	PRINT_PATH
  6265 000014B8 E8B304                  		call	CRLF2
  6266 000014BB C3                      		retn
  6267                                  
  6268                                  ; =============== S U B	R O U T	I N E =======================================
  6269                                  
  6270                                  PRINT_PATH:
  6271 000014BC 26803D00                		cmp	byte [es:di],0
  6272 000014C0 750A                    		jnz	short PATH1
  6273                                  PATH0:
  6274 000014C2 BA[0B3C]                		mov	dx,NULLPATHPTR
  6275 000014C5 0E                      		push	cs
  6276 000014C6 07                      		pop	es
  6277 000014C7 0E                      		push	cs
  6278 000014C8 1F                      		pop	ds
  6279 000014C9 E90720                  		jmp	STD_PRINTF
  6280                                  PATH1:
  6281 000014CC 06                      		push	es
  6282 000014CD 1F                      		pop	ds
  6283 000014CE 83EF05                  		sub	di,5
  6284 000014D1 89FE                    		mov	si,di
  6285 000014D3 E84203                  		call	SCASB2		; Look for null
  6286 000014D6 81F9FF00                		cmp	cx,0FFh
  6287 000014DA 74E6                    		jz	short PATH0
  6288 000014DC 0E                      		push	cs
  6289 000014DD 07                      		pop	es
  6290 000014DE BF[C843]                		mov	di,ARG_BUF
  6291 000014E1 BA0001                  		mov	dx,100h
  6292 000014E4 29CA                    		sub	dx,cx
  6293 000014E6 87D1                    		xchg	dx,cx
  6294 000014E8 F3A4                    		rep movsb
  6295 000014EA BA[2337]                		mov	dx,ARG_BUF_PTR
  6296 000014ED 0E                      		push	cs
  6297 000014EE 1F                      		pop	ds
  6298 000014EF E9E11F                  		jmp	STD_PRINTF
  6299                                  
  6300                                  ; ---------------------------------------------------------------------------
  6301                                  
  6302                                  ; ****************************************************************
  6303                                  ; *
  6304                                  ; * ROUTINE:	 CLS
  6305                                  ; *
  6306                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6307                                  ; *		 installed, send a control string to clear the
  6308                                  ; *		 screen.
  6309                                  ; *
  6310                                  ; * INPUT:	 command line at offset 81H
  6311                                  ; *
  6312                                  ; * OUTPUT:	 none
  6313                                  ; *
  6314                                  ; ****************************************************************
  6315                                  
  6316                                  ; MSDOS 3.3
  6317                                  
  6318                                  CLS:
  6319 000014F2 BB0100                  		mov	bx,STDOUT ; 1
  6320 000014F5 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6321 000014F8 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6322                                  				; BX = file or device handle
  6323 000014FA F6C280                  		test	dl,80h	; devid_ISDEV
  6324 000014FD 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6325 000014FF F6C210                  		test	dl,10h  ; devid_SPECIAL
  6326 00001502 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6327                                  
  6328 00001504 B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6329 00001507 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6330                                  				; AL = interrupt number
  6331                                  				; Return: ES:BX	= value	of interrupt vector
  6332 00001509 8CC2                    		mov	dx,es
  6333 0000150B B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6334 0000150E CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6335                                  				; AL = interrupt number
  6336                                  				; Return: ES:BX	= value	of interrupt vector
  6337 00001510 8CC0                    		mov	ax,es
  6338 00001512 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6339 00001514 7735                    		ja	short ANSICLS
  6340                                  
  6341 00001516 B40F                    		mov	ah,0Fh
  6342 00001518 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6343                                  				; Return: AH = number of columns on screen
  6344                                  				; AL = current video mode
  6345                                  				; BH = current active display page
  6346 0000151A 3C03                    		cmp	al,3
  6347 0000151C 7609                    		jbe	short DOALPHA
  6348 0000151E 3C07                    		cmp	al,7
  6349 00001520 7405                    		jz	short DOALPHA
  6350 00001522 B400                    		mov	ah,0
  6351 00001524 CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6352                                  				; AL = mode
  6353 00001526 C3                      		retn
  6354                                  
  6355                                  DOALPHA:
  6356 00001527 B40B                    		mov	ah,0Bh	; Set overscan to black
  6357 00001529 31DB                    		xor	bx,bx
  6358 0000152B CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6359                                  				; BH = 00h, BL = border color
  6360                                  				; BH = 01h, BL = palette (0-3)
  6361 0000152D B40F                    		mov	ah,0Fh
  6362 0000152F CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6363                                  				; Return: AH = number of columns on screen
  6364                                  				; AL = current video mode
  6365                                  				; BH = current active display page
  6366 00001531 88E2                    		mov	dl,ah
  6367 00001533 FECA                    		dec	dl
  6368 00001535 B618                    		mov	dh,24
  6369 00001537 31C0                    		xor	ax,ax
  6370 00001539 89C1                    		mov	cx,ax
  6371 0000153B BB0007                  		mov	bx,700h
  6372 0000153E B406                    		mov	ah,6
  6373 00001540 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6374                                  				; AL = number of lines to scroll window	
  6375                                  				;	(0 = blank whole window)
  6376                                  				; BH = attributes to be	used on	blanked	lines
  6377                                  				; CH,CL	= row,column of	upper left corner of window 
  6378                                  				;	  to scroll
  6379                                  				; DH,DL	= row,column of	lower right corner of window
  6380 00001542 31D2                    		xor	dx,dx
  6381 00001544 B700                    		mov	bh,0
  6382 00001546 B402                    		mov	ah,2
  6383 00001548 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6384                                  				; DH,DL	= row,column (0,0 = upper left)
  6385                                  				; BH = page number
  6386 0000154A C3                      		retn
  6387                                  
  6388                                  ANSICLS:
  6389 0000154B BE[9A3D]                		mov	si,CLSSTRING
  6390 0000154E AC                      		lodsb
  6391 0000154F 88C1                    		mov	cl,al
  6392 00001551 30ED                    		xor	ch,ch
  6393 00001553 B406                    		mov	ah,RAW_CON_IO ; 6
  6394                                  CLRLOOP:
  6395 00001555 AC                      		lodsb
  6396 00001556 88C2                    		mov	dl,al
  6397 00001558 CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6398                                  				; DL = character <> FFh
  6399                                  				;  Return: ZF set = no character
  6400                                  				;   ZF clear = character recieved, AL = character
  6401 0000155A E2F9                    		loop	CLRLOOP
  6402 0000155C C3                      		retn
  6403                                  
  6404                                  ; ---------------------------------------------------------------------------
  6405                                  
  6406                                  ; MSDOS 6.0
  6407                                  
  6408                                  ;ANSI_installed		equ    0ffh
  6409                                  ;
  6410                                  ;CLS:
  6411                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6412                                  ;	mov	al,0			;AN000;
  6413                                  ;	int	2fh			;AN000;
  6414                                  ;	cmp	al,ANSI_installed	;AN000;
  6415                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6416                                  ;
  6417                                  ;check_lines:
  6418                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6419                                  ;					;AN000; get lines per page on display
  6420                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6421                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6422                                  ;	mov	cl,get_generic		;AN000; get information
  6423                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6424                                  ;	int	21h			;AN000;
  6425                                  ;	jc	no_variable		;AN000; function had error, use default
  6426                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6427                                  ;	mov	dh,al			;AN000; set number of rows
  6428                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6429                                  ;	mov	dl,al			;AN000; set number of columns
  6430                                  ;	jmp	short regcls		;AN000; go do cls
  6431                                  ;
  6432                                  ;no_variable:
  6433                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6434                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6435                                  ;	int	21h			;AC000;
  6436                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6437                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6438                                  ;	test	dl,devid_SPECIAL	;AC000;
  6439                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6440                                  ;
  6441                                  ;ansicls:
  6442                                  ;	call	ansi_cls		;AN000; clear the screen
  6443                                  ;	jmp	short cls_ret		;AN000; exit
  6444                                  ;
  6445                                  ;;
  6446                                  ;; Get video mode
  6447                                  ;;
  6448                                  ;
  6449                                  ;cls_normal:				;AC000;
  6450                                  ;
  6451                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6452                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6453                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6454                                  ;	jbe	DoAlpha
  6455                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6456                                  ;	jz	DoAlpha
  6457                                  ;;
  6458                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6459                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6460                                  ;; screen too.
  6461                                  ;;
  6462                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6463                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6464                                  ;	jmp	short cls_ret		;AC000; exit
  6465                                  ;
  6466                                  ;DoAlpha:
  6467                                  ;;
  6468                                  ;; Get video mode and number of columns to scroll
  6469                                  ;;
  6470                                  ;
  6471                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6472                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6473                                  ;;M01   area
  6474                                  ;;M01   Commented out code here is the original
  6475                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6476                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6477                                  ;;M01	mov	dl,ah
  6478                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6479                                  ;
  6480                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6481                                  ;
  6482                                  ;	push	ds
  6483                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6484                                  ;	MOV	DS,AX			;  *			M01
  6485                                  ;	Assume	DS:ROMBIOS_DATA
  6486                                  ;
  6487                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6488                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6489                                  ;	pop	ds			;			M01
  6490                                  ;	Assume	DS:Trangroup
  6491                                  ;
  6492                                  ;	or	dh,dh			; Q:ZERO		M01
  6493                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6494                                  ;
  6495                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6496                                  ;
  6497                                  ;regcls:
  6498                                  ;	inc	dh			; height+1		M018
  6499                                  ;	call	reg_cls 		; go clear the screen
  6500                                  ;
  6501                                  ;cls_ret:
  6502                                  ;	ret				; exit
  6503                                  
  6504                                  ; ---------------------------------------------------------------------------
  6505                                  
  6506                                  ; MSDOS 6.0
  6507                                  
  6508                                  ; ****************************************************************
  6509                                  ; *
  6510                                  ; * ROUTINE:	 REG_CLS
  6511                                  ; *
  6512                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6513                                  ; *
  6514                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6515                                  ; *		 DH = NUMBER OF ROWS
  6516                                  ; *
  6517                                  ; * OUTPUT:	 none
  6518                                  ; *
  6519                                  ; ****************************************************************
  6520                                  
  6521                                  ;reg_cls proc	near
  6522                                  ;
  6523                                  ;;
  6524                                  ;; Set overscan to black.
  6525                                  ;;
  6526                                  ;	dec	dh			;  decrement rows and columns
  6527                                  ;	dec	dl			;     to zero base
  6528                                  ;	push	dx			;  save rows,columns
  6529                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6530                                  ;	xor	bx,bx
  6531                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6532                                  ;	pop	dx			;  retore rows,colums
  6533                                  ;
  6534                                  ;	xor	ax,ax			;  zero out ax
  6535                                  ;	mov	CX,ax			;     an cx
  6536                                  ;;
  6537                                  ;; Scroll active page
  6538                                  ;;
  6539                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6540                                  ;	mov	bh,video_attribute	; attribute for blank line
  6541                                  ;	xor	bl,bl			; set BL to 0
  6542                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6543                                  ;;
  6544                                  ;; Seek to cursor to 0,0
  6545                                  ;;
  6546                                  ;;M022 following two lines added
  6547                                  ;	mov	ah,get_video_state	; get current video page in BH
  6548                                  ;	int	video_io_int
  6549                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6550                                  ;	xor	dx,dx			; row and column 0
  6551                                  ;;M022	mov	bh.0
  6552                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6553                                  ;
  6554                                  ;	ret
  6555                                  ;
  6556                                  ;reg_cls endp
  6557                                  
  6558                                  ; ---------------------------------------------------------------------------
  6559                                  
  6560                                  ; MSDOS 6.0
  6561                                  
  6562                                  ; ****************************************************************
  6563                                  ; *
  6564                                  ; * ROUTINE:	 ANSI_CLS
  6565                                  ; *
  6566                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6567                                  ; *		 to STDOUT.
  6568                                  ; *
  6569                                  ; * INPUT:	 none
  6570                                  ; *
  6571                                  ; * OUTPUT:	 none
  6572                                  ; *
  6573                                  ; ****************************************************************
  6574                                  
  6575                                  ;ansi_cls proc	near			;AC000;
  6576                                  ;
  6577                                  ;	mov	si,offset trangroup:clsstring
  6578                                  ;	lodsb
  6579                                  ;	mov	cl,al
  6580                                  ;	xor	ch,ch
  6581                                  ;	mov	ah,Raw_CON_IO
  6582                                  ;clrloop:
  6583                                  ;	lodsb
  6584                                  ;	mov	DL,al
  6585                                  ;	int	21h
  6586                                  ;	loop	clrloop
  6587                                  ;	return
  6588                                  ;
  6589                                  ;ansi_cls	endp			;AC000;
  6590                                  
  6591                                  ;============================================================================
  6592                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6593                                  ;============================================================================
  6594                                  ; 08/10/2018 - Retro DOS v3.0
  6595                                  
  6596                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6597                                  
  6598                                  ; ---------------------------------------------------------------------------
  6599                                  
  6600                                  ; ****************************************************************
  6601                                  ; *
  6602                                  ; * ROUTINE:	 CTTY - Change console
  6603                                  ; *
  6604                                  ; * SYNTAX:	 CTTY device
  6605                                  ; *
  6606                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6607                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6608                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6609                                  ; *
  6610                                  ; * INPUT:	 command line at offset 81H
  6611                                  ; *
  6612                                  ; * OUTPUT:	 none
  6613                                  ; *
  6614                                  ; ****************************************************************
  6615                                  
  6616                                  CTTY:
  6617                                  		; MSDOS 6.0
  6618                                  		;push	ds			;AN000; Get local ES
  6619                                  		;pop	es			;AN000;
  6620                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6621                                  
  6622                                  		;mov	di,offset trangroup:parse_ctty	
  6623                                  						;AC000; Get adderss of PARSE_CTTY
  6624                                  		;xor	cx,cx			;AC000; clear cx,dx
  6625                                  		;xor	dx,dx			;AC000;
  6626                                  		;invoke	cmd_parse		;AC000; call parser
  6627                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6628                                  		;jz	ctty_error		;AN000; yes - error
  6629                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6630                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6631                                  
  6632                                  		;push	si			;AN000; save position in line
  6633                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6634                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6635                                  
  6636                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6637                                  		;lodsb				;AN000; get a char from buffer
  6638                                  		;stosb				;AN000; store in srcbuf
  6639                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6640                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6641                                  		;pop	si			;AN000; get line position back
  6642                                  		;mov	di,offset trangroup:parse_ctty	
  6643                                  						;AC000; Get adderss of PARSE_CTTY
  6644                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6645                                  		;jz	nocolon 		;AN000; yes - continue
  6646                                  
  6647                                  ;ctty_error:
  6648                                  		;jmp	short isbaddev		;AC000; yes - exit
  6649                                  
  6650                                  		; MSDOS 3.3
  6651 0000155D E81908                  		call	SETPATH
  6652 00001560 4E                      		dec	si
  6653 00001561 4E                      		dec	si
  6654 00001562 803C3A                  		cmp	byte [si],':'
  6655 00001565 7503                    		jnz	short NOCOLON
  6656 00001567 C60400                  		mov	byte [si],0
  6657                                  NOCOLON:
  6658                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6659                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6660 0000156A B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6661 0000156D CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6662                                  				; DS:DX	-> ASCIZ filename
  6663                                  				; AL = access mode
  6664                                  				; 2 - read & write
  6665 0000156F 7210                    		jc	short ISBADDEV
  6666 00001571 89C3                    			mov	bx,ax
  6667 00001573 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6668 00001576 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6669                                  				; BX = file or device handle
  6670 00001578 F6C280                  		test	dl,80h
  6671 0000157B 750C                    		jnz	short DEVISOK
  6672                                  CLOSEDEV:
  6673 0000157D B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6674 0000157F CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6675                                  				; BX = file handle
  6676                                  ISBADDEV:
  6677 00001581 BA[533C]                		mov	dx,BADDEVPTR
  6678 00001584 E84C1F                  		call	STD_PRINTF
  6679 00001587 EB28                    		jmp	short RESRET
  6680                                  
  6681                                  		;nop
  6682                                  DEVISOK:
  6683                                  		; MSDOS 6.0
  6684                                  		;push	dx		;AN007; save device info
  6685                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6686                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6687                                  		;push	bx		;AN021; save handle
  6688                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6689                                  		;mov	dx,si		;AN021; get address into dx
  6690                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6691                                  		;mov	cx,2		;AN007; write two bytes
  6692                                  		;int	21h		;AN007;
  6693                                  		;pop	bx		;AN021; get back handle
  6694                                  		;pop	dx		;AN007; get back device info
  6695                                  		;jc	closedev	;AN007; if error, quit
  6696                                  
  6697                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6698 00001589 30F6                    		xor	dh,dh
  6699 0000158B 80CA03                  		or	dl,3
  6700                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6701 0000158E B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6702 00001591 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6703                                  				; BX = device handle,DH = 0
  6704                                  				; DL = device information to set 
  6705                                  				;		(bits 0-7 from	function 0)
  6706 00001593 53                      		push	bx
  6707 00001594 B90300                  		mov	cx,3
  6708 00001597 31DB                    		xor	bx,bx
  6709                                  
  6710                                  ICLLOOP:				; Close basic handles
  6711 00001599 B43E                    		mov	ah,CLOSE ; 3Eh
  6712 0000159B CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6713                                  				; BX = file handle
  6714 0000159D 43                      		inc	bx
  6715 0000159E E2F9                    		loop	ICLLOOP
  6716 000015A0 5B                      		pop	bx		; Get handle
  6717 000015A1 B445                    		mov	ah,XDUP ; 45h
  6718 000015A3 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6719                                  				; BX = file handle to duplicate
  6720 000015A5 B445                    		mov	ah,XDUP ; 45h
  6721 000015A7 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6722                                  				; BX = file handle to duplicate
  6723 000015A9 B445                    		mov	ah,XDUP ;45h
  6724 000015AB CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6725                                  				; BX = file handle to duplicate
  6726 000015AD B43E                    		mov	ah,CLOSE ; 3Eh
  6727 000015AF CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6728                                  				; BX = file handle
  6729                                  RESRET:
  6730 000015B1 8E1E[7142]              		mov	ds,[RESSEG]
  6731 000015B5 1E                      		push	ds
  6732 000015B6 A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6733 000015B9 A3EF0B                  		mov	word [IO_SAVE],ax
  6734                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6735                                  		;mov	ax,31Eh ;  MSDOS 3.3
  6736 000015BC B81803                  		mov	ax,LODCOM1
  6737 000015BF 50                      		push	ax
  6738                                  
  6739 000015C0 CB                      		retf		; Far return
  6740                                  
  6741                                  ; ---------------------------------------------------------------------------
  6742                                  
  6743                                  ;****************************************************************
  6744                                  ;*
  6745                                  ;* ROUTINE:	CHCP - Change code page internal command
  6746                                  ;*		(added DOS 3.30 07/21/86)
  6747                                  ;*
  6748                                  ;* SYNTAX:	CHCP [xxx]
  6749                                  ;*		where xxx is a valid code page
  6750                                  ;*
  6751                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6752                                  ;*		6402H to set the code page to xxxx. If no parameters
  6753                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6754                                  ;*		to get global code page and display it to the user.
  6755                                  ;*
  6756                                  ;* INPUT:	command line at offset 81H
  6757                                  ;*
  6758                                  ;* OUTPUT:	none
  6759                                  ;*
  6760                                  ;****************************************************************
  6761                                  
  6762                                  ;NLSFUNC_installed equ  0FFh
  6763                                  set_global_cp	  equ   2
  6764                                  get_global_cp	  equ   1
  6765                                  
  6766                                  CHCP:
  6767                                  		; MSDOS 6.0
  6768                                  		;push	ds		;AN000; Get local ES
  6769                                  		;pop	es		;AN000;
  6770                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6771                                  
  6772                                  		;mov	di,offset trangroup:parse_chcp	
  6773                                  					;AN000; Get adderss of PARSE_CHCP
  6774                                  		;xor	cx,cx		;AC000; clear cx,dx
  6775                                  		;xor	dx,dx		;AC000;
  6776                                  		;call	parse_with_msg	;AC018; call parser
  6777                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6778                                  
  6779                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6780                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6781                                  ;setcp:
  6782                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6783                                  		;jne	cp_error	;AC018; yes - go issue message
  6784                                  
  6785                                  		;push	cx		;AN000; save positional count
  6786                                  		;mov	bx,offset trangroup:parse1_addr 
  6787                                  					;AN000; get number returned
  6788                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6789                                  		;mov	system_cpage,cx ;AN000; save user input number
  6790                                  		;pop	cx		;AC000; restore positional count
  6791                                  		;mov	di,offset trangroup:parse_chcp	
  6792                                  					;AN000; Get adderss of PARSE_CHCP
  6793                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6794                                  		;jnz	cp_error	;AC000; no - exit
  6795                                  ;okset:
  6796                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6797                                  		;mov	al,0		;AN000;
  6798                                  		;int	2fh		;AN000;
  6799                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6800                                  		;jz	got_NLS 	;AN000; Yes - continue
  6801                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6802                                  					;AN000; no - set up error message
  6803                                  		;jmp	short cp_error	;AN000; error exit
  6804                                  ;got_NLS:
  6805                                  
  6806                                  		; MSDOS 3.3
  6807 000015C1 BE8100                  		mov	si,81h
  6808 000015C4 E8B403                  		call	SCANOFF
  6809 000015C7 3C0D                    		cmp	al,0Dh ; CR
  6810 000015C9 7502                    		jnz	short SETCP
  6811 000015CB EB72                    		jmp	short GETCP
  6812                                  
  6813                                  		;nop
  6814                                  SETCP:
  6815 000015CD 31DB                    		xor	bx,bx
  6816 000015CF 89D9                    		mov	cx,bx
  6817 000015D1 89D8                    		mov	ax,bx
  6818                                  GET_CP_DIGIT:
  6819 000015D3 AC                      		lodsb
  6820 000015D4 3C30                    		cmp	al,'0'
  6821 000015D6 721C                    		jb	short CHRNOTNUMBER
  6822 000015D8 3C39                    		cmp	al,'9'
  6823 000015DA 7718                    		ja	short CHRNOTNUMBER
  6824 000015DC 2C30                    		sub	al,'0'
  6825 000015DE FEC1                    		inc	cl
  6826 000015E0 80F904                  		cmp	cl,4
  6827 000015E3 771B                    		ja	short CHCP_BADPARM
  6828 000015E5 89DA                    		mov	dx,bx
  6829 000015E7 D1E2                    		shl	dx,1
  6830 000015E9 D1E2                    		shl	dx,1
  6831 000015EB 01D3                    		add	bx,dx
  6832 000015ED D1E3                    		shl	bx,1
  6833 000015EF 01C3                    		add	bx,ax
  6834 000015F1 EBE0                    		jmp	short GET_CP_DIGIT
  6835                                  CP_NEXTCHR:
  6836 000015F3 AC                      		lodsb
  6837                                  CHRNOTNUMBER:
  6838 000015F4 3C20                    		cmp	al,' '		; SPACE
  6839 000015F6 74FB                    		jz	short CP_NEXTCHR
  6840 000015F8 3C09                    		cmp	al,9		; TAB
  6841 000015FA 74F7                    		jz	short CP_NEXTCHR
  6842 000015FC 3C0D                    		cmp	al,0Dh		; CR
  6843 000015FE 7406                    		jz	short SET_CP_TBL_NUM
  6844                                  CHCP_BADPARM:
  6845 00001600 BA[223A]                		mov	dx,BADPARMPTR
  6846 00001603 E92506                  		jmp	CERROR
  6847                                  ;GOT_NLS:
  6848                                  SET_CP_TBL_NUM:
  6849                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6850 00001606 891E[0F3F]              		mov	word [SYSTEM_CPAGE],bx
  6851 0000160A B466                    		mov	ah,GETSETCDPG  ; 66h
  6852 0000160C B002                    		mov	al,set_global_cp ; 2
  6853 0000160E CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6854                                  				; BX = active code page
  6855                                  				; DX = system code page	(active	page at	boot time)
  6856 00001610 733D                    		jnc	short CHCP_RETURN
  6857                                  
  6858 00001612 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6859 00001615 7511                    		jnz	short CHCP_OTHER_ERROR
  6860                                  
  6861 00001617 B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6862 00001619 31DB                    		xor	bx,bx
  6863 0000161B CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6864                                  				; BX = version code (0000h for DOS 3.x)
  6865 0000161D 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6866 00001620 7417                    		jz	short NONE_SET
  6867 00001622 BA[F837]                		mov	dx,FNOTFOUNDPTR
  6868 00001625 E90306                  		jmp	CERROR
  6869                                  CHCP_OTHER_ERROR:			; end of p716
  6870 00001628 B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6871 0000162A 31DB                    		xor	bx,bx
  6872 0000162C CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6873                                  				; BX = version code (0000h for DOS 3.x)
  6874 0000162E 83F841                  		cmp	ax,65		;was it access denied?
  6875 00001631 7506                    		jnz	short NONE_SET	;no - assume all failed
  6876 00001633 BA[A839]                		mov	dx,CPNOTALLPTR	;set up message
  6877 00001636 E9F205                  		jmp	CERROR		;AC000; error exit
  6878                                  NONE_SET:
  6879 00001639 BA[7539]                		mov	dx,CPNOTSETPTR	;set up message
  6880                                  CP_ERROR:
  6881 0000163C E9EC05                  		jmp	CERROR		;exit
  6882                                  GETCP:
  6883 0000163F B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6884 00001641 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6885 00001643 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6886 00001645 891E[0F3F]              		mov	word [SYSTEM_CPAGE],bx ;get active cp for output
  6887 00001649 BA[C639]                		mov	dx,CPACTIVEPTR
  6888 0000164C E8841E                  		call	STD_PRINTF	;print it out
  6889                                  CHCP_RETURN:
  6890 0000164F C3                      		retn
  6891                                  
  6892                                  ; ---------------------------------------------------------------------------
  6893                                  
  6894                                  ; ****************************************************************
  6895                                  ; *
  6896                                  ; * ROUTINE:	 TRUENAME
  6897                                  ; *
  6898                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  6899                                  ; *		 Parses the command line. If a path is found, set
  6900                                  ; *		 SRCXNAME to path.  If only a drive letter is
  6901                                  ; *		 found, set SRCXNAME to the drive letter.  If
  6902                                  ; *		 no path is found, set the path of SRCXNAME to
  6903                                  ; *		 dot (.) for current directory.  Use the NAME
  6904                                  ; *		 TRANSLATE system call to get the real name and
  6905                                  ; *		 then display the real name.  If an error occurs
  6906                                  ; *		 issue an error message and transfer control to
  6907                                  ; *		 CERROR.
  6908                                  ; *
  6909                                  ; * INPUT:	 command line at offset 81H
  6910                                  ; *
  6911                                  ; * OUTPUT:	 none
  6912                                  ; *
  6913                                  ; ****************************************************************
  6914                                  
  6915                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  6916                                  ;
  6917                                  ;TRUENAME:					;AN000; TRUENAME entry point
  6918                                  ;	push	ds				;AN000; Get local ES
  6919                                  ;	pop	es				;AN000;
  6920                                  ;	mov	si,81H				;AN000; Get command line
  6921                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
  6922                                  ;	xor	cx,cx				;AN000; clear cx,dx
  6923                                  ;	xor	dx,dx				;AN000;
  6924                                  ;	call	parse_with_msg			;AC018; call parser
  6925                                  ;
  6926                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  6927                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  6928                                  ;	je	tn_eol				;AN000; yes - go process
  6929                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  6930                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  6931                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  6932                                  ;	je	tn_drive			;AN000; yes - go process
  6933                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  6934                                  ;
  6935                                  ;tn_eol: 					;AN000; no parameters on line
  6936                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  6937                                  ;	mov	al,dot_chr			;AN000;     for current dir
  6938                                  ;	stosw					;AN000; store in srcxname
  6939                                  ;	jmp	short tn_doit			;AN000; go do command
  6940                                  ;
  6941                                  ;tn_drive:					;AN000; a drive was entered
  6942                                  ;	push	si				;AN000; save position in line
  6943                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  6944                                  ;	lodsb					;AN000; get the drive number
  6945                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  6946                                  ;	stosb					;AN000; store it in srcxname
  6947                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  6948                                  ;	stosw					;AN000;    store in srcxname
  6949                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  6950                                  ;	stosb					;AN000;
  6951                                  ;	pop	si				;AN000; get line position back
  6952                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  6953                                  ;
  6954                                  ;tn_filespec:					;AN000; a filespec was entered
  6955                                  ;	push	si				;AN000; save position in line
  6956                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  6957                                  ;
  6958                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  6959                                  ;	lodsb					;AN000; get a char from buffer
  6960                                  ;	stosb					;AN000; store in srcxname
  6961                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  6962                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  6963                                  ;	pop	si				;AN000; get line position back
  6964                                  ;
  6965                                  ;tn_check_eol:					;AN000; make sure no extra parms
  6966                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  6967                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  6968                                  ;	je	tn_doit 			;AN000; Yes - do the command
  6969                                  ;
  6970                                  ;tn_parse_error: 				;AN000; A parse error occurred
  6971                                  ;	jmp	cerror				;AN000; Go to error routine
  6972                                  ;
  6973                                  ;tn_doit:					;AN000;
  6974                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  6975                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  6976                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  6977                                  ;	int	21h			;AN000;
  6978                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  6979                                  ;
  6980                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  6981                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  6982                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  6983                                  ;	jmp	cerror				;AN000; Go to error routine
  6984                                  ;
  6985                                  ;tn_print_xname: 				;AN000;
  6986                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  6987                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  6988                                  ;	invoke	crlf2				;AN000; print a crlf
  6989                                  ;	invoke	printf_crlf			;AN000; print it out
  6990                                  ;
  6991                                  ;	ret					;AN000;
  6992                                  ;
  6993                                  
  6994                                  ; ---------------------------------------------------------------------------
  6995                                  
  6996                                  _$EXIT:
  6997                                  		; MSDOS 3.3
  6998 00001650 8E06[7142]              		mov	es,[RESSEG]
  6999 00001654 26A18C0B                		mov	ax,word [es:PARENT]
  7000                                  		;mov	[es:16h],ax
  7001 00001658 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7002 0000165C 26A18E0B                		mov	ax,word [es:OLDTERM]
  7003                                  		;mov	[es:0Ah],ax
  7004 00001660 26A30A00                		mov	[es:PDB.EXIT],ax
  7005 00001664 26A1900B                		mov	ax,word [es:OLDTERM+2]
  7006                                  		;mov	[es:0Ch],ax
  7007 00001668 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7008 0000166C 06                      		push	es
  7009 0000166D 8E06[8142]              		mov	es,[TRAN_TPA]
  7010 00001671 B449                    		mov	ah,DEALLOC ; 49h
  7011 00001673 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7012                                  				; ES = segment address of area to be freed
  7013 00001675 07                      		pop	es
  7014 00001676 B44C                    		mov	ah,EXIT ; 4Ch
  7015                                  		;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
  7016 00001678 26A0EA0B                		mov	al,byte [es:RETCODE]
  7017 0000167C CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7018                                  
  7019                                  ;;here:
  7020                                  ;;		jmp	short here
  7021                                  
  7022                                  		; MSDOS 6.0
  7023                                  		;push	ds			;AN000; save data segment
  7024                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7025                                  
  7026                                  		;assume	ds:resgroup		;AN000;
  7027                                  
  7028                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7029                                  		;jz	free_com		;AN045; no - free everything
  7030                                  
  7031                                  ;	We're a permanent command.
  7032                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7033                                  
  7034                                  		;cmp	[singlecom],-1		;M034
  7035                                  		;je	no_reset		;M034	;exit singlecom
  7036                                  
  7037                                  		;jmp	TCommand		;permanent command, recycle
  7038                                  
  7039                                  ;free_com:
  7040                                  		;mov	ax,(multdos shl 8 or message_2f)
  7041                                  						;AN060; reset parse message pointers
  7042                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7043                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7044                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7045                                  		;int	2fh			;AN000; go set it
  7046                                  ;no_reset:					;AN045;
  7047                                  		;pop	ds			;AN000; restore local data segment
  7048                                  
  7049                                  		;assume	ds:trangroup		;AN000;
  7050                                  ;
  7051                                  ;M040
  7052                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7053                                  ;this, restores user dir if flag is set and resets the flag.
  7054                                  ;
  7055                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7056                                  		;MOV	ES,[RESSEG]
  7057                                  
  7058                                  		;assume	es:resgroup
  7059                                  
  7060                                  		;MOV	AX,[PARENT]
  7061                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7062                                  		;MOV	AX,WORD PTR OldTerm
  7063                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7064                                  		;MOV	AX,WORD PTR OldTerm+2
  7065                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7066                                  
  7067                                  		;PUSH	ES
  7068                                  		;MOV	ES,[TRAN_TPA]
  7069                                  		;MOV	AH,DEALLOC
  7070                                  		;INT	21h			; Now running in "free" space
  7071                                  		;POP	ES
  7072                                  
  7073                                  		;MOV	AH,Exit
  7074                                  		;MOV	AL,BYTE PTR RetCode
  7075                                  		;INT	21h
  7076                                  
  7077                                  ; ---------------------------------------------------------------------------
  7078                                  
  7079                                  ; MSDOS 6.0
  7080                                  ; ****************************************************************
  7081                                  ; *
  7082                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7083                                  ; *
  7084                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7085                                  ; *		 If not end of line, set up to print parse
  7086                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7087                                  ; *		 EXPECTED!
  7088                                  ; *
  7089                                  ; * INPUT:	 DS:SI	  last output from parser
  7090                                  ; *		 ES:DI	  points to parse block
  7091                                  ; *		 CX	  last output from parser
  7092                                  ; *
  7093                                  ; * OUTPUT:	 AX	  parser return code
  7094                                  ; *
  7095                                  ; *		 if end of line found
  7096                                  ; *		     zero flag set
  7097                                  ; *		 else
  7098                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7099                                  ; *
  7100                                  ; ****************************************************************
  7101                                  
  7102                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7103                                  ;
  7104                                  ;parse_check_eol Proc near			;AN000;
  7105                                  ;
  7106                                  ;	xor	dx,dx				;AN000;
  7107                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7108                                  ;	invoke	cmd_parse			;AN000; call parser
  7109                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7110                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7111                                  ;
  7112                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7113                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7114                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7115                                  ;
  7116                                  ;ok_to_setup_pmsg:
  7117                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7118                                  ;
  7119                                  ;parse_good_eol:
  7120                                  ;	ret					;AN000;
  7121                                  ;
  7122                                  ;parse_check_eol endp				;AN000;
  7123                                  
  7124                                  ; ---------------------------------------------------------------------------
  7125                                  
  7126                                  ; MSDOS 6.0
  7127                                  ; ****************************************************************
  7128                                  ; *
  7129                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7130                                  ; *
  7131                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7132                                  ; *		 message is set up.
  7133                                  ; *
  7134                                  ; * INPUT:	 DS:SI	  last output from parser
  7135                                  ; *		 ES:DI	  points to parse block
  7136                                  ; *		 CX	  last output from parser
  7137                                  ; *
  7138                                  ; * OUTPUT:	 AX	  parser return code
  7139                                  ; *
  7140                                  ; *		 if no error
  7141                                  ; *		     outputs from parser
  7142                                  ; *		 else
  7143                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7144                                  ; *		     error message set up for STD_PRINTF
  7145                                  ; *
  7146                                  ; ****************************************************************
  7147                                  
  7148                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7149                                  ;
  7150                                  ;parse_with_msg	Proc near			;AN018;
  7151                                  ;
  7152                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7153                                  ;	invoke	cmd_parse			;AN018; call parser
  7154                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7155                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7156                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7157                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7158                                  ;
  7159                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7160                                  ;
  7161                                  ;parse_msg_good:
  7162                                  ;	ret					;AN018;
  7163                                  ;
  7164                                  ;parse_with_msg endp				;AN018;
  7165                                  
  7166                                  ; ---------------------------------------------------------------------------
  7167                                  
  7168                                  ; MSDOS 6.0
  7169                                  ; ****************************************************************
  7170                                  ; *
  7171                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7172                                  ; *
  7173                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7174                                  ; *		 message is set up.
  7175                                  ; *
  7176                                  ; * INPUT:	 AX	     Parse error number
  7177                                  ; *		 SI	     Set to past last parameter
  7178                                  ; *		 Parse_last  Set to start of last parameter
  7179                                  ; *
  7180                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7181                                  ; *		 error message set up for STD_PRINTF
  7182                                  ; *
  7183                                  ; ****************************************************************
  7184                                  
  7185                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7186                                  ;
  7187                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7188                                  ;
  7189                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7190                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7191                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7192                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7193                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7194                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7195                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7196                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7197                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7198                                  ;
  7199                                  ;setup_parse_msg_ret:
  7200                                  ;	inc	si				;AN018; make sure zero flag not set
  7201                                  ;
  7202                                  ;	ret					;AC018;
  7203                                  ;
  7204                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7205                                  
  7206                                  ;============================================================================
  7207                                  ; TENV.ASM, MSDOS 6.0, 1991
  7208                                  ;============================================================================
  7209                                  ; 08/10/2018 - Retro DOS v3.0
  7210                                  
  7211                                  ; TITLE	Part6 COMMAND Transient routines.
  7212                                  
  7213                                  ;	Environment utilities and misc. routines
  7214                                  
  7215                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7216                                  
  7217                                  ; ---------------------------------------------------------------------------
  7218                                  
  7219                                  ADD_PROMPT:
  7220 0000167E E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7221 00001681 E87A01                  		call	SCAN_DOUBLE_NULL
  7222                                  
  7223                                  ADD_PROMPT2:
  7224 00001684 56                      		push	si
  7225 00001685 E86801                  		call	GETARG
  7226 00001688 5E                      		pop	si
  7227 00001689 7501                    		jnz	short ADD_PROMPT3
  7228                                  ADD_PROMPT_RETN:
  7229 0000168B C3                      		retn
  7230                                  ADD_PROMPT3:				; Pre scan for arguments
  7231 0000168C E85001                  		call	MOVE_NAME	 ;Move in name
  7232 0000168F E85E01                  		call	GETARG
  7233 00001692 56                      		push	si
  7234 00001693 EB4F                    		jmp	short ADD_NAME
  7235                                  
  7236                                  ;break	The SET command
  7237                                  
  7238                                  ; Input: DS:SI points to a CR terminated string
  7239                                  ; Output: carry flag is set if no room
  7240                                  ;	  otherwise name is added to environment
  7241                                  
  7242                                  DISP_ENVJ:
  7243 00001695 E9B100                  		jmp	DISP_ENV
  7244                                  
  7245                                  ADD_NAME_TO_ENVIRONMENT:
  7246 00001698 E85501                  		call	GETARG
  7247 0000169B 74F8                    		jz	short DISP_ENVJ
  7248                                  
  7249                                  ; check if line contains exactly one equals sign
  7250                                  
  7251 0000169D 31DB                    		xor	bx,bx		; = count is 0
  7252 0000169F 56                      		push	si		; Save pointer to beginning of line
  7253                                  EQLP:
  7254 000016A0 AC                      		lodsb			; Get a char
  7255 000016A1 3C0D                    		cmp	al,13		; IF CR we're all done
  7256 000016A3 740F                    		jz	short QUEQ	
  7257 000016A5 3C3D                    		cmp	al,'='		; Look for = sign	
  7258 000016A7 75F7                    		jnz	short EQLP	; not there, get next char
  7259 000016A9 FEC3                    		inc	bl		; Otherwise increment EQ count
  7260 000016AB 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7261 000016AE 75F0                    		jnz	short EQLP
  7262 000016B0 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7263 000016B2 EBEC                    		jmp	short EQLP	; And look for more
  7264                                  QUEQ:
  7265 000016B4 5E                      		pop	si		; Restore beginning of line
  7266 000016B5 FECB                    		dec	bl		; Zero flag means only one EQ
  7267 000016B7 7406                    		jz	short ONEQ	; Good line
  7268 000016B9 BA[783C]                		mov	dx,SYNTMESPTR
  7269 000016BC E96C05                  		jmp	CERROR
  7270                                  ONEQ:
  7271 000016BF 53                      		push	bx
  7272 000016C0 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7273 000016C3 5B                      		pop	bx
  7274 000016C4 FECF                    		dec	bh
  7275 000016C6 74C3                    		jz	short ADD_PROMPT_RETN
  7276 000016C8 E83301                  		call	SCAN_DOUBLE_NULL
  7277 000016CB 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7278 000016CD E80F01                  		call	MOVE_NAME
  7279 000016D0 56                      		push	si
  7280 000016D1 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7281                                  					;  env var name
  7282                                  		
  7283                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7284                                  ; necessary in the resident for re-reading the transient. Let's look for
  7285                                  ; COMSPEC=
  7286                                  
  7287                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7288 000016D3 BE[193C]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7289 000016D6 B90400                  		mov	cx,4
  7290 000016D9 F3A7                    		repe cmpsw
  7291 000016DB 7505                    		jnz	short NOT_COMSPEC
  7292                                  					; Zero set => exact match
  7293                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7294 000016DD C606[A845]01            		mov	byte [COMSPEC_FLAG],1
  7295                                  NOT_COMSPEC:
  7296 000016E2 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7297                                  ADD_NAME:
  7298 000016E4 5E                      		pop	si		; Add the value of the new env var
  7299 000016E5 56                      		push	si		;  to the environment.
  7300                                  ADD_NAME1:
  7301 000016E6 AC                      		lodsb
  7302 000016E7 3C0D                    		cmp	al,13
  7303 000016E9 7405                    		jz	short ADD_NAME_RET
  7304 000016EB E84601                  		call	STORE_CHAR
  7305 000016EE EBF6                    		jmp	short ADD_NAME1
  7306                                  ADD_NAME_RET:
  7307 000016F0 5E                      		pop	si
  7308 000016F1 803E[A845]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7309                                  ADD_NAME_JZ_RET:
  7310 000016F6 7493                    		jz	short ADD_PROMPT_RETN 
  7311                                  					;  copy the value into the
  7312                                  					;  comspec var in the resident
  7313                                  
  7314                                  ; We have changed the COMSPEC variable. We need to update the resident
  7315                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7316                                  
  7317 000016F8 E88002                  		call	SCANOFF
  7318 000016FB 8E06[7142]              		mov	es,[RESSEG]	;  comspec var in the resident
  7319                                  
  7320                                  ; Make sure that the printer knows where the beginning of the string is
  7321                                  
  7322 000016FF BF990B                  		mov	di,COMSPEC
  7323 00001702 89FB                    		mov	bx,di
  7324                                  
  7325                                  ; Generate drive letter for display
  7326                                  
  7327 00001704 31C0                    		xor	ax,ax		;g assume no drive first
  7328 00001706 26A2E40B                		mov	byte [es:COMDRV],al ;g
  7329 0000170A 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7330 0000170E 7512                    		jnz	short _GOTDRIVE
  7331 00001710 8A04                    		mov	al,[si]		; get his specified drive
  7332                                  		;call	UPCONV
  7333 00001712 E80B01                  		call	UPCONV_MAPCALL	; convert to uppercase
  7334 00001715 2C41                    		sub	al,'A'		; convert to 0-based
  7335 00001717 83C702                  		add	di,2
  7336 0000171A FEC0                    		inc	al		; convert to 1-based number
  7337 0000171C 26A2E40B                		mov	byte [es:COMDRV],al
  7338                                  
  7339                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7340                                  ; done here..
  7341                                  		;add	al,40h
  7342 00001720 0440                    		add	al,'A'-1
  7343                                  _GOTDRIVE:
  7344                                  		;mov	word [es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7345 00001722 26893ED90B              		mov	word [es:PUTBACKSUBSTPTR],di
  7346                                  					;g point to beginning of name after drive
  7347                                  		;mov	byte [es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7348 00001727 26A2210A                		mov	byte [es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7349                                  
  7350                                  ; Copy chars until delim      	
  7351                                  
  7352 0000172B 89DF                    		mov	di,bx
  7353                                  COPY_COMSPEC:
  7354 0000172D AC                      		lodsb
  7355 0000172E E85202                  		call	DELIM
  7356 00001731 7407                    		jz	short COPYDONE
  7357 00001733 3C0D                    		cmp	al,13
  7358 00001735 7403                    		jz	short COPYDONE
  7359 00001737 AA                      		stosb
  7360 00001738 EBF3                    		jmp	short COPY_COMSPEC
  7361                                  COPYDONE:
  7362 0000173A 30C0                    		xor	al,al		; Null terminate the string and quit
  7363 0000173C AA                      		stosb
  7364 0000173D C606[A845]00            		mov	byte [COMSPEC_FLAG],0
  7365 00001742 4F                      		dec	di
  7366 00001743 26893EDB0B              		mov	word [es:COMSPEC_END],di
  7367 00001748 C3                      		retn
  7368                                  DISP_ENV:
  7369 00001749 8E1E[7142]              		mov	ds,[RESSEG]
  7370 0000174D 8E1E030D                		mov	ds,word [ENVIRSEG]
  7371                                  		; assume ds:nothing
  7372 00001751 31F6                    		xor	si,si
  7373                                  PENVLP:
  7374 00001753 803C00                  		cmp	byte [si],0
  7375 00001756 749E                    		jz	short ADD_NAME_JZ_RET
  7376 00001758 BF[C843]                		mov	di,ARG_BUF
  7377                                  PENVLP2:
  7378 0000175B AC                      		lodsb
  7379 0000175C AA                      		stosb
  7380 0000175D 08C0                    		or	al,al
  7381 0000175F 75FA                    		jnz	short PENVLP2
  7382 00001761 BA[2337]                		mov	dx,ARG_BUF_PTR
  7383 00001764 1E                      		push	ds
  7384 00001765 06                      		push	es
  7385 00001766 1F                      		pop	ds
  7386                                  		; assume ds:nothing
  7387 00001767 E8591D                  		call	PRINTF_CRLF
  7388 0000176A 1F                      		pop	ds
  7389 0000176B EBE6                    		jmp	short PENVLP
  7390                                  
  7391                                  ; =============== S U B	R O U T	I N E =======================================
  7392                                  
  7393                                  DELETE_PATH:
  7394 0000176D BE[0D3C]                		mov	si,PATH_TEXT ; "PATH="
  7395 00001770 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7396                                  
  7397                                  ; =============== S U B	R O U T	I N E =======================================
  7398                                  
  7399                                  DELETE_PROMPT:
  7400 00001772 BE[123C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7401                                  
  7402                                  ; ---------------------------------------------------------------------------
  7403                                  
  7404                                  DELETE_NAME_IN_ENVIRONMENT:
  7405                                  
  7406                                  ; Input: DS:SI points to a "=" terminated string
  7407                                  ; Output: carry flag is set if name not found
  7408                                  ;	  otherwise name is deleted
  7409                                  
  7410 00001775 56                      		push	si
  7411 00001776 1E                      		push	ds
  7412 00001777 E82400                  		call	FIND		; ES:DI points to name
  7413 0000177A 7210                    		jc	short DEL1
  7414 0000177C 89FE                    		mov	si,di		; Save it
  7415 0000177E E89700                  		call	SCASB2		; Scan for the nul
  7416 00001781 87F7                    		xchg	si,di
  7417                                  ;SR;
  7418                                  ; If we have only one env string, then the double null is lost when the last
  7419                                  ;string is deleted and we have an invalid empty environment with only a 
  7420                                  ;single null. To avoid this, we will look for the double null case and then
  7421                                  ;move an extra null char.
  7422                                  ; Bugbug: The only possible problem is that the last pathstring 
  7423                                  ;will be followed by a triple null. Is this really a problem?
  7424                                  
  7425                                  		; MSDOS 6.0
  7426                                  		;cmp	byte ptr es:[si],0 ;null char?
  7427                                  		;jnz	not_dnull	   ;no, we are at a double null
  7428                                  		;dec	si		   ;point at the double null
  7429                                  ;not_dnull:
  7430                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7431 00001783 E8F600                  		call	GETENVSIZ
  7432 00001786 29F1                    		sub	cx,si
  7433 00001788 06                      		push	es
  7434 00001789 1F                      		pop	ds		; ES:DI points to name
  7435                                  					; DS:SI points to next name
  7436 0000178A F3A4                    		rep movsb
  7437                                  DEL1:
  7438 0000178C 1F                      		pop	ds
  7439 0000178D 5E                      		pop	si
  7440                                  FIND_RETN:
  7441 0000178E C3                      		retn
  7442                                  
  7443                                  ; =============== S U B	R O U T	I N E =======================================
  7444                                  
  7445                                  FIND_PATH:
  7446 0000178F BE[0D3C]                		mov	si,PATH_TEXT ; "PATH="
  7447 00001792 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7448                                  
  7449                                  
  7450                                  ; =============== S U B	R O U T	I N E =======================================
  7451                                  
  7452                                  FIND_PROMPT:
  7453 00001794 BE[123C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7454                                  
  7455                                  ; ---------------------------------------------------------------------------
  7456                                  
  7457                                  FIND_NAME_IN_ENVIRONMENT:
  7458                                  
  7459                                  ; Input: DS:SI points to a "=" terminated string
  7460                                  ; Output: ES:DI points to the arguments in the environment
  7461                                  ;	  zero is set if name not found
  7462                                  ;	  carry flag is set if name not valid format
  7463                                  
  7464 00001797 E80400                  		call	FIND		; Find the name
  7465 0000179A 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7466 0000179C EB76                    		jmp	short SCASB1	; Scan for = sign
  7467                                  
  7468                                  ; ---------------------------------------------------------------------------
  7469                                  		;nop
  7470                                  
  7471                                  ; =============== S U B	R O U T	I N E =======================================
  7472                                  
  7473                                  ; On return of FIND1, ES:DI points to beginning of name
  7474                                  
  7475                                  FIND:
  7476 0000179E FC                      		cld
  7477 0000179F E82D00                  		call	COUNT0		; CX = Length of name
  7478 000017A2 8E06[7142]              		mov	es,[RESSEG]
  7479                                  		; assume es:RESGROUP
  7480 000017A6 268E06030D              		mov	es,word [es:ENVIRSEG]
  7481                                  		; assume es:NOTHING
  7482 000017AB 31FF                    		xor	di,di
  7483                                  FIND1:	
  7484 000017AD 51                      		push	cx
  7485 000017AE 56                      		push	si
  7486 000017AF 57                      		push	di
  7487                                  
  7488                                  FIND11:
  7489 000017B0 AC                      		lodsb
  7490                                  		;call	UPCONV
  7491 000017B1 E86C00                  		call	UPCONV_MAPCALL
  7492 000017B4 47                      		inc	di
  7493 000017B5 263A45FF                		cmp	al,[es:di-1]
  7494 000017B9 7502                    		jnz	short FIND12
  7495 000017BB E2F3                    		loop	FIND11
  7496                                  FIND12:
  7497 000017BD 5F                      		pop	di
  7498 000017BE 5E                      		pop	si
  7499 000017BF 59                      		pop	cx
  7500 000017C0 74CC                    		jz	short FIND_RETN
  7501 000017C2 51                      		push	cx
  7502 000017C3 E85200                  		call	SCASB2		; Scan for a nul
  7503 000017C6 59                      		pop	cx
  7504 000017C7 26803D00                		cmp	byte [es:di],0
  7505 000017CB 75E0                    		jnz	short FIND1
  7506 000017CD F9                      		stc			; Indicate not found
  7507 000017CE C3                      		retn
  7508                                  
  7509                                  ; =============== S U B	R O U T	I N E =======================================
  7510                                  
  7511                                  COUNT0:
  7512 000017CF 1E                      		push	ds
  7513 000017D0 07                      		pop	es
  7514                                  		; assume es:nothing
  7515 000017D1 89F7                    		mov	di,si
  7516                                  ;COUNT1:
  7517 000017D3 57                      		push	di		; Count number of chars until "="
  7518 000017D4 E83D00                  		call	SCASB1
  7519 000017D7 EB00                    		jmp	short COUNTX
  7520                                  
  7521                                  ;COUNT2:
  7522                                  ;		PUSH	DI		; Count number of chars until nul
  7523                                  ;		CALL	SCASB2
  7524                                  
  7525                                  COUNTX:
  7526 000017D9 59                      		pop	cx
  7527 000017DA 29CF                    		sub	di,cx
  7528 000017DC 87F9                    		xchg	di,cx
  7529                                  MOVE_NAME_RETN:
  7530 000017DE C3                      		retn
  7531                                  
  7532                                  ; =============== S U B	R O U T	I N E =======================================
  7533                                  
  7534                                  MOVE_NAME:
  7535 000017DF 803C0D                  		cmp	byte [si],13
  7536 000017E2 74FA                    		jz	short MOVE_NAME_RETN
  7537 000017E4 AC                      		lodsb
  7538                                  		;call	UPCONV
  7539 000017E5 E83800                  		call	UPCONV_MAPCALL
  7540 000017E8 E84900                  		call	STORE_CHAR
  7541 000017EB 3C3D                    		cmp	al,'='
  7542 000017ED 75F0                    		jnz	short MOVE_NAME
  7543                                  GETARG_RETN:
  7544 000017EF C3                      		retn
  7545                                  
  7546                                  ; =============== S U B	R O U T	I N E =======================================
  7547                                  
  7548                                  GETARG:
  7549 000017F0 BE8000                  		mov	si,80h
  7550 000017F3 AC                      		lodsb
  7551 000017F4 08C0                    		or	al,al
  7552 000017F6 74F7                    		jz	short GETARG_RETN
  7553 000017F8 E88001                  		call	SCANOFF
  7554 000017FB 3C0D                    		cmp	al,13
  7555                                  SDN_RETN:
  7556 000017FD C3                      		retn
  7557                                  
  7558                                  ; =============== S U B	R O U T	I N E =======================================
  7559                                  
  7560                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7561                                  ; there is NO double NULL, merely a string that is empty.
  7562                                  
  7563                                  SCAN_DOUBLE_NULL:
  7564 000017FE 8E06[7142]              		mov	es,[RESSEG]
  7565                                  		; ASSUME ES:RESGROUP
  7566 00001802 268E06030D              		mov	es,word [es:ENVIRSEG]
  7567                                  		; ASSUME ES:NOTHING
  7568 00001807 31FF                    		xor	di,di
  7569                                  
  7570                                  ; Top cycle-point. If the string here is empty, then we are done
  7571                                  
  7572                                  SDN1:
  7573 00001809 26803D00                		cmp	byte [es:di],0	; nul string?
  7574 0000180D 74EE                    		jz	short SDN_RETN	; yep, all done
  7575 0000180F E80600                  		call	SCASB2
  7576 00001812 EBF5                    		jmp	short SDN1
  7577                                  
  7578                                  ; =============== S U B	R O U T	I N E =======================================
  7579                                  
  7580                                  SCASB1:
  7581 00001814 B03D                    		mov	al,'='		; Scan for an =
  7582 00001816 EB02                    		jmp	short SCASBX
  7583                                  
  7584                                  ; =============== S U B	R O U T	I N E =======================================
  7585                                  
  7586                                  SCASB2:
  7587 00001818 30C0                    		xor	al,al		; Scan for a nul
  7588                                  
  7589                                  ; ---------------------------------------------------------------------------
  7590                                  
  7591                                  SCASBX:
  7592 0000181A B90001                  		mov	cx,256
  7593 0000181D F2AE                    		repne scasb
  7594 0000181F C3                      		retn
  7595                                  
  7596                                  ; =============== S U B	R O U T	I N E =======================================
  7597                                  
  7598                                  ; MSDOS 6.0
  7599                                  
  7600                                  ; ****************************************************************
  7601                                  ; *
  7602                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7603                                  ; *
  7604                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7605                                  ; *		 the character in AL from the file upper case table
  7606                                  ; *		 in DOS if character if above  ascii 128, else
  7607                                  ; *		 subtracts 20H if between "a" and "z".
  7608                                  ; *
  7609                                  ; * INPUT:	 AL	      char to be upper cased
  7610                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7611                                  ; *
  7612                                  ; * OUTPUT:	 AL	      upper cased character
  7613                                  ; *
  7614                                  ; ****************************************************************
  7615                                  
  7616                                  ;assume	ds:trangroup			;AN000;
  7617                                  ;
  7618                                  ;upconv	proc	near			;AN000;
  7619                                  ;
  7620                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7621                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7622                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7623                                  ;	push	ds			;AN000;
  7624                                  ;	push	bx			;AN000;
  7625                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7626                                  ;assume	ds:resgroup			;AN000;
  7627                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7628                                  ;	add	bx,2			;AN000;  skip over first word
  7629                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7630                                  ;	pop	bx			;AN000;
  7631                                  ;	pop	ds			;AN000;
  7632                                  ;assume	ds:trangroup			;AN000;
  7633                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7634                                  ;
  7635                                  ;oth_fucase:				;AN000;
  7636                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7637                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7638                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7639                                  ;	ja	upconv_end		;AC000;
  7640                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7641                                  ;
  7642                                  ;upconv_end:				;AN000;
  7643                                  ;	ret
  7644                                  ;
  7645                                  ;upconv	endp				;AN000;
  7646                                  
  7647                                  ; ---------------------------------------------------------------------------
  7648                                  
  7649                                  ; MSDOS 3.3
  7650                                  
  7651                                  UPCONV_MAPCALL:
  7652                                  					; If between "a" and "z"
  7653 00001820 3A06[023F]              		cmp	al,[small_a]
  7654 00001824 7208                    		jb	short UPCONV_END
  7655 00001826 3A06[033F]              		cmp	al,[small_z]
  7656 0000182A 7702                    		ja	short UPCONV_END
  7657 0000182C 2C20                    		sub	al,20h		; Change lower-case to upper
  7658                                  UPCONV_END:
  7659 0000182E 2EFF1E[0A4D]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7660                                  					  ; 	  for (current) country
  7661 00001833 C3                      		retn
  7662                                  
  7663                                  ; =============== S U B	R O U T	I N E =======================================
  7664                                  
  7665                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7666                                  
  7667                                  STORE_CHAR:
  7668 00001834 51                      		push	cx
  7669 00001835 53                      		push	bx
  7670                                  
  7671                                  		; 16/10/2018
  7672                                  		; MSDOS 6.0
  7673                                  		;PUSH	ES		;AN056;*
  7674                                  		;PUSH	DS		;AN056; Save local DS
  7675                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7676                                  		;;ASSUME DS:RESGROUP	;AN056;
  7677                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7678                                  		;; ASSUME ES:NOTHING	;AN056;
  7679                                  		;POP	DS		;AN056; Get local segment back
  7680                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7681                                  
  7682                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7683 00001836 E84300                  		call	GETENVSIZ
  7684 00001839 89CB                    		mov	bx,cx		; Save room for double nul	
  7685 0000183B 83EB02                  		sub	bx,2
  7686 0000183E 39DF                    		cmp	di,bx
  7687 00001840 7231                    		jb	short STORE1
  7688                                  
  7689 00001842 50                      		push	ax
  7690 00001843 51                      		push	cx
  7691 00001844 53                      		push	bx		; Save Size of environment
  7692 00001845 E818EE                  		call	FREE_TPA
  7693 00001848 5B                      		pop	bx
  7694 00001849 83C302                  		add	bx,2		; Recover true environment size
  7695                                  
  7696 0000184C 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7697 00001850 7203                    		jb	short ENVSIZ_OK
  7698                                  BAD_ENV_SIZE:				;AN056;
  7699 00001852 F9                      		stc
  7700 00001853 EB09                    		jmp	short ENVNOSET
  7701                                  
  7702                                  		;nop
  7703                                  ENVSIZ_OK:
  7704 00001855 B104                    		mov	cl,4
  7705 00001857 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7706 00001859 43                      		inc	bx
  7707                                  
  7708                                  		; MSDOS 6.0
  7709                                  		;MOV	CX,ES		;AN056; Get environment segment
  7710                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7711                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7712                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7713                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7714                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7715                                  
  7716                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7717 0000185A B44A                    		mov	ah,SETBLOCK ; 4Ah
  7718 0000185C CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7719                                  				; ES = segment address of block	to change
  7720                                  				; BX = new size	in paragraphs
  7721                                  ENVNOSET:
  7722 0000185E 9C                      		pushf
  7723 0000185F 06                      		push	es
  7724 00001860 8E06[7142]              		mov	es,[RESSEG]
  7725                                  		;ASSUME ES:RESGROUP
  7726 00001864 E809EE                  		call	ALLOC_TPA
  7727 00001867 07                      		pop	es
  7728 00001868 9D                      		popf
  7729 00001869 59                      		pop	cx
  7730 0000186A 58                      		pop	ax
  7731                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7732 0000186B 7306                    		jnc	short STORE1
  7733 0000186D BA[5638]                		mov	dx,ENVERRPTR
  7734 00001870 E9B803                  		jmp	CERROR
  7735                                  
  7736                                  STORE1:	
  7737 00001873 AA                      		stosb
  7738 00001874 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7739                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7740 00001879 5B                      		pop	bx
  7741 0000187A 59                      		pop	cx
  7742 0000187B C3                      		retn
  7743                                  
  7744                                  ; =============== S U B	R O U T	I N E =======================================
  7745                                  
  7746                                  GETENVSIZ:
  7747                                  
  7748                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7749                                  ;ES has environment segment
  7750                                  ;Size returned in CX, all other registers preserved
  7751                                  
  7752 0000187C 06                      		push	es
  7753 0000187D 50                      		push	ax
  7754 0000187E 8CC0                    		mov	ax,es
  7755 00001880 48                      		dec	ax	;Point at arena	
  7756 00001881 8EC0                    		mov	es,ax
  7757 00001883 26A10300                		mov	ax,word [es:ARENA.size]
  7758 00001887 B104                    		mov	cl,4
  7759 00001889 D3E0                    		shl	ax,cl	;Convert to bytes
  7760 0000188B 89C1                    		mov	cx,ax
  7761 0000188D 58                      		pop	ax
  7762 0000188E 07                      		pop	es
  7763                                  GETENVSIZ_RETN:
  7764 0000188F C3                      		retn
  7765                                  
  7766                                  ; =============== S U B	R O U T	I N E =======================================
  7767                                  
  7768                                  RESTUDIR1:
  7769 00001890 1E                      		push	ds
  7770 00001891 8E1E[7142]              		mov	ds,[RESSEG]
  7771                                  		;ASSUME	DS:RESGROUP
  7772 00001895 803EF10B00              		cmp	byte [RESTDIR],0
  7773 0000189A 1F                      		pop	ds
  7774                                  		;ASSUME	DS:TRANGROUP
  7775 0000189B 74F2                    		jz	short GETENVSIZ_RETN
  7776                                  
  7777                                  ; =============== S U B	R O U T	I N E =======================================
  7778                                  
  7779                                  RESTUDIR:
  7780 0000189D BA[5341]                		mov	dx,USERDIR1
  7781 000018A0 B43B                    		mov	ah,CHDIR ; 3Bh
  7782 000018A2 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7783                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7784 000018A4 30C0                    		xor	al,al
  7785 000018A6 E86506                  		call	SETREST
  7786 000018A9 C3                      		retn
  7787                                  
  7788                                  ;============================================================================
  7789                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7790                                  ;============================================================================
  7791                                  ; 07/10/2018 - Retro DOS v3.0
  7792                                  
  7793                                  ; TITLE	Part6 COMMAND Transient routines.
  7794                                  
  7795                                  ;	Environment utilities and misc. routines
  7796                                  
  7797                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7798                                  
  7799                                  ; ---------------------------------------------------------------------------
  7800                                  
  7801                                  ; ****************************************************************
  7802                                  ; *
  7803                                  ; * ROUTINE:	 $CHDIR
  7804                                  ; *
  7805                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7806                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7807                                  ; *		 letter is found, get and display the current dir
  7808                                  ; *		 of the specified drive. If nothing is found, get
  7809                                  ; *		 and display the current dir of the default drive.
  7810                                  ; *
  7811                                  ; * INPUT:	 command line at offset 81H
  7812                                  ; *
  7813                                  ; * OUTPUT:	 none
  7814                                  ; *
  7815                                  ; ****************************************************************
  7816                                  
  7817                                  _$CHDIR:
  7818                                  		; MSDOS 6.0
  7819                                  		;mov	si,81H
  7820                                  		;mov	di,offset trangroup:parse_chdir 
  7821                                  		;			;AN000; Get address of PARSE_CHDIR
  7822                                  		;xor	cx,cx		;AN000; clear cx,dx
  7823                                  		;xor	dx,dx		;AN000;
  7824                                  		;invoke	parse_with_msg	;AC018; call parser
  7825                                  
  7826                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7827                                  		;jz	bwdJ		; No args
  7828                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7829                                  		;jnz	ChDirErr	;AC018; yes - exit
  7830                                  
  7831                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7832                                  		;jnz	REALCD		; no
  7833                                  ;;
  7834                                  ;; D: was found. See if there is anything more.
  7835                                  ;;
  7836                                  		;mov	di,offset trangroup:parse_chdir 
  7837                                  					;AC000; get address of parse_chdir
  7838                                  		;xor	dx,dx		;AC000;
  7839                                  		;invoke	parse_check_eol ;AC000; call parser
  7840                                  		;jnz	ChDirErr	;AC000;
  7841                                  	;bwdJ:
  7842                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7843                                  		;call	crlf2
  7844                                  		;return
  7845                                  
  7846                                  		; MSDOS 3.3
  7847 000018AA A1[8842]                		mov	ax,[COMSW]
  7848 000018AD 0B06[8E42]              		or	ax,[ALLSWITCH]
  7849 000018B1 BA[223A]                		mov	dx,BADPARMPTR
  7850 000018B4 7533                    		jnz	short CHDIR_ERR
  7851 000018B6 BE8100                  		mov	si,81h
  7852 000018B9 E8BF00                  		call	SCANOFF
  7853 000018BC 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7854 000018BE 740F                    		je	short BWDJ	; No args
  7855 000018C0 46                      		inc	si
  7856 000018C1 AC                      		lodsb
  7857 000018C2 3C3A                    		cmp	al,':'
  7858 000018C4 7510                    		jne	short REALCD
  7859 000018C6 56                      		push	si
  7860 000018C7 E8B100                  		call	SCANOFF
  7861 000018CA 5E                      		pop	si
  7862 000018CB 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7863 000018CD 7507                    		jne	short REALCD	; no
  7864                                  BWDJ:
  7865 000018CF E871FB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7866 000018D2 E89900                  		call	CRLF2
  7867                                  CHDIR_RETN:
  7868 000018D5 C3                      		retn
  7869                                  
  7870                                  		; MSDOS 6.0
  7871                                  ;REALCD:
  7872                                  		;push	si		;AN000; save position in line
  7873                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7874                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7875                                  		;pop	si		;AN000; restore position in line
  7876                                  		;mov	di,offset trangroup:parse_chdir 
  7877                                  		;			;AC000; get address of parse_chdir
  7878                                  		;xor	dx,dx		;AC000;
  7879                                  		;invoke	parse_check_eol ;AC000; call parser
  7880                                  		;jnz	ChDirErr	;AC000;
  7881                                  		;
  7882                                  		;invoke	SETPATH
  7883                                  		;TEST	[DESTINFO],2
  7884                                  		;JNZ	BadChdir
  7885                                  		;MOV	AH,CHDIR
  7886                                  		;INT	21h
  7887                                  		;retnc
  7888                                  		;
  7889                                  		;invoke	get_ext_error_number
  7890                                  		;			;AN022; get the extended error
  7891                                  		;cmp	ax,error_path_not_found
  7892                                  		;			;AN022; see if path not found
  7893                                  		;jz	BadChDir	;AN022; yes - issue old message
  7894                                  ;;SR;
  7895                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  7896                                  ;;but is not a directory. The extended error returns "Access denied" which
  7897                                  ;;is kind of confusing. Issue the old message if access denied error is 
  7898                                  ;;returned
  7899                                  ;;
  7900                                  		;cmp	ax,error_access_denied
  7901                                  		;jz	BadChDir
  7902                                  		;
  7903                                  		;call	Set_Ext_Error_Subst ;AN022;
  7904                                  		;jmp	short  chdirerr ;AN022;
  7905                                  ;BadChDir:
  7906                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  7907                                  ;ChDirErr:
  7908                                  		;invoke	Std_Eprintf
  7909                                  		;return
  7910                                  
  7911                                  		; MSDOS 3.3
  7912                                  REALCD:
  7913 000018D6 E8A004                  		call	SETPATH
  7914 000018D9 F606[7044]02            		test	byte [DESTINFO],2
  7915 000018DE 7506                    		jnz	short BADCHDIR
  7916 000018E0 B43B                    		mov	ah,CHDIR ; 3Bh
  7917 000018E2 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7918                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7919 000018E4 73EF                    		jnc	short CHDIR_RETN
  7920                                  BADCHDIR:
  7921 000018E6 BA[763B]                		mov	dx,BADCDPTR
  7922                                  CHDIR_ERR:
  7923 000018E9 E8DE1B                  		call	STD_EPRINTF
  7924                                  MKDIR_RETN:
  7925 000018EC C3                      		retn
  7926                                  
  7927                                  ; ---------------------------------------------------------------------------
  7928                                  
  7929                                  _$MKDIR:
  7930                                  		; MSDOS 6.0
  7931                                  		;CALL	SETRMMK
  7932                                  		;JC	MkDirErr
  7933                                  		;MOV	AH,MKDIR
  7934                                  		;INT	21h
  7935                                  		;retnc
  7936                                  
  7937                                  		;invoke	get_ext_error_number	
  7938                                  		;			;AN022; get the extended error
  7939                                  		;cmp	ax,error_path_not_found 
  7940                                  		;			;AN022; see if path not found
  7941                                  		;jz	MD_other_err	;AN022; yes - issue old message
  7942                                  		;cmp	ax,error_access_denied
  7943                                  		;			;AN022; access denied?
  7944                                  		;jz	badmderr	;AN022; yes - see if file exists
  7945                                  		
  7946                                  		;call	Set_Ext_Error_Subst ;AN022;
  7947                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  7948                                  ;BADMDERR:
  7949                                  		;mov	dx,offset trangroup:srcxname	
  7950                                  		;			;AN006; Set Disk transfer address
  7951                                  		;mov	ah,Set_DMA	;AN006;
  7952                                  		;int	21h		;AN006;
  7953                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  7954                                  		;mov	cx,attr_directory ;AN006;   search for directory
  7955                                  		;INT	21h		;AN006;
  7956                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  7957                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  7958                                  		;test	dl,attr_directory ;AN006; was it a directory?
  7959                                  		;jz	MD_other_err	;AN006; no - must have been a file
  7960                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  7961                                  		;			;AN006; set up already exists error
  7962                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  7963                                  ;MD_other_err:				;AN006;
  7964                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  7965                                  ;MkDirErr:
  7966                                  		;invoke	Std_Eprintf
  7967                                  		;return
  7968                                  
  7969                                  		; MSDOS 3.3
  7970 000018ED E81200                  		call	SETRMMK
  7971 000018F0 720C                    		jb	short MKDIRERR
  7972 000018F2 B439                    		mov	ah,MKDIR ; 39h
  7973 000018F4 CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  7974                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  7975 000018F6 73F4                    		jnc	short MKDIR_RETN
  7976 000018F8 BA[953B]                		mov	dx,BADMKDPTR
  7977 000018FB E8CE05                  		call	GET_EXT_ERR_NUMBER
  7978                                  MKDIRERR:
  7979 000018FE E8C91B                  		call	STD_EPRINTF
  7980 00001901 C3                      		retn
  7981                                  
  7982                                  ; =============== S U B	R O U T	I N E =======================================
  7983                                  
  7984                                  ; 	<Common MkDir/RmDir set up code>
  7985                                  ;****************************************************************
  7986                                  ;*
  7987                                  ;* ROUTINE:	SETRMMK
  7988                                  ;*
  7989                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  7990                                  ;*		commands. Parses the command line for a required
  7991                                  ;*		filespec.
  7992                                  ;*
  7993                                  ;* INPUT:	command line at offset 81H
  7994                                  ;*
  7995                                  ;* OUTPUT:	carry clear
  7996                                  ;*		    DS:DX points to ASCIIZ argument
  7997                                  ;*		carry set
  7998                                  ;*		    DS:DX has error message pointer
  7999                                  ;*
  8000                                  ;****************************************************************
  8001                                  
  8002                                  		; MSDOS 6.0
  8003                                  		;mov	si,81H
  8004                                  		;mov	di,offset trangroup:parse_mrdir 
  8005                                  					;AN000; Get adderss of PARSE_MRDIR
  8006                                  		;xor	cx,cx		;AN000; clear cx,dx
  8007                                  		;xor	dx,dx		;AN000;
  8008                                  		;invoke	parse_with_msg	;AC000; call parser
  8009                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8010                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8011                                  
  8012                                  		;mov	di,offset trangroup:srcxname
  8013                                  		;			;AN000; get address of srcxname
  8014                                  		;push	di		;AN000; save address
  8015                                  		;push	si		;AN000; save position in line
  8016                                  		;lds	si,parse1_addr	;AN000; get address of path
  8017                                  
  8018                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8019                                  		;lodsb			;get a char from buffer
  8020                                  		;stosb			;AN000; store in srcxname
  8021                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8022                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8023                                  		;pop	si		;AN000; get line position back
  8024                                  ;;
  8025                                  ;; we have scanned an argument.	See if any args beyond.
  8026                                  ;;
  8027                                  		;mov	di,offset trangroup:parse_mrdir 
  8028                                  		;			;AC000; get address of parse_mrdir
  8029                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8030                                  		;pop	dx		;AC000; get address of SRCXNAME
  8031                                  		;retz			;yes - return no error
  8032                                  ;NOARGERR:
  8033                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8034                                  		;			;AC000; get extended message pointer
  8035                                  		;XOR	AX,AX
  8036                                  		;STC
  8037                                  		;return
  8038                                  
  8039                                  		; MSDOS 3.3
  8040                                  SETRMMK:
  8041 00001902 BE8100                  		mov	si,81h
  8042 00001905 E87300                  		call	SCANOFF
  8043 00001908 3C0D                    		cmp	al,0Dh
  8044 0000190A 741E                    		je	short NOARGERR
  8045 0000190C 89F2                    		mov	dx,si
  8046                                  SETRMMK1:
  8047 0000190E AC                      		lodsb
  8048 0000190F E87100                  		call	DELIM
  8049 00001912 7409                    		jz	short SETRMMK3
  8050 00001914 3C0D                    		cmp	al,0Dh
  8051 00001916 75F6                    		jne	short SETRMMK1
  8052 00001918 C644FF00                		mov	byte [si-1],0
  8053                                  SETRMMK2:
  8054 0000191C C3                      		retn
  8055                                  SETRMMK3:
  8056 0000191D C644FF00                		mov	byte [si-1],0
  8057 00001921 56                      		push	si
  8058 00001922 E85600                  		call	SCANOFF
  8059 00001925 5E                      		pop	si
  8060 00001926 3C0D                    		cmp	al,0Dh
  8061 00001928 74F2                    		je	short SETRMMK2
  8062                                  NOARGERR:
  8063 0000192A BA[6D3D]                		mov	dx,BADARGSPTR
  8064 0000192D 31C0                    		xor	ax,ax
  8065 0000192F F9                      		stc
  8066                                  SETRMMK_RETN:
  8067 00001930 C3                      		retn
  8068                                  
  8069                                  ; ---------------------------------------------------------------------------
  8070                                  
  8071                                  _$RMDIR:
  8072 00001931 E8CEFF                  		call	SETRMMK
  8073 00001934 720E                    		jb	short RMDIRERR
  8074 00001936 7506                    		jnz	short BADRDERR
  8075 00001938 B43A                    		mov	ah,RMDIR ; 3Ah
  8076 0000193A CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8077                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8078 0000193C 73F2                    		jnc	short SETRMMK_RETN
  8079                                  
  8080                                  		; MSDOS 6.0
  8081                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8082                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8083                                  		;jz	badrderr	;AN022; yes - issue old message
  8084                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8085                                  		;jz	badrderr	;AN022; yes - issue old message
  8086                                  
  8087                                  		;call	Set_Ext_Error_Subst ;AN022;
  8088                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8089                                  
  8090                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8091                                  BADRDERR:
  8092 0000193E BA[CE3B]                		mov	dx,BADRMDPTR
  8093 00001941 E88805                  		call	GET_EXT_ERR_NUMBER
  8094                                  RMDIRERR:
  8095 00001944 E8831B                  		call	STD_EPRINTF
  8096                                  RMDIR_RETN:
  8097 00001947 C3                      		retn
  8098                                  
  8099                                  ; =============== S U B	R O U T	I N E =======================================
  8100                                  
  8101                                  ; MSDOS 6.0
  8102                                  
  8103                                  ;****************************************************************
  8104                                  ;*
  8105                                  ;* ROUTINE:	Set_ext_error_subst
  8106                                  ;*
  8107                                  ;* FUNCTION:	Sets up substitution for extended error
  8108                                  ;*
  8109                                  ;* INPUT:	AX - extended error number
  8110                                  ;*		DX - offset of string
  8111                                  ;*
  8112                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8113                                  ;*
  8114                                  ;****************************************************************
  8115                                  
  8116                                  ;Set_ext_error_subst  proc near		;AN022;
  8117                                  ;
  8118                                  ;	mov	msg_disp_class,ext_msg_class
  8119                                  ;					;AN022; set up extended error msg class
  8120                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8121                                  ;	mov	Extend_buf_sub,one_subst 
  8122                                  ;					;AN022; put number of subst in control block
  8123                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8124                                  ;					;AN022; get extended message pointer
  8125                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8126                                  ;
  8127                                  ;	ret				;AN022; return
  8128                                  ;
  8129                                  ;Set_ext_error_subst  endp		;AN022;
  8130                                  
  8131                                  ; =============== S U B	R O U T	I N E =======================================
  8132                                  
  8133                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8134                                  
  8135                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8136                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8137                                  ;   buffer
  8138                                  ;
  8139                                  ;   Inputs:	DL has 1-based drive number
  8140                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8141                                  ;   Outputs:	Carry Clear
  8142                                  ;		    DS = TranGroup
  8143                                  ;		Carry Set
  8144                                  ;		    AX has error code
  8145                                  ;   Registers Modified: AX, SI
  8146                                  
  8147                                  SAVUDIR:
  8148 00001948 BF[5341]                		mov	di,USERDIR1
  8149                                  
  8150                                  ; ---------------------------------------------------------------------------
  8151                                  
  8152                                  SAVUDIR1:
  8153 0000194B 88D0                    		mov	al,dl
  8154 0000194D 0440                    		add	al,'@'
  8155 0000194F 3C40                    		cmp	al,'@'
  8156 00001951 7506                    		jnz	short GOTUDRV
  8157 00001953 0206[8542]              		add	al,[CURDRV]
  8158 00001957 FEC0                    		inc	al		; A = 1
  8159                                  GOTUDRV:
  8160 00001959 AA                      		stosb
  8161 0000195A 8A26[7642]              		mov	ah,[DIRCHAR]
  8162 0000195E B03A                    		mov	al,':'
  8163 00001960 AB                      		stosw
  8164 00001961 06                      		push	es
  8165 00001962 1F                      		pop	ds
  8166 00001963 89FE                    		mov	si,di
  8167 00001965 B447                    		mov	ah,CURRENT_DIR	; 47h
  8168 00001967 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8169                                  				; DL = drive (0=default,1=A,etc.)
  8170                                  				; DS:SI	points to 64-byte buffer area
  8171 00001969 72DC                    		jc	short RMDIR_RETN
  8172 0000196B 0E                      		push	cs
  8173 0000196C 1F                      		pop	ds
  8174 0000196D C3                      		retn
  8175                                  
  8176                                  ; =============== S U B	R O U T	I N E =======================================
  8177                                  
  8178                                  CRLF2:
  8179 0000196E 52                      		push	dx
  8180 0000196F BA[8E3D]                		mov	dx,ACRLFPTR
  8181 00001972 1E                      		push	ds
  8182 00001973 0E                      		push	cs
  8183 00001974 1F                      		pop	ds
  8184 00001975 E85B1B                  		call	STD_PRINTF
  8185 00001978 1F                      		pop	ds
  8186 00001979 5A                      		pop	dx
  8187 0000197A C3                      		retn
  8188                                  
  8189                                  ; =============== S U B	R O U T	I N E =======================================
  8190                                  
  8191                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8192                                  ; may NOT be TRANGROUP
  8193                                  
  8194                                  SCANOFF:
  8195 0000197B AC                      		lodsb
  8196 0000197C E80400                  		call	DELIM
  8197 0000197F 74FA                    		jz	short SCANOFF
  8198 00001981 4E                      		dec	si		; Point to first non-delimiter
  8199                                  SCANOFF_RETN:
  8200 00001982 C3                      		retn
  8201                                  
  8202                                  ; ---------------------------------------------------------------------------
  8203                                  
  8204                                  ; Input:    AL is character to classify
  8205                                  ; Output:   Z set if delimiter
  8206                                  ;	    NZ set otherwise
  8207                                  ; Registers modified: none
  8208                                  
  8209                                  DELIM:
  8210 00001983 3C20                    		cmp	al,' '
  8211 00001985 74FB                    		jz	short SCANOFF_RETN
  8212 00001987 3C3D                    		cmp	al,'='
  8213 00001989 74F7                    		jz	short SCANOFF_RETN
  8214 0000198B 3C2C                    		cmp	al,','
  8215 0000198D 74F3                    		jz	short SCANOFF_RETN
  8216 0000198F 3C3B                    		cmp	al,';'
  8217 00001991 74EF                    		jz	short SCANOFF_RETN
  8218 00001993 3C09                    		cmp	al,9		; Check for TAB character
  8219 00001995 74EB                    		jz	short SCANOFF_RETN
  8220 00001997 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8221 00001999 C3                      		retn
  8222                                  
  8223                                  
  8224                                  ; =============== S U B	R O U T	I N E =======================================
  8225                                  
  8226                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8227 0000199A B90800                  		mov	cx,8
  8228                                  MAINNAME:
  8229 0000199D AC                      		lodsb
  8230 0000199E 3C20                    		cmp	al,' '
  8231 000019A0 7401                    		jz	short SKIPSPC
  8232 000019A2 AA                      		stosb
  8233                                  SKIPSPC:
  8234 000019A3 E2F8                    		loop	MAINNAME
  8235 000019A5 AC                      		lodsb
  8236 000019A6 3C20                    		cmp	al,' '
  8237 000019A8 7413                    		jz	short GOTNAME
  8238 000019AA 88C4                    		mov	ah,al
  8239                                  		;mov	al,'.'
  8240 000019AC A0[083F]                		mov	al,[DOT_CHR]
  8241 000019AF AA                      		stosb
  8242 000019B0 86C4                    		xchg	al,ah
  8243 000019B2 AA                      		stosb
  8244 000019B3 B102                    		mov	cl,2
  8245                                  EXTNAME:
  8246 000019B5 AC                      		lodsb
  8247 000019B6 3C20                    		cmp	al,' '
  8248 000019B8 7403                    		jz	short GOTNAME
  8249 000019BA AA                      		stosb
  8250 000019BB E2F8                    		loop	EXTNAME
  8251                                  GOTNAME:
  8252 000019BD 30C0                    		xor	al,al
  8253 000019BF AA                      		stosb
  8254                                  STRCOMP_RETN:
  8255 000019C0 C3                      		retn
  8256                                  
  8257                                  ; =============== S U B	R O U T	I N E =======================================
  8258                                  
  8259                                  ; Compare ASCIZ DS:SI with ES:DI.
  8260                                  ; SI,DI destroyed.
  8261                                  
  8262                                  STRCOMP:	
  8263 000019C1 A6                      		cmpsb
  8264 000019C2 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8265 000019C4 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8266 000019C8 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8267 000019CA EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8268                                  
  8269                                  ; =============== S U B	R O U T	I N E =======================================
  8270                                  
  8271                                  CRPRINT:
  8272 000019CC 50                      		push	ax
  8273                                  		;mov	al,13
  8274 000019CD B00D                    		mov	al,0Dh
  8275 000019CF 51                      		push	cx
  8276 000019D0 57                      		push	di
  8277 000019D1 89D7                    		mov	di,dx
  8278 000019D3 B9FFFF                  		mov	cx,65535
  8279 000019D6 06                      		push	es
  8280 000019D7 1E                      		push	ds
  8281 000019D8 07                      		pop	es
  8282 000019D9 F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8283 000019DB C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8284 000019DF 07                      		pop	es
  8285 000019E0 8916[4E44]              		mov	[STRING_PTR_2],dx
  8286 000019E4 BA[3F37]                		mov	dx,STRINGBUF2PTR
  8287 000019E7 E8E91A                  		call	STD_PRINTF
  8288                                  		;mov	byte [di-1],13
  8289 000019EA C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8290 000019EE 7204                    		jb	short ERROR_OUTPUT
  8291 000019F0 5F                      		pop	di
  8292 000019F1 59                      		pop	cx
  8293 000019F2 58                      		pop	ax
  8294 000019F3 C3                      		retn
  8295                                  
  8296                                  ; ---------------------------------------------------------------------------
  8297                                  
  8298                                  ERROR_OUTPUT:
  8299 000019F4 0E                      		push	cs
  8300 000019F5 1F                      		pop	ds
  8301 000019F6 8E06[7142]              		mov	es,[RESSEG]
  8302 000019FA BA[3938]                		mov	dx,NOSPACEPTR
  8303 000019FD 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  8304 00001A03 7406                    		jz	short GO_TO_ERROR
  8305 00001A05 E88609                  		call	PIPEOFF
  8306 00001A08 BA[D23C]                		mov	dx,PIPEEMESPTR
  8307                                  GO_TO_ERROR:
  8308 00001A0B E91D02                  		jmp	CERROR
  8309                                  
  8310                                  ; =============== S U B	R O U T	I N E =======================================
  8311                                  
  8312                                  ;---- Mod for path invocation ----
  8313                                  
  8314                                  PATHCHRCMP:
  8315 00001A0E 50                      		push	ax
  8316 00001A0F B42F                    		mov	ah,'/'
  8317 00001A11 3826[7542]              		cmp	[SWITCHAR],ah
  8318 00001A15 7404                    		jz	short NOSLASHT
  8319 00001A17 3C2F                    		cmp	al,'/'
  8320 00001A19 7402                    		jz	short PCCONT
  8321                                  NOSLASHT:
  8322 00001A1B 3C5C                    		cmp	al,'\'
  8323                                  PCCONT:	
  8324 00001A1D 58                      		pop	ax
  8325 00001A1E C3                      		retn
  8326                                  
  8327                                  ; =============== S U B	R O U T	I N E =======================================
  8328                                  
  8329                                  ; PATHCRUNCH -
  8330                                  ;
  8331                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8332                                  ;       PathPos = ptr to string with pathname in it
  8333                                  ;       PathCnt = length of string
  8334                                  ;
  8335                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8336                                  ;       PathCnt = length left in string
  8337                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8338                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8339                                  ;       If path crunched successfully,
  8340                                  ;         CY = clear
  8341                                  ;         Current directory is changed to directory in pathname
  8342                                  ;         UserDir1 contains previous directory for use by RestUDir
  8343                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8344                                  ;         DestTail = ptr to beginning of filename
  8345                                  ;         If filename found in pathname,
  8346                                  ;           ZR = clear
  8347                                  ;           FCB filename fields contain filename
  8348                                  ;         If filename not found (pure directory path),
  8349                                  ;           ZR = set
  8350                                  ;           FCB filename fields are wildcarded with ?'s
  8351                                  ;       If pathcrunch failed (no ChDir's worked),
  8352                                  ;         CY = set
  8353                                  ;         Msg_Numb = extended error code
  8354                                  ;
  8355                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8356                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8357                                  ;       with the filename wildcarded.
  8358                                  
  8359                                  PATHCRUNCH:
  8360                                  		; MSDOS 6.0
  8361                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8362                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8363                                  		;mov	dl,[5CH]
  8364 00001A1F 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8365 00001A23 E822FF                  		call	SAVUDIR		; save current directory in UserDir1
  8366 00001A26 E85003                  		call	SETPATH
  8367                                  		; MSDOS 6.0
  8368                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8369                                  
  8370                                  ;       DX = ptr to pathname, NULL-terminated
  8371                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8372                                  
  8373                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8374 00001A29 F606[7044]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8375 00001A2E 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8376                                  
  8377 00001A30 B43B                    		mov	ah,CHDIR ; 3Bh
  8378 00001A32 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8379                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8380                                  		; MSDOS 6.0
  8381                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8382                                  		;
  8383                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8384                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8385                                  		;jz	trypeel                 ;AC022;     keep trying
  8386                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8387                                  		;jz	trypeel                 ;AC022;     keep trying
  8388                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8389                                  		;jmp	peelfail                ;AN022; exit with other error
  8390                                  
  8391                                  		; MSDOS 3.3
  8392 00001A34 7210                    		jc	short TRYPEEL
  8393                                  ;chdir_worked:
  8394                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8395 00001A36 E8D304                  		call	SETREST1	; set 'Restore Directory' flag true
  8396 00001A39 B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8397 00001A3B BF5D00                  		mov	di,5Dh
  8398 00001A3E B90B00                  		mov	cx,11
  8399 00001A41 F3AA                    		rep stosb
  8400 00001A43 30C0                    		xor	al,al		; return carry clear, zero set
  8401 00001A45 C3                      		retn
  8402                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8403                                  		;jmp	pcrunch_cderr	;AN022;
  8404                                  TRYPEEL:
  8405 00001A46 8B36[C043]              		mov	si,[PATHPOS]
  8406 00001A4A 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8407 00001A4B 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8408 00001A4E E8BDFF                  		call	PATHCHRCMP
  8409 00001A51 7424                    		jz	short PEELFAIL
  8410                                  DELLOOP:
  8411 00001A53 39D6                    		cmp	si,dx
  8412 00001A55 742C                    		jz	short BADRET
  8413 00001A57 8A04                    		mov	al,[si]
  8414 00001A59 E8B2FF                  		call	PATHCHRCMP
  8415 00001A5C 7403                    		jz	short TRYCD
  8416 00001A5E 4E                      		dec	si
  8417 00001A5F EBF2                    		jmp	short DELLOOP
  8418                                  TRYCD:
  8419 00001A61 50                      		push	ax
  8420                                  		;mov	al,'.'
  8421 00001A62 A0[083F]                		mov	al,[DOT_CHR]	; AL = '.'
  8422                                  		; MSDOS 6.0
  8423                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8424                                  					;M019; allow continuation if '. ' or 
  8425                                  					;M019; '..' is not found.
  8426                                  		;jnz	@f		;M019; '.' not found
  8427                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8428                                  		;jz	@f		;M019; found '..'
  8429                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8430                                  ;@@:		;pop     ax
  8431                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8432                                  
  8433                                  		; MSDOS 3.3
  8434 00001A65 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8435 00001A68 58                      		pop	ax
  8436 00001A69 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8437                                  
  8438                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8439 00001A6B 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8440 00001A6E 3C3A                    		cmp	al,':'
  8441 00001A70 7411                    		jz	short BADRET
  8442 00001A72 E899FF                  		call	PATHCHRCMP
  8443 00001A75 7502                    		jnz	short NODOUBLESL
  8444                                  PEELFAIL:
  8445 00001A77 F9                      		stc
  8446 00001A78 C3                      		retn
  8447                                  NODOUBLESL:
  8448 00001A79 C60400                  		mov	byte [si],0
  8449 00001A7C B43B                    		mov	ah,CHDIR ; 3Bh
  8450 00001A7E CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8451                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8452 00001A80 7317                    		jnc	short CDSUCC
  8453                                  
  8454                                  		; MSDOS 6.0
  8455                                  ;pcrunch_cderr:
  8456                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8457                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8458                                  		;or	si,si		;AN022; set up zero flag to not zero
  8459                                  		;stc			;AN022; set up carry flag
  8460                                  		;return
  8461                                  		
  8462                                  		; MSDOS 3.3
  8463                                  PATHCRUNCH_RETN:
  8464 00001A82 C3                      		retn
  8465                                  
  8466                                  BADRET:
  8467 00001A83 8A04                    		mov	al,[si]
  8468 00001A85 E886FF                  		call	PATHCHRCMP
  8469 00001A88 F9                      		stc
  8470 00001A89 75F7                    		jnz	short PATHCRUNCH_RETN
  8471 00001A8B 30DB                    		xor	bl,bl
  8472 00001A8D 865C01                  		xchg	bl,[si+1]
  8473 00001A90 B43B                    		mov	ah,CHDIR ; 3Bh
  8474 00001A92 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8475                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8476 00001A94 72EC                    		jb	short PATHCRUNCH_RETN
  8477 00001A96 885C01                  		mov	[si+1],	bl
  8478                                  CDSUCC:
  8479 00001A99 E87004                  		call	SETREST1
  8480 00001A9C 46                      		inc	si
  8481 00001A9D 8936[6E44]              		mov	[DESTTAIL],si
  8482                                  		; MSDOS 6.0
  8483                                  		;pushf			;AN015; save flags
  8484                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8485                                  		;jz	pcrunch_end	;AN015;
  8486                                  		;MOV	DI,FCB
  8487                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8488                                  					; Parse with default drive
  8489                                  		;INT	21h
  8490                                  ;pcrunch_end:
  8491                                  		;popf			;AN015; get flags back
  8492                                  		;return
  8493                                  
  8494                                  		; MSDOS 3.3
  8495 00001AA1 BF5C00                  		mov	di,FCB ; 5Ch
  8496 00001AA4 B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8497 00001AA7 CD21                    		int	21h	; DOS -	PARSE FILENAME
  8498                                  				; DS:SI	-> string to parse
  8499                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8500                                  				; AL = bit mask	to control parsing
  8501 00001AA9 C3                      		retn
  8502                                  
  8503                                  ;============================================================================
  8504                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8505                                  ;============================================================================
  8506                                  ; 05/10/2018 - Retro DOS v3.0
  8507                                  
  8508                                  ;TITLE	Part7 COMMAND Transient Routines
  8509                                  
  8510                                  ;	More misc routines
  8511                                  
  8512                                  ;---------------------------
  8513                                  ; We can get rid of this switch processing code if we can take
  8514                                  ; care of the remaining two calls to switch, later in the file.
  8515                                  ; However, I have not checked whether or not any other files use
  8516                                  ; switch -- after all, it IS public!
  8517                                  ;---------------------------
  8518                                  
  8519                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8520                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8521                                  
  8522                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8523                                  
  8524                                  ; ---------------------------------------------------------------------------
  8525                                  
  8526 00001AAA 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8527 00001AAB C3                      		retn
  8528                                  
  8529                                  ; =============== S U B	R O U T	I N E =======================================
  8530                                  
  8531                                  SWITCH:
  8532 00001AAC 31DB                    		xor	bx,bx		; Initialize - no switches set
  8533                                  SWLOOP:
  8534 00001AAE E8CAFE                  		call	SCANOFF		; Skip any delimiters
  8535 00001AB1 3A06[7542]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8536 00001AB5 75F3                    		jnz	short RETSW	; No -- we're finished
  8537                                  		;or	bx,8000h
  8538 00001AB7 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8539 00001ABB 46                      		inc	si		; Skip over the switch character
  8540 00001ABC E8BCFE                  		call	SCANOFF
  8541 00001ABF 3C0D                    		cmp	al,0Dh
  8542 00001AC1 74E7                    		je	short RETSW	; Oops
  8543 00001AC3 46                      		inc	si
  8544                                  
  8545                                  		; Convert lower case input to upper case
  8546                                  
  8547                                  		;call	UPCONV
  8548 00001AC4 E859FD                  		call	UPCONV_MAPCALL
  8549                                  
  8550 00001AC7 BF[1D3F]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8551                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8552                                  		;mov	cx,5  ; MSDOS 3.3
  8553 00001ACA B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8554                                  		
  8555                                  		;nop
  8556                                  		
  8557 00001ACD F2AE                    		repne scasb		; Look for matching switch
  8558 00001ACF 7507                    		jnz	short BADSW
  8559 00001AD1 B80100                  		mov	ax,1
  8560 00001AD4 D3E0                    		shl	ax,cl		; Set a bit for the switch
  8561 00001AD6 09C3                    		or	bx,ax
  8562                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8563 00001AD8 EBD4                    		jmp	short SWLOOP
  8564                                  
  8565                                  ;BADSW:
  8566                                  		;jmp	short SWLOOP
  8567                                  
  8568                                  DRVBAD:
  8569 00001ADA BA[4939]                		mov	dx,BADDRVPTR
  8570 00001ADD E94B01                  		jmp	CERROR
  8571                                  
  8572                                  EXTERNALJ:
  8573 00001AE0 E9B100                  		jmp	EXTERNAL
  8574                                  
  8575                                  FNDCOM:					; search the internal command table
  8576 00001AE3 08C0                    		or	al,al		; Get real length of first arg
  8577 00001AE5 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8578                                  					;  to be external.
  8579                                  ; barryf code starts here
  8580                                  
  8581 00001AE7 E87E02                  		call	TEST_APPEND	; see if APPEND installed
  8582 00001AEA 7421                    		jz	short CONTCOM	; not loaded
  8583                                  
  8584                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8585 00001AEC 8A0E[EB42]              		mov	cl,[IDLEN]
  8586 00001AF0 B500                    		mov	ch,0
  8587 00001AF2 890E[C043]              		mov	[PATHPOS],cx
  8588                                  		
  8589                                  		; MSDOS 6.0
  8590                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8591                                  
  8592 00001AF6 E80E03                  		call	IOSET		; re-direct the o'l io
  8593                                  
  8594 00001AF9 BE[EB42]                		mov	si,IDLEN	; address command name, DS already set	
  8595 00001AFC BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8596                                  		
  8597                                  		; MSDOS 6.0
  8598                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8599                                  					;AN010; Get the entry point for PARSE for APPEND
  8600                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8601 00001AFF B801AE                  		mov	ax,0AE01h
  8602 00001B02 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8603                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8604                                  				; DX = FFFFh,[SI -> buffer
  8605                                  				; Return: buffer at DS:SI filled with a	length byte
  8606                                  				;		 followed by the uppercase
  8607                                  				; internal command to execute (if length not 0)
  8608 00001B04 803E[EB42]00            		cmp	byte [IDLEN],0 ; execute requested
  8609 00001B09 7502                    		jne	short CONTCOM
  8610 00001B0B EB57                    		jmp	short CMD_DONE
  8611                                  
  8612                                  		;nop
  8613                                  CONTCOM:				; continue with internal scan
  8614 00001B0D BF[E33D]                		mov	di,COMTAB
  8615 00001B10 31C9                    		xor	cx,cx
  8616                                  FINDCOM:
  8617 00001B12 BE[EC42]                		mov	si,ID		; pointer to command argument
  8618 00001B15 8A0D                    		mov	cl,[di]		; load length of internal command
  8619 00001B17 47                      		inc	di		; advance past length
  8620 00001B18 E3C6                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8621 00001B1A 3A0E[EB42]              		cmp	cl,[IDLEN]	; that of the command argument
  8622 00001B1E 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8623 00001B20 890E[C043]              		mov	[PATHPOS],cx	; store length of command
  8624 00001B24 F3A6                    		repe cmpsb
  8625                                  ABCD:					
  8626 00001B26 9F                      		lahf			; save the good ol' flags
  8627 00001B27 01CF                    		add	di,cx		; skip over remaining internal, if any
  8628 00001B29 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8629 00001B2B A2[8342]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8630 00001B2E 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8631 00001B2F 8B1D                    		mov	bx,[di]		; load internal command address
  8632 00001B31 47                      		inc	di		; skip over the puppy
  8633 00001B32 47                      		inc	di
  8634                                  		
  8635                                  		; MSDOS 6.0
  8636                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8637                                  		;inc     DI
  8638                                  		;inc     DI
  8639                                  		;sahf			; remember those flags?
  8640                                  		;jnz     findcom	; well, if all the cmps worked...
  8641                                  ;;
  8642                                  ;; All messages get redirected.
  8643                                  ;;
  8644                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8645                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8646                                  		;invoke  ioset		; re-direct the ol' i/o
  8647                                  
  8648                                  ;dont_set_io:					;AN041;
  8649                                  ;;
  8650                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8651                                  ;; respond to /? only if it is the only command-line argument.
  8652                                  ;;
  8653                                  		;mov     ax,[COMSW]	; AX = switches after command
  8654                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8655                                  		;and     ax,SwitchQues	
  8656                                  		;jz      drive_check	; /? not in command line
  8657                                  		;	
  8658                                  		;test    [CHKDRV],fLimitHelp
  8659                                  		;jz      do_help	; /? allowed in combination
  8660                                  ;;
  8661                                  ;; Make sure /? is the only argument on the command line.
  8662                                  ;;
  8663                                  		;cmp     [arg.argvcnt],2
  8664                                  		;jne     drive_check	; /? not only arg - ignore
  8665                                  ;;
  8666                                  ;; Note:  this is all the check we need, even against things like /??.
  8667                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8668                                  ;;
  8669                                  
  8670                                  ;do_help:
  8671                                  ;
  8672                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8673                                  
  8674                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8675                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8676                                  		;push    ax		; build subst block on stack
  8677                                  
  8678                                  ;next_help_msg:
  8679                                  		;lodsw			; AX = help msg # or zero
  8680                                  		;or      ax,ax
  8681                                  		;jz      help_done
  8682                                  		;push    ax		; SS:SP = ptr to subst block
  8683                                  					;  (msg # and no_subst byte)
  8684                                  ;; We assume DS = SS.
  8685                                  
  8686                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8687                                      		;invoke  Std_PrintF	; display help message
  8688                                      		;pop     ax		; remove msg # from stack
  8689                                     		;jmp     next_help_msg
  8690                                  
  8691                                  ;help_done:
  8692                                  		;pop     ax		; clean up stack
  8693                                  		;jmp     TCommand	
  8694                                  
  8695                                  		; MSDOS 3.3
  8696 00001B33 9E                      		sahf			; remember those flags?
  8697 00001B34 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8698 00001B36 E8CE02                  		call	IOSET		; re-direct the ol' i/o
  8699                                  
  8700                                  DRIVE_CHECK:
  8701                                  		;test	byte [CHKDRV],1
  8702 00001B39 F606[8342]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8703                                  					; did we wanna check those drives?
  8704 00001B3E 740D                    		jz	short NOCHECK
  8705 00001B40 A0[8642]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8706 00001B43 0A06[8742]              		or	al,[PARM2]	; us whether those drives were OK
  8707 00001B47 3CFF                    		cmp	al,-1
  8708 00001B49 7502                    		jnz	short NOCHECK
  8709 00001B4B EB8D                    		jmp	short DRVBAD
  8710                                  
  8711                                  ; The user may have omitted the space between the command and its arguments.
  8712                                  ; We need to copy the remainder of the user's command line into the buffer.
  8713                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8714                                  ; into the command line at 80.
  8715                                  
  8716                                  NOCHECK:
  8717 00001B4D E8FB01                  		call	CMD_COPY
  8718                                  SWITCHECK:
  8719                                  		;test	byte [CHKDRV],2
  8720 00001B50 F606[8342]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8721                                  					; Does the command take switches
  8722 00001B55 750B                    		jnz	short REALWORK	; Yes, process the command
  8723 00001B57 E82400                  		call	NOSWIT		; No, check to see if any switches
  8724 00001B5A 7506                    		jnz	short REALWORK	; None, process the command
  8725                                  
  8726                                  		; MSDOS 6.0
  8727                                  		;mov	msg_disp_class,parse_msg_class	
  8728                                  		;			;AN000; set up parse error msg class
  8729                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8730                                  		;			;AC000; get extended message pointer
  8731                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8732                                  		;			;AN000; get "Invalid switch" message number
  8733                                  		;jmp	CERROR		; Print error and chill out...
  8734                                  
  8735                                  		; MSDOS 3.0
  8736 00001B5C BA[223A]                		mov	dx,BADPARMPTR
  8737 00001B5F E9C900                  		jmp	CERROR
  8738                                  
  8739                                  REALWORK:
  8740 00001B62 FFD3                    		call	bx		; do some real work, at last
  8741                                  
  8742                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8743                                  ; otherwise, go get another command.
  8744                                  
  8745                                  CMD_DONE:
  8746 00001B64 0E                      		push	cs		; g  restore data segment
  8747 00001B65 1F                      		pop	ds		; g
  8748 00001B66 1E                      		push	ds
  8749 00001B67 8E1E[7142]              		mov	ds,[RESSEG]	; g  save data segment
  8750                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8751 00001B6B 803EFE0B01              		cmp	byte [CALL_FLAG],call_in_progress
  8752 00001B70 C606FE0B00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8753 00001B75 1F                      		pop	ds		; g  get data segment back
  8754 00001B76 7403                    		jz	short INCALL	; G
  8755 00001B78 E989E5                  		jmp	TCOMMAND	; chill out...
  8756                                  INCALL:
  8757 00001B7B E92FE7                  		jmp	DOCOM1
  8758                                  
  8759                                  ; =============== S U B	R O U T	I N E =======================================
  8760                                  
  8761                                  NOSWIT:
  8762 00001B7E 57                      		push	di		; Save di
  8763 00001B7F BF8100                  		mov	di,81h		; di = ptr to command args
  8764 00001B82 BE8000                  		mov	si,80h		; Get address of length of command args
  8765 00001B85 AC                      		lodsb			; Load length
  8766 00001B86 88C1                    		mov	cl,al		; Move length to cl
  8767 00001B88 30ED                    		xor	ch,ch		; Zero ch
  8768 00001B8A 2EA0[7542]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8769 00001B8E 3C00                    		cmp	al,0		; Turn off ZF
  8770 00001B90 F2AE                    		repne scasb		; Scan for a switch character and return
  8771 00001B92 5F                      		pop	di		;  with ZF set if one was found
  8772 00001B93 C3                      		retn
  8773                                  
  8774                                  ; ---------------------------------------------------------------------------
  8775                                  
  8776                                  EXTERNAL:
  8777 00001B94 E8D101                  		call	TEST_APPEND	; check to see if append installed
  8778 00001B97 7403                    		jz	short NOT_BARRYF ; no - truly external command
  8779 00001B99 E950FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8780                                  
  8781                                  NOT_BARRYF:
  8782 00001B9C 2EC606[8442]00          		mov	byte [cs:FILTYP],0
  8783 00001BA2 2E8A16[9142]            		mov	dl,[cs:SPECDRV]
  8784 00001BA7 2E8816[EB42]            		mov	[cs:IDLEN],dl
  8785 00001BAC 2EC606[6744]00          		mov	byte [cs:ROM_CALL],0
  8786 00001BB2 52                      		push	dx
  8787 00001BB3 BA[EB42]                		mov	dx,IDLEN
  8788 00001BB6 E817E8                  		call	ROM_SCAN
  8789 00001BB9 5A                      		pop	dx
  8790                                  		;jnc	short POSTSAVE
  8791 00001BBA 7305                    		jnc	short DO_SCAN
  8792 00001BBC 2EFE06[6744]            		inc	byte [cs:ROM_CALL]
  8793                                  		;jmp	short POSTSAVE
  8794                                  
  8795                                  		;nop
  8796                                  DO_SCAN:
  8797                                  POSTSAVE:
  8798 00001BC1 BF[9941]                		mov	di,EXECPATH
  8799 00001BC4 C60500                  		mov	byte [di],0	; Initialize to current directory
  8800                                  	
  8801 00001BC7 2E803E[6744]00          		cmp	byte [cs:ROM_CALL],0
  8802 00001BCD 7402                    		jz	short RESEARCH
  8803 00001BCF EB13                    		jmp	short NEOEXECUTE
  8804                                  		
  8805                                  		;nop
  8806                                  RESEARCH:
  8807 00001BD1 E81C09                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8808 00001BD4 09C0                    		or	ax,ax		; did we find anything?
  8809 00001BD6 740A                    		jz	short BADCOMJ45	; null means no (sob)
  8810 00001BD8 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8811                                  					; fuckin' sixteen-bit machine ought
  8812 00001BDB 7C02                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8813                                  					; DISPLACEMENT!!
  8814                                  		;jmp	short NEOEXECUTE
  8815 00001BDD EB05                    		jmp	short EXECUTE	
  8816                                  
  8817                                  		; 02H is .bat
  8818                                  
  8819                                  		;nop
  8820                                  BATCOMJ:
  8821 00001BDF E904EB                  		jmp	BATCOM
  8822                                  
  8823                                  BADCOMJ45:
  8824 00001BE2 EB42                    		jmp	short BADCOM
  8825                                  
  8826                                  		;nop
  8827                                  EXECUTE:
  8828                                  NEOEXECUTE:
  8829 00001BE4 E82002                  		call	IOSET
  8830                                  
  8831                                  ; MSDOS 6.0
  8832                                  ;M051
  8833                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8834                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8835                                  ;After a close, this would still leave one open active resulting in sharing
  8836                                  ;errors on subsequent opens of the redirected file.
  8837                                  ;
  8838                                  ;LH_EXECUTE:				;M051	
  8839 00001BE7 8E06[8142]              		mov	es,[TRAN_TPA]
  8840 00001BEB B449                    		mov	ah,DEALLOC ; 49h
  8841 00001BED CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8842                                  				; ES = segment address of area to be freed
  8843                                  					; Now running in "free" space
  8844 00001BEF 8E06[7142]              		mov	es,[RESSEG]
  8845 00001BF3 26FE06E90B              		inc	byte [es:EXTCOM] ; Indicate external command
  8846 00001BF8 26C606F10B00            		mov	byte [es:RESTDIR],0 
  8847                                  					; Since USERDIR1 is in transient, insure
  8848                                  					; this flag value for re-entry to COMMAND
  8849                                  		; MSDOS 6.0
  8850                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8851                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8852                                  		;MOV	CX,LenMsgOrPathBuf
  8853                                  		;CLD
  8854                                  		;REP	MOVSB		; copy program pathname to resident
  8855                                  
  8856                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8857 00001BFE BF5C00                  		mov	di,FCB ; 5Ch
  8858 00001C01 89FE                    		mov	si,di
  8859 00001C03 B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8860 00001C06 F3A5                    		rep movsw		; Transfer parameters to resident header
  8861 00001C08 BA[9941]                		mov	dx,EXECPATH
  8862                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8863 00001C0B BB030D                  		mov	bx,EXEC_BLOCK
  8864 00001C0E B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8865 00001C11 F606[6744]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8866 00001C16 7403                    		jz	short OK_EXEC
  8867 00001C18 E92EE8                  		jmp	ROM_EXEC
  8868                                  OK_EXEC:
  8869                                  ;
  8870                                  ; we are now running in free space. Anything we do from here on may get
  8871                                  ; trashed. Move the stack (also in free space) to allocated space because
  8872                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  8873                                  ;
  8874 00001C1B 8CC1                    		mov	cx,es
  8875 00001C1D 8ED1                    		mov	ss,cx
  8876 00001C1F BC3C08                  		mov	sp,RSTACK
  8877 00001C22 FF2E[7742]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  8878                                  
  8879                                  ; ---------------------------------------------------------------------------
  8880                                  
  8881                                  BADCOM:
  8882 00001C26 0E                      		push	cs
  8883 00001C27 1F                      		pop	ds
  8884 00001C28 BA[BB37]                		mov	dx,BADNAMPTR
  8885                                  CERROR:		
  8886 00001C2B E89C18                  		call	STD_EPRINTF
  8887 00001C2E E9D3E4                  		jmp	TCOMMAND
  8888                                  
  8889                                  
  8890                                  ; =============== S U B	R O U T	I N E =======================================
  8891                                  
  8892                                  ; Prescan converts the input buffer into a canonicalized form.
  8893                                  ; All redirections and pipes are removed.
  8894                                  
  8895                                  PRESCAN:
  8896 00001C31 31C9                    		xor	cx,cx
  8897 00001C33 8E06[7142]              		mov	es,[RESSEG]
  8898 00001C37 BE[D240]                		mov	si,COMBUF+2
  8899 00001C3A 89F7                    		mov	di,si
  8900                                  COUNTQUOTES:
  8901 00001C3C AC                      		lodsb			; get a byte
  8902 00001C3D 3C22                    		cmp	al,22h		; is it a quote?
  8903 00001C3F 7504                    		jne	short COUNTEND	; no, try for end of road
  8904 00001C41 FEC5                    		inc	ch		; bump count
  8905 00001C43 EBF7                    		jmp	short COUNTQUOTES ; go get next char
  8906                                  COUNTEND:
  8907 00001C45 3C0D                    		cmp	al,0Dh		; end of road?
  8908 00001C47 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  8909 00001C49 89FE                    		mov	si,di		; restore pointer to begining
  8910                                  PRESCANLP:
  8911 00001C4B AC                      		lodsb
  8912 00001C4C 3C22                    		cmp	al,'"'		; " character
  8913 00001C4E 7510                    		jne	short TRYGREATER
  8914 00001C50 FECD                    		dec	ch
  8915 00001C52 740C                    		jz	short TRYGREATER
  8916                                  QLOOP:
  8917 00001C54 8805                    		mov	[di],al
  8918 00001C56 47                      		inc	di
  8919 00001C57 FEC1                    		inc	cl
  8920 00001C59 AC                      		lodsb
  8921 00001C5A 3C22                    		cmp	al,'"'		; " character
  8922 00001C5C 75F6                    		jne	short QLOOP
  8923 00001C5E FECD                    		dec	ch
  8924                                  TRYGREATER:
  8925 00001C60 3A06[F33E]              		cmp	al,[RABRACKET]
  8926 00001C64 753E                    		jne	short NOOUT
  8927                                  
  8928                                  ; We have found a ">" char. We need to see if there is another ">"
  8929                                  ; following it.
  8930                                  
  8931 00001C66 3804                    		cmp	[si],al
  8932 00001C68 7506                    		jnz	short NOAPPND
  8933 00001C6A AC                      		lodsb
  8934 00001C6B 26FE06080C              		inc	byte [es:RE_OUT_APP] ; Flag >>
  8935                                  NOAPPND:
  8936                                  ; Now we attempt to find the file name. First, scan off all whitespace
  8937                                  
  8938 00001C70 E808FD                  		call	SCANOFF
  8939                                  
  8940                                  		; MSDOS 6.0
  8941                                  		;CMP	AL,[LABRACKET]	   ;AN040; was there no filename?
  8942                                  		;Je	short REOUT_ERRSET ;AN040; yes - set up error
  8943                                  
  8944                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8945 00001C73 3C0D                    		cmp	al,0Dh
  8946 00001C75 750D                    		jnz	short GOTREOFIL
  8947                                  
  8948                                  ; There was no file present.  Set us up at end-of-line.
  8949                                  
  8950                                  REOUT_ERRSET:				;AN040; set up for an error
  8951 00001C77 C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  8952 00001C7A 26C706090C0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  8953 00001C81 E99E00                  		jmp	PRESCANEND
  8954                                  
  8955                                  GOTREOFIL:
  8956 00001C84 57                      		push	di
  8957                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  8958 00001C85 BF090C                  		mov	di,RE_OUTSTR
  8959 00001C88 89FB                    		mov	bx,di
  8960 00001C8A 06                      		push	es
  8961                                  
  8962                                  		; MSDOS 6.0
  8963                                  SETREOUTSTR:				; Get the output redirection name
  8964                                  					; MSKK06 07/14/89
  8965                                  		;push	cx		; save cx
  8966                                  		;mov	cx,64+13	; CX = max string length
  8967                                  ;SETREOUTSTR_LOOP:
  8968                                  		;LODSB
  8969                                  		;CMP	AL,0DH
  8970                                  		;JZ	GOTRESTR_J
  8971                                  		;INVOKE	DELIM
  8972                                  		;JZ	GOTRESTR_J
  8973                                  		;CMP	AL,[SWITCHAR]
  8974                                  		;JZ	GOTRESTR_J
  8975                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  8976                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  8977                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  8978                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  8979                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  8980                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  8981                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  8982                                  		;DEC	SI		;AN002; back up over symbol
  8983                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  8984                                  ;GOTRESTR_J:
  8985                                  		;pop	cx		; MSKK06 07/14/89
  8986                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  8987                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  8988                                  		;STOSB			; store it into resgroup
  8989                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  8990                                  		;jmp	GOTRESTR_j
  8991                                  ;PIPEERRSYNJ5_J:
  8992                                  		;pop	cx		; recover CX
  8993                                  		;jmp	short PIPEERRSYNJ5
  8994                                  
  8995                                  		; MSDOS 3.3
  8996                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  8997 00001C8B AC                      		lodsb
  8998 00001C8C 3C0D                    		cmp	al,0Dh
  8999 00001C8E 746E                    		jz	short GOTRESTR
  9000 00001C90 E8F0FC                  		call	DELIM
  9001 00001C93 7469                    		jz	short GOTRESTR
  9002 00001C95 3A06[7542]              		cmp	al,[SWITCHAR]
  9003 00001C99 7463                    		je	short GOTRESTR
  9004 00001C9B 3C22                    		cmp	al,'"'
  9005 00001C9D 7502                    		jne	short NO_ABRACKET
  9006 00001C9F FECD                    		dec	ch
  9007                                  NO_ABRACKET:
  9008 00001CA1 AA                      		stosb
  9009 00001CA2 EBE7                    		jmp	short SETREOUTSTR_LOOP
  9010                                  NOOUT:
  9011                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9012 00001CA4 3A06[F23E]              		cmp	al,[LABRACKET]
  9013 00001CA8 751F                    		jnz	short CHKPIPE
  9014 00001CAA 89F3                    		mov	bx,si		; Save loc of "<"
  9015 00001CAC E8CCFC                  		call	SCANOFF
  9016                                  		; MSDOS 6.0
  9017                                  		;CMP	AL,[RABRACKET]	;AN040; was there no filename?
  9018                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9019                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9020 00001CAF 3C0D                    		cmp	al,0Dh
  9021 00001CB1 750B                    		jnz	short GOTREIFIL
  9022                                  REIN_ERRSET:				;AN040; set up for error
  9023 00001CB3 C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9024 00001CB6 C706[1C42]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9025 00001CBC EB64                    		jmp	short PRESCANEND
  9026                                  GOTREIFIL:
  9027 00001CBE 57                      		push	di
  9028 00001CBF BF[1C42]                		mov	di,RE_INSTR
  9029 00001CC2 89FB                    		mov	bx,di
  9030 00001CC4 06                      		push	es
  9031 00001CC5 0E                      		push	cs
  9032 00001CC6 07                      		pop	es		; store in TRANGROUP
  9033 00001CC7 EBC2                    		jmp	short SETREOUTSTR_LOOP 
  9034                                  					; Get the input redirection name
  9035                                  CHKPIPE:
  9036 00001CC9 88C4                    		mov	ah,al
  9037                                  		;cmp	ah,'|'
  9038 00001CCB 80FC7C                  		cmp	ah,ALTPIPECHR
  9039 00001CCE 7406                    		je	short ISPIPE3
  9040 00001CD0 3A26[F13E]              		cmp	ah,[VBAR]
  9041 00001CD4 753F                    		jne	short CONTPRESCAN
  9042                                  ISPIPE3:
  9043                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9044                                  
  9045 00001CD6 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  9046 00001CDC 7505                    		jne	short NOECHOPUSH
  9047 00001CDE 26D026ED0B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9048                                  NOECHOPUSH:
  9049 00001CE3 26FE065A0C              		inc	byte [es:PIPEFLAG]
  9050 00001CE8 E890FC                  		call	SCANOFF
  9051 00001CEB 3C0D                    		cmp	al,0Dh
  9052 00001CED 740A                    		jz	short PIPEERRSYNJ5
  9053                                  		;cmp	al,'|'
  9054 00001CEF 3C7C                    		cmp	al,ALTPIPECHR
  9055 00001CF1 7406                    		jz	short PIPEERRSYNJ5
  9056 00001CF3 3A06[F13E]              		cmp	al,[VBAR]	; Double '|'?	
  9057 00001CF7 751C                    		jnz	short CONTPRESCAN
  9058                                  
  9059                                  PIPEERRSYNJ5:
  9060 00001CF9 06                      		push	es
  9061 00001CFA 1F                      		pop	ds
  9062 00001CFB E93A02                  		jmp	PIPEERRSYN
  9063                                  
  9064                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9065                                  ; than just a : in the redir string.
  9066                                  
  9067                                  GOTRESTR:
  9068 00001CFE 86E0                    		xchg	ah,al
  9069 00001D00 B03A                    		mov	al,':'
  9070 00001D02 29FB                    		sub	bx,di		; compute negative of number of chars
  9071 00001D04 83FBFF                  		cmp	bx,-1		; is there just a :?
  9072 00001D07 7407                    		je	short NOTRAILCOL ; yep, don't change
  9073 00001D09 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9074 00001D0D 7501                    		jne	short NOTRAILCOL
  9075 00001D0F 4F                      		dec	di		; Back up over trailing ':'
  9076                                  NOTRAILCOL:
  9077 00001D10 30C0                    		xor	al,al
  9078 00001D12 AA                      		stosb			; NUL terminate the string
  9079 00001D13 07                      		pop	es
  9080 00001D14 5F                      		pop	di		; Remember the start
  9081                                  CONTPRESCAN:
  9082 00001D15 8825                    		mov	[di],ah		; "delete" the redirection string
  9083 00001D17 47                      		inc	di
  9084 00001D18 80FC0D                  		cmp	ah,0Dh
  9085 00001D1B 7405                    		je	short PRESCANEND
  9086 00001D1D FEC1                    		inc	cl
  9087 00001D1F E929FF                  		jmp	PRESCANLP
  9088                                  PRESCANEND:
  9089 00001D22 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  9090 00001D28 7414                    		je	short ISNOPIPE
  9091                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9092 00001D2A BF7E0C                  		mov	di,PIPESTR
  9093 00001D2D 26893E7C0C              		mov	word [es:PIPEPTR],di
  9094 00001D32 BE[D240]                		mov	si,COMBUF+2
  9095 00001D35 E843FC                  		call	SCANOFF
  9096                                  PIPESETLP:				; Transfer the pipe into the resident
  9097 00001D38 AC                      		lodsb			; pipe buffer
  9098 00001D39 AA                      		stosb
  9099 00001D3A 3C0D                    		cmp	al,0Dh
  9100 00001D3C 75FA                    		jnz	short PIPESETLP
  9101                                  ISNOPIPE:
  9102 00001D3E 880E[D140]              		mov	[COMBUF+1],cl
  9103 00001D42 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  9104 00001D48 0E                      		push	cs
  9105 00001D49 07                      		pop	es
  9106 00001D4A C3                      		retn
  9107                                  
  9108                                  ; =============== S U B	R O U T	I N E =======================================
  9109                                  
  9110                                  CMD_COPY:
  9111 00001D4B BE[D240]                		mov	si,COMBUF+2
  9112 00001D4E E82AFC                  		call	SCANOFF		; advance past separators...
  9113 00001D51 0336[C043]              		add	si,[PATHPOS]
  9114 00001D55 BF8100                  		mov	di,81h
  9115 00001D58 31C9                    		xor	cx,cx
  9116                                  CMDCOPY:
  9117 00001D5A AC                      		lodsb
  9118 00001D5B AA                      		stosb
  9119 00001D5C 3C0D                    		cmp	al,0Dh
  9120 00001D5E 7403                    		je	short COPY_DONE
  9121 00001D60 41                      		inc	cx
  9122 00001D61 EBF7                    		jmp	short CMDCOPY
  9123                                  COPY_DONE:
  9124 00001D63 880E8000                		mov	[80h],cl
  9125 00001D67 C3                      		retn
  9126                                  
  9127                                  ; =============== S U B	R O U T	I N E =======================================
  9128                                  
  9129                                  TEST_APPEND:
  9130 00001D68 BB[D040]                		mov	bx,COMBUF	; barry can address
  9131 00001D6B BE[EB42]                		mov	si,IDLEN	; address command name, DS already set 	
  9132 00001D6E BAFFFF                  		mov	dx,-1
  9133 00001D71 B800AE                  		mov	ax,0AE00h
  9134 00001D74 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9135                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9136                                  				; DX = FFFFh,[BX -> command line
  9137                                  				; Return: AL = FFh if this command is a TSR extension 
  9138                                  				;		   to COMMAND.COM
  9139                                  				; AL = 00h if the command should be executed as	usual
  9140 00001D76 3C00                    		cmp	al,0
  9141 00001D78 C3                      		retn
  9142                                  
  9143                                  ;============================================================================
  9144                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9145                                  ;============================================================================
  9146                                  ; 05/10/2018 - Retro DOS v3.0
  9147                                  
  9148                                  ;	More misc routines
  9149                                  
  9150                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9151                                  
  9152                                  ; =============== S U B	R O U T	I N E =======================================
  9153                                  
  9154                                  SETPATH:
  9155                                  
  9156                                  ; ENTRY PathPos = ptr to string
  9157                                  ;       PathCnt = length of string
  9158                                  ;
  9159                                  ; EXIT  PathPos = ptr to string after pathname
  9160                                  ;       PathCnt = length of rest of string
  9161                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9162                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9163                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9164                                  ;
  9165                                  ;       A null character is dropped at the end of the pathname. If the
  9166                                  ;       character in that spot previously was CR, it is copied into the
  9167                                  ;       following byte. So there must be at least two two character 
  9168                                  ;       positions in the buffer following the pathname.
  9169                                  
  9170                                  		; MSDOS 6.0
  9171                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9172                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9173                                  
  9174                                  		; MSDOS 3.3
  9175 00001D79 BE8000                  		mov	si,80h
  9176 00001D7C AC                      		lodsb
  9177 00001D7D 30E4                    		xor	ah,ah
  9178 00001D7F A3[BE43]                		mov	[PATHCNT],ax
  9179 00001D82 8936[C043]              		mov	[PATHPOS],si
  9180                                  GETPATH:
  9181                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9182 00001D86 C606[7044]00            		mov	byte [DESTINFO],0
  9183 00001D8B C606[6C44]00            		mov	byte [DESTVARS],0
  9184 00001D90 8B36[C043]              		mov	si,[PATHPOS]	; SI = ptr to string
  9185 00001D94 8B0E[BE43]              		mov	cx,[PATHCNT]	; CX = string length
  9186 00001D98 89F2                    		mov	dx,si		; DX = ptr to string
  9187 00001D9A E33D                    		jcxz	PATHDONE	; string length is zero, we're done
  9188 00001D9C 51                      		push	cx		; save string length
  9189 00001D9D 56                      		push	si		; save ptr to string
  9190 00001D9E E80BFD                  		call	SWITCH
  9191                                  
  9192                                  ;       After Switch, SI has been scanned past any switches, and
  9193                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9194                                  
  9195 00001DA1 A3[C243]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9196 00001DA4 5B                      		pop	bx		; BX = ptr to original string
  9197 00001DA5 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9198 00001DA7 59                      		pop	cx		; CX = string length
  9199 00001DA8 01D9                    		add	cx,bx		; CX = string length from current SI
  9200 00001DAA 89F2                    		mov	dx,si		; DX = ptr to current string
  9201                                  SKIPPATH:
  9202 00001DAC E32B                    		jcxz	PATHDONE	; string length is zero, we're done
  9203 00001DAE 49                      		dec	cx		; CX = length left after next char
  9204 00001DAF AC                      		lodsb			; AL = next char of string
  9205                                  					; SI = ptr to char after this one
  9206 00001DB0 E85BFC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9207 00001DB3 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9208 00001DB5 FE06[6C44]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9209                                  TESTPMETA:
  9210 00001DB9 3C3F                    		cmp	al,'?'
  9211 00001DBB 7505                    		jne	short TESTPSTAR	; char is not '?'
  9212 00001DBD 800E[7044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9213                                  TESTPSTAR:
  9214                                  		;cmp	al,'*'
  9215 00001DC2 3A06[FD3E]              		cmp	al,[STAR]
  9216 00001DC6 7505                    		jne	short TESTPDELIM ; char is not '*'
  9217 00001DC8 800E[7044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9218                                  TESTPDELIM:
  9219 00001DCD E8B3FB                  		call	DELIM		; compare AL to all delimiters
  9220 00001DD0 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9221 00001DD2 3A06[7542]              		cmp	al,[SWITCHAR]
  9222 00001DD6 75D4                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9223                                  PATHDONEDEC:
  9224 00001DD8 4E                      		dec	si		; SI = ptr to char after pathname
  9225                                  PATHDONE:
  9226 00001DD9 30C0                    		xor	al,al		; AL = NULL
  9227 00001DDB 8604                    		xchg	al,[si]		; place NULL after pathname
  9228 00001DDD 46                      		inc	si		; SI = ptr to byte after NULL
  9229 00001DDE 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9230 00001DE0 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9231 00001DE2 8804                    		mov	[si],al		; save EOL after NULL
  9232                                  NOPSTORE:
  9233 00001DE4 8936[C043]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9234 00001DE8 890E[BE43]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9235                                  SETPATH_RETN:
  9236 00001DEC C3                      		retn
  9237                                  
  9238                                  ; ---------------------------------------------------------------------------
  9239                                  
  9240                                  PGETARG:
  9241 00001DED BE8000                  		mov	si,80h
  9242 00001DF0 AC                      		lodsb
  9243 00001DF1 08C0                    		or	al,al
  9244 00001DF3 74F7                    		jz	short SETPATH_RETN
  9245 00001DF5 E80300                  		call	PSCANOFF
  9246 00001DF8 3C0D                    		cmp	al,0Dh
  9247 00001DFA C3                      		retn
  9248                                  
  9249                                  ; ---------------------------------------------------------------------------
  9250                                  
  9251                                  PSCANOFF:
  9252 00001DFB AC                      		lodsb
  9253 00001DFC E884FB                  		call	DELIM
  9254 00001DFF 7504                    		jnz	short PSCANOFFD
  9255 00001E01 3C3B                    		cmp	al,';'
  9256 00001E03 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9257                                  PSCANOFFD:
  9258 00001E05 4E                      		dec	si		; Point to first non-delimiter
  9259 00001E06 C3                      		retn
  9260                                  
  9261                                  ; =============== S U B	R O U T	I N E =======================================
  9262                                  
  9263                                  IOSET:
  9264                                  		; ALL REGISTERS PRESERVED
  9265 00001E07 1E                      		push	ds
  9266 00001E08 52                      		push	dx
  9267 00001E09 50                      		push	ax
  9268 00001E0A 53                      		push	bx
  9269 00001E0B 51                      		push	cx
  9270 00001E0C 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9271 00001E11 803E5A0C00              		cmp	byte [PIPEFLAG],0
  9272 00001E16 750D                    		jne	short NOREDIR
  9273 00001E18 F606F80BFF              		test	byte [IFFLAG],0FFh
  9274 00001E1D 7506                    		jnz	short NOREDIR
  9275 00001E1F E80900                  		call	TESTDOREIN
  9276 00001E22 E85400                  		call	TESTDOREOUT
  9277                                  NOREDIR:
  9278 00001E25 59                      		pop	cx
  9279 00001E26 5B                      		pop	bx
  9280 00001E27 58                      		pop	ax
  9281 00001E28 5A                      		pop	dx
  9282 00001E29 1F                      		pop	ds
  9283                                  IOSET_RETN:
  9284 00001E2A C3                      		retn
  9285                                  
  9286                                  ; =============== S U B	R O U T	I N E =======================================
  9287                                  
  9288                                  TESTDOREIN:
  9289 00001E2B 2E803E[1C42]00          		cmp	byte [cs:RE_INSTR],0
  9290 00001E31 74F7                    		jz	short IOSET_RETN
  9291 00001E33 1E                      		push	ds
  9292 00001E34 0E                      		push	cs
  9293 00001E35 1F                      		pop	ds
  9294 00001E36 BA[1C42]                		mov	dx,RE_INSTR
  9295 00001E39 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9296 00001E3C 89C3                    		mov	bx,ax
  9297 00001E3E CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9298                                  				; DS:DX	-> ASCIZ filename
  9299                                  				; AL = access mode
  9300                                  				; 0 - read
  9301 00001E40 1F                      		pop	ds
  9302 00001E41 720B                    		jb	short REDIRERR
  9303 00001E43 89C3                    		mov	bx,ax
  9304 00001E45 B0FF                    		mov	al,0FFh
  9305                                  
  9306                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9307                                  ; spot. We invalidate the new JFN we got.
  9308                                  
  9309                                  		;xchg	al,[bx+18h]
  9310 00001E47 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9311 00001E4A A21800                  		mov	byte [PDB.JFN_TABLE],al
  9312 00001E4D C3                      		retn
  9313                                  
  9314                                  ; ---------------------------------------------------------------------------
  9315                                  
  9316                                  ; We had some kind of error on the redirection. Figure out what the
  9317                                  ; appropriate message should be; BX has the system call that failed
  9318                                  
  9319                                  REDIRERR:
  9320 00001E4E 0E                      		push	cs
  9321 00001E4F 1F                      		pop	ds
  9322                                  		;call	TriageError
  9323 00001E50 E87900                  		call	GET_EXT_ERR_NUMBER
  9324                                  
  9325                                  ; At this point, we have recognized the network-generated access denied error.
  9326                                  ; The correct message is in DX
  9327                                  
  9328 00001E53 83F841                  		cmp	ax,65
  9329 00001E56 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9330 00001E58 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9331 00001E5B 7406                    		jz	short OPENERR
  9332 00001E5D BA[6E38]                		mov	dx,FULDIRPTR
  9333                                  _CERRORJ:
  9334 00001E60 E9C8FD                  		jmp	CERROR
  9335                                  
  9336                                  OPENERR:
  9337                                  ; The system call was an OPEN. Report either file not found or path not found.
  9338                                  
  9339                                  		; MSDOS 6.0
  9340                                  		;mov	msg_disp_class,ext_msg_class 
  9341                                  		;			;AN000; set up extended error msg class
  9342                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9343                                  		;			;AC000; get extended message pointer
  9344                                  		;mov	Extend_Buf_ptr,ax	
  9345                                  		;			;AN000; get message number in control block
  9346                                  		;JMP	CERROR
  9347                                  
  9348                                  		; MSDOS 3.3
  9349 00001E63 BA[F837]                		mov	dx,FNOTFOUNDPTR
  9350                                  		;cmp	ax,2
  9351 00001E66 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9352 00001E69 74F5                    		je	short _CERRORJ
  9353 00001E6B BA[1D38]                		mov	dx,ACCDENPTR
  9354                                  		;cmp	ax,5 ; Access denied error
  9355 00001E6E 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9356 00001E71 74ED                    		je	short _CERRORJ
  9357                                  			; ERROR_PATH_NOT_FOUND
  9358 00001E73 BA[0B38]                		mov	dx,PNOTFOUNDPTR
  9359 00001E76 E9B2FD                  		jmp	CERROR
  9360                                  
  9361                                  ; =============== S U B	R O U T	I N E =======================================
  9362                                  
  9363                                  TESTDOREOUT:
  9364 00001E79 803E090C00              		cmp	byte [RE_OUTSTR],0
  9365 00001E7E 743D                    		je	short NOREOUT
  9366                                  
  9367                                  REOUTEXISTS:
  9368 00001E80 803E080C00              		cmp	byte [RE_OUT_APP],0
  9369 00001E85 741F                    		je	short REOUTCRT
  9370                                  
  9371 00001E87 BA090C                  		mov	dx,RE_OUTSTR
  9372                                  
  9373                                  		; MSDOS 6.0
  9374                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9375                                  		;mov	ax,3D02h
  9376                                  
  9377                                  		; MSDOS 3.3
  9378 00001E8A B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9379                                  	
  9380                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9381 00001E8D 50                      		push	ax
  9382 00001E8E CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9383                                  				; DS:DX	-> ASCIZ filename
  9384                                  				; AL = access mode
  9385                                  				; 1 - write
  9386 00001E90 5B                      		pop	bx
  9387 00001E91 720D                    		jc	short OPENWRITEERROR
  9388                                  
  9389                                  		; MSDOS 6.0
  9390                                  		;MOV	BX,AX
  9391                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9392                                  		;INT	21h			;AN035;
  9393                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9394                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9395                                  		;
  9396                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9397                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9398                                  		;MOV	DX,CX			;AC011;
  9399                                  		;INT	21h
  9400                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9401                                  		;POP	DS			;AN011;
  9402                                  		;assume	DS:Trangroup		;AN011;
  9403                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9404                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9405                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9406                                  		;INT	21h			;AN011;
  9407                                  		;JC	OpenWriteError		;AN011; If error, exit
  9408                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9409                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9410                                  		;
  9411                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9412                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9413                                  		;assume	DS:Resgroup		;AN011;
  9414                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9415                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9416                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9417                                  		;MOV	DX,CX			;AN011;
  9418                                  		;INT	21h			;AN011;
  9419                                  		;JMP	SHORT SET_REOUT
  9420                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9421                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9422                                  		;assume	DS:Resgroup		;AN017;
  9423                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9424                                  		;XOR	CX,CX			;AN017; Offset is 0
  9425                                  		;MOV	DX,CX			;AN017;
  9426                                  		;INT	21h			;AN017;
  9427                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9428                                  
  9429                                  		; MSDOS 3.3
  9430 00001E93 31D2                    		xor	dx,dx
  9431 00001E95 31C9                    		xor	cx,cx
  9432 00001E97 89C3                    		mov	bx,ax
  9433 00001E99 B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9434 00001E9C CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9435                                  				; AL = method: offset from end of file
  9436 00001E9E EB15                    		jmp	short SET_REOUT
  9437                                  		
  9438                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9439                                  OPENWRITEERROR:	
  9440                                  		;cmp	ax,5
  9441 00001EA0 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9442 00001EA3 F9                      		stc
  9443 00001EA4 74A8                    		je	short REDIRERR
  9444                                  REOUTCRT:	
  9445 00001EA6 BA090C                  		mov	dx,RE_OUTSTR
  9446 00001EA9 31C9                    		xor	cx,cx
  9447 00001EAB B43C                    		mov	ah,CREAT ; 3Ch
  9448 00001EAD 50                      		push	ax
  9449 00001EAE CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9450                                  				; CX = attributes for file
  9451                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9452 00001EB0 5B                      		pop	bx
  9453 00001EB1 729B                    		jc	short REDIRERR
  9454                                  NOREDIRERR:
  9455 00001EB3 89C3                    		mov	bx,ax
  9456                                  SET_REOUT:
  9457                                  
  9458                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9459                                  ; spot. We invalidate the new JFN we got.
  9460                                  
  9461 00001EB5 B0FF                    		mov	al,0FFh
  9462                                  		;xchg	al,[bx+18h]
  9463 00001EB7 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9464 00001EBA A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9465                                  NOREOUT:
  9466 00001EBD C3                      		retn
  9467                                  
  9468                                  ; =============== S U B	R O U T	I N E =======================================
  9469                                  
  9470                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9471                                  ; registers
  9472                                  
  9473                                  DSTRLEN:
  9474 00001EBE 50                      		push	ax
  9475 00001EBF 31C9                    		xor	cx,cx
  9476 00001EC1 FC                      		cld
  9477                                  DLOOP:
  9478 00001EC2 AC                      		lodsb
  9479 00001EC3 41                      		inc	cx
  9480 00001EC4 08C0                    		or	al,al
  9481 00001EC6 75FA                    		jnz	short DLOOP
  9482 00001EC8 29CE                    		sub	si,cx
  9483 00001ECA 58                      		pop	ax
  9484                                  TRIAGEERR_RETN:
  9485 00001ECB C3                      		retn
  9486                                  
  9487                                  ; =============== S U B	R O U T	I N E =======================================
  9488                                  
  9489                                  ;Break	<Extended error support>
  9490                                  
  9491                                  TriageError:  ; MSDOS 6.0
  9492                                  
  9493                                  ;
  9494                                  ; TriageError will examine the return from a carry-set system call and
  9495                                  ; return the correct error if applicable.
  9496                                  ;
  9497                                  ;   Inputs:	outputs from a carry-settable system call
  9498                                  ;		No system calls may be done in the interrim
  9499                                  ;   Outputs:	If carry was set on input
  9500                                  ;		    carry set on output
  9501                                  ;		    DX contains trangroup offset to printf message
  9502                                  ;		else
  9503                                  ;		    No registers changed
  9504                                  ;
  9505                                  
  9506                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9507                                  
  9508                                  GET_EXT_ERR_NUMBER:
  9509 00001ECC 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9510 00001ECE 9C                      		pushf
  9511 00001ECF 53                      		push	bx
  9512 00001ED0 51                      		push	cx
  9513 00001ED1 56                      		push	si
  9514 00001ED2 57                      		push	di
  9515 00001ED3 55                      		push	bp
  9516 00001ED4 06                      		push	es
  9517 00001ED5 1E                      		push	ds
  9518 00001ED6 50                      		push	ax
  9519 00001ED7 52                      		push	dx
  9520                                  		;mov	ah,59h
  9521 00001ED8 B459                    		mov	ah,GETEXTENDEDERROR
  9522 00001EDA CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9523                                  				; BX = version code (0000h for DOS 3.x)
  9524 00001EDC 59                      		pop	cx
  9525 00001EDD 5B                      		pop	bx		; restore original AX
  9526 00001EDE BA[1D38]                		mov	dx,ACCDENPTR
  9527 00001EE1 83F841                  		cmp	ax,65		; network access denied?
  9528 00001EE4 7404                    		je	short NOMOVE	; Yes, return it.
  9529 00001EE6 89D8                    		mov	ax,bx
  9530 00001EE8 89CA                    		mov	dx,cx
  9531                                  NOMOVE:
  9532 00001EEA 1F                      		pop	ds
  9533 00001EEB 07                      		pop	es
  9534 00001EEC 5D                      		pop	bp
  9535 00001EED 5F                      		pop	di
  9536 00001EEE 5E                      		pop	si
  9537 00001EEF 59                      		pop	cx
  9538 00001EF0 5B                      		pop	bx
  9539 00001EF1 9D                      		popf
  9540 00001EF2 C3                      		retn
  9541                                  
  9542                                  ; =============== S U B	R O U T	I N E =======================================
  9543                                  
  9544                                  		; Far call from resident portion/segment of COMMAND.COM
  9545                                  
  9546                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9547                                  
  9548                                  TRIAGE_INIT:
  9549                                  		;call	TriageError
  9550 00001EF3 E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9551 00001EF6 CB                      		retf
  9552                                  
  9553                                  ;============================================================================
  9554                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9555                                  ;============================================================================
  9556                                  ; 03/10/2018 - Retro DOS v3.0
  9557                                  
  9558                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9559                                  
  9560                                  ; =============== S U B	R O U T	I N E =======================================
  9561                                  
  9562                                  SINGLETEST:
  9563 00001EF7 1E                      		push	ds
  9564 00001EF8 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9565 00001EFD 833EF30B00              		cmp	word [SINGLECOM],0
  9566 00001F02 7406                    		jz	short TESTDONE
  9567 00001F04 813EF30BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9568                                  TESTDONE:
  9569 00001F0A 1F                      		pop	ds
  9570 00001F0B C3                      		retn
  9571                                  
  9572                                  ; =============== S U B	R O U T	I N E =======================================
  9573                                  
  9574                                  SETREST1:
  9575 00001F0C B001                    		mov	al,1
  9576                                  
  9577                                  ; ---------------------------------------------------------------------------
  9578                                  
  9579                                  SETREST:
  9580 00001F0E 1E                      		push	ds
  9581 00001F0F 8E1E[7142]              		mov	ds,[RESSEG]
  9582 00001F13 A2F10B                  		mov	byte [RESTDIR],al
  9583 00001F16 1F                      		pop	ds
  9584 00001F17 C3                      		retn
  9585                                  
  9586                                  ; =============== S U B	R O U T	I N E =======================================
  9587                                  
  9588                                  ; Note that we need to handle the same thing that RestDir handles: the
  9589                                  ; requirement that we try only once to restore the user's environment after
  9590                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9591                                  ; disappear, we just give up.
  9592                                  
  9593                                  PIPEDEL:
  9594 00001F18 1E                      		push	ds
  9595 00001F19 52                      		push	dx
  9596 00001F1A 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9597 00001F1F BA5C0C                  		mov	dx,PIPE1	; Clean up in case ^C
  9598 00001F22 B441                    		mov	ah,UNLINK ; 41h 
  9599 00001F24 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9600                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9601                                  				;		(no wildcards allowed)
  9602 00001F26 BA6C0C                  		mov	dx,PIPE2
  9603 00001F29 B441                    		mov	ah,UNLINK ; 41h
  9604 00001F2B CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9605                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9606                                  				;		(no wildcards allowed)
  9607 00001F2D 5A                      		pop	dx
  9608 00001F2E E85D04                  		call	PIPEOFF
  9609 00001F31 C6065B0C00              		mov	byte [PIPEFILES],0
  9610 00001F36 1F                      		pop	ds
  9611 00001F37 C3                      		retn
  9612                                  
  9613                                  ; ---------------------------------------------------------------------------
  9614                                  
  9615                                  PIPEERRSYN:
  9616 00001F38 BA[783C]                		mov	dx,SYNTMESPTR
  9617 00001F3B E8DAFF                  		call	PIPEDEL
  9618 00001F3E 0E                      		push	cs
  9619 00001F3F 1F                      		pop	ds
  9620 00001F40 E9E8FC                  		jmp	CERROR
  9621                                  
  9622                                  ; ---------------------------------------------------------------------------
  9623                                  
  9624                                  PIPERR:
  9625 00001F43 9C                      		pushf
  9626                                  		;invoke	TRIAGEERROR
  9627 00001F44 E885FF                  		call	GET_EXT_ERR_NUMBER
  9628 00001F47 50                      		push	ax		; Save results from TriageError
  9629 00001F48 52                      		push	dx
  9630 00001F49 BA[D23C]                		mov	dx,PIPEEMESPTR
  9631 00001F4C E8C9FF                  		call	PIPEDEL
  9632 00001F4F 0E                      		push	cs
  9633 00001F50 1F                      		pop	ds
  9634 00001F51 E87615                  		call	STD_EPRINTF
  9635 00001F54 5A                      		pop	dx		; Restore results from TriageError
  9636 00001F55 58                      		pop	ax
  9637 00001F56 9D                      		popf
  9638 00001F57 83F841                  		cmp	ax,65
  9639 00001F5A 7503                    		jnz	short TCOMMANDJ
  9640 00001F5C E9CCFC                  		jmp	CERROR
  9641                                  
  9642                                  TCOMMANDJ:
  9643 00001F5F E9A2E1                  		jmp	TCOMMAND
  9644                                  
  9645                                  PIPEPROCSTRT:
  9646 00001F62 8E1E[7142]              		mov	ds,[RESSEG]
  9647 00001F66 FE065B0C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9648                                  
  9649                                  		; MSDOS 6.0
  9650                                  		;push	es
  9651                                  		;push	di
  9652                                  		;push	ds
  9653                                  		;push	si
  9654                                  		;
  9655                                  		;push	ds
  9656                                  		;push	es
  9657                                  		;pop	ds				;ds = TRANGROUP
  9658                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9659                                  ;
  9660                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9661                                  ;so the routine is not really general
  9662                                  ;
  9663                                  		;call	Find_Name_In_Environment	;es:di points at path
  9664                                  		;pop	ds				;ds = DATARES again
  9665                                  		;jc	no_temp_path
  9666                                  		;
  9667                                  		;push	ds
  9668                                  		;push	es
  9669                                  		;pop	ds
  9670                                  		;pop	es				;swap ds and es
  9671                                  		;mov	si,di				;ds:si points at path
  9672                                  		;
  9673                                  		;call	skip_white			;skip white space chars
  9674                                  ;
  9675                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9676                                  ;
  9677                                  		;call	copy_pipe_path			;copy the pipe path
  9678                                  		;
  9679                                  ;
  9680                                  ;Check if the TEMP path is valid
  9681                                  ;
  9682                                  		;push	es
  9683                                  		;pop	ds				;ds = DATARES
  9684                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9685                                  		;mov	ax, (CHMOD shl 8) or 0
  9686                                  		;int	21h
  9687                                  		;jc	no_temp_path
  9688                                  		;
  9689                                  		;test	cx,10h				;is it a directory?
  9690                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9691                                  		;
  9692                                  		;stc					;no, indicate fail
  9693                                  no_temp_path:
  9694                                  		;pop	si
  9695                                  		;pop	ds
  9696                                  		;pop	di
  9697                                  		;pop	es
  9698                                  		;jnc	crt_temp			;path found, create tempfiles
  9699                                  
  9700                                  		; MSDOS 3.3
  9701 00001F6A B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9702 00001F6C CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9703 00001F6E 2E0206[F03E]            		add	al,[cs:CAPITAL_A]
  9704 00001F73 A26C0C                  		mov	byte [PIPE2],al		; Make pipe files in root of def drv
  9705 00001F76 BB5C0C                  		mov	bx,PIPE1
  9706 00001F79 8807                    		mov	[bx],al
  9707 00001F7B 30E4                    		xor	ah,ah			; nul terminate path names
  9708 00001F7D 88265F0C                		mov	byte [PIPE1+3],ah
  9709 00001F81 88266F0C                		mov	byte [PIPE2+3],ah
  9710                                  
  9711                                  		; MSDOS 6.0
  9712                                  ;SR;
  9713                                  ; We want to create temp files in the current directory rather than in the 
  9714                                  ;root of the drive. This is because the number of files that can be present
  9715                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9716                                  ;
  9717                                  		;mov	ah,'.'
  9718                                  		;mov	Pipe1,ah
  9719                                  		;mov	Pipe2,ah
  9720                                  		;xor	ah,ah
  9721                                  		;mov	Pipe1+1,ah
  9722                                  		;mov	Pipe2+1,ah		;create files in current dir
  9723                                  
  9724                                  ;crt_temp:
  9725                                  		; MSDOS 6.0
  9726                                  		;mov	dx,offset DATARES:Pipe1
  9727                                  		;mov	dx,PIPE1
  9728                                  	
  9729                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9730 00001F85 89DA                    		mov	dx,bx
  9731 00001F87 31C9                    		xor	cx,cx
  9732 00001F89 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9733 00001F8B CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9734                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9735                                  			; receive generated filename
  9736                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9737 00001F8D 72B4                    		jc	short PIPERR	; Couldn't create
  9738 00001F8F 89C3                    		mov	bx,ax
  9739 00001F91 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9740 00001F93 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9741                                  				; BX = file handle
  9742 00001F95 BA6C0C                  		mov	dx,PIPE2
  9743 00001F98 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9744 00001F9A CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9745                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9746                                  			; receive generated filename
  9747                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9748 00001F9C 72A5                    		jc	short PIPERR
  9749 00001F9E 89C3                    		mov	bx,ax
  9750 00001FA0 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9751 00001FA2 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9752                                  					; BX = file handle
  9753                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9754 00001FA4 E884FE                  		call	TESTDOREIN
  9755 00001FA7 8B367C0C                		mov	si,word [PIPEPTR]
  9756 00001FAB 833EF30BFF              		cmp	word [SINGLECOM],-1
  9757 00001FB0 7506                    		jne	short NOSINGP
  9758 00001FB2 C706F30B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9759                                  NOSINGP:
  9760 00001FB8 EB30                    		jmp	short FIRSTPIPE
  9761                                  
  9762                                  ; ---------------------------------------------------------------------------
  9763                                  
  9764                                  PIPEPROC:
  9765 00001FBA 8026ED0BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9766 00001FBF 8B367C0C                		mov	si,word [PIPEPTR]
  9767 00001FC3 AC                      		lodsb
  9768                                  		;cmp	al,'|'		
  9769 00001FC4 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9770 00001FC6 740A                    		je	short ISPIPE1	; Yes
  9771 00001FC8 2E3A06[F13E]            		cmp	al,[cs:VBAR]
  9772 00001FCD 7403                    		je	short ISPIPE1
  9773 00001FCF E98900                  		jmp	PIPEEND		; Pipe done
  9774                                  ISPIPE1:
  9775 00001FD2 8B16FF0C                		mov	dx,word [INPIPEPTR] ; Get the input file name
  9776 00001FD6 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9777 00001FD9 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9778                                  				; DS:DX	-> ASCIZ filename
  9779                                  				; AL = access mode
  9780                                  				; 0 - read
  9781                                  PIPEERRJ:
  9782 00001FDB 7303                    		jnc	short NO_PIPEERR
  9783 00001FDD E963FF                  		jmp	PIPERR		; Lost the pipe file
  9784                                  NO_PIPEERR:
  9785 00001FE0 89C3                    		mov	bx,ax
  9786 00001FE2 B0FF                    		mov	al,0FFh
  9787                                  		;xchg	al,[bx+18h]
  9788 00001FE4 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9789 00001FE7 A21800                  		mov	byte [PDB.JFN_TABLE],al	; Redirect
  9790                                  FIRSTPIPE:
  9791 00001FEA BF[D240]                		mov	di,COMBUF+2
  9792 00001FED 31C9                    		xor	cx,cx
  9793 00001FEF 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9794 00001FF2 7503                    		jne	short PIPEOK1
  9795                                  PIPEERRSYNJ:
  9796 00001FF4 E941FF                  		jmp	PIPEERRSYN
  9797                                  PIPEOK1:
  9798 00001FF7 2EA0[F13E]              		mov	al,[cs:VBAR]
  9799 00001FFB 3804                    		cmp	[si],al		; '||'
  9800 00001FFD 74F5                    		je	short PIPEERRSYNJ
  9801                                  		;cmp	byte [si],'|'
  9802 00001FFF 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9803 00002002 74F0                    		je	short PIPEERRSYNJ
  9804                                  PIPECOMLP:
  9805 00002004 AC                      		lodsb
  9806 00002005 AA                      		stosb
  9807 00002006 3C0D                    		cmp	al,0Dh
  9808 00002008 743F                    		je	short LASTPIPE
  9809 0000200A 41                      		inc	cx
  9810                                  		;cmp	al,'|'
  9811 0000200B 3C7C                    		cmp	al,ALTPIPECHR
  9812 0000200D 7407                    		je	short ISPIPE2
  9813 0000200F 2E3A06[F13E]            		cmp	al,[cs:VBAR]
  9814 00002014 75EE                    		jne	short PIPECOMLP
  9815                                  ISPIPE2:
  9816 00002016 26C645FF0D              		mov	byte [es:di-1],0Dh
  9817 0000201B 49                      		dec	cx
  9818 0000201C 2E880E[D140]            		mov	[cs:COMBUF+1],cl
  9819 00002021 4E                      		dec	si
  9820 00002022 89367C0C                		mov	word [PIPEPTR],si	; On to next pipe element
  9821 00002026 8B16010D                		mov	dx,word [OUTPIPEPTR]
  9822 0000202A 51                      		push	cx
  9823 0000202B 31C9                    		xor	cx,cx
  9824 0000202D B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9825 00002030 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9826                                  				; CX = attributes for file
  9827                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9828 00002032 59                      		pop	cx
  9829 00002033 72A6                    		jc	short PIPEERRJ		; Lost the file
  9830 00002035 89C3                    		mov	bx,ax
  9831 00002037 B0FF                    		mov	al,0FFh
  9832                                  		;xchg	al,[bx+18h]
  9833 00002039 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9834 0000203C A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9835 0000203F 8716FF0C                		xchg	dx,word [INPIPEPTR]	; Swap for next element of pipe
  9836 00002043 8916010D                		mov	word [OUTPIPEPTR],dx
  9837 00002047 EB0D                    		jmp	short PIPECOM
  9838                                  LASTPIPE:
  9839 00002049 2E880E[D140]            		mov	[cs:COMBUF+1],cl 
  9840 0000204E 4E                      		dec	si
  9841 0000204F 89367C0C                		mov	word [PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9842 00002053 E823FE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9843                                  PIPECOM:
  9844 00002056 0E                      		push	cs
  9845 00002057 1F                      		pop	ds
  9846 00002058 E95DE2                  		jmp	NOPIPEPROC	; Process the pipe element
  9847                                  PIPEEND:
  9848 0000205B E8BAFE                  		call	PIPEDEL
  9849 0000205E 813EF30B00F0            		cmp	word [SINGLECOM],0F000h
  9850 00002064 7506                    		jnz	short NOSINGP2
  9851 00002066 C706F30BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
  9852                                  NOSINGP2:
  9853 0000206C E995E0                  		jmp	TCOMMAND
  9854                                  
  9855                                  ; =============== S U B	R O U T	I N E =======================================
  9856                                  
  9857                                  ; Date and time are set during initialization and use
  9858                                  ; this routines since they need to do a long return
  9859                                  
  9860                                  DATINIT:
  9861 0000206F 2E8C1E[7142]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
  9862 00002074 06                      		push	es
  9863 00002075 1E                      		push	ds		; Going to use the previous stack
  9864 00002076 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
  9865 00002078 8EC0                    		mov	es,ax
  9866 0000207A 8ED8                    		mov	ds,ax
  9867                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
  9868 0000207C BA[F84C]                		mov	dx,INTERNATVARS
  9869 0000207F B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  9870 00002082 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9871                                  				; get current-country info
  9872                                  				; DS:DX	-> buffer for returned info
  9873                                  		; 20/10/2018
  9874 00002084 C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
  9875 0000208A C606[D040]80            		mov	byte [COMBUF],128 ; Init COMBUF
  9876 0000208F C706[D140]010D          		mov	word [COMBUF+1],0D01h
  9877 00002095 E86C00                  		call	DATE
  9878 00002098 E88001                  		call	CTIME
  9879 0000209B 1F                      		pop	ds
  9880 0000209C 07                      		pop	es
  9881 0000209D CB                      		retf
  9882                                  
  9883                                  ; =============== S U B	R O U T	I N E =======================================
  9884                                  
  9885                                  ; MSDOS 6.0
  9886                                  
  9887                                  ; ****************************************************************
  9888                                  ; *
  9889                                  ; * ROUTINE:	 DATE - Set system date
  9890                                  ; *
  9891                                  ; * FUNCTION:	 If a date is specified, set the system date,
  9892                                  ; *		 otherwise display the current system date and
  9893                                  ; *		 prompt the user for a new date.  If an invalid
  9894                                  ; *		 date is specified, issue an error message and
  9895                                  ; *		 prompt for a new date.  If the user enters
  9896                                  ; *		 nothing when prompted for a date, terminate.
  9897                                  ; *
  9898                                  ; * INPUT:	 command line at offset 81H
  9899                                  ; *
  9900                                  ; * OUTPUT:	 none
  9901                                  ; *
  9902                                  ; ****************************************************************
  9903                                  
  9904                                  ;assume	ds:trangroup,es:trangroup
  9905                                  ;
  9906                                  ;DATE:
  9907                                  ;	MOV	SI,81H				; Accepting argument for date inline
  9908                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
  9909                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9910                                  ;	xor	dx,dx				;AN000;
  9911                                  ;	invoke	cmd_parse			;AC000; call parser
  9912                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9913                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
  9914                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9915                                  ;	jne	daterr				;AN000; yes - go issue message
  9916                                  ;	JMP	short COMDAT			;AC000; we have a date
  9917                                  ;
  9918                                  ;PRMTDAT:
  9919                                  ;	; Print "Current date is
  9920                                  ;
  9921                                  ;	invoke	GetDate 			;AN000; get date  for output
  9922                                  ;	xchg	dh,dl				;AN000; switch month & day
  9923                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
  9924                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
  9925                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
  9926                                  ;	invoke	std_printf
  9927                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
  9928                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
  9929                                  ;
  9930                                  ;GET_NEW_DATE:					;AN000;
  9931                                  ;	call	getdat				;AC000; prompt user for date
  9932                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9933                                  ;	jz	date_end			;AC000; yes - exit
  9934                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9935                                  ;	jne	daterr				;AN000; yes - go issue message
  9936                                  ;COMDAT:
  9937                                  ;	mov	cx,date_year			;AC000; get parts of date in
  9938                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
  9939                                  ;	mov	dl,date_day			;AC000;    date function call.
  9940                                  ;	push	cx				;AC000; save date
  9941                                  ;	push	dx				;AC000;
  9942                                  ;	mov	cx,1				;AC000; set 1 positional entered
  9943                                  ;	xor	dx,dx				;AN029;
  9944                                  ;	invoke	cmd_parse			;AN029; call parser
  9945                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
  9946                                  ;	pop	dx				;AC000; retrieve date
  9947                                  ;	pop	cx				;AC000;
  9948                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
  9949                                  ;	MOV	AH,SET_DATE			;yes - set date
  9950                                  ;	INT	21h
  9951                                  ;	OR	AL,AL
  9952                                  ;	JNZ	DATERR
  9953                                  ;date_end:
  9954                                  ;	ret
  9955                                  ;
  9956                                  ;DATERR:
  9957                                  ;	invoke	crlf2				;AN028; print out a blank line
  9958                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
  9959                                  ;	invoke	std_printf
  9960                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
  9961                                  
  9962                                  ; =============== S U B	R O U T	I N E =======================================
  9963                                  
  9964                                  ; MSDOS 6.0
  9965                                  
  9966                                  ; TIME gets and sets the time
  9967                                  
  9968                                  ; ****************************************************************
  9969                                  ; *
  9970                                  ; * ROUTINE:	 TIME - Set system time
  9971                                  ; *
  9972                                  ; * FUNCTION:	 If a time is specified, set the system time,
  9973                                  ; *		 otherwise display the current system time and
  9974                                  ; *		 prompt the user for a new time.  If an invalid
  9975                                  ; *		 time is specified, issue an error message and
  9976                                  ; *		 prompt for a new time.  If the user enters
  9977                                  ; *		 nothing when prompted for a time, terminate.
  9978                                  ; *
  9979                                  ; * INPUT:	 command line at offset 81H
  9980                                  ; *
  9981                                  ; * OUTPUT:	 none
  9982                                  ; *
  9983                                  ; ****************************************************************
  9984                                  
  9985                                  ;assume	ds:trangroup,es:trangroup
  9986                                  ;
  9987                                  ;CTIME:
  9988                                  ;	MOV	SI,81H				; Accepting argument for time inline
  9989                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
  9990                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9991                                  ;	xor	dx,dx				;AN000;
  9992                                  ;	invoke	cmd_parse			;AC000; call parser
  9993                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9994                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
  9995                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9996                                  ;	jne	timerr				;AN000; yes - go issue message
  9997                                  ;	JMP	short COMTIM			;AC000; we have a time
  9998                                  ;
  9999                                  ;PRMTTIM:
 10000                                  ;	;Printf "Current time is ... "
 10001                                  ;
 10002                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10003                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10004                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10005                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10006                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10007                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10008                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10009                                  ;	invoke	std_printf
 10010                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10011                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10012                                  ;
 10013                                  ;GET_NEW_TIME:
 10014                                  ;	call	gettim				;AC000;
 10015                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10016                                  ;	jz	time_end			;AC000;
 10017                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10018                                  ;	jne	timerr				;AN000; yes - go issue message
 10019                                  ;
 10020                                  ;COMTIM:
 10021                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10022                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10023                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10024                                  ;	mov	dl,time_fraction		;AC000;
 10025                                  ;	push	cx				;AC000; save time
 10026                                  ;	push	dx				;AC000;
 10027                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10028                                  ;	xor	dx,dx				;AN029;
 10029                                  ;	invoke	cmd_parse			;AN029; call parser
 10030                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10031                                  ;	pop	dx				;AC000; retieve time
 10032                                  ;	pop	cx				;AC000;
 10033                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10034                                  ;
 10035                                  ;SAVTIM:
 10036                                  ;	MOV	AH,SET_TIME
 10037                                  ;	INT	21h
 10038                                  ;	OR	AL,AL
 10039                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10040                                  ;
 10041                                  ;TIME_END:
 10042                                  ;
 10043                                  ;	ret
 10044                                  ;
 10045                                  ;TIMERR:
 10046                                  ;	invoke	crlf2				;AN028; print out a blank line
 10047                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10048                                  ;	invoke	std_printf			; Print error message
 10049                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10050                                  
 10051                                  ; =============== S U B	R O U T	I N E =======================================
 10052                                  
 10053                                  ; MSDOS 6.0
 10054                                  
 10055                                  ;
 10056                                  ; Set the special flag in the INIT flag to the value in CX.
 10057                                  ;
 10058                                  
 10059                                  ;SetInitFlag:
 10060                                  ;	mov	ds,[RESSEG]
 10061                                  ;assume ds:resgroup
 10062                                  ;	and	InitFlag,NOT initSpecial
 10063                                  ;	or	InitFlag,cL
 10064                                  ;	push	cs
 10065                                  ;	pop	ds
 10066                                  ;	return
 10067                                  ;
 10068                                  ;Public	PipeOff
 10069                                  ;PipeOff:
 10070                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10071                                  ;	SaveReg <DS,AX>
 10072                                  ;	MOV	DS,ResSeg
 10073                                  ;	ASSUME	DS:RESGroup
 10074                                  ;	XOR	AL,AL
 10075                                  ;	XCHG	PipeFlag,AL
 10076                                  ;	OR	AL,AL
 10077                                  ;	JZ	PipeOffDone
 10078                                  ;	SHR	EchoFlag,1
 10079                                  ;PipeOffDone:
 10080                                  ;	RestoreReg  <AX,DS>
 10081                                  ;	return
 10082                                  
 10083                                  ; =============== S U B	R O U T	I N E =======================================
 10084                                  
 10085                                  ; MSDOS 6.0
 10086                                  
 10087                                  ;PRINT_TIME:
 10088                                  ;
 10089                                  ;	MOV	AH,GET_TIME
 10090                                  ;	INT	21h			; Get time in CX:DX
 10091                                  ;
 10092                                  ;	PUSH	ES
 10093                                  ;	PUSH	CS
 10094                                  ;	POP	ES
 10095                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10096                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10097                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10098                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10099                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10100                                  ;	invoke	std_printf
 10101                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10102                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10103                                  ;
 10104                                  ;	POP	ES
 10105                                  ;	return
 10106                                  
 10107                                  ; =============== S U B	R O U T	I N E =======================================
 10108                                  
 10109                                  ; MSDOS 6.0
 10110                                  
 10111                                  ; ****************************************************************
 10112                                  ; *
 10113                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10114                                  ; *
 10115                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10116                                  ; *		 INFORMATION and issues the "Enter new date"
 10117                                  ; *		 message with the proper date format.  COMBUF
 10118                                  ; *		 is reset to get a date from the command line.
 10119                                  ; *		 The PARSE_DATE blocks are then reset and the
 10120                                  ; *		 PARSE function call is issued.
 10121                                  ; *
 10122                                  ; * INPUT:	 NONE
 10123                                  ; *
 10124                                  ; * OUTPUT:	 COMBUF
 10125                                  ; *		 PARSER RETURN CODES
 10126                                  ; *
 10127                                  ; ****************************************************************
 10128                                  
 10129                                  ;GETDAT	proc	near				;AC000;
 10130                                  ;
 10131                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10132                                  ;	mov	dx,5ch				;  should be entered in and
 10133                                  ;	int	21h			;  print a message describing it
 10134                                  ;	mov	si,dx
 10135                                  ;	lodsw
 10136                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10137                                  ;	dec	ax
 10138                                  ;	js	printformat
 10139                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10140                                  ;	jz	printformat
 10141                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10142                                  ;printformat:
 10143                                  ;	mov	ax,dx				;AN000; get message number of format
 10144                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10145                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10146                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10147                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10148                                  ;	invoke	std_printf
 10149                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10150                                  ;
 10151                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10152                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10153                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10154                                  ;	call	SetInitFlag			;  prompting for date.
 10155                                  ;	INT	21h			; Get input line
 10156                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10157                                  ;	call	SetInitFlag			;  prompting for date.
 10158                                  ;	invoke	CRLF2
 10159                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10160                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
 10161                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10162                                  ;	xor	dx,dx				;AN000;
 10163                                  ;	invoke	cmd_parse			;AC000; call parser
 10164                                  ;
 10165                                  ;	ret
 10166                                  ;
 10167                                  ;GETDAT	endp					;AC000;
 10168                                  
 10169                                  ; =============== S U B	R O U T	I N E =======================================
 10170                                  
 10171                                  ; MSDOS 6.0
 10172                                  
 10173                                  ; ****************************************************************
 10174                                  ; *
 10175                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10176                                  ; *
 10177                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10178                                  ; *		 INFORMATION and issues the "Enter new time"
 10179                                  ; *		 message. COMBUF is reset to get a time from the
 10180                                  ; *		 command line.	The PARSE_TIME blocks are then
 10181                                  ; *		 reset and the PARSE function call is issued.
 10182                                  ; *
 10183                                  ; * INPUT:	 NONE
 10184                                  ; *
 10185                                  ; * OUTPUT:	 COMBUF
 10186                                  ; *		 PARSER RETURN CODES
 10187                                  ; *
 10188                                  ; ****************************************************************
 10189                                  
 10190                                  ;GETTIM	proc	near				;AC000;
 10191                                  ;
 10192                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10193                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10194                                  ;	invoke	std_printf
 10195                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10196                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10197                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10198                                  ;	call	SetInitFlag			;  prompting for time.
 10199                                  ;	INT	21h			; Get input line
 10200                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10201                                  ;	call	SetInitFlag			;  prompting for time.
 10202                                  ;	invoke	CRLF2
 10203                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10204                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
 10205                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10206                                  ;	xor	dx,dx				;AN000;
 10207                                  ;	invoke	cmd_parse			;AC000; call parser
 10208                                  ;
 10209                                  ;	ret
 10210                                  ;
 10211                                  ;GETTIM	endp					;AC000;
 10212                                  
 10213                                  ; =============== S U B	R O U T	I N E =======================================
 10214                                  
 10215                                  ; MSDOS 6.0
 10216                                  
 10217                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10218                                  ;the '=' sign in the environment variable before the actual path.
 10219                                  ;
 10220                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10221                                  ;
 10222                                  ;	EXIT:	ds:si = start of the path
 10223                                  ;
 10224                                  ;	REGISTERS AFFECTED: ax
 10225                                  ;
 10226                                  
 10227                                  ;Skip_white	proc	near
 10228                                  ;
 10229                                  ;	cld
 10230                                  ;skw_lp:
 10231                                  ;	lodsb
 10232                                  ;	cmp	al,' '				;blank char?
 10233                                  ;	jz	skw_lp				;yes, skip it
 10234                                  ;	cmp	al,09				;tab char?
 10235                                  ;	jz	skw_lp				;yes, skip it
 10236                                  ;
 10237                                  ;	dec	si				;point at first non-white
 10238                                  ;
 10239                                  ;	ret
 10240                                  ;
 10241                                  ;Skip_white	endp
 10242                                  
 10243                                  ; =============== S U B	R O U T	I N E =======================================
 10244                                  
 10245                                  ; MSDOS 6.0
 10246                                  
 10247                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10248                                  ;variable into the path buffers Pipe1 & Pipe2.
 10249                                  ;
 10250                                  ;	ENTRY:	ds:si = path to be copied
 10251                                  ;		es = RESGROUP
 10252                                  ;
 10253                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10254                                  ;
 10255                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10256                                  ;
 10257                                  
 10258                                  ;Copy_pipe_path	proc	near
 10259                                  ;
 10260                                  ;	mov	cx,0ffffh
 10261                                  ;	xor	al,al
 10262                                  ;
 10263                                  ;	mov	di,si
 10264                                  ;	push	es			;save es
 10265                                  ;	push	ds
 10266                                  ;	pop	es			;es:di = path to be copied
 10267                                  ;	
 10268                                  ;	cld
 10269                                  ;	push	di
 10270                                  ;	repnz	scasb			;look for the null char
 10271                                  ;	pop	di
 10272                                  ;
 10273                                  ;	pop	es			;es = RESGROUP again
 10274                                  ;
 10275                                  ;	not	cx			;length including the null
 10276                                  ;
 10277                                  ;	mov	di,offset DATARES:Pipe1	
 10278                                  ;	push	di
 10279                                  ;	push	cx			
 10280                                  ;	rep	movsb			;copy path into Pipe1
 10281                                  ;	pop	cx
 10282                                  ;	pop	di
 10283                                  ;
 10284                                  ;	push	ds
 10285                                  ;	push	es
 10286                                  ;	pop	ds			;ds:si = Pipe1
 10287                                  ;	mov	si,di
 10288                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10289                                  ;	rep	movsb			;copy path into Pipe2
 10290                                  ;	pop	ds
 10291                                  ;
 10292                                  ;	ret				;
 10293                                  ;
 10294                                  ;Copy_pipe_path	endp
 10295                                  
 10296                                  ;============================================================================
 10297                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10298                                  ;============================================================================
 10299                                  ; 05/10/2018 - Retro DOS v3.0
 10300                                  
 10301                                  ; DATE - Gets and sets the time
 10302                                  
 10303                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10304                                  
 10305                                  ; =============== S U B	R O U T	I N E =======================================
 10306                                  
 10307                                  DATE_CXDX:
 10308 0000209E 89CB                    		mov	bx,cx
 10309                                  
 10310                                  ; =============== S U B	R O U T	I N E =======================================
 10311                                  
 10312                                  P_DATE:
 10313 000020A0 89D8                    		mov	ax,bx
 10314 000020A2 89D1                    		mov	cx,dx
 10315 000020A4 B264                    		mov	dl,100
 10316 000020A6 F6F2                    		div	dl
 10317 000020A8 86C4                    		xchg	al,ah
 10318 000020AA 92                      		xchg	ax,dx
 10319 000020AB B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10320                                  		;mov	ax,[INTERNATVARS]
 10321 000020AD A1[F84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10322 000020B0 09C0                    		or	ax,ax
 10323 000020B2 7415                    		jz	short USPDAT
 10324 000020B4 48                      		dec	ax
 10325 000020B5 7422                    		jz	short EUPDAT
 10326 000020B7 B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10327 000020B9 E83900                  		call	P_YR
 10328 000020BC E82B00                  		call	P_DSEP
 10329 000020BF E82200                  		call	P_MON
 10330 000020C2 E82500                  		call	P_DSEP
 10331 000020C5 E82700                  		call	P_DAY
 10332 000020C8 C3                      		retn
 10333                                  
 10334                                  USPDAT:
 10335 000020C9 E81800                  		call	P_MON
 10336 000020CC E81B00                  		call	P_DSEP
 10337 000020CF E81D00                  		call	P_DAY
 10338                                  PLST:
 10339 000020D2 E81500                  		call	P_DSEP
 10340 000020D5 E81D00                  		call	P_YR
 10341 000020D8 C3                      		retn
 10342                                  
 10343                                  EUPDAT:
 10344 000020D9 E81300                  		call	P_DAY
 10345 000020DC E80B00                  		call	P_DSEP
 10346 000020DF E80200                  		call	P_MON
 10347 000020E2 EBEE                    		jmp	short PLST
 10348                                  
 10349                                  ; ---------------------------------------------------------------------------
 10350                                  
 10351                                  P_MON:
 10352 000020E4 88E8                    		mov	al,ch
 10353 000020E6 E88402                  		call	OUT2
 10354 000020E9 C3                      		retn
 10355                                  
 10356                                  ; ---------------------------------------------------------------------------
 10357                                  
 10358                                  P_DSEP:
 10359                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10360 000020EA A0[034D]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10361 000020ED AA                      		stosb
 10362 000020EE C3                      		retn
 10363                                  
 10364                                  ; ---------------------------------------------------------------------------
 10365                                  
 10366                                  P_DAY:
 10367 000020EF 88C8                    		mov	al,cl
 10368 000020F1 E87902                  		call	OUT2
 10369 000020F4 C3                      		retn
 10370                                  
 10371                                  ; ---------------------------------------------------------------------------
 10372                                  
 10373                                  P_YR:
 10374 000020F5 88F0                    		mov	al,dh
 10375 000020F7 08C0                    		or	al,al
 10376 000020F9 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10377 000020FB E86F02                  		call	OUT2
 10378                                  TWODIGYR:
 10379 000020FE 88D0                    		mov	al,dl
 10380 00002100 E86A02                  		call	OUT2
 10381                                  DATE_RETN:
 10382 00002103 C3                      		retn
 10383                                  
 10384                                  ; =============== S U B	R O U T	I N E =======================================
 10385                                  
 10386                                  DATE:				 	; Accepting argument for date inline
 10387 00002104 BE8100                  		mov	si,81h
 10388 00002107 E871F8                  		call	SCANOFF
 10389 0000210A 3C0D                    		cmp	al,0Dh
 10390 0000210C 7402                    		jz	short PRMTDAT
 10391 0000210E EB48                    		jmp	short COMDAT
 10392                                  
 10393                                  		;nop
 10394                                  
 10395                                  PRMTDAT:
 10396                                  		; MSDOS 3.3
 10397 00002110 BA[5B3A]                		mov	dx,CURDATPTR
 10398 00002113 E8BD13                  		call	STD_PRINTF	; Print "Current date is "	
 10399 00002116 E88608                  		call	PRINT_DATE
 10400                                  
 10401                                  GETDAT:	
 10402 00002119 BA[6F3A]                		mov	dx,NEWDATPTR
 10403 0000211C E8B413                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10404                                  
 10405 0000211F B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10406                                  					; Determine what format the date
 10407 00002122 BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10408 00002125 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10409                                  				; get current-country info
 10410                                  				; DS:DX	-> buffer for returned info
 10411 00002127 89D6                    		mov	si,dx		;  print a message describing it
 10412 00002129 AD                      		lodsw
 10413 0000212A BA[7E3A]                		mov	dx,USADATPTR	; get mm-dd-yy
 10414 0000212D 48                      		dec	ax
 10415 0000212E 7808                    		js	short PRINTFORMAT
 10416 00002130 BA[8D3A]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10417 00002133 7403                    		jz	short PRINTFORMAT
 10418 00002135 BA[9C3A]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10419                                  PRINTFORMAT:
 10420 00002138 E89813                  		call	STD_PRINTF
 10421 0000213B B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10422 0000213D BA[D040]                		mov	dx,COMBUF
 10423 00002140 B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10424 00002143 E83802                  		call	SETINITFLAG	;  prompting for date.
 10425 00002146 CD21                    		int	21h		; Get input line
 10426 00002148 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10427 0000214A E83102                  		call	SETINITFLAG	;  prompting for date.
 10428 0000214D E81EF8                  		call	CRLF2
 10429 00002150 BE[D240]                		mov	si,COMBUF+2
 10430 00002153 803C0D                  		cmp	byte [si],0Dh
 10431 00002156 74AB                    		jz	short DATE_RETN
 10432                                  COMDAT:
 10433                                  		;mov	ax,[INTERNATVARS]
 10434 00002158 A1[F84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10435 0000215B 09C0                    		or	ax,ax
 10436 0000215D 7435                    		jz	short USSDAT
 10437 0000215F 48                      		dec	ax
 10438 00002160 744B                    		jz	short EUSDAT
 10439 00002162 E86500                  		call	GET_YR
 10440 00002165 7235                    		jc	short DATERRJ
 10441 00002167 E89E00                  		call	GET_DSEP
 10442 0000216A 7230                    		jc	short DATERRJ
 10443 0000216C E84D00                  		call	GET_MON
 10444 0000216F 722B                    		jc	short DATERRJ
 10445 00002171 E89400                  		call	GET_DSEP
 10446 00002174 7226                    		jc	short DATERRJ
 10447 00002176 E84B00                  		call	GET_DAY
 10448                                  DAT_SET:
 10449 00002179 7303                    		jnc	short DATSET
 10450 0000217B E98100                  		jmp	DATERR
 10451                                  
 10452                                  ; ---------------------------------------------------------------------------
 10453                                  
 10454                                  DATSET:
 10455 0000217E AC                      		lodsb
 10456 0000217F 3C20                    		cmp	al,' '
 10457 00002181 74FB                    		jz	short DATSET
 10458 00002183 3C09                    		cmp	al,9
 10459 00002185 74F7                    		jz	short DATSET
 10460 00002187 3C0D                    		cmp	al,0Dh
 10461 00002189 7574                    		jnz	short DATERR
 10462 0000218B B42B                    		mov	ah,SET_DATE ; 2Bh
 10463 0000218D CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10464                                  				; DL = day,DH = month,	CX = year
 10465                                  				; Return: AL = 00h if no error 
 10466                                  				; 	     = FFh if bad value sent to routine
 10467 0000218F 08C0                    		or	al,al
 10468 00002191 756C                    		jnz	short DATERR
 10469                                  DAT_SET_RETN:
 10470 00002193 C3                      		retn
 10471                                  
 10472                                  ; ---------------------------------------------------------------------------
 10473                                  
 10474                                  USSDAT:
 10475 00002194 E82500                  		call	GET_MON
 10476 00002197 7266                    		jb	short DATERR
 10477 00002199 E86C00                  		call	GET_DSEP
 10478                                  DATERRJ:
 10479 0000219C 7261                    		jc	short DATERR
 10480 0000219E E82300                  		call	GET_DAY
 10481                                  TGET:
 10482 000021A1 725C                    		jc	short DATERR
 10483 000021A3 E86200                  		call	GET_DSEP
 10484 000021A6 7257                    		jc	short DATERR
 10485 000021A8 E81F00                  		call	GET_YR
 10486 000021AB EBCC                    		jmp	short DAT_SET
 10487                                  
 10488                                  ; ---------------------------------------------------------------------------
 10489                                  
 10490                                  EUSDAT:
 10491 000021AD E81400                  		call	GET_DAY
 10492 000021B0 724D                    		jc	short DATERR
 10493 000021B2 E85300                  		call	GET_DSEP
 10494 000021B5 7248                    		jc	short DATERR
 10495 000021B7 E80200                  		call	GET_MON
 10496 000021BA EBE5                    		jmp	short TGET
 10497                                  
 10498                                  
 10499                                  ; =============== S U B	R O U T	I N E =======================================
 10500                                  
 10501                                  GET_MON:
 10502 000021BC E88E01                  		call	GETNUM		; Get one or two digit number
 10503 000021BF 72D2                    		jc	short DAT_SET_RETN
 10504 000021C1 88E6                    		mov	dh,ah		; Put in position
 10505 000021C3 C3                      		retn
 10506                                  
 10507                                  
 10508                                  ; =============== S U B	R O U T	I N E =======================================
 10509                                  
 10510                                  GET_DAY:
 10511 000021C4 E88601                  		call	GETNUM
 10512 000021C7 88E2                    		mov	dl,ah		; Put in position
 10513                                  GET_DAY_RETN:
 10514 000021C9 C3                      		retn
 10515                                  
 10516                                  ; =============== S U B	R O U T	I N E =======================================
 10517                                  
 10518                                  GET_YR:
 10519 000021CA E88001                  		call	GETNUM
 10520 000021CD 72FA                    		jc	short GET_DAY_RETN
 10521 000021CF B96C07                  		mov	cx,1900
 10522 000021D2 E83300                  		call	GET_DSEP
 10523 000021D5 9C                      		pushf
 10524 000021D6 4E                      		dec	si
 10525 000021D7 9D                      		popf
 10526 000021D8 741E                    		jz	short BIAS
 10527 000021DA 803C0D                  		cmp	byte [si],0Dh
 10528 000021DD 7419                    		je	short BIAS
 10529 000021DF 803C20                  		cmp	byte [si],' '
 10530 000021E2 7414                    		je	short BIAS
 10531 000021E4 803C09                  		cmp	byte [si],9
 10532 000021E7 740F                    		je	short BIAS
 10533 000021E9 53                      		push	bx
 10534 000021EA B364                    		mov	bl,100
 10535 000021EC 88E0                    		mov	al,ah
 10536 000021EE F6E3                    		mul	bl
 10537 000021F0 5B                      		pop	bx
 10538 000021F1 89C1                    		mov	cx,ax
 10539 000021F3 E85701                  		call	GETNUM
 10540 000021F6 72D1                    		jc	short GET_DAY_RETN
 10541                                  BIAS:
 10542 000021F8 88E0                    		mov	al,ah
 10543 000021FA B400                    		mov	ah,0
 10544 000021FC 01C1                    		add	cx,ax
 10545                                  BIAS_RETN:
 10546 000021FE C3                      		retn
 10547                                  
 10548                                  ; ---------------------------------------------------------------------------
 10549                                  
 10550                                  DATERR:
 10551 000021FF BA[483A]                		mov	dx,BADDATPTR
 10552 00002202 E8CE12                  		call	STD_PRINTF
 10553 00002205 E911FF                  		jmp	GETDAT
 10554                                  
 10555                                  ; =============== S U B	R O U T	I N E =======================================
 10556                                  
 10557                                  GET_DSEP:
 10558 00002208 AC                      		lodsb
 10559 00002209 3C2F                    		cmp	al,'/'
 10560 0000220B 74F1                    		je	short BIAS_RETN
 10561                                  		;cmp	al,'.'
 10562 0000220D 3A06[083F]              		cmp	al,[DOT_CHR]
 10563 00002211 74EB                    		je	short BIAS_RETN
 10564                                  		;cmp	al,'-'
 10565 00002213 3A06[FE3E]              		cmp	al,[CHAR_SUB]
 10566 00002217 74E5                    		je	short BIAS_RETN
 10567 00002219 F9                      		stc
 10568 0000221A C3                      		retn
 10569                                  
 10570                                  ; =============== S U B	R O U T	I N E =======================================
 10571                                  
 10572                                  ; TIME gets and sets the time
 10573                                  
 10574                                  CTIME:
 10575 0000221B BE8100                  		mov	si,81h		; Accepting argument for time inline
 10576 0000221E E85AF7                  		call	SCANOFF
 10577 00002221 3C0D                    		cmp	al,0Dh
 10578 00002223 747C                    		je	short PRMTTIM
 10579 00002225 BB3A2E                  		mov	bx,2E3Ah ; ":."
 10580 00002228 E80601                  		call	INLINE
 10581 0000222B E98B00                  		jmp	COMTIM
 10582                                  
 10583                                  ; =============== S U B	R O U T	I N E =======================================
 10584                                  
 10585                                  PRINT_TIME:
 10586 0000222E B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10587 00002230 CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10588                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10589                                  				; DL = hundredths of seconds
 10590 00002232 57                      		push	di
 10591 00002233 06                      		push	es
 10592 00002234 0E                      		push	cs
 10593 00002235 07                      		pop	es
 10594 00002236 BF[9B42]                		mov	di,CHARBUF
 10595 00002239 B301                    		mov	bl,1	; Always 24 hour time
 10596 0000223B E81300                  		call	P_TIME
 10597 0000223E 31C0                    		xor	ax,ax
 10598 00002240 AA                      		stosb
 10599 00002241 BA[9B42]                		mov	dx,CHARBUF
 10600 00002244 8916[4E44]              		mov	[STRING_PTR_2],dx
 10601 00002248 BA[3F37]                		mov	dx,STRINGBUF2PTR
 10602 0000224B E88512                  		call	STD_PRINTF
 10603 0000224E 07                      		pop	es
 10604 0000224F 5F                      		pop	di
 10605                                  P_TIME_RETN:
 10606 00002250 C3                      		retn
 10607                                  
 10608                                  ; =============== S U B	R O U T	I N E =======================================
 10609                                  
 10610                                  P_TIME:
 10611 00002251 88E8                    		mov	al,ch	
 10612 00002253 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10613 00002256 7512                    		jnz	short T24	; 24 hr time?
 10614 00002258 B761                    		mov	bh,'a'		; Assume A.M.
 10615 0000225A 3C0C                    		cmp	al,12		; In the afternoon?
 10616 0000225C 7206                    		jb	short MORN
 10617 0000225E B770                    		mov	bh,'p'
 10618 00002260 7402                    		jz	short MORN
 10619 00002262 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10620                                  MORN:
 10621 00002264 08C0                    		or	al,al		; Before 1 am?
 10622 00002266 7502                    		jnz	short T24
 10623 00002268 B00C                    		mov	al,12
 10624                                  T24:
 10625 0000226A 53                      		push	bx
 10626 0000226B B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10627 0000226D E8FD00                  		call	OUT2
 10628 00002270 E82900                  		call	P_TSEP
 10629 00002273 88C8                    		mov	al,cl
 10630 00002275 E8F500                  		call	OUT2
 10631 00002278 5B                      		pop	bx
 10632 00002279 53                      		push	bx
 10633 0000227A F6C380                  		test	bl,80h
 10634 0000227D 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10635 0000227F B700                    		mov	bh,0		; Disable leading zero suppression
 10636 00002281 E81800                  		call	P_TSEP
 10637 00002284 88F0                    		mov	al,dh
 10638 00002286 E8E400                  		call	OUT2
 10639                                  		;mov	al,'.'
 10640 00002289 A0[014D]                		mov	al,[DECIMAL_SEP]
 10641 0000228C AA                      		stosb
 10642 0000228D 88D0                    		mov	al,dl
 10643 0000228F E8DB00                  		call	OUT2
 10644                                  PAP:
 10645 00002292 5B                      		pop	bx
 10646 00002293 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10647 00002296 75B8                    		jnz	short P_TIME_RETN
 10648 00002298 88F8                    		mov	al,bh
 10649 0000229A AA                      		stosb
 10650 0000229B C3                      		retn
 10651                                  
 10652                                  ; =============== S U B	R O U T	I N E =======================================
 10653                                  
 10654                                  P_TSEP:
 10655                                  		;mov	al,[TIME_SEP]
 10656 0000229C A0[054D]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10657 0000229F AA                      		stosb
 10658                                  P_TSEP_RETN:
 10659 000022A0 C3                      		retn
 10660                                  
 10661                                  ; ---------------------------------------------------------------------------
 10662                                  
 10663                                  PRMTTIM:
 10664 000022A1 BA[C13A]                		mov	dx,CURTIMPTR
 10665 000022A4 E82C12                  		call	STD_PRINTF	; Print "Current time is "
 10666 000022A7 E884FF                  		call	PRINT_TIME
 10667                                  GETTIM:
 10668 000022AA 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10669 000022AC BA[D63A]                		mov	dx,NEWTIMPTR
 10670 000022AF E82112                  		call	STD_PRINTF
 10671                                  		;mov	bx,':.'
 10672 000022B2 8B1E[0C3F]              		mov	bx,[TIMECHARS] 
 10673 000022B6 E85B00                  		call	GETBUF
 10674                                  COMTIM:
 10675 000022B9 74E5                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10676 000022BB 724F                    		jc	short TIMEERR
 10677 000022BD 89D1                    		mov	cx,dx
 10678 000022BF 31D2                    		xor	dx,dx
 10679 000022C1 AC                      		lodsb
 10680 000022C2 3C0D                    		cmp	al,0Dh
 10681 000022C4 743E                    		je	short SAVTIM
 10682 000022C6 3C20                    		cmp	al,' '
 10683 000022C8 742D                    		je	short GOTSEC2
 10684 000022CA 3C09                    		cmp	al,9
 10685 000022CC 7429                    		je	short GOTSEC2
 10686 000022CE 38D8                    		cmp	al,bl
 10687 000022D0 7404                    		je	short GOTSEC
 10688 000022D2 38F8                    		cmp	al,bh
 10689 000022D4 7536                    		jne	short TIMEERR
 10690                                  GOTSEC:
 10691 000022D6 E87400                  		call	GETNUM
 10692 000022D9 7231                    		jc	short TIMEERR
 10693 000022DB 88E6                    		mov	dh,ah		; Position seconds
 10694 000022DD AC                      		lodsb
 10695 000022DE 3C0D                    		cmp	al,0Dh
 10696 000022E0 7422                    		je	short SAVTIM
 10697 000022E2 3C20                    		cmp	al,' '
 10698 000022E4 7411                    		je	short GOTSEC2
 10699 000022E6 3C09                    		cmp	al,9
 10700 000022E8 740D                    		je	short GOTSEC2
 10701                                  		;cmp	al,'.'
 10702 000022EA 3A06[014D]              		cmp	al,[DECIMAL_SEP]
 10703 000022EE 751C                    		jne	short TIMEERR
 10704 000022F0 E85A00                  		call	GETNUM
 10705 000022F3 7217                    		jc	short TIMEERR
 10706 000022F5 88E2                    		mov	dl,ah
 10707                                  GOTSEC2:
 10708 000022F7 AC                      		lodsb
 10709 000022F8 3C20                    		cmp	al,' '
 10710 000022FA 74FB                    		je	short GOTSEC2
 10711 000022FC 3C09                    		cmp	al,9
 10712 000022FE 74F7                    		je	short GOTSEC2
 10713 00002300 3C0D                    		cmp	al,0Dh
 10714 00002302 7508                    		jne	short TIMEERR
 10715                                  SAVTIM:
 10716 00002304 B42D                    		mov	ah,SET_TIME ; 2Dh
 10717 00002306 CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10718                                  				; CH = hours,CL = minutes,DH = seconds,
 10719                                  				;		DL = hundredths of seconds
 10720                                  				; Return: AL = 00h if no error 
 10721                                  				;	     = FFh if bad value sent to routine
 10722 00002308 08C0                    		or	al,al
 10723                                  P_TSEP_JRETN:
 10724 0000230A 7494                    		jz	short P_TSEP_RETN ; Error in time?
 10725                                  TIMEERR:
 10726 0000230C BA[AE3A]                		mov	dx,BADTIMPTR
 10727 0000230F E8C111                  		call	STD_PRINTF	; Print "Enter new time: "
 10728 00002312 EB96                    		jmp	short GETTIM
 10729                                  
 10730                                  ; =============== S U B	R O U T	I N E =======================================
 10731                                  
 10732                                  GETBUF:
 10733 00002314 B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10734 00002316 BA[D040]                		mov	dx,COMBUF
 10735 00002319 B90200                  		mov	cx,2
 10736 0000231C E85F00                  		call	SETINITFLAG
 10737 0000231F CD21                    		int	21h		; Get input line
 10738 00002321 31C9                    		xor	cx,cx
 10739 00002323 E85800                  		call	SETINITFLAG
 10740 00002326 E845F6                  		call	CRLF2
 10741 00002329 BE[D240]                		mov	si,COMBUF+2
 10742 0000232C 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10743 0000232F 74D9                    		jz	short P_TSEP_JRETN
 10744                                  
 10745                                  ; =============== S U B	R O U T	I N E =======================================
 10746                                  
 10747                                  INLINE:
 10748 00002331 E81900                  		call	GETNUM		; Get one or two digit number
 10749 00002334 7301                    		jnb	short INLINE1
 10750 00002336 C3                      		retn
 10751                                  INLINE1:
 10752 00002337 88E6                    		mov	dh,ah		; Put in position
 10753 00002339 AC                      		lodsb
 10754 0000233A 38D8                    		cmp	al,bl
 10755 0000233C 7409                    		jz	short NEXT
 10756 0000233E 38F8                    		cmp	al,bh
 10757 00002340 7405                    		jz	short NEXT
 10758 00002342 4E                      		dec	si		; Clears zero flag
 10759 00002343 F8                      		clc
 10760 00002344 B200                    		mov	dl,0
 10761 00002346 C3                      		retn			; Time may have only an hour specified
 10762                                  NEXT:
 10763 00002347 E80300                  		call	GETNUM
 10764 0000234A 88E2                    		mov	dl,ah		; Put in position
 10765                                  INLINE_RETN:
 10766 0000234C C3                      		retn
 10767                                  
 10768                                  ;============================================================================
 10769                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10770                                  ;============================================================================
 10771                                  ; 05/10/2018 - Retro DOS v3.0
 10772                                  
 10773                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10774                                  
 10775                                  ; =============== S U B	R O U T	I N E =======================================
 10776                                  
 10777                                  GETNUM:
 10778 0000234D E81000                  		call	INDIG
 10779 00002350 72FA                    		jb	short INLINE_RETN
 10780 00002352 88C4                    		mov	ah,al		; Save first digit
 10781 00002354 E80900                  		call	INDIG		; Another digit?
 10782 00002357 7204                    		jb	short OKRET
 10783 00002359 D50A                    		aad			; Convert unpacked BCD to decimal
 10784 0000235B 88C4                    		mov	ah,al
 10785                                  OKRET:
 10786 0000235D 0C01                    		or	al,1
 10787                                  GETNUM_RETN:
 10788 0000235F C3                      		retn
 10789                                  
 10790                                  ; =============== S U B	R O U T	I N E =======================================
 10791                                  
 10792                                  INDIG:
 10793 00002360 8A04                    		mov	al,[si]
 10794 00002362 2C30                    		sub	al,'0'
 10795 00002364 72F9                    		jc	short GETNUM_RETN
 10796 00002366 3C0A                    		cmp	al,10
 10797 00002368 F5                      		cmc
 10798 00002369 72F4                    		jc	short GETNUM_RETN
 10799 0000236B 46                      		inc	si
 10800 0000236C C3                      		retn
 10801                                  
 10802                                  ; =============== S U B	R O U T	I N E =======================================
 10803                                  
 10804                                  OUT2:					; Output binary number as two ASCII digits
 10805 0000236D D40A                    		aam			; Convert binary to unpacked BCD
 10806 0000236F 86C4                    		xchg	al,ah
 10807 00002371 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10808 00002374 3C30                    		cmp	al,'0'		; Is MSD zero?
 10809 00002376 7502                    		jnz	short NOSUP
 10810 00002378 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10811                                  NOSUP:
 10812 0000237A B700                    		mov	bh,0		; Disable zero suppression
 10813 0000237C AB                      		stosw
 10814 0000237D C3                      		retn
 10815                                  
 10816                                  ; ---------------------------------------------------------------------------
 10817                                  		;stosb
 10818                                  		;retn
 10819                                  
 10820                                  ;============================================================================
 10821                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10822                                  ;============================================================================
 10823                                  ; 03/10/2018 - Retro DOS v3.0
 10824                                  
 10825                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10826                                  
 10827                                  ; =============== S U B	R O U T	I N E =======================================
 10828                                  
 10829                                  ; Set the special flag in the INIT flag to the value in CX.
 10830                                  
 10831                                  SETINITFLAG:
 10832 0000237E 8E1E[7142]              		mov	ds,[RESSEG]
 10833                                  		;and	byte [INITFLAG],0FDh
 10834 00002382 8026590CFD              		and	byte [INITFLAG],~INITSPECIAL
 10835 00002387 080E590C                		or	byte [INITFLAG],cl
 10836 0000238B 0E                      		push	cs
 10837 0000238C 1F                      		pop	ds
 10838 0000238D C3                      		retn
 10839                                  
 10840                                  ; =============== S U B	R O U T	I N E =======================================
 10841                                  
 10842                                  PIPEOFF:
 10843 0000238E 1E                      		push	ds
 10844 0000238F 50                      		push	ax
 10845 00002390 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
 10846 00002395 30C0                    		xor	al,al
 10847 00002397 86065A0C                		xchg	al,byte [PIPEFLAG]
 10848 0000239B 08C0                    		or	al,al
 10849 0000239D 7404                    		jz	short PIPEOFFDONE
 10850 0000239F D02EED0B                		shr	byte [ECHOFLAG],1
 10851                                  PIPEOFFDONE:
 10852 000023A3 58                      		pop	ax
 10853 000023A4 1F                      		pop	ds
 10854 000023A5 C3                      		retn
 10855                                  
 10856                                  ; ---------------------------------------------------------------------------
 10857                                  		;db    0,0,0,0,0
 10858                                  		;times 5 db 0
 10859 000023A6 90<rept>                align 16
 10860                                  
 10861                                  ;============================================================================
 10862                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 10863                                  ;============================================================================
 10864                                  ; 03/10/2018 - Retro DOS v3.0
 10865                                  
 10866                                  ;----------------------------------------------------------------------------
 10867                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 10868                                  ; argv[argvcnt] array. The most important difference between this array and
 10869                                  ; the tradition UNIX format is the extra cparse information included with
 10870                                  ; each argument element.
 10871                                  ;---------------
 10872                                  ; ENTRY:
 10873                                  ;	BL	     special delimiter for cparse -- not implemented)
 10874                                  ;---------------
 10875                                  ; EXIT:
 10876                                  ;	CF	    set if error
 10877                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 10878                                  ;	argv[]	    array of cparse flags and pointers to arguments
 10879                                  ;	argvcnt     argument count
 10880                                  ;---------------
 10881                                  ; NOTE(S):
 10882                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 10883                                  ;	*   Parseflags record contains cparse flags, as follows:
 10884                                  ;		sw_flag 	--	was this arg a switch?
 10885                                  ;		wildcard	--	whether or not it contained a * or ?
 10886                                  ;		path_sep	--	maybe it was a pathname
 10887                                  ;		unused		--	for future expansion
 10888                                  ;		special_delim	--	was there an initial special delimiter?
 10889                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 10890                                  ;	*   Relationship between input, cparse output, and comtail can be
 10891                                  ;	    found in the following chart.  Despite the claim of the cparse
 10892                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 10893                                  ;	    tokens", such is not the case (see column two, row two).
 10894                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 10895                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 10896                                  ;	    STARTEL addresses) will be null. This is clearly just a
 10897                                  ;	    documentation error.
 10898                                  ;	*   cparse also returns a switch code in BP for each switch it
 10899                                  ;	    recognizes on the command line.
 10900                                  ;	*   arglen for each token does NOT include the terminating null.
 10901                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 10902                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 10903                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 10904                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 10905                                  ;	    line parsing may result in slightly different behavior than
 10906                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 10907                                  ;
 10908                                  ;	    Input		    Cparse		Command Line (80H)
 10909                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 10910                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 10911                                  ;	foo.bat 		foo.bat 		foo.bat
 10912                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 10913                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 10914                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 10915                                  
 10916                                  ; =============== S U B	R O U T	I N E =======================================
 10917                                  
 10918                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 10919                                  
 10920                                  PARSELINE:
 10921 000023B0 50                      		push	ax			; most of these are clobbered
 10922 000023B1 53                      		push	bx			; by cparse...
 10923 000023B2 51                      		push	cx
 10924 000023B3 52                      		push	dx
 10925 000023B4 57                      		push	di
 10926 000023B5 56                      		push	si
 10927 000023B6 9C                      		pushf
 10928 000023B7 C606[5644]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 10929 000023BC C706[6F4B]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 10930 000023C2 31C0                    		xor	ax,ax
 10931                                  		;mov	cx,1348
 10932 000023C4 B94405                  		mov	cx,ARG_UNIT.SIZE
 10933 000023C7 BF[A945]                		mov	di,ARG
 10934 000023CA F3AA                    		rep stosb
 10935                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 10936 000023CC C706[ED4A][6D48]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 10937                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 10938 000023D2 C706[6B48]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 10939                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 10940 000023D8 C706[6948]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 10941 000023DE BE[D240]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 10942                                  
 10943                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 10944                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 10945                                  ; otherwise. This is done so that commands can get arg pointers into their
 10946                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 10947                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 10948                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 10949                                  ; the command to be repeated or the transient part of command has been
 10950                                  ; reloaded.
 10951                                  
 10952 000023E1 1E                      		push	ds
 10953 000023E2 8E1E[7142]              		mov	ds,[RESSEG]
 10954 000023E6 803EF90B00              		cmp	byte [FORFLAG],0
 10955 000023EB 1F                      		pop	ds
 10956 000023EC 7510                    		jnz	short PCONT
 10957                                  		;mov	di,ARG_ARGFORCOMBUF
 10958 000023EE BF[6D4A]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 10959 000023F1 30ED                    		xor	ch,ch
 10960 000023F3 8A0E[D140]              		mov	cl,[COMBUF+1]
 10961 000023F7 FEC1                    		inc	cl
 10962 000023F9 F3A4                    		rep movsb
 10963                                  		;mov	si,ARG_ARGFORCOMBUF
 10964 000023FB BE[6D4A]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 10965                                  PCONT:
 10966 000023FE BF[EF4A]                		mov	di,TPBUF	; destination is temporary token buffer	
 10967 00002401 B320                    		mov	bl,' '		; no special delimiter, for now
 10968                                  PARSELOOP:
 10969 00002403 8936[714B]              		mov	[COMPTR],si	; save ptr into original command buffer
 10970 00002407 31ED                    		xor	bp,bp		; switch information put here by cparse
 10971 00002409 C606[A745]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 10972 0000240E E86AF5                  		call	SCANOFF		; skip leading blanks...
 10973 00002411 E8000F                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 10974 00002414 7309                    		jnb	short MORE_PRSE
 10975 00002416 09ED                    		or	bp,bp		; Check for trailing switch character
 10976 00002418 7411                    		jz	short PARSEDONE
 10977 0000241A E81B00                  		call	NEWARG		; We hit CR but BP is non-zero. The
 10978                                  					;   typical cause of this is that a
 10979                                  					;   switch char IMMEDIATELY preceeds
 10980                                  					;   the CR. We have an argument, but it
 10981                                  					;   is sort of an error.
 10982 0000241D EB0C                    		jmp	short PARSEDONE	; We're done (found the CR).
 10983                                  
 10984                                  MORE_PRSE:
 10985 0000241F C606[5644]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 10986 00002424 E81100                  		call	NEWARG		; add to argv array (CX has char count)
 10987 00002427 73DA                    		jnb	short PARSELOOP	; was everything OK?
 10988 00002429 EB04                    		jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 10989                                  
 10990                                  PARSEDONE:
 10991 0000242B 9D                      		popf
 10992 0000242C F8                      		clc
 10993 0000242D EB02                    		jmp	short PARSE_EXIT
 10994                                  
 10995                                  PARSE_ERROR:				; error entry (er, exit) point
 10996 0000242F 9D                      		popf
 10997 00002430 F9                      		stc
 10998                                  PARSE_EXIT:				; depend on not changing CF
 10999 00002431 5E                      		pop	si
 11000 00002432 5F                      		pop	di
 11001 00002433 5A                      		pop	dx
 11002 00002434 59                      		pop	cx
 11003 00002435 5B                      		pop	bx
 11004 00002436 58                      		pop	ax
 11005 00002437 C3                      		retn
 11006                                  
 11007                                  ; =============== S U B	R O U T	I N E =======================================
 11008                                  
 11009                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11010                                  ;
 11011                                  ; ENTRY:
 11012                                  ;   BH			argflags
 11013                                  ;   CX			character count in argstring
 11014                                  ;   DI			pointer to argstring
 11015                                  ;   comptr		ptr to starting loc of current token in original command
 11016                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11017                                  ; EXIT:
 11018                                  ;   argbufptr		points to next free section of argbuffer
 11019                                  ;   arg.argbuf		contains null-terminated argument strings
 11020                                  ;   arg.argvcnt 	argument count
 11021                                  ;   arg.argv[]		array of flags and pointers
 11022                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11023                                  ;   CF			set if error
 11024                                  ;   AL			carry set:  error code; otherwise, zero
 11025                                  
 11026                                  NEWARG:
 11027 00002438 53                      		push	bx
 11028 00002439 51                      		push	cx
 11029 0000243A 52                      		push	dx
 11030 0000243B 57                      		push	di
 11031 0000243C 56                      		push	si
 11032 0000243D 9C                      		pushf
 11033 0000243E E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11034                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11035                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11036                                  
 11037                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11038 00002441 833E[6948]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11039 00002446 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11040 00002448 88FE                    		mov	dh,bh			
 11041                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11042 0000244A 8B1E[6948]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11043                                  		;inc	word [ARG_ARGVCNT]
 11044 0000244E FF06[6948]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11045                                  		;mov	ax,ARG_ARGV
 11046 00002452 B8[A945]                		mov	ax,ARG+ARG_UNIT.argv
 11047 00002455 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11048                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11049                                  		;mov	word [bx+7],0
 11050 00002458 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11051                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11052                                  		;mov	[bx+5],cx
 11053 0000245D 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11054                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11055                                  		;mov	[bx+2],dh
 11056 00002460 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11057 00002463 8B36[ED4A]              		mov	si,[ARGBUFPTR]
 11058                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11059                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11060 00002467 8937                    		mov	[bx],si			
 11061 00002469 0336[9745]              		add	si,[STARTEL]		; save startel from new location
 11062 0000246D 29FE                    		sub	si,di			; form pointer into argbuf
 11063                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11064                                  		;mov	[bx+3],si
 11065 0000246F 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11066 00002472 8B36[714B]              		mov	si,[COMPTR]
 11067                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11068                                  		;mov	[bx+9],si
 11069 00002476 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11070                                  
 11071 00002479 89FE                    		mov	si,di			; now save argstring in argbuffer
 11072 0000247B 8B3E[ED4A]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11073 0000247F 01CF                    		add	di,cx			; sure we're not about to run off
 11074                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11075                                  		;cmp	di,ARG_ARGBUF+255
 11076 00002481 81FF[6C49]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11077 00002485 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11078 00002487 29CF                    		sub	di,cx
 11079 00002489 FC                      		cld
 11080 0000248A F3A4                    		rep movsb
 11081 0000248C B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11082 0000248E AA                      		stosb
 11083 0000248F 893E[ED4A]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11084                                  
 11085                                  NEWARG_DONE:
 11086 00002493 9D                      		popf
 11087 00002494 F8                      		clc
 11088 00002495 EB0A                    		jmp	short NEWARG_EXIT
 11089                                  
 11090                                  TO_MANY_ARGS:
 11091 00002497 B80100                  		mov	ax,1
 11092 0000249A EB03                    		jmp	short NEWARG_ERROR
 11093                                  
 11094                                  BUF_OVFLOW:
 11095 0000249C B80200                  		mov	ax,2
 11096                                  NEWARG_ERROR:
 11097 0000249F 9D                      		popf
 11098 000024A0 F9                      		stc
 11099                                  NEWARG_EXIT:
 11100 000024A1 5E                      		pop	si
 11101 000024A2 5F                      		pop	di
 11102 000024A3 5A                      		pop	dx
 11103 000024A4 59                      		pop	cx
 11104 000024A5 5B                      		pop	bx
 11105 000024A6 C3                      		retn
 11106                                  
 11107                                  ; =============== S U B	R O U T	I N E =======================================
 11108                                  
 11109                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11110                                  ; event that it is, and we can recognize
 11111                                  ;
 11112                                  ; ENTRY:
 11113                                  ;   As in <newarg>.
 11114                                  ; EXIT:
 11115                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11116                                  ; NOTE(S):
 11117                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11118                                  ;	on the order of definition in the <switch_list> variable and the
 11119                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11120                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11121                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11122                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11123                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11124                                  ;   *	An ugly routine.
 11125                                  
 11126                                  ARG_SWITCH:
 11127 000024A7 50                      		push	ax
 11128 000024A8 53                      		push	bx
 11129 000024A9 51                      		push	cx
 11130 000024AA 57                      		push	di
 11131 000024AB 9C                      		pushf
 11132 000024AC F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11133 000024AF 741C                    		jz	short ARG_NO_SWITCH0
 11134 000024B1 833E[6F4B]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11135 000024B6 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11136 000024B8 8B1E[6F4B]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11137                                  		;mov	ax,offset TRANGROUP:arg.argv
 11138                                  		;mov	ax,ARG_ARGV
 11139 000024BC B8[A945]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11140 000024BF E81800                  		call	ARGV_CALC
 11141                                  		;or	[BX].argsw_word,BP
 11142                                  		;or	[bx+7],bp
 11143 000024C2 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11144                                  		;or	arg.argswinfo,BP
 11145                                  		;or	[ARG_ARGSWINFO],bp
 11146 000024C5 092E[6B48]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11147                                  ARG_YES_SWITCH:
 11148 000024C9 9D                      		popf
 11149 000024CA F9                      		stc
 11150 000024CB EB08                    		jmp	short ARG_SWITCH_EXIT
 11151                                  
 11152                                  ARG_NO_SWITCH0:
 11153                                  		;mov	ax,[ARG_ARGVCNT]
 11154 000024CD A1[6948]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11155 000024D0 A3[6F4B]                		mov	[LASTARG],ax
 11156                                  ARG_NO_SWITCH1:
 11157 000024D3 9D                      		popf
 11158 000024D4 F8                      		clc
 11159                                  ARG_SWITCH_EXIT:
 11160 000024D5 5F                      		pop	di
 11161 000024D6 59                      		pop	cx
 11162 000024D7 5B                      		pop	bx
 11163 000024D8 58                      		pop	ax
 11164 000024D9 C3                      		retn
 11165                                  
 11166                                  ; =============== S U B	R O U T	I N E =======================================
 11167                                  
 11168                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11169                                  ; the supplied array.  Method used for computing the address is:
 11170                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11171                                  ; ENTRY:
 11172                                  ;   AX	    --	    base of array
 11173                                  ;   BX	    --	    array index
 11174                                  ; EXIT:
 11175                                  ;   BX	    --	    byte offset
 11176                                  
 11177                                  ARGV_CALC:
 11178 000024DA 50                      		push	ax		; Save base
 11179 000024DB 88D8                    		mov	al,bl		; al = array index
 11180                                  		;mov	bl,11
 11181 000024DD B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11182 000024DF F6E3                    		mul	bl		; ax = base offset
 11183 000024E1 5B                      		pop	bx		; Get base
 11184 000024E2 01D8                    		add	ax,bx		; Add in base offset
 11185 000024E4 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11186 000024E5 C3                      		retn
 11187                                  
 11188                                  ; ---------------------------------------------------------------------------
 11189                                  	
 11190                                  		;db 0Ah dup(0)
 11191                                  		;times 10 db 0
 11192 000024E6 90<rept>                align 16
 11193                                  
 11194                                  ;============================================================================
 11195                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11196                                  ;============================================================================
 11197                                  ; 03/10/2018 - Retro DOS v3.0
 11198                                  
 11199                                  ;----------------------------------------------------------------------------
 11200                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11201                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11202                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11203                                  ;    file on disk. Directories specified in the user's search path will be
 11204                                  ;    searched for a matching file, if a match is not found in the current
 11205                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11206                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11207                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11208                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11209                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11210                                  ;    (easily) modified to make no assumptions about where its input is found.
 11211                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11212                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11213                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11214                                  ;    else that wants to save the whole shebang and then process other command
 11215                                  ;    lines.
 11216                                  ;
 11217                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11218                                  ;
 11219                                  ; ENTRY:
 11220                                  ;   <Path_Search>:	    argv[0].
 11221                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11222                                  ; EXIT:
 11223                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11224                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11225                                  ; NOTE(S):
 11226                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11227                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11228                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11229                                  ;	does not function as specified; see <Parseline> for more details.
 11230                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11231                                  ;	need to know about. This extra information is stored in a switch_flag
 11232                                  ;	word with each command-line argument; the switches themselves will not
 11233                                  ;	appear in the resulting arg structure.
 11234                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11235                                  ;----------------------------------------------------------------------------
 11236                                  
 11237                                  ; =============== S U B	R O U T	I N E =======================================
 11238                                  
 11239                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11240                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11241                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11242                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11243                                  ; have a match, either in the current working directory if we were handed
 11244                                  ; a filename, or in the specified directory, given a pathname. If this call
 11245                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11246                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11247                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11248                                  ; either the first invocation of search or on one of the succeeding calls
 11249                                  ; sets up the appropriate information for copying the successful pathname
 11250                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11251                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11252                                  ;
 11253                                  ; ENTRY:
 11254                                  ;   argv[0]		--	command name and associated information
 11255                                  ; EXIT:
 11256                                  ;   AX			--	non-zero indicates type of file found
 11257                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11258                                  ; NOTE(S):
 11259                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11260                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11261                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11262                                  ;	if search returns an .exe or .bat.
 11263                                  ;   5)	Clobbers dma address.
 11264                                  
 11265                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11266                                  PATH_SEP_CHAR	EQU	';'
 11267                                  
 11268                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11269                                  
 11270                                  		;special_delim equ 128
 11271                                  		;path_sep equ 4
 11272                                  		;wildcard equ 2
 11273                                  		;sw_flag  equ 1
 11274                                  
 11275                                  ;----------------------------------------------------------------------------
 11276                                  
 11277                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11278                                  
 11279                                  PATH_SEARCH:
 11280 000024F0 53                      		push	bx
 11281 000024F1 51                      		push	cx
 11282 000024F2 52                      		push	dx		; could use a "stack 'em" instruction
 11283 000024F3 56                      		push	si
 11284 000024F4 57                      		push	di
 11285 000024F5 55                      		push	bp
 11286 000024F6 9C                      		pushf
 11287                                  
 11288                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11289                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11290 000024F7 F606[AB45]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11291 000024FC 7403                    		jz	short PATH_SEARCH_OK
 11292                                  
 11293                                  PATH_FAILURE_JMP:
 11294 000024FE E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11295                                  
 11296                                  PATH_SEARCH_OK:
 11297 00002501 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11298 00002504 BA[734B]                		mov	dx,FBUF		; clobber old dma value with
 11299 00002507 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11300 0000250A CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11301                                  				; DS:DX	-> disk	transfer buffer
 11302 0000250C 06                      		push	es
 11303 0000250D E87FF2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11304 00002510 8C06[9E4B]              		mov	[PATHINFO+0],es	; and squirrel it away
 11305 00002514 893E[A04B]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11306 00002518 893E[A24B]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11307 0000251C 07                      		pop	es
 11308                                  		
 11309 0000251D BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11310 00002520 BE[9941]                		mov	si,EXECPATH
 11311 00002523 E84B02                  		call	STRIP
 11312 00002526 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11313                                  		
 11314 00002528 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11315 0000252A C706[F34B][4939]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11316 00002530 E88301                  		call	PSEARCH		; must do at least one search
 11317 00002533 09C0                    		or	ax,ax		; find anything?
 11318 00002535 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11319                                  		
 11320 00002537 89C5                    		mov	bp,ax		; success... save filetype code	
 11321 00002539 BF[9941]                		mov	di,EXECPATH
 11322                                  		;mov	si,ds:arg.argv[0].argpointer
 11323                                  		;mov	si,[ARG_ARGV]
 11324 0000253C 8B36[A945]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11325                                  		;mov	cx,ds:arg.argv[0].argstartel
 11326                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11327 00002540 8B0E[AC45]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11328 00002544 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11329                                  
 11330                                  ; We have the number of bytes in the prefix (up to the final component).
 11331                                  ; We need to form the complete pathname including leading drive and current
 11332                                  ; directory.
 11333                                  ;
 11334                                  ; Is there a drive letter present?
 11335                                  
 11336 00002546 B43A                    		mov	ah,':'
 11337 00002548 83F902                  		cmp	cx,2		; room for drive letter?
 11338 0000254B 7205                    		jb	short ADDDRIVE	; no, stick it in
 11339 0000254D 386401                  		cmp	[si+1],	ah	; colon present?
 11340 00002550 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11341                                  ADDDRIVE:
 11342 00002552 A0[8542]                		mov	al,[CURDRV]	; get current drive
 11343 00002555 0441                    		add	al,'A'		; convert to uppercase letter
 11344 00002557 AB                      		stosw			; store d:
 11345 00002558 EB05                    		jmp	short CHECKPATH
 11346                                  
 11347                                  MOVEDRIVE:
 11348 0000255A AD                      		lodsw			; move d:
 11349 0000255B AB                      		stosw
 11350 0000255C 83E902                  		sub	cx,2		; 2 bytes less to move
 11351                                  CHECKPATH:
 11352 0000255F 0C20                    		or	al,20h
 11353 00002561 88C2                    		mov	dl,al		
 11354                                  		;sub	dl,60h
 11355 00002563 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11356                                  
 11357                                  ; Stick in beginning path char
 11358                                  
 11359 00002566 A0[A44B]                		mov	al,[PSEP_CHAR]
 11360 00002569 AA                      		stosb
 11361                                  
 11362                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11363                                  ; Otherwise, get current dir for DL.
 11364                                  
 11365 0000256A 83F901                  		cmp	cx,1		; is there room for path char?
 11366 0000256D 720A                    		jb	short ADDPATH	; no, go add path
 11367 0000256F AC                      		lodsb
 11368 00002570 49                      		dec	cx
 11369 00002571 3A06[A44B]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11370 00002575 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11371 00002577 41                      		inc	cx
 11372 00002578 4E                      		dec	si		; undo the lodsb
 11373                                  ADDPATH:
 11374 00002579 56                      		push	si
 11375 0000257A 89FE                    		mov	si,di		; remainder of buffer
 11376 0000257C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11377 0000257F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11378                                  				; DL = drive (0=default,1=A,etc.)
 11379                                  				; DS:SI	points to 64-byte buffer area
 11380                                  
 11381                                  ; The previous current dir will succeed a previous find_first already worked.
 11382                                  ;
 11383                                  ; Find end of string.
 11384                                  
 11385 00002581 89F7                    		mov	di,si
 11386 00002583 5E                      		pop	si
 11387 00002584 A0[A44B]                		mov	al,[PSEP_CHAR]
 11388 00002587 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11389 0000258A 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11390                                  SCANEND:
 11391 0000258C 803D00                  		cmp	byte [di],0	; end of string?
 11392 0000258F 7403                    		jz	short FOUNDEND
 11393 00002591 47                      		inc	di
 11394 00002592 EBF8                    		jmp	short SCANEND
 11395                                  
 11396                                  ; Stick in a trailing path char.
 11397                                  
 11398                                  FOUNDEND:
 11399 00002594 AA                      		stosb
 11400                                  
 11401                                  ; Move remaining part of path.	Skip leading path char if present.
 11402                                  
 11403                                  MOVEPATH:
 11404 00002595 3804                    		cmp	[si],al		; first char a path char?
 11405 00002597 7502                    		jnz	short COPYPATH
 11406 00002599 46                      		inc	si		; move past leading char
 11407 0000259A 49                      		dec	cx		; drop from count
 11408                                  COPYPATH:
 11409 0000259B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11410 0000259D F3A4                    		rep movsb
 11411                                  _COPYDONE:
 11412 0000259F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11413                                  
 11414                                  PATH_NOINIT:
 11415                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11416                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11417 000025A2 F606[AB45]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11418 000025A7 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11419                                  		;mov	bh,';'
 11420 000025A9 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11421                                  		;mov	dx,ds:arg.argv[0].argstartel
 11422                                  					; this is where the last element starts
 11423                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11424 000025AB 8B16[AC45]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11425                                  		;sub	dx,ds:arg.argv[0].argpointer
 11426                                  					; form pointer into EXECPATH,
 11427                                  		;sub	dx,[ARG_ARGV]
 11428 000025AF 2B16[A945]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11429 000025B3 81C2[9941]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11430                                  PATH_LOOP:
 11431 000025B7 E89A00                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11432 000025BA 89C5                    		mov	bp,ax		; save filetype code
 11433 000025BC 9F                      		lahf			; save flags, just in case
 11434 000025BD 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11435 000025BF 7507                    		jnz	short PATH_FOUND 
 11436 000025C1 9E                      		sahf			; see?	needed those flags, after all!
 11437 000025C2 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11438                                  PATH_FAILURE:
 11439 000025C4 31C0                    		xor	ax,ax
 11440 000025C6 EB70                    		jmp	short PATH_EXIT
 11441                                  
 11442                                  PATH_FOUND:				; pathinfo[] points to winner
 11443 000025C8 BF[9941]                		mov	di,EXECPATH
 11444                                  		;mov	cx,pathinfo[4] 
 11445 000025CB 8B0E[A24B]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11446                                  		;mov	SI,pathinfo[2]
 11447 000025CF 8B36[A04B]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11448                                  
 11449                                  ;	BAS Nov 20/84
 11450                                  ;   Look at the pathname and expand . and .. if they are the first element
 11451                                  ;   in the pathname (after the drive letter)
 11452                                  
 11453 000025D3 06                      		push	es
 11454                                  		;push	pathinfo[0]
 11455 000025D4 FF36[9E4B]              		push	word [PATHINFO+0]
 11456 000025D8 07                      		pop	es
 11457                                  ;SR;
 11458                                  ; Oops! Gets fooled if path= \;..
 11459                                  ; We should also check if a drive letter is really present
 11460                                  ;
 11461 000025D9 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11462 000025DE 7534                    		jnz	short PATH_CPY
 11463                                  
 11464                                  		; MSDOS 6.0
 11465                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11466                                  		;jnz	path_cpy	       ;no, copy the path string
 11467                                  
 11468 000025E0 51                      		push	cx		; Save pointer to end of string
 11469 000025E1 268A04                  		mov	al,[es:si]
 11470 000025E4 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11471 000025E6 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11472 000025EA 884501                  		mov	[di+1],al
 11473 000025ED A0[A44B]                		mov	al,[PSEP_CHAR]
 11474 000025F0 884502                  		mov	[di+2],	al
 11475 000025F3 56                      		push	si		; Save pointer to begining of string
 11476 000025F4 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11477 000025F7 80CA20                  		or	dl,20h
 11478                                  		;sub	dl,60h
 11479 000025FA 80EA60                  		sub	dl,'a'-1
 11480 000025FD 89FE                    		mov	si,di		; pointer to EXECPATH
 11481 000025FF 83C603                  		add	si,3		; Don't wipe out drive and root info
 11482 00002602 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11483 00002605 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11484                                  				; DL = drive (0=default,1=A,etc.)
 11485                                  				; DS:SI	points to 64-byte buffer area
 11486 00002607 E8B4F8                  		call	DSTRLEN		; Determine length of present info
 11487 0000260A 01CE                    		add	si,cx		; Don't copy over drive and root info
 11488 0000260C 4E                      		dec	si
 11489 0000260D 89F7                    		mov	di,si		; Point to end of target string
 11490 0000260F 5E                      		pop	si		; Restore pointer to begining of string
 11491 00002610 83C603                  		add	si,3		; Point past drive letter, :, .
 11492 00002613 59                      		pop	cx		; Restore pointer to end of string
 11493                                  PATH_CPY:
 11494 00002614 07                      		pop	es
 11495 00002615 29F1                    		sub	cx,si		; yields character count
 11496 00002617 1E                      		push	ds		; time to switch segments
 11497 00002618 FF36[9E4B]              		push	word [PATHINFO+0] ; string lives in this segment
 11498 0000261C 1F                      		pop	ds
 11499 0000261D FC                      		cld
 11500 0000261E F3A4                    		rep movsb
 11501 00002620 1F                      		pop	ds		; return to our segment
 11502 00002621 4F                      		dec	di		; overwrite terminator
 11503 00002622 A0[A44B]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11504 00002625 3A45FF                  		cmp	al,[di-1]
 11505 00002628 7401                    		jz	short PATH_SUCCESS
 11506 0000262A AA                      		stosb
 11507                                  PATH_SUCCESS:
 11508 0000262B BE[A64B]                		mov	si,SEARCH_BEST_BUF
 11509 0000262E 31C9                    		xor	cx,cx
 11510                                  PATH_SUCC_LOOP:
 11511 00002630 AC                      		lodsb			; append winning filename to path
 11512 00002631 AA                      		stosb			; (including terminating null)	
 11513 00002632 08C0                    		or	al,al
 11514 00002634 75FA                    		jnz	short PATH_SUCC_LOOP
 11515 00002636 89E8                    		mov	ax,bp		; retrieve filetype code
 11516                                  PATH_EXIT:
 11517 00002638 9D                      		popf
 11518 00002639 5D                      		pop	bp
 11519 0000263A 5F                      		pop	di
 11520 0000263B 5E                      		pop	si		; chill out...
 11521 0000263C 5A                      		pop	dx
 11522 0000263D 59                      		pop	cx
 11523 0000263E 5B                      		pop	bx
 11524 0000263F C3                      		retn
 11525                                  
 11526                                  
 11527                                  ; =============== S U B	R O U T	I N E =======================================
 11528                                  
 11529                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11530                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11531                                  ;
 11532                                  ; ENTRY:
 11533                                  ; EXIT:
 11534                                  ; NOTE(S):
 11535                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11536                                  
 11537                                  STORE_PCHAR:
 11538 00002640 50                      		push	ax
 11539 00002641 B02F                    		mov	al,'/'		; is the pathname-element separator
 11540 00002643 E8C8F3                  		call	PATHCHRCMP	; a regular slash?
 11541 00002646 7407                    		jz	short STORE_SLASH ; if yes, remember slash
 11542 00002648 B05C                    		mov	al,'\'
 11543 0000264A A2[A44B]                		mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11544 0000264D 58                      		pop	ax
 11545 0000264E C3                      		retn
 11546                                  STORE_SLASH:
 11547 0000264F A2[A44B]                		mov	[PSEP_CHAR],al
 11548 00002652 58                      		pop	ax
 11549 00002653 C3                      		retn
 11550                                  
 11551                                  ; =============== S U B	R O U T	I N E =======================================
 11552                                  
 11553                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11554                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11555                                  ; additional separator to use for breaking up the path-string. Null is the
 11556                                  ; default. Once the user-string has been formed, search is invoked to see
 11557                                  ; what's out there.
 11558                                  ;
 11559                                  ; ENTRY:
 11560                                  ;   BH			--	additional terminator character
 11561                                  ;   SI			--	pointer into pathstring to be dissected
 11562                                  ;   DX			--	pointer to stripped filename
 11563                                  ; EXIT:
 11564                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11565                                  ;   SI			--	moves along pathstring from call to call
 11566                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11567                                  ;   [tpbuf]		--	clobbered
 11568                                  ; NOTE(S):
 11569                                  ;   *	Implicit in this code is the ability to specify when to search
 11570                                  ;	the current directory (if at all) through the PATH defined by
 11571                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11572                                  ;	current directory before the bin and etc directories of drive c).
 11573                                  
 11574                                  PATH_CRUNCH:
 11575 00002654 53                      		push	bx
 11576 00002655 51                      		push	cx
 11577 00002656 52                      		push	dx
 11578 00002657 57                      		push	di
 11579 00002658 56                      		push	si
 11580 00002659 9C                      		pushf
 11581 0000265A E8E3FF                  		call	STORE_PCHAR	; figure out pathname separator
 11582 0000265D BF[EF4A]                		mov	di,TPBUF	; destination of concatenated string
 11583 00002660 8B36[A24B]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11584 00002664 8936[A04B]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11585 00002668 1E                      		push	ds		; save old segment pointer
 11586 00002669 FF36[9E4B]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11587 0000266D 1F                      		pop	ds		; segment		
 11588                                  PATH_CR_COPY:
 11589 0000266E AC                      		lodsb			; get a pathname byte
 11590 0000266F 08C0                    		or	al,al		; check for terminator(s)
 11591 00002671 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11592 00002673 38F8                    		cmp	al,bh
 11593 00002675 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11594 00002677 AA                      		stosb
 11595 00002678 EBF4                    		jmp	short PATH_CR_COPY
 11596                                  
 11597                                  PATH_SEG:
 11598 0000267A 1F                      		pop	ds		; restore old data segment
 11599 0000267B 8936[A24B]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11600 0000267F 88C3                    		mov	bl,al		; remember if we saw null or not...
 11601                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11602 00002681 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11603 00002683 81FF[EF4A]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11604 00002687 741D                    		jz	short PATH_CR_LEAVE 
 11605                                  					; if nothing was copied, pathstr empty
 11606                                  PATH_CR_LOOK:
 11607 00002689 A0[A44B]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11608 0000268C 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11609 0000268F 7401                    		jz	short PATH_CR_L1
 11610 00002691 AA                      		stosb
 11611                                  PATH_CR_L1:
 11612 00002692 89D6                    		mov	si,dx
 11613                                  PATH_CR_L2:
 11614 00002694 AC                      		lodsb			; tack the stripped filename onto
 11615 00002695 AA                      		stosb			; the end of the path, up to and
 11616 00002696 08C0                    		or	al,al		; including the terminating null
 11617 00002698 75FA                    		jnz	short PATH_CR_L2
 11618 0000269A BA[EF4A]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11619 0000269D C706[F34B][403C]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11620                                  		;invoke search
 11621 000026A3 E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11622                                  
 11623                                  PATH_CR_LEAVE:
 11624 000026A6 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11625 000026A8 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11626 000026AA 9D                      		popf			; otherwise, plenty left
 11627 000026AB F8                      		clc
 11628 000026AC EB02                    		jmp	short PATH_CR_EXIT
 11629                                  
 11630                                  PATH_CR_EMPTY:
 11631 000026AE 9D                      		popf
 11632 000026AF F9                      		stc
 11633                                  PATH_CR_EXIT:
 11634 000026B0 5E                      		pop	si
 11635 000026B1 5F                      		pop	di
 11636 000026B2 5A                      		pop	dx
 11637 000026B3 59                      		pop	cx
 11638 000026B4 5B                      		pop	bx
 11639 000026B5 C3                      		retn
 11640                                  
 11641                                  ;============================================================================
 11642                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11643                                  ;============================================================================
 11644                                  ; 02/10/2018 - Retro DOS v3.0
 11645                                  
 11646                                  ;----------------------------------------------------------------------------
 11647                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11648                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11649                                  ; lowest priority). Where conflicts arise, the extension with
 11650                                  ; the highest priority is favored.
 11651                                  ; ENTRY:
 11652                                  ;   DX		--	pointer to null-terminated pathname
 11653                                  ;   fbuf	--	dma buffer for findfirst/next
 11654                                  ; EXIT:
 11655                                  ;   AX		--	8)  file found with .com extension
 11656                                  ;			4)  file found with .exe extension
 11657                                  ;			2)  file found with .bat extension
 11658                                  ;			0)  no such file to be found
 11659                                  ;   (if AX is non-zero:)
 11660                                  ;   [search_best]	identical to AX
 11661                                  ;   [search_best_buf]	null-terminated filename
 11662                                  ; NOTES:
 11663                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11664                                  ;---------------
 11665                                  ; CONSTANTS:
 11666                                  ;---------------
 11667                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11668                                  SEARCH_COM		EQU	8
 11669                                  SEARCH_EXE		EQU	4
 11670                                  SEARCH_BAT		EQU	2
 11671                                  FNAME_LEN		EQU	8
 11672                                  FNAME_MAX_LEN		EQU	13
 11673                                  DOT			EQU	'.'
 11674                                  WILDCHAR		EQU	'?'
 11675                                  
 11676                                  
 11677                                  ; =============== S U B	R O U T	I N E =======================================
 11678                                  
 11679                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11680                                  
 11681                                  PSEARCH:
 11682 000026B6 51                      		push	cx
 11683 000026B7 52                      		push	dx
 11684 000026B8 57                      		push	di
 11685 000026B9 56                      		push	si
 11686 000026BA 9C                      		pushf
 11687 000026BB 52                      		push	dx		; check drivespec (save pname ptr)
 11688 000026BC 89D7                    		mov	di,dx		; working copy of pathname
 11689 000026BE BE[B34B]                		mov	si,SEARCH_CURDIR_BUF
 11690 000026C1 31D2                    		xor	dx,dx		; zero means current drive
 11691 000026C3 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11692 000026C7 7508                    		jne	short SEARCH_DIR_CHECK
 11693 000026C9 8A15                    		mov	dl,[di]		; get the drive byte
 11694 000026CB 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11695 000026CE 80EA40                  		sub	dl,'@'		; and convert to drive number
 11696                                  SEARCH_DIR_CHECK:
 11697 000026D1 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11698 000026D4 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11699                                  				; DL = drive (0=default,1=A,etc.)
 11700                                  				; DS:SI	points to 64-byte buffer area
 11701 000026D6 5A                      		pop	dx		; directory? If we can't we'll		
 11702 000026D7 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11703 000026D9 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11704 000026DC B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11705 000026DF CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11706                                  				; CX = search attributes
 11707                                  				; DS:DX	-> ASCIZ filespec
 11708                                  				; (drive,path,	and wildcards allowed)
 11709 000026E1 723C                    		jc	short SEARCH_NO_FILE
 11710 000026E3 C606[A54B]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11711 000026E8 C606[A64B]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11712                                  SEARCH_LOOP:
 11713 000026ED E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11714 000026F0 3A06[A54B]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11715 000026F4 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11716 000026F6 A2[A54B]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11717                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11718                                  		;mov	si,FBUF_PNAME
 11719 000026F9 BE[914B]                		mov	si,FBUF+FIND_BUF.PNAME
 11720 000026FC BF[A64B]                		mov	di,SEARCH_BEST_BUF
 11721 000026FF B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11722 00002702 FC                      		cld
 11723 00002703 F3A4                    		rep movsb		; save complete pathname representation
 11724 00002705 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11725 00002707 740A                    		je	short SEARCH_DONE
 11726                                  SEARCH_NEXT:				; keep on looking
 11727 00002709 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11728 0000270C B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11729 0000270F CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11730                                  				; [DTA]	= data block from
 11731                                  				; last AH = 4Eh/4Fh call
 11732 00002711 73DA                    		jnc	short SEARCH_LOOP
 11733                                  SEARCH_DONE:				; it's all over with...
 11734 00002713 A0[A54B]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11735                                  		; MSDOS 6.0
 11736                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11737                                  		;jz	search_exit	;AN005; no - exit
 11738                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11739                                  		;mov	search_best,al	;AN005; save the real file type
 11740                                  		;
 11741 00002716 EB0A                    		jmp	short SEARCH_EXIT
 11742                                  
 11743                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11744 00002718 8B16[F34B]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11745 0000271C E8B40D                  		call	STD_PRINTF	 ; and pretend no file found
 11746                                  
 11747                                  SEARCH_NO_FILE:				; couldn't find a match
 11748 0000271F B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11749                                  
 11750                                  SEARCH_EXIT:
 11751 00002722 9D                      		popf
 11752 00002723 5E                      		pop	si
 11753 00002724 5F                      		pop	di
 11754 00002725 5A                      		pop	dx
 11755 00002726 59                      		pop	cx
 11756 00002727 C3                      		retn
 11757                                  
 11758                                  ; =============== S U B	R O U T	I N E =======================================
 11759                                  
 11760                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11761                                  ;
 11762                                  ; ENTRY:
 11763                                  ;   fbuf    --	    dma buffer containing filename
 11764                                  ; EXIT:
 11765                                  ;   AX	    --	    file code, as given in search header
 11766                                  ; NOTE(S):
 11767                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11768                                  
 11769                                  SEARCH_FTYPE:
 11770 00002728 57                      		push	di
 11771 00002729 56                      		push	si
 11772 0000272A B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11773                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11774                                  		;mov	di,FBUF_PNAME
 11775 0000272D BF[914B]                		mov	di,FBUF+FIND_BUF.PNAME
 11776 00002730 B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11777 00002733 FC                      		cld
 11778 00002734 F2AE                    		repnz scasb		; search for the terminating null
 11779 00002736 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11780 00002738 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11781                                  
 11782                                  		; Compare .COM
 11783                                  
 11784 0000273B BE[113F]                		mov	si,COMEXT ; ".COM"
 11785 0000273E 89F8                    		mov	ax,di
 11786 00002740 A7                      		cmpsw
 11787 00002741 7508                    		jnz	short FTYPE_EXE
 11788 00002743 A7                      		cmpsw
 11789 00002744 7505                    		jnz	short FTYPE_EXE
 11790                                  		;mov	ax,8
 11791 00002746 B80800                  		mov	ax,SEARCH_COM	; success!
 11792 00002749 EB23                    		jmp	short FTYPE_EXIT
 11793                                  
 11794                                  		; Compare .EXE
 11795                                  FTYPE_EXE:				; still looking... now for '.exe'
 11796 0000274B 89C7                    		mov	di,ax
 11797 0000274D BE[153F]                		mov	si,EXEEXT ; ".EXE"
 11798 00002750 A7                      		cmpsw
 11799 00002751 7508                    		jnz	short FTYPE_BAT
 11800 00002753 A7                      		cmpsw
 11801 00002754 7505                    		jnz	short FTYPE_BAT
 11802                                  		;mov	ax,4
 11803 00002756 B80400                  		mov	ax,SEARCH_EXE	; success!
 11804 00002759 EB13                    		jmp	short FTYPE_EXIT
 11805                                  
 11806                                  		; Compare .BAT
 11807                                  FTYPE_BAT:				; still looking... now for '.bat'
 11808 0000275B 89C7                    		mov	di,ax
 11809 0000275D BE[193F]                		mov	si,BATEXT ; ".BAT"
 11810 00002760 A7                      		cmpsw
 11811 00002761 7508                    		jnz	short FTYPE_FAIL
 11812 00002763 A7                      		cmpsw
 11813 00002764 7505                    		jnz	short FTYPE_FAIL
 11814                                  		;mov	ax,2
 11815 00002766 B80200                  		mov	ax,SEARCH_BAT	; success!
 11816 00002769 EB03                    		jmp	short FTYPE_EXIT
 11817                                  
 11818                                  FTYPE_FAIL:				; file doesn't match what we need
 11819 0000276B B80000                  		mov	ax,ANULL ; 0
 11820                                  
 11821                                  FTYPE_EXIT:
 11822                                  		; MSDOS 6.0
 11823                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11824                                  		;jz	ftype_done	;AN005; no - exit
 11825                                  		;cmp	ax,ANULL	;AN005; was any match found
 11826                                  		;jz	ftype_done	;AN005; no - exit
 11827                                  		;mov	ext_entered,al	;AN005; save the match type found
 11828                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11829                                  ;ftype_done:
 11830 0000276E 5E                      		pop	si
 11831 0000276F 5F                      		pop	di
 11832 00002770 C3                      		retn
 11833                                  
 11834                                  ; =============== S U B	R O U T	I N E =======================================
 11835                                  
 11836                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 11837                                  ; replacing any extension with wildcards.
 11838                                  ;
 11839                                  ; ENTRY:
 11840                                  ;	BX		--		maximum length of destination buffer
 11841                                  ;	DS:SI		--		address of destination buffer
 11842                                  ;	argv[0] 	--		command name to be stripped
 11843                                  ; EXIT:
 11844                                  ;	CF		--		set if failure, clear if successful
 11845                                  ; NOTE(S):
 11846                                  
 11847                                  
 11848                                  STRIP:
 11849 00002771 50                      		push	ax
 11850 00002772 53                      		push	bx
 11851 00002773 51                      		push	cx
 11852 00002774 52                      		push	dx
 11853 00002775 57                      		push	di
 11854 00002776 56                      		push	si
 11855 00002777 9C                      		pushf
 11856                                  		
 11857                                  		; MSDOS 6.0
 11858                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 11859                                  
 11860                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11861                                  		;mov	dx,[ARG_ARGV]
 11862                                  		;mov	dx,ds:arg.argv[0].argpointer
 11863                                  					; save pointer to beginning of argstring
 11864                                  		;mov	dx,[ARGV0_ARGPOINTER]
 11865 00002778 8B16[A945]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 11866                                  		;mov	di,ds:arg.argv[0].argstartel
 11867                                  					; beginning of last pathname element
 11868                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 11869 0000277C 8B3E[AC45]              		mov	di,[ARG+ARGV_ELE.argstartel]
 11870 00002780 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 11871 00002783 742E                    		je	short STRIP_ERROR
 11872 00002785 89D1                    		mov	cx,dx		; compute where end of argstring lies
 11873                                  		;add	cx,ds:arg.argv[0].arglen
 11874                                  		;add	cx,[ARGV0_ARGLEN]
 11875 00002787 030E[AE45]              		add	cx,[ARG+ARGV_ELE.arglen]
 11876 0000278B 29F9                    		sub	cx,di		; and then find length of last element
 11877 0000278D 41                      		inc	cx		; include null as well
 11878                                  		;mov	al,'.'
 11879 0000278E B02E                    		mov	al,DOT		; let's find the filetype extension
 11880 00002790 FC                      		cld
 11881 00002791 F2AE                    		repnz scasb		; wind up pointing to either null or dot
 11882                                  
 11883                                  		; MSDOS 6.0
 11884                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 11885                                  		;mov	ext_entered,0	;AN005; we found an extension
 11886                                  		;mov	al,ANULL	;AN005; continue scanning until the
 11887                                  		;repnz	scasb		;AN005;    end of line is reached.
 11888                                  PROCESS_EXT:
 11889                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11890 00002793 89F9                    		mov	cx,di		; pointer to end of argstring yields
 11891 00002795 29D1                    		sub	cx,dx		; number of bytes to be copied
 11892 00002797 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 11893 0000279A 39D9                    		cmp	cx,bx
 11894 0000279C 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 11895 0000279E 89F7                    		mov	di,si		; destination buffer
 11896 000027A0 89D6                    		mov	si,dx		; source is beginning of pathname
 11897 000027A2 FC                      		cld
 11898 000027A3 F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 11899                                  
 11900                                  		; MSDOS 6.0
 11901                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 11902                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 11903                                  
 11904                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11905 000027A5 4F                      		dec	di		; overwrite null or dot
 11906 000027A6 AA                      		stosb			; with a dot
 11907                                  		;mov	al,'?'
 11908 000027A7 B03F                    		mov	al,WILDCHAR	; now add wildcards
 11909 000027A9 AA                      		stosb
 11910 000027AA AA                      		stosb
 11911 000027AB AA                      		stosb
 11912                                  		;mov	al,0
 11913 000027AC B000                    		mov	al,ANULL	; and a terminating null	
 11914 000027AE AA                      		stosb
 11915                                  SKIP_WILDS:
 11916 000027AF 9D                      		popf
 11917 000027B0 F8                      		clc
 11918 000027B1 EB02                    		jmp	short STRIP_EXIT ; chill out...
 11919                                  
 11920                                  STRIP_ERROR:
 11921 000027B3 9D                      		popf
 11922 000027B4 F9                      		stc
 11923                                  STRIP_EXIT:
 11924 000027B5 5E                      		pop	si
 11925 000027B6 5F                      		pop	di
 11926 000027B7 5A                      		pop	dx
 11927 000027B8 59                      		pop	cx
 11928 000027B9 5B                      		pop	bx
 11929 000027BA 58                      		pop	ax
 11930 000027BB C3                      		retn
 11931                                  
 11932                                  ; =============== S U B	R O U T	I N E =======================================
 11933                                  
 11934                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 11935                                  ;
 11936                                  ; structure in newly allocated memory. The argv[] structure is found at the
 11937                                  ; beginning of this area. The caller indicates how much extra space is
 11938                                  ; needed in the resulting structure; Save_Args returns a segment number and
 11939                                  ; an offset into that area, indicating where the caller may preserve its own
 11940                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 11941                                  ; ENTRY:
 11942                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 11943                                  ; EXIT:
 11944                                  ;   AX	    --	    segment of new area.
 11945                                  ;   CF	    --	    set if unable to save a copy.
 11946                                  ; NOTE(S):
 11947                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 11948                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 11949                                  ;	paragraphs.
 11950                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 11951                                  ;	as the caller of Save_Args requests.
 11952                                  ;   3)	AX is undefined if CF indicates an error.
 11953                                  
 11954                                  SAVE_ARGS:
 11955 000027BC 53                      		push	bx
 11956 000027BD 51                      		push	cx
 11957 000027BE 52                      		push	dx
 11958 000027BF 57                      		push	di
 11959 000027C0 56                      		push	si
 11960 000027C1 55                      		push	bp
 11961 000027C2 9C                      		pushf
 11962                                  		;add	bx,1363		; space for arg structure, round up
 11963 000027C3 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 11964 000027C7 B104                    		mov	cl,4		; to paragraph size and convert
 11965 000027C9 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 11966 000027CB B80048                  		mov	ax,ALLOC*256 ; 4800h
 11967 000027CE CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11968                                  				; BX = number of 16-byte paragraphs desired
 11969 000027D0 7244                    		jc	short SAVE_ERROR
 11970 000027D2 89C5                    		mov	bp,ax		; save segment id
 11971 000027D4 06                      		push	es		; save TRANGROUP address
 11972 000027D5 8EC0                    		mov	es,ax		; switch to new memory segment
 11973                                  		; assume es:nothing
 11974                                  		;mov	cx,1348		; get back structure size
 11975 000027D7 B94405                  		mov	cx,ARG_UNIT.SIZE
 11976 000027DA 31FF                    		xor	di,di		; destination is new memory area
 11977                                  		;mov	si,ARG_ARGV
 11978 000027DC BE[A945]                		mov	si,ARG		; source is arg structure
 11979 000027DF F3A4                    		rep movsb		; move that sucker!
 11980                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 11981                                  		;mov	cx,[ARG_ARGVCNT]
 11982 000027E1 8B0E[6948]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 11983 000027E5 31C0                    		xor	ax,ax		; base address for argv_calc
 11984                                  
 11985                                  	;	Bugbug:	What did they mean by this?
 11986                                  	;	Note that the replacement line produces exactly the same code.
 11987                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 11988                                  	;	mov	SI, OFFSET TRANGROUP:arg
 11989                                  
 11990                                  		;mov	si,ARG_ARGV
 11991 000027E7 BE[A945]                		mov	si,ARG	
 11992                                  SAVE_PTR_LOOP:
 11993 000027EA 49                      		dec	cx		; exhausted all args?
 11994 000027EB 7C24                    		jl	short SAVE_DONE
 11995 000027ED 89CB                    		mov	bx,cx		; get arg index and
 11996 000027EF E8E8FC                  		call	ARGV_CALC	; convert to a pointer
 11997                                  		;mov	dx,ds:arg.argv[bx].argpointer
 11998                                  		;mov	dx,[ARG_ARGV+bx]
 11999 000027F2 8B97[A945]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 12000 000027F6 29F2                    		sub	dx,si		; adjust argpointer
 12001                                  		;mov	es:argv[BX].argpointer,dx
 12002                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12003 000027F8 268917                  		mov	[es:bx],dx
 12004                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12005                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12006 000027FB 8B97[AC45]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12007 000027FF 29F2                    		sub	dx,si		; and adjust argstartel
 12008                                  		;mov	es:argv[bx].argstartel,dx
 12009                                  		;mov	[es:bx+3],dx
 12010 00002801 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12011                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12012                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12013 00002805 8B97[B245]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12014 00002809 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12015                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12016                                  		;mov	[es:bx+9],dx
 12017 0000280B 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12018 0000280F EBD9                    		jmp	short SAVE_PTR_LOOP
 12019                                  SAVE_DONE:
 12020 00002811 07                      		pop	es		; back we go to TRANGROUP
 12021                                  		; assume es:nothing
 12022 00002812 89E8                    		mov	ax,bp		; restore segment id
 12023 00002814 EB04                    		jmp	short SAVE_OK
 12024                                  
 12025                                  SAVE_ERROR:
 12026 00002816 9D                      		popf
 12027 00002817 F9                      		stc
 12028 00002818 EB02                    		jmp	short SAVE_EXIT
 12029                                  
 12030                                  SAVE_OK:
 12031 0000281A 9D                      		popf
 12032 0000281B F8                      		clc
 12033                                  SAVE_EXIT:
 12034 0000281C 5D                      		pop	bp
 12035 0000281D 5E                      		pop	si
 12036 0000281E 5F                      		pop	di
 12037 0000281F 5A                      		pop	dx
 12038 00002820 59                      		pop	cx
 12039 00002821 5B                      		pop	bx
 12040 00002822 C3                      		retn
 12041                                  
 12042                                  ;============================================================================
 12043                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12044                                  ;============================================================================
 12045                                  ; 02/10/2018 - Retro DOS v3.0
 12046                                  
 12047                                  ; Title	COMMAND Language midifiable Code Transient
 12048                                  
 12049                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12050                                  
 12051                                  ; =============== S U B	R O U T	I N E =======================================
 12052                                  
 12053                                  ; ****************************************************************
 12054                                  ; *
 12055                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12056                                  ; *
 12057                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12058                                  ; *		 user for Y/N if necessary. If an error occurs,
 12059                                  ; *		 set up an error message and go to CERROR.
 12060                                  ; *
 12061                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12062                                  ; *		 Current directory set to entered directory
 12063                                  ; *
 12064                                  ; * OUTPUT:	 none
 12065                                  ; *
 12066                                  ; ****************************************************************
 12067                                  ;
 12068                                  ; ARE YOU SURE prompt when deleting *.*
 12069                                  
 12070                                  NOTEST2:
 12071 00002823 B90B00                  		mov	cx,11
 12072 00002826 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12073                                  AMBSPEC:
 12074 00002829 AC                      		lodsb
 12075 0000282A 3C3F                    		cmp	al,'?'
 12076 0000282C 7502                    		jnz	short ALLFIL
 12077 0000282E E2F9                    		loop	AMBSPEC
 12078                                  ALLFIL:
 12079 00002830 83F900                  		cmp	cx,0
 12080 00002833 7531                    		jnz	short NOPRMPT
 12081                                  ASKAGN:	
 12082 00002835 BA[EC3A]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12083 00002838 E8980C                  		call	STD_PRINTF
 12084 0000283B BE8000                  		mov	si,80h
 12085 0000283E 89F2                    		mov	dx,si
 12086 00002840 C7047800                		mov	word [si],120	; zero length
 12087                                  		;mov	ax,0C0Ah
 12088 00002844 B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12089 00002847 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12090                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12091 00002849 AD                      		lodsw
 12092 0000284A 08E4                    		or	ah,ah
 12093 0000284C 74E7                    		jz	short ASKAGN
 12094 0000284E E82AF1                  		call	SCANOFF
 12095                                  		; MSDOS 6.0
 12096                                  		;call	char_in_xlat	; Convert to upper case
 12097                                  		;retc			; return if function not supported
 12098                                  		; MSDOS 3.3
 12099 00002851 E87E01                  		call	UPCONV
 12100                                  		
 12101                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12102 00002854 3A06[993D]              		cmp	al,[CAPITAL_N]
 12103 00002858 7501                    		jne	short CHECK_Y
 12104 0000285A C3                      		retn
 12105                                  CHECK_Y:
 12106 0000285B 3A06[983D]              		cmp	al,[CAPITAL_Y]
 12107 0000285F 9C                      		pushf
 12108 00002860 E80BF1                  		call	CRLF2
 12109 00002863 9D                      		popf
 12110 00002864 75CF                    		jne	short ASKAGN
 12111                                  NOPRMPT:
 12112 00002866 B413                    		mov	ah,FCB_DELETE ; 13h
 12113 00002868 BA5C00                  		mov	dx,FCB ; 5Ch
 12114 0000286B CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12115                                  				; DS:DX	-> FCB with filename field filled with
 12116                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12117                                  				; Return: AL = 00h file	found,FFh file	not found
 12118 0000286D FEC0                    		inc	al
 12119 0000286F 7404                    		jz	short ERAERR
 12120 00002871 E829F0                  		call	RESTUDIR
 12121 00002874 C3                      		retn
 12122                                  
 12123                                  		; MSDOS 6.0
 12124                                  ;eraerr:
 12125                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12126                                  		;push	dx			;AN022; save message
 12127                                  		;invoke	RESTUDIR
 12128                                  		;pop	dx			;AN022; restore message
 12129                                  		;
 12130                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12131                                  		;				;AN022; convert no more files to
 12132                                  		;jnz	cerrorj2		;AN022; 	file not found
 12133                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12134                                  		;			;AN000; get message number in control block
 12135                                  ;cerrorj2:
 12136                                  		;jmp	cerror
 12137                                  	
 12138                                  		; MSDOS 3.3
 12139                                  ERAERR:	
 12140 00002875 B41A                    		mov	ah,SET_DMA ; 1Ah
 12141 00002877 BA5C00                  		mov	dx,FCB ; 5Ch
 12142 0000287A CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12143                                  					; DS:DX	-> disk	transfer buffer
 12144 0000287C B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12145 0000287E CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12146                                  					; DS:DX	-> FCB
 12147 00002880 50                      		push	ax
 12148 00002881 E819F0                  		call	RESTUDIR
 12149 00002884 58                      		pop	ax
 12150 00002885 BA[F837]                		mov	dx,FNOTFOUNDPTR
 12151 00002888 FEC0                    		inc	al
 12152 0000288A 743D                    		jz	short CERRORJ
 12153 0000288C BA[1D38]                		mov	dx,ACCDENPTR
 12154 0000288F E999F3                  		jmp	CERROR
 12155                                  
 12156                                  ; =============== S U B	R O U T	I N E =======================================
 12157                                  
 12158                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12159                                  
 12160                                  ECHO:
 12161 00002892 E89400                  		call	ON_OFF
 12162 00002895 7212                    		jb	short DOEMES
 12163 00002897 8E1E[7142]              		mov	ds,[RESSEG]
 12164 0000289B 7506                    		jnz	short ECH_OFF
 12165 0000289D 800EED0B01              		or	byte [ECHOFLAG],1
 12166 000028A2 C3                      		retn
 12167                                  
 12168                                  ECH_OFF:
 12169 000028A3 8026ED0BFE              		and	byte [ECHOFLAG],0FEh
 12170 000028A8 C3                      		retn
 12171                                  
 12172                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12173                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12174                                  
 12175                                  DOEMES:
 12176                                  		; MSDOS 6.0
 12177                                  		;cmp	cl,0		;AC000; was anything on the line?
 12178                                  		;jz	PECHO		; just display current state.
 12179                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12180                                  		;invoke	CRPRINT
 12181                                  		;JMP	CRLF2
 12182                                  
 12183                                  		; MSDOS 3.3
 12184 000028A9 E82000                  		call	MOVE_TO_FIRST_ARG
 12185 000028AC 7409                    		jz	short PECHO
 12186 000028AE BA8200                  		mov	dx,82h
 12187 000028B1 E818F1                  		call	CRPRINT
 12188 000028B4 E9B7F0                  		jmp	CRLF2
 12189                                  
 12190                                  PECHO:
 12191                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12192 000028B7 8E1E[7142]              		mov	ds,[RESSEG]
 12193 000028BB 8A1EED0B                		mov	bl,byte [ECHOFLAG]
 12194 000028BF 0E                      		push	cs
 12195 000028C0 1F                      		pop	ds
 12196 000028C1 80E301                  		and	bl,1
 12197 000028C4 BA[1F3D]                		mov	dx,ECHOMESPTR
 12198 000028C7 EB2E                    		jmp	short PYN
 12199                                  
 12200                                  ; ---------------------------------------------------------------------------
 12201                                  
 12202                                  		; MSDOS 3.3
 12203                                  CERRORJ:
 12204 000028C9 E95FF3                  		jmp	CERROR
 12205                                  
 12206                                  
 12207                                  ; =============== S U B	R O U T	I N E =======================================
 12208                                  
 12209                                  MOVE_TO_FIRST_ARG:
 12210 000028CC BE8100                  		mov	si,81h
 12211 000028CF E8A9F0                  		call	SCANOFF
 12212 000028D2 3C0D                    		cmp	al,0Dh
 12213 000028D4 C3                      		retn
 12214                                  
 12215                                  ; =============== S U B	R O U T	I N E =======================================
 12216                                  
 12217                                  CNTRLC:
 12218 000028D5 E85100                  		call	ON_OFF
 12219 000028D8 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12220 000028DB 720C                    		jc	short PCNTRLC
 12221 000028DD 7505                    		jnz	short CNTRLC_OFF
 12222 000028DF B201                    		mov	dl,1
 12223 000028E1 CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12224                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12225                                  				; DL = 00h for OFF or 01h for ON
 12226 000028E3 C3                      		retn
 12227                                  
 12228                                  ; ---------------------------------------------------------------------------
 12229                                  
 12230                                  CNTRLC_OFF:
 12231 000028E4 30D2                    		xor	dl,dl
 12232 000028E6 CD21                    		int	21h		; Turn off ^C check
 12233 000028E8 C3                      		retn
 12234                                  
 12235                                  ; ---------------------------------------------------------------------------
 12236                                  
 12237                                  PCNTRLC:
 12238                                  		; MSDOS 6.0
 12239                                  		;CMP	CL,0		;AC000; rest of line blank?
 12240                                  		;JNZ	CERRORJ 	; no, oops!
 12241                                  
 12242                                  		; MSDOS 3.3
 12243 000028E9 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12244 000028EC 75DB                    		jnz	short CERRORJ
 12245                                  ;pccont:
 12246                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12247 000028EE 30C0                    		xor	al,al
 12248 000028F0 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12249 000028F2 88D3                    		mov	bl,dl
 12250 000028F4 BA[073D]                		mov	dx,CTRLMESPTR
 12251                                  
 12252                                  ; ---------------------------------------------------------------------------
 12253                                  
 12254                                  PYN:		; write "ON" or "OFF" state 
 12255                                  
 12256 000028F7 E8D90B                  		call	STD_PRINTF
 12257 000028FA BA[2E3D]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12258 000028FD 08DB                    		or	bl,bl
 12259 000028FF 7503                    		jnz	short PRINTVAL
 12260 00002901 BA[273D]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12261                                  
 12262                                  PRINTVAL:
 12263                                  		; MSDOS 3.3
 12264 00002904 E9CC0B                  		jmp	STD_PRINTF
 12265                                  
 12266                                  		; MSDOS 6.0
 12267                                  		;push	dx		;AN000; save offset of message block
 12268                                  		;mov	bx,dx		;AN000; save offset value
 12269                                  		;lodsw			;AN000; get message number of on or off
 12270                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12271                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12272                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12273                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12274                                  		;pop	dx		;AN000; get message back
 12275                                  		;invoke	std_printf	;AC000; go print message
 12276                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12277                                  		;
 12278                                  		;ret			;AN000; exit
 12279                                  
 12280                                  ; =============== S U B	R O U T	I N E =======================================
 12281                                  
 12282                                  VERIFY:
 12283 00002907 E81F00                  		call	ON_OFF
 12284 0000290A B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12285 0000290D 720A                    		jc	short PVERIFY
 12286 0000290F 7503                    		jnz	short VER_OFF
 12287 00002911 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12288                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12289 00002913 C3                      		retn
 12290                                  
 12291                                  ; ---------------------------------------------------------------------------
 12292                                  
 12293                                  VER_OFF:
 12294 00002914 FEC8                    		dec	al
 12295 00002916 CD21                    		int	21h		; Turn off verify after write
 12296 00002918 C3                      		retn
 12297                                  
 12298                                  ; ---------------------------------------------------------------------------
 12299                                  
 12300                                  PVERIFY:
 12301                                  		; MSDOS 6.0
 12302                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12303                                  		;JNZ	CERRORJ 	; nope...
 12304                                  
 12305                                  		; MSDOS 3.3
 12306 00002919 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12307 0000291C 75AB                    		jnz	short CERRORJ
 12308                                  
 12309 0000291E B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12310 00002920 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12311                                  					; Return: AL = 00h if flag OFF
 12312                                  					; AL = 01h if flag ON
 12313 00002922 88C3                    		mov	bl,al
 12314 00002924 BA[143D]                		mov	dx,VERIMESPTR
 12315 00002927 EBCE                    		jmp	short PYN
 12316                                  
 12317                                  ; =============== S U B	R O U T	I N E =======================================
 12318                                  
 12319                                  ; ****************************************************************
 12320                                  ; *
 12321                                  ; * ROUTINE:	 ON_OFF
 12322                                  ; *
 12323                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12324                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12325                                  ; *		 routines.
 12326                                  ; *
 12327                                  ; * INPUT:	 command line at offset 81H
 12328                                  ; *		 PARSE_BREAK control block
 12329                                  ; *
 12330                                  ; * OUTPUT:	 If carry is clear
 12331                                  ; *		    If ON is found
 12332                                  ; *		       Zero flag set
 12333                                  ; *		    If OFF is found
 12334                                  ; *		       Zero flag clear
 12335                                  ; *		 If carry set
 12336                                  ; *		    If nothing on command line
 12337                                  ; *		       CL set to zero
 12338                                  ; *		    If error
 12339                                  ; *		       CL contains error value from parse
 12340                                  ; *
 12341                                  ; ****************************************************************
 12342                                  
 12343                                  ON_OFF:
 12344 00002929 BE8100                  		mov	si,81h
 12345                                  
 12346                                  		; MSDOS 3.3
 12347 0000292C E84CF0                  		call	SCANOFF		; scan off leading blanks & equal
 12348 0000292F 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12349 00002931 742A                    		je	short BAD_ONF	; yes, return error
 12350 00002933 AD                      		lodsw
 12351 00002934 0D2020                  		or	ax,2020h	; convert to lowercase
 12352 00002937 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12353 0000293A 7410                    		je	short ON_CHECK
 12354 0000293C 3D6F66                  		cmp	ax,666Fh ;'of'
 12355 0000293F 751C                    		jne	short BAD_ONF
 12356 00002941 AC                      		lodsb
 12357 00002942 0C20                    		or	al,20h		; convert to lowercase		
 12358 00002944 3C66                    		cmp	al,66h	 ; 'f'
 12359 00002946 7515                    		jne	short BAD_ONF	
 12360 00002948 0C66                    		or	al,66h ; or al,'f'
 12361 0000294A EB02                    		jmp	short OFF_CHECK
 12362                                  ON_CHECK:
 12363 0000294C 30C0                    		xor	al,al
 12364                                  OFF_CHECK:
 12365 0000294E 9F                      		lahf
 12366 0000294F 89C3                    		mov	bx,ax
 12367 00002951 E827F0                  		call	SCANOFF		; scan off leading blanks & equal
 12368 00002954 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12369 00002956 7505                    		jne	short BAD_ONF	; no, return error
 12370 00002958 89D8                    		mov	ax,bx
 12371 0000295A 9E                      		sahf
 12372 0000295B F8                      		clc
 12373 0000295C C3                      		retn
 12374                                  
 12375                                  		; MSDOS 6.0
 12376                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12377                                  ;		lodsb			;AN032; get a char
 12378                                  ;		cmp	al,blank	;AN032; if whitespace
 12379                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12380                                  ;		cmp	al,tab_chr	;AN032; if tab
 12381                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12382                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12383                                  ;		jz	parse_on_off	;AN032;    start parsing
 12384                                  ;		dec	si		;AN032; if none of above - back up
 12385                                  ;
 12386                                  ;parse_on_off:				;AN032;    and start parsing
 12387                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
 12388                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12389                                  ;		xor	dx,dx		;AN000;
 12390                                  ;		invoke	cmd_parse	;AC000; call parser
 12391                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12392                                  ;		jz	BADONF		;AC000; yes, return error
 12393                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12394                                  ;		jz	on_off_there	;AN000; no - continue
 12395                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12396                                  ;		jmp	short BADONF	;AN000; return error
 12397                                  ;
 12398                                  ;on_off_there:
 12399                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12400                                  ;		jnz	good_on_off	;AN014; yes - continue
 12401                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12402                                  ;		jmp	short BADONF	;AN014; return error
 12403                                  ;
 12404                                  ;good_on_off:				;AN014;
 12405                                  ;		xor	ax,ax		;AC000; set up return code for
 12406                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12407                                  ;		pushf			;AN000; save flags
 12408                                  ;		mov	di,offset trangroup:parse_break
 12409                                  ;					;AN000; Get adderss of PARSE_BREAK
 12410                                  ;		xor	dx,dx		;AN000;
 12411                                  ;		invoke	cmd_parse	;AN000; call parser
 12412                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12413                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12414                                  ;		popf			;AN000; restore flags
 12415                                  ;		clc			;AC000; no error
 12416                                  ;		jmp	short on_off_end ;AN000; return to caller
 12417                                  ;
 12418                                  ;BADONF_flags:
 12419                                  ;		mov	cx,ax
 12420                                  ;		popf
 12421                                  
 12422                                  ; ---------------------------------------------------------------------------
 12423                                  
 12424                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12425                                  ; and return the error
 12426                                  
 12427                                  BAD_ONF:
 12428 0000295D BA[E93B]                		mov	dx,BADONOFFPTR
 12429 00002960 F9                      		stc
 12430                                  ;on_off_end:
 12431 00002961 C3                      		retn
 12432                                  
 12433                                  ;============================================================================
 12434                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12435                                  ;============================================================================
 12436                                  ; 02/10/2018 - Retro DOS v3.0
 12437                                  
 12438                                  ; Print volume ID info
 12439                                  
 12440                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12441                                  
 12442                                  ; ---------------------------------------------------------------------------
 12443                                  
 12444                                  PRINTVOL:
 12445 00002962 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12446 00002963 A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12447 00002966 0440                    		add	al,'@'
 12448 00002968 3C40                    		cmp	al,'@'
 12449 0000296A 7507                    		jnz	short DRVOK
 12450 0000296C A0[8542]                		mov	al,[CURDRV]
 12451 0000296F 0206[F03E]              		add	al,[CAPITAL_A]
 12452                                  DRVOK:
 12453 00002973 A2[6444]                		mov	[VOL_DRV],al	; get drive letter into argument
 12454 00002976 58                      		pop	ax		; get return code back
 12455 00002977 BA[553B]                		mov	dx,NOVOL ; "has	no label" 
 12456 0000297A 08C0                    		or	al,al		; volume label found?
 12457 0000297C 7517                    		jnz	short PRINTVOL2	; print no volume message
 12458                                  GOODVOL:
 12459                                  		; MSDOS 3.3
 12460 0000297E BF[9B42]                		mov	di,CHARBUF
 12461 00002981 89FA                    		mov	dx,di
 12462 00002983 BE[513B]                		mov	si,IS	; "is "
 12463 00002986 E8FBDE                  		call	STRCPY
 12464 00002989 4F                      		dec	di
 12465 0000298A BE[7243]                		mov	si,DIRBUF+8
 12466 0000298D B90B00                  		mov	cx,11
 12467 00002990 F3A4                    		rep movsb
 12468 00002992 31C0                    		xor	ax,ax
 12469                                  		;xor	al,al  ; MSDOS 6.0
 12470 00002994 AA                      		stosb			; store a zero to terminate the string
 12471                                  PRINTVOL2:
 12472 00002995 8916[6244]              		mov	[VOLNAME_ADDR],dx
 12473 00002999 BA[4B3B]                		mov	dx,VOLMESPTR
 12474 0000299C E9240B                  		jmp	PRINTF_CRLF
 12475                                  
 12476                                  		; MSDOS 6.0
 12477                                  ;drvok:
 12478                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12479                                  ;		pop	ax		;AC000; get return code back
 12480                                  ;		or	al,al		;AC000; volume label found?
 12481                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12482                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12483                                  ;					;AC000; set up no volume message
 12484                                  ;		jmp	short print_serial	;AC000; go print it
 12485                                  ;
 12486                                  ;Get_vol_name:
 12487                                  ;		mov	di,offset trangroup:charbuf
 12488                                  ;		mov	dx,di
 12489                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12490                                  ;		mov	cx,11				;AN000;  3/3/KK
 12491                                  ;		rep	movsb				;AN000;  3/3/KK
 12492                                  ;
 12493                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12494                                  ;		stosb
 12495                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12496                                  ;
 12497                                  ;PRINT_SERIAL:
 12498                                  ;
 12499                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12500                                  ;; occurs, do not print volume serial number.
 12501                                  ;
 12502                                  ;		push	dx		;AN000; save message offset
 12503                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12504                                  ;					;AC036; Get the volume serial info
 12505                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12506                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12507                                  ;		int	21h		;AN000; do the call
 12508                                  ;		pop	dx		;AN000; get message offset back
 12509                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12510                                  ;		call	std_printf	;AC000; go print volume message
 12511                                  ;		mov	al,blank	;AN051; Print out a blank
 12512                                  ;		invoke	print_char	;AN051;   before volume message
 12513                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12514                                  ;					;AN000; get serial number message
 12515                                  ;printvol_end:
 12516                                  ;		jmp	std_printf	;AC000; go print and exit
 12517                                  
 12518                                  ;============================================================================
 12519                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12520                                  ;============================================================================
 12521                                  ; 02/10/2018 - Retro DOS v3.0
 12522                                  
 12523                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12524                                  
 12525                                  ; =============== S U B	R O U T	I N E =======================================
 12526                                  
 12527                                  PRINT_DATE:
 12528                                  		; MSDOS 3.3
 12529 0000299F 06                      		push	es
 12530 000029A0 57                      		push	di
 12531 000029A1 0E                      		push	cs
 12532 000029A2 07                      		pop	es
 12533 000029A3 BF[C843]                		mov	di,ARG_BUF
 12534 000029A6 B42A                    		mov	ah,GET_DATE ; 2Ah
 12535 000029A8 CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12536                                  				; Return: DL = day,DH = month,	CX = year
 12537                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12538 000029AA 98                      		cbw
 12539 000029AB E80F00                  		call	GETDATE
 12540 000029AE E8EFF6                  		call	P_DATE
 12541 000029B1 30C0                    		xor	al,al
 12542 000029B3 AA                      		stosb
 12543 000029B4 BA[2337]                		mov	dx,ARG_BUF_PTR
 12544 000029B7 E8190B                  		call	STD_PRINTF
 12545 000029BA 07                      		pop	es
 12546 000029BB 5F                      		pop	di
 12547 000029BC C3                      		retn
 12548                                  
 12549                                  		; MSDOS 6.0
 12550                                  		;PUSH	ES
 12551                                  		;PUSH	DI
 12552                                  		;PUSH	CS
 12553                                  		;POP	ES
 12554                                  		;CALL	GetDate 		; get date
 12555                                  		;xchg	dh,dl			;AN000; switch month & day
 12556                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12557                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12558                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12559                                  		;invoke	std_printf
 12560                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12561                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12562                                  		;POP	DI			;AC000; restore di,es
 12563                                  		;POP	ES			;AC000;
 12564                                  		;return
 12565                                  
 12566                                  ; ---------------------------------------------------------------------------
 12567                                  
 12568                                  GETDATE:
 12569                                  		; MSDOS 3.3
 12570 000029BD 89C6                    		mov	si,ax
 12571 000029BF D1E6                    		shl	si,1
 12572 000029C1 01C6                    		add	si,ax
 12573 000029C3 81C6[243A]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12574 000029C7 89CB                    		mov	bx,cx
 12575 000029C9 B90300                  		mov	cx,3
 12576 000029CC F3A4                    		rep movsb
 12577 000029CE B020                    		mov	al,' '
 12578 000029D0 AA                      		stosb
 12579 000029D1 C3                      		retn
 12580                                  
 12581                                  		; MSDOS 6.0
 12582                                  
 12583                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12584                                  ; for output.  Date will be returned in CX,DX.
 12585                                  
 12586                                  ;GetDate:
 12587                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12588                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12589                                  		;INT	21h			;AC000; Get date in CX:DX
 12590                                  		;CBW				;AC000;
 12591                                  		;
 12592                                  		;push	cx			;AN000; save date returned in
 12593                                  		;push	dx			;AN000;      CX:DX
 12594                                  		;MOV	SI,AX
 12595                                  		;
 12596                                  		;SHL	SI,1
 12597                                  		;ADD	SI,AX			; SI=AX*3
 12598                                  		;
 12599                                  		;mov	cx,si			;AN000; save si
 12600                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12601                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12602                                  		;push	di			;AN000; save argument buffer
 12603                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12604                                  		;pop	di			;AN000; retrieve argument buffer
 12605                                  		;add	si,cx			;AC000; get day of week
 12606                                  		;
 12607                                  		;MOV	CX,3
 12608                                    		;REP	MOVSB
 12609                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12610                                  		;stosb
 12611                                  		;pop	dx			;AN000; get back date
 12612                                  		;pop	cx			;AN000;
 12613                                  		;
 12614                                  		;return
 12615                                  
 12616                                  ; =============== S U B	R O U T	I N E =======================================
 12617                                  
 12618                                  		; MSDOS 6.0
 12619                                  
 12620                                  ; This routine determines whether the character in AL is a
 12621                                  ; Yes or No character. On return, if AL=0, the character is
 12622                                  ; No, if AL=1, the character is Yes.
 12623                                  
 12624                                  ;		assume	ds:trangroup
 12625                                  
 12626                                  ;char_in_xlat	proc	near
 12627                                  ;
 12628                                  ;		mov	dl,al			;AC000; get character into DX
 12629                                  ;		xor	dh,dh			;AC000;
 12630                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12631                                  ;		int	21h			;AC000;
 12632                                  ;
 12633                                  ;		ret
 12634                                  ;
 12635                                  ;char_in_xlat	endp
 12636                                  
 12637                                  ;============================================================================
 12638                                  ; TENV.ASM, MSDOS 6.0, 1991
 12639                                  ;============================================================================
 12640                                  ; 02/10/2018 - Retro DOS v3.0
 12641                                  
 12642                                  ;	Environment utilities and misc. routines
 12643                                  
 12644                                  ; MSDOS 6.0
 12645                                  ; ****************************************************************
 12646                                  ; *
 12647                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12648                                  ; *
 12649                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12650                                  ; *		 the character in AL from the file upper case table
 12651                                  ; *		 in DOS if character if above  ascii 128, else
 12652                                  ; *		 subtracts 20H if between "a" and "z".
 12653                                  ; *
 12654                                  ; * INPUT:	 AL	      char to be upper cased
 12655                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12656                                  ; *
 12657                                  ; * OUTPUT:	 AL	      upper cased character
 12658                                  ; *
 12659                                  ; ****************************************************************
 12660                                  ;
 12661                                  ;assume	ds:trangroup				;AN000;
 12662                                  ;
 12663                                  ;upconv	proc	near				;AN000;
 12664                                  ;
 12665                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12666                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12667                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12668                                  ;	push	ds				;AN000;
 12669                                  ;	push	bx				;AN000;
 12670                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12671                                  ;assume	ds:resgroup				;AN000;
 12672                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12673                                  ;	add	bx,2				;AN000;  skip over first word
 12674                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12675                                  ;	pop	bx				;AN000;
 12676                                  ;	pop	ds				;AN000;
 12677                                  ;assume	ds:trangroup				;AN000;
 12678                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12679                                  ;
 12680                                  ;oth_fucase:					;AN000;
 12681                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12682                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12683                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12684                                  ;	ja	upconv_end			;AC000;
 12685                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12686                                  ;
 12687                                  ;upconv_end:					;AN000;
 12688                                  ;	ret
 12689                                  ;
 12690                                  ;upconv	endp					;AN000;
 12691                                  
 12692                                  
 12693                                  ; =============== S U B	R O U T	I N E =======================================
 12694                                  
 12695                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12696                                  
 12697                                  UPCONV:
 12698 000029D2 3C80                    		cmp	al,80h
 12699 000029D4 7214                    		jb	short OTH_UCASE
 12700 000029D6 2C80                    		sub	al,80h
 12701 000029D8 1E                      		push	ds
 12702 000029D9 53                      		push	bx
 12703 000029DA 8E1E[7142]              		mov	ds,[RESSEG]
 12704 000029DE C51E040C                		lds	bx,[UPPERCASETBL]
 12705 000029E2 83C302                  		add	bx,2
 12706 000029E5 D7                      		xlat
 12707 000029E6 5B                      		pop	bx
 12708 000029E7 1F                      		pop	ds
 12709 000029E8 EB0A                    		jmp	short UPCONV_RETN
 12710                                  
 12711                                  OTH_UCASE:
 12712 000029EA 3C61                    		cmp	al,'a'
 12713 000029EC 7206                    		jb	short UPCONV_RETN
 12714 000029EE 3C7A                    		cmp	al,'z'
 12715 000029F0 7702                    		ja	short UPCONV_RETN
 12716 000029F2 2C20                    		sub	al,20h
 12717                                  
 12718                                  UPCONV_RETN:
 12719 000029F4 C3                      		retn
 12720                                  
 12721                                  ;============================================================================
 12722                                  ; COPY.ASM, MSDOS 6.0, 1991
 12723                                  ;============================================================================
 12724                                  ; 01/10/2018 - Retro DOS v3.0
 12725                                  
 12726                                  ;	title	COMMAND COPY routines.
 12727                                  
 12728                                  ;/*
 12729                                  ; *                      Microsoft Confidential
 12730                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12731                                  ; *                      All Rights Reserved.
 12732                                  ; */
 12733                                  
 12734                                  ;***	COPY.ASM
 12735                                  
 12736                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12737                                  
 12738                                  
 12739                                  ;***	MODIFICATION HISTORY
 12740                                  
 12741                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12742                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12743                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12744                                  ;	     to tokens which begin with path characters so that PARSELINE
 12745                                  ;	     will work correctly.
 12746                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12747                                  ;	     individual tokens.  That distinction is no longer needed for
 12748                                  ;	     FOR loop processing.
 12749                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12750                                  ;	     1 when Cparse is called from COPY.
 12751                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12752                                  ;	     mod.  It now is conditional on flag like previous mod.
 12753                                  ;11/21/83 NP  Added printf
 12754                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12755                                  ;	     be added to a token.
 12756                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12757                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12758                                  ;	     special values:  -1 meaning destination was never opened and
 12759                                  ;	     0 which means that the destination has been openned and
 12760                                  ;	     closed.
 12761                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12762                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12763                                  ;	     lost on large and multiple file (wildcard) copies.
 12764                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12765                                  ;	     destination are not equal.
 12766                                  ;
 12767                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12768                                  ;	     first source file AND we run out of disk space before
 12769                                  ;	     completing the concatenation, restore the first source
 12770                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12771                                  ;
 12772                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12773                                  ;		instead of compatibility mode. This gives lesser sharing
 12774                                  ;		violations when files are opened for read on a copy.
 12775                                  
 12776                                  ; ---------------------------------------------------------------------------
 12777                                  ;***	COPY CODE
 12778                                  ; ---------------------------------------------------------------------------
 12779                                  
 12780                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12781                                  
 12782                                  COPY:
 12783                                  	; 	Initialize internal variables.
 12784                                  
 12785 000029F5 31C0                    		xor	ax,ax		; AX = 0
 12786 000029F7 A3[5044]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12787 000029FA A3[8545]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12788 000029FD A3[D144]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12789 00002A00 A2[9042]                		mov	[CFLAG],al	; 'destination file created' = false
 12790 00002A03 A3[9442]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12791 00002A06 A3[8C42]                		mov	[DESTSWITCH],ax	; destination switches = none
 12792 00002A09 A3[9745]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12793 00002A0C A3[6E44]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12794 00002A0F A2[9142]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12795 00002A12 A2[6D44]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12796 00002A15 A2[D044]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12797 00002A18 A2[7044]                		mov	[DESTINFO],al	; destination pathname flags = none
 12798 00002A1B A2[D344]                		mov	[SRCINFO],al	; source pathname flags = none
 12799 00002A1E A2[8745]                		mov	[INEXACT],al	; 'inexact copy' = false
 12800 00002A21 A2[6C44]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12801 00002A24 A2[CF44]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12802 00002A27 A2[5341]                		mov	[USERDIR1],al	; saved working directory = null
 12803 00002A2A A2[8945]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12804 00002A2D A2[8442]                		mov	[RDEOF],al	; 'read end of file' = false
 12805 00002A30 A3[2B45]                		mov	[SRCHAND],ax	; source handle = 0
 12806 00002A33 A3[9145]                		mov	[CPDATE],ax	; copy date = 0
 12807 00002A36 A3[9345]                		mov	[CPTIME],ax	; copy time = 0
 12808 00002A39 A2[2D45]                		mov	[SRCISDEV],al	; 'source is device' = false
 12809                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12810                                  		;mov	[OFilePtr_Lo],ax
 12811                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12812 00002A3C A2[8D45]                		mov	[TERMREAD],al	; 'terminate read' = false
 12813 00002A3F A2[C643]                		mov	[COMMA],al	; '"+,," found' = false
 12814 00002A42 A2[C743]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12815 00002A45 A3[8E42]                		mov	[ALLSWITCH],ax	; all switches = none
 12816 00002A48 A2[8742]                		mov	[ARGC],al	; source/dest argument count = 0
 12817 00002A4B A2[8F45]                		mov	[PLUS],al	; '"+" in command line' = false
 12818 00002A4E A2[8A45]                		mov	[BINARY],al	; 'binary copy' = false
 12819 00002A51 A2[8E45]                		mov	[ASCII],al	; 'ascii copy' = false
 12820 00002A54 A3[9942]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12821 00002A57 A3[8B45]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12822 00002A5A A2[8642]                		mov	[CONCAT],al	; 'concatenating' = false
 12823 00002A5D A2[CC44]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12824 00002A60 A3[CD44]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12825                                  
 12826                                  	;	Initialize buffers with double-nulls.
 12827                                  
 12828 00002A63 A3[2E45]                		mov	[SCANBUF],ax
 12829 00002A66 A3[7144]                		mov	[DESTBUF],ax
 12830 00002A69 A3[D444]                		mov	[SRCBUF],ax
 12831 00002A6C A3[B043]                		mov	[SDIRBUF],ax
 12832 00002A6F A3[6A43]                		mov	[DIRBUF],ax
 12833 00002A72 A3[2743]                		mov	[DESTFCB],ax
 12834                                  
 12835 00002A75 A2[9045]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 12836                                  		
 12837 00002A78 48                      		dec	ax		; AX = 0FFFFh
 12838 00002A79 A3[C844]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 12839 00002A7C A2[9642]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 12840 00002A7F A2[CB44]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 12841 00002A82 A2[6C44]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 12842                                  		
 12843 00002A85 BE8100                  		mov	si,81h		; SI = ptr to command line
 12844 00002A88 8A1E[FF3E]              		mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 12845 00002A8C FE06[A745]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 12846 00002A90 C606[5644]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 12847                                  
 12848                                  	;*	Scan the command line for destination information.
 12849                                  
 12850                                  DESTSCAN:
 12851 00002A95 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 12852 00002A97 BF[2E45]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 12853                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 12854 00002A9A E87708                  		call	CPARSE			; parse next object
 12855 00002A9D 9C                      		pushf				; save CParse flags
 12856 00002A9E FE06[9045]              		inc	byte [OBJCNT]		; count object
 12857 00002AA2 F6C780                  		test	bh,80h
 12858 00002AA5 7405                    		jz	short NOCOPY		; no "+" delimiter
 12859 00002AA7 C606[8F45]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 12860                                  NOCOPY:
 12861 00002AAC F6C701                  		test	bh,1
 12862 00002AAF 740D                    		jz	short TESTP2		; not a switch
 12863                                  
 12864                                  	;	Found a switch.
 12865                                  
 12866                                  		; MSDOS 6.0
 12867                                  		;test	bp,SwitchV		;AN038; Verify requested?
 12868                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12869                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 12870                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12871                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 12872                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 12873                                  
 12874                                  NOT_SLASHV:
 12875 00002AB1 092E[8C42]              		or	[DESTSWITCH],bp		; assume destination
 12876 00002AB5 092E[8E42]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 12877                                  
 12878                                  		; MSDOS 6.0
 12879                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 12880                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 12881                                  		;popf				;AN018; fix up stack
 12882                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 12883                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 12884                                  		;jmp	CError			;AC018; exit
 12885                                  
 12886                                  NOT_BAD_SWITCH:
 12887 00002AB9 9D                      		popf				; restore CParse flags
 12888 00002ABA 7233                    		jc	short CHECKDONE		; found CR
 12889 00002ABC EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 12890                                  
 12891                                  TESTP2:
 12892 00002ABE 9D                      		popf				; restore CParse flags
 12893 00002ABF 722E                    		jc	short CHECKDONE		; found CR
 12894 00002AC1 F6C780                  		test	bh,80h
 12895 00002AC4 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 12896 00002AC6 FE06[8742]              		inc	byte [ARGC]		; count independent pathname args
 12897                                  GOTPLUS:
 12898 00002ACA 56                      		push	si			; save cmd line ptr
 12899 00002ACB A1[9745]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 12900 00002ACE BE[2E45]                		mov	si,SCANBUF		; SI = ptr to path string
 12901 00002AD1 29F0                    		sub	ax,si			; AX = offset of last element
 12902 00002AD3 BF[7144]                		mov	di,DESTBUF		; DI = ptr to destination buf
 12903 00002AD6 01F8                    		add	ax,di			; AX = ptr to last element in
 12904                                  						;  destination path buffer
 12905 00002AD8 A3[6E44]                		mov	[DESTTAIL],ax		; save ptr to last element
 12906 00002ADB 880E[6D44]              		mov	[DESTSIZ],cl		; save path string length
 12907 00002ADF 41                      		inc	cx			; CX = mov length (incl null)
 12908 00002AE0 F3A4                    		rep movsb			; DestBuf = possible destination path
 12909 00002AE2 883E[7044]              		mov	[DESTINFO],bh		; save CParse info flags
 12910 00002AE6 C706[8C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12911 00002AEC 5E                      		pop	si			; SI = ptr into cmd line again
 12912 00002AED EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 12913                                  
 12914                                  CHECKDONE:
 12915                                  
 12916                                  	;	We reached the CR. The destination scan is finished.
 12917                                  
 12918                                  	;	Disallow "copy file1+" as file overwriting itself.
 12919                                  	;
 12920                                  	;	(Note that "copy file1+file2+" will be accepted, and
 12921                                  	;	equivalent to "copy file1+file2".)
 12922                                  
 12923                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 12924                                  	;	through this check, since the switch would count
 12925                                  	;	as another object in ObjCnt.
 12926                                  
 12927 00002AEF 803E[8F45]01            		cmp	byte [PLUS],1		; "+" with
 12928 00002AF4 7514                    		jnz	short CDCONT
 12929 00002AF6 803E[8742]01            		cmp	byte [ARGC],1		; one arg,
 12930 00002AFB 750D                    		jnz	short CDCONT
 12931 00002AFD 803E[9045]02            		cmp	byte [OBJCNT],2		; two objects..
 12932 00002B02 7506                    		jnz	short CDCONT
 12933 00002B04 BA[9438]                		mov	dx,OVERWRPTR
 12934 00002B07 E9B605                  		jmp	COPYERR			; is file overwrite
 12935                                  
 12936                                  CDCONT:
 12937 00002B0A A0[8F45]                		mov	al,[PLUS]		; AL = '"+" occurred'
 12938 00002B0D A2[8642]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 12939 00002B10 D0E0                    		shl	al,1
 12940 00002B12 D0E0                    		shl	al,1
 12941 00002B14 A2[8745]                		mov	[INEXACT],al		; therefore making an inexact copy
 12942 00002B17 BA[6D3D]                		mov	dx,BADARGSPTR
 12943 00002B1A A0[8742]                		mov	al,[ARGC]		; AL = # independent arguments
 12944 00002B1D 08C0                    		or	al,al
 12945 00002B1F 7404                    		jz	short CERROR4J
 12946                                  
 12947                                  		; MSDOS 6.0
 12948                                  		;or	al,al
 12949                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 12950                                  		
 12951                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12952                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 12953                                  		;jmp	short CError_ParseJ		; take parse error exit		
 12954                                  
 12955                                  	; more than 0 args; check if too many
 12956                                  
 12957                                  TRY_TOO_MANY:
 12958 00002B21 3C02                    		cmp	al,2
 12959 00002B23 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 12960                                  
 12961                                  		; MSDOS 6.0
 12962                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12963                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 12964                                  ;CError_ParseJ:
 12965                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 12966                                  
 12967                                  CERROR4J:
 12968 00002B25 E903F1                  		jmp	CERROR
 12969                                  
 12970                                  ACOUNTOK:
 12971 00002B28 BD[6C44]                		mov	bp,DESTVARS		; BP = base of dest variables
 12972                                  
 12973 00002B2B 3C01                    		cmp	al,1
 12974 00002B2D 7522                    		jnz	short GOT2ARGS
 12975                                  
 12976                                  	;	Only one independent pathname argument on command line.
 12977                                  	;	Set destination to d:*.*, where d: is current drive.
 12978                                  
 12979                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 12980                                  	;	The two files would be appended as d:file1, rather than x:file1.
 12981                                  
 12982 00002B2F A0[8542]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 12983 00002B32 0206[F03E]              		add	al,[CAPITAL_A]		; AL = current drive letter
 12984 00002B36 B43A                    		mov	ah,':'			; AX = "d:"
 12985                                  		;mov	byte [bp+1],2
 12986 00002B38 C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 12987                                  
 12988 00002B3C BF[7144]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 12989 00002B3F AB                      		stosw				; store "d:"
 12990                                  		
 12991 00002B40 C706[8C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12992                                  		;mov	byte [bp+4],2		
 12993 00002B46 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 12994                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 12995                                  		;mov	byte [bp+0],0		
 12996 00002B4A C6460000                		mov	byte [bp],0
 12997 00002B4E E89307                  		call	SETSTARS		; add wildcards
 12998                                  GOT2ARGS:
 12999                                  
 13000                                  	;	If destination pathname is "d:", add full wildcard filename
 13001                                  
 13002                                  		;cmp	byte [bp+1],2
 13003 00002B51 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13004 00002B55 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13005 00002B57 B03A                    		mov	al,':'
 13006 00002B59 3806[7244]              		cmp	byte [DESTBUF+1],al
 13007 00002B5D 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13008                                  		;or	byte [bp+4],2
 13009 00002B5F 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13010 00002B63 BF[7344]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13011                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13012                                  		;mov	byte [bp+0],0		
 13013 00002B66 C6460000                		mov	byte [bp],0
 13014 00002B6A E87707                  		call	SETSTARS		; add wildcards
 13015                                  
 13016                                  NOTSHORTDEST:
 13017                                  
 13018                                  	;	If destination pathname ends with "\", try to make
 13019                                  	;	sure it's "d:\".
 13020                                  
 13021                                  		;mov	di,[bp+2]
 13022 00002B6D 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13023 00002B70 803D00                  		cmp	byte [di],0
 13024 00002B73 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13025                                  
 13026 00002B75 BA[763B]                		mov	dx,BADCDPTR
 13027 00002B78 B03A                    		mov	al,':'
 13028 00002B7A 3845FE                  		cmp	[di-2],al
 13029 00002B7D 75A6                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13030                                  		;mov	byte [bp+0],2
 13031                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13032 00002B7F C6460002                		mov	byte [bp],2
 13033                                  		;or	byte [bp+4],6
 13034 00002B83 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13035                                  						  ;  path character
 13036 00002B87 E85A07                  		call	SETSTARS		; add wildcards
 13037                                  
 13038                                  CHKSWTCHES:
 13039                                  
 13040                                  	;	We have enough information about the destination for now.
 13041                                  
 13042                                  	;	Turn on verify if requested. Save the current verify flag.
 13043                                  
 13044 00002B8A BA[223A]                		mov	dx,BADPARMPTR
 13045 00002B8D A1[8E42]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13046                                  
 13047                                  		; MSDOS 3.3
 13048                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13049 00002B90 A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13050 00002B93 7590                    		jnz	short CERROR4J
 13051                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13052 00002B95 A91000                  		test	ax,SWITCHV ; 10h
 13053 00002B98 7414                    		jz	short NOVERIF		; no /v, no verify
 13054                                  
 13055 00002B9A B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13056 00002B9C CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13057                                  					; Return: AL = 00h if flag OFF
 13058                                  					; AL = 01h if flag ON
 13059 00002B9E 1E                      		push	ds
 13060 00002B9F 8E1E[7142]              		mov	ds,[RESSEG]
 13061 00002BA3 30E4                    		xor	ah,ah
 13062 00002BA5 A3F50B                  		mov	word [VERVAL],ax	; save current verify flag
 13063 00002BA8 1F                      		pop	ds
 13064 00002BA9 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13065 00002BAC CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13066                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13067                                  NOVERIF:
 13068                                  		;*	Scan for first source.
 13069                                  
 13070 00002BAE 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13071 00002BB0 BE8100                  		mov	si,81h			; SI = ptr into command line
 13072 00002BB3 8A1E[FF3E]              		mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13073                                  SCANFSRC:
 13074 00002BB7 BF[2E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13075 00002BBA E85707                  		call	CPARSE			; parse first source pathname
 13076 00002BBD F6C701                  		test	bh,1			; switch?
 13077 00002BC0 75F5                    		jnz	short SCANFSRC		; yes, try again
 13078 00002BC2 092E[8C42]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13079                                  
 13080                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13081                                  
 13082                                  		;test	bp,8
 13083 00002BC6 F7C50800                		test	bp,SWITCHB
 13084 00002BCA 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13085 00002BCC 803E[8642]00            		cmp	byte [CONCAT],0
 13086 00002BD1 7405                    		je	short NOSETCASC		; we're not concatenating
 13087                                  		;mov	byte [ASCII],4
 13088 00002BD3 C606[8E45]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13089                                  NOSETCASC:
 13090 00002BD8 E89703                  		call	SOURCE_SET		; set source variables
 13091 00002BDB E83B00                  		call	FRSTSRC			; set up first source copy
 13092 00002BDE E99000                  		jmp	FIRSTENT		; jump into the copy loop
 13093                                  
 13094                                  ; ---------------------------------------------------------------------------
 13095                                  
 13096                                  ENDCOPY:
 13097                                  
 13098                                  	;*	End of the road. Close destination, display # files
 13099                                  	;	copied (meaning # destinations), and go back to main
 13100                                  	;	transient COMMAND code.
 13101                                  
 13102 00002BE1 E8A802                  		call	CLOSEDEST
 13103                                  ENDCOPY2:
 13104 00002BE4 BA[FE38]                		mov	dx,COPIEDPTR
 13105 00002BE7 8B36[9942]              		mov	si,[FILECNT]
 13106 00002BEB 8936[5044]              		mov	[COPY_NUM],si
 13107 00002BEF E8E108                  		call	STD_PRINTF
 13108 00002BF2 E90FD5                  		jmp	TCOMMAND		; stack could be messed up
 13109                                  
 13110                                  ; ---------------------------------------------------------------------------
 13111                                  
 13112                                  SRCNONEXIST:
 13113                                  
 13114                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13115                                  	;	Otherwise, say 'file not found' and quit.
 13116                                  
 13117 00002BF5 803E[8642]00            		cmp	byte [CONCAT],0
 13118 00002BFA 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13119                                  
 13120                                  		; MSDOS 3.3
 13121 00002BFC BA[D444]                		mov	dx,SRCBUF
 13122 00002BFF 8916[4844]              		mov	[STRING_PTR_1],dx
 13123 00002C03 BA[2D37]                		mov	dx,STRINGBUF1PTR
 13124 00002C06 E8CA08                  		call	STD_PRINTF
 13125 00002C09 BA[F837]                		mov	dx,FNOTFOUNDPTR
 13126 00002C0C E9B104                  		jmp	COPYERR
 13127                                  
 13128                                  		; MSDOS 6.0
 13129                                  	;	Set up error message.
 13130                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13131                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13132                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13133                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13134                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13135                                  		;
 13136                                  		;jmp	CopErr			; print msg and clean up
 13137                                  
 13138                                  ; ---------------------------------------------------------------------------
 13139                                  
 13140                                  SOURCEPROC:
 13141                                  
 13142                                  	;*	Preparatory processing for each source file.
 13143                                  	;	Called at FrstSrc for first source file.
 13144                                  
 13145 00002C0F E86003                  		call	SOURCE_SET		; set source variables & ascii/binary
 13146 00002C12 803E[8642]00            		cmp	byte [CONCAT],0
 13147 00002C17 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13148                                  
 13149                                  ; ---------------------------------------------------------------------------
 13150                                  
 13151                                  FRSTSRC:
 13152 00002C19 31C0                    		xor	ax,ax
 13153 00002C1B A2[9042]                		mov	[CFLAG],al		; 'destination not created'
 13154 00002C1E A3[9442]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13155 00002C21 A2[9142]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13156                                  
 13157                                  LEAVECFLAG:
 13158 00002C24 8936[8545]              		mov	[SRCPT],si		; save cmd-line ptr
 13159 00002C28 BF[5341]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13160                                  						;   current dir
 13161 00002C2B BD[CF44]                		mov	bp,SRCVARS		; BP = base of source variables
 13162 00002C2E E8D705                  		call	BUILDPATH		; cd to source dir, figure
 13163                                  						;   out stuff about source
 13164 00002C31 8B36[D144]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13165 00002C35 C3                      		retn
 13166                                  
 13167                                  ; ---------------------------------------------------------------------------
 13168                                  
 13169                                  NEXTSRC:
 13170                                  
 13171                                  	;*	Next source. Come here after handling each pathname.
 13172                                  	;	We're done unless there are additional source pathnames
 13173                                  	;	to be appended.
 13174                                  	;
 13175                                  	;	Note that all files matching an ambiguous pathname
 13176                                  	;	are processed before coming here.
 13177                                  
 13178 00002C36 803E[8F45]00            		cmp	byte [PLUS],0
 13179 00002C3B 7502                    		jne	short MORECP		; copying "+" sources - keep going
 13180                                  
 13181                                  ENDCOPYJ2:
 13182 00002C3D EBA2                    		jmp	short ENDCOPY
 13183                                  
 13184                                  MORECP:
 13185 00002C3F 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13186 00002C41 8B36[8545]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13187 00002C45 8A1E[FF3E]              		mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13188                                  
 13189                                  SCANSRC:
 13190 00002C49 BF[2E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13191 00002C4C E8C506                  		call	CPARSE			; parse first source name
 13192 00002C4F 72EC                    		jb	short ENDCOPYJ2		; CR found - we're done
 13193                                  
 13194 00002C51 F6C780                  		test	bh,80h
 13195 00002C54 74E7                    		jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13196                                  
 13197 00002C56 F6C701                  		test	bh,1
 13198 00002C59 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13199                                  
 13200                                  	;	ScanBuf contains the next source pathname.
 13201                                  
 13202 00002C5B E8B1FF                  		call	SOURCEPROC		; prepare this source
 13203 00002C5E 803E[C643]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13204 00002C63 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13205 00002C65 C606[C743]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13206 00002C6A EB89                    		jmp	short SRCNONEXIST	; we know we won't find it
 13207                                  
 13208                                  NOSTAMP:
 13209 00002C6C C606[C743]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13210                                  
 13211                                  ; ---------------------------------------------------------------------------
 13212                                  
 13213                                  FIRSTENT:
 13214                                  
 13215                                  ;M047
 13216                                  ; The only case we need to worry about is when the source is wildcarded and
 13217                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13218                                  ;concatenation. We check for this case.
 13219                                  ;
 13220                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13221                                  ;right place to do this check.
 13222                                  
 13223                                  	;	This is where we enter the loop with the first source.
 13224                                  
 13225 00002C71 BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13226 00002C74 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13227 00002C77 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13228                                  					; DS:SI	-> string to parse
 13229                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13230                                  					; AL = bit mask	to control parsing
 13231 00002C79 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13232 00002C7C 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13233 00002C7E A1[D444]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13234 00002C81 80FC3A                  		cmp	ah,':'
 13235 00002C84 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13236 00002C86 B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13237                                  DRVSPEC1:
 13238 00002C88 0C20                    		or	al,20h			; AL = lowercase drive letter
 13239 00002C8A 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13240                                  		;mov	[5Ch],al
 13241 00002C8C A25C00                  		mov	[FCB],al		; put drive id in FCB
 13242                                  
 13243                                  	;	FCB contains drive and filename to search.
 13244                                  		
 13245 00002C8F B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13246 00002C91 E80701                  		call	SEARCH
 13247                                  SRCHDONE:
 13248 00002C94 9C                      		pushf				; save flags from Search
 13249 00002C95 E8F8EB                  		call	RESTUDIR1		; restore users current directory
 13250 00002C98 9D                      		popf				; restore flags from search
 13251 00002C99 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13252 00002C9B E957FF                  		jmp	SRCNONEXIST		; didn't find the source
 13253                                  
 13254                                  NEXTAMBIG0:
 13255 00002C9E 30C0                    		xor	al,al
 13256 00002CA0 8606[9642]              		xchg	al,[FRSTSRCH]
 13257 00002CA4 08C0                    		or	al,al
 13258 00002CA6 740B                    		jz	short NEXTAMBIG
 13259                                  SETNMEL:
 13260 00002CA8 B90C00                  		mov	cx,12
 13261 00002CAB BF[B043]                		mov	di,SDIRBUF
 13262 00002CAE BE[6A43]                		mov	si,DIRBUF
 13263 00002CB1 F3A4                    		rep movsb			; save very first source name
 13264                                  NEXTAMBIG:
 13265 00002CB3 30C0                    		xor	al,al
 13266 00002CB5 A2[8945]                		mov	[NOWRITE],al		; turn off nowrite
 13267 00002CB8 8B3E[D144]              		mov	di,[SRCTAIL]
 13268 00002CBC BE[6B43]                		mov	si,DIRBUF+1
 13269 00002CBF E8D8EC                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13270                                  MELDO:
 13271 00002CC2 803E[8642]00            		cmp	byte [CONCAT],0
 13272 00002CC7 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13273 00002CC9 F606[D344]02            		test	byte [SRCINFO],2	; wildcard - show name
 13274 00002CCE 7410                    		jz	short DOREAD
 13275                                  SHOWCPNAM:
 13276 00002CD0 BA[D444]                		mov	dx,SRCBUF
 13277 00002CD3 8916[4E44]              		mov	[STRING_PTR_2],dx
 13278 00002CD7 BA[3F37]                		mov	dx,STRINGBUF2PTR
 13279 00002CDA E8F607                  		call	STD_PRINTF
 13280 00002CDD E88EEC                  		call	CRLF2
 13281                                  DOREAD:
 13282 00002CE0 E8C900                  		call	DOCOPY
 13283 00002CE3 803E[8642]00            		cmp	byte [CONCAT],0
 13284 00002CE8 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13285                                  
 13286 00002CEA E89F01                  		call	CLOSEDEST		; close current destination
 13287 00002CED 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13288                                  
 13289 00002CEF C606[9042]00            		mov	byte [CFLAG],0		; 'destination not created'
 13290                                  NODCLOSE:
 13291 00002CF4 803E[8642]00            		cmp	byte [CONCAT],0		
 13292 00002CF9 740C                    		jz	short NOFLUSH
 13293                                  
 13294                                  ;	Concatenating - flush output between source files so LostErr
 13295                                  ;	stuff works correctly.
 13296                                  
 13297                                  		;invoke	FlshFil  ; MSDOS 6.0
 13298                                  
 13299 00002CFB E8AA02                  		call	FLUSHFIL ; MSDOS 3.3
 13300 00002CFE F606[CC44]FF            		test	byte [MELCOPY],0FFh
 13301 00002D03 7402                    		jz	short NOFLUSH
 13302 00002D05 EB0C                    		jmp	short DOMELCOPY
 13303                                  NOFLUSH:
 13304 00002D07 E88500                  		call	SEARCHNEXT		; try next match
 13305 00002D0A 755F                    		jnz	short NEXTSRCJ		; not found - finished with 
 13306                                  						;   this source spec
 13307 00002D0C C606[9142]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13308                                  
 13309 00002D11 EBA0                    		jmp	short NEXTAMBIG		; do next ambig match
 13310                                  
 13311                                  DOMELCOPY:
 13312 00002D13 803E[CC44]FF            		cmp	byte [MELCOPY],0FFh
 13313 00002D18 740D                    		je	short CONTMEL
 13314 00002D1A 8B36[8545]              		mov	si,[SRCPT]
 13315 00002D1E 8936[CD44]              		mov	[MELSTART],si
 13316 00002D22 C606[CC44]FF            		mov	byte [MELCOPY],0FFh
 13317                                  
 13318                                  CONTMEL:
 13319 00002D27 31ED                    		xor	bp,bp
 13320 00002D29 8B36[8545]              		mov	si,[SRCPT]
 13321 00002D2D 8A1E[FF3E]              		mov	bl,[PLUS_CHR]
 13322                                  SCANSRC2:
 13323 00002D31 BF[2E45]                		mov	di,SCANBUF
 13324 00002D34 E8DD05                  		call	CPARSE
 13325 00002D37 F6C780                  		test	bh,80h
 13326 00002D3A 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13327 00002D3C F6C701                  		test	bh,1
 13328 00002D3F 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13329 00002D41 E8CBFE                  		call	SOURCEPROC
 13330 00002D44 E849EB                  		call	RESTUDIR1
 13331 00002D47 BF[EB42]                		mov	di,DESTFCB2
 13332 00002D4A B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13333 00002D4D CD21                    		int	21h		; DOS -	PARSE FILENAME
 13334                                  					; DS:SI	-> string to parse
 13335                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13336                                  					; AL = bit mask	to control parsing
 13337 00002D4F BB[B143]                		mov	bx,SDIRBUF+1
 13338 00002D52 BE[EC42]                		mov	si,DESTFCB2+1
 13339 00002D55 8B3E[D144]              		mov	di,[SRCTAIL]
 13340                                  
 13341 00002D59 E87B04                  		call	BUILDNAME
 13342                                  
 13343 00002D5C 803E[8642]00            		cmp	byte [CONCAT],0
 13344 00002D61 7405                    		je	short MELDOJ		; not concatenating - continue
 13345                                  
 13346                                  	;	Yes, turn off nowrite because this part of the code 
 13347                                  	;	is only reached after the first file has been dealt with.
 13348                                  
 13349 00002D63 C606[8945]00            		mov	byte [NOWRITE],0
 13350                                  MELDOJ:
 13351 00002D68 E957FF                  		jmp	MELDO
 13352                                  
 13353                                  NEXTSRCJ:
 13354 00002D6B E9C8FE                  		jmp	NEXTSRC
 13355                                  
 13356                                  NEXTMEL:
 13357 00002D6E E81B01                  		call	CLOSEDEST
 13358 00002D71 31C0                    		xor	ax,ax
 13359 00002D73 A2[9042]                		mov	[CFLAG],al
 13360 00002D76 A3[9442]                		mov	[NXTADD],ax
 13361 00002D79 A2[9142]                		mov	[SPECDRV],al
 13362 00002D7C 8B36[CD44]              		mov	si,[MELSTART]
 13363 00002D80 8936[8545]              		mov	[SRCPT],si
 13364 00002D84 E80800                  		call	SEARCHNEXT
 13365 00002D87 7403                    		jz	short SETNMELJ
 13366 00002D89 E958FE                  		jmp	ENDCOPY2
 13367                                  
 13368                                  SETNMELJ:
 13369 00002D8C E919FF                  		jmp	SETNMEL
 13370                                  
 13371                                  ; ---------------------------------------------------------------------------
 13372                                  
 13373                                  SEARCHNEXT:
 13374 00002D8F B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13375 00002D91 F606[D344]02            		test	byte [SRCINFO],2
 13376 00002D96 7503                    		jnz	short SEARCH		; do search-next if ambig
 13377 00002D98 08E4                    		or	ah,ah			; reset zero flag
 13378 00002D9A C3                      		retn
 13379                                  
 13380                                  ; ---------------------------------------------------------------------------
 13381                                  
 13382                                  SEARCH:
 13383 00002D9B 50                      		push	ax
 13384 00002D9C B41A                    		mov	ah,SET_DMA ; 1Ah
 13385 00002D9E BA[6A43]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13386 00002DA1 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13387                                  				; DS:DX	-> disk	transfer buffer
 13388 00002DA3 58                      		pop	ax		; restore search first/next command
 13389 00002DA4 BA5C00                  		mov	dx,FCB ; 5Ch
 13390 00002DA7 CD21                    		int	21h		; Do the search
 13391 00002DA9 08C0                    		or	al,al
 13392 00002DAB C3                      		retn
 13393                                  
 13394                                  ; ---------------------------------------------------------------------------
 13395                                  
 13396                                  DOCOPY:
 13397 00002DAC BE[D444]                		mov	si,SRCBUF	; do name translate of source
 13398 00002DAF BF[9F3F]                		mov	di,SRCXNAME	; save for name comparison
 13399 00002DB2 B460                    		mov	ah,XNAMETRANS ; 60h
 13400 00002DB4 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13401                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13402                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13403 00002DB6 C606[8442]00            		mov	byte [RDEOF],0	; no EOF yet
 13404                                  
 13405                                  		; MSDOS 6.0
 13406                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13407                                  ;M046
 13408                                  ; For reads, the sharing mode should be deny none so that any process can
 13409                                  ;open this file again in any other sharing mode. This is mainly to allow
 13410                                  ;multiple command.com's to access the same file without getting sharing
 13411                                  ;violations
 13412                                  ;
 13413                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
 13414                                  		;xor	cx,cx				; no special files
 13415                                  		;mov	dx,READ_OPEN_FLAG		; set up open flags
 13416                                  		;int	21h
 13417                                  		;
 13418                                  		;jnc	OpenOk
 13419                                  
 13420                                  	;	Bogosity:  IBM wants us to issue Access Denied in this case.
 13421                                  	;	They asked for it...
 13422                                  
 13423                                  		;jmp	short Error_On_Source 		;AC022; clean up and exit
 13424                                  
 13425                                  		; MSDOS 3.3
 13426 00002DBB BA[D444]                		mov	dx,SRCBUF
 13427 00002DBE B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13428 00002DC1 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13429                                  					; DS:DX	-> ASCIZ filename
 13430                                  					; AL = access mode
 13431                                  					; 0 - read
 13432 00002DC3 7311                    		jnc	short OPENOK
 13433 00002DC5 E804F1                  		call	GET_EXT_ERR_NUMBER
 13434 00002DC8 9C                      		pushf
 13435 00002DC9 83F841                  		cmp	ax,65
 13436 00002DCC 7506                    		jnz	short DOCOPY_ERR
 13437 00002DCE BA[1D38]                		mov	dx,ACCDENPTR
 13438 00002DD1 E8FF06                  		call	STD_PRINTF
 13439                                  DOCOPY_ERR:
 13440 00002DD4 9D                      		popf
 13441 00002DD5 C3                      		retn
 13442                                  
 13443                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13444                                  OPENOK:
 13445 00002DD6 89C3                    		mov	bx,ax
 13446 00002DD8 891E[2B45]              		mov	[SRCHAND],bx		; save handle
 13447 00002DDC B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13448 00002DDF CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13449                                  					; BX = file handle
 13450                                  
 13451                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13452                                  
 13453 00002DE1 8916[9145]              		mov	[CPDATE],dx		; save date
 13454 00002DE5 890E[9345]              		mov	[CPTIME],cx		; save time
 13455                                  
 13456                                  		; MSDOS 6.0
 13457                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13458                                  
 13459                                  ;Error_On_Source:				;AN022; we have a BAD error
 13460                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13461                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13462                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13463                                  		;invoke	Std_EprintF		;AN022; print it
 13464                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13465                                  		;je	No_Close_Src		;AN022; no - don't close
 13466                                  		;call	CloseSrc		;AN022; clean up
 13467                                  ;No_Close_Src:					;AN022;
 13468                                  		;cmp	CFlag,0			;AN022; was destination created?
 13469                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13470                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13471                                  ;EndCopyJ3:					;AN022;
 13472                                  		;jmp	EndCopy2		;AN022;
 13473                                  ;No_Copy_Xa:
 13474                                  		;mov	bx,SrcHand		;AN022; get handle back
 13475                                  
 13476                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13477 00002DE9 B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13478 00002DEC CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13479                                  					; BX = file or device handle
 13480 00002DEE 80E280                  		and	dl,devid_ISDEV ; 80h
 13481 00002DF1 8816[2D45]              		mov	[SRCISDEV],dl		; set source info
 13482 00002DF5 740D                    		jz	short COPYLP		; source not a device
 13483 00002DF7 803E[8A45]00            		cmp	byte [BINARY],0
 13484 00002DFC 7406                    		je	short COPYLP		; ascii device ok
 13485 00002DFE BA[FB3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13486 00002E01 E9BC02                  		jmp	COPYERR
 13487                                  
 13488                                  COPYLP:
 13489 00002E04 8B1E[2B45]              		mov	bx,[SRCHAND]
 13490 00002E08 8B0E[9242]              		mov	cx,[BYTCNT]
 13491 00002E0C 8B16[9442]              		mov	dx,[NXTADD]
 13492 00002E10 29D1                    		sub	cx,dx			; compute available space
 13493 00002E12 750E                    		jnz	short GOTROOM
 13494                                  		;invoke	FlshFil   ; MSDOS 6.0
 13495 00002E14 E89101                  		call	FLUSHFIL  ; MSDOS 3.3
 13496 00002E17 803E[8D45]00            		cmp	byte [TERMREAD],0
 13497 00002E1C 7565                    		jne	short CLOSESRC		; give up
 13498 00002E1E 8B0E[9242]              		mov	cx,[BYTCNT]
 13499                                  GOTROOM:
 13500 00002E22 1E                      		push	ds
 13501 00002E23 8E1E[7342]              		mov	ds,[TPA]
 13502 00002E27 B43F                    		mov	ah,READ ; 3Fh
 13503 00002E29 CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13504                                  					; BX = file handle,CX = number	of bytes to read
 13505                                  					; DS:DX	-> buffer
 13506 00002E2B 1F                      		pop	ds
 13507 00002E2C 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13508                                  		;jc	Error_On_Source ; MSDOS 6.0
 13509 00002E2E 89C1                    		mov	cx,ax			; get count
 13510 00002E30 E351                    		jcxz	CLOSESRC		; no more to read
 13511 00002E32 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13512 00002E37 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13513 00002E39 803E[8E45]00            		cmp	byte [ASCII],0
 13514 00002E3E 741B                    		je	short BINREAD
 13515                                  NOTESTA:
 13516 00002E40 89CA                    		mov	dx,cx
 13517 00002E42 8B3E[9442]              		mov	di,[NXTADD]
 13518 00002E46 B01A                    		mov	al,1Ah
 13519 00002E48 06                      		push	es
 13520 00002E49 8E06[7342]              		mov	es,[TPA]		; scan for EOF
 13521 00002E4D F2AE                    		repne scasb
 13522 00002E4F 07                      		pop	es
 13523 00002E50 7505                    		jnz	short USEALL
 13524 00002E52 FE06[8442]              		inc	byte [RDEOF]
 13525 00002E56 41                      		inc	cx
 13526                                  USEALL:
 13527 00002E57 29CA                    		sub	dx,cx
 13528 00002E59 89D1                    		mov	cx,dx
 13529                                  BINREAD:
 13530 00002E5B 030E[9442]              		add	cx,[NXTADD]
 13531 00002E5F 890E[9442]              		mov	[NXTADD],cx
 13532 00002E63 3B0E[9242]              		cmp	cx,[BYTCNT]		; is buffer full?
 13533 00002E67 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13534                                  		;invoke	FlshFil
 13535 00002E69 E83C01                  		call	FLUSHFIL
 13536 00002E6C 803E[8D45]00            		cmp	byte [TERMREAD],0
 13537 00002E71 7510                    		jne	short CLOSESRC		; give up
 13538 00002E73 EB8F                    		jmp	short COPYLP
 13539                                  TESTDEV:
 13540 00002E75 803E[2D45]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13541 00002E7A 7407                    		je	short CLOSESRC
 13542 00002E7C 803E[8442]00            		cmp	byte [RDEOF],0
 13543 00002E81 7481                    		je	short COPYLP		; on device, go till ^Z
 13544                                  CLOSESRC:
 13545 00002E83 8B1E[2B45]              		mov	bx,[SRCHAND]
 13546 00002E87 B43E                    		mov	ah,CLOSE ; 3Eh
 13547 00002E89 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13548                                  					; BX = file handle
 13549                                  CLOSESRCDEST_RETN:
 13550 00002E8B C3                      		retn
 13551                                  
 13552                                  ; ---------------------------------------------------------------------------
 13553                                  
 13554                                  CLOSEDEST:
 13555                                  
 13556                                  	;	We are called to close the destination.
 13557                                  	;	We need to note whether or not there is any internal data left
 13558                                  	;	to be flushed out.
 13559                                  
 13560 00002E8C 803E[9142]00            		cmp	byte [DESTCLOSED],0
 13561 00002E91 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13562 00002E93 A0[8C42]                		mov	al,byte [DESTSWITCH]
 13563 00002E96 E86602                  		call	SETASC			; check for b or a switch
 13564 00002E99 7434                    		jz	short BINCLOS		;   on destination
 13565 00002E9B 8B1E[9442]              		mov	bx,[NXTADD]
 13566                                  ;
 13567                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13568                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13569                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13570                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13571                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13572                                  ;performance overhead on single ASCII file copies which now always involve
 13573                                  ;2 writes instead of 1 before. Is this really that important?
 13574                                  ;
 13575                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13576                                  ;M048;	jne	PutZ
 13577                                  
 13578                                  		; MSDOS 3.3
 13579 00002E9F 3B1E[9242]              		cmp	bx,[BYTCNT]	; is memory full?
 13580 00002EA3 7509                    		jne	short PUTZ
 13581                                  
 13582 00002EA5 E8F300                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13583 00002EA8 7402                    		jz	short NOCONC
 13584                                  CONCHNG:
 13585 00002EAA F9                      		stc
 13586 00002EAB C3                      		retn
 13587                                  
 13588                                  NOCONC:	
 13589 00002EAC 31DB                    		xor	bx,bx
 13590                                  PUTZ:
 13591 00002EAE 1E                      		push	ds
 13592 00002EAF 8E1E[7342]              		mov	ds,[TPA]
 13593 00002EB3 C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13594 00002EB7 1F                      		pop	ds
 13595 00002EB8 FF06[9442]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13596 00002EBC C606[8945]00            		mov	byte [NOWRITE],0
 13597 00002EC1 A1[8B45]                		mov	ax,[WRITTEN]
 13598 00002EC4 0306[9442]              		add	ax,[NXTADD]
 13599 00002EC8 7205                    		jc	short BINCLOS	; > 1
 13600 00002ECA 83F801                  		cmp	ax,1
 13601 00002ECD 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13602                                  BINCLOS:
 13603 00002ECF E8C900                  		call	TRYFLUSH
 13604 00002ED2 75D6                    		jnz	short CONCHNG
 13605                                  
 13606 00002ED4 803E[8B45]00            		cmp	byte [WRITTEN],0
 13607                                  FORGETITJ:
 13608 00002ED9 747D                    		jz	short FORGETIT	; never wrote nothing
 13609                                  NO_FORGET:				; wrote something
 13610 00002EDB 8B1E[C844]              		mov	bx,[DESTHAND]
 13611 00002EDF 8B0E[9345]              		mov	cx,[CPTIME]
 13612 00002EE3 8B16[9145]              		mov	dx,[CPDATE]
 13613 00002EE7 803E[8745]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13614 00002EEC 7431                    		je	short DODCLOSE	; if no, copy date & time
 13615 00002EEE B42C                    		mov	ah,GET_TIME ; 2Ch
 13616 00002EF0 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13617                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13618                                  					; DL = hundredths of seconds
 13619 00002EF2 D0E1                    		shl	cl,1
 13620 00002EF4 D0E1                    		shl	cl,1		; left justify min in cl
 13621 00002EF6 D1E1                    		shl	cx,1
 13622 00002EF8 D1E1                    		shl	cx,1
 13623 00002EFA D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13624 00002EFC D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13625 00002EFE 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13626 00002F00 51                      		push	cx		; save packed time
 13627 00002F01 B42A                    		mov	ah,GET_DATE ; 2Ah
 13628 00002F03 CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13629                                  					; Return: DL = day,DH = month,	CX = year
 13630                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13631 00002F05 81E9BC07                		sub	cx,1980
 13632 00002F09 86E9                    		xchg	ch,cl
 13633 00002F0B D1E1                    		shl	cx,1		; year to high 7 bits
 13634 00002F0D D0E6                    		shl	dh,1		; month to high 3 bits
 13635 00002F0F D0E6                    		shl	dh,1
 13636 00002F11 D0E6                    		shl	dh,1
 13637 00002F13 D0E6                    		shl	dh,1
 13638 00002F15 D0E6                    		shl	dh,1		; most sig bit of month in carry
 13639 00002F17 80D500                  		adc	ch,0		; put that bit next to year
 13640 00002F1A 08F2                    		or	dl,dh		; or low three of month into day
 13641 00002F1C 88EE                    		mov	dh,ch		; get year and high bit of month
 13642 00002F1E 59                      		pop	cx
 13643                                  DODCLOSE:
 13644 00002F1F 83FB00                  		cmp	bx,0
 13645 00002F22 7E2A                    		jle	short CLOSEDONE
 13646 00002F24 B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13647 00002F27 CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13648                                  					; BX = file handle,CX = time to be set
 13649                                  					; DX = date to be set
 13650                                  		; MSDOS 6.0
 13651                                  		;jc	Cleanup_Err	;AN022; handle error
 13652                                  
 13653                                  	;	See if the destination has *anything* in it.
 13654                                  	;	If not, just close and delete it.
 13655                                  
 13656 00002F29 B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13657 00002F2C 31D2                    		xor	dx,dx
 13658 00002F2E 89D1                    		mov	cx,dx
 13659 00002F30 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13660                                  					; AL = method: offset from end of file
 13661                                  	;	DX:AX is file size
 13662                                  
 13663 00002F32 09C2                    		or	dx,ax
 13664 00002F34 9C                      		pushf
 13665 00002F35 B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13666 00002F38 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13667                                  					; BX = file or device handle
 13668 00002F3A 52                      		push	dx			; save them away
 13669 00002F3B B43E                    		mov	ah,CLOSE ; 3Eh
 13670 00002F3D CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13671                                  					; BX = file handle
 13672 00002F3F 5A                      		pop	dx
 13673                                  
 13674                                  		; MSDOS 6.0
 13675                                  		;jnc	Close_Cont	;AN022; handle error on close
 13676                                  		;popf			;AN022; get the flags back
 13677                                  ;Cleanup_Err: 				;AN022;
 13678                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13679                                  		;call	DestDelete	;AN022; attempt to delete the target
 13680                                  		;jmp	short FileClosed ;AN022; close the file
 13681                                  ;Close_Cont:				;AN022; no error - co
 13682                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13683 00002F40 9D                      		popf
 13684 00002F41 750B                    		jnz	short CLOSEDONE
 13685 00002F43 F7C28000                		test	dx,80h		; is the destination a device?
 13686 00002F47 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13687 00002F49 E81E00                  		call	DESTDELETE
 13688 00002F4C EB04                    		jmp	short FILECLOSED
 13689                                  CLOSEDONE:
 13690 00002F4E FF06[9942]              		inc	word [FILECNT]
 13691                                  FILECLOSED:
 13692 00002F52 FE06[9142]              		inc	byte [DESTCLOSED]
 13693                                  RET50:
 13694 00002F56 F8                      		clc
 13695 00002F57 C3                      		retn
 13696                                  
 13697                                  FORGETIT:
 13698 00002F58 8B1E[C844]              		mov	bx,[DESTHAND]
 13699 00002F5C E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13700 00002F5F E80800                  		call	DESTDELETE
 13701 00002F62 C706[9942]0000          		mov	word [FILECNT],0 ; no files transferred
 13702 00002F68 EBEC                    		jmp	short RET50
 13703                                  
 13704                                  ; ---------------------------------------------------------------------------
 13705                                  
 13706                                  DESTDELETE:
 13707 00002F6A BA[7144]                		mov	dx,DESTBUF
 13708 00002F6D B441                    		mov	ah,UNLINK ; 41h
 13709 00002F6F CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13710                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13711                                  				;		(no wildcards allowed)
 13712 00002F71 C3                      		retn
 13713                                  
 13714                                  ; ---------------------------------------------------------------------------
 13715                                  
 13716                                  SOURCE_SET:
 13717 00002F72 56                      		push	si
 13718 00002F73 A1[9745]                		mov	ax,[STARTEL]
 13719 00002F76 BE[2E45]                		mov	si,SCANBUF	; adjust to copy
 13720 00002F79 29F0                    		sub	ax,si
 13721 00002F7B BF[D444]                		mov	di,SRCBUF
 13722 00002F7E 01F8                    		add	ax,di
 13723 00002F80 A3[D144]                		mov	[SRCTAIL],ax
 13724 00002F83 880E[D044]              		mov	[SRCSIZ],cl	; save its size
 13725 00002F87 41                      		inc	cx		; include the nul
 13726 00002F88 F3A4                    		rep movsb		; save this source
 13727 00002F8A 883E[D344]              		mov	[SRCINFO],bh	; save info about it
 13728 00002F8E 5E                      		pop	si
 13729 00002F8F 89E8                    		mov	ax,bp		; switches so far
 13730 00002F91 E86B01                  		call	SETASC		; set a,b switches accordingly
 13731 00002F94 E815EB                  		call	SWITCH		; get any more switches on this arg
 13732 00002F97 E86501                  		call	SETASC		; set
 13733 00002F9A C3                      		retn
 13734                                  
 13735                                  ; =============== S U B	R O U T	I N E =======================================
 13736                                  
 13737                                  ; MSDOS 6.0
 13738                                  
 13739                                  ;****************************************************************
 13740                                  ;*
 13741                                  ;* ROUTINE:	CleanupErr
 13742                                  ;*
 13743                                  ;* FUNCTION:	Issues extended error message for destination
 13744                                  ;*		if not alreay issued
 13745                                  ;*
 13746                                  ;* INPUT:	return from INT 21
 13747                                  ;*
 13748                                  ;* OUTPUT:	none
 13749                                  ;*
 13750                                  ;****************************************************************
 13751                                  
 13752                                  ;CleanupErr	proc	near		;AN022;
 13753                                  ;
 13754                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13755                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13756                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13757                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13758                                  ;					;AN022; get address of failed string
 13759                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13760                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13761                                  ;
 13762                                  ;CleanupErr_Cont:			;AN022;
 13763                                  ;	ret				;AN022; return to caller
 13764                                  ;
 13765                                  ;CleanupErr	endp			;AN022;
 13766                                  
 13767                                  ;============================================================================
 13768                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13769                                  ;============================================================================
 13770                                  ; 01/10/2018 - Retro DOS v3.0
 13771                                  
 13772                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13773                                  
 13774                                  ; =============== S U B	R O U T	I N E =======================================
 13775                                  
 13776                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13777                                  ;
 13778                                  ;	EXIT	ZR set if concatenate flag unchanged
 13779                                  
 13780                                  TRYFLUSH:
 13781 00002F9B A0[8642]                		mov	al,[CONCAT]
 13782 00002F9E 50                      		push	ax
 13783 00002F9F E80600                  		call	FLUSHFIL
 13784 00002FA2 58                      		pop	ax
 13785 00002FA3 3A06[8642]              		cmp	al,[CONCAT]
 13786 00002FA7 C3                      		retn
 13787                                  
 13788                                  ; =============== S U B	R O U T	I N E =======================================
 13789                                  
 13790                                  FLUSHFIL:
 13791 00002FA8 A0[8A45]                		mov	al,[BINARY]
 13792 00002FAB 8A26[8E45]              		mov	ah,[ASCII]
 13793 00002FAF 50                      		push	ax
 13794 00002FB0 E80900                  		call	FLSHFIL
 13795 00002FB3 58                      		pop	ax
 13796 00002FB4 8826[8E45]              		mov	[ASCII],ah
 13797 00002FB8 A2[8A45]                		mov	[BINARY],al
 13798 00002FBB C3                      		retn
 13799                                  
 13800                                  ; =============== S U B	R O U T	I N E =======================================
 13801                                  
 13802                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13803                                  ;
 13804                                  ;	Inputs:
 13805                                  ;	  [NXTADD] = No. of bytes to write
 13806                                  ;	  [CFLAG] <> 0 if file has been created
 13807                                  ;	Outputs:
 13808                                  ;	  [NXTADD] = 0
 13809                                  
 13810                                  FLSHFIL:
 13811 00002FBC C606[8D45]00            		mov	byte [TERMREAD],0
 13812 00002FC1 803E[9042]00            		cmp	byte [CFLAG],0
 13813 00002FC6 7403                    		jz	short NOTEXISTS
 13814 00002FC8 E98300                  		jmp	EXISTS
 13815                                  
 13816                                  NOTEXISTS:
 13817 00002FCB E84B01                  		call	BUILDDEST	; find out all about the destination
 13818 00002FCE E82F03                  		call	COMPNAME	; source and dest. the same?
 13819 00002FD1 7516                    		jnz	short PROCDEST	; if not, go ahead
 13820 00002FD3 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13821 00002FD8 750F                    		jnz	short PROCDEST	; same name on device ok
 13822 00002FDA 803E[8642]00            		cmp	byte [CONCAT],0	; concatenation?
 13823 00002FDF BA[9438]                		mov	dx,OVERWRPTR
 13824 00002FE2 745E                    		je	short COPERR	; not concatenating - overwrite error
 13825                                  		
 13826                                  ;No_Concat_Err:	; concatenating
 13827 00002FE4 C606[8945]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 13828                                  PROCDEST:
 13829                                  		; MSDOS 6.0
 13830                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13831                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 13832                                  ;M046
 13833                                  ; For writes, we want to deny writes by anyone else at the same time that we
 13834                                  ;are writing to it. For instance, on a network, 2 workstations could try
 13835                                  ;writing to the same file. Also, because we opened the source file with
 13836                                  ;DENY NONE, it is fine if the source and destination files are the same as
 13837                                  ;would happen when we append to an existing file.
 13838                                  ;
 13839                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 13840                                  		;xor	cx,cx				; no special files
 13841                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 13842                                  		;
 13843                                  		;cmp	NoWrite,0
 13844                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 13845                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 13846                                  
 13847 00002FE9 B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 13848 00002FEC 803E[8945]00            		cmp	byte [NOWRITE],0
 13849 00002FF1 7504                    		jne	short DODESTOPEN
 13850 00002FF3 B43C                    		mov	ah,CREAT ; 3Ch
 13851 00002FF5 31C9                    		xor	cx,cx
 13852                                  DODESTOPEN:
 13853 00002FF7 BA[7144]                		mov	dx,DESTBUF
 13854 00002FFA CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 13855                                  				; CX = attributes for file
 13856                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 13857                                  		
 13858                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 13859                                  		;mov	dx,FULDIRPTR
 13860                                  		;call	GET_EXT_ERR_NUMBER
 13861                                  		;jc	short COPERR
 13862                                  
 13863                                  		; 01/10/2018
 13864                                  		;jnc	short DEST_OPEN_OKAY
 13865                                  		
 13866                                  		;mov	dx,FULDIRPTR
 13867                                  		;call	GET_EXT_ERR_NUMBER
 13868                                  		;jmp	short COPERR
 13869                                  
 13870 00002FFC 723E                    		jc	short DEST_OPEN_ERROR
 13871                                  
 13872                                  ;DEST_OPEN_OKAY:
 13873 00002FFE A3[C844]                		mov	[DESTHAND],ax	; save handle
 13874 00003001 C606[9042]01            		mov	byte [CFLAG],1	; destination now exists
 13875 00003006 89C3                    		mov	bx,ax
 13876 00003008 B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 13877 0000300B CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 13878                                  				   	; BX = file or device handle
 13879                                  
 13880 0000300D 8816[CA44]              		mov	[DESTISDEV],dl	; set dest info
 13881                                  		;test	dl,80h
 13882 00003011 F6C280                  		test	dl,devid_ISDEV
 13883 00003014 7438                    		jz	short EXISTS	; Dest not a device
 13884                                  
 13885                                  ;	Destination is device.
 13886                                  
 13887 00003016 A0[8C42]                		mov	al,byte [DESTSWITCH]
 13888                                  		;and	al,0Ch
 13889 00003019 240C                    		and	al,SWITCHA+SWITCHB
 13890 0000301B 7509                    		jnz	short TESTBOTH
 13891 0000301D A0[8E45]                		mov	al,[ASCII]	; neither set, use current setting
 13892 00003020 0A06[8A45]              		or	al,[BINARY]
 13893 00003024 741E                    		jz	short EXSETA	; neither set, default to ascii
 13894                                  TESTBOTH:
 13895 00003026 7A26                    		jpe	short EXISTS	; both are set, ignore
 13896                                  		;test	al,8
 13897 00003028 A808                    		test	al,SWITCHB
 13898 0000302A 7422                    		jz	short EXISTS
 13899                                  		;mov	ax,(IOCTL shl 8) or 1
 13900 0000302C B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 13901 0000302F 30F6                    		xor	dh,dh
 13902                                  		;or	dl,20h
 13903 00003031 80CA20                  		or	dl,devid_RAW
 13904 00003034 8816[CA44]              		mov	[DESTISDEV],dl
 13905 00003038 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 13906                                  				; BX = device handle,DH = 0
 13907                                  				; DL = device information to set (bits 0-7 from	function 0)
 13908 0000303A EB12                    		jmp	short EXISTS
 13909                                  
 13910                                  		; 01/10/2018 - Retro DOS v3.0 modification
 13911                                  DEST_OPEN_ERROR:
 13912 0000303C BA[6E38]                		mov	dx,FULDIRPTR
 13913 0000303F E88AEE                  		call	GET_EXT_ERR_NUMBER
 13914                                  COPERR:
 13915 00003042 EB7C                    		jmp	short COPYERR
 13916                                  
 13917                                  EXSETA:
 13918                                  
 13919                                  ;	What we read in may have been in binary mode, flag zapped write OK
 13920                                  
 13921                                  		;mov	byte [ASCII],4
 13922 00003044 C606[8E45]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 13923                                  		;or	byte [INEXACT],4
 13924 00003049 800E[8745]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 13925                                  EXISTS:
 13926 0000304E 803E[8945]00            		cmp	byte [NOWRITE],0
 13927 00003053 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 13928 00003055 803E[C743]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 13929 0000305A 741D                    		jz	short NOCHECKING
 13930 0000305C E8A102                  		call	COMPNAME		; source and dest. the same?
 13931 0000305F 7518                    		jnz	short NOCHECKING	; if not, go ahead
 13932 00003061 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13933 00003066 7511                    		jne	short NOCHECKING	; same name on device ok
 13934                                  
 13935                                  ;	At this point we know in append (would have gotten overwrite error
 13936                                  ;	on first destination create otherwise), and user trying to specify
 13937                                  ;	destination which has been scribbled already (if dest had been named
 13938                                  ;	first, NoWrite would be set).
 13939                                  
 13940 00003068 BA[C038]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 13941                                  		;invoke	Std_EprintF		;ac022;
 13942 0000306B E86504                  		call	STD_PRINTF
 13943 0000306E C706[9442]0000          		mov	word [NXTADD],0		; set return
 13944 00003074 FE06[8D45]              		inc	byte [TERMREAD]		; tell read to give up
 13945                                  RET60:
 13946 00003078 C3                      		retn
 13947                                  
 13948                                  NOCHECKING:
 13949 00003079 8B1E[C844]              		mov	bx,[DESTHAND]		; get handle
 13950 0000307D 31C9                    		xor	cx,cx
 13951 0000307F 870E[9442]              		xchg	cx,[NXTADD]
 13952 00003083 E3F3                    		jcxz	RET60			; if nothing to write, forget it
 13953 00003085 FF06[8B45]              		inc	word [WRITTEN]		; flag that we wrote something
 13954 00003089 803E[8945]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 13955 0000308E 755A                    		jnz	short SEEKEND
 13956 00003090 31D2                    		xor	dx,dx
 13957 00003092 1E                      		push	ds
 13958 00003093 8E1E[7342]              		mov	ds,[TPA]
 13959 00003097 B440                    		mov	ah,WRITE ; 40h
 13960 00003099 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 13961                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 13962 0000309B 1F                      		pop	ds
 13963 0000309C BA[3938]                		mov	dx,NOSPACEPTR
 13964 0000309F 7222                    		jc	short COPERRP		; failure
 13965 000030A1 29C1                    		sub	cx,ax
 13966 000030A3 74D3                    		jz	short RET60		; wrote all supposed to
 13967 000030A5 F606[CA44]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 13968 000030AA 7414                    		jz	short COPYERR		; is a file, error
 13969 000030AC F606[CA44]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 13970 000030B1 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 13971 000030B3 803E[8745]00            		cmp	byte [INEXACT],0
 13972 000030B8 75BE                    		jnz	short RET60		; inexact so ok
 13973 000030BA 49                      		dec	cx
 13974                                  RETZ60:
 13975 000030BB 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 13976                                  
 13977                                  DEVWRTERR:
 13978 000030BD BA[893D]                		mov	dx,DEVWMESPTR
 13979                                  
 13980                                  COPYERR:
 13981                                  		;invoke	Std_EPrintF		;AC022;
 13982 000030C0 E81004                  		call	STD_PRINTF
 13983                                  COPERRP:
 13984 000030C3 FE06[9142]              		inc	byte [DESTCLOSED]
 13985 000030C7 803E[9042]00            		cmp	byte [CFLAG],0
 13986 000030CC 7419                    		jz	short ENDCOPYJ		; never actually got it open
 13987 000030CE 8B1E[C844]              		mov	bx,[DESTHAND]
 13988 000030D2 83FB00                  		cmp	bx,0
 13989 000030D5 7E04                    		jle	short NOCLOSE
 13990                                  
 13991                                  ;	Check to see if we should save part of the destination file.
 13992                                  
 13993                                  		; MSDOS 6.0
 13994                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 13995                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 13996                                  			
 13997                                  		;mov	ax,cx
 13998                                  		;or	ax,dx
 13999                                  		;jz	ceClose			; null file ptr means nothing to save
 14000                                  
 14001                                  ;	Destination was also the first source.  Do the best we can to
 14002                                  ;	restore it.  Truncate it back to the size we took from it (which
 14003                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14004                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14005                                  
 14006                                  		;mov	ax,LSEEK shl 8
 14007                                  		;int	21h
 14008                                  
 14009                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14010                                  		;mov	ah,WRITE
 14011                                  		;int	21h			; truncate file
 14012                                  
 14013                                  		;cmp	OCtrlZ,0
 14014                                  		;je	@f			; no ctrl-z removed from original
 14015                                  		;inc	cx			; CX = # bytes to write = 1
 14016                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14017                                  		;mov	ah,WRITE
 14018                                  		;int	21h			; write ctrl-z
 14019                                  ;@@:
 14020                                  		;mov	ah,CLOSE
 14021                                  		;int	21h			; close it
 14022                                  ;;		;mov	CFlag,0
 14023                                  		;jmp	EndCopy			; and go home
 14024                                  
 14025                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14026                                  CECLOSE:
 14027 000030D7 B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14028 000030D9 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14029                                  					; BX = file handle
 14030                                  NOCLOSE:
 14031 000030DB BA[7144]                		mov	dx,DESTBUF
 14032 000030DE B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14033 000030E0 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14034                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14035 000030E2 C606[9042]00            		mov	byte [CFLAG],0
 14036                                  ENDCOPYJ:
 14037 000030E7 E9F7FA                  		jmp	ENDCOPY
 14038                                  
 14039                                  SEEKEND:
 14040 000030EA 31D2                    		xor	dx,dx
 14041 000030EC 87D1                    		xchg	dx,cx
 14042                                  		;mov	ax,(LSEEK shl 8) or 1
 14043 000030EE B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14044 000030F1 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14045                                  					; AL = method: offset from present location
 14046 000030F3 803E[8442]00            		cmp	byte [RDEOF],0
 14047 000030F8 74C1                    		jz	short RETZ60
 14048                                  
 14049                                  ;	^Z has been read - we must set the file size to the current
 14050                                  ;	file pointer location
 14051                                  
 14052 000030FA B440                    		mov	ah,WRITE ; 40h
 14053 000030FC CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14054                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14055                                  
 14056                                  		; MSDOS 6.0
 14057                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14058                                  
 14059                                  ;	Make note that ^Z was removed, in case the
 14060                                  ;	copy should fail and we need to restore the file.
 14061                                  
 14062                                  		;mov	OCtrlZ,1Ah
 14063                                  
 14064 000030FE C3                      		retn
 14065                                  
 14066                                  ;============================================================================
 14067                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14068                                  ;============================================================================
 14069                                  ; 01/10/2018 - Retro DOS v3.0
 14070                                  
 14071                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14072                                  
 14073                                  ; =============== S U B	R O U T	I N E =======================================
 14074                                  
 14075                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14076                                  ;
 14077                                  ;	Given switch vector in AX,
 14078                                  ;	  Set Ascii flag if /a is set
 14079                                  ;	  Clear Ascii flag if /b is set
 14080                                  ;	  Binary set if /b specified
 14081                                  ;	  Leave Ascii unchanged if neither or both are set
 14082                                  ; 	Also sets Inexact if Ascii is ever set. 
 14083                                  ;	AL = Ascii on exit, flags set
 14084                                  
 14085                                  SETASC:
 14086 000030FF 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14087 00003101 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14088 00003103 50                      		push	ax
 14089 00003104 2408                    		and	al,SWITCHB  ; 8
 14090 00003106 A2[8A45]                		mov	[BINARY],al
 14091 00003109 58                      		pop	ax
 14092 0000310A 2404                    		and	al,4
 14093 0000310C A2[8E45]                		mov	[ASCII],al
 14094 0000310F 0806[8745]              		or	[INEXACT],al
 14095                                  LOADSW:
 14096 00003113 A0[8E45]                		mov	al,[ASCII]
 14097 00003116 08C0                    		or	al,al
 14098 00003118 C3                      		retn
 14099                                  
 14100                                  ; =============== S U B	R O U T	I N E =======================================
 14101                                  
 14102                                  BUILDDEST:
 14103 00003119 803E[6C44]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14104 0000311E 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14105 00003120 BF[5341]                		mov	di,USERDIR1
 14106 00003123 BD[6C44]                		mov	bp,DESTVARS
 14107 00003126 E8DF00                  		call	BUILDPATH
 14108 00003129 E864E7                  		call	RESTUDIR1
 14109                                  
 14110                                  ;	We now know all about the destination
 14111                                  
 14112                                  KNOWABOUTDEST:
 14113 0000312C 30C0                    		xor	al,al
 14114 0000312E 8606[CB44]              		xchg	al,[FIRSTDEST]
 14115 00003132 08C0                    		or	al,al
 14116 00003134 7503                    		jnz	short FIRSTDST
 14117 00003136 E98A00                  		jmp	NOFIRSTDEST
 14118                                  FIRSTDST:
 14119                                  
 14120                                  ;	Create an fcb of the original dest.
 14121                                  
 14122 00003139 8B36[6E44]              		mov	si,[DESTTAIL]
 14123 0000313D BF[2743]                		mov	di,DESTFCB
 14124 00003140 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14125 00003143 CD21                    		int	21h		; DOS -	PARSE FILENAME
 14126                                  					; DS:SI	-> string to parse
 14127                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14128                                  					; AL = bit mask	to control parsing
 14129 00003145 803C00                  		cmp	byte [si],0
 14130 00003148 7404                    		jz	short GOODPARSE
 14131 0000314A C645017C                		mov	byte [di+1],'|'
 14132                                  		; MSDOS 6.0
 14133                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14134                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14135                                  		;jmp	CopErr				;AN052;
 14136                                  GOODPARSE:
 14137 0000314E A1[7144]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14138 00003151 80FC3A                  		cmp	ah,':'
 14139 00003154 7402                    		jz	short DRVSPEC4
 14140 00003156 B040                    		mov	al,'@'
 14141                                  DRVSPEC4:
 14142                                  
 14143                                  ;	AX = "d:" for following FCB drive computation
 14144                                  
 14145 00003158 8A0E[8E45]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14146 0000315C 0C20                    		or	al,20h
 14147 0000315E 2C60                    		sub	al,60h
 14148 00003160 A2[2743]                		mov	byte [DESTFCB],al	; store drive # in FCB
 14149                                  
 14150                                  ;*	Figure out what copy mode we're in.
 14151                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14152                                  ;	+n stands for additional sources delimited by +'s.
 14153                                  ;
 14154                                  ;	copy a b	not concatenating
 14155                                  ;	copy a *	not concatenating
 14156                                  ;	copy * a	concatenating
 14157                                  ;	copy * *	not concatenating
 14158                                  ;	copy a+n b	concatenating
 14159                                  ;	copy *+n a	concatenating
 14160                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14161                                  
 14162                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14163                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14164                                  
 14165 00003163 A0[7044]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14166 00003166 8A26[D344]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14167 0000316A 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14168 0000316D 08C0                    		or	al,al
 14169 0000316F 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14170                                  
 14171                                  ;	Destination is wildcarded.
 14172                                  	
 14173 00003171 38E0                    		cmp	al,ah
 14174 00003173 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14175                                  
 14176                                  ;	Source and destination are both wildcarded.
 14177                                  
 14178 00003175 803E[8F45]00            		cmp	byte [PLUS],0
 14179 0000317A 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14180                                  
 14181                                  ;	Source and destination are wildcarded, and source includes +'s.
 14182                                  ;	It's Mel Hallorman copy time.
 14183                                  
 14184 0000317C FE06[CC44]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14185 00003180 30C0                    		xor	al,al
 14186 00003182 EB06                    		jmp	short SETCONC
 14187                                  
 14188                                  NOTMELCOPY:
 14189 00003184 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14190 00003186 20E0                    		and	al,ah
 14191 00003188 D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14192                                  				;   (implies concatenation)
 14193                                  SETCONC:
 14194 0000318A 0A06[8F45]              		or	al,[PLUS]	; "+" always infers concatenation
 14195                                  
 14196                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14197                                  
 14198 0000318E A2[8642]                		mov	[CONCAT],al
 14199 00003191 D0E0                    		shl	al,1
 14200 00003193 D0E0                    		shl	al,1
 14201 00003195 A2[8745]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14202 00003198 803E[8A45]00            		cmp	byte [BINARY],0
 14203 0000319D 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14204                                  
 14205 0000319F A2[8E45]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14206 000031A2 08C9                    		or	cl,cl
 14207 000031A4 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14208 000031A6 08C0                    		or	al,al
 14209 000031A8 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14210                                  
 14211                                  ;	At this point there may already be binary read data in the read
 14212                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14213                                  ;	amount of data in the buffer correctly.
 14214                                  
 14215 000031AA 8B0E[9442]              		mov	cx,[NXTADD]
 14216 000031AE E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14217 000031B0 B01A                    		mov	al,1Ah
 14218 000031B2 06                      		push	es
 14219 000031B3 31FF                    		xor	di,di
 14220 000031B5 8E06[7342]              		mov	es,[TPA]
 14221 000031B9 F2AE                    		repne scasb		; scan for EOF
 14222 000031BB 07                      		pop	es
 14223 000031BC 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14224 000031BE 4F                      		dec	di		; point at ^z
 14225 000031BF 893E[9442]              		mov	[NXTADD],di	; new buffer length
 14226                                  
 14227                                  NOFIRSTDEST:
 14228 000031C3 BB[6B43]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14229 000031C6 803E[8642]00            		cmp	byte [CONCAT],0
 14230 000031CB 7403                    		jz	short GOTCHRSRC	; Not a concat
 14231 000031CD BB[B143]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14232                                  GOTCHRSRC:
 14233 000031D0 BE[2843]                		mov	si,DESTFCB+1	; Original dest name
 14234 000031D3 8B3E[6E44]              		mov	di,[DESTTAIL]	; Where to put result
 14235                                  
 14236                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14237                                  
 14238                                  BUILDNAME:
 14239 000031D7 B90800                  		mov	cx,8
 14240                                  BUILDMAIN:
 14241 000031DA AC                      		lodsb
 14242 000031DB 3C3F                    		cmp	al,'?'
 14243 000031DD 7502                    		jnz	short NOTAMBIG
 14244 000031DF 8A07                    		mov	al,[bx]
 14245                                  NOTAMBIG:
 14246 000031E1 3C20                    		cmp	al,' '
 14247 000031E3 7401                    		jz	short NOSTORE
 14248 000031E5 AA                      		stosb
 14249                                  NOSTORE:
 14250 000031E6 43                      		inc	bx
 14251 000031E7 E2F1                    		loop	BUILDMAIN
 14252 000031E9 B103                    		mov	cl,3
 14253 000031EB B020                    		mov	al,' '
 14254 000031ED 3804                    		cmp	[si],al
 14255 000031EF 7413                    		jz	short ENDDEST	; No extension
 14256 000031F1 A0[083F]                		mov	al,[DOT_CHR]
 14257 000031F4 AA                      		stosb
 14258                                  BUILDEXT:
 14259 000031F5 AC                      		lodsb
 14260 000031F6 3C3F                    		cmp	al,'?'
 14261 000031F8 7502                    		jnz	short NOTAMBIGE
 14262 000031FA 8A07                    		mov	al,[bx]
 14263                                  NOTAMBIGE:
 14264 000031FC 3C20                    		cmp	al,' '
 14265 000031FE 7401                    		jz	short NOSTOREE
 14266 00003200 AA                      		stosb
 14267                                  NOSTOREE:
 14268 00003201 43                      		inc	bx
 14269 00003202 E2F1                    		loop	BUILDEXT
 14270                                  ENDDEST:
 14271 00003204 30C0                    		xor	al,al
 14272 00003206 AA                      		stosb			; NUL terminate
 14273 00003207 C3                      		retn
 14274                                  
 14275                                  ; =============== S U B	R O U T	I N E =======================================
 14276                                  
 14277                                  BUILDPATH:
 14278 00003208 F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14279 0000320C 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14280 0000320E 89EA                    		mov	dx,bp		; Set DX to spec
 14281 00003210 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14282                                  
 14283                                  		; MSDOS 6.0
 14284                                  		;push	di				;AN000;
 14285                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14286                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14287                                  		;xor	cx,cx				;AN000; no special files
 14288                                  		;mov	si,dx				;AN030; get file name offset
 14289                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14290                                  		;INT	21h
 14291                                  		;pop	di				;AN000;
 14292                                  		;jnc	pure_file			;AN022; is pure file
 14293                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14294                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14295                                  		;jz	notpfile			;AN022;
 14296                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14297                                  		;jz	notpfile			;AN022;
 14298                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14299                                  		;jz	notpfile			;AN022;
 14300                                  		;jmp	extend_setup			;AN022; exit with error
 14301                                  ;pure_file:
 14302                                  		; MSDOS 3.3
 14303 00003213 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14304 00003216 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14305                                  					; DS:DX	-> ASCIZ filename
 14306                                  					; AL = access mode
 14307                                  					; 0 - read
 14308 00003218 7216                    		jc	short NOTPFILE
 14309                                  ;PURE_FILE:
 14310 0000321A 89C3                    		mov	bx,ax
 14311 0000321C B80044                  		mov	ax,IOCTL*256 ; 4400h
 14312 0000321F CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14313                                  					; BX = file or device handle
 14314 00003221 B43E                    		mov	ah,CLOSE ;3Eh
 14315 00003223 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14316                                  					; BX = file handle
 14317 00003225 F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14318 00003228 7545                    		jnz	short ISADEV
 14319 0000322A F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14320 0000322E 743F                    		jz	short ISADEV
 14321                                  
 14322                                  NOTPFILE:
 14323 00003230 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14324                                  		
 14325                                  		;MSDOS 6.0
 14326                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14327                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14328                                  
 14329 00003233 80FE3A                  		cmp	dh,':'
 14330 00003236 7402                    		je	short DRVSPEC5
 14331                                  
 14332                                  SET_DRIVE_SPEC:
 14333 00003238 B240                    		mov	dl,'@'
 14334                                  
 14335                                  DRVSPEC5:
 14336 0000323A 80CA20                  		or	dl,20h
 14337 0000323D 80EA60                  		sub	dl,60h		; A = 1
 14338 00003240 E808E7                  		call	SAVUDIR1
 14339                                  	
 14340                                  		; MSDOS 6.0
 14341                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14342                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14343                                  		;jmp	extend_setup		;AN022; exit with error
 14344                                  
 14345                                  CURDIR_OK:
 14346 00003243 89EA                    		mov	dx,bp
 14347                                  		;add	dx,5
 14348 00003245 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14349                                  		;mov	bh,[bp+4]
 14350 00003248 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14351 0000324B 80E706                  		and	bh,6
 14352 0000324E 80FF06                  		cmp	bh,6			; Ambig and path ?
 14353 00003251 7517                    		jne	short CHECKAMB		; jmp if no
 14354                                  		;mov	si,[bp+2]
 14355 00003253 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14356 00003256 B33A                    		mov	bl,':'
 14357 00003258 385CFE                  		cmp	[si-2],bl
 14358 0000325B 7506                    		jne	short KNOWNOTSPEC
 14359                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14360                                  		;mov	byte [bp+0],2
 14361 0000325D C6460002                		mov	byte [bp],2
 14362 00003261 EB05                    		jmp	short DOPCDJ
 14363                                  
 14364                                  KNOWNOTSPEC:
 14365                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14366                                  		;mov	byte [bp+0],1		
 14367 00003263 C6460001                		mov	byte [bp],1
 14368 00003267 4E                      		dec	si
 14369                                  DOPCDJ:
 14370 00003268 EB62                    		jmp	short DOPCD
 14371                                  
 14372                                  CHECKAMB:
 14373 0000326A 80FF02                  		cmp	bh,2
 14374 0000326D 7505                    		jnz	short CHECKCD
 14375                                  ISSIMPFILE:
 14376                                  ISADEV:
 14377                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14378                                  		;mov	byte [bp+0],0		
 14379 0000326F C6460000                		mov	byte [bp],0
 14380 00003273 C3                      		retn
 14381                                  
 14382                                  CHECKCD:
 14383 00003274 E895EC                  		call	SETREST1
 14384 00003277 B43B                    		mov	ah,CHDIR ; 3Bh
 14385 00003279 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14386                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14387 0000327B 7223                    		jb	short NOTPDIR
 14388 0000327D 89D7                    		mov	di,dx
 14389 0000327F 31C0                    		xor	ax,ax
 14390 00003281 89C1                    		mov	cx,ax
 14391 00003283 49                      		dec	cx
 14392 00003284 F2AE                    		repne scasb
 14393                                  DONE:
 14394 00003286 4F                      		dec	di
 14395 00003287 A0[7642]                		mov	al,[DIRCHAR]
 14396                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14397                                  		;mov	byte [bp+0],2
 14398 0000328A C6460002                		mov	byte [bp],2
 14399 0000328E 3A45FF                  		cmp	al,[di-1]
 14400 00003291 7405                    		jz	short GOTSRCSLSH
 14401                                  _STORE_PCHAR:
 14402 00003293 AA                      		stosb
 14403                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14404                                  		;mov	byte [bp+0],1
 14405 00003294 C6460001                		mov	byte [bp],1
 14406                                  GOTSRCSLSH:
 14407                                  		;or	byte [bp+4],6
 14408 00003298 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14409 0000329C E84500                  		call	SETSTARS
 14410                                  NOTPDIR_RETN:
 14411 0000329F C3                      		retn
 14412                                  
 14413                                  NOTPDIR:
 14414                                  		; MSDOS 6.0
 14415                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14416                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14417                                  		;jz	notpdir_try		;AN022;
 14418                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14419                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14420                                  ;notpdir_try:
 14421                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14422                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14423                                  		;mov	byte [bp+0],0
 14424 000032A0 C6460000                		mov	byte [bp],0
 14425                                  		;mov	bh,[bp+4]
 14426 000032A4 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14427 000032A7 F6C704                  		test	bh,4
 14428 000032AA 74F3                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14429                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14430                                  		;mov	byte [bp+0],2		
 14431 000032AC C6460002                		mov	byte [bp],2
 14432                                  		;mov	si,[bp+2]
 14433 000032B0 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14434 000032B3 803C00                  		cmp	byte [si],0
 14435 000032B6 7428                    		je	short BADCDERRJ2	; Trailing '/'	
 14436 000032B8 8A1E[083F]              		mov	bl,[DOT_CHR]
 14437 000032BC 381C                    		cmp	[si],bl
 14438 000032BE 7420                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14439 000032C0 B33A                    		mov	bl,':'
 14440 000032C2 385CFE                  		cmp	[si-2],bl
 14441 000032C5 7405                    		je	short DOPCD		   ; Know d:/file
 14442                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14443                                  		;mov	byte [bp+0],1
 14444 000032C7 C6460001                		mov	byte [bp],1
 14445 000032CB 4E                      		dec	si			; Point at last '/'
 14446                                  DOPCD:
 14447 000032CC 30DB                    		xor	bl,bl
 14448 000032CE 861C                    		xchg	bl,[si]			; Stick in a NUL
 14449 000032D0 E839EC                  		call	SETREST1
 14450 000032D3 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14451 000032D6 7408                    		je	short BADCDERRJ2
 14452 000032D8 B43B                    		mov	ah,CHDIR ; 3Bh
 14453 000032DA CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14454                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14455 000032DC 861C                    		xchg	bl,[si]
 14456 000032DE 73BF                    		jnc	short NOTPDIR_RETN
 14457                                  		
 14458                                  		; MSDOS 3.3
 14459                                  BADCDERRJ2:
 14460 000032E0 F9                      		stc
 14461 000032E1 E9FADE                  		jmp	BADCDERR
 14462                                  
 14463                                  		; MSDOS 6.0
 14464                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14465                                  ;EXTEND_SETUPJ:					;AN022;
 14466                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14467                                  ;BADCDERRJ2:
 14468                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14469                                  
 14470                                  ; =============== S U B	R O U T	I N E =======================================
 14471                                  
 14472                                  SETSTARS:
 14473                                  		;mov	[bp+2],di
 14474 000032E4 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14475                                  		;add	byte [bp+1],12
 14476 000032E7 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14477 000032EB A1[093F]                		mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14478 000032EE B90800                  		mov	cx,8
 14479 000032F1 F3AA                    		rep stosb
 14480 000032F3 86C4                    		xchg	al,ah
 14481 000032F5 AA                      		stosb
 14482 000032F6 86C4                    		xchg	al,ah
 14483 000032F8 B103                    		mov	cl,3
 14484 000032FA F3AA                    		rep stosb
 14485 000032FC 30C0                    		xor	al,al
 14486 000032FE AA                      		stosb
 14487 000032FF C3                      		retn
 14488                                  
 14489                                  ; =============== S U B	R O U T	I N E =======================================
 14490                                  
 14491                                  COMPNAME:
 14492 00003300 BE[7144]                		mov	si,DESTBUF	; do name translate of target
 14493 00003303 BF[F63F]                		mov	di,TRGXNAME	; save for name comparison
 14494 00003306 B460                    		mov	ah,XNAMETRANS ; 60h
 14495 00003308 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14496                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14497                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14498 0000330A BE[9F3F]                		mov	si,SRCXNAME	; get name translate of source
 14499 0000330D BF[F63F]                		mov	di,TRGXNAME	; get name translate of target
 14500 00003310 E8AEE6                  		call	STRCOMP
 14501 00003313 C3                      		retn
 14502                                  
 14503                                  ;============================================================================
 14504                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14505                                  ;============================================================================
 14506                                  ; 30/09/2018 - Retro DOS v3.0
 14507                                  
 14508                                  ;-----------------------------------------------------------------------;
 14509                                  ; ENTRY:								;
 14510                                  ;	DS:SI	Points input buffer					;
 14511                                  ;	ES:DI	Points to the token buffer				;
 14512                                  ;	BL	Special delimiter for this call 			;
 14513                                  ;		    Always checked last 				;
 14514                                  ;		    set it to space if there is no special delimiter	;
 14515                                  ; EXIT: 								;
 14516                                  ;	DS:SI	Points to next char in the input buffer 		;
 14517                                  ;	ES:DI	Points to the token buffer				;
 14518                                  ;	[STARTEL] Points to start of last element of path in token	;
 14519                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14520                                  ;	CX	Character count 					;
 14521                                  ;	BH	Condition Code						;
 14522                                  ;			Bit 1H of BH set if switch character		;
 14523                                  ;				Token buffer contains char after	;
 14524                                  ;				switch character			;
 14525                                  ;				BP has switch bits set (ORing only)	;
 14526                                  ;			Bit 2H of BH set if ? or * in token		;
 14527                                  ;				if * found element ? filled		;
 14528                                  ;			Bit 4H of BH set if path sep in token		;
 14529                                  ;			Bit 80H of BH set if the special delimiter	;
 14530                                  ;			   was skipped at the start of this token	;
 14531                                  ;		Token buffer always starts d: for non switch tokens	;
 14532                                  ;	CARRY SET							;
 14533                                  ;	    if CR on input						;
 14534                                  ;		token buffer not altered				;
 14535                                  ;									;
 14536                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14537                                  ; MODIFIES:								;
 14538                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14539                                  ;									;
 14540                                  ;-----------------------------------------------------------------------;
 14541                                  
 14542                                  ; Modifications to cparse: recognition of right and left parentheses
 14543                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14544                                  ;
 14545                                  ; Both modifications were installed in the course of adding a coherent
 14546                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14547                                  ; structure for command-line arguments. This parser relies on cparse to
 14548                                  ; recognize individual tokens.
 14549                                  ;
 14550                                  ; To process for-loops correctly, parentheses must therefore be
 14551                                  ; recognized as tokens. The upper-case conversion code was removed so
 14552                                  ; that commands (such as for and echo) would be able to use the "original"
 14553                                  ; text of the command line.
 14554                                  ;
 14555                                  ; Note also the modification to prevent the automatic conversion of colons
 14556                                  ; into spaces WITHIN THE SOURCE TEXT!
 14557                                  ;
 14558                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14559                                  ; on the command line.
 14560                                  ;
 14561                                  ; Alan L, OS/MSDOS				    14 August 1983
 14562                                  
 14563                                  ; ---------------------------------------------------------------------------
 14564                                  
 14565                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14566                                  
 14567                                  ;FSWITCH	EQU	8000h
 14568                                  ;FBADSWITCH	EQU	4000h
 14569                                  
 14570                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14571                                  
 14572                                  ; =============== S U B	R O U T	I N E =======================================
 14573                                  
 14574                                  CPARSE:
 14575 00003314 31C0                    		xor	ax,ax
 14576 00003316 893E[9745]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14577 0000331A A2[9A45]                		mov	[ELPOS],al		; Start in 8 char prefix
 14578 0000331D A2[9B45]                		mov	[SOURCE],al		; No skip delimiter yet
 14579 00003320 88C7                    		mov	bh,al			; Init nothing
 14580 00003322 9C                      		pushf				; save flags
 14581 00003323 57                      		push	di			; save the token buffer addrss
 14582 00003324 31C9                    		xor	cx,cx			; no chars in token buffer
 14583 00003326 880E[C643]              		mov	[COMMA],cl		; reset comma flag
 14584                                  
 14585                                  MOREDELIM:
 14586 0000332A AC                      		lodsb
 14587 0000332B E855E6                  		call	DELIM
 14588 0000332E 751D                    		jnz	short SCANCDONE
 14589 00003330 3C20                    		cmp	al,' '
 14590 00003332 74F6                    		jz	short MOREDELIM
 14591 00003334 3C09                    		cmp	al,9
 14592 00003336 74F2                    		jz	short MOREDELIM
 14593 00003338 8606[9B45]              		xchg	al,[SOURCE]
 14594 0000333C 08C0                    		or	al,al
 14595 0000333E 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14596 00003340 F6C780                  		test	bh,80h			; has a special char been found?
 14597 00003343 7405                    		jz	short NO_COMMA		; no - just exit
 14598 00003345 C606[C643]01            		mov	byte [COMMA],1		; set comma flag
 14599                                  
 14600                                  NO_COMMA:
 14601 0000334A E92201                  		jmp	X_DONE			; Nul argument
 14602                                  
 14603                                  SCANCDONE:
 14604 0000334D 803E[5644]01            		cmp	byte [CPYFLAG],1
 14605 00003352 7503                    		jnz	short CPCONT1
 14606 00003354 E8C9E4                  		call	UPCONV_MAPCALL
 14607                                  CPCONT1:
 14608 00003357 38D8                    		cmp	al,bl			; Special delimiter?
 14609 00003359 7505                    		jnz	short NOSPEC
 14610 0000335B 80CF80                  		or	bh,80h
 14611 0000335E EBCA                    		jmp	short MOREDELIM
 14612                                  
 14613                                  NOSPEC:
 14614 00003360 3C0D                    		cmp	al,0Dh			; a CR?
 14615 00003362 7503                    		jnz	short NCPERROR
 14616 00003364 E90301                  		jmp	CPERROR
 14617                                  
 14618                                  NCPERROR:
 14619 00003367 3A06[7542]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14620 0000336B 7503                    		jnz	short NA_SWITCH		; yes, process...
 14621 0000336D E90201                  		jmp	A_SWITCH
 14622                                  
 14623                                  NA_SWITCH:
 14624 00003370 B23A                    		mov	dl,':'
 14625 00003372 3814                    		cmp	[si],dl
 14626 00003374 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14627 00003376 E83F01                  		call	MOVE_CHAR
 14628 00003379 AC                      		lodsb				; Get the ':'
 14629 0000337A E83B01                  		call	MOVE_CHAR
 14630 0000337D 893E[9745]              		mov	[STARTEL],di
 14631 00003381 C606[9945]00            		mov	byte [ELCNT],0
 14632 00003386 E9A400                  		jmp	ANUM_TEST
 14633                                  
 14634                                  ANUM_CHARD:
 14635 00003389 893E[9745]              		mov	[STARTEL],di
 14636 0000338D C606[9945]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14637 00003392 803E[5644]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14638 00003397 751F                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14639 00003399 E872E6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14640 0000339C 751A                    		jnz	short ANUM_CHAR		; no
 14641 0000339E 50                      		push	ax
 14642 0000339F A0[8542]                		mov	al,[CURDRV]		; Insert drive spec
 14643 000033A2 0206[F03E]              		add	al,[CAPITAL_A]
 14644 000033A6 E80F01                  		call	MOVE_CHAR
 14645 000033A9 B03A                    		mov	al,':'
 14646 000033AB E80A01                  		call	MOVE_CHAR
 14647 000033AE 58                      		pop	ax
 14648 000033AF 893E[9745]              		mov	[STARTEL],di
 14649 000033B3 C606[9945]00            		mov	byte [ELCNT],0
 14650                                  
 14651                                  ANUM_CHAR:
 14652 000033B8 3A06[083F]              		cmp	al,[DOT_CHR]
 14653 000033BC 7509                    		jnz	short TESTQUEST
 14654 000033BE FE06[9A45]              		inc	byte [ELPOS]		; flag in extension
 14655 000033C2 C606[9945]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14656                                  TESTQUEST:
 14657 000033C7 3C3F                    		cmp	al,'?'
 14658 000033C9 7503                    		jnz	short TESTSPLAT
 14659 000033CB 80CF02                  		or	bh,2
 14660                                  TESTSPLAT:
 14661 000033CE 3A06[FD3E]              		cmp	al,[STAR]
 14662 000033D2 7530                    		jnz	short TESTPATH
 14663 000033D4 80CF02                  		or	bh,2
 14664 000033D7 803E[A745]00            		cmp	byte [EXPAND_STAR],0
 14665 000033DC 7504                    		jnz	short EXPAND_FILENAME
 14666 000033DE EB24                    		jmp	short TESTPATH
 14667                                  
 14668                                  BADPERR2J:
 14669 000033E0 EB7F                    		jmp	BADPERR2
 14670                                  
 14671                                  		;db	0E9h
 14672                                  		;db	7Eh	
 14673                                  		;db	0
 14674                                  
 14675                                  EXPAND_FILENAME:
 14676 000033E2 B407                    		mov	ah,7
 14677 000033E4 803E[9A45]00            		cmp	byte [ELPOS],0
 14678 000033E9 7402                    		jz	short GOTELCNT
 14679 000033EB B402                    		mov	ah,2
 14680                                  GOTELCNT:
 14681 000033ED B03F                    		mov	al,'?'
 14682 000033EF 2A26[9945]              		sub	ah,[ELCNT]
 14683 000033F3 72EB                    		jb	short BADPERR2J
 14684 000033F5 86E1                    		xchg	ah,cl
 14685 000033F7 E309                    		jcxz	TESTPATHX
 14686                                  QMOVE:
 14687 000033F9 86E1                    		xchg	ah,cl
 14688 000033FB E8BA00                  		call	MOVE_CHAR
 14689 000033FE 86E1                    		xchg	ah,cl
 14690 00003400 E2F7                    		loop	QMOVE
 14691                                  TESTPATHX:
 14692 00003402 86E1                    		xchg	ah,cl
 14693                                  TESTPATH:
 14694 00003404 E807E6                  		call	PATHCHRCMP
 14695 00003407 7521                    		jnz	short NOTSPECIAL
 14696 00003409 80CF04                  		or	bh,4
 14697 0000340C 803E[A745]00            		cmp	byte [EXPAND_STAR],0
 14698 00003411 7405                    		jz	short NO_ERR_CHECK
 14699 00003413 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14700 00003416 754F                    		jnz	short BADPERR
 14701                                  NO_ERR_CHECK:
 14702 00003418 893E[9745]              		mov	[STARTEL],di	  ; New element
 14703 0000341C FF06[9745]              		inc	word [STARTEL]	  ; Point to char after /
 14704 00003420 C606[9945]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14705 00003425 C606[9A45]00            		mov	byte [ELPOS],0
 14706                                  NOTSPECIAL:
 14707 0000342A E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14708                                  ANUM_TEST:
 14709 0000342D AC                      		lodsb
 14710 0000342E 803E[5644]01            		cmp	byte [CPYFLAG],1
 14711 00003433 7503                    		jnz	short CPCONT3
 14712 00003435 E8E8E3                  		call	UPCONV_MAPCALL
 14713                                  CPCONT3:
 14714 00003438 E848E5                  		call	DELIM
 14715 0000343B 7432                    		jz	short X_DONE
 14716 0000343D 3C0D                    		cmp	al,0Dh
 14717 0000343F 742E                    		jz	short X_DONE
 14718 00003441 3A06[7542]              		cmp	al,[SWITCHAR]
 14719 00003445 7428                    		jz	short X_DONE
 14720 00003447 38D8                    		cmp	al,bl
 14721 00003449 7424                    		jz	short X_DONE
 14722 0000344B 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14723 0000344D 750F                    		jnz	short ANUM_CHARJ
 14724                                  
 14725                                  ; Modification made for parseline.
 14726                                  ; Why would it be necessary to change colons to spaces? In this
 14727                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14728                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14729                                  
 14730 0000344F 803E[5644]02            		cmp	byte [CPYFLAG],2
 14731 00003454 7505                    		jnz	short CPCONT4
 14732 00003456 E85F00                  		call	MOVE_CHAR
 14733 00003459 EBD2                    		jmp	short ANUM_TEST
 14734                                  
 14735                                  CPCONT4:
 14736 0000345B 46                      		inc	si		;Skip the ':'
 14737 0000345C EB11                    		jmp	short X_DONE
 14738                                  
 14739                                  ANUM_CHARJ:
 14740 0000345E E957FF                  		jmp	ANUM_CHAR
 14741                                  
 14742                                  BADPERR2:
 14743 00003461 BA[4C3D]                		mov	dx,BADCPMESPTR
 14744 00003464 E9C4E7                  		jmp	CERROR
 14745                                  
 14746                                  BADPERR:
 14747 00003467 E974DD                  		jmp	BADCDERR  ; MSDOS 3.3	
 14748                                  
 14749                                  CPERROR:
 14750 0000346A 4E                      		dec	si		; adjust the pointer
 14751 0000346B 5F                      		pop	di		; retrive token buffer address
 14752 0000346C 9D                      		popf			; restore flags
 14753 0000346D F9                      		stc			; set the carry bit
 14754 0000346E C3                      		retn
 14755                                  
 14756                                  X_DONE:
 14757 0000346F 4E                      		dec	si		; adjust for next round
 14758                                  
 14759                                  ; Mod to recognize right and left parens as integral tokens.
 14760                                  ;X_DONE2:
 14761 00003470 EB3F                    		jmp	short OUT_TOKEN
 14762                                  
 14763                                  A_SWITCH:
 14764 00003472 80CF01                  		or	bh,1		; Indicate switch
 14765 00003475 81CD0080                		or	bp,FSWITCH ; 8000h
 14766 00003479 E8FFE4                  		call	SCANOFF
 14767 0000347C 46                      		inc	si
 14768 0000347D 3C0D                    		cmp	al,0Dh
 14769 0000347F 7509                    		jnz	short STORE_SWT
 14770 00003481 B000                    		mov	al,0
 14771 00003483 AA                      		stosb
 14772 00003484 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14773 00003488 EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14774                                  					;   BP = fSwitch but no switch
 14775                                  					;   bit is set (unknown switch)
 14776                                  
 14777                                  STORE_SWT:
 14778 0000348A E82B00                  		call	MOVE_CHAR	; store the character
 14779                                  
 14780                                  ; This upconv call must stay.  It is used to identify copy-switches
 14781                                  ; on the command line, and won't store anything into the output buffer.
 14782                                  
 14783 0000348D E890E3                  		call	UPCONV_MAPCALL
 14784 00003490 06                      		push	es
 14785 00003491 57                      		push	di
 14786 00003492 51                      		push	cx
 14787 00003493 0E                      		push	cs
 14788 00003494 07                      		pop	es
 14789 00003495 BF[1D3F]                		mov	di,SWITCH_LIST ; "VBAPW"
 14790 00003498 B90500                  		mov	cx,SWCOUNT ; 5
 14791 0000349B 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14792 0000349F F2AE                    		repne scasb
 14793 000034A1 750B                    		jnz	short OUT_TOKENP
 14794 000034A3 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14795 000034A7 B80100                  		mov	ax,1
 14796 000034AA D3E0                    		shl	ax,cl
 14797 000034AC 09C5                    		or	bp,ax
 14798                                  OUT_TOKENP:
 14799 000034AE 59                      		pop	cx
 14800 000034AF 5F                      		pop	di
 14801 000034B0 07                      		pop	es
 14802                                  OUT_TOKEN:
 14803 000034B1 B000                    		mov	al,0		; null at the end
 14804 000034B3 AA                      		stosb
 14805 000034B4 5F                      		pop	di		; restore token buffer pointer	
 14806 000034B5 9D                      		popf
 14807 000034B6 F8                      		clc			; clear carry flag
 14808 000034B7 C3                      		retn
 14809                                  
 14810                                  ; =============== S U B	R O U T	I N E =======================================
 14811                                  
 14812                                  MOVE_CHAR:
 14813 000034B8 AA                      		stosb			; store char in token buffer
 14814 000034B9 41                      		inc	cx		; increment char count
 14815 000034BA FE06[9945]              		inc	byte [ELCNT]	; increment element count for * substi
 14816 000034BE C3                      		retn
 14817                                  
 14818                                  ;============================================================================
 14819                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 14820                                  ;============================================================================
 14821                                  ; 30/09/2018 - Retro DOS v3.0
 14822                                  
 14823                                  ; BREAK	<Message Printing Routine>
 14824                                  
 14825                                  ;
 14826                                  ;	MSDOS V3.00 PRINT
 14827                                  ;
 14828                                  ;	Message Printing Routine
 14829                                  ;
 14830                                  
 14831                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 14832                                  ;
 14833                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 14834                                  ;
 14835                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 14836                                  ;
 14837                                  ; Characters are output to PFHandle according to the
 14838                                  ; specifications contained in the Control String.
 14839                                  ;
 14840                                  ; The conversion characters are as follow:
 14841                                  ;
 14842                                  ;               %c - output the next argument as a character
 14843                                  ;               %s - output the next argument as a string
 14844                                  ;               %x - output the next argument as a hexidecimal number
 14845                                  ;                    using abcedf
 14846                                  ;               %X - output the next argument as a hexidecimal number
 14847                                  ;                    using ABCDEF
 14848                                  ;               %d - output the next argument as a decimal number
 14849                                  ;
 14850                                  ;
 14851                                  ; Other format specifiers that may precede the conversion character are:
 14852                                  ;
 14853                                  ;               - (minus sign) - causes the field to be left-adjusted
 14854                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 14855                                  ;               n - digit specifing the minimum field width (default to 1)
 14856                                  ;               L - specifing a long integer
 14857                                  ;
 14858                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 14859                                  ;   to an argument list.
 14860                                  ;
 14861                                  ;   ____________________
 14862                                  ;   |   Ret Addr       |      <= SP
 14863                                  ;   --------------------
 14864                                  ;   |  Ptr to Arg List |
 14865                                  ;   --------------------
 14866                                  ;
 14867                                  ;   And the argument list contains the following:
 14868                                  ;
 14869                                  ;       String_ptr                  (a pointer to the control string)
 14870                                  ;       Arg 1
 14871                                  ;       Arg 2
 14872                                  ;         .
 14873                                  ;         .
 14874                                  ;         .
 14875                                  ;       Arg n-1
 14876                                  ;       Arg n
 14877                                  ;
 14878                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 14879                                  ;   or character.
 14880                                  ;
 14881                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 14882                                  
 14883                                  
 14884                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 14885                                  
 14886                                  ; =============== S U B	R O U T	I N E =======================================
 14887                                  
 14888                                  PRINTF_INIT:
 14889 000034BF E81100                  		call	STD_PRINTF
 14890 000034C2 CB                      		retf
 14891                                  
 14892                                  ; =============== S U B	R O U T	I N E =======================================
 14893                                  
 14894                                  PRINTF_CRLF:
 14895 000034C3 E80D00                  		call	STD_PRINTF
 14896 000034C6 E8A5E4                  		call	CRLF2
 14897 000034C9 C3                      		retn
 14898                                  
 14899                                  ; =============== S U B	R O U T	I N E =======================================
 14900                                  
 14901                                  STD_EPRINTF:
 14902 000034CA 2EC706[393F]0200        		mov	word [cs:PRINTF_HANDLE],2
 14903 000034D1 EB07                    		jmp	short NEW_PRINTF
 14904                                  
 14905                                  ; =============== S U B	R O U T	I N E =======================================
 14906                                  
 14907                                  STD_PRINTF:
 14908                                  
 14909                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 14910                                  
 14911 000034D3 2EC706[393F]0100        		mov	word [cs:PRINTF_HANDLE],1
 14912                                  
 14913                                  NEW_PRINTF:				;Save the callers' registers
 14914 000034DA FC                      		cld
 14915 000034DB 52                      		push	dx
 14916 000034DC 55                      		push	bp
 14917 000034DD 89E5                    		mov	bp,sp
 14918 000034DF 51                      		push	cx
 14919 000034E0 53                      		push	bx
 14920 000034E1 50                      		push	ax
 14921 000034E2 57                      		push	di
 14922 000034E3 56                      		push	si
 14923 000034E4 06                      		push	es
 14924 000034E5 1E                      		push	ds
 14925 000034E6 0E                      		push	cs
 14926 000034E7 07                      		pop	es		;ES points to Printf segment
 14927 000034E8 BF[3B3F]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 14928 000034EB 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 14929                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 14930 000034EE 3E8B7600                		mov	si,[ds:bp] ; bp
 14931 000034F2 83C502                  		add	bp,2
 14932 000034F5 31DB                    		xor	bx,bx
 14933 000034F7 E8F901                  		call	CLEAR_FLAGS	; initialize the world
 14934                                  
 14935                                  GET_CHAR:
 14936 000034FA AC                      		lodsb			;Get a character
 14937 000034FB 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 14938 000034FD 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 14939 000034FF 08C0                    		or	al,al		;Is it the end of the control string?
 14940 00003501 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 14941                                  PRINTF_PERCENT:				
 14942 00003503 E88801                  		call	OUTCHR		;Otherwise store the character
 14943 00003506 EBF2                    		jmp	short GET_CHAR	;And go get another
 14944                                  
 14945                                  PRINTF_DONE:
 14946 00003508 E88B01                  		call	FLUSH
 14947 0000350B 1F                      		pop	ds
 14948 0000350C 07                      		pop	es
 14949 0000350D 5E                      		pop	si
 14950 0000350E 5F                      		pop	di
 14951 0000350F 58                      		pop	ax
 14952 00003510 5B                      		pop	bx
 14953 00003511 59                      		pop	cx
 14954 00003512 5D                      		pop	bp
 14955 00003513 5A                      		pop	dx
 14956 00003514 C3                      		retn
 14957                                  
 14958                                  CONV_CHAR:
 14959 00003515 2EC606[303F]00          		mov	byte [cs:PRINTF_LEFT],0
 14960                                  
 14961                                  NXT_CONV_CHAR:	
 14962                                  		;Look for any format specifiers preceeding the conversion character
 14963 0000351B AC                      		lodsb
 14964 0000351C 3C25                    		cmp	al,'%'			;Just print the %
 14965 0000351E 74E3                    		jz	short PRINTF_PERCENT
 14966 00003520 2E3A06[FE3E]            		cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 14967 00003525 7448                    		jz	short LEFT_ADJ
 14968 00003527 2E3A06[FF3E]            		cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 14969 0000352C 74E7                    		jz	short CONV_CHAR
 14970 0000352E 2E3A06[003F]            		cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 14971 00003533 7442                    		jz	short LONG_INT
 14972 00003535 2E3A06[013F]            		cmp	al,[cs:char_l]	 ; "l"		
 14973 0000353A 743B                    		jz	short LONG_INT
 14974 0000353C 3C30                    		cmp	al,'0'			;Is it a precision specification
 14975 0000353E 723F                    		jb	short LOOK_CONV_CHAR
 14976 00003540 3C39                    		cmp	al,'9'
 14977 00003542 773B                    		ja	short LOOK_CONV_CHAR
 14978 00003544 3C30                    		cmp	al,'0'
 14979 00003546 750F                    		jnz	short NOT_PAD
 14980 00003548 2E833E[343F]00          		cmp	word [cs:PRINTF_WIDTH],0
 14981 0000354E 7507                    		jnz	short NOT_PAD
 14982 00003550 B430                    		mov	ah,'0'
 14983 00003552 2E8826[383F]            		mov	[cs:PAD_CHAR],ah
 14984                                  NOT_PAD:					;Adjust decimal place on precision
 14985 00003557 50                      		push	ax
 14986 00003558 2EA1[343F]              		mov	ax,[cs:PRINTF_WIDTH]
 14987 0000355C B90A00                  		mov	cx,10
 14988 0000355F F7E1                    		mul	cx
 14989 00003561 5A                      		pop	dx
 14990 00003562 30F6                    		xor	dh,dh
 14991 00003564 80EA30                  		sub	dl,'0'
 14992 00003567 01D0                    		add	ax,dx
 14993 00003569 2EA3[343F]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 14994 0000356D EBAC                    		jmp	short NXT_CONV_CHAR
 14995                                  
 14996                                  LEFT_ADJ:
 14997 0000356F 2EC606[303F]01          		mov	byte [cs:PRINTF_LEFT],1
 14998 00003575 EBA4                    		jmp	short NXT_CONV_CHAR
 14999                                  
 15000                                  LONG_INT:
 15001 00003577 2E800E[313F]01          		or	byte [cs:PRINTF_LONG],1
 15002 0000357D EB9C                    		jmp	short NXT_CONV_CHAR
 15003                                  
 15004                                  LOOK_CONV_CHAR:
 15005 0000357F 24DF                    		and	al,0DFh
 15006 00003581 2E3A06[073F]            		cmp	al,[cs:CHAR_X]	 ; "X"
 15007 00003586 741B                    		jz	short HEX_UP
 15008 00003588 2E3A06[043F]            		cmp	al,[cs:CHAR_D]	 ; "D"
 15009 0000358D 741D                    		jz	short DECIMAL
 15010 0000358F 2E3A06[053F]            		cmp	al,[cs:CHAR_C]	 ; "C"
 15011 00003594 741F                    		jz	short C_PUT_CHAR
 15012 00003596 2E3A06[063F]            		cmp	al,[cs:CHAR_S]	 ; "S"
 15013 0000359B 7426                    		jz	short S_PUT_STRG
 15014 0000359D E85301                  		call	CLEAR_FLAGS
 15015 000035A0 E957FF                  		jmp	GET_CHAR
 15016                                  
 15017                                  HEX_UP:
 15018 000035A3 2EC706[363F]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15019 000035AA EB6C                    		jmp	short CONV_TO_NUM
 15020                                  DECIMAL:
 15021 000035AC 2EC706[363F]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15022 000035B3 EB63                    		jmp	short CONV_TO_NUM
 15023                                  
 15024                                  C_PUT_CHAR:
 15025 000035B5 E82E01                  		call	NEXT_CHRS
 15026 000035B8 88D0                    		mov	al,dl
 15027 000035BA E8D100                  		call	OUTCHR
 15028 000035BD E83301                  		call	CLEAR_FLAGS
 15029 000035C0 E937FF                  		jmp	GET_CHAR
 15030                                  
 15031                                  S_PUT_STRG:
 15032 000035C3 56                      		push	si			;Save pointer to control string
 15033 000035C4 E81F01                  		call	NEXT_CHRS
 15034 000035C7 89D6                    		mov	si,dx
 15035                                  S_PUT_1:
 15036 000035C9 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15037 000035CE 09C9                    		or	cx,cx
 15038 000035D0 740B                    		jz	short S_PUT_2
 15039 000035D2 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15040 000035D8 7503                    		jnz	short S_PUT_2
 15041 000035DA E82700                  		call	PAD_STRING
 15042                                  S_PUT_2:
 15043 000035DD 56                      		push	si
 15044                                  S_PUT_3:
 15045 000035DE AC                      		lodsb
 15046 000035DF 08C0                    		or	al,al
 15047 000035E1 7405                    		jz	short S_PUT_4
 15048 000035E3 E8A800                  		call	OUTCHR			;Put it into our buffer
 15049 000035E6 EBF6                    		jmp	short S_PUT_3
 15050                                  S_PUT_4:
 15051 000035E8 5E                      		pop	si
 15052 000035E9 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15053 000035EF 740C                    		jz	short C_S_END
 15054 000035F1 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15055 000035F6 09C9                    		or	cx,cx
 15056 000035F8 7403                    		jz	short C_S_END
 15057 000035FA E80700                  		call	PAD_STRING
 15058                                  C_S_END:
 15059 000035FD 5E                      		pop	si			;Restore control string pointer
 15060 000035FE E8F200                  		call	CLEAR_FLAGS
 15061 00003601 E9F6FE                  		jmp	GET_CHAR		;Go get another character	
 15062                                  
 15063                                  
 15064                                  ; =============== S U B	R O U T	I N E =======================================
 15065                                  
 15066                                  PAD_STRING:
 15067 00003604 31D2                    		xor	dx,dx
 15068 00003606 56                      		push	si
 15069                                  
 15070                                  COUNT_LOOP:
 15071 00003607 AC                      		lodsb
 15072 00003608 08C0                    		or	al,al
 15073 0000360A 7403                    		jz	short COUNT_DONE
 15074 0000360C 42                      		inc	dx
 15075 0000360D EBF8                    		jmp	short COUNT_LOOP
 15076                                  
 15077                                  COUNT_DONE:
 15078 0000360F 5E                      		pop	si
 15079 00003610 29D1                    		sub	cx,dx
 15080 00003612 7603                    		jbe	short COUNT_RET
 15081 00003614 E86700                  		call	PAD
 15082                                  
 15083                                  COUNT_RET:
 15084 00003617 C3                      		retn
 15085                                  
 15086                                  ; ---------------------------------------------------------------------------
 15087                                  
 15088                                  CONV_TO_NUM:
 15089 00003618 E8CB00                  		call	NEXT_CHRS
 15090 0000361B 89D0                    		mov	ax,dx
 15091 0000361D 31D2                    		xor	dx,dx
 15092 0000361F 2E803E[313F]00          		cmp	byte [cs:PRINTF_LONG],0 
 15093                                  				;Is this is a short or long integer?
 15094 00003625 7403                    		jz	short NOT_LONG_INT
 15095 00003627 E8BC00                  		call	NEXT_CHRS
 15096                                  
 15097                                  NOT_LONG_INT:
 15098 0000362A 53                      		push	bx
 15099 0000362B 56                      		push	si
 15100 0000362C 2E8B36[363F]            		mov	si,[cs:PRINTF_BASE]
 15101 00003631 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15102 00003636 E80B00                  		call	PNUM
 15103 00003639 5E                      		pop	si
 15104 0000363A 5B                      		pop	bx
 15105 0000363B E84000                  		call	PAD
 15106 0000363E E8B200                  		call	CLEAR_FLAGS
 15107 00003641 E9B6FE                  		jmp	GET_CHAR
 15108                                  
 15109                                  
 15110                                  ; =============== S U B	R O U T	I N E =======================================
 15111                                  
 15112                                  PNUM:
 15113 00003644 49                      		dec	cx
 15114 00003645 50                      		push	ax
 15115 00003646 89D0                    		mov	ax,dx
 15116 00003648 31D2                    		xor	dx,dx
 15117 0000364A F7F6                    		div	si
 15118 0000364C 89C3                    		mov	bx,ax
 15119 0000364E 58                      		pop	ax
 15120 0000364F F7F6                    		div	si
 15121 00003651 87DA                    		xchg	bx,dx
 15122 00003653 50                      		push	ax
 15123 00003654 09D0                    		or	ax,dx
 15124 00003656 58                      		pop	ax
 15125 00003657 7407                    		jz	short DO_PAD
 15126 00003659 53                      		push	bx
 15127 0000365A E8E7FF                  		call	PNUM
 15128 0000365D 5B                      		pop	bx
 15129 0000365E EB0B                    		jmp	short REM
 15130                                  
 15131                                  DO_PAD:
 15132 00003660 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15133 00003666 7503                    		jnz	short REM
 15134 00003668 E81300                  		call	PAD
 15135                                  REM:
 15136 0000366B 80FB0A                  		cmp	bl,10
 15137 0000366E 7203                    		jb	short NOT_HEX
 15138 00003670 83C306                  		add	bx,6
 15139                                  NOT_HEX:
 15140 00003673 2E8A87[1037]            		mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 15141 00003678 51                      		push	cx
 15142 00003679 E81200                  		call	OUTCHR
 15143 0000367C 59                      		pop	cx
 15144 0000367D C3                      		retn
 15145                                  
 15146                                  ; =============== S U B	R O U T	I N E =======================================
 15147                                  
 15148                                  PAD:
 15149 0000367E 09C9                    		or	cx,cx
 15150 00003680 7E0B                    		jle	short PAD_DONE
 15151 00003682 2EA0[383F]              		mov	al,[cs:PAD_CHAR]
 15152                                  PAD_LOOP:
 15153 00003686 51                      		push	cx
 15154 00003687 E80400                  		call	OUTCHR
 15155 0000368A 59                      		pop	cx
 15156 0000368B E2F9                    		loop	PAD_LOOP
 15157                                  PAD_DONE:
 15158 0000368D C3                      		retn
 15159                                  
 15160                                  ; =============== S U B	R O U T	I N E =======================================
 15161                                  
 15162                                  OUTCHR:
 15163 0000368E AA                      		stosb
 15164 0000368F 81FF[9F3F]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15165 00003693 7401                    		je	short FLUSH
 15166                                  OUTCHR_RETN:
 15167 00003695 C3                      		retn
 15168                                  
 15169                                  ; =============== S U B	R O U T	I N E =======================================
 15170                                  
 15171                                  FLUSH:
 15172 00003696 B9[3B3F]                		mov	cx,PRINTF_BUF
 15173 00003699 87CF                    		xchg	cx,di
 15174 0000369B 29F9                    		sub	cx,di
 15175 0000369D 74F6                    		jz	short OUTCHR_RETN
 15176                                  WRITE_CHARS:
 15177 0000369F 53                      		push	bx
 15178 000036A0 2E8B1E[393F]            		mov	bx,[cs:PRINTF_HANDLE]
 15179 000036A5 1E                      		push	ds
 15180 000036A6 0E                      		push	cs
 15181 000036A7 1F                      		pop	ds
 15182 000036A8 BA[3B3F]                		mov	dx,PRINTF_BUF
 15183 000036AB B440                    		mov	ah,WRITE ; 40h
 15184 000036AD CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15185                                  					; BX = file handle, CX = number	of bytes to write,
 15186                                  					; DS:DX -> buffer
 15187 000036AF 730A                    		jnb	short FOOB2_1
 15188 000036B1 E818E8                  		call	GET_EXT_ERR_NUMBER
 15189 000036B4 83F806                  		cmp	ax,6
 15190 000036B7 742A                    		jz	short FOOB2_4
 15191 000036B9 EB04                    		jmp	short FOOB2_2
 15192                                  
 15193                                  FOOB2_1:
 15194 000036BB 39C1                    		cmp	cx,ax
 15195 000036BD 7424                    		jz	short FOOB2_4
 15196                                  FOOB2_2:
 15197 000036BF 89D3                    		mov	bx,dx
 15198 000036C1 01C3                    		add	bx,ax
 15199 000036C3 803F1A                  		cmp	byte [bx],1Ah
 15200 000036C6 741B                    		jz	short FOOB2_4
 15201 000036C8 1F                      		pop	ds
 15202 000036C9 5B                      		pop	bx
 15203 000036CA 2E8E06[7142]            		mov	es,[cs:RESSEG]
 15204 000036CF BA[3938]                		mov	dx,NOSPACEPTR
 15205 000036D2 26F6065A0CFF            		test	byte [es:PIPEFLAG],0FFh
 15206 000036D8 7406                    		jz	short PRINT_ERR_EXIT
 15207 000036DA E8B1EC                  		call	PIPEOFF
 15208 000036DD BA[D23C]                		mov	dx,PIPEEMESPTR
 15209                                  PRINT_ERR_EXIT:	
 15210 000036E0 E948E5                  		jmp	CERROR
 15211                                  
 15212                                  FOOB2_4:
 15213 000036E3 1F                      		pop	ds
 15214 000036E4 5B                      		pop	bx
 15215 000036E5 C3                      		retn
 15216                                  
 15217                                  ; =============== S U B	R O U T	I N E =======================================
 15218                                  
 15219                                  NEXT_CHRS:
 15220 000036E6 56                      		push	si		;Save pointer to control string
 15221 000036E7 89DE                    		mov	si,bx		;Get index into argument list
 15222 000036E9 83C302                  		add	bx,2		;Increment the index
 15223 000036EC 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15224 000036EF 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15225 000036F1 5E                      		pop	si
 15226 000036F2 C3                      		retn
 15227                                  
 15228                                  ; =============== S U B	R O U T	I N E =======================================
 15229                                  
 15230                                  CLEAR_FLAGS:
 15231 000036F3 31C0                    		xor	ax,ax
 15232 000036F5 2EA2[303F]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15233 000036F9 2EA2[313F]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15234 000036FD 2EA3[343F]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15235 00003701 B020                    		mov	al,' '			
 15236 00003703 2EA2[383F]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15237 00003707 C3                      		retn
 15238                                  
 15239                                  ; ---------------------------------------------------------------------------
 15240                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15241                                  
 15242                                  		; times 7 db 0
 15243                                  
 15244                                  ;============================================================================
 15245                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15246                                  ;============================================================================
 15247                                  ; 30/09/2018 - Retro DOS v3.0
 15248                                  
 15249                                  ; TITLE	COMMAND Transient Initialized DATA
 15250                                  
 15251                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15252                                  ;initial values at the beginning of each command cycle. It is
 15253                                  ;included in the transient checksum area. If values in TRANDATA
 15254                                  ;change, the transient will be reloaded for the next command cycle.
 15255                                  
 15256 00003708 90<rept>                align 16
 15257                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15258                                  
 15259 00003710 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15260 00003719 39414243444546     
 15261 00003720 255300                  _3740h:		db '%S',0
 15262 00003723 [2037]                  ARG_BUF_PTR:	dw _3740h
 15263 00003725 [2737]                  		dw _3747h
 15264 00003727 [C843]                  _3747h:		dw ARG_BUF ; _43E8h
 15265 00003729 25532000                _3749h:		db '%S ',0
 15266 0000372D [2937]                  STRINGBUF1PTR:	dw _3749h
 15267 0000372F [4844]                  		dw STRING_PTR_1 ; _4468h
 15268 00003731 25396C6400              _3751h:		db '%9ld',0
 15269 00003736 [3137]                  FSIZEMESPTR:	dw _3751h
 15270 00003738 [4A44]                  		dw FILESIZE_L ; _446Ah
 15271 0000373A [4C44]                  		dw FILESIZE_H ; _446Ch
 15272 0000373C 255300                  _375Ch:		db '%S',0
 15273 0000373F [3C37]                  STRINGBUF2PTR:	dw _375Ch
 15274 00003741 [4E44]                  		dw STRING_PTR_2 ; _446Eh
 15275 00003743 0900                    _3763h:		db 9,0
 15276 00003745 [4337]                  TABPTR:		dw _3763h
 15277 00003747 0D0A                    _3767h:		db 0Dh,0Ah
 15278 00003749 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15279 00003752 65206D697373696E67-
 15280 0000375B 0D0A00             
 15281 0000375E [4737]                  BADPATHPTR:	dw _3767h
 15282 00003760 0D0A                    _3780h:		db 0Dh,0Ah
 15283 00003762 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15284 0000376B 736B20776974682062-
 15285 00003774 617463682066696C65-
 15286 0000377D 0D0A               
 15287 0000377F 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15288 00003788 20616E79206B657920-
 15289 00003791 7768656E2072656164-
 15290 0000379A 790D0A00           
 15291 0000379E [6037]                  INSERTDSKPTR:	dw _3780h
 15292 000037A0 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15293 000037A9 6E64206F722066696C-
 15294 000037B2 65206E616D650D0A00 
 15295 000037BB [A037]                  BADNAMPTR:	dw _37C0h
 15296 000037BD 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15297 000037C6 2066696C65206E616D-
 15298 000037CF 65206F722046696C65-
 15299 000037D8 206E6F7420666F756E-
 15300 000037E1 640D0A00           
 15301 000037E5 [BD37]                  RENERRPTR:	dw _37DDh
 15302 000037E7 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15303 000037F0 666F756E640D0A00   
 15304 000037F8 [E737]                  FNOTFOUNDPTR:	dw _3807h
 15305 000037FA 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15306 00003803 666F756E640D0A00   
 15307 0000380B [FA37]                  PNOTFOUNDPTR:	dw _381Ah
 15308 0000380D 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15309 00003816 6E6965640D0A00     
 15310 0000381D [0D38]                  ACCDENPTR:	dw _382Dh
 15311 0000381F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15312 00003828 656E74206469736B20-
 15313 00003831 73706163650D0A00   
 15314 00003839 [1F38]                  NOSPACEPTR:	dw _383Fh
 15315 0000383B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15316 00003844 7669726F6E6D656E74-
 15317 0000384D 2073706163650D0A00 
 15318 00003856 [3B38]                  ENVERRPTR:	dw _385Bh
 15319 00003858 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15320 00003861 74696F6E206572726F-
 15321 0000386A 720D0A00           
 15322 0000386E 7838                    FULDIRPTR:	dw 3878h
 15323 00003870 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15324 00003879 6F7420626520636F70-
 15325 00003882 696564206F6E746F20-
 15326 0000388B 697473656C660D0A00 
 15327 00003894 [7038]                  OVERWRPTR:	dw _3890h
 15328 00003896 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15329 0000389F 662064657374696E61-
 15330 000038A8 74696F6E206C6F7374-
 15331 000038B1 206265666F72652063-
 15332 000038BA 6F70790D0A00       
 15333 000038C0 [9638]                  LOSTERRPTR:	dw _38B6h
 15334 000038C2 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15335 000038CB 696C656E616D65206F-
 15336 000038D4 722066696C65206E6F-
 15337 000038DD 7420666F756E640D0A-
 15338 000038E6 00                 
 15339 000038E7 [C238]                  INORNOTPTR:	dw _38E2h
 15340 000038E9 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15341 000038F2 732920636F70696564-
 15342 000038FB 0D0A00             
 15343 000038FE [E938]                  COPIEDPTR:	dw _3909h
 15344 00003900 [5044]                  		dw COPY_NUM ; _4470h
 15345 00003902 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15346 0000390B 73292000           
 15347 0000390F [0239]                  DIRMESPTR:	dw _3922h
 15348 00003911 [5744]                  		dw DIR_NUM  ; _4477h
 15349 00003913 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15350 0000391C 7320667265650D0A00 
 15351 00003925 [1339]                  BYTEMESPTR:	dw _3933h
 15352 00003927 [5944]                  		dw BYTES_FREE   ; _4479h
 15353 00003929 [5B44]                  		dw BYTES_FREE+2 ; _447Bh
 15354 0000392B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15355 00003934 726976652073706563-
 15356 0000393D 696669636174696F6E-
 15357 00003946 0D0A00             
 15358 00003949 [2B39]                  BADDRVPTR:	dw _394Bh
 15359 0000394B 0D0A                    _396Bh:		db 0Dh,0Ah
 15360 0000394D 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15361 00003956 20253564206E6F7420-
 15362 0000395F 707265706172656420-
 15363 00003968 666F72207379737465-
 15364 00003971 6D0D0A00           
 15365 00003975 [4B39]                  CPNOTSETPTR:	dw _396Bh
 15366 00003977 [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15367 00003979 0D0A                    _3999h:		db 0Dh,0Ah
 15368 0000397B 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15369 00003984 20253564206E6F7420-
 15370 0000398D 707265706172656420-
 15371 00003996 666F7220616C6C2064-
 15372 0000399F 6576696365730D0A00 
 15373 000039A8 [7939]                  CPNOTALLPTR:	dw _3999h
 15374 000039AA [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15375 000039AC 0D0A                    _39CCh:		db 0Dh,0Ah
 15376 000039AE 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15377 000039B7 646520706167653A20-
 15378 000039C0 2535640D0A00       
 15379 000039C6 [AC39]                  CPACTIVEPTR:	dw _39CCh
 15380 000039C8 [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15381 000039CA 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15382 000039D3 72697665206973206E-
 15383 000039DC 6F206C6F6E67657220-
 15384 000039E5 76616C696400       
 15385 000039EB [CA39]                  BADCURDRVPTR:	dw _39EAh
 15386 000039ED 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15387 000039F6 6B6579207768656E20-
 15388 000039FF 7265616479202E202E-
 15389 00003A08 202E2000           
 15390 00003A0C [ED39]                  PAUSEMESPTR:	dw _3A0Dh
 15391 00003A0E 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15392 00003A17 6172616D657465720D-
 15393 00003A20 0A00               
 15394 00003A22 [0E3A]                  BADPARMPTR:	dw _3A2Eh
 15395 00003A24 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15396 00003A2D 576564546875467269-
 15397 00003A36 536174             
 15398 00003A39 0D0A                    _3A59h:		db 0Dh,0Ah
 15399 00003A3B 496E76616C69642064-     		db 'Invalid date',0
 15400 00003A44 61746500           
 15401 00003A48 [393A]                  BADDATPTR:	dw _3A59h
 15402 00003A4A 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15403 00003A53 6174652069732000   
 15404 00003A5B [4A3A]                  CURDATPTR:	dw _3A6Ah
 15405 00003A5D 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15406 00003A5F 456E746572206E6577-     		db 'Enter new date ',0
 15407 00003A68 20646174652000     
 15408 00003A6F [5D3A]                  NEWDATPTR:	dw _3A7Dh
 15409 00003A71 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15410 00003A7A 293A2000           
 15411 00003A7E [713A]                  USADATPTR:	dw _3A91h
 15412 00003A80 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15413 00003A89 293A2000           
 15414 00003A8D [803A]                  EURDATPTR:	dw _3AA0h
 15415 00003A8F 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15416 00003A98 293A2000           
 15417 00003A9C [8F3A]                  JAPDATPTR:	dw _3AAFh
 15418 00003A9E 0D0A                    _3ABEh:		db 0Dh,0Ah
 15419 00003AA0 496E76616C69642074-     		db 'Invalid time ',0
 15420 00003AA9 696D652000         
 15421 00003AAE [9E3A]                  BADTIMPTR:	dw _3ABEh
 15422 00003AB0 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15423 00003AB9 696D652069732000   
 15424 00003AC1 [B03A]                  CURTIMPTR:	dw _3AD0h
 15425 00003AC3 0D0A                    _3AE3h:		db 0Dh,0Ah
 15426 00003AC5 456E746572206E6577-     		db 'Enter new time: ',0
 15427 00003ACE 2074696D653A2000   
 15428 00003AD6 [C33A]                  NEWTIMPTR:	dw _3AE3h
 15429 00003AD8 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15430 00003AE1 7572652028592F4E29-
 15431 00003AEA 3F00               
 15432 00003AEC [D83A]                  SUREMESPTR:	dw _3AF8h
 15433 00003AEE 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15434 00003AF7 00                 
 15435 00003AF8 [EE3A]                  DMESPTR:	dw _3B0Eh
 15436 00003AFA 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15437 00003B03 7273696F6E20253164-
 15438 00003B0C 2E2530326420202020-
 15439 00003B15 202020202020202020-
 15440 00003B1E 202020202020202000 
 15441 00003B27 [FA3A]                  VERMESPTR:	dw _3B1Ah
 15442 00003B29 [5D44]                  		dw MAJOR_VER_NUM ; _447Dh
 15443 00003B2B [5F44]                  		dw MINOR_VER_NUM ; _447Fh
 15444 00003B2D 254300                  _3B4Dh:		db '%C',0
 15445 00003B30 [2D3B]                  ONECHRVALPTR:	dw _3B4Dh
 15446 00003B32 [6144]                  		dw ONE_CHAR_VAL	; _4481h
 15447 00003B34 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15448 00003B3D 6E2064726976652025-
 15449 00003B46 6320257300         
 15450 00003B4B [343B]                  VOLMESPTR:	dw _3B54h
 15451 00003B4D [6444]                  		dw VOL_DRV ; _4484h
 15452 00003B4F [6244]                  		dw VOLNAME_ADDR ; _4482h
 15453 00003B51 69732000                IS:		db 'is ',0
 15454 00003B55 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15455 00003B5E 62656C00           
 15456 00003B62 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15457 00003B6B 69726563746F72790D-
 15458 00003B74 0A00               
 15459 00003B76 [623B]                  BADCDPTR:	dw _3B82h
 15460 00003B78 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15461 00003B81 206372656174652064-
 15462 00003B8A 69726563746F72790D-
 15463 00003B93 0A00               
 15464 00003B95 [783B]                  BADMKDPTR:	dw _3B98h
 15465 00003B97 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15466 00003BA0 6174682C206E6F7420-
 15467 00003BA9 6469726563746F7279-
 15468 00003BB2 2C0D0A             
 15469 00003BB5 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15470 00003BBE 6F7279206E6F742065-
 15471 00003BC7 6D7074790D0A00     
 15472 00003BCE [973B]                  BADRMDPTR:	dw _3BB7h
 15473 00003BD0 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15474 00003BD9 696679204F4E206F72-
 15475 00003BE2 204F46460D0A00     
 15476 00003BE9 [D03B]                  BADONOFFPTR:	dw _3BF0h
 15477 00003BEB 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15478 00003BF4 79206F66202025530D-
 15479 00003BFD 0A00               
 15480 00003BFF [EB3B]                  DIRHEADPTR:	dw _3C0Bh
 15481 00003C01 [6544]                  		dw VOL_DIR ; _4485h
 15482 00003C03 4E6F205061746800        _3C23h:		db 'No Path',0
 15483 00003C0B [033C]                  NULLPATHPTR:	dw _3C23h
 15484 00003C0D 504154483D              PATH_TEXT:	db 'PATH='
 15485 00003C12 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15486 00003C19 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15487 00003C21 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15488 00003C2A 7269766520696E2073-
 15489 00003C33 656172636820706174-
 15490 00003C3C 680D0A00           
 15491 00003C40 [213C]                  BADPMESPTR:	dw _3C41h
 15492 00003C42 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15493 00003C4B 65766963650D0A00   
 15494 00003C53 [423C]                  BADDEVPTR:	dw _3C62h
 15495 00003C55 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15496 00003C5E 20666F756E640D0A00 
 15497 00003C67 [553C]                  BADLABPTR:	dw _3C75h
 15498 00003C69 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15499 00003C72 726F720D0A00       
 15500 00003C78 [693C]                  SYNTMESPTR:	dw _3C89h
 15501 00003C7A 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15502 00003C83 6F74206265206E6573-
 15503 00003C8C 7465640D0A00       
 15504 00003C92 [7A3C]                  FORNESTMESTR:	dw _3C9Ah
 15505 00003C94 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15506 00003C9D 656E74206D656D6F72-
 15507 00003CA6 790D0A00           
 15508 00003CAA [943C]                  INSFMEMMESPTR:	dw _3CB4h
 15509 00003CAC 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15510 00003CB5 6174652066696C6520-
 15511 00003CBE 6572726F7220647572-
 15512 00003CC7 696E6720706970650D-
 15513 00003CD0 0A00               
 15514 00003CD2 [AC3C]                  PIPEEMESPTR:	dw _3CCCh
 15515 00003CD4 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15516 00003CDD 2062696E6172792072-
 15517 00003CE6 656164732066726F6D-
 15518 00003CEF 206120646576696365-
 15519 00003CF8 0D0A00             
 15520 00003CFB [D43C]                  INBDEVPTR:	dw _3CF4h
 15521 00003CFD 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15522 00003D06 00                 
 15523 00003D07 [FD3C]                  CTRLMESPTR:	dw _3D1Dh
 15524 00003D09 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15525 00003D12 2000               
 15526 00003D14 [093D]                  VERIMESPTR:	dw _3D29h
 15527 00003D16 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15528 00003D1F [163D]                  ECHOMESPTR:	dw _3D36h
 15529 00003D21 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15530 00003D27 [213D]                  OFFMESPTR:	dw _3D41h
 15531 00003D29 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15532 00003D2E [293D]                  ONMESPTR:	dw _3D49h
 15533 00003D30 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15534 00003D39 617468206F72206669-
 15535 00003D42 6C65206E616D650D0A-
 15536 00003D4B 00                 
 15537 00003D4C [303D]                  BADCPMESPTR:	dw _3D50h
 15538 00003D4E 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15539 00003D57 756D626572206F6620-
 15540 00003D60 706172616D65746572-
 15541 00003D69 730D0A00           
 15542 00003D6D [4E3D]                  BADARGSPTR:	dw _3D6Eh
 15543 00003D6F 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15544 00003D78 74696E6720746F2064-
 15545 00003D81 65766963650D0A00   
 15546 00003D89 [6F3D]                  DEVWMESPTR:	dw _3D8Fh
 15547 00003D8B 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15548 00003D8E [8B3D]                  ACRLFPTR:	dw _3DABh
 15549 00003D90 08                      _3DB0h:		db 8
 15550 00003D91 20                      		db 20h
 15551 00003D92 08                      		db 8
 15552 00003D93 00                      		db 0
 15553 00003D94 [903D]                  DBACKPTR:	dw _3DB0h
 15554 00003D96 79                      small_y:	db 'y'
 15555 00003D97 6E                      small_n:	db 'n'
 15556 00003D98 59                      CAPITAL_Y:	db 'Y'
 15557 00003D99 4E                      CAPITAL_N:	db 'N'
 15558 00003D9A 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15559                                  PROMPT_TABLE:
 15560 00003D9F 42                      		db 'B' ; 42h
 15561 00003DA0 [F813]                  		dw PRINT_B
 15562 00003DA2 44                      		db 'D' ; 44h
 15563 00003DA3 [9F29]                  		dw PRINT_DATE
 15564 00003DA5 45                      		db 'E' ; 45h
 15565 00003DA6 [EA13]                  		dw PRINT_ESC
 15566 00003DA8 47                      		db 'G' ; 47h
 15567 00003DA9 [EE13]                  		dw PRINT_G
 15568 00003DAB 48                      		db 'H' ; 48h
 15569 00003DAC [E013]                  		dw PRINT_BACK
 15570 00003DAE 4C                      		db 'L' ; 4Ch
 15571 00003DAF [F313]                  		dw PRINT_L
 15572 00003DB1 4E                      		db 'N' ; 4Eh
 15573 00003DB2 [0E14]                  		dw PRINT_DRIVE
 15574 00003DB4 50                      		db 'P' ; 50h
 15575 00003DB5 [1A14]                  		dw BUILD_DIR_FOR_PROMPT
 15576 00003DB7 51                      		db 'Q' ; 51h
 15577 00003DB8 [E613]                  		dw PRINT_EQ
 15578 00003DBA 54                      		db 'T' ; 54h
 15579 00003DBB [2E22]                  		dw PRINT_TIME
 15580 00003DBD 56                      		db 'V' ; 56h
 15581 00003DBE [7213]                  		dw PRINT_VERSION
 15582 00003DC0 5F                      		db '_' ; 5Fh
 15583 00003DC1 [6E19]                  		dw CRLF2
 15584 00003DC3 24                      		db '$' ; 24h
 15585 00003DC4 [FB13]                  		dw PRINT_CHAR
 15586 00003DC6 00                      		db 0
 15587                                  
 15588                                  		; Table of IF conditionals
 15589                                  IFTAB:
 15590 00003DC7 03                      		db 3	; First byte is count
 15591 00003DC8 4E4F54                  		db 'NOT'
 15592 00003DCB [7F09]                  		dw IFNOT
 15593 00003DCD 0A                      		db 10
 15594 00003DCE 4552524F524C455645-     		db 'ERRORLEVEL'
 15595 00003DD7 4C                 
 15596 00003DD8 [420A]                  		dw IFERLEV
 15597 00003DDA 05                      		db 5
 15598 00003DDB 4558495354              		db 'EXIST'
 15599 00003DE0 [D609]                  		dw IFEXISTS
 15600 00003DE2 00                      		db 0
 15601                                  
 15602                                  		; Table for internal command names
 15603                                  
 15604 00003DE3 03                      COMTAB:		db 3
 15605 00003DE4 444952                  		db 'DIR'
 15606 00003DE7 03                      		db 3
 15607 00003DE8 [C20E]                  		dw CATALOG
 15608 00003DEA 04                      		db 4
 15609 00003DEB 43414C4C                		db 'CALL'
 15610 00003DEF 02                      		db 2
 15611 00003DF0 [B70A]                  		dw _$CALL
 15612 00003DF2 04                      		db 4
 15613 00003DF3 43484350                		db 'CHCP'
 15614 00003DF7 02                      		db 2
 15615 00003DF8 [C115]                  		dw CHCP
 15616 00003DFA 06                      		db 6
 15617 00003DFB 52454E414D45            		db 'RENAME'
 15618 00003E01 01                      		db 1
 15619 00003E02 [0212]                  		dw CRENAME
 15620 00003E04 03                      		db 3
 15621 00003E05 52454E                  		db 'REN'
 15622 00003E08 01                      		db 1
 15623 00003E09 [0212]                  		dw CRENAME
 15624 00003E0B 05                      		db 5
 15625 00003E0C 4552415345              		db 'ERASE'
 15626 00003E11 01                      		db 1
 15627 00003E12 [9911]                  		dw ERASE
 15628 00003E14 03                      		db 3
 15629 00003E15 44454C                  		db 'DEL'
 15630 00003E18 01                      		db 1
 15631 00003E19 [9911]                  		dw ERASE
 15632 00003E1B 04                      		db 4
 15633 00003E1C 54595045                		db 'TYPE'
 15634 00003E20 01                      		db 1
 15635 00003E21 [7612]                  		dw TYPEFIL
 15636 00003E23 03                      		db 3
 15637 00003E24 52454D                  		db 'REM'
 15638 00003E27 02                      		db 2
 15639 00003E28 [0401]                  		dw TCOMMAND
 15640 00003E2A 04                      		db 4
 15641 00003E2B 434F5059                		db 'COPY'
 15642 00003E2F 03                      		db 3
 15643 00003E30 [F529]                  		dw COPY
 15644 00003E32 05                      		db 5
 15645 00003E33 5041555345              		db 'PAUSE'
 15646 00003E38 02                      		db 2
 15647 00003E39 [8C11]                  		dw PAUSE
 15648 00003E3B 04                      		db 4
 15649 00003E3C 44415445                		db 'DATE'
 15650 00003E40 02                      		db 2
 15651 00003E41 [0421]                  		dw DATE
 15652 00003E43 04                      		db 4
 15653 00003E44 54494D45                		db 'TIME'
 15654 00003E48 00                      		db 0
 15655 00003E49 [1B22]                  		dw CTIME
 15656 00003E4B 03                      		db 3
 15657 00003E4C 564552                  		db 'VER'
 15658 00003E4F 00                      		db 0
 15659 00003E50 [6913]                  		dw VERSION
 15660 00003E52 03                      		db 3
 15661 00003E53 564F4C                  		db 'VOL'
 15662 00003E56 01                      		db 1
 15663 00003E57 [1313]                  		dw VOLUME
 15664 00003E59 02                      		db 2
 15665 00003E5A 4344                    		db 'CD'
 15666 00003E5C 01                      		db 1
 15667 00003E5D [AA18]                  		dw _$CHDIR
 15668 00003E5F 05                      		db 5
 15669 00003E60 4348444952              		db 'CHDIR'
 15670 00003E65 01                      		db 1
 15671 00003E66 [AA18]                  		dw _$CHDIR
 15672 00003E68 02                      		db 2
 15673 00003E69 4D44                    		db 'MD'
 15674 00003E6B 01                      		db 1
 15675 00003E6C [ED18]                  		dw _$MKDIR
 15676 00003E6E 05                      		db 5
 15677 00003E6F 4D4B444952              		db 'MKDIR'
 15678 00003E74 01                      		db 1
 15679 00003E75 [ED18]                  		dw _$MKDIR
 15680 00003E77 02                      		db 2
 15681 00003E78 5244                    		db 'RD'
 15682 00003E7A 01                      		db 1
 15683 00003E7B [3119]                  		dw _$RMDIR
 15684 00003E7D 05                      		db 5
 15685 00003E7E 524D444952              		db 'RMDIR'
 15686 00003E83 01                      		db 1
 15687 00003E84 [3119]                  		dw _$RMDIR
 15688 00003E86 05                      		db 5
 15689 00003E87 425245414B              		db 'BREAK'
 15690 00003E8C 00                      		db 0
 15691 00003E8D [D528]                  		dw CNTRLC
 15692 00003E8F 06                      		db 6
 15693 00003E90 564552494659            		db 'VERIFY'
 15694 00003E96 00                      		db 0
 15695 00003E97 [0729]                  		dw VERIFY
 15696 00003E99 03                      		db 3
 15697 00003E9A 534554                  		db 'SET'
 15698 00003E9D 02                      		db 2
 15699 00003E9E [9816]                  		dw ADD_NAME_TO_ENVIRONMENT
 15700 00003EA0 06                      		db 6
 15701 00003EA1 50524F4D5054            		db 'PROMPT'
 15702 00003EA7 02                      		db 2
 15703 00003EA8 [7E16]                  		dw ADD_PROMPT
 15704 00003EAA 04                      		db 4
 15705 00003EAB 50415448                		db 'PATH'
 15706 00003EAF 02                      		db 2
 15707 00003EB0 [8314]                  		dw PATH
 15708 00003EB2 04                      		db 4
 15709 00003EB3 45584954                		db 'EXIT'
 15710 00003EB7 00                      		db 0
 15711 00003EB8 [5016]                  		dw _$EXIT
 15712 00003EBA 04                      		db 4
 15713 00003EBB 43545459                		db 'CTTY'
 15714 00003EBF 03                      		db 3
 15715 00003EC0 [5D15]                  		dw CTTY
 15716 00003EC2 04                      		db 4
 15717 00003EC3 4543484F                		db 'ECHO'
 15718 00003EC7 02                      		db 2
 15719 00003EC8 [9228]                  		dw ECHO
 15720 00003ECA 04                      		db 4
 15721 00003ECB 474F544F                		db 'GOTO'
 15722 00003ECF 02                      		db 2
 15723 00003ED0 [EB0A]                  		dw GOTO
 15724 00003ED2 05                      		db 5
 15725 00003ED3 5348494654              		db 'SHIFT'
 15726 00003ED8 02                      		db 2
 15727 00003ED9 [700A]                  		dw SHIFT
 15728 00003EDB 02                      		db 2
 15729 00003EDC 4946                    		db 'IF'
 15730 00003EDE 02                      		db 2
 15731 00003EDF [2F09]                  		dw _$IF
 15732 00003EE1 03                      		db 3
 15733 00003EE2 464F52                  		db 'FOR'
 15734 00003EE5 02                      		db 2
 15735 00003EE6 [460D]                  		dw _$FOR
 15736 00003EE8 03                      		db 3
 15737 00003EE9 434C53                  		db 'CLS'
 15738 00003EEC 00                      		db 0
 15739 00003EED [F214]                  		dw CLS
 15740 00003EEF 00                      		db 0
 15741                                  
 15742 00003EF0 41                      CAPITAL_A:	db 'A'
 15743 00003EF1 7C                      VBAR:		db '|'
 15744 00003EF2 3C                      LABRACKET:	db '<' ; 3Ch
 15745 00003EF3 3E                      RABRACKET:	db '>' ; 3Eh
 15746 00003EF4 24                      DOLLAR:		db '$'
 15747 00003EF5 28                      LPAREN:		db '('
 15748 00003EF6 29                      RPAREN:		db ')'
 15749 00003EF7 29                      NULLRPAREN:	db ')' ; 29h
 15750 00003EF8 00                      		db 0
 15751 00003EF9 494E                    IN_WORD:	db 'I','N'
 15752 00003EFB 444F                    DO_WORD	:	db 'D','O'
 15753 00003EFD 2A                      STAR:		db '*'
 15754 00003EFE 2D                      CHAR_SUB:	db '-' 
 15755 00003EFF 2B                      PLUS_CHR:	db '+'
 15756 00003F00 4C                      CHAR_L:		db 'L'
 15757 00003F01 6C                      char_l:		db 'l'
 15758 00003F02 61                      small_a:	db 'a'
 15759 00003F03 7A                      small_z:	db 'z'
 15760 00003F04 44                      CHAR_D:		db 'D'
 15761 00003F05 43                      CHAR_C:		db 'C'
 15762 00003F06 53                      CHAR_S:		db 'S'
 15763 00003F07 58                      CHAR_X:		db 'X'
 15764 00003F08 2E                      DOT_CHR:	db '.' 
 15765 00003F09 3F2E                    DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15766 00003F0B 2C                      		db ','
 15767 00003F0C 3A2E                    TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15768 00003F0E 70                      MNCHR:		db 'p'
 15769 00003F0F 00                      SYSTEM_CPAGE:	db 0
 15770 00003F10 00                      		db 0
 15771                                  
 15772 00003F11 2E434F4D                COMEXT:		db '.COM'
 15773 00003F15 2E455845                EXEEXT:		db '.EXE'
 15774 00003F19 2E424154                BATEXT:		db '.BAT'
 15775 00003F1D 5642415057              SWITCH_LIST:	db 'VBAPW'
 15776 00003F22 2000                    BATBUFLEN:	dw BATLEN ; 32
 15777                                  
 15778                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15779                                  
 15780                                  TRANDATAEND:
 15781                                  
 15782                                  ;============================================================================
 15783                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15784                                  ;============================================================================
 15785                                  ; 29/09/2018 - Retro DOS v3.0
 15786                                  
 15787                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15788                                  
 15789                                  ;The TRANSPACE segment contains variable data that is considered
 15790                                  ;volatile between command cycles, and therefore is not included in the
 15791                                  ;transient checksum area. Contents of these variables MUST be
 15792                                  ;initialized before use, and must not be relied upon from command
 15793                                  ;cycle to command cycle.
 15794                                  ;
 15795                                  ;No constant data values should be stored here.
 15796                                  
 15797                                  ; ---------------------------------------------------------------------------
 15798                                  ; START OF UNITIALIZED DATA
 15799                                  ; ---------------------------------------------------------------------------	
 15800                                  
 15801                                  ;	times 12 db 0
 15802                                  
 15803 00003F24 90<rept>                align 16
 15804                                  
 15805                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15806                                  
 15807 00003F30 00                      PRINTF_LEFT:	db 0
 15808 00003F31 00                      PRINTF_LONG:	db 0
 15809 00003F32 00                      PRINTF_HEX:	db 0
 15810 00003F33 00                      TABLE_INDEX:	db 0
 15811 00003F34 0000                    PRINTF_WIDTH:	dw 0
 15812 00003F36 0000                    PRINTF_BASE:	dw 0
 15813 00003F38 00                      PAD_CHAR:	db 0
 15814 00003F39 0000                    PRINTF_HANDLE:	dw 0
 15815 00003F3B 00<rept>                PRINTF_BUF: times 100 db 0
 15816                                  PRINTF_BUF_END: ; 30/09/2018
 15817                                  
 15818                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15819                                  
 15820 00003F9F 00<rept>                SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15821 00003FF6 00<rept>                TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15822 0000404D 00<rept>                UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15823 000040D0 00<rept>                COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15824 00004153 00<rept>                USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15825 00004199 00<rept>                EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15826 0000421C 00<rept>                RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15827                                  
 15828                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15829 0000426F 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15830 00004271 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15831 00004273 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15832 00004275 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15833 00004276 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15834 00004277 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15835                                  					; MYSEG1    (dw 0)	
 15836 0000427B 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15837                                  					; MYSEG2    (dw 0)	
 15838 0000427F 0000                    		dw 0			; RESTEST   (dw 0)	
 15839 00004281 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15840                                  
 15841 00004283 00                      CHKDRV:		db 0
 15842                                  IFNOTFLAG:
 15843                                  FILTYP:
 15844 00004284 00                      RDEOF:		db 0			; Misc flags
 15845 00004285 00                      CURDRV:		db 0
 15846                                  PARM1:
 15847 00004286 00                      CONCAT:		db 0
 15848                                  PARM2:
 15849 00004287 00                      ARGC:		db 0
 15850 00004288 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15851 0000428A 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15852                                  ARG2S:					; Switches after 2nd arg		
 15853 0000428C 0000                    DESTSWITCH:	dw 0
 15854                                  ARGTS:
 15855 0000428E 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15856 00004290 00                      CFLAG:		db 0
 15857                                  DESTCLOSED:
 15858 00004291 00                      SPECDRV:	db 0
 15859 00004292 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15860 00004294 0000                    NXTADD:		dw 0
 15861 00004296 00                      FRSTSRCH:	db 0
 15862                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15863                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15864 00004297 00                      LINCNT:		db 0
 15865 00004298 00                      LINLEN:		db 0
 15866                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15867 00004299 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15868                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15869                                  
 15870                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15871                                  ;
 15872                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15873                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15874                                  
 15875                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15876                                  
 15877 0000429B 00<rept>                CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15878                                  DESTFCB2:
 15879 000042EB 00                      IDLEN:		db 0
 15880 000042EC 00<rept>                ID:	  times	8  db 0
 15881 000042F4 00<rept>                COM:	  times	3  db 0 
 15882 000042F7 00<rept>                DEST:	  times 37 db 0
 15883 0000431C 00<rept>                DESTNAME: times 11 db 0
 15884                                  DESTDIR:
 15885 00004327 00<rept>                DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15886                                  GOTOLEN:	; word
 15887                                  BWDBUF: 	; byte
 15888                                  EXEFCB: 	; word
 15889 0000436A 00<rept>                DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15890                                  
 15891                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15892                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15893                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15894                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15895                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15896                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15897                                  
 15898 000043B0 00<rept>                SDIRBUF:  times 12 db 0	
 15899 000043BC 0000                    _BITS:		dw 0
 15900 000043BE 0000                    PATHCNT:	dw 0
 15901 000043C0 0000                    PATHPOS:	dw 0
 15902 000043C2 0000                    PATHSW:		dw 0
 15903                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15904                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15905 000043C4 00                      LINPERPAG:	db 0
 15906 000043C5 00                      		db 0
 15907 000043C6 00                      COMMA:		db 0			; flag set if +,, occurs
 15908 000043C7 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 15909                                  
 15910                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 15911                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 15912                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 15913                                  
 15914 000043C8 00<rept>                ARG_BUF:  times 128 db 0   ; _43E8h	
 15915 00004448 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 15916 0000444A 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 15917 0000444C 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 15918 0000444E 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 15919                                  
 15920 00004450 0000                    COPY_NUM:	dw 0
 15921 00004452 00<rept>                	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 15922 00004456 00                      CPYFLAG:	db 0
 15923 00004457 0000                    DIR_NUM:	dw 0
 15924 00004459 0000                    BYTES_FREE:	dw 0
 15925 0000445B 0000                    		dw 0
 15926 0000445D 0000                    MAJOR_VER_NUM:	dw 0
 15927 0000445F 0000                    MINOR_VER_NUM:	dw 0
 15928 00004461 00                      ONE_CHAR_VAL:	db 0
 15929                                  		;db 0
 15930 00004462 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 15931 00004464 00                      VOL_DRV:	db 0
 15932 00004465 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 15933                                  
 15934 00004467 00                      ROM_CALL:	db 0			; flag for rom function
 15935 00004468 0000                    ROM_IP:		dw 0
 15936 0000446A 0000                    ROM_CS:		dw 0
 15937                                  
 15938                                  DESTVARS:
 15939 0000446C 00                      DESTISDIR:	db 0
 15940 0000446D 00                      DESTSIZ:	db 0
 15941 0000446E 0000                    DESTTAIL:	dw 0
 15942 00004470 00                      DESTINFO:	db 0
 15943 00004471 00<rept>                DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 15944                                  ENDDESTBUF:
 15945                                  
 15946 000044C8 0000                    DESTHAND:	dw 0
 15947 000044CA 00                      DESTISDEV:	db 0
 15948 000044CB 00                      FIRSTDEST:	db 0
 15949 000044CC 00                      MELCOPY:	db 0
 15950 000044CD 0000                    MELSTART:	dw 0
 15951                                  
 15952                                  SRCVARS:
 15953 000044CF 00                      SRCISDIR:	db 0
 15954 000044D0 00                      SRCSIZ:		db 0
 15955 000044D1 0000                    SRCTAIL:	dw 0
 15956 000044D3 00                      SRCINFO:	db 0
 15957 000044D4 00<rept>                SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 15958                                  
 15959 0000452B 0000                    SRCHAND:	dw 0
 15960 0000452D 00                      SRCISDEV:	db 0
 15961                                  
 15962 0000452E 00<rept>                SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 15963                                  
 15964 00004585 0000                    SRCPT:		dw 0
 15965 00004587 00                      INEXACT:	db 0
 15966 00004588 00                      		db 0 ; MSDOS 3.3 
 15967 00004589 00                      NOWRITE:	db 0
 15968 0000458A 00                      BINARY:		db 0
 15969 0000458B 0000                    WRITTEN:	dw 0
 15970 0000458D 00                      TERMREAD:	db 0
 15971 0000458E 00                      ASCII:		db 0
 15972 0000458F 00                      PLUS:		db 0
 15973 00004590 00                      OBJCNT:		db 0			; Used in copy
 15974 00004591 0000                    CPDATE:		dw 0
 15975 00004593 0000                    CPTIME:		dw 0
 15976                                  
 15977                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 15978                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 15979                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 15980                                  
 15981 00004595 0000                    BATHAND:	dw 0			; Batch handle
 15982 00004597 0000                    STARTEL:	dw 0
 15983 00004599 00                      ELCNT:		db 0
 15984 0000459A 00                      ELPOS:		db 0
 15985 0000459B 00<rept>                SOURCE:   times	11 db 0
 15986                                  
 15987 000045A6 00                      ext_entered:	db 0			;AN005;
 15988                                  
 15989                                  ;display_ioctl	db 0			;AN000; info level
 15990                                  ;		db 0			;AN000; reserved
 15991                                  ;		dw crt_ioctl_ln		;AN000; length of data
 15992                                  ;		dw 0			;AN000; control flags
 15993                                  ;display_mode:	db 0			;AN000; display mode, colors
 15994                                  ;		db 0			;AN000; reserved
 15995                                  ;		dw 0			;AN023; colors
 15996                                  ;		dw 0			;AN000; display width (PELS)
 15997                                  ;		dw 0			;AN000; display length (PELS)
 15998                                  ;display_width:	dw 0			;AN000; display width
 15999                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 16000                                  ;
 16001                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 16002                                  ;		dw 0			;AN000; info level
 16003                                  ;vol_serial:	dd 0			;AN000; volume serial number
 16004                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 16005                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 16006                                  
 16007 000045A7 00                      EXPAND_STAR:	db 0
 16008                                  
 16009                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 16010                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 16011                                  ;append_exec:	db 0			;AN041; set if internal append executed
 16012                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 16013                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 16014                                  
 16015 000045A8 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 16016                                  
 16017                                  ; Data declarations taken out of parse.asm
 16018                                  
 16019                                  ; MSDOS 6.0
 16020                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 16021                                  ;argbufptr	dw	?		; index for argv[].argpointer
 16022                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 16023                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 16024                                  ;comptr		dw	?		; ptr into combuf
 16025                                  
 16026                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 16027                                  ARG:
 16028                                  ARG_ARGV:
 16029 000045A9 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 16030 000045AB 00                      ARGV0_ARG_FLAGS:  db 0
 16031 000045AC 0000                    ARGV0_ARGSTARTEL: dw 0
 16032 000045AE 0000                    ARGV0_ARGLEN:	  dw 0
 16033 000045B0 0000                    ARGV0_ARGSW_WORD: dw 0
 16034 000045B2 0000                    ARGV0_OCOMPTR:	  dw 0
 16035                                  
 16036 000045B4 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 16037 000045B6 00<rept>                	  times 5 db 0
 16038 000045BB 0000                    ARGV1_ARGSW_WORD: dw 0
 16039 000045BD 0000                    		  dw 0
 16040                                  
 16041 000045BF 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 16042 000045C1 00<rept>                	  times 5 db 0
 16043 000045C6 0000                    ARGV2_ARGSW_WORD: dw 0
 16044 000045C8 0000                    		  dw 0
 16045                                  
 16046 000045CA 00<rept>                	times 671 db 0  ; ARGV[3] to ARGV[63]
 16047                                  	
 16048 00004869 0000                    ARG_ARGVCNT:	dw 0
 16049 0000486B 0000                    ARG_ARGSWINFO:	dw 0
 16050                                  
 16051 0000486D 0000<rept>              ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 16052 00004A6D 00<rept>                ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 16053                                  
 16054                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 16055                                  
 16056 00004AED 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 16057 00004AEF 00<rept>                TPBUF:    times 128 db 0		; temporary buffer
 16058 00004B6F 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 16059 00004B71 0000                    COMPTR:		dw 0			; ptr into combuf
 16060                                  
 16061                                  ; Data declarations taken out of path.asm
 16062                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 16063                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 16064                                  ;psep_char	DB	?			; '/' or '\'
 16065                                  ;search_best	DB	(?)			; best code, best filename so far
 16066                                  ;fname_max_len	equ	13
 16067                                  ;search_best_buf DB	fname_max_len DUP (?)
 16068                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 16069                                  ;search_error	DW	(?)			; address of error message to be printed
 16070                                  
 16071                                  FINDBUFLEN equ FIND_BUF.size ; 43
 16072                                  
 16073                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 16074                                  
 16075 00004B73 00<rept>                FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 16076                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 16077                                  PATHINFO:
 16078 00004B9E 0000                    PATHINFO_0:	dw 0
 16079 00004BA0 0000                    PATHINFO_2:	dw 0
 16080 00004BA2 0000                    PATHINFO_4:	dw 0
 16081 00004BA4 00                      PSEP_CHAR:	db 0
 16082 00004BA5 00                      SEARCH_BEST:	db 0
 16083                                  ;FNAME_MAX_LEN equ 13
 16084 00004BA6 00<rept>                SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 16085 00004BB3 00<rept>                SEARCH_CURDIR_BUF: times 64 db 0
 16086 00004BF3 0000                    SEARCH_ERROR:	dw 0
 16087                                  
 16088                                  ; Data declarations taken out of tbatch.asm
 16089                                  
 16090                                  ;if_not_count	DW	?
 16091                                  ;
 16092                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 16093                                  ;
 16094                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 16095                                  ;STACK		LABEL	WORD
 16096                                  
 16097                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 16098                                  
 16099 00004BF5 0000                    IF_NOT_COUNT:	dw 0
 16100 00004BF7 00                      ZFLAG:		db 0
 16101 00004BF8 00<rept>                	  times 256 db 0 	
 16102                                  STACK:
 16103                                  
 16104                                  ;INTERNATVARS	internat_block <>
 16105                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 16106                                  ;
 16107                                  ;;		Buffer for DOS function 64h (Get extended country information)
 16108                                  ;;		subfunctions 2, 4, 6, or 7:
 16109                                  ;
 16110                                  ;CountryPtrInfo	label	byte
 16111                                  ;CountryPtrId	db	?
 16112                                  ;CountryPtr	dd	?
 16113                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 16114                                  
 16115                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 16116                                  
 16117                                  INTERNATVARS:	
 16118 00004CF8 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 16119 00004CFA 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 16120 00004CFF 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 16121 00004D01 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 16122 00004D03 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 16123 00004D05 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 16124 00004D07 00                      BIT_FIELD:	db 0			; Bit values
 16125                                  					;   Bit 0 = 0 if currency symbol first
 16126                                  					;	  = 1 if currency symbol last
 16127                                  					;   Bit 1 = 0 if No space after currency symbol
 16128                                  					;	  = 1 if space after currency symbol
 16129 00004D08 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16130 00004D09 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16131 00004D0A 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16132                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16133                                  					;  in pieces.
 16134 00004D0E 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16135                                  
 16136 00004D10 00<rept>                		times 8 db 0
 16137                                  ;
 16138                                  ; Max size of the block returned by the INTERNATIONAL call
 16139                                  ;
 16140                                  INTERNAT_BLOCK_SIZE EQU	32
 16141                                  
 16142                                  BATLEN equ 32
 16143                                  	
 16144                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16145                                  
 16146 00004D18 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16147                                  
 16148 00004D1A 00<rept>                BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16149                                  
 16150 00004D3A 0000                    BATBUFEND:	dw 0
 16151                                  
 16152                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16153                                  
 16154                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
