     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 01/03/2023 ((Prev: 20/10/2018))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   309 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   315 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   316 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 ??                      .ISDIR:		RESB	1
   623 00000001 ??                      .SIZ:		RESB	1
   624 00000002 ????                    .TTAIL:		RESW	1
   625 00000004 ??                      .INFO:		RESB	1
   626 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 ??                      .BatType:	RESB	1		; signature
   660 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   691 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   735 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   736 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   737 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   738 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   739 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   740 00000015 ??                      .ATTR:	    resb 1	; attribute found
   741 00000016 ????                    .TIMR:	    resw 1	; time
   742 00000018 ????                    .DATE:	    resw 1	; date
   743 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   744 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   745 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 ??                                      resb 1
   766 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   768 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   782 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 ????                    .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 ??????????              .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 ????                    .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 ????                    .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B ????                    .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D ????                    .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F ??                      .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 ??                      .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 ??                      .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 ????                    .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 ????                                      RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 ????                    .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 ????                      .owner:	resw 1		; owner of arena item
   917 00000003 ????                      .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  ;LODCOM1   equ	0318h	; 13/10/2018
   962                                  LODCOM1    equ	0319h	; 24/02/2023
   963                                  
   964                                  ; EXEC call adressses in resident portion for calling from transient portion
   965                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   966                                  
   967                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   968                                  ;PUTBACKDRV equ	0A21h	; 14/10/2018
   969                                  PUTBACKDRV equ	0A23h	; 24/02/2023
   970                                  
   971                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   972                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   973                                  
   974                                  ; Resident portion stack address  
   975                                  ;RSTACK	   equ	083Ch
   976                                  RSTACK	   equ	083Eh	; 24/02/2023 
   977                                  
   978                                  ;RETRABASE equ  0B86h	; 13/10/2018 (Base addr for following common params.)
   979                                  RETRABASE  equ  0B88h	; 24/02/2023	
   980                                  
   981                                  ; RESGROUP       [RESSEG]
   982                                  ; DATA		  offset
   983                                  ; --------     	------------
   984                                  PARENT	  equ	RETRABASE+6	; 0B8Ch
   985                                  OLDTERM	  equ	RETRABASE+8	; 0B9Eh
   986                                  BATCH	  equ	RETRABASE+17	; 0B97h
   987                                  COMSPEC	  equ	RETRABASE+19	; 0B99h
   988                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD9h
   989                                  COMSPEC_END equ	RETRABASE+85	; 0BDBh
   990                                  IN_BATCH  equ	RETRABASE+92	; 0BE2h
   991                                  BATCH_ABORT equ	RETRABASE+93	; 0BE3h
   992                                  COMDRV	  equ	RETRABASE+94	; 0BE4h
   993                                  EXTCOM	  equ	RETRABASE+99	; 0BE9h
   994                                  RETCODE	  equ	RETRABASE+100	; 0BEAh
   995                                  ECHOFLAG  equ	RETRABASE+103	; 0BEDh
   996                                  SUPPRESS  equ	RETRABASE+104	; 0BEEh
   997                                  IO_SAVE	  equ	RETRABASE+105	; 0BEFh
   998                                  RESTDIR	  equ	RETRABASE+107	; 0BF1h
   999                                  PERMCOM	  equ	RETRABASE+108	; 0BF2h
  1000                                  SINGLECOM equ	RETRABASE+109	; 0BF3h
  1001                                  VERVAL	  equ	RETRABASE+111	; 0BF5h
  1002                                  IFFLAG	  equ	RETRABASE+114	; 0BF8h	
  1003                                  FORFLAG	  equ	RETRABASE+115	; 0BF9h
  1004                                  FORPTR	  equ	RETRABASE+116	; 0BFAh 	
  1005                                  NEST	  equ	RETRABASE+118	; 0BFCh
  1006                                  CALL_FLAG equ	RETRABASE+120	; 0BFEh
  1007                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFFh
  1008                                  NEXT_BATCH equ	RETRABASE+122 	; 0C00h
  1009                                  NULLFLAG  equ	RETRABASE+124	; 0C02h
  1010                                  UPPERCASETBL equ RETRABASE+126	; 0C04h
  1011                                  RE_OUT_APP equ	RETRABASE+130	; 0C08h
  1012                                  RE_OUTSTR equ	RETRABASE+131	; 0C09h
  1013                                  INITFLAG  equ	RETRABASE+211	; 0C59h	
  1014                                  PIPEFLAG  equ	RETRABASE+212	; 0C5Ah
  1015                                  PIPEFILES equ	RETRABASE+213	; 0C5Bh
  1016                                  PIPE1	  equ	RETRABASE+214	; 0C5Ch	
  1017                                  PIPE2	  equ	RETRABASE+230	; 0C6Ch
  1018                                  PIPEPTR	  equ	RETRABASE+246	; 0C7Ch
  1019                                  PIPESTR	  equ	RETRABASE+248	; 0C7Eh
  1020                                  INPIPEPTR equ	RETRABASE+377	; 0CFFh
  1021                                  OUTPIPEPTR equ	RETRABASE+379	; 0D01h
  1022                                  ENVIRSEG  equ	RETRABASE+381	; 0D03h
  1023                                  EXEC_BLOCK equ	RETRABASE+381 	; 0D03h  ; ENVIRSEG
  1024                                  LTPA	  equ	RETRABASE+399	; 0D15h
  1025                                  RES_TPA	  equ	RETRABASE+413	; 0D23h
  1026                                  
  1027                                  ;=============================================================================
  1028                                  					
  1029                                  ; (command3.s -> offset TRANGOUP)
  1030                                  
  1031                                  TRANGROUP:
  1032                                  
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; START OF TRANSIENT PORTION
  1035                                  ; ----------------------------------------------------------------------------
  1036                                  ; SEGMENT - TRANSCODE
  1037                                  ; ----------------------------------------------------------------------------
  1038                                  ; 13/10/2018 - Retro DOS v3.0
  1039                                  
  1040                                  ;[BITS 16]
  1041                                  ;[ORG 0]
  1042 00000000 00<rep 100h>            		times 256 db 0
  1043                                  
  1044                                  ;============================================================================
  1045                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1046                                  ;============================================================================
  1047                                  ; 12/10/2018 - Retro DOS v3.0
  1048                                  
  1049                                  ;[ORG 100h]
  1050                                  
  1051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1052                                  
  1053                                  ; ---------------------------------------------------------------------------
  1054                                  
  1055                                  SETDRV:					; Allow for 100H parameter area
  1056 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1057 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1058                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1059                                  				; Return: AL = number of logical drives
  1060                                  
  1061                                  ; ---------------------------------------------------------------------------
  1062                                  
  1063                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1064                                  ; No registers (CS:IP) no flags, nothing.
  1065                                  
  1066                                  TCOMMAND:
  1067 00000104 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  1068 00000109 B8FFFF                  		mov	ax,-1
  1069 0000010C 8706F70B                		xchg	ax,[VERVAL]
  1070 00000110 83F8FF                  		cmp	ax,-1
  1071 00000113 7404                    		jz	short NOSETVER2
  1072 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1073 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1074                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1075                                  NOSETVER2:
  1076 00000119 2EFF1E[AF41]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1077 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1078 00000120 833EF50BFF              		cmp	word [SINGLECOM],-1
  1079 00000125 7505                    		jnz	short COMMAND
  1080                                  _$EXITPREP:
  1081 00000127 0E                      		push	cs
  1082 00000128 1F                      		pop	ds
  1083 00000129 E90715                  		jmp	_$EXIT		; Have finished the single command
  1084                                  
  1085                                  ; ---------------------------------------------------------------------------
  1086                                  ;
  1087                                  ; Main entry point from resident portion.
  1088                                  ;
  1089                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1090                                  ;   just beginning the processing of another command.
  1091                                  ;
  1092                                  ; ---------------------------------------------------------------------------
  1093                                  
  1094                                  ; We are not always sure of the state of the world at this time. We presume
  1095                                  ; worst case and initialize the relevant registers: segments and stack.
  1096                                  
  1097                                  COMMAND:
  1098 0000012C FC                      		cld
  1099 0000012D 8CC8                    		mov	ax,cs
  1100 0000012F FA                      		cli
  1101 00000130 8ED0                    		mov	ss,ax
  1102                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1103 00000132 BC[384C]                		mov	sp,STACK
  1104 00000135 FB                      		sti
  1105                                  		
  1106 00000136 8EC0                    		MOV	ES,AX
  1107                                  		
  1108                                  		; MSDOS 6.0
  1109                                  		;MOV	DS,AX		;AN000; set DS to transient
  1110                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1111                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1112                                  		;mov	append_exec,0	;AN041; set internal append state off
  1113                                  
  1114                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1115 00000138 368E1E[B141]            		mov	ds,[ss:RESSEG]
  1116 0000013D 36C606[8D3F]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1117 00000143 36C606[1040]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1118                                  
  1119                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1120                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1121                                  ; I guess not:  the only circumstances in which we reload the command processor
  1122                                  ; is after a transient program execution. In this case, we let the current
  1123                                  ; directory lie where it may.
  1124                                  
  1125 00000149 09ED                    		or	bp,bp		; See if just read
  1126 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1127 0000014D 36C706[8E3F]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1128 00000154 EB17                    		jmp	short NOSETBUF
  1129                                  TESTRDIR:
  1130 00000156 803EF30B00              		cmp	byte [RESTDIR],0
  1131 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1132 0000015D 1E                      		push	ds
  1133                                  
  1134                                  ; We have an unusual situation to handle. The user *may* have changed his
  1135                                  ; directory as a result of an internal command that got aborted. Restoring it
  1136                                  ; twice may not help us: the problem may never go away. We just attempt it
  1137                                  ; once and give up.
  1138                                  
  1139 0000015E C606F30B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1140                                  
  1141                                  		; Restore users directory
  1142 00000163 0E                      		push	cs
  1143 00000164 1F                      		pop	ds
  1144 00000165 BA[9340]                		mov	dx,USERDIR1
  1145 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1146 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1147                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1148 0000016C 1F                      		pop	ds
  1149                                  NOSETBUF:
  1150 0000016D 803E5D0C00              		cmp	byte [PIPEFILES],0
  1151 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1152 00000174 803E5C0C00              		cmp	byte [PIPEFLAG],0
  1153 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1154 0000017B E85D1D                  		call	PIPEDEL
  1155                                  NOPCLOSE:
  1156                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1157 0000017E C606EB0B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1158 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1159 00000185 8ED8                    		mov	ds,ax
  1160 00000187 50                      		push	ax
  1161 00000188 BA[384C]                		mov	dx,INTERNATVARS
  1162 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1163 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1164                                  				; get current-country info
  1165                                  				; DS:DX	-> buffer for returned info
  1166 00000190 58                      		pop	ax
  1167 00000191 2B06[B341]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1168 00000195 53                      		push	bx
  1169 00000196 BB1000                  		mov	bx,16
  1170 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1171 0000019B 5B                      		pop	bx
  1172 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1173 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1174 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1175                                  SAVSIZ:
  1176                                  
  1177                                  ; AX is the number of bytes free in the buffer between the resident and the
  1178                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1179                                  
  1180 000001A3 3D0002                  		cmp	ax,512
  1181 000001A6 7603                    		jbe	short GOTSIZE
  1182                                  		;and	ax,~1FFh
  1183 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1184                                  GOTSIZE:
  1185 000001AB A3[D241]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1186 000001AE 8E1E[B141]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1187                                  
  1188 000001B2 F606EF0B01              		test	byte [ECHOFLAG],1 
  1189 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1190 000001B9 E8FE1C                  		call	SINGLETEST
  1191 000001BC 7219                    		jb	short GETCOM
  1192 000001BE F6065C0CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1193 000001C3 7512                    		jnz	short GETCOM
  1194                                  					; G  Don't print prompt in FOR
  1195 000001C5 F606FB0BFF              		test	byte [FORFLAG],0FFh ; -1
  1196 000001CA 750B                    		jnz	short GETCOM
  1197                                  					; G  Don't print prompt if in batch
  1198 000001CC F706990BFFFF            		test	word [BATCH],0FFFFh ; -1
  1199 000001D2 7503                    		jnz	short GETCOM
  1200 000001D4 E87417                  		call	CRLF2
  1201                                  GETCOM:
  1202 000001D7 C606000C00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1203 000001DC C606010C00              		mov	byte [CALL_BATCH_FLAG],0
  1204 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1205 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1206 000001E5 36A2[C541]              		mov	[ss:CURDRV],al
  1207 000001E9 F6065C0CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1208 000001EE 7403                    		jz	short NOPIPE
  1209 000001F0 E9871D                  		jmp	PIPEPROC	; Continue the pipeline
  1210                                  NOPIPE:
  1211 000001F3 F606EF0B01              		test	byte [ECHOFLAG],1
  1212 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1213 000001FA E8BD1C                  		call	SINGLETEST
  1214 000001FD 7212                    		jb	short NOPDRV
  1215 000001FF F606FB0BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1216 00000204 750B                    		jnz	short NOPDRV
  1217 00000206 F706990BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1218 0000020C 750D                    		jnz	short TESTFORBAT
  1219 0000020E E86711                  		call	PRINT_PROMPT	; Prompt the user
  1220                                  NOPDRV:
  1221 00000211 F606FB0BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1222 00000216 7403                    		jz	short TESTFORBAT
  1223 00000218 E9FD09                  		jmp	FORPROC		; Continue the FOR
  1224                                  
  1225                                  TESTFORBAT:
  1226 0000021B 36C606[5C41]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1227 00000221 C6060B0C00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1228 00000226 C6060A0C00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1229 0000022B C606FA0B00              		mov	byte [IFFLAG],0	; no more ifs...
  1230 00000230 F706990BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1231 00000236 7429                    		jz	short ISNOBAT
  1232                                  
  1233                                  		; MSDOS 6.0
  1234                                  
  1235                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1236                                  
  1237                                  		;push	es			;AN000; save ES
  1238                                  		;push	ds			;AN000; save DS
  1239                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1240                                  		;mov	es,[batch]		;AN000; get batch segment
  1241                                  		;mov	di,batfile		;AN000; get batch file name
  1242                                  		;push	cs			;AN000; get local segment to DS
  1243                                  		;pop	ds			;AN000;
  1244                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1245                                  		;int	2fh			;AN000; call the shell
  1246                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1247                                  		;pop	ds			;AN000; restore DS
  1248                                  		;pop	es			;AN000; restore ES
  1249                                  		;jz	jdocom1 		;AN000; yes - go process command
  1250                                  
  1251                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1252 00000238 1E                      		push	ds
  1253 00000239 E8BB02                  		call	READBAT			; Continue BATCH
  1254 0000023C 1F                      		pop	ds
  1255 0000023D C606040C00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1256 00000242 F706990BFFFF            		test	word [BATCH],0FFFFh
  1257 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1258 0000024A 8B1E020C                		mov	bx,[NEXT_BATCH]
  1259 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1260 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1261 00000253 891E990B                		mov	[BATCH],bx		;G get segment of next batch file
  1262 00000257 C706020C0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1263                                  JDOCOM1:
  1264 0000025D 0E                      		push	cs
  1265 0000025E 1F                      		pop	ds
  1266 0000025F EB4C                    		jmp	short DOCOM1
  1267                                  
  1268 00000261 833EF50B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1269 00000266 741C                    		jz	short REGCOM
  1270                                  		;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  1271 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1272 0000026B 8736F50B                		xchg	si,[SINGLECOM]
  1273 0000026F BF[1240]                		mov	di,COMBUF+2
  1274 00000272 31C9                    		xor	cx,cx
  1275                                  SINGLELOOP:
  1276 00000274 AC                      		lodsb
  1277 00000275 AA                      		stosb
  1278 00000276 41                      		inc	cx
  1279 00000277 3C0D                    		cmp	al,0Dh
  1280 00000279 75F9                    		jnz	short SINGLELOOP
  1281 0000027B 49                      		dec	cx
  1282 0000027C 0E                      		push	cs
  1283 0000027D 1F                      		pop	ds
  1284 0000027E 880E[1140]              		mov	[COMBUF+1],cl
  1285                                  
  1286                                  ; do NOT issue a trailing CRLF...
  1287                                  
  1288 00000282 EB29                    		jmp	short DOCOM1
  1289                                  
  1290                                  		;nop
  1291                                  
  1292                                  ; We have a normal command.  
  1293                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1294                                  ; sometimes they aren't. At this point, we automatically close all spool
  1295                                  ; files and turn on truncation mode.
  1296                                  
  1297                                  REGCOM:
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1299                                  		;mov	ax,5D09h
  1300 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1301 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1302                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1303                                  		;mov	ax,5D08h
  1304 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1305 0000028C B201                    		mov	dl,1
  1306 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1307                                  				; DL = 00h redirected output is	combined
  1308                                  				;      01h redirected output placed in separate	jobs
  1309                                  				; start	new print job now
  1310 00000290 0E                      		push	cs
  1311 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1312 00000292 BA[8D3F]                		mov	dx,UCOMBUF
  1313                                  
  1314                                  		; MSDOS 6.0
  1315                                  ;	Try to read interactive command line via DOSKey.
  1316                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1317                                  
  1318                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1319                                  		;int	2fh
  1320                                  		;or	ax,ax
  1321                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1322                                  
  1323                                  		;mov	ah,0Ah
  1324 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1325 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1326                                  				; DS:DX	-> buffer
  1327                                  ;GOTCOM:
  1328 00000299 8A0E[8D3F]              		mov	cl,[UCOMBUF]
  1329 0000029D 30ED                    		xor	ch,ch
  1330 0000029F 83C103                  		add	cx,3
  1331 000002A2 BE[8D3F]                		mov	si,UCOMBUF
  1332 000002A5 BF[1040]                		mov	di,COMBUF
  1333 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1334                                  DOCOM:
  1335 000002AA E89E16                  		call	CRLF2
  1336                                  DOCOM1:
  1337 000002AD E85619                  		call	PRESCAN		; Cook the input buffer
  1338 000002B0 7406                    		jz	short NOPIPEPROC
  1339 000002B2 E9701C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1340                                  
  1341                                  NULLCOMJ:
  1342 000002B5 E9F900                  		jmp	NULLCOM
  1343                                  
  1344                                  NOPIPEPROC:
  1345 000002B8 E89520                  		call	PARSELINE
  1346 000002BB 730B                    		jnb	short OKPARSE	; user error?  or maybe we goofed?
  1347                                  BADPARSE:
  1348 000002BD 0E                      		push	cs
  1349 000002BE 1F                      		pop	ds
  1350 000002BF BA[1B37]                		mov	dx,BADNAMPTR
  1351 000002C2 E88631                  		call	STD_EPRINTF
  1352 000002C5 E93CFE                  		jmp	TCOMMAND
  1353                                  
  1354                                  OKPARSE:
  1355                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1356 000002C8 F606[EB44]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1357 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1358                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1359 000002CF 833E[A947]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1360 000002D4 74DF                    		jz	short NULLCOMJ
  1361                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1362 000002D6 833E[EE44]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1363 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1364                                  
  1365 000002DD BE[1240]                		mov	si,COMBUF+2
  1366 000002E0 BF[2B42]                		mov	di,IDLEN
  1367                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1368                                  					; Make FCB with blank scan-off
  1369 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1370                                  		;mov	ax,2901h
  1371 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1372                                  				; DS:SI	-> string to parse
  1373                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1374                                  				; AL = bit mask	to control parsing
  1375                                  		;mov	bx,[ARG_ARGV]
  1376 000002E8 8B1E[E944]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1377 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1378 000002F0 751B                    		jne	short DRVGD	; no, use default of zero...
  1379 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1380                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1381                                  		;and	dl,~20h
  1382 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1383                                  		;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1384                                  		; 01/03/2023
  1385 000002F7 80EA41                  		sub	dl,capital_A  ; sub dl,'A'
  1386 000002FA 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1387 000002FC 740C                    		jz	short DRVBADJ	; It was invalid.
  1388                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1389 000002FE 8B3E[EC44]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1390 00000302 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1391 00000305 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1392 00000307 E9F6FD                  		jmp	SETDRV		; and set drive to new drive spec
  1393                                  DRVBADJ:
  1394 0000030A E9A817                  		jmp	DRVBAD
  1395                                  DRVGD:
  1396 0000030D 8A05                    		mov	al,[di]
  1397 0000030F A2[D141]                		mov	[SPECDRV],al
  1398 00000312 B020                    		mov	al,' '
  1399 00000314 B90900                  		mov	cx,9
  1400 00000317 47                      		inc	di
  1401 00000318 F2AE                    		repne scasb		; Count number of letters in command name
  1402 0000031A B008                    		mov	al,8
  1403 0000031C 28C8                    		sub	al,cl
  1404 0000031E A2[2B42]                		mov	[IDLEN],al	; IDLEN is truly the length
  1405 00000321 BF8100                  		mov	di,81h
  1406 00000324 56                      		push	si
  1407 00000325 BE[1240]                		mov	si,COMBUF+2	; Skip over all leading delims
  1408 00000328 E82D16                  		call	SCANOFF
  1409                                  
  1410                                  		; MSDOS 6.0
  1411                                  ;SR;
  1412                                  ; We are going to skip over the first char always. The logic is that the
  1413                                  ;command tail can never start from the first character. The code below is 
  1414                                  ;trying to figure out the command tail and copy it to the command line 
  1415                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1416                                  ;character and the user given command line is a full 128 bytes, we try to
  1417                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1418                                  ;char overwrites the code and leads to a crash on future commands.
  1419                                  ;
  1420                                  		;inc	si ;  MSDOS 6.0
  1421                                  DO_SKIPCOM:
  1422 0000032B AC                      		lodsb			; move command line pointer over
  1423 0000032C E83116                  		call	DELIM		; pathname -- have to do it ourselves
  1424 0000032F 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1425 00000331 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1426 00000333 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1427 00000335 3A06[B541]              		cmp	al,[SWITCHAR]	; specified command string
  1428 00000339 75F0                    		jnz	short DO_SKIPCOM 
  1429                                  DO_SKIPPED:
  1430 0000033B 4E                      		dec	si
  1431 0000033C 31C9                    		xor	cx,cx
  1432                                  COMTAIL:
  1433 0000033E AC                      		lodsb
  1434 0000033F AA                      		stosb			; Move command tail to 80h
  1435 00000340 3C0D                    		cmp	al,0Dh
  1436 00000342 E0FA                    		loopne	COMTAIL
  1437 00000344 4F                      		dec	di
  1438 00000345 89FD                    		mov	bp,di
  1439 00000347 F6D1                    		not	cl
  1440 00000349 880E8000                		mov	[80h],cl
  1441 0000034D 5E                      		pop	si
  1442                                  ;-----
  1443                                  ; Some of these comments are sadly at odds with this brave new code.
  1444                                  ;-----
  1445                                  ; If the command has 0 parameters must check here for
  1446                                  ; any switches that might be present.
  1447                                  ; SI -> first character after the command.
  1448                                  
  1449                                  		;mov	di, arg.argv[0].argsw_word
  1450                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1451 0000034E 8B3E[F044]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1452 00000352 893E[C841]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1453                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1454                                  					; s = argv[1];
  1455                                  		;mov	si,[ARGV1_ARGPOINTER]
  1456 00000356 8B36[F444]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1457 0000035A 09F6                    		or	si,si		;   if (s == NULL)
  1458 0000035C 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1459 0000035E 89EE                    		mov	si,bp
  1460                                  DOPARSE:
  1461 00000360 BF5C00                  		mov	di,FCB ; 5Ch
  1462                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1463                                  		;mov	ax,2901h
  1464 00000363 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1465 00000366 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1466                                  				; DS:SI	-> string to parse
  1467                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1468                                  				; AL = bit mask	to control parsing
  1469 00000368 A2[C641]                		mov	[PARM1],al	; Save result of parse
  1470                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1471                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1472 0000036B 8B3E[FB44]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1473 0000036F 893E[CA41]              		mov	[ARG1S],di
  1474                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1475                                  					; s = argv[2];
  1476                                  		;mov	si,[ARGV2_ARGPOINTER]
  1477 00000373 8B36[FF44]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1478 00000377 09F6                    		or	si,si		;   if (s == NULL)
  1479 00000379 7502                    		jnz	short DOPARSE2
  1480 0000037B 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1481                                  DOPARSE2:			
  1482 0000037D BF6C00                  		mov	di,FCB+10H ; 6Ch
  1483                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1484                                  		;mov	ax,2901h
  1485 00000380 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1486 00000383 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1487                                  				; DS:SI	-> string to parse
  1488                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1489                                  				; AL = bit mask	to control parsing
  1490 00000385 A2[C741]                		mov	[PARM2],al	; Save result
  1491                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1492                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1493 00000388 8B3E[0645]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1494 0000038C 893E[CC41]              		mov	[ARG2S],di
  1495                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1496                                  		;mov	di,arg.argv[0].argsw_word
  1497 00000390 8B3E[F044]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1498 00000394 F7D7                    		not	di		; ARGTS doesn't include the flags
  1499                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1500                                  		;and	di,arg.argswinfo	
  1501 00000396 233E[AB47]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1502 0000039A 893E[CE41]              		mov	[ARGTS],di
  1503                                  
  1504 0000039E A0[2B42]                		mov	al,[IDLEN]
  1505 000003A1 8A16[D141]              		mov	dl,[SPECDRV]
  1506 000003A5 08D2                    		or	dl,dl		; if a drive was specified...
  1507 000003A7 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1508 000003A9 FEC8                    		dec	al		; (I don't know why -- old code did it)
  1509 000003AB E91017                  		jmp	FNDCOM		; otherwise, check internal com table
  1510                                  EXTERNALJ1:
  1511 000003AE E9BE17                  		jmp	EXTERNAL
  1512                                  NULLCOM:
  1513 000003B1 8E1E[B141]              		mov	ds,[RESSEG]
  1514 000003B5 F706990BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1515 000003BB 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1516                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1517 000003BD C606040C01              		mov	byte [NULLFLAG],nullcommand ; 1
  1518                                  NOSETFLAG:
  1519 000003C2 833EF50BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1520 000003C7 7403                    		jz	short EXITJ
  1521 000003C9 E90BFE                  		jmp	GETCOM
  1522                                  EXITJ:
  1523 000003CC E958FD                  		jmp	_$EXITPREP
  1524                                  
  1525                                  ;============================================================================
  1526                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1527                                  ;============================================================================
  1528                                  ; 12/10/2018 - Retro DOS v3.0
  1529                                  
  1530                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1531                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1532                                  ;   there is a header that describes a block of rom program.  This header
  1533                                  ;   contains information needed to initialize a module and to provide PCDOS
  1534                                  ;   with a set of reserved names for execution.
  1535                                  ;
  1536                                  ;   This header has the following format:
  1537                                  ;
  1538                                  ;   rom_header	STRUC
  1539                                  ;	Signature1  DB	55h
  1540                                  ;	Signature2  DB	AAh
  1541                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1542                                  ;	init_jmp    DB	3 dup (?)
  1543                                  ;	name_list   name_struc <>
  1544                                  ;   rom_header	ENDS
  1545                                  ;
  1546                                  ;   name_struc	STRUC
  1547                                  ;	name_len    DB	?
  1548                                  ;	name_text   DB	? DUP (?)
  1549                                  ;	name_jmp    DB	3 DUP (?)
  1550                                  ;   name_struc	ENDS
  1551                                  ;
  1552                                  ;   The name list is a list of names that are reserved by a particular section
  1553                                  ;   of a module.  This list of names is terminated by a null name (length
  1554                                  ;   is zero).
  1555                                  ;
  1556                                  ;   Consider now, the PCDOS action when a user enters a command:
  1557                                  ;
  1558                                  ;	COMMAND.COM has control.
  1559                                  ;	o   If location FFFFEh has FDh then
  1560                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1561                                  ;		    by AAh, stop scan if we get above or = F0000H
  1562                                  ;	o	When we've found one, compare the name entered by the user
  1563                                  ;		    with the one found in the rom.  If we have a match, then
  1564                                  ;		    set up the environment for execution and do a long jump
  1565                                  ;		    to the near jump after the found name.
  1566                                  ;	o	If no more names in the list, then continue scanning the module
  1567                                  ;		    for more 55h followed by AAh.
  1568                                  ;	o   We get to this point only if there is no matching name in the
  1569                                  ;		rom.  We now look on disk for the command.
  1570                                  ;
  1571                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1572                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1573                                  ;   want to be invisible to the DOS should not have any names in their lists
  1574                                  ;   (i.e. they have a single null name).
  1575                                  ;
  1576                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1577                                  ;   Clearly this version will be available on disk.  How does a user actually
  1578                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1579                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1580                                  ;   solution:
  1581                                  ;
  1582                                  ;   o	Keep things consistent and force the user to have his software named
  1583                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1584                                  
  1585                                  struc ROM_HEADER
  1586 00000000 ??                          .signature1: resb 1
  1587 00000001 ??                          .signature2: resb 1
  1588 00000002 ??                          .rom_length: resb 1
  1589 00000003 ??????                      .init_jmp:	 resb 3
  1590 00000006 ??                          .name_list:	 resb 1
  1591                                      .size:
  1592                                  endstruc
  1593                                  
  1594                                  struc NAME_STRUC
  1595 00000000 ??                          .name_len:	resb 1
  1596 00000001 ??                          .name_text:	resb 1
  1597 00000002 ??????                      .name_jmp:	resb 3
  1598                                      .size:	
  1599                                  endstruc
  1600                                  
  1601                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1602                                  
  1603                                  ; =============== S U B	R O U T	I N E =======================================
  1604                                  
  1605                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1606                                  
  1607                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1608                                  
  1609                                  ROM_SCAN:
  1610 000003CF 06                      		push	es
  1611 000003D0 56                      		push	si
  1612 000003D1 57                      		push	di
  1613 000003D2 51                      		push	cx
  1614 000003D3 50                      		push	ax
  1615 000003D4 53                      		push	bx
  1616                                  
  1617                                  		; check for PC Jr signature in rom
  1618                                  
  1619 000003D5 B800F0                  		mov	ax,0F000h
  1620 000003D8 8EC0                    		mov	es,ax
  1621 000003DA 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1622 000003E0 7408                    		je	short SCAN_IT
  1623                                  NO_ROM:
  1624 000003E2 F8                      		clc
  1625                                  ROM_RET:
  1626 000003E3 5B                      		pop	bx
  1627 000003E4 58                      		pop	ax
  1628 000003E5 59                      		pop	cx
  1629 000003E6 5F                      		pop	di
  1630 000003E7 5E                      		pop	si
  1631 000003E8 07                      		pop	es
  1632 000003E9 C3                      		retn
  1633                                  
  1634                                  SCAN_IT:	; start scanning at C000h
  1635                                  
  1636 000003EA B800C0                  		mov	ax,0C000h
  1637                                  SCAN_ONE:
  1638 000003ED 8EC0                    		mov	es,ax
  1639 000003EF 31FF                    		xor	di,di
  1640                                  
  1641                                  SCAN_MODULE:	; check for a valid header
  1642                                  
  1643 000003F1 26813D55AA              		cmp	word [es:di],0AA55h
  1644 000003F6 740A                    		jz	short SCAN_LIST
  1645 000003F8 058000                  		add	ax,80h
  1646                                  SCAN_END:
  1647 000003FB 3D00F0                  		cmp	ax,0F000h
  1648 000003FE 72ED                    		jb	short SCAN_ONE
  1649 00000400 EBE0                    		jmp	short NO_ROM
  1650                                  
  1651                                  		; trundle down list of names
  1652                                  SCAN_LIST:
  1653                                  		;mov	bl,[es:di+2]
  1654                                  					; number of 512-byte jobbers
  1655 00000402 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1656 00000406 30FF                    		xor	bh,bh		; nothing in the high byte
  1657 00000408 D1E3                    		shl	bx,1
  1658 0000040A D1E3                    		shl	bx,1		; number of paragraphs
  1659 0000040C 83C37F                  		add	bx,7Fh
  1660 0000040F 83E380                  		and	bx,0FF80h	; round to 2k	
  1661                                  		;mov	di,6
  1662 00000412 BF0200                  		mov	di,ROM_HEADER.rom_length
  1663                                  
  1664                                  		;nop
  1665                                  SCAN_NAME:
  1666 00000415 268A0D                  		mov	cl,[es:di]	; length of name
  1667 00000418 47                      		inc	di		; point to name
  1668 00000419 30ED                    		xor	ch,ch
  1669 0000041B 09C9                    		or	cx,cx		; zero length name
  1670 0000041D 7504                    		jnz	short SCAN_TEST	; nope... compare
  1671 0000041F 01D8                    		add	ax,bx		; yep, skip to next block
  1672 00000421 EBD8                    		jmp	short SCAN_END
  1673                                  
  1674                                  SCAN_TEST:	; compare a single name
  1675                                  
  1676 00000423 89D6                    		mov	si,dx
  1677 00000425 46                      		inc	si
  1678 00000426 F3A6                    		repe cmpsb		 ; compare name
  1679 00000428 7407                    		jz	short SCAN_FOUND ; success!
  1680                                  SCAN_NEXT:
  1681 0000042A 01CF                    		add	di,cx		; failure, next name piece
  1682 0000042C 83C703                  		add	di,3
  1683 0000042F EBE4                    		jmp	short SCAN_NAME
  1684                                  
  1685                                  SCAN_FOUND:	; found a name. save entry location
  1686                                  
  1687 00000431 803C3F                  		cmp	byte [si],'?'
  1688 00000434 7405                    		jz	short SCAN_SAVE
  1689 00000436 803C20                  		cmp	byte [si],' '
  1690 00000439 75EF                    		jnz	short SCAN_NEXT
  1691                                  SCAN_SAVE:
  1692 0000043B 2E8C06[AA43]            		mov	[cs:ROM_CS],es
  1693 00000440 2E893E[A843]            		mov	[cs:ROM_IP],di
  1694 00000445 F9                      		stc
  1695 00000446 EB9B                    		jmp	short ROM_RET
  1696                                  
  1697                                  ; ---------------------------------------------------------------------------
  1698                                  
  1699                                  ; execute a rom-placed body of code. allocate largest block
  1700                                  
  1701                                  ROM_EXEC:
  1702 00000448 BBFFFF                  		mov	bx,0FFFFh
  1703 0000044B B448                    		mov	ah,ALLOC ; 48h
  1704 0000044D CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1705                                  				; BX = number of 16-byte paragraphs desired
  1706 0000044F B448                    		mov	ah,ALLOC ; 48h
  1707 00000451 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1708                                  				; BX = number of 16-byte paragraphs desired
  1709 00000453 53                      		push	bx
  1710 00000454 50                      		push	ax
  1711                                  
  1712                                  		; set terminate addresses
  1713                                  
  1714                                  		;mov	ax,2522h
  1715                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1716 00000455 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1717 00000458 1E                      		push	ds
  1718 00000459 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  1719                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1720                                  		;mov	dx,131h ; MSDOS 3.3
  1721 0000045E BA3101                  		mov	dx,EXEC_WAIT
  1722 00000461 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1723                                  				; AL = interrupt number
  1724                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1725 00000463 8CDA                    		mov	dx,ds
  1726 00000465 8EC2                    		mov	es,dx
  1727 00000467 1F                      		pop	ds
  1728                                  		
  1729                                  		; and create program header and dup all jfn's
  1730                                  
  1731 00000468 5A                      		pop	dx
  1732 00000469 B455                    		mov	ah,DUP_PDB ; 55h
  1733 0000046B CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1734                                  				; DX = segment number at which to set up PSP
  1735                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1736                                  		
  1737                                  		; set up dma address
  1738                                  
  1739 0000046D 8EDA                    		mov	ds,dx
  1740 0000046F BA8000                  		mov	dx,80h
  1741 00000472 B41A                    		mov	ah,SET_DMA ; 1Ah
  1742 00000474 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1743                                  				; DS:DX	-> disk	transfer buffer
  1744                                  
  1745                                  		; copy in environment info
  1746                                  
  1747 00000476 26A1050D                		mov	ax,[es:ENVIRSEG]
  1748 0000047A A32C00                  		mov	[PDB.ENVIRON],	ax
  1749                                  
  1750                                  		; set up correct size of block
  1751                                  
  1752 0000047D 5B                      		pop	bx		; BX has size, DS has segment
  1753 0000047E 8CDA                    		mov	dx,ds
  1754 00000480 01DA                    		add	dx,bx
  1755                                  		;mov	[2],dx
  1756 00000482 89160200                		mov	[PDB.BLOCK_LEN],dx
  1757                                  
  1758                                  		; change ownership of block
  1759                                  
  1760 00000486 8CDA                    		mov	dx,ds
  1761 00000488 4A                      		dec	dx
  1762 00000489 8EDA                    		mov	ds,dx
  1763 0000048B 42                      		inc	dx	
  1764                                  		;mov	[1],dx
  1765 0000048C 89160100                		mov	[ARENA.owner],dx
  1766 00000490 8EDA                    		mov	ds,dx
  1767                                  
  1768                                  		; set up correct stack
  1769                                  
  1770 00000492 81FB0010                		cmp	bx,1000h
  1771 00000496 7202                    		jb	short GOT_STACK
  1772 00000498 31DB                    		xor	bx,bx
  1773                                  GOT_STACK:
  1774 0000049A B104                    		mov	cl,4
  1775 0000049C D3E3                    		shl	bx,cl
  1776 0000049E 8CDA                    		mov	dx,ds
  1777 000004A0 8ED2                    		mov	ss,dx
  1778 000004A2 89DC                    		mov	sp,bx
  1779 000004A4 31C0                    		xor	ax,ax
  1780 000004A6 50                      		push	ax
  1781                                  
  1782                                  		; set up initial registers and go to the guy
  1783                                  
  1784 000004A7 F7D0                    		not	ax
  1785 000004A9 2EFF36[AA43]            		push	word [cs:ROM_CS]
  1786 000004AE 2EFF36[A843]            		push	word [cs:ROM_IP]
  1787 000004B3 8EC2                    		mov	es,dx
  1788 000004B5 CB                      		retf	; far return
  1789                                  
  1790                                  ;============================================================================
  1791                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1792                                  ;============================================================================
  1793                                  ; 12/10/2018 - Retro DOS v3.0
  1794                                  
  1795                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1796                                  
  1797                                  ; =============== S U B	R O U T	I N E =======================================
  1798                                  
  1799                                  ;Break	<PromptBat - Open or wait for batch file>
  1800                                  
  1801                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1802                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1803                                  ; file. Leave segment registers alone.
  1804                                  
  1805                                  PROMPTBAT:
  1806 000004B6 E8EF06                  		call	BATOPEN
  1807 000004B9 7201                    		jc	short PROMPTBAT1
  1808 000004BB C3                      		retn
  1809                                  PROMPTBAT1:
  1810                                  		; MSDOS 6.0 COMMAND.COM
  1811                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1812                                  		;jz	Bat_Remcheck		;AN022;
  1813                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1814                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1815                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1816                                  		;jmp	short BatDie		;AN022;
  1817                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1818                                  		;call	[RCH_ADDR]		; DX has error number
  1819                                  		;jz	AskForBat		; Media is removable
  1820                                  
  1821                                  		; MSDOS 3.3 COMMAND.COM
  1822 000004BC 81FA[7D37]              		cmp	dx,ACCDENPTR
  1823 000004C0 7413                    		jz	short BATDIE
  1824                                  
  1825                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1826                                  BAT_REMCHECK:				; Go see if media is removable
  1827 000004C2 2EFF1E[BB41]            		call	far [cs:RCH_ADDR] ; DX has error number
  1828 000004C7 7417                    		jz	short ASKFORBAT	; Media is removable
  1829                                  
  1830                                  ; The media is not changeable. Turn everything off.
  1831                                  
  1832 000004C9 E8BD09                  		call	FOROFF
  1833 000004CC E8611E                  		call	PIPEOFF
  1834 000004CF A2FA0B                  		mov	[IFFLAG],al	; No If in progress.	
  1835 000004D2 BA[BE36]                		mov	dx,BADPATHPTR
  1836                                  BATDIE:
  1837 000004D5 E84F03                  		call	BATCHOFF
  1838 000004D8 0E                      		push	cs
  1839 000004D9 1F                      		pop	ds
  1840                                  		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
  1841 000004DA E8772F                  		call	STD_PRINTF	; MSDOS 3.3
  1842                                  
  1843                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1844                                  
  1845 000004DD E924FC                  		jmp	TCOMMAND
  1846                                  
  1847                                  ; Ask the user to reinsert the batch file
  1848                                  
  1849                                  ASKFORBAT:
  1850 000004E0 1E                      		push	ds
  1851 000004E1 0E                      		push	cs
  1852 000004E2 1F                      		pop	ds
  1853                                  
  1854                                  		; MSDOS 6.0
  1855                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1856                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1857                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1858                                  		;;invoke std_eprintf		;AN000; get second part of message
  1859                                  						;AN000; print it to stderr
  1860                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1861 000004E3 E8652F                  		call	STD_EPRINTF
  1862 000004E6 E80300                  		call	GETKEYSTROKE
  1863 000004E9 1F                      		pop	ds
  1864 000004EA EBCA                    		jmp	short PROMPTBAT
  1865                                  
  1866                                  
  1867                                  ; MSDOS 6.0
  1868                                  ;****************************************************************
  1869                                  ;*
  1870                                  ;* ROUTINE:	Output_batch_name
  1871                                  ;*
  1872                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1873                                  ;*
  1874                                  ;* INPUT:	DX - extended error number
  1875                                  ;*
  1876                                  ;* OUTPUT:	Ready to call print routine
  1877                                  ;*
  1878                                  ;****************************************************************
  1879                                  ;
  1880                                  ;public	output_batch_name			;AN022;
  1881                                  ;
  1882                                  ;Output_batch_name    proc near			;AN022;
  1883                                  ;
  1884                                  ;		push	ds			;AN022; save resident segment
  1885                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1886                                  ;	assume	DS:nothing			;AN022;
  1887                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1888                                  ;		invoke	dstrlen 		;AN022; get length of string
  1889                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1890                                  ;		rep	movsb			;AN022; move the name
  1891                                  ;
  1892                                  ;		push	cs			;AN022; get local segment
  1893                                  ;		pop	ds			;AN022;
  1894                                  ;	assume	DS:trangroup			;AN022;
  1895                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1896                                  ;		mov	msg_disp_class,ext_msg_class
  1897                                  ;						;AN022; set up extended error msg class
  1898                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1899                                  ;						;AN022; get extended message pointer
  1900                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1901                                  ;						;AN022; point to substitution
  1902                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1903                                  ;		pop	ds			;AN022; restore data segment
  1904                                  ;
  1905                                  ;		ret				;AN022; return
  1906                                  ;
  1907                                  ;Output_batch_name    endp			;AN022;
  1908                                  
  1909                                  
  1910                                  ; =============== S U B	R O U T	I N E =======================================
  1911                                  
  1912                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1913                                  
  1914                                  ; Read the next keystroke. Since there may be several characters in the queue
  1915                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1916                                  ; AFTER waiting.
  1917                                  
  1918                                  GETKEYSTROKE:
  1919                                  		; MSDOS 3.3
  1920                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1921                                  		;mov	ax,0C08h
  1922 000004EC B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1923 000004EF CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1924                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1925                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1926                                  		;mov	ax,0C00h
  1927 000004F1 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1928 000004F4 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1929                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1930 000004F6 C3                      		retn
  1931                                  
  1932                                  		; MSDOS 6.0
  1933                                  		;PUSH	DX				;AN000;  3/3/KK
  1934                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1935                                  		;INT	21h				;AN000;  3/3/KK
  1936                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1937                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1938                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1939                                  		;INT	21h				;AN000;  3/3/KK
  1940                                  		;
  1941                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1942                                  		;INT	21h		; Get character with KB buffer flush
  1943                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1944                                  		;INT	21h
  1945                                  		;
  1946                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1947                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1948                                  		;INT	21h				;AN000;  3/3/KK
  1949                                  		;POP	DX				;AN000;  3/3/KK
  1950                                  		;
  1951                                  		;return
  1952                                  
  1953                                  ; =============== S U B	R O U T	I N E =======================================
  1954                                  
  1955                                  ; Break	<ReadBat - read 1 line from batch file>
  1956                                  
  1957                                  ; ReadBat - read a single line from the batch file. 
  1958                                  ; Perform all substitutions as appropriate.
  1959                                  
  1960                                  READBAT:
  1961                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1962                                  		
  1963                                  		;mov	byte [SUPPRESS],1
  1964                                  					; initialize line suppress status
  1965 000004F7 C606F00B01              		mov	byte [SUPPRESS],YES_ECHO 
  1966 000004FC F606E50BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1967 00000501 7508                    		jnz	short TRYING_TO_ABORT
  1968 00000503 C606E40B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1969                                  
  1970                                  		; MSDOS 6.0
  1971                                  ;
  1972                                  ;M037; Start of changes
  1973                                  ; We check here if we have set the flag indicating that the batchfile is at
  1974                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1975                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1976                                  ;batch file gets closed etc. and then return as if everything is done.
  1977                                  ;
  1978                                  		;push	ds
  1979                                  		;mov	ds,Batch
  1980                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1981                                  		;pop	ds
  1982                                  		;jz	contbat		; no, continue normal processing
  1983                                  		;invoke	GetBatByt	; frees up batchseg
  1984                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1985                                  		;			; as a dummy command
  1986                                  		;invoke CrLf2		; print a CR-LF
  1987                                  		;return			; done batch processing
  1988                                  
  1989                                  ;M037; End of changes
  1990                                  		
  1991                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1992                                  CONTBAT:
  1993 00000508 E8ABFF                  		call	PROMPTBAT
  1994                                  
  1995                                  TRYING_TO_ABORT:
  1996 0000050B BF[1240]                		mov	di,COMBUF+2
  1997                                  
  1998                                  ; Save position and try to scan for first non delimiter.
  1999                                  
  2000                                  TESTNOP:
  2001 0000050E 8CD8                    		mov	ax,ds
  2002 00000510 8E1E990B                		mov	ds,[BATCH]
  2003 00000514 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  2004 00000518 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  2005 0000051C 8ED8                    		mov	ds,ax
  2006 0000051E E88105                  		call	SKIPDELIM	; skip to first non-delim
  2007                                  
  2008                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2009                                  ; beginning and read the line.
  2010                                  
  2011 00000521 3C3A                    		cmp	al,':'		; is it a label?
  2012 00000523 59                      		pop	cx
  2013 00000524 5A                      		pop	dx		; restore position in bat file
  2014 00000525 7431                    		jz	short NOPLINE	; yes, resync everything.
  2015 00000527 F706990BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2016 0000052D 7438                    		jz	short RDBAT	; no, go read batch file
  2017                                  
  2018                                  		;cmp	al,'@'
  2019 0000052F 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2020 00000531 7507                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2021                                  		;mov	byte [SUPPRESS],0
  2022 00000533 C606F00B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2023 00000538 EB2D                    		jmp	short RDBAT	; go read batch file
  2024                                  
  2025                                  		;nop
  2026                                  SET_BAT_POS:
  2027 0000053A 1E                      		push	ds
  2028 0000053B 8E1E990B                		mov	ds,[BATCH]
  2029 0000053F 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2030 00000543 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2031 00000547 1F                      		pop	ds
  2032                                  		;MOV	AX,(LSEEK SHL 8) + 0
  2033 00000548 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2034 0000054B CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2035                                  				; AL = method: offset from beginning of	file
  2036                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2037 0000054D 2EC706[584C]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2038 00000554 31C9                    		xor	cx,cx		; Initialize line length to zero
  2039 00000556 EB0F                    		jmp	short RDBAT
  2040                                  
  2041                                  		;nop
  2042                                  
  2043                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2044                                  ; We eat characters until a CR is seen.
  2045                                  
  2046                                  NOPLINE:
  2047 00000558 E8F400                  		call	SKIPTOEOL
  2048 0000055B E82E03                  		call	GETBATBYT	; eat trailing LF
  2049                                  		;test	word [BATCH],0FFFFh
  2050 0000055E F706990BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2051 00000564 75A8                    		jnz	short TESTNOP	; no, go get another line
  2052                                  READBAT_RETN:				; Hit EOF			
  2053 00000566 C3                      		retn
  2054                                  
  2055                                  ; ---------------------------------------------------------------------------
  2056                                  
  2057                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2058                                  ; input, we are to consider two special cases:
  2059                                  ;
  2060                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2061                                  ;   %sym%	This is a symbol from the environment
  2062                                  
  2063                                  RDBAT:
  2064 00000567 E82203                  		call	GETBATBYT
  2065 0000056A 41                      		inc	cx		; Inc the line length
  2066                                  RDBAT1:
  2067 0000056B 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2068 0000056F 7344                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2069                                  
  2070                                  ; See if we have a parameter character.
  2071                                  
  2072 00000571 3C25                    		cmp	al,'%'		; Check for parameter
  2073 00000573 744A                    		jz	short NEEDPARM
  2074                                  
  2075                                  ; no parameter character. Store it as usual and see if we are done.
  2076                                  
  2077                                  SAVBATBYT:
  2078 00000575 AA                      		stosb			; End of line found?
  2079 00000576 3C0D                    		cmp	al,0Dh
  2080 00000578 75ED                    		jnz	short RDBAT	; no, go for more
  2081                                  
  2082                                  ; We have read in an entire line. 
  2083                                  ; Decide whether we should echo the command line or not.
  2084                                  
  2085                                  FOUND_EOL:
  2086 0000057A 81EF[1340]              		sub	di,COMBUF+3
  2087 0000057E 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2088 00000580 26A2[1140]              		mov	[es:COMBUF+1],al ; Set length of line
  2089 00000584 E80503                  		call	GETBATBYT	; Eat linefeed
  2090 00000587 E80A06                  		call	BATCLOSE
  2091 0000058A 803EF00B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2092 0000058F 7407                    		jz	short RESET
  2093 00000591 F606EF0B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2094 00000596 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2095                                  RESET:
  2096 00000598 0E                      		push	cs
  2097 00000599 1F                      		pop	ds		; Go back to local segment
  2098 0000059A 74CA                    		jz	short READBAT_RETN ; no echoing here...
  2099                                  TRY_NEXTFLAG:
  2100 0000059C 803E040C01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2101                                  					;G was there a command last time?
  2102 000005A1 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2103 000005A3 E8A513                  		call	CRLF2		;G  Print out prompt
  2104                                  NO_CRLF_PRINT:
  2105 000005A6 E8CF0D                  		call	PRINT_PROMPT
  2106 000005A9 0E                      		push	cs		;G change data segment
  2107 000005AA 1F                      		pop	ds
  2108 000005AB BA[1240]                		mov	dx,COMBUF+2	; get command line for echoing
  2109 000005AE E8F713                  		call	CRPRINT
  2110 000005B1 E89713                  		call	CRLF2
  2111 000005B4 C3                      		retn
  2112                                  
  2113                                  ; The line was too long. Eat remainder of input text up until the CR
  2114                                  
  2115                                  TOOLONG:
  2116 000005B5 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2117 000005B7 7403                    		jz	short LTLCONT	; Yes, continue
  2118 000005B9 E89300                  		call	SKIPTOEOL	; Eat remainder of line	
  2119                                  LTLCONT:
  2120 000005BC AA                      		stosb			; Terminate the command
  2121 000005BD EBBB                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2122                                  
  2123                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2124                                  
  2125                                  NEEDPARM:
  2126 000005BF E8CA02                  		call	GETBATBYT	; get next character
  2127 000005C2 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2128 000005C4 74AF                    		jz	short SAVBATBYT	; if so, replace with a single %
  2129 000005C6 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2130 000005C8 74AB                    		jz	short SAVBATBYT	; yes, treat it normally
  2131                                  
  2132                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2133                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2134                                  ; see if the <something> has a terminating % and then look up the contents
  2135                                  ; in the environment.
  2136                                  
  2137                                  PAROK:
  2138 000005CA 2C30                    		sub	al,'0'
  2139 000005CC 7239                    		jb	short NEEDENV	; look for parameter in the environment
  2140 000005CE 3C09                    		cmp	al,9
  2141 000005D0 7735                    		ja	short NEEDENV
  2142                                  
  2143                                  ; We have found %<number>. This is taken from the parameters in the
  2144                                  ; allocated batch area.
  2145                                  
  2146 000005D2 98                      		cbw
  2147 000005D3 89C3                    		mov	bx,ax		; move index into AX
  2148 000005D5 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2149 000005D7 06                      		push	es
  2150 000005D8 8E06990B                		mov	es,[BATCH]
  2151                                  ;
  2152                                  ; The structure of the batch area is:
  2153                                  ;
  2154                                  ;   BYTE    type of segment
  2155                                  ;   DWORD   offset for next line
  2156                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2157                                  ;   ASCIZ   file name (with . and ..)
  2158                                  ;   BYTES   CR-terminated parameters
  2159                                  ;   BYTE    0 flag to indicate end of parameters
  2160                                  ;
  2161                                  ; Get pointer to BX'th argument
  2162                                  ;
  2163                                  		;mov	si,[es:bx+0Bh]
  2164 000005DC 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2165 000005E0 07                      		pop	es
  2166                                  
  2167                                  ; Is there a parameter here?
  2168                                  
  2169 000005E1 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2170 000005E4 7503                    		jnz	short YES_THERE_IS ; Yes go get it
  2171 000005E6 E97EFF                  		jmp	RDBAT		; Ignore if it doesn't
  2172                                  
  2173                                  ; Copy in the found parameter from batch segment
  2174                                  
  2175                                  YES_THERE_IS:
  2176 000005E9 1E                      		push	ds
  2177 000005EA 8E1E990B                		mov	ds,[BATCH]
  2178 000005EE 49                      		dec	cx		; Don't count '%' in line length
  2179                                  COPYPARM:
  2180 000005EF AC                      		lodsb			; From resident segment
  2181 000005F0 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2182 000005F2 740F                    		jz	short ENDPARAM
  2183 000005F4 41                      		inc	cx		; Inc the line length
  2184 000005F5 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2185 000005F9 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2186 000005FB AA                      		stosb
  2187 000005FC EBF1                    		jmp	short COPYPARM
  2188                                  
  2189                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2190                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2191                                  ; believing that we are at EOL. Clobber AL too.
  2192                                  
  2193                                  LINETOOL:
  2194 000005FE 30C0                    		xor	al,al
  2195 00000600 1F                      		pop	ds
  2196 00000601 EBB2                    		jmp	short TOOLONG
  2197                                  
  2198                                  ; We have copied in an entire parameter. Go back for more
  2199                                  
  2200                                  ENDPARAM:
  2201 00000603 1F                      		pop	ds
  2202 00000604 E960FF                  		jmp	RDBAT
  2203                                  
  2204                                  ; We have found % followed by something other than 0-9. We presume that there
  2205                                  ; will be a following % character. In between is an environment variable that
  2206                                  ; we will fetch and replace in the batch line with its value.
  2207                                  
  2208                                  NEEDENV:
  2209                                  		; MSDOS 6.0 COMMAND.COM 
  2210                                  		;dec     cx 		;AN070; Don't count "%"
  2211                                  
  2212                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2213 00000607 1E                      		push	ds
  2214 00000608 57                      		push	di
  2215                                  					; temp spot for name
  2216 00000609 BF[2C42]                		mov	di,ID
  2217 0000060C 0430                    		add	al,'0'		; reconvert character
  2218 0000060E AA                      		stosb			; store it in appropriate place
  2219                                  
  2220                                  ; loop getting characters until the next % is found or until EOL
  2221                                  
  2222                                  GETENV1:
  2223 0000060F E87A02                  		call	GETBATBYT	; get the byte
  2224 00000612 AA                      		stosb			; store it
  2225 00000613 3C0D                    		cmp	al,0Dh		; EOL?
  2226 00000615 7513                    		jnz	short GETENV15	; no, see if it the term char
  2227                                  
  2228                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2229                                  
  2230 00000617 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2231 0000061C BE[2C42]                		mov	si,ID 		; point to buffer
  2232 0000061F 5F                      		pop	di		; point to line buffer
  2233 00000620 0E                      		push	cs
  2234 00000621 1F                      		pop	ds
  2235 00000622 E85E02                  		call	STRCPY
  2236                                  		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
  2237 00000625 4F                      		dec	di  		;  MSDOS 3.3 COMMAND.COM	
  2238 00000626 1F                      		pop	ds
  2239 00000627 E94BFF                  		jmp	SAVBATBYT
  2240                                  GETENV15:
  2241 0000062A 3C25                    		cmp	al,'%'		; terminating %?
  2242 0000062C 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2243                                  
  2244                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2245                                  ; This was the source of bug #1.
  2246                                  ;		dec	cx		;AN070; Don't count "%"
  2247                                  
  2248 0000062E B03D                    		mov	al,'='		; terminate  with =
  2249 00000630 268845FF                		mov	[es:di-1],al
  2250                                  
  2251                                  ; ID now either has a =-terminated string which we are to find in the
  2252                                  ; environment or a non =-terminated string which will not be found in the
  2253                                  ; environment.
  2254                                  
  2255                                  GETENV2:
  2256 00000634 BE[2C42]                		mov	si,ID
  2257 00000637 0E                      		push	cs
  2258 00000638 1F                      		pop	ds		; DS:SI points to name
  2259 00000639 51                      		push	cx
  2260 0000063A E83D11                  		call	FIND_NAME_IN_ENVIRONMENT
  2261 0000063D 59                      		pop	cx
  2262 0000063E 06                      		push	es
  2263 0000063F 1F                      		pop	ds
  2264 00000640 0E                      		push	cs
  2265 00000641 07                      		pop	es
  2266 00000642 89FE                    		mov	si,di
  2267 00000644 5F                      		pop	di		; get back pointer to command line
  2268                                  
  2269                                  ; If the parameter was not found, there is no need to perform any replacement.
  2270                                  ; We merely pretend that we've copied the parameter.
  2271                                  
  2272 00000645 7204                    		jc	short GETENV6
  2273                                  
  2274                                  ; ES:DI points to command line being built
  2275                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2276                                  
  2277 00000647 E83902                  		call	STRCPY		; (let RdBat handle overflow)
  2278 0000064A 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2279                                  GETENV6:
  2280 0000064B 1F                      		pop	ds
  2281 0000064C E918FF                  		jmp	RDBAT		; go back to batch file
  2282                                  
  2283                                  ; =============== S U B	R O U T	I N E =======================================
  2284                                  
  2285                                  ;   SkipToEOL - read from batch file until end of line
  2286                                  
  2287                                  SKIPTOEOL:
  2288 0000064F F706990BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2289                                  		
  2290                                  		;jnz	short SKIPTOEOL1  	
  2291                                  		;retn			; no batch file in effect
  2292                                  		
  2293 00000655 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2294                                  SKIPTOEOL1:
  2295 00000657 E83202                  		call	GETBATBYT
  2296 0000065A 3C0D                    		cmp	al,0Dh		; eol character?
  2297 0000065C 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2298                                  SKIPTOEOL2:
  2299 0000065E C3                      		retn
  2300                                  
  2301                                  ; =============== S U B	R O U T	I N E =======================================
  2302                                  
  2303                                  ;Break	<Allocate and deallocate the transient portion>
  2304                                  
  2305                                  ; Free Transient. Modify ES,AX,flags
  2306                                  
  2307                                  FREE_TPA:
  2308 0000065F 06                      		push	es
  2309 00000660 8E06[B141]              		mov	es,[RESSEG]
  2310 00000664 268E06250D              		mov	es,[es:RES_TPA]
  2311 00000669 B449                    		mov	ah,DEALLOC ; 49h
  2312 0000066B CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2313                                  				; ES = segment address of area to be freed
  2314 0000066D 07                      		pop	es
  2315 0000066E C3                      		retn
  2316                                  
  2317                                  ; =============== S U B	R O U T	I N E =======================================
  2318                                  
  2319                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2320                                  
  2321                                  ALLOC_TPA:
  2322 0000066F 06                      		push	es
  2323 00000670 8E06[B141]              		mov	es,[RESSEG]
  2324 00000674 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2325 00000677 B448                    		mov	ah,ALLOC ; 48h
  2326 00000679 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2327                                  				; BX = number of 16-byte paragraphs desired
  2328 0000067B 53                      		push	bx	  	; Save size of block
  2329 0000067C B448                    		mov	ah,ALLOC ; 48h
  2330 0000067E CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2331                                  				; BX = number of 16-byte paragraphs desired
  2332                                  
  2333                                  ; Attempt to align TPA on 64K boundary
  2334                                  
  2335 00000680 5B                      		pop	bx		; Restore size of block
  2336 00000681 26A3250D                		mov	[es:RES_TPA],ax ; Save segment to beginning of block
  2337 00000685 A3[C141]                		mov	[TRAN_TPA],ax
  2338                                  
  2339                                  ; Is the segment already aligned on a 64K boundary
  2340                                  
  2341 00000688 89C2                    		mov	dx,ax		; Save segment
  2342 0000068A 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2343 0000068D 7507                    		jnz	short CALC_TPA
  2344 0000068F 89D0                    		mov	ax,dx
  2345 00000691 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2346 00000694 7523                    		jnz	short NOROUND
  2347                                  CALC_TPA:
  2348 00000696 89D0                    		mov	ax,dx
  2349 00000698 2500F0                  		and	ax,0F000h
  2350 0000069B 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2351 0000069E 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2352                                  
  2353                                  ; Make sure that new boundary is within allocated range
  2354                                  
  2355 000006A0 268B16250D              		mov	dx,[es:RES_TPA]
  2356 000006A5 01DA                    		add	dx,bx		; Compute maximum address
  2357 000006A7 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2358 000006A9 720E                    		jb	short NOROUND
  2359                                  
  2360                                  ; Make sure that we won't overwrite the transient
  2361                                  
  2362 000006AB 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2363 000006AD 39C3                    		cmp	bx,ax
  2364 000006AF 7208                    		jb	short NOROUND
  2365                                  
  2366                                  ; The area from the 64K boundary to the beginning of the transient must
  2367                                  ; be at least 64K.
  2368                                  
  2369 000006B1 29C3                    		sub	bx,ax
  2370                                  		;cmp	bx,4096
  2371 000006B3 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2372 000006B7 7304                    		jnb	short ROUNDDONE
  2373                                  NOROUND:
  2374 000006B9 26A1250D                		mov	ax,[es:RES_TPA]
  2375                                  ROUNDDONE:
  2376 000006BD 26A3170D                		mov	[es:LTPA],ax ; Re-compute everything
  2377 000006C1 A3[B341]                		mov	[TPA],ax
  2378 000006C4 89C3                    		mov	bx,ax
  2379 000006C6 8CC8                    		mov	ax,cs
  2380 000006C8 29D8                    		sub	ax,bx
  2381 000006CA 53                      		push	bx
  2382 000006CB BB1000                  		mov	bx,16
  2383 000006CE F7E3                    		mul	bx
  2384 000006D0 5B                      		pop	bx
  2385 000006D1 09D2                    		or	dx,dx
  2386 000006D3 7403                    		jz	short SAVSIZ2
  2387 000006D5 B8FFFF                  		mov	ax,-1
  2388                                  SAVSIZ2:
  2389                                  
  2390                                  ; AX is the number of bytes free in the buffer between the resident and the
  2391                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2392                                  
  2393 000006D8 3D0002                  		cmp	ax,512
  2394 000006DB 7603                    		jbe	short GOTSIZE2
  2395                                  		;and	ax,~1FFh
  2396 000006DD 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2397                                  GOTSIZE2:
  2398 000006E0 A3[D241]                		mov	[BYTCNT],ax
  2399 000006E3 07                      		pop	es
  2400 000006E4 C3                      		retn
  2401                                  
  2402                                  ; =============== S U B	R O U T	I N E =======================================
  2403                                  
  2404                                  ;Break	<BatCom - enter a batch file>
  2405                                  
  2406                                  ; The exec search has determined that the user has requested a batch file for
  2407                                  ; execution. We parse the arguments, create the batch segment, and signal
  2408                                  ; batch processing.
  2409                                  
  2410                                  BATCOM:	
  2411                                  
  2412                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2413                                  
  2414                                  ; Batch parameters are read with ES set to segment of resident part
  2415                                  
  2416                                  		; MSDOS 6.0
  2417                                  		;mov	es,[RESSEG]
  2418                                  		;ASSUME	ES:RESGROUP
  2419                                  		;cmp	es:[call_batch_flag],call_in_progress
  2420                                  		;				;AN043; If in CALL,
  2421                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2422                                  		;invoke	IOSET			; Set up any redirection
  2423                                  ;skip_ioset:					;AN043;
  2424                                  		;call	FREE_TPA		; G
  2425                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2426                                  		;jz	getecho 		; G if we're in a call, don't execute
  2427                                  
  2428                                  		; MSDOS 3.3
  2429 000006E5 E8E216                  		call	IOSET
  2430 000006E8 8E06[B141]              		mov	es,[RESSEG]
  2431 000006EC E870FF                  		call	FREE_TPA
  2432                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2433 000006EF 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2434 000006F5 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2435                                  
  2436                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2437                                  
  2438                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2439                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2440                                  ; Don't execute if in call
  2441                                  
  2442 000006F7 E88F07                  		call	FOROFF
  2443                                  GETECHO:
  2444 000006FA E8331C                  		call	PIPEOFF
  2445 000006FD 26A0EF0B                		mov	al,[es:ECHOFLAG]	; preserve echo state for chaining
  2446 00000701 2401                    		and	al,1		; Save current echo state
  2447                                  
  2448 00000703 50                      		push	ax
  2449 00000704 31C0                    		xor	ax,ax
  2450 00000706 26F706990BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2451 0000070D 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2452 0000070F 26A1990B                		mov	ax,[es:BATCH]	; Get current batch segment
  2453                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2454 00000713 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2455 00000719 7408                    		jz	short LEAVEBAT
  2456                                  
  2457                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2458                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2459                                  
  2460 0000071B 06                      		push	es
  2461 0000071C 8EC0                    		mov	es,ax		; Get current batch segment
  2462                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2463                                  					; Get previous batch segment
  2464 0000071E 26A10200                		mov	ax,[es:BATCHSEGMENT.BatLast]
  2465 00000722 07                      		pop	es
  2466                                  LEAVEBAT:
  2467 00000723 50                      		push	ax		; Keep segment until new one created
  2468 00000724 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2469 0000072A 7403                    		jz	short STARTBAT
  2470 0000072C E8F800                  		call	BATCHOFF
  2471                                  
  2472                                  ; Find length of batch file
  2473                                  
  2474                                  STARTBAT:
  2475 0000072F 26C606010C00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2476 00000735 BE[D940]                		mov	si,EXECPATH
  2477                                  
  2478                                  		; MSDOS 6.0
  2479                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2480                                  		;int	2fh		;AN042;    was found with APPEND
  2481                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2482                                  		;mov	dx,si		;AN042; Get the string
  2483                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2484                                  		;int	21h		;AN042;
  2485                                  
  2486                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2487 00000738 E84617                  		call	DSTRLEN
  2488                                  ;
  2489                                  ; Allocate batch area:
  2490                                  ;   BYTE    type of segment
  2491                                  ;   WORD    segment of last batch file
  2492                                  ;   WORD    segment for FOR command
  2493                                  ;   BYTE    FOR flag state on entry to batch file
  2494                                  ;   DWORD   offset for next line
  2495                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2496                                  ;   ASCIZ   file name (with . and ..)
  2497                                  ;   BYTES   CR-terminated parameters
  2498                                  ;   BYTE    0 flag to indicate end of parameters
  2499                                  ;
  2500                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2501                                  ; later when we've squeezed out the extra
  2502                                  ;
  2503 0000073B 89CB                    		mov	bx,cx		; length of file name.
  2504                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2505 0000073D 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2506                                  					; structure + max len + round up
  2507 00000741 51                      		push	cx
  2508 00000742 B104                    		mov	cl,4
  2509 00000744 D3EB                    		shr	bx,cl		; convert to paragraphs
  2510 00000746 53                      		push	bx		; Save size of batch segment
  2511 00000747 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2512 00000749 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2513                                  				; BX = number of 16-byte paragraphs desired
  2514 0000074B 5B                      		pop	bx		; Get size of batch segment
  2515                                  
  2516                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2517                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2518                                  ; G This error will occur with nesting of batch files. We also need to
  2519                                  ; G make sure that we don't overlay the transient.
  2520                                  
  2521 0000074C 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2522                                  
  2523 0000074E 50                      		push	ax		;G save batch segment
  2524 0000074F 01D8                    		add	ax,bx		;G get end of batch segment
  2525 00000751 83C020                  		add	ax,20h		;G add some tpa work area
  2526 00000754 8CCB                    		mov	bx,cs		;G get the transient segment
  2527                                  
  2528                                  		; MSDOS 6.0
  2529                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2530                                  ; M006; batchseg is always above the transient. We need to change this code
  2531                                  ; M006; to only check for an overlap
  2532                                  ;
  2533                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2534                                  		;add	dx,15		;round up para; M006
  2535                                  		;shr	dx,cl		;para size of transient; M006
  2536                                  		;add	dx,bx		;dx = top of transient; M006
  2537                                  
  2538                                  		;cmp	ax,bx		; M006
  2539                                  		;jb	enough_mem	; Batchseg below transient
  2540                                  					; enough memory ; M006
  2541                                  		;cmp	ax,dx		; M006
  2542                                  		;ja	enough_mem	; Batchseg above transient
  2543                                  					; enough memory ; M006
  2544                                  ;
  2545                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2546                                  ;
  2547                                  		;pop	ax		; restore ax; M006
  2548                                  
  2549                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2550                                  ;M006;		pop	ax		;G get batch segment back
  2551                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2552                                  
  2553                                  		; MSDOS 3.3
  2554 00000756 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2555 00000758 58                      		pop	ax		; get batch segment back
  2556 00000759 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2557                                  
  2558                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2559 0000075B 06                      		push	es		;G no we're hitting the transient
  2560 0000075C 8EC0                    		mov	es,ax
  2561 0000075E B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2562 00000761 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2563                                  				; ES = segment address of area to be freed
  2564 00000763 07                      		pop	es
  2565                                  MEM_ERROR:
  2566 00000764 E9B400                  		jmp	NO_MEMORY	;G Set up for message and exit
  2567                                  
  2568                                  ENOUGH_MEM:
  2569                                  		; MSDOS 6.0
  2570                                  		;pop	ax		; restore ax; M006
  2571                                  
  2572                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2573 00000767 26A3990B                		mov	[es:BATCH],ax
  2574 0000076B E801FF                  		call	ALLOC_TPA
  2575                                  
  2576                                  ; Initialize batch segment
  2577                                  
  2578 0000076E 5A                      		pop	dx		; length of name
  2579 0000076F 58                      		pop	ax		;G get saved batch segment back
  2580 00000770 26FF06FE0B              		inc	word [es:NEST]	;G increment # batch files in progress
  2581 00000775 06                      		push	es
  2582 00000776 268E06990B              		mov	es,[es:BATCH]
  2583                                  		;mov	byte [es:0],0
  2584                                  					; signal batch file type
  2585 0000077B 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2586                                  		;mov	[es:2],ax ; MSDOS 3.3
  2587                                  					;G save segment of last batch file
  2588 00000781 26A30200                		mov	[es:BATCHSEGMENT.BatLast],ax
  2589 00000785 1E                      		push	ds
  2590 00000786 8E1E[B141]              		mov	ds,[RESSEG]	;G set to resident data
  2591                                  
  2592 0000078A 31C0                    		xor	ax,ax
  2593 0000078C 8A1EFB0B                		mov	bl,[FORFLAG]	;G get the current FOR state
  2594                                  		;mov	[es:6],bl ; MSDOS 3.3
  2595                                  					;G save it in the batch segment
  2596 00000790 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2597 00000795 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2598 00000798 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2599 0000079A A1FC0B                  		mov	ax,[FORPTR]	;G yes, get current FOR segment	
  2600 0000079D C606FB0B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2601                                  FOR_NOT_ON:
  2602                                  		;mov	[es:4],ax ; MSDOS 3.3
  2603                                  					;G save FOR segment in batch segment
  2604 000007A2 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2605 000007A6 31C0                    		xor	ax,ax
  2606 000007A8 A3FC0B                  		mov	[FORPTR],ax	;G make sure for segment is not active
  2607 000007AB 8A1EEF0B                		mov	bl,[ECHOFLAG]
  2608 000007AF 1F                      		pop	ds
  2609                                  		;mov	[es:1],bl 
  2610                                  					 ;G save echo state of parent
  2611 000007B0 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2612                                  ;SR;
  2613                                  ; Initialize the new BatchEOF flag we have added to 0
  2614                                  ;
  2615                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2616                                  
  2617 000007B5 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2618 000007B9 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2619                                  
  2620                                  ; Initialize pointers
  2621                                  
  2622 000007BD 48                      		dec	ax		; put -1 into AX
  2623                                  		;mov	di,0Bh  ; MSDOS 3.3
  2624                                  					; point to parm area
  2625 000007BE BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2626 000007C1 89FB                    		mov	bx,di
  2627 000007C3 B90A00                  		mov	cx,10
  2628 000007C6 F3AB                    		rep stosw		; Init to no parms
  2629                                  
  2630                                  ; Move in batch file name
  2631                                  
  2632 000007C8 89D1                    		mov	cx,dx
  2633 000007CA F3A4                    		rep movsb
  2634                                  
  2635                                  ; Now copy the command line into batch segment, parsing the arguments along
  2636                                  ; the way. Segment will look like this:
  2637                                  ;
  2638                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2639                                  ;
  2640                                  ; or, in the case of fewer arguments:
  2641                                  ;
  2642                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2643                                  ;
  2644 000007CC BE[1240]                		mov	si,COMBUF+2
  2645 000007CF B90A00                  		mov	cx,10		; at most 10 arguments
  2646                                  EACHPARM:
  2647 000007D2 E88311                  		call	SCANOFF		; skip to argument
  2648                                  
  2649                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2650                                  
  2651 000007D5 3C0D                    		cmp	al,0Dh		; end of road?
  2652 000007D7 741D                    		jz	short HAVPARM	; yes, no more arguments
  2653                                  
  2654                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2655                                  
  2656 000007D9 E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2657                                  
  2658                                  ; Go into allocated piece and stick in new argument pointer.
  2659                                  
  2660 000007DB 26893F                  		mov	[es:bx],di	; store batch pointer
  2661 000007DE 83C302                  		add	bx,2		; advance arg counter
  2662                                  
  2663                                  ; Move the parameter into batch segment
  2664                                  
  2665                                  MOVPARM:
  2666 000007E1 AC                      		lodsb			; get byte
  2667 000007E2 E87B11                  		call	DELIM		; if delimiter
  2668 000007E5 7407                    		jz	short ENDPARM	; then done with parm
  2669 000007E7 AA                      		stosb			; store byte
  2670 000007E8 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2671 000007EA 740A                    		jz	short HAVPARM	; but end of parm list, finish
  2672 000007EC EBF3                    		jmp	short MOVPARM
  2673                                  
  2674                                  ; We have copied a parameter up until the first separator.
  2675                                  ; Terminate it with CR.
  2676                                  
  2677                                  ENDPARM:
  2678 000007EE B00D                    		mov	al,0Dh
  2679 000007F0 AA                      		stosb
  2680 000007F1 E3DF                    		jcxz	EACHPARM	; if no parameters, don't dec
  2681 000007F3 49                      		dec	cx		; remember that we've seen one.	
  2682 000007F4 EBDC                    		jmp	short EACHPARM
  2683                                  
  2684                                  ; We have parsed the entire line. Terminate the arg list
  2685                                  
  2686                                  HAVPARM:
  2687 000007F6 30C0                    		xor	al,al		; Nul terminate the parms
  2688 000007F8 AA                      		stosb
  2689                                  
  2690                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2691                                  ; into paragraphs and setblock to the appropriate size
  2692                                  
  2693 000007F9 8D5D0F                  		lea	bx,[di+15]
  2694 000007FC B104                    		mov	cl,4
  2695 000007FE D3EB                    		shr	bx,cl
  2696 00000800 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2697 00000802 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2698                                  				; ES = segment address of block	to change
  2699                                  				; BX = new size	in paragraphs
  2700 00000804 07                      		pop	es
  2701 00000805 06                      		push	es
  2702 00000806 1F                      		pop	ds		; Simply batch FCB setup
  2703 00000807 833EF50BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2704 0000080C 7506                    		jnz	short NOBATSING
  2705 0000080E C706F50BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2706                                  NOBATSING:
  2707                                  
  2708                                  ; Enter the batch file with the current echo state
  2709                                  
  2710 00000814 58                      		pop	ax		; Get original echo state
  2711 00000815 A2EF0B                  		mov	[ECHOFLAG],al	; restore it
  2712 00000818 E9E9F8                  		jmp	TCOMMAND
  2713                                  
  2714                                  ; The following is executed if there isn't enough memory for batch segment
  2715                                  
  2716                                  NO_MEMORY:
  2717 0000081B 5A                      		pop	dx		; even up our stack 
  2718 0000081C 58                      		pop	ax
  2719 0000081D 58                      		pop	ax
  2720 0000081E E84EFE                  		call	ALLOC_TPA	; reallocate memory
  2721                                  
  2722                                  		; MSDOS 3.3
  2723 00000821 BA[0A3C]                		mov	dx,INSFMEMMESPTR
  2724 00000824 E9D913                  		jmp	CERROR
  2725                                  
  2726                                  		; MSDOS 6.0
  2727                                  		;mov	msg_disp_class,ext_msg_class
  2728                                  		;			;AN000; set up extended error msg class
  2729                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2730                                  		;			;AC000; get extended message pointer
  2731                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2732                                  		;			;AN000; get message number in control block
  2733                                  		;jmp	cerror		;g print error message and go...
  2734                                  
  2735                                  ; =============== S U B	R O U T	I N E =======================================
  2736                                  
  2737                                  BATCHOFF:
  2738 00000827 50                      		push	ax
  2739 00000828 06                      		push	es
  2740 00000829 1E                      		push	ds
  2741 0000082A 53                      		push	bx
  2742                                  
  2743 0000082B 2E8E06[B141]            		mov	es,[cs:RESSEG]
  2744 00000830 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  2745 00000835 A1990B                  		mov	ax,[BATCH]	; Free the batch segment
  2746 00000838 09C0                    		or	ax,ax
  2747 0000083A 7442                    		jz	short NOTFREE
  2748                                  
  2749 0000083C 06                      		push	es
  2750 0000083D 8EC0                    		mov	es,ax
  2751 0000083F F606EF0B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2752 00000844 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2753                                  		;mov	byte [SUPPRESS],0
  2754 00000846 C606F00B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2755                                  ECHO_LAST_LINE:
  2756                                  		;mov	bl,[es:1]
  2757 0000084B 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2758 00000850 881EEF0B                		mov	[ECHOFLAG],bl	; G and restore it
  2759                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2760 00000854 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2761 00000859 891EFC0B                		mov	[FORPTR],bx	;G  and restore it
  2762                                  		;mov	bl,[es:6]
  2763 0000085D 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2764 00000862 881EFB0B                		mov	[FORFLAG],bl	;G  and restore it
  2765                                  		;mov	bx,[es:2] ; MSDOS 3.3
  2766 00000866 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment
  2767                                  
  2768 0000086B B449                    		mov	ah,DEALLOC ; 49h
  2769 0000086D CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2770                                  				; ES = segment address of area to be freed
  2771 0000086F 07                      		pop	es
  2772 00000870 891E020C                		mov	[NEXT_BATCH],bx	;G  reset batch segment	
  2773 00000874 26FF0EFE0B              		dec	word [es:NEST]
  2774 00000879 31C0                    		xor	ax,ax
  2775 0000087B A3990B                  		mov	[BATCH],ax	; No batch in progress
  2776                                  NOTFREE:
  2777 0000087E 5B                      		pop	bx
  2778 0000087F 1F                      		pop	ds
  2779 00000880 07                      		pop	es
  2780 00000881 58                      		pop	ax
  2781 00000882 C3                      		retn
  2782                                  
  2783                                  ; =============== S U B	R O U T	I N E =======================================
  2784                                  
  2785                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2786                                  ;	Entry : DS:SI ==> source string
  2787                                  ;		ES:DI ==> destination string
  2788                                  ;		CX = current length of destination string
  2789                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2790                                  
  2791                                  		; MSDOS 3.3
  2792                                  STRCPY:
  2793 00000883 50                      		push	ax
  2794                                  CCYCLE:
  2795 00000884 AC                      		lodsb
  2796 00000885 AA                      		stosb
  2797 00000886 08C0                    		or	al,al
  2798 00000888 75FA                    		jnz	short CCYCLE
  2799 0000088A 58                      		pop	ax
  2800 0000088B C3                      		retn
  2801                                  
  2802                                  		; MSDOS 6.0
  2803                                  ;Procedure StrCpy,NEAR
  2804                                  		;push	ax
  2805                                  ;ccycle:
  2806                                  		;lodsb
  2807                                  		;inc	cx
  2808                                  		;cmp	cx,COMBUFLEN
  2809                                  		;jb	ccopy
  2810                                  		;stc			; set carry to signal error
  2811                                  		;jmp	short ccend
  2812                                  ;ccopy:
  2813                                  		;stosb
  2814                                  		;or	al,al
  2815                                  		;jnz	ccycle
  2816                                  ;ccend:
  2817                                  		;dec	cx		; discount extra byte
  2818                                  		;dec	di		; back up pointer
  2819                                  		;pop	ax
  2820                                  		;return			; return carry clear
  2821                                  ;EndProc StrCpy
  2822                                  
  2823                                  ;============================================================================
  2824                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2825                                  ;============================================================================
  2826                                  ; 12/10/2018 - Retro DOS v3.0
  2827                                  
  2828                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2829                                  
  2830                                  ; =============== S U B	R O U T	I N E =======================================
  2831                                  
  2832                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2833                                  
  2834                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2835                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2836                                  ; AH, DX destroyed.
  2837                                  
  2838                                  GETBATBYT:
  2839 0000088C 53                      		push	bx
  2840 0000088D 51                      		push	cx
  2841 0000088E 1E                      		push	ds
  2842 0000088F F606E50BFF              		test	byte [BATCH_ABORT],-1
  2843 00000894 755E                    		jnz	short BATEOF
  2844 00000896 F706990BFFFF            		test	word [BATCH],-1
  2845 0000089C 7456                    		jz	short BATEOF
  2846 0000089E 06                      		push	es
  2847 0000089F 8E06990B                		mov	es,[BATCH]
  2848                                  
  2849                                  		; MSDOS 6.0
  2850                                  ;M020;
  2851                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2852                                  ;try to read from the batchfile again.
  2853                                  ;
  2854                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2855                                  		;jz	not_eof		;no, read batch file	;M020
  2856                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2857                                  ;not_eof:							;M020
  2858                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2859 000008A3 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2860 000008A9 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2861 000008AF 07                      		pop	es
  2862                                  
  2863                                  ; See if we have bytes buffered...
  2864                                  
  2865 000008B0 8CC8                    		mov	ax,cs
  2866 000008B2 8ED8                    		mov	ds,ax
  2867 000008B4 8B1E[584C]              		mov	bx,[BATBUFPOS]
  2868 000008B8 83FBFF                  		cmp	bx,-1
  2869 000008BB 751D                    		jnz	short UNBUF
  2870                                  
  2871                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2872                                  
  2873 000008BD BA[5A4C]                		mov	dx,BATBUF
  2874 000008C0 8B0E[633E]              		mov	cx,[BATBUFLEN] ; max to read.
  2875 000008C4 8B1E[D544]              		mov	bx,[BATHAND]
  2876 000008C8 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2877 000008CA CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2878                                  				; BX = file handle,CX = number	of bytes to read
  2879                                  				; DS:DX	-> buffer
  2880                                  		; MSDOS 6.0
  2881                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2882                                  		;invoke	get_ext_error_number	;AN022; get the error
  2883                                  		;push	ds			;AN022; save local segment
  2884                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2885                                  		;assume ds:resgroup		;AN022;
  2886                                  		;mov	dx,ax			;AN022; put error in DX
  2887                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2888                                  		;pop	ds			;AN022;
  2889                                  		;assume	ds:trangroup		;AN022;
  2890                                  		;invoke	std_eprintf		;AN022; print out the error
  2891                                  		;mov	byte ptr combuf+2,end_of_line_in
  2892                                  		;				;AN022; terminate the batch line for parsing
  2893                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2894                                  		;				;AN022; terminate the batch line for output
  2895                                  ;M020;
  2896                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2897                                  ;error is never hit (and it shouldn't be)
  2898                                  ;
  2899                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2900                                  		;
  2901                                  		;jmp	short bateof		;AN022; terminate the batch file
  2902                                  ;bat_read_ok:					;AN022;
  2903                                  
  2904                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2905 000008CC 89C1                    		mov	cx,ax
  2906 000008CE E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2907                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2908 000008D0 890E[7A4C]              		mov	[BATBUFEND],cx
  2909 000008D4 31DB                    		xor	bx,bx
  2910 000008D6 891E[584C]              		mov	[BATBUFPOS],bx
  2911                                  
  2912                                  ; Buffered bytes!
  2913                                  
  2914                                  UNBUF:
  2915 000008DA 8A87[5A4C]              		mov	al,[BATBUF+bx]		; get next byte
  2916 000008DE 43                      		inc	bx
  2917 000008DF 3B1E[7A4C]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2918 000008E3 7203                    		jb	short SETBUFPOS
  2919 000008E5 BBFFFF                  		mov	bx,-1
  2920                                  SETBUFPOS:
  2921 000008E8 891E[584C]              		mov	[BATBUFPOS],bx
  2922 000008EC 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2923 000008EE 7533                    		jnz	short GETBYTEDONE
  2924                                  
  2925                                  ;We get here only when we hit an EOF
  2926                                  		
  2927                                  		; MSDOS 6.0
  2928                                  ;BatEOFDS:
  2929                                  ;SR;
  2930                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2931                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2932                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2933                                  ;batch processing is turned off before the last line is processed and so 
  2934                                  ;this line would never be executed. 
  2935                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2936                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2937                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2938                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2939                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2940                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2941                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2942                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2943                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2944                                  ;another redundant CR-LF. There is no work-around I can think of.
  2945                                  ; 	I would love to restructure this entire routine and its caller to
  2946                                  ;make the flow really easy to understand but I guess this will have to wait.
  2947                                  ;
  2948                                  		;push	es
  2949                                  		;mov	es,ResSeg
  2950                                  ;SR;
  2951                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2952                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2953                                  ;
  2954                                  		;mov	es,es:Batch
  2955                                  		;cmp	es:BatchEOF,0
  2956                                  		;jnz	crpresent
  2957                                  
  2958                                  		;inc	es:BatchEOF		;match the dec following
  2959                                  		;mov	bx,BatBufEnd
  2960                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2961                                  		;je	crpresent		;yes, no need to fake it
  2962                                  
  2963                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2964                                  
  2965                                  ;crpresent:
  2966                                  ;;;		;pop	es
  2967                                  
  2968                                  		;ASSUME	DS:TranGroup
  2969                                  		;MOV	DS,ResSeg
  2970                                  		;ASSUME	DS:ResGroup
  2971                                  
  2972                                  ;SR;
  2973                                  ; The shift operation is done here to replace the decrement. This is because
  2974                                  ;we can jump to this label directly from above when bogus calls are made to
  2975                                  ;this routine even after batch processing is turned off. The shift ensures
  2976                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  2977                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  2978                                  ;calls.
  2979                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  2980                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  2981                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  2982                                  ;turning batch processing off.
  2983                                  
  2984                                  ;At_EOF:						;new label added ;M020
  2985                                  		;shr	es:BatchEOF,1		;decrement the flag
  2986                                  		;jz	turn_off		;zero,turn batch off
  2987                                  		;cmp	es:BatchEOF,1				
  2988                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  2989                                  ;
  2990                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  2991                                  ;
  2992                                  		;mov	al,0dh			;return fake CR.
  2993                                  		;pop	es
  2994                                  		;jmp	short GetByteDone
  2995                                  ;ret_lf:
  2996                                  		;mov	al,0ah			;return fake LF
  2997                                  		;pop	es
  2998                                  		;jmp	short	GetByteDone			
  2999                                  ;turn_off:
  3000                                  		;pop	es
  3001                                  
  3002                                  ;BATEOF:
  3003                                  
  3004                                  		; MSDOS 3.3
  3005                                  TURN_OFF:
  3006 000008F0 8E1E[B141]              		mov	ds,[RESSEG]
  3007                                  
  3008                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3009                                  BATEOF:
  3010 000008F4 E830FF                  		call	BATCHOFF
  3011 000008F7 E89A02                  		call	BATCLOSE
  3012                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3013                                  
  3014                                  ;SR; BugBug
  3015                                  ; There is a good reason why this carriage return is being returned here. 
  3016                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3017                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3018                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3019                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3020                                  ;the batchfile already had a CR-LF. 
  3021                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3022                                  ;the end-of-line. This CR is to mark the end-of-file.
  3023                                  
  3024 000008FA B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3025 000008FC F606E50BFF              		test	byte [BATCH_ABORT],-1
  3026 00000901 C606E50B00              		mov	byte [BATCH_ABORT],0
  3027 00000906 7407                    		jz	short CONT_GET_BYT
  3028 00000908 BF[1240]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3029 0000090B 31C9                    		xor	cx,cx		; zero line length
  3030 0000090D EB14                    		jmp	short GETBYTEDONE
  3031                                  CONT_GET_BYT:
  3032 0000090F 833EF50BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3033 00000914 750D                    		jnz	short GETBYTEDONE
  3034 00000916 833EFE0B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3035 0000091B 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3036 0000091D C706F50BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3037                                  GETBYTEDONE:
  3038 00000923 1F                      		pop	ds
  3039 00000924 59                      		pop	cx
  3040 00000925 5B                      		pop	bx
  3041 00000926 C3                      		retn
  3042                                  
  3043                                  ; ---------------------------------------------------------------------------
  3044                                  
  3045                                  ;break	<$If - conditional execution>
  3046                                  
  3047                                  IFERRORP:
  3048 00000927 58                      		pop	ax
  3049                                  IFERROR:
  3050                                  FORERROR:
  3051 00000928 BA[D83B]                		mov	dx,SYNTMESPTR
  3052 0000092B E9D212                  		jmp	CERROR
  3053                                  
  3054                                  ; ---------------------------------------------------------------------------
  3055                                  
  3056                                  _$IF:
  3057                                  		; MSDOS 6.0
  3058                                  ; Turn off any pipes in progress.
  3059                                  		;push	ds			;AN004; save local DS
  3060                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3061                                  		;assume	ds:resgroup		;AN004;
  3062                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3063                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3064                                  		;invoke	PipeDel 		;AN004; turn off piping
  3065                                  ;IFNoPipe:					;AN004;
  3066                                  		;pop	ds			;AN004; get local DS back
  3067                                  		;assume	ds:trangroup		;AN004;
  3068                                  
  3069                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3070 0000092E C606[C441]00            		mov	byte [IFNOTFLAG],0
  3071 00000933 C706[354B]0000          		mov	word [IF_NOT_COUNT],0
  3072 00000939 BE8100                  		mov	si,81h
  3073                                  IFREENT:
  3074 0000093C E81910                  		call	SCANOFF
  3075 0000093F 3C0D                    		cmp	al,0Dh
  3076 00000941 74E5                    		jz	short IFERROR
  3077 00000943 89F5                    		mov	bp,si
  3078 00000945 BF[273D]                		mov	di,IFTAB	; Prepare to search if table	
  3079 00000948 B500                    		mov	ch,0
  3080                                  IFINDCOM:
  3081 0000094A 89EE                    		mov	si,bp
  3082 0000094C 8A0D                    		mov	cl,[di]
  3083 0000094E 47                      		inc	di
  3084 0000094F E337                    		jcxz	IFSTRING
  3085 00000951 EB02                    		jmp	short FIRSTCOMP
  3086                                  
  3087                                  IFCOMP:
  3088 00000953 7510                    		jnz	short IF_DIF
  3089                                  FIRSTCOMP:
  3090 00000955 AC                      		lodsb
  3091 00000956 268A25                  		mov	ah,[es:di]
  3092 00000959 47                      		inc	di
  3093 0000095A 38E0                    		cmp	al,ah
  3094 0000095C 7405                    		jz	short IFLP
  3095 0000095E 80CC20                  		or	ah,20h		; Try lower case
  3096 00000961 38E0                    		cmp	al,ah
  3097                                  IFLP:
  3098 00000963 E2EE                    		loop	IFCOMP
  3099                                  IF_DIF:
  3100 00000965 9F                      		lahf
  3101 00000966 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3102 00000968 8B1D                    		mov	bx,[di]		; Get handler address
  3103 0000096A 47                      		inc	di
  3104 0000096B 47                      		inc	di
  3105 0000096C 9E                      		sahf
  3106 0000096D 75DB                    		jnz	short IFINDCOM
  3107 0000096F AC                      		lodsb
  3108 00000970 3C0D                    		cmp	al,0Dh
  3109                                  IFERRJ:
  3110 00000972 74B4                    		jz	short IFERROR
  3111 00000974 E8E90F                  		call	DELIM
  3112 00000977 75D1                    		jnz	short IFINDCOM
  3113 00000979 E8DC0F                  		call	SCANOFF
  3114 0000097C FFE3                    		jmp	bx
  3115                                  
  3116                                  IFNOT:
  3117 0000097E F616[C441]              		not	byte [IFNOTFLAG]
  3118 00000982 FF06[354B]              		inc	word [IF_NOT_COUNT]
  3119 00000986 EBB4                    		jmp	short IFREENT
  3120                                  
  3121                                  ; We are comparing two strings for equality. First, find the end of the
  3122                                  ; first string.
  3123                                  
  3124                                  IFSTRING:
  3125 00000988 56                      		push	si		; save away pointer for later compare
  3126 00000989 31C9                    		xor	cx,cx		; count of chars in first string
  3127                                  FIRST_STRING:
  3128 0000098B AC                      		lodsb			; get character
  3129 0000098C 3C0D                    		cmp	al,0Dh		; end of line?
  3130 0000098E 7497                    		jz	short IFERRORP	; yes => error
  3131 00000990 E8CD0F                  		call	DELIM		; is it a delimiter?
  3132 00000993 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3133 00000995 41                      		inc	cx		; remember 1 byte for the length
  3134 00000996 EBF3                    		jmp	short FIRST_STRING ; go back for more
  3135                                  EQUAL_CHECK:
  3136 00000998 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3137 0000099A 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3138 0000099C 3C0D                    		cmp	al,0Dh		; end of line?
  3139 0000099E 7487                    		jz	short IFERRORP	; yes, syntax error
  3140 000009A0 AC                      		lodsb			; get next char
  3141 000009A1 EBF5                    		jmp	short EQUAL_CHECK
  3142                                  
  3143                                  ; The first = has been found. The next char had better be an = too.
  3144                                  
  3145                                  EQUAL_CHECK2:
  3146 000009A3 AC                      		lodsb			; get potential = char
  3147 000009A4 3C3D                    		cmp	al,'='		; is it good?	
  3148 000009A6 7520                    		jnz	short IFERRPJ	; no, error
  3149                                  
  3150                                  ; Find beginning of second string.
  3151                                  
  3152 000009A8 E8AD0F                  		call	SCANOFF
  3153 000009AB 3C0D                    		cmp	al,0Dh
  3154 000009AD 7419                    		jz	short IFERRPJ
  3155 000009AF 5F                      		pop	di
  3156                                  
  3157                                  ; DS:SI points to second string
  3158                                  ; CX has number of chars in first string
  3159                                  ; ES:DI points to first string
  3160                                  
  3161 000009B0 F3A6                    		repe cmpsb
  3162 000009B2 7417                    		jz	short MATCH	; match found!
  3163                                  
  3164                                  ; No match.  Let's find out what was wrong. The character that did not match
  3165                                  ; has been advanced over. Let's back up to it.
  3166                                  
  3167 000009B4 4E                      		dec	si
  3168                                  
  3169                                  ; If it is EOL, then syntax error
  3170                                  
  3171 000009B5 803C0D                  		cmp	byte [si],0Dh
  3172 000009B8 74B8                    		jz	short IFERRJ
  3173                                  
  3174                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3175                                  
  3176                                  SKIPSTRINGEND:
  3177 000009BA AC                      		lodsb
  3178                                  NOTMATCH:
  3179 000009BB 3C0D                    		cmp	al,0Dh
  3180                                  IFERRORJ2:
  3181 000009BD 74B3                    		jz	short IFERRJ
  3182 000009BF E89E0F                  		call	DELIM
  3183 000009C2 75F6                    		jnz	short SKIPSTRINGEND
  3184                                  
  3185                                  ; Signal that we did NOT have a match
  3186                                  
  3187 000009C4 B0FF                    		mov	al,-1
  3188 000009C6 EB3A                    		jmp	short IFRET
  3189                                  IFERRPJ:
  3190 000009C8 E95CFF                  		jmp	IFERRORP
  3191                                  
  3192                                  ; The compare succeeded. Was the second string longer than the first?
  3193                                  ; We do this by seeing if the next char is a delimiter.
  3194                                  
  3195                                  MATCH:
  3196 000009CB AC                      		lodsb
  3197 000009CC E8910F                  		call	DELIM
  3198 000009CF 75EA                    		jnz	short NOTMATCH ; not same.
  3199 000009D1 30C0                    		xor	al,al
  3200 000009D3 EB2D                    		jmp	short IFRET
  3201                                  
  3202                                  ; ---------------------------------------------------------------------------
  3203                                  
  3204                                  IFEXISTS:
  3205                                  
  3206                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3207                                  
  3208                                  ;MOREDELIM:
  3209 000009D5 AC                      		lodsb
  3210 000009D6 E8870F                  		call	DELIM
  3211 000009D9 75FA                    		jnz	short IFEXISTS
  3212                                  		;jnz	short MOREDELIM
  3213                                  
  3214 000009DB BA[AA42]                		mov	dx,DIRBUF
  3215 000009DE B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3216 000009E1 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3217                                  				; DS:DX	-> disk	transfer buffer
  3218 000009E3 BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3219 000009E6 031E[354B]              		add	bx,[IF_NOT_COUNT]
  3220                                  		;mov	ax,ARG_ARGV
  3221                                  		;mov	ax,ARG+ARG_UNIT.argv
  3222 000009EA B8[E944]                		mov	ax,ARG
  3223 000009ED E8861A                  		call	ARGV_CALC	; convert arg index to pointer
  3224 000009F0 8B17                    		mov	dx,[bx]
  3225                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3226                                  		;mov	cx,6
  3227 000009F2 B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3228 000009F5 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3229 000009F8 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3230                                  				; CX = search attributes
  3231                                  				; DS:DX	-> ASCIZ filespec
  3232                                  				; (drive,path, and wildcards allowed)
  3233 000009FA 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3234 000009FC 30C0                    		xor	al,al
  3235 000009FE EB02                    		jmp	short IFRET
  3236                                  
  3237                                  		;nop
  3238                                  IF_EX_C:
  3239 00000A00 B0FF                    		mov	al,-1		; false 'n' fall through...
  3240                                  IFRET:
  3241 00000A02 F606[C441]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3242 00000A07 7402                    		jz	short REALTEST
  3243 00000A09 F6D0                    		not	al
  3244                                  REALTEST:
  3245 00000A0B 08C0                    		or	al,al
  3246 00000A0D 7403                    		jz	short IFTRUE
  3247 00000A0F E9F2F6                  		jmp	TCOMMAND
  3248                                  
  3249                                  IFTRUE:
  3250 00000A12 E8430F                  		call	SCANOFF
  3251 00000A15 89F1                    		mov	cx,si
  3252 00000A17 81E98100                		sub	cx,81h
  3253 00000A1B 280E8000                		sub	[80h],cl
  3254 00000A1F 8A0E8000                		mov	cl,[80h]
  3255 00000A23 880E[1140]              		mov	[COMBUF+1],cl
  3256 00000A27 BF[1240]                		mov	di,COMBUF+2
  3257 00000A2A FC                      		cld
  3258 00000A2B F3A4                    		rep movsb
  3259 00000A2D B00D                    		mov	al,0Dh
  3260 00000A2F AA                      		stosb
  3261                                  
  3262                                  ; Signal that an IF was done. 
  3263                                  ; This prevents the redirections from getting lost.
  3264                                  
  3265 00000A30 1E                      		push	ds
  3266 00000A31 8E1E[B141]              		mov	ds,[RESSEG]
  3267 00000A35 C606FA0BFF              		mov	byte [IFFLAG],-1
  3268 00000A3A 1F                      		pop	ds
  3269                                  
  3270                                  ; Go do the command
  3271                                  
  3272 00000A3B E96FF8                  		jmp	DOCOM1
  3273                                  
  3274                                  ; ---------------------------------------------------------------------------
  3275                                  
  3276                                  IFERRORJ3:
  3277 00000A3E E97CFF                  		jmp	IFERRORJ2
  3278                                  
  3279                                  IFERLEV:
  3280 00000A41 B70A                    		mov	bh,10
  3281 00000A43 30DB                    		xor	bl,bl
  3282                                  GETNUMLP:
  3283 00000A45 AC                      		lodsb
  3284 00000A46 3C0D                    		cmp	al,0Dh
  3285 00000A48 74F4                    		jz	short IFERRORJ3
  3286 00000A4A E8130F                  		call	DELIM
  3287 00000A4D 740C                    		jz	short GOTNUM
  3288 00000A4F 2C30                    		sub	al,'0'
  3289 00000A51 86C3                    		xchg	al,bl
  3290 00000A53 F6E7                    		mul	bh
  3291 00000A55 00D8                    		add	al,bl
  3292 00000A57 86C3                    		xchg	al,bl
  3293 00000A59 EBEA                    		jmp	short GETNUMLP
  3294                                  GOTNUM:
  3295 00000A5B 1E                      		push	ds
  3296 00000A5C 8E1E[B141]              		mov	ds,[RESSEG]
  3297 00000A60 8A26EC0B                		mov	ah,[RETCODE]	; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3298 00000A64 1F                      		pop	ds
  3299 00000A65 30C0                    		xor	al,al
  3300 00000A67 38DC                    		cmp	ah,bl
  3301 00000A69 7397                    		jnb	short IFRET
  3302 00000A6B FEC8                    		dec	al
  3303 00000A6D EB93                    		jmp	short IFRET
  3304                                  
  3305                                  ; ---------------------------------------------------------------------------
  3306                                  
  3307                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3308                                  ; This is a NOP if no batch in progress.
  3309                                  
  3310                                  SHIFT:
  3311 00000A6F 8E1E[B141]              		mov	ds,[RESSEG]
  3312 00000A73 A1990B                  		mov	ax,[BATCH]	; get batch pointer
  3313 00000A76 09C0                    		or	ax,ax		; in batch mode?
  3314 00000A78 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3315                                  SHIFT_RETN:				; no, done.
  3316 00000A7A C3                      		retn
  3317                                  SHIFT1:
  3318 00000A7B 8EC0                    		mov	es,ax
  3319 00000A7D 8ED8                    		mov	ds,ax
  3320                                  
  3321                                  ; Now move the batch args down by 1 word
  3322                                  
  3323                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3324 00000A7F BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3325 00000A82 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3326 00000A85 B90900                  		mov	cx,9		; move 9 parameters
  3327 00000A88 F3A5                    		rep movsw		; SHIFT down
  3328                                  
  3329                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3330                                  ; We have copied it into the previous position.
  3331                                  
  3332 00000A8A 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3333 00000A8D 74EB                    		jz	short SHIFT_RETN ; No new parm
  3334                                  
  3335                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3336                                  ; Assume, first, that there is no next argument.
  3337                                   
  3338 00000A8F 8B35                    		mov	si,[di]
  3339 00000A91 C705FFFF                		mov	word [di],-1	; Assume no parm
  3340                                  
  3341                                  ; The parameters are CR separated. Scan for end of this parm.
  3342                                  
  3343                                  SKIPCRLP:
  3344 00000A95 AC                      		lodsb
  3345 00000A96 3C0D                    		cmp	al,0Dh
  3346 00000A98 75FB                    		jnz	short SKIPCRLP
  3347                                  
  3348                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3349                                  ; are finished. There are no more parms and the pointer has been previously
  3350                                  ; initialized to indicate it.
  3351                                  
  3352 00000A9A 803C00                  		cmp	byte [si],0
  3353 00000A9D 74DB                    		jz	short SHIFT_RETN ; End of parms
  3354 00000A9F 8935                    		mov	[di],si		; Pointer to next parm as %9
  3355 00000AA1 C3                      		retn
  3356                                  
  3357                                  ; =============== S U B	R O U T	I N E =======================================
  3358                                  
  3359                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3360                                  ; returns char in AL, carry set -> eof
  3361                                  
  3362                                  SKIPDELIM:
  3363 00000AA2 F706990BFFFF            		test	word [BATCH],-1	; batch file empty.  OOPS!
  3364 00000AA8 740A                    		jz	short SKIPERR
  3365 00000AAA E8DFFD                  		call	GETBATBYT	; get a char
  3366 00000AAD E8B00E                  		call	DELIM		; check for ignoreable chars
  3367 00000AB0 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3368 00000AB2 F8                      		clc
  3369 00000AB3 C3                      		retn
  3370                                  SKIPERR:
  3371 00000AB4 F9                      		stc
  3372                                  GOTO_RETN:
  3373 00000AB5 C3                      		retn
  3374                                  
  3375                                  ; ---------------------------------------------------------------------------
  3376                                  
  3377                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3378                                  ;  .com file. This routine strips the CALL off the command line, sets
  3379                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3380                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3381                                  ;  being CALLed.
  3382                                  
  3383                                  _$CALL:
  3384                                  
  3385                                  ;  strip off CALL from command line
  3386                                  
  3387                                  		;ASSUME DS:trangroup,ES:trangroup
  3388                                  
  3389 00000AB6 56                      		push	si
  3390 00000AB7 57                      		push	di
  3391 00000AB8 50                      		push	ax
  3392 00000AB9 51                      		push	cx
  3393 00000ABA BE[1240]                		mov	si,COMBUF+2
  3394 00000ABD E8980E                  		call	SCANOFF		;get to first non-delimeter
  3395                                  		;add	si,4
  3396 00000AC0 83C604                  		add	si,length_call	;point to char past CALL
  3397 00000AC3 BF[1240]                		mov	di,COMBUF+2
  3398                                  		;mov	cx,124		
  3399 00000AC6 B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3400 00000AC9 F3A4                    		rep movsb		;move it
  3401 00000ACB 59                      		pop	cx
  3402 00000ACC 58                      		pop	ax
  3403 00000ACD 5F                      		pop	di
  3404 00000ACE 5E                      		pop	si
  3405                                  
  3406                                  ;  set call flag to indicate call in progress
  3407                                  
  3408 00000ACF 1E                      		push	ds
  3409 00000AD0 8E1E[B141]              		mov	ds,[RESSEG]
  3410 00000AD4 C606000C01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3411 00000AD9 C606010C01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3412                                  
  3413                                  ; Turn off any pipes in progress.
  3414                                  
  3415 00000ADE 803E5D0C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3416 00000AE3 7403                    		jz	short _NOPIPE
  3417 00000AE5 E8F313                  		call	PIPEDEL
  3418                                  _NOPIPE:
  3419 00000AE8 1F                      		pop	ds
  3420 00000AE9 C3                      		retn
  3421                                  
  3422                                  ; ---------------------------------------------------------------------------
  3423                                  
  3424                                  GOTO:
  3425 00000AEA 8E1E[B141]              		mov	ds,[RESSEG]
  3426 00000AEE F706990BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3427 00000AF4 74BF                    		jz	short GOTO_RETN
  3428 00000AF6 31D2                    		xor	dx,dx
  3429 00000AF8 1E                      		push	ds
  3430 00000AF9 8E1E990B                		mov	ds,[BATCH]
  3431 00000AFD 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3432 00000B01 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3433                                  
  3434                                  		; MSDOS 6.0
  3435                                  ;M037
  3436                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3437                                  ;
  3438                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3439                                  
  3440                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3441                                  
  3442 00000B05 1F                      		pop	ds
  3443                                  GOTOOPEN:
  3444 00000B06 E8ADF9                  		call	PROMPTBAT
  3445                                  		;mov	di,5Dh
  3446 00000B09 BF5D00                  		mov	di,FCB+1	; Get the label
  3447 00000B0C B90B00                  		mov	cx,11
  3448 00000B0F B020                    		mov	al,' '
  3449 00000B11 F2AE                    		repne scasb
  3450 00000B13 7501                    		jnz	short NOINC
  3451 00000B15 41                      		inc	cx
  3452                                  NOINC:
  3453 00000B16 83E90B                  		sub	cx,11
  3454 00000B19 F7D9                    		neg	cx
  3455 00000B1B 2E890E[AA42]            		mov	[cs:GOTOLEN],cx
  3456                                  
  3457                                  ; At beginning of file. Skip to first non-delimiter char
  3458                                  
  3459 00000B20 E87FFF                  		call	SKIPDELIM
  3460 00000B23 721C                    		jb	short BADGOTO
  3461 00000B25 3C3A                    		cmp	al,':'
  3462 00000B27 7423                    		jz	short CHKLABEL
  3463                                  LABLKLP:				; Look for the label
  3464 00000B29 E860FD                  		call	GETBATBYT
  3465 00000B2C 3C0A                    		cmp	al,0Ah
  3466 00000B2E 7509                    		jnz	short LABLKTST
  3467                                  
  3468                                  ; At beginning of line.  Skip to first non-delimiter char
  3469                                  
  3470 00000B30 E86FFF                  		call	SKIPDELIM
  3471 00000B33 720C                    		jb	short BADGOTO
  3472 00000B35 3C3A                    		cmp	al,':'
  3473 00000B37 7413                    		jz	short CHKLABEL
  3474                                  LABLKTST:
  3475 00000B39 F706990BFFFF            		test	word [BATCH],0FFFFh ; -1
  3476 00000B3F 75E8                    		jnz	short LABLKLP
  3477                                  BADGOTO:
  3478 00000B41 E85000                  		call	BATCLOSE
  3479                                  
  3480                                  		; MSDOS 6.0
  3481                                  ;SR;
  3482                                  ; At this point we are terminating without freeing up any nested batch 
  3483                                  ;segments i.e if the error occurred within a called batch file. This routine
  3484                                  ;will traverse the linked list of batch segments and free all of them.
  3485                                  ;
  3486                                  		;call	free_batch	;free up nested batch segments
  3487                                  
  3488                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3489 00000B44 0E                      		push	cs
  3490 00000B45 1F                      		pop	ds
  3491 00000B46 BA[C73B]                		mov	dx,BADLABPTR
  3492 00000B49 E9B410                  		jmp	CERROR
  3493                                  
  3494                                  ; Found the :.	Skip to first non-delimiter char
  3495                                  
  3496                                  CHKLABEL:
  3497 00000B4C E853FF                  		call	SKIPDELIM
  3498 00000B4F 72F0                    		jb	short BADGOTO
  3499 00000B51 BF5D00                  		mov	di,FCB+1 ; 5Dh
  3500 00000B54 2E8B0E[AA42]            		mov	cx,[cs:GOTOLEN]
  3501 00000B59 EB05                    		jmp	short GOTBYTE
  3502                                  
  3503                                  NEXTCHRLP:
  3504 00000B5B 51                      		push	cx
  3505 00000B5C E82DFD                  		call	GETBATBYT
  3506 00000B5F 59                      		pop	cx
  3507                                  GOTBYTE:
  3508 00000B60 0C20                    		or	al,20h
  3509 00000B62 263A05                  		cmp	al,[es:di]
  3510 00000B65 7502                    		jnz	short TRYUPPER
  3511 00000B67 EB07                    		jmp	short NEXTLABCHR
  3512                                  TRYUPPER:
  3513 00000B69 2C20                    		sub	al,20h
  3514 00000B6B 263A05                  		cmp	al,[es:di]
  3515 00000B6E 75C9                    		jnz	short LABLKTST
  3516                                  NEXTLABCHR:
  3517 00000B70 47                      		inc	di
  3518 00000B71 E2E8                    		loop	NEXTCHRLP
  3519 00000B73 E816FD                  		call	GETBATBYT
  3520 00000B76 2E833E[AA42]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3521 00000B7C 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3522 00000B7E 3C20                    		cmp	al,' '
  3523 00000B80 77B7                    		ja	short LABLKTST
  3524                                  GOTOCONT:
  3525 00000B82 3C0D                    		cmp	al,0Dh
  3526 00000B84 7407                    		jz	short SKIPLFEED
  3527                                  TONEXTBATLIN:
  3528 00000B86 E803FD                  		call	GETBATBYT
  3529 00000B89 3C0D                    		cmp	al,0Dh
  3530 00000B8B 75F9                    		jnz	short TONEXTBATLIN
  3531                                  SKIPLFEED:
  3532 00000B8D E8FCFC                  		call	GETBATBYT
  3533                                  
  3534                                  		; MSDOS 6.0
  3535                                  ;SR;
  3536                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3537                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3538                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3539                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3540                                  ;all other cases, EOF will be hit while trying to read the next line and
  3541                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3542                                  ;
  3543                                  		;push	es
  3544                                  		;mov	es,Batch
  3545                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3546                                  		;pop	es
  3547                                  
  3548                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3549 00000B90 E80100                  		call	BATCLOSE
  3550 00000B93 C3                      		retn
  3551                                  
  3552                                  ; =============== S U B	R O U T	I N E =======================================
  3553                                  
  3554                                  BATCLOSE:
  3555 00000B94 2E8B1E[D544]            		mov	bx,[cs:BATHAND]
  3556 00000B99 83FB05                  		cmp	bx,5
  3557 00000B9C 7204                    		jb	short CLOSERETURN
  3558 00000B9E B43E                    		mov	ah,CLOSE ; 3Eh
  3559 00000BA0 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3560                                  				; BX = file handle
  3561                                  CLOSERETURN:
  3562 00000BA2 C606E40B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3563 00000BA7 C3                      		retn
  3564                                  
  3565                                  ; =============== S U B	R O U T	I N E =======================================
  3566                                  
  3567                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3568                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3569                                  
  3570                                  BATOPEN:
  3571 00000BA8 1E                      		push	ds
  3572 00000BA9 8E1E990B                		mov	ds,[BATCH]
  3573                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3574 00000BAD BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3575 00000BB0 B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3576 00000BB3 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3577                                  				; DS:DX	-> ASCIZ filename
  3578                                  				; AL = access mode
  3579                                  				; 0 - read
  3580 00000BB5 721C                    		jb	short SETERRDL
  3581 00000BB7 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3582 00000BBB 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3583 00000BBF 1F                      		pop	ds
  3584 00000BC0 2EA3[D544]              		mov	[cs:BATHAND],ax
  3585 00000BC4 89C3                    		mov	bx,ax
  3586 00000BC6 B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3587 00000BC9 CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3588                                  				; AL = method: offset from beginning of	file
  3589                                  
  3590 00000BCB 2EC706[584C]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3591                                  BATOPEN_RETN:
  3592 00000BD2 C3                      		retn
  3593                                  
  3594                                  SETERRDL:
  3595 00000BD3 89D3                    		mov	bx,dx
  3596                                  		; MSDOS 6.0
  3597                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3598                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3599                                  
  3600                                  		; MSDOS 3.3
  3601 00000BD5 BA[FE36]                		mov	dx,INSERTDSKPTR
  3602 00000BD8 E8B412                  		call	GET_EXT_ERR_NUMBER
  3603                                  
  3604                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3605 00000BDB 8A07                    		mov	al,[bx]		; Get drive spec
  3606 00000BDD 2C40                    		sub	al,'@'		; A = 1
  3607 00000BDF 1F                      		pop	ds
  3608 00000BE0 F9                      		stc			; SUB mucked over carry
  3609 00000BE1 C3                      		retn
  3610                                  
  3611                                  ;============================================================================
  3612                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3613                                  ;============================================================================
  3614                                  ; 10/10/2018 - Retro DOS v3.0
  3615                                  
  3616                                  ; All batch proccessing has DS set to segment of resident portion
  3617                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3618                                  
  3619                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3620                                  
  3621                                  ; ---------------------------------------------------------------------------
  3622                                  
  3623                                  FORTERM:
  3624                                  		; MSDOS 6.0
  3625                                  		;push	cs		;AN037; Get local segment into
  3626                                  		;pop	ds		;AN037;    DS, ES
  3627                                  		;push	cs		;AN037;
  3628                                  		;pop	es		;AN037;
  3629                                  
  3630                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3631 00000BE2 E8A402                  		call	FOROFF
  3632 00000BE5 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  3633 00000BEA 813EF50B00FF            		cmp	word [SINGLECOM],0FF00h
  3634 00000BF0 750F                    		jne	short BAT_CRLF
  3635 00000BF2 833EFE0B00              		cmp	word [NEST],0	;See if we have nested batch files
  3636 00000BF7 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3637 00000BF9 C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3638 00000BFF EB12                    		jmp	short NOFORP2
  3639                                  BAT_CRLF:
  3640 00000C01 F606EF0B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3641 00000C06 740B                    		jz	short NOFORP2	; no - exit
  3642 00000C08 F706990BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3643 00000C0E 7403                    		jz	short NOFORP2
  3644 00000C10 E8380D                  		call	CRLF2
  3645                                  NOFORP2:
  3646 00000C13 E9EEF4                  		jmp	TCOMMAND
  3647                                  
  3648                                  ; ---------------------------------------------------------------------------
  3649                                  
  3650                                  ;------
  3651                                  ;   For-loop processing.  For loops are of the form:
  3652                                  ;	    for %<loop-variable> in (<list>) do <command>
  3653                                  ; where <command> may contain references of the form %<variable>, which are
  3654                                  ; later substituted with the items in <list>. The for-loop structure is
  3655                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3656                                  ; <command> once for each item in <list>. All of the information needed for
  3657                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3658                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3659                                  ; a complete copy of the original command-line structure as parsed by
  3660                                  ; 'parseline', loop control variables, and a dma buffer for the
  3661                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3662                                  ; processing has completed, this chunk of memory is returned to the system.
  3663                                  ;
  3664                                  ;   All of the previously defined variables, in 'datares', used for loop
  3665                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3666                                  ;
  3667                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3668                                  ; containing all of the other error messages.
  3669                                  ;
  3670                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3671                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3672                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3673                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3674                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3675                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3676                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3677                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3678                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3679                                  ; instead of
  3680                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3681                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3682                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3683                                  ; doesn't matter whether we put brackets around the location or not -- the
  3684                                  ; assembler is "smart" enough to know that we want an address instead of the
  3685                                  ; contents of that location.
  3686                                  ;
  3687                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3688                                  ; One method would be to have a link field in each for-structure pointing to
  3689                                  ; its parent.  Variable references that couldn't be resolved in the local
  3690                                  ; frame would cause a search of prior frames. For-structures would still be
  3691                                  ; allocated and released in exactly the same fashion. The only limit on the
  3692                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3693                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3694                                  ; maintained in the resident data area. This structure would be an array of
  3695                                  ; control-variable names and pointers to for-structure blocks. This would
  3696                                  ; greatly speed up the resolution of non-local variable references. However,
  3697                                  ; since space in the resident is precious, we would have to compromise on a
  3698                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3699                                  ; allocation and de-allocation would have to be modified slightly to take this
  3700                                  ; new structure into account.
  3701                                  ;
  3702                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3703                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3704                                  ; it may be easier to allocate it as part of 'for_segment'.
  3705                                  ;------
  3706                                  
  3707                                  		; include fordata.asm
  3708                                  
  3709                                  ; Data structure definitions included by tfor.asm
  3710                                  
  3711                                  struc FOR_INFO
  3712 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3713 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
  3714 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3715 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
  3716 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
  3717 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
  3718 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
  3719 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
  3720                                    .size:
  3721                                  endstruc
  3722                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3723                                  
  3724                                  _$FOR_EXIT:
  3725 00000C16 EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3726                                  
  3727                                  ; ---------------------------------------------------------------------------
  3728                                  
  3729                                  FORPROC:
  3730 00000C18 A1FC0B                  		mov	ax,[FORPTR]
  3731 00000C1B 8ED8                    		mov	ds,ax
  3732 00000C1D 8EC0                    		mov	es,ax		; operate in for-info area
  3733 00000C1F BACB05                  		mov	dx,FOR_INFO.FORDMA
  3734 00000C22 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3735 00000C25 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3736                                  				; DS:DX	-> disk	transfer buffer
  3737                                  FOR_BEGIN:
  3738 00000C27 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3739 00000C2C 7404                    		jz	short FOR_BEGIN1
  3740                                  					; non-zero for_expand equals FALSE
  3741 00000C2E FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3742                                  
  3743                                  FOR_BEGIN1:
  3744 00000C32 8B1E4705                		mov	bx,[FOR_INFO.FOR_MINARG]
  3745                                  					; current item in <list> to examine
  3746 00000C36 3B1E4905                		cmp	bx,[FOR_INFO.FOR_MAXARG]	; [549h]
  3747 00000C3A 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3748                                  		;mov	ax,0
  3749 00000C3C B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3750 00000C3F E83418                  		call	ARGV_CALC	; compute argv[x] address
  3751                                  		;mov	cx,[bx+3]
  3752 00000C42 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3753 00000C45 8B17                    		mov	dx,[bx]
  3754                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3755                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3756 00000C47 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3757 00000C4B 7514                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3758 00000C4D 8B37                    		mov	si,[bx]
  3759                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3760                                  
  3761                                  		;mov	al,[cs:LPAREN]
  3762                                  		; 01/03/2023
  3763 00000C4F B028                    		mov	al,lparen ; '('
  3764 00000C51 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3765 00000C54 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3766 00000C56 41                      		inc	cx		;  the opening paren as its first char,
  3767                                  					;  the argstartel ptr needs to be
  3768                                  					;  advanced passed it before the prefix
  3769                                  					;  length is computed.
  3770 00000C57 B03A                    		mov	al,':'
  3771 00000C59 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3772 00000C5C 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3773 00000C5E 83C102                  		add	cx,2		;  rest of the prefix as well.
  3774                                  FORSUB:
  3775 00000C61 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3776 00000C63 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3777 00000C68 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3778                                  		;test	byte [bx+2],2
  3779 00000C6A F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3780 00000C6E 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3781                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3782 00000C70 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3783 00000C73 EB1F                    		jmp	short FOR_SMOOSH
  3784                                  
  3785                                  		;nop
  3786                                  FOR_FIND_FIRST:
  3787 00000C75 51                      		push	cx
  3788 00000C76 31C9                    		xor	cx,cx
  3789 00000C78 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3790 00000C7B CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3791                                  				; CX = search attributes
  3792                                  				; DS:DX	-> ASCIZ filespec
  3793                                  				; (drive,path, and wildcards allowed)
  3794 00000C7D 59                      		pop	cx
  3795 00000C7E EB05                    		jmp	short FOR_RESULT
  3796                                  
  3797                                  		;nop
  3798                                  FOR_FIND_NEXT:
  3799 00000C80 B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3800 00000C83 CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3801                                  				; [DTA]	= data block from
  3802                                  				; last AH = 4Eh/4Fh call
  3803                                  FOR_RESULT:
  3804 00000C85 B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3805 00000C88 7203                    		jc	short FOR_CHECK
  3806 00000C8A B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3807                                  FOR_CHECK:				; record success of findfirst/next
  3808 00000C8D A34505                  		mov	[FOR_INFO.FOR_EXPAND],ax
  3809 00000C90 09C0                    		or	ax,ax	; anything out there?
  3810 00000C92 7593                    		jnz	short FOR_BEGIN	; if not, try next arg
  3811                                  FOR_SMOOSH:
  3812                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3813 00000C94 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3814 00000C96 BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3815 00000C99 F3A4                    		rep movsb		; arg, some days just the path prefix
  3816                                  					
  3817 00000C9B 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3818                                  					; if we're not expanding, we can
  3819 00000CA0 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3820                                  
  3821                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3822 00000CA2 BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3823                                  FOR_MORE:
  3824 00000CA5 803C00                  		cmp	byte [si],0	; tack on matching filename
  3825 00000CA8 7403                    		jz	short FOR_MAKE_COM
  3826 00000CAA A4                      		movsb
  3827 00000CAB 75F8                    		jnz	short FOR_MORE
  3828                                  FOR_MAKE_COM:
  3829 00000CAD 30C0                    		xor	al,al		; tack a null byte onto the end
  3830 00000CAF AA                      		stosb			; of the substitute string
  3831 00000CB0 31C9                    		xor	cx,cx		; character count for command line
  3832 00000CB2 F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3833 00000CB4 31DB                    		xor	bx,bx		; argpointer
  3834 00000CB6 BF[1240]                		mov	di,COMBUF+2
  3835 00000CB9 8A1E4405                		mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
  3836 00000CBD 8A364B06                		mov	dh,[FOR_INFO.FOR_VAR] 
  3837                                  					; %<for-var> is replaced by [forbuf]
  3838 00000CC1 0E                      		push	cs		; time to form the <command> string
  3839 00000CC2 07                      		pop	es
  3840                                  		;assume ES:trangroup
  3841                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3842 00000CC3 B80000                  		mov	ax,0		; translate offset to pointer
  3843 00000CC6 E8AD17                  		call	ARGV_CALC
  3844                                  		;mov	si,[bx+9]
  3845 00000CC9 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3846                                  					; mov ptr passed beginning space
  3847 00000CCC 46                      		inc	si
  3848                                  FOR_MAKE_LOOP:
  3849 00000CCD 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3850 00000CCF 46                      		inc	si
  3851 00000CD0 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3852 00000CD2 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3853 00000CD4 3834                    		cmp	[si],dh		; got the right <variable>?
  3854 00000CD6 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3855 00000CD8 46                      		inc	si		; skip over <for-variable>
  3856                                  
  3857 00000CD9 56                      		push	si
  3858 00000CDA BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3859                                  					; to make a final <command> to execute
  3860                                  SLOOP:					
  3861 00000CDD AC                      		lodsb			; grab all those <item> bytes, and
  3862 00000CDE AA                      		stosb			; add 'em to the <command> string,
  3863 00000CDF 08C0                    		or	al,al		; until we run into a null
  3864 00000CE1 E0FA                    		loopne	SLOOP
  3865 00000CE3 4F                      		dec	di		; adjust length and <command> pointer
  3866 00000CE4 41                      		inc	cx		; so we can overwrite the null
  3867 00000CE5 5E                      		pop	si
  3868 00000CE6 EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3869                                  
  3870                                  FOR_STOSB:
  3871 00000CE8 AA                      		stosb			; take a byte from the <command> arg
  3872 00000CE9 49                      		dec	cx		; and put it into the <command> to be
  3873                                  					; executed (and note length, too)
  3874 00000CEA 3C0D                    		cmp	al,0Dh		
  3875 00000CEC 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3876                                  FOR_MADE_COM:
  3877 00000CEE F6D1                    		not	cl
  3878 00000CF0 2E880E[1140]            		mov	[cs:COMBUF+1],cl
  3879                                  
  3880 00000CF5 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  3881                                  		;assume DS:resgroup
  3882 00000CFA F606EF0B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3883 00000CFF 742F                    		jz	short NOECHO3
  3884                                  		;cmp	byte [NULLFLAG],nullcommand
  3885 00000D01 803E040C01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3886 00000D06 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3887                                  
  3888 00000D08 E8400C                  		call	CRLF2		  ;G  Print out prompt
  3889                                  NO_CRLF_PR:
  3890 00000D0B C606040C00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3891 00000D10 0E                      		push	cs
  3892 00000D11 1F                      		pop	ds
  3893 00000D12 57                      		push	di
  3894 00000D13 E86206                  		call	PRINT_PROMPT	  ;G Prompt the user
  3895 00000D16 5F                      		pop	di
  3896                                  
  3897 00000D17 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3898 00000D1C C706[8E43][1240]        		mov	word [STRING_PTR_2],COMBUF+2
  3899 00000D22 BA[9F36]                		mov	dx,STRINGBUF2PTR
  3900 00000D25 E82C27                  		call	STD_PRINTF
  3901 00000D28 26C645FF0D              		mov	byte [es:di-1],0Dh
  3902 00000D2D E97AF5                  		jmp	DOCOM		  ; run silent, run deep...
  3903                                  NOECHO3:
  3904 00000D30 C606040C00              		mov	byte [NULLFLAG],0
  3905 00000D35 0E                      		push	cs
  3906 00000D36 1F                      		pop	ds
  3907 00000D37 E973F5                  		jmp	DOCOM1
  3908                                  
  3909                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3910 00000D3A E84C01                  		call	FOROFF
  3911 00000D3D E92F01                  		jmp	FORNESTERR
  3912                                  
  3913                                  ; ---------------------------------------------------------------------------
  3914                                  
  3915                                  FORERRORJ:
  3916 00000D40 E9E5FB                  		jmp	FORERROR
  3917                                  
  3918                                  ; ---------------------------------------------------------------------------
  3919                                  
  3920                                  _$FOR:
  3921 00000D43 8E06[B141]              		mov	es,[RESSEG]
  3922 00000D47 26803EFB0B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3923 00000D4D 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3924                                  
  3925                                  ; Turn off any pipes in progress.
  3926                                  
  3927 00000D4F 26803E5D0C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3928 00000D55 7403                    		jz	short NO_PIPE
  3929 00000D57 E88111                  		call	PIPEDEL
  3930                                  NO_PIPE:
  3931 00000D5A 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3932 00000D5C E8FA00                  		call	NEXTARG		; move to next argv[n]
  3933 00000D5F 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3934 00000D61 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3935 00000D63 75DB                    		jnz	short FORERRORJ
  3936 00000D65 89C5                    		mov	bp,ax		; save forloop variable
  3937 00000D67 AC                      		lodsb
  3938 00000D68 08C0                    		or	al,al		; and MUST end immediately...
  3939 00000D6A 75D4                    		jnz	short FORERRORJ
  3940 00000D6C E8EA00                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3941 00000D6F 72CF                    		jb	short FORERRORJ
  3942                                  		;and	ax,0DFDFh
  3943 00000D71 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3944                                  		;cmp	ax,[IN_WORD]
  3945                                  		; 01/03/2023
  3946 00000D74 3D494E                  		cmp	ax,in_word ; cmp ax,'IN'
  3947 00000D77 75C7                    		jnz	short FORERRORJ
  3948 00000D79 AC                      		lodsb
  3949                                  
  3950                                  		; MSDOS 3.3
  3951 00000D7A 08C0                    		or	al,al		; it, too, must end right away
  3952 00000D7C 7414                    		jz	short CHECKLPAREN
  3953                                  		;cmp	al,[LPAREN]
  3954                                  		; 01/03/2023
  3955 00000D7E 3C28                    		cmp	al,lparen ; '('
  3956 00000D80 75BE                    		jnz	short FORERRORJ
  3957                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3958 00000D82 830702                  		add	word [bx],2
  3959                                  		;add	word [bx+9],2
  3960 00000D85 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3961                                  		;sub	word [bx+5],2
  3962 00000D89 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3963 00000D8D 8B44FF                  		mov	ax,[si-1]
  3964 00000D90 EB05                    		jmp	short LPCHECK
  3965                                  
  3966                                  		; MSDOS 6.0
  3967                                  ;; Compaq bug fix -- exit from this loop on error
  3968                                  ;
  3969                                  ;		or	al,al
  3970                                  ;		jne	forerrorj	; jump on error
  3971                                  ;
  3972                                  ;;;		je	CheckLParen
  3973                                  ;;
  3974                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  3975                                  ;;   FOR %i in(foo bar...
  3976                                  ;; Check for the Lparen here
  3977                                  ;;
  3978                                  ;;;		CMP	AL,lparen
  3979                                  ;;;		JNZ	forerrorj
  3980                                  ;;
  3981                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  3982                                  ;; being there in the first place.
  3983                                  ;;
  3984                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  3985                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  3986                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  3987                                  ;;
  3988                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  3989                                  ;; current value.
  3990                                  ;;
  3991                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  3992                                  ;;;		jmp	short lpcheck
  3993                                  ;;
  3994                                  ;; end of Compaq bug fix
  3995                                  
  3996                                  ; ---------------------------------------------------------------------------
  3997                                  
  3998                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3999                                  CHECKLPAREN:
  4000 00000D92 E8C400                  		call	NEXTARG		; lparen delimits beginning of <list>
  4001 00000D95 72A9                    		jc	short FORERRORJ
  4002                                  LPCHECK:
  4003                                  		;cmp	al,[LPAREN]
  4004                                  		; 01/03/2023
  4005 00000D97 3C28                    		cmp	al,lparen ; '('
  4006 00000D99 75A5                    		jne	short FORERRORJ
  4007                                  		;cmp	ah,0
  4008                                  		;je	short FOR_PAREN_TOKEN
  4009 00000D9B 08E4                    		or	ah,ah ; 0 ?
  4010 00000D9D 7408                    		jz	short FOR_PAREN_TOKEN
  4011                                  		;cmp	ah,[RPAREN]	; special case:  null list	
  4012 00000D9F 80FC29                  		cmp	ah,rparen ; ')'
  4013 00000DA2 7510                    		jne	short FOR_LIST_NOT_EMPTY
  4014 00000DA4 E93BFE                  		jmp	FORTERM
  4015                                  
  4016                                  		; 01/03/2023
  4017                                  FOR_PAREN_TOKEN:
  4018 00000DA7 E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4019 00000DAA 7294                    		jc	short FORERRORJ
  4020                                  		;
  4021                                  		;;cmp	ax,[RPAREN+1]	
  4022                                  		;cmp	ax,[NULLRPAREN]	; special case: null list
  4023                                  		; 01/03/2023
  4024 00000DAC 83F829                  		cmp	ax,nullrparen ; 0029h  ; db ')',0
  4025 00000DAF 7509                    		jne	short FOR_LIST
  4026 00000DB1 E92EFE                  		jmp	FORTERM
  4027                                  
  4028                                  FOR_LIST_NOT_EMPTY:
  4029                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4030 00000DB4 FF07                    		inc	word [bx]	; Advance ptr past "("
  4031                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4032 00000DB6 FF4F05                  		dec	word [bx+ARGV_ELE.arglen] ; to agree.
  4033 00000DB9 46                      		inc	si		; Inc si so check for ")" works
  4034                                  		; 01/03/2023
  4035                                  		;jmp	short FOR_LIST ;-->
  4036                                  
  4037                                  		;nop
  4038                                  
  4039                                  		; 01/03/2023
  4040                                  ;FOR_PAREN_TOKEN:
  4041                                  		;call	NEXTARG		; what have we in our <list>?
  4042                                  		;jc	short FORERRORJ
  4043                                  		;;;cmp	ax,[RPAREN+1]	
  4044                                  		;;cmp	ax,[NULLRPAREN]	; special case: null list
  4045                                  		;cmp	ax,nullrparen ; 0029h  ; db ')',0
  4046                                  		;jne	short FOR_LIST
  4047                                  		;jmp	FORTERM
  4048                                  		; 01/03/2023
  4049                                  ;FORERORJJ:
  4050                                  		;jmp	FORERROR
  4051                                  ; -->
  4052                                  FOR_LIST:				; skip over rest of <list>
  4053 00000DBA 89D1                    		mov	cx,dx		; first arg of <list>
  4054                                  
  4055                                  SKIP_LIST:
  4056                                  		;add	si,[bx+5]
  4057 00000DBC 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4058 00000DBF 83EE03                  		sub	si,3		; si = ptr to last char of token
  4059                                  		;mov	al,[RPAREN]
  4060                                  		; 01/03/2023
  4061 00000DC2 B029                    		mov	al,rparen ; ')'
  4062 00000DC4 3804                    		cmp	[si],al		; Is this the last element in <list>
  4063 00000DC6 7408                    		je	short FOR_END_LIST ; Yes, exit loop.
  4064 00000DC8 E88E00                  		call	NEXTARG		; No, get next arg <list>
  4065                                  		;jc	short FORERORJJ	; If no more and no rparen, error.
  4066                                  		;jmp	short SKIP_LIST
  4067                                  		; 01/03/2023
  4068 00000DCB 73EF                    		jnc	short SKIP_LIST
  4069                                  FORERORJJ:
  4070 00000DCD E958FB                  		jmp	FORERROR
  4071                                  
  4072                                  FOR_END_LIST:
  4073 00000DD0 89D7                    		mov	di,dx		; record position of last arg in <list>
  4074 00000DD2 C60400                  		mov	byte [si],0	; Zap the rparen
  4075                                  		;;cmp	ax,[RPAREN+1]	
  4076                                  		;cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4077 00000DD5 83F829                  		cmp	ax,nullrparen ; 0029h  ; db ')',0
  4078 00000DD8 7401                    		je	short FOR_DO	; Yes, continue
  4079 00000DDA 47                      		inc	di		; No, inc position of last arg
  4080                                  FOR_DO:
  4081 00000DDB E87B00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4082 00000DDE 72ED                    		jc	short FORERORJJ
  4083                                  		;and	ax,0DFDFh	
  4084 00000DE0 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4085                                  		;cmp	ax,[DO_WORD]
  4086                                  		; 01/03/2023
  4087 00000DE3 3D444F                  		cmp	ax,do_word ; cmp ax,'DO'
  4088 00000DE6 75E5                    		jne	short FORERORJJ
  4089 00000DE8 AC                      		lodsb
  4090 00000DE9 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4091 00000DEB 75E0                    		jnz	short FORERORJJ
  4092                                  		
  4093 00000DED E86900                  		call	NEXTARG		; on to the beginning of <command>
  4094 00000DF0 72DB                    		jc	short FORERORJJ	; null <command> not legal
  4095                                  
  4096 00000DF2 50                      		push	ax
  4097 00000DF3 53                      		push	bx
  4098 00000DF4 51                      		push	cx
  4099 00000DF5 52                      		push	dx		; preserve registers against disaster
  4100 00000DF6 57                      		push	di
  4101 00000DF7 56                      		push	si
  4102 00000DF8 55                      		push	bp
  4103 00000DF9 E863F8                  		call	FREE_TPA	; need to make free memory, first
  4104 00000DFC E88A00                  		call	FOROFF
  4105                                  		;mov	bx,264
  4106 00000DFF BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4107 00000E02 E85719                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4108 00000E05 9C                      		pushf
  4109 00000E06 26A3FC0B                		mov	[es:FORPTR],ax
  4110 00000E0A E862F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4111 00000E0D 9D                      		popf
  4112 00000E0E 5D                      		pop	bp
  4113 00000E0F 5E                      		pop	si
  4114 00000E10 5F                      		pop	di
  4115 00000E11 5A                      		pop	dx
  4116 00000E12 59                      		pop	cx
  4117 00000E13 5B                      		pop	bx
  4118 00000E14 58                      		pop	ax
  4119 00000E15 723C                    		jc	short FOR_ALLOC_ERR
  4120                                  
  4121 00000E17 06                      		push	es		; save resgroup seg...
  4122 00000E18 26FF36FC0B              		push	word [es:FORPTR]
  4123 00000E1D 07                      		pop	es
  4124                                  		;assume ES:for_segment	
  4125 00000E1E 49                      		dec	cx		; forproc wants min pointing before
  4126 00000E1F 4F                      		dec	di		; first arg, max right at last one
  4127 00000E20 26890E4705              		mov	[es:FOR_INFO.FOR_MINARG],cx
  4128 00000E25 26893E4905              		mov	[es:FOR_INFO.FOR_MAXARG],di
  4129 00000E2A 2688164405              		mov	[es:FOR_INFO.FOR_COM_START],dl
  4130 00000E2F 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4131 00000E36 89E8                    		mov	ax,bp
  4132 00000E38 2688264B06              		mov	[es:FOR_INFO.FOR_VAR],ah
  4133 00000E3D 07                      		pop	es
  4134                                  		;assume ES:resgroup	
  4135 00000E3E 26FE06FB0B              		inc	byte [es:FORFLAG]
  4136 00000E43 26833EF50BFF            		cmp	word [es:SINGLECOM],-1
  4137 00000E49 7507                    		jne	short FOR_RET
  4138 00000E4B 26C706F50B00FF          		mov	word [es:SINGLECOM],0FF00h
  4139                                  FOR_RET:
  4140 00000E52 C3                      		retn
  4141                                  
  4142                                  FOR_ALLOC_ERR:
  4143                                  		; MSDOS 3.3
  4144 00000E53 BA[0A3C]                		mov	dx,INSFMEMMESPTR
  4145 00000E56 E9A70D                  		jmp	CERROR
  4146                                  
  4147                                  		; MSDOS 6.0
  4148                                  		;mov	msg_disp_class,ext_msg_class	
  4149                                  		;			;AN000; set up extended error msg class
  4150                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4151                                  		;			;AC000; get extended message pointer
  4152                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4153                                  		;			;AN000; get message number in control block
  4154                                  		;jmp	cerror
  4155                                  
  4156                                  
  4157                                  ; =============== S U B	R O U T	I N E =======================================
  4158                                  
  4159                                  NEXTARG:
  4160 00000E59 42                      		inc	dx		; next argv[n]
  4161                                  		;cmp	dx,[ARG_ARGVCNT]
  4162 00000E5A 3B16[A947]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4163 00000E5E 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4164 00000E60 89D3                    		mov	bx,dx
  4165                                  		;mov	ax,ARG_ARGV
  4166                                  		;mov	ax,ARG+ARG_UNIT.argv
  4167 00000E62 B8[E944]                		mov	ax,ARG
  4168 00000E65 E80E16                  		call	ARGV_CALC	; convert array index to pointer
  4169 00000E68 8B37                    		mov	si,[bx]		; load pointer to argstring
  4170                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4171 00000E6A AD                      		lodsw			; and load first two chars
  4172 00000E6B F8                      		clc
  4173 00000E6C C3                      		retn
  4174                                  NEXTARG_ERR:
  4175 00000E6D F9                      		stc
  4176 00000E6E C3                      		retn
  4177                                  
  4178                                  ; ---------------------------------------------------------------------------
  4179                                  
  4180                                  FORNESTERR:
  4181 00000E6F 1E                      		push	ds
  4182 00000E70 8E1E[B141]              		mov	ds,[RESSEG]
  4183                                  		;ASSUME DS:RESGROUP
  4184 00000E74 BA[F23B]                		mov	dx,FORNESTMESTR
  4185 00000E77 813EF50B00FF            		cmp	word [SINGLECOM],0FF00h
  4186 00000E7D 7506                    		jnz	short NOFORP3
  4187 00000E7F C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4188                                  NOFORP3:
  4189 00000E85 1F                      		pop	ds
  4190 00000E86 E9770D                  		jmp	CERROR
  4191                                  
  4192                                  ; =============== S U B	R O U T	I N E =======================================
  4193                                  
  4194                                  ; General routine called to free the for segment. We also clear the forflag
  4195                                  ; too. Change no registers.
  4196                                  
  4197                                  FOROFF:
  4198 00000E89 50                      		push	ax
  4199 00000E8A 06                      		push	es
  4200 00000E8B 2E8E06[B141]            		mov	es,[cs:RESSEG]
  4201 00000E90 26A1FC0B                		mov	ax,[es:FORPTR]
  4202 00000E94 09C0                    		or	ax,ax
  4203 00000E96 7408                    		jz	short FREEDONE
  4204 00000E98 06                      		push	es
  4205 00000E99 8EC0                    		mov	es,ax
  4206 00000E9B B449                    		mov	ah,DEALLOC ; 49h
  4207 00000E9D CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4208                                  				; ES = segment address of area to be freed
  4209 00000E9F 07                      		pop	es
  4210                                  FREEDONE:
  4211 00000EA0 26C706FC0B0000          		mov	word [es:FORPTR],0
  4212 00000EA7 26C606FB0B00            		mov	byte [es:FORFLAG],0
  4213 00000EAD 07                      		pop	es
  4214 00000EAE 58                      		pop	ax
  4215 00000EAF C3                      		retn
  4216                                  
  4217                                  ;============================================================================
  4218                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4219                                  ;============================================================================
  4220                                  ; 09/10/2018 - Retro DOS v3.0
  4221                                  
  4222                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4223                                  
  4224                                  ; ---------------------------------------------------------------------------
  4225                                  
  4226                                  ; The DIR command displays the contents of a directory.
  4227                                  ;
  4228                                  ; ****************************************************************
  4229                                  ; *
  4230                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4231                                  ; *
  4232                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4233                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4234                                  ; *		 If an error occurs issue and error message and
  4235                                  ; *		 transfer control to CERROR.
  4236                                  ; *
  4237                                  ; * INPUT:	 command line at offset 81H
  4238                                  ; *
  4239                                  ; * OUTPUT:	 none
  4240                                  ; *
  4241                                  ; ****************************************************************
  4242                                  
  4243                                  CATALOG:
  4244                                  		; MSDOS 3.3
  4245                                  
  4246                                  		;mov	ax,ARG_ARGV
  4247                                  		;mov	ax,ARG+ARG_UNIT.argv
  4248 00000EB0 B8[E944]                		mov	ax,ARG
  4249 00000EB3 BAFFFF                  		mov	dx,0FFFFh
  4250 00000EB6 31C9                    		xor	cx,cx
  4251 00000EB8 31F6                    		xor	si,si
  4252                                  
  4253                                  DIR1:
  4254                                  		;cmp	cx,[ARG_ARGVCNT]
  4255 00000EBA 3B0E[A947]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4256 00000EBE 733F                    		jnb	short DIR6 ; No more arguments
  4257 00000EC0 89CB                    		mov	bx,cx
  4258 00000EC2 E8B115                  		call	ARGV_CALC
  4259                                  		;or	si,[bx+7]
  4260 00000EC5 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4261 00000EC8 F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4262 00000ECC 7508                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4263                                  		;test	byte [bx+2],1
  4264 00000ECE F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4265 00000ED2 7408                    		jz	short DIR3
  4266 00000ED4 EB26                    		jmp	short DIR5
  4267                                  DIR2:
  4268 00000ED6 BA[8239]                		mov	dx,BADPARMPTR
  4269 00000ED9 E9240D                  		jmp	CERROR
  4270                                  DIR3:
  4271 00000EDC 09C9                    		or	cx,cx
  4272 00000EDE 7515                    		jnz	short DIR4	
  4273                                  		;cmp	word [bx+5],3
  4274 00000EE0 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4275 00000EE4 7416                    		jz	short DIR5
  4276                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4277 00000EE6 830703                  		add	word [bx],3
  4278                                  		;add	word [bx+9],3
  4279 00000EE9 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4280                                  		;add	word [bx+3],3
  4281 00000EED 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4282                                  		;sub	word [bx+5],3
  4283 00000EF1 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4284                                  DIR4:
  4285 00000EF5 83FAFF                  		cmp	dx,0FFFFh
  4286 00000EF8 75DC                    		jnz	short DIR2
  4287 00000EFA 89DA                    		mov	dx,bx
  4288                                  
  4289 00000EFC 41                      DIR5:		inc	cx
  4290 00000EFD EBBB                    		jmp	short DIR1
  4291                                  DIR6:
  4292 00000EFF 8936[C841]              		mov	[COMSW],si
  4293 00000F03 52                      		push	dx
  4294 00000F04 30C0                    		xor	al,al
  4295 00000F06 83FAFF                  		cmp	dx,0FFFFh
  4296 00000F09 7410                    		jz	short DIR7
  4297 00000F0B 89D3                    		mov	bx,dx
  4298                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4299 00000F0D 8B3F                    		mov	di,[bx]
  4300 00000F0F 807D013A                		cmp	byte [di+1],':'
  4301 00000F13 7506                    		jnz	short DIR7
  4302 00000F15 8A05                    		mov	al,[di]
  4303 00000F17 0C20                    		or	al,20h		; Lowercase drive name	
  4304 00000F19 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4305                                  DIR7:
  4306                                  		;mov	[5CH],al
  4307 00000F1B A25C00                  		mov	[FCB],al
  4308 00000F1E E80A04                  		call	OKVOLARG
  4309 00000F21 B03F                    		mov	al,'?'		; *.* is default file spec.
  4310                                  		;mov	di,5Dh
  4311 00000F23 BF5D00                  		mov	di,FCB+1
  4312 00000F26 B90B00                  		mov	cx,11
  4313 00000F29 F3AA                    		rep stosb
  4314                                  
  4315                                  ; Begin by processing any switches that may have been specified.
  4316                                  ; BITS will contain any information about switches that was
  4317                                  ; found when the command line was parsed.
  4318                                  
  4319 00000F2B A1[C841]                		mov	ax,[COMSW]	; Get switches from command
  4320 00000F2E A3[FC42]                		mov	[_BITS],ax	; initialize switches
  4321 00000F31 C706[C841]0000          		mov	word [COMSW],0	; initialize flags
  4322 00000F37 C606[0443]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4323                                  		;test	al,1
  4324 00000F3C A801                    		test	al,SWITCHW	; /W ?
  4325                                  		;mov	al,1
  4326 00000F3E B001                    		mov	al,NORMPERLIN
  4327 00000F40 7402                    		jz	short DIR8
  4328                                  		;mov	al,5
  4329 00000F42 B005                    		mov	al,WIDEPERLIN
  4330                                  DIR8:
  4331 00000F44 A2[D841]                		mov	[LINLEN],al	; Set number of entries per line
  4332 00000F47 A2[D741]                		mov	[LINCNT],al
  4333 00000F4A C706[D941]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4334 00000F50 BA[AA42]                		mov	dx,DIRBUF
  4335 00000F53 B41A                    		mov	ah,SET_DMA ; 1Ah
  4336 00000F55 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4337                                  				; DS:DX	-> disk	transfer buffer
  4338                                  		;mov	dl,[5Ch]
  4339 00000F57 8A165C00                		mov	dl,[FCB]
  4340 00000F5B E8C709                  		call	SAVUDIR
  4341 00000F5E 5B                      		pop	bx
  4342 00000F5F 83FBFF                  		cmp	bx,0FFFFh
  4343 00000F62 7415                    		jz	short DIR9
  4344                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4345 00000F64 8B17                    		mov	dx,[bx]
  4346                                  
  4347                                  ; The user may have specified a device. Search for the path and see if the
  4348                                  ; attributes indicate a device.
  4349                                  
  4350 00000F66 B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4351 00000F68 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4352                                  				; CX = search attributes
  4353                                  				; DS:DX	-> ASCIZ filespec
  4354                                  				; (drive,path, and wildcards allowed)
  4355 00000F6A 720F                    		jc	short DIR10
  4356                                  				; Check device atrribute..
  4357                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4358                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4359                                  		; 14/10/2018
  4360                                  		;test	byte [DIRBUF+21],40h
  4361 00000F6C F606[BF42]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4362 00000F71 7408                    		jz	short DIR10	; no, go do normal operation
  4363 00000F73 C706[C841]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4364                                  DIR9:
  4365 00000F79 EB7B                    		jmp	short DOHEADER
  4366                                  DIR10:
  4367                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4368 00000F7B 8B17                    		mov	dx,[bx]
  4369 00000F7D B43B                    		mov	ah,CHDIR ; 3Bh
  4370 00000F7F CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4371                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4372 00000F81 7373                    		jnc	short DOHEADER
  4373                                  		;mov	si,[bx+3]
  4374 00000F83 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4375 00000F86 39F2                    		cmp	dx,si
  4376 00000F88 7449                    		jz	short DIR_NO_DRIVE
  4377 00000F8A 30C9                    		xor	cl,cl
  4378 00000F8C 860C                    		xchg	cl,[si]
  4379 00000F8E B43B                    		mov	ah,CHDIR ; 3Bh
  4380 00000F90 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4381                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4382 00000F92 860C                    		xchg	cl,[si]
  4383 00000F94 733D                    		jnc	short DIR_NO_DRIVE
  4384 00000F96 8A44FF                  		mov	al,[si-1]
  4385 00000F99 E84E0A                  		call	PATHCHRCMP
  4386 00000F9C 7514                    		jnz	short DIR11
  4387 00000F9E 8A44FE                  		mov	al,[si-2]
  4388 00000FA1 E8460A                  		call	PATHCHRCMP
  4389 00000FA4 741E                    		jz	short DIR12
  4390 00000FA6 864CFF                  		xchg	cl,[si-1]
  4391 00000FA9 B43B                    		mov	ah,CHDIR ; 3Bh
  4392 00000FAB CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4393                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4394 00000FAD 864CFF                  		xchg	cl,[si-1]
  4395 00000FB0 7321                    		jnc	short DIR_NO_DRIVE
  4396                                  DIR11:
  4397 00000FB2 B53A                    		mov	ch,':'
  4398 00000FB4 3A6CFF                  		cmp	ch,[si-1]
  4399 00000FB7 750B                    		jnz	short DIR12
  4400                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4401 00000FB9 8B0F                    		mov	cx,[bx]
  4402 00000FBB 87CE                    		xchg	cx,si
  4403 00000FBD 29F1                    		sub	cx,si
  4404 00000FBF 83F902                  		cmp	cx,2
  4405 00000FC2 740F                    		jz	short DIR_NO_DRIVE
  4406                                  DIR12:
  4407 00000FC4 BA[D63A]                		mov	dx,BADCDPTR
  4408                                  		;test	byte [bx+2],4
  4409 00000FC7 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4410 00000FCB 7503                    		jnz	short DIRERROR
  4411                                  DIRNF:
  4412 00000FCD BA[5837]                		mov	dx,FNOTFOUNDPTR
  4413                                  DIRERROR:
  4414 00000FD0 E92D0C                  		jmp	CERROR
  4415                                  DIR_NO_DRIVE:
  4416 00000FD3 813C2E2E                		cmp	word [si],'..'
  4417 00000FD7 750C                    		jnz	short DOREALPARSE
  4418 00000FD9 807C0200                		cmp	byte [si+2],0
  4419 00000FDD 7506                    		jnz	short DOREALPARSE
  4420 00000FDF FF06[C841]              		inc	word [COMSW]
  4421 00000FE3 EB11                    		jmp	short DOHEADER
  4422                                  DOREALPARSE:
  4423 00000FE5 BF5C00                  		mov	di,FCB ; 5Ch	
  4424                                  		;mov	ax,290Eh
  4425 00000FE8 B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4426 00000FEB CD21                    		int	21h	; DOS -	PARSE FILENAME
  4427                                  				; DS:SI	-> string to parse
  4428                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4429                                  				; AL = bit mask	to control parsing
  4430 00000FED 803C00                  		cmp	byte [si],0
  4431 00000FF0 7404                    		jz	short DOHEADER
  4432 00000FF2 FF0E[C841]              		dec	word [COMSW]
  4433                                  DOHEADER:
  4434                                  
  4435                                  ; Display the header
  4436                                  
  4437 00000FF6 53                      		push	bx
  4438 00000FF7 E83D04                  		call	BUILD_DIR_STRING
  4439 00000FFA BA[AA42]                		mov	dx,DIRBUF
  4440 00000FFD 8916[A543]              		mov	[VOL_DIR],dx
  4441 00001001 BA[5F3B]                		mov	dx,DIRHEADPTR
  4442 00001004 E83D24                  		call	PRINTF_CRLF
  4443 00001007 5B                      		pop	bx
  4444 00001008 83FBFF                  		cmp	bx,0FFFFh
  4445 0000100B 7417                    		jz	short DOSEARCH
  4446                                  
  4447                                  ; If there were chars left after parse or device, then invalid file name
  4448                                  
  4449 0000100D 833E[C841]00            		cmp	word [COMSW],0
  4450 00001012 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4451 00001014 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4452 00001016 E86108                  		call	RESTUDIR
  4453 00001019 BA[D63A]                		mov	dx,BADCDPTR
  4454 0000101C E9E10B                  		jmp	CERROR		; was .. => error directory not found
  4455                                  DIRNFFIX:
  4456 0000101F E85808                  		call	RESTUDIR
  4457 00001022 EBA9                    		jmp	short DIRNF
  4458                                  
  4459                                  ; We are assured that everything is correct. Let's go and search. Use
  4460                                  ; attributes that will include finding directories. Perform the first search
  4461                                  ; and reset our directory afterward.
  4462                                  
  4463                                  DOSEARCH:
  4464                                  		;mov	byte [55h],0FFh
  4465 00001024 C6065500FF              		mov	byte [FCB-7],0FFh
  4466                                  		;mov	byte [5Bh],10h
  4467 00001029 C6065B0010              		mov	byte [FCB-1],10h
  4468                                  
  4469                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4470                                  ; the directory information as an extended FCB. We must bias all fetches into
  4471                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4472                                  
  4473 0000102E B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4474 00001030 BA5500                  		mov	dx,FCB-7 ; 55h
  4475 00001033 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4476                                  				; DS:DX	-> FCB
  4477                                  
  4478                                  ; Restore the user's directory. We preserve, though, the return from the
  4479                                  ; previous system call for later checking.
  4480                                  
  4481                                  FOUND_FIRST_FILE:
  4482 00001035 50                      		push	ax		; save return state
  4483 00001036 E84108                  		call	RESTUDIR	; restore user's dir	
  4484 00001039 58                      		pop	ax		; get return state back
  4485                                  
  4486                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4487                                  ; no more.
  4488                                  
  4489                                  DIRSTART:
  4490 0000103A FEC0                    		inc	al		; 0FFh = file not found
  4491 0000103C 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4492 0000103E E9D200                  		jmp	CHKCNT
  4493                                  DISPLAY:
  4494 00001041 FF06[D941]              		inc	word [FILECNT]	; Keep track of how many we find
  4495 00001045 BE[B242]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4496                                  		;call	SHONAME
  4497 00001048 E80C01                  		call	DISPLAYNAME
  4498                                  		;test	byte [_BITS],1
  4499 0000104B F606[FC42]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4500 00001050 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4501 00001052 E98800                  		jmp	NEXENT
  4502                                  DIRTEST:
  4503                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4504                                  		; 14/10/2018
  4505                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4506                                  		;test	byte [DIRBUF+19],10h
  4507 00001055 F606[BD42]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4508 0000105A 7408                    		jz	short FILEENT
  4509 0000105C BA[583A]                		mov	dx,DMESPTR
  4510 0000105F E8F223                  		call	STD_PRINTF
  4511 00001062 EB16                    		jmp	short NOFSIZ
  4512                                  FILEENT:
  4513                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4514                                  		;mov	dx,[DIRBUF+36]
  4515 00001064 8B16[CE42]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4516 00001068 8916[8A43]              		mov	[FILESIZE_L],dx
  4517                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4518                                  		;mov	dx,[DIRBUF+38]
  4519 0000106C 8B16[D042]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4520 00001070 8916[8C43]              		mov	[FILESIZE_H],dx
  4521 00001074 BA[9636]                		mov	dx,FSIZEMESPTR
  4522 00001077 E8DA23                  		call	STD_PRINTF	; Print size of file
  4523                                  NOFSIZ:
  4524                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4525                                  		;mov	ax,[DIRBUF+32]
  4526 0000107A A1[CA42]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4527 0000107D 09C0                    		or	ax,ax
  4528 0000107F 745C                    		jz	short NEXENT	; Skip if no date
  4529 00001081 BF[DB41]                		mov	di,CHARBUF
  4530 00001084 50                      		push	ax
  4531 00001085 B82020                  		mov	ax,'  '
  4532 00001088 AB                      		stosw
  4533 00001089 58                      		pop	ax
  4534 0000108A 89C3                    		mov	bx,ax
  4535 0000108C 83E01F                  		and	ax,1Fh		; Get day
  4536 0000108F 88C2                    		mov	dl,al
  4537 00001091 89D8                    		mov	ax,bx
  4538 00001093 B105                    		mov	cl,5
  4539 00001095 D3E8                    		shr	ax,cl		; Align month
  4540 00001097 240F                    		and	al,0Fh		; Get month
  4541 00001099 88C6                    		mov	dh,al
  4542 0000109B 88F9                    		mov	cl,bh
  4543 0000109D D0E9                    		shr	cl,1		; Align year
  4544 0000109F 30ED                    		xor	ch,ch
  4545 000010A1 83C150                  		add	cx,80		; Relative 1980
  4546 000010A4 80F964                  		cmp	cl,100
  4547 000010A7 7203                    		jb	short MILLENIUM
  4548 000010A9 80E964                  		sub	cl,100
  4549                                  MILLENIUM:
  4550 000010AC E8960F                  		call	DATE_CXDX
  4551                                  		;mov	cx,[DIRBUF_FTIME]
  4552                                  		;mov	cx,[DIRBUF+30]
  4553 000010AF 8B0E[C842]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4554 000010B3 E318                    		jcxz	PRBUF		; Time field present?
  4555 000010B5 B82020                  		mov	ax,2020h
  4556 000010B8 AB                      		stosw
  4557 000010B9 D1E9                    		shr	cx,1
  4558 000010BB D1E9                    		shr	cx,1
  4559 000010BD D1E9                    		shr	cx,1
  4560 000010BF D0E9                    		shr	cl,1
  4561 000010C1 D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4562 000010C3 8A1E[494C]              		mov	bl,[TIME_24]
  4563 000010C7 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4564 000010CA E82711                  		call	P_TIME		; Don't care about DX, never used with DIR
  4565                                  PRBUF:
  4566 000010CD 31C0                    		xor	ax,ax
  4567 000010CF AA                      		stosb
  4568 000010D0 BA[DB41]                		mov	dx,CHARBUF
  4569 000010D3 8916[8E43]              		mov	[STRING_PTR_2],dx
  4570 000010D7 BA[9F36]                		mov	dx,STRINGBUF2PTR
  4571 000010DA E87723                  		call	STD_PRINTF
  4572                                  NEXENT:
  4573 000010DD FE0E[D741]              		dec	byte [LINCNT]
  4574 000010E1 7520                    		jnz	short SAMLIN
  4575                                  NEXLIN:
  4576 000010E3 A0[D841]                		mov	al,[LINLEN]
  4577 000010E6 A2[D741]                		mov	[LINCNT],al
  4578 000010E9 E85F08                  		call	CRLF2
  4579 000010EC FE0E[0443]              		dec	byte [LINPERPAG]
  4580 000010F0 7517                    		jnz	short SCROLL
  4581                                  		;test	byte [_BITS],2
  4582 000010F2 F606[FC42]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4583 000010F7 7410                    		jz	short SCROLL	; If not, just continue
  4584 000010F9 C606[0443]17            		mov	byte [LINPERPAG],23
  4585 000010FE E87900                  		call	PAUSE
  4586 00001101 EB06                    		jmp	short SCROLL
  4587                                  SAMLIN:
  4588 00001103 BA[A536]                		mov	dx,TABPTR	; Output a tab
  4589 00001106 E84B23                  		call	STD_PRINTF
  4590                                  SCROLL:
  4591 00001109 B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4592                                  		;mov	dx,55h
  4593 0000110B BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4594 0000110E CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4595                                  				; DS:DX	-> FCB
  4596                                  				; Return: AL = status
  4597 00001110 E927FF                  		jmp	DIRSTART
  4598                                  CHKCNT:
  4599 00001113 F706[D941]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4600 00001119 7503                    		jnz	short TRAILER
  4601 0000111B E9AFFE                  		jmp	DIRNF
  4602                                  TRAILER:
  4603 0000111E A0[D841]                		mov	al,[LINLEN]
  4604 00001121 3A06[D741]              		cmp	al,[LINCNT]
  4605 00001125 7403                    		jz	short MMESSAGE
  4606 00001127 E82108                  		call	CRLF2
  4607                                  MMESSAGE:
  4608 0000112A BA[6F38]                		mov	dx,DIRMESPTR
  4609 0000112D 8B36[D941]              		mov	si,[FILECNT]
  4610 00001131 8936[9743]              		mov	[DIR_NUM],si
  4611 00001135 E81C23                  		call	STD_PRINTF
  4612                                  DTFREE:
  4613 00001138 B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4614                                  		;mov	dl,[5Ch]
  4615 0000113A 8A165C00                		mov	dl,[FCB]
  4616 0000113E CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4617                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4618 00001140 83F8FF                  		cmp	ax,-1
  4619 00001143 7501                    		jnz	short DTFREE1
  4620                                  DTRET:
  4621 00001145 C3                      		retn
  4622                                  DTFREE1:
  4623 00001146 F7E1                    		mul	cx
  4624 00001148 F7E3                    		mul	bx
  4625 0000114A A3[9943]                		mov	[BYTES_FREE],ax
  4626 0000114D 8916[9B43]              		mov	[BYTES_FREE+2],dx
  4627 00001151 BA[8538]                		mov	dx,BYTEMESPTR
  4628 00001154 E9FD22                  		jmp	STD_PRINTF
  4629                                  
  4630                                  
  4631                                  	; MSDOS 6.0
  4632                                  ;CATALOG:
  4633                                  
  4634                                  ;;
  4635                                  ;; Set up DTA for dir search firsts
  4636                                  ;;
  4637                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4638                                  ;	mov	ah,Set_DMA			;AC000;
  4639                                  ;	int	int_command			;AC000;
  4640                                  ;;
  4641                                  ;; Set up defaults for switches and parse the command line.
  4642                                  ;;
  4643                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4644                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4645                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4646                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4647                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4648                                  ;	stosb					;AN000;
  4649                                  ;	mov	al,end_of_line_in		;AN000;
  4650                                  ;	stosb					;AN000;
  4651                                  ;	mov	si,81H				;AN000; Get command line
  4652                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get address of PARSE_DIR
  4653                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4654                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4655                                  ;	mov	bits,cx 			;AC000; initialize switches
  4656                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4657                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4658                                  ;	mov	lincnt,normperlin		;AC000;
  4659                                  ;
  4660                                  ;dirscan:
  4661                                  ;	xor	dx,dx				;AN000;
  4662                                  ;	invoke	parse_with_msg			;AC018; call parser
  4663                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4664                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4665                                  ;	jmp	scandone			;AN000; yes - go process
  4666                                  ;
  4667                                  ;dirscan_cont:
  4668                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4669                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4670                                  ;	jmp	badparm 			;AN000; yes - exit
  4671                                  ;
  4672                                  ;dirscan_cont2:
  4673                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4674                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4675                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4676                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4677                                  ;;
  4678                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4679                                  ;;
  4680                                  ;	push	si				;AC000; save position in line
  4681                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4682                                  ;	push	si				;AN000; save address
  4683                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4684                                  ;	pop	dx				;AC000; get address in DX
  4685                                  ;
  4686                                  ;;
  4687                                  ;; The user may have specified a device. Search for the path and see if the
  4688                                  ;; attributes indicate a device.
  4689                                  ;;
  4690                                  ;	mov	ah,Find_First			;AC000; find the file
  4691                                  ;	int	int_command			;AC000;
  4692                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4693                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4694                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4695                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4696                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4697                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4698                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4699                                  ;
  4700                                  ;dir_check_device:				;AN022;
  4701                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4702                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4703                                  ;	mov	ComSw,-2			;AC000; signal device
  4704                                  ;
  4705                                  ;dir_fspec_end:
  4706                                  ;	pop	si				;AC000; restore position in line
  4707                                  ;	jmp	short dirscan			;AC000; keep parsing
  4708                                  ;
  4709                                  ;set_dir_width:
  4710                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4711                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4712                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4713                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4714                                  ;	jmp	badparm 			;AN018; exit
  4715                                  ;
  4716                                  ;ok_set_width:
  4717                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4718                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4719                                  ;	mov	lincnt,wideperlin		;AC000;
  4720                                  ;	jmp	short dirscan			;AC000; keep parsing
  4721                                  ;
  4722                                  ;set_dir_pause:
  4723                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4724                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4725                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4726                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4727                                  ;	jmp	badparm 			;AN018; exit
  4728                                  ;
  4729                                  ;ok_set_pause:
  4730                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4731                                  ;	push	cx				;AN000; save necessary registers
  4732                                  ;	push	si				;AN000;
  4733                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4734                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4735                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4736                                  ;	mov	cl,get_generic			;AN000; get information
  4737                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4738                                  ;	int	int_command			;AN000;
  4739                                  ;
  4740                                  ;lines_set:
  4741                                  ;	dec	linperpag			;AN000; lines per actual page should
  4742                                  ;	dec	linperpag			;AN000;     two less than the max
  4743                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4744                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4745                                  ;	pop	si				;AN000; restore registers
  4746                                  ;	pop	cx				;AN000;
  4747                                  ;	jmp	dirscan 			;AC000; keep parsing
  4748                                  ;
  4749                                  ;;
  4750                                  ;; The syntax is incorrect. Report only message we can.
  4751                                  ;;
  4752                                  ;BadParm:
  4753                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4754                                  ;
  4755                                  ;ScanDone:
  4756                                  ;
  4757                                  ;;
  4758                                  ;; Find and display the volume ID on the drive.
  4759                                  ;;
  4760                                  ;
  4761                                  ;	invoke	okvolarg			;AC000;
  4762                                  ;;
  4763                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4764                                  ;; in the HeadFix routine, after we're done.
  4765                                  ;;
  4766                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4767                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4768                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4769                                  ;
  4770                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4771                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4772                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4773                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4774                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4775                                  ;	mov	si,[desttail]			;AN015; get filename back
  4776                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4777                                  ;
  4778                                  ;DirCheckPath:
  4779                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4780                                  ;	cmp	ax,0				;AN022; Is there a message?
  4781                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4782                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4783                                  ;	jz	doparse 			;AC000; no - no problem
  4784                                  ;	inc	comsw				;AC000; indicate error
  4785                                  ;	jmp	short doheader			;AC000; go print header
  4786                                  ;
  4787                                  ;DirNF:
  4788                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4789                                  ;
  4790                                  ;dir_err_setup:
  4791                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4792                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4793                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4794                                  ;
  4795                                  ;DirError:
  4796                                  ;	jmp	Cerror
  4797                                  ;
  4798                                  ;;
  4799                                  ;; We have changed to something. We also have a file. Parse it into a
  4800                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4801                                  ;; filename alone. We need to special case ... If we are at the root, the
  4802                                  ;; parse will fail and it will give us a file not found instead of file not
  4803                                  ;; found.
  4804                                  ;;
  4805                                  ;DoParse:
  4806                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4807                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4808                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4809                                  ;	lodsw					;AN000; bypass drive
  4810                                  ;
  4811                                  ;dir_no_drive:
  4812                                  ;	cmp	[si],".."
  4813                                  ;	jnz	DoRealParse
  4814                                  ;	cmp	byte ptr [si+2],0
  4815                                  ;	jnz	DoRealParse
  4816                                  ;	inc	ComSw
  4817                                  ;	jmp	short DoHeader
  4818                                  ;
  4819                                  ;DoRealParse:
  4820                                  ;	mov	di,FCB			; where to put the file name
  4821                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4822                                  ;	int	int_command
  4823                                  ;
  4824                                  ;;
  4825                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4826                                  ;; off.	This will be reset in the HEADFIX routine
  4827                                  ;;
  4828                                  ;
  4829                                  ;DoHeader:
  4830                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4831                                  ;
  4832                                  ;;
  4833                                  ;; Display the header
  4834                                  ;;
  4835                                  ;
  4836                                  ;DoHeaderCont:
  4837                                  ;	mov	al,blank			;AN051; Print out a blank
  4838                                  ;	invoke	print_char			;AN051;   before DIR header
  4839                                  ;	invoke	build_dir_string		; get current dir string
  4840                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4841                                  ;	invoke	printf_crlf			; bang!
  4842                                  ;
  4843                                  ;;
  4844                                  ;; If there were chars left after parse or device, then invalid file name
  4845                                  ;;
  4846                                  ;	cmp	ComSw,0
  4847                                  ;	jz	DoSearch			; nothing left; good parse
  4848                                  ;	jl	DirNFFix			; not .. => error file not found
  4849                                  ;	invoke	RestUDir
  4850                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4851                                  ;	jmp	Cerror				; was .. => error directory not found
  4852                                  ;DirNFFix:
  4853                                  ;	invoke	RestUDir
  4854                                  ;	jmp	DirNF
  4855                                  ;;
  4856                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4857                                  ;; attributes that will include finding directories.  perform the first search
  4858                                  ;; and reset our directory afterward.
  4859                                  ;;
  4860                                  ;DoSearch:
  4861                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4862                                  ;	mov	byte ptr DS:[FCB-1],010H
  4863                                  ;;
  4864                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4865                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4866                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4867                                  ;;
  4868                                  ;	mov	ah,Dir_Search_First
  4869                                  ;	mov	dx,FCB-7
  4870                                  ;	int	int_command
  4871                                  ;
  4872                                  ;	push	ax				;AN022; save return state
  4873                                  ;	inc	al				;AN022; did an error occur?
  4874                                  ;	pop	ax				;AN022; get return state back
  4875                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4876                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4877                                  ;	push	dx				;AN022; save message
  4878                                  ;	invoke	restudir			;AN022; restore user's dir
  4879                                  ;	pop	dx				;AN022; restore message
  4880                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4881                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4882                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4883                                  ;
  4884                                  ;DirCerrorJ:					;AN022;
  4885                                  ;	jmp	Cerror				;AN022; exit
  4886                                  ;
  4887                                  ;;
  4888                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4889                                  ;; previous system call for later checking.
  4890                                  ;;
  4891                                  ;
  4892                                  ;found_first_file:
  4893                                  ;	push	ax
  4894                                  ;	invoke	restudir
  4895                                  ;	pop	ax
  4896                                  ;;
  4897                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4898                                  ;; no more.
  4899                                  ;;
  4900                                  ;DIRSTART:
  4901                                  ;	inc	al				; FF = file not found
  4902                                  ;	jnz	Display
  4903                                  ;	jmp	DirDone 			; Either an error or we are finished
  4904                                  ;;
  4905                                  ;; Note that we've seen a file and display the found file.
  4906                                  ;;
  4907                                  ;
  4908                                  ;Display:
  4909                                  ;	inc	[filecnt]			; Keep track of how many we find
  4910                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4911                                  ;	call	shoname
  4912                                  ;;
  4913                                  ;; If we are displaying in wide mode, do not output the file info
  4914                                  ;;
  4915                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4916                                  ;	jz	DirTest
  4917                                  ;	jmp	nexent				; If so, no size, date, or time
  4918                                  ;
  4919                                  ;;
  4920                                  ;; Test for directory.
  4921                                  ;;
  4922                                  ;DirTest:
  4923                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4924                                  ;	jz	fileent
  4925                                  ;;
  4926                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4927                                  ;;
  4928                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4929                                  ;	call	std_printf
  4930                                  ;	jmp	short nofsiz
  4931                                  ;;
  4932                                  ;; We have a file.  Display the file size
  4933                                  ;;
  4934                                  ;fileent:
  4935                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4936                                  ;	mov	file_size_low,dx
  4937                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4938                                  ;	mov	file_size_high,dx
  4939                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4940                                  ;	call	std_printf
  4941                                  ;;
  4942                                  ;; Display time and date of last modification
  4943                                  ;;
  4944                                  ;nofsiz:
  4945                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4946                                  ;;
  4947                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4948                                  ;; date/time fields as 1.x did not have them.
  4949                                  ;;
  4950                                  ;	or	ax,ax
  4951                                  ;	jz	nexent				; Skip if no date
  4952                                  ;	mov	bx,ax
  4953                                  ;	and	ax,1FH				; get day
  4954                                  ;	mov	dl,al
  4955                                  ;	mov	ax,bx
  4956                                  ;	mov	cl,5
  4957                                  ;	shr	ax,cl				; Align month
  4958                                  ;	and	al,0FH				; Get month
  4959                                  ;	mov	dh,al
  4960                                  ;	mov	cl,bh
  4961                                  ;	shr	cl,1				; Align year
  4962                                  ;	xor	ch,ch
  4963                                  ;	add	cx,80				; Relative 1980
  4964                                  ;	cmp	cl,100
  4965                                  ;	jb	millenium
  4966                                  ;	sub	cl,100
  4967                                  ;
  4968                                  ;millenium:
  4969                                  ;	xchg	dh,dl				;AN000; switch month & day
  4970                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  4971                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  4972                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  4973                                  ;	jcxz	prbuf				; Time field present?
  4974                                  ;	shr	cx,1
  4975                                  ;	shr	cx,1
  4976                                  ;	shr	cx,1
  4977                                  ;	shr	cl,1
  4978                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  4979                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  4980                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  4981                                  ;
  4982                                  ;prbuf:
  4983                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  4984                                  ;	call	std_printf
  4985                                  ;	invoke	crlf2				;AC066;end the line
  4986                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  4987                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  4988                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  4989                                  ;	endif04:				;AN066;
  4990                                  ;	jmp	scroll				; If not, just continue
  4991                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  4992                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  4993                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  4994                                  ;;
  4995                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  4996                                  ;; is only for /W case.
  4997                                  ;;
  4998                                  ;nexent:
  4999                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  5000                                  ;	dec	[lincnt]			      ;count this entry on the line
  5001                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  5002                                  ;	   mov	   al,[linlen]
  5003                                  ;	   mov	   [lincnt],al
  5004                                  ;	   invoke  crlf2
  5005                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  5006                                  ;	   jnz	   endif02			;AN066;
  5007                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  5008                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  5009                                  ;	   jmp	   short endif01		;AN066;
  5010                                  ;	else01: 				;AN066;ELSE since screen not full
  5011                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  5012                                  ;	   jne	   endif03			;	     count the line
  5013                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  5014                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  5015                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  5016                                  ;	   call    std_printf
  5017                                  ;	endif01:				;AX066;
  5018                                  ;;
  5019                                  ;; All we need to do now is to get the next directory entry.
  5020                                  ;;
  5021                                  ;scroll:
  5022                                  ;	mov	ah,Dir_Search_Next
  5023                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  5024                                  ;	int	int_command			; Search for a file to match FCB
  5025                                  ;	jmp	DirStart
  5026                                  ;;
  5027                                  ;; If no files have been found, display a not-found message
  5028                                  ;;
  5029                                  ;DirDone:
  5030                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  5031                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  5032                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  5033                                  ;	test	[filecnt],-1
  5034                                  ;	jnz	Trailer
  5035                                  ;	mov	ax,error_file_not_found 	;AN022;
  5036                                  ;
  5037                                  ;dir_err_setup_jmp:				;AN022;
  5038                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  5039                                  ;;
  5040                                  ;; If we have printed the maximum number of files per line, terminate it with
  5041                                  ;; CRLF.
  5042                                  ;;
  5043                                  ;Trailer:
  5044                                  ;	mov	al,[linlen]
  5045                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5046                                  ;	jz	mmessage
  5047                                  ;	invoke	crlf2
  5048                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5049                                  ;	jnz	endif06 			;AN066;   pause before going on
  5050                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5051                                  ;	endif06:				;AN066;   displays
  5052                                  ;
  5053                                  ;mmessage:
  5054                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5055                                  ;	mov	si,[filecnt]
  5056                                  ;	mov	dir_num,si
  5057                                  ;	call	std_printf
  5058                                  ;	mov	ah,Get_Drive_Freespace
  5059                                  ;	mov	dl,byte ptr DS:[FCB]
  5060                                  ;	int	int_command
  5061                                  ;	cmp	ax,-1
  5062                                  ;	retz
  5063                                  ;	mul	cx				; AX is bytes per cluster
  5064                                  ;	mul	bx
  5065                                  ;	mov	bytes_free,ax			;AC000;
  5066                                  ;	mov	bytes_free+2,dx 		;AC000;
  5067                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5068                                  ;	jmp	std_printf
  5069                                  ;
  5070                                  ;shoname:
  5071                                  ;	mov	di,offset trangroup:charbuf
  5072                                  ;	mov	cx,8
  5073                                  ;	rep	movsb
  5074                                  ;	mov	al,' '
  5075                                  ;	stosb
  5076                                  ;	mov	cx,3
  5077                                  ;	rep	movsb
  5078                                  ;	xor	ax,ax
  5079                                  ;	stosb
  5080                                  ;	push	dx
  5081                                  ;	mov	dx,offset trangroup:charbuf
  5082                                  ;	mov	string_ptr_2,dx
  5083                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5084                                  ;	call	std_printf
  5085                                  ;	pop	DX
  5086                                  ;	return
  5087                                  ;
  5088                                  ;check_for_P    PROC  NEAR		;AN066;
  5089                                  ;
  5090                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5091                                  ;	jz	endif05 		;AN066;
  5092                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5093                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5094                                  ;   	invoke  Pause
  5095                                  ;endif05:
  5096                                  ;	ret				;AN066;
  5097                                  ;
  5098                                  ;check_for_P    ENDP			;AN066;
  5099                                  
  5100                                  ; =============== S U B	R O U T	I N E =======================================
  5101                                  
  5102                                  SHONAME:
  5103                                  DISPLAYNAME:
  5104                                  		; MSDOS 3.3
  5105 00001157 BF[DB41]                		mov	di,CHARBUF
  5106 0000115A B90800                  		mov	cx,8
  5107 0000115D F3A4                    		rep movsb
  5108 0000115F B020                    		mov	al,' '
  5109 00001161 AA                      		stosb
  5110 00001162 B90300                  		mov	cx,3
  5111 00001165 F3A4                    		rep movsb
  5112 00001167 31C0                    		xor	ax,ax
  5113 00001169 AA                      		stosb
  5114 0000116A 52                      		push	dx
  5115 0000116B BA[DB41]                		mov	dx,CHARBUF
  5116 0000116E 8916[8E43]              		mov	[STRING_PTR_2],dx
  5117 00001172 BA[9F36]                		mov	dx,STRINGBUF2PTR
  5118 00001175 E8DC22                  		call	STD_PRINTF
  5119 00001178 5A                      		pop	dx
  5120 00001179 C3                      		retn
  5121                                  
  5122                                  ;============================================================================
  5123                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5124                                  ;============================================================================
  5125                                  ; 09/10/2018 - Retro DOS v3.0
  5126                                  
  5127                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5128                                  
  5129                                  
  5130                                  ; =============== S U B	R O U T	I N E =======================================
  5131                                  
  5132                                  PAUSE:
  5133 0000117A BA[6C39]                		mov	dx,PAUSEMESPTR
  5134 0000117D E8D422                  		call	STD_PRINTF
  5135 00001180 E869F3                  		call	GETKEYSTROKE
  5136 00001183 E8C507                  		call	CRLF2
  5137 00001186 C3                      		retn
  5138                                  
  5139                                  ; ---------------------------------------------------------------------------
  5140                                  
  5141                                  ;****************************************************************
  5142                                  ;*
  5143                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5144                                  ;*
  5145                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5146                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5147                                  ;*		up an error message and transfer control to CERROR.
  5148                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5149                                  ;*		entered or SLASHP_ERASE if /P entered.
  5150                                  ;*
  5151                                  ;* INPUT:	command line at offset 81H
  5152                                  ;*
  5153                                  ;* OUTPUT:	if no error:
  5154                                  ;*		FCB at 5ch set up with filename(s) entered
  5155                                  ;*		Current directory set to entered directory
  5156                                  ;*
  5157                                  ;****************************************************************
  5158                                  
  5159                                  ERASE:
  5160                                  		; MSDOS 6.0
  5161                                  
  5162                                  ;assume	ds:trangroup,es:trangroup
  5163                                  
  5164                                  ;		mov	si,81H		;AC000; get command line
  5165                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5166                                  ;		mov	di,offset trangroup:parse_erase
  5167                                  ;					;AN000; Get address of PARSE_erase
  5168                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5169                                  ;
  5170                                  ;erase_scan:
  5171                                  ;		xor	dx,dx		;AN000;
  5172                                  ;		invoke	parse_with_msg	;AC018; call parser
  5173                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5174                                  ;		jz	good_line	;AN000; yes - done parsing
  5175                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5176                                  ;		jnz	errj2		;AC000; yes exit
  5177                                  ;
  5178                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5179                                  ;					;AN000; was /P entered?
  5180                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5181                                  ;
  5182                                  ;;
  5183                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5184                                  ;;
  5185                                  ;		push	si		;AC000; save position in line
  5186                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5187                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5188                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5189                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5190                                  ;					;AC000; was only drive entered?
  5191                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5192                                  ;		mov	ax,error_file_not_found 
  5193                                  ;					;AN022; get message number in control block
  5194                                  ;		jmp	short extend_setup ;AC000; exit
  5195                                  ;
  5196                                  ;erase_drive_ok:
  5197                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5198                                  ;		pop	si		;AC000; get position back
  5199                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5200                                  ;
  5201                                  ;set_erase_prompt:
  5202                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5203                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5204                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5205                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5206                                  ;		jmp	short errj2	;AN018; exit
  5207                                  ;
  5208                                  ;ok_to_set_erase_prompt: 		;AN018;
  5209                                  ;		inc	comsw		;AN000; indicate /p specified
  5210                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5211                                  ;
  5212                                  ;good_line:				;G  We know line is good
  5213                                  ;		invoke	pathcrunch
  5214                                  ;		jnc	checkdr
  5215                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5216                                  ;		cmp	ax,0		;AN022; was message flag set?
  5217                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5218                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5219                                  ;		jnz	badpath_err	;AC022; see if they should have
  5220                                  ;
  5221                                  ;checkdr:
  5222                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5223                                  ;		jz	notest2j	;AN000; no - go to notest2
  5224                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5225                                  ;
  5226                                  ;notest2j:
  5227                                  ;		jmp	notest2
  5228                                  ;
  5229                                  ;badpath_err:				;AN022; "Path not found" message
  5230                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5231                                  ;
  5232                                  ;extend_setup:				;AN022;
  5233                                  ;		mov	msg_disp_class,ext_msg_class
  5234                                  ;					;AN022; set up extended error msg class
  5235                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5236                                  ;					;AC022; get extended message pointer
  5237                                  ;		mov	Extend_Buf_ptr,ax
  5238                                  ;					;AN022; get message number in control block
  5239                                  ;errj2:					;AC022; exit jump
  5240                                  ;		jmp	Cerror		;AN022;
  5241                                  
  5242                                  		; MSDOS 3.3
  5243 00001187 BA[CD3C]                		mov	dx,BADARGSPTR
  5244 0000118A BE8000                  		mov	si,80h
  5245 0000118D AC                      		lodsb
  5246 0000118E 08C0                    		or	al,al
  5247 00001190 743E                    		jz	short ERRJ2
  5248 00001192 E8C307                  		call	SCANOFF
  5249 00001195 3C0D                    		cmp	al,0Dh		; Return key
  5250 00001197 7437                    		jz	short ERRJ2	; If so no parameters specified
  5251 00001199 52                      		push	dx
  5252 0000119A 56                      		push	si
  5253 0000119B BA[5837]                		mov	dx,FNOTFOUNDPTR
  5254                                  ERASE_SCAN:
  5255 0000119E AC                      		lodsb
  5256 0000119F E8BE07                  		call	DELIM
  5257 000011A2 7406                    		jz	short ERASE_CHKDELIMCHR
  5258 000011A4 3C0D                    		cmp	al,0Dh
  5259 000011A6 7415                    		jz	short GOOD_LINE
  5260 000011A8 EBF4                    		jmp	short ERASE_SCAN
  5261                                  ERASE_CHKDELIMCHR:
  5262 000011AA 3C20                    		cmp	al,20h
  5263 000011AC 7F22                    		jg	short ERRJ2
  5264 000011AE AC                      		lodsb
  5265 000011AF E8AE07                  		call	DELIM
  5266 000011B2 74F6                    		jz	short ERASE_CHKDELIMCHR
  5267 000011B4 3C0D                    		cmp	al,0Dh
  5268 000011B6 7405                    		jz	short GOOD_LINE
  5269 000011B8 BA[CD3C]                		mov	dx,BADARGSPTR
  5270 000011BB EB13                    		jmp	short ERRJ2
  5271                                  GOOD_LINE:
  5272 000011BD 5E                      		pop	si
  5273 000011BE 5A                      		pop	dx
  5274 000011BF 56                      		push	si
  5275 000011C0 E83808                  		call	PATHCRUNCH
  5276 000011C3 730E                    		jnc	short CHECKDR
  5277 000011C5 803E[AC43]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5278 000011CA 7407                    		jz	short CHECKDR	   ; see if they should have
  5279                                  BADCDERR:
  5280 000011CC 5E                      		pop	si
  5281 000011CD BA[D63A]                		mov	dx,BADCDPTR
  5282                                  ERRJ2:
  5283 000011D0 E92D0A                  		jmp	CERROR
  5284                                  CHECKDR:
  5285 000011D3 BA[5837]                		mov	dx,FNOTFOUNDPTR
  5286 000011D6 59                      		pop	cx
  5287 000011D7 B020                    		mov	al,' '
  5288                                  		;cmp	[5Dh],al
  5289 000011D9 38065D00                		cmp	[FCB+1],al
  5290 000011DD 74F1                    		jz	short ERRJ2
  5291 000011DF 83C103                  		add	cx,3
  5292 000011E2 39CE                    		cmp	si,cx
  5293 000011E4 7507                    		jnz	short NOTEST2J
  5294 000011E6 B03A                    		mov	al,':'
  5295 000011E8 3844FE                  		cmp	[si-2],al
  5296 000011EB 74E3                    		jz	short ERRJ2
  5297                                  NOTEST2J:
  5298 000011ED E9D315                  		jmp	NOTEST2
  5299                                  
  5300                                  ; ---------------------------------------------------------------------------
  5301                                  
  5302                                  ; ****************************************************************
  5303                                  ; *
  5304                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5305                                  ; *
  5306                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5307                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5308                                  ; *		 Make sure the second filespec only contains a
  5309                                  ; *		 filename.  If both openands are valid, attempt
  5310                                  ; *		 to rename the file.
  5311                                  ; *
  5312                                  ; * INPUT:	 command line at offset 81H
  5313                                  ; *
  5314                                  ; * OUTPUT:	 none
  5315                                  ; *
  5316                                  ; ****************************************************************
  5317                                  
  5318                                  CRENAME:
  5319                                  		; MSDOS 6.0
  5320                                  		;assume	ds:trangroup,es:trangroup
  5321                                  ;
  5322                                  ;		mov	si,81H		;AC000; Point to command line
  5323                                  ;		mov	di,offset trangroup:parse_rename
  5324                                  ;					;AN000; Get address of PARSE_RENAME
  5325                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5326                                  ;		xor	dx,dx		;AN000;
  5327                                  ;		invoke	parse_with_msg	;AC018; call parser
  5328                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5329                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5330                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5331                                  ;;
  5332                                  ;;  Get first file name returned from parse into our buffer
  5333                                  ;;
  5334                                  ;crename_no_parse_error:
  5335                                  ;		push	si		;AN000; save position in line
  5336                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5337                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5338                                  ;		pop	si		;AN000; restore position in line
  5339                                  ;
  5340                                  ;		xor	dx,dx		;AN000; clear dx
  5341                                  ;		invoke	parse_with_msg	;AC018; call parser
  5342                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5343                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5344                                  ;;
  5345                                  ;;  Check the second file name for drive letter colon
  5346                                  ;;
  5347                                  ;		push	si		;AN000; save position in line
  5348                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5349                                  ;
  5350                                  ;		mov	al,':'		;AC000;
  5351                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5352                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5353                                  ;		mov	msg_disp_class,parse_msg_class
  5354                                  ;					;AN000; set up parse error msg class
  5355                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5356                                  ;					;AC000; get extended message pointer
  5357                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5358                                  ;					;AN000; get "Invalid parameter" message number
  5359                                  ;		pop	si		;AN000;
  5360                                  ;crename_parse_error:			;AC022;
  5361                                  ;		jmp	short errj	;AC000;
  5362                                  ;
  5363                                  ;;  Get second file name returned from parse into the fCB. Save
  5364                                  ;;  character after file name so we can later check to make sure it
  5365                                  ;;  isn't a path character.
  5366                                  ;
  5367                                  ;
  5368                                  ;ren_no_drive:
  5369                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5370                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5371                                  ;		int	21h		;AC000; do the function
  5372                                  ;		lodsb			;AC000; Load char after filename
  5373                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5374                                  ;		pop	si		;AN000; get line position back
  5375                                  ;
  5376                                  ;;
  5377                                  ;; We have source and target.  See if any args beyond.
  5378                                  ;;
  5379                                  ;
  5380                                  ;		mov	di,offset trangroup:parse_rename
  5381                                  ;					;AC000; get address of parse_rename
  5382                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5383                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5384                                  ;
  5385                                  ;		invoke	pathcrunch
  5386                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5387                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5388                                  ;		jnc	notest3
  5389                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5390                                  ;		cmp	ax,0		;AN022; was message flag set?
  5391                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5392                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5393                                  ;		jz	notest3 	; see if they should have
  5394                                  ;		Jmp	badpath_err	;AC022; set up error
  5395                                  ;
  5396                                  ;notest3:
  5397                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5398                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5399                                  ;					; Load invalid fname error ptr
  5400                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5401                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5402                                  ;					;  filename only.
  5403                                  ;		mov	ah,FCB_Rename
  5404                                  ;		mov	dx,FCB
  5405                                  ;		int	21h
  5406                                  ;		cmp	al, 0FFH	; Did an error occur??
  5407                                  ;		jnz	renameok
  5408                                  ;
  5409                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5410                                  ;		SaveReg <AX>		;AC022; Save results
  5411                                  ;		mov	al, 0FFH	; Restore original error state
  5412                                  ;
  5413                                  ;renameok:
  5414                                  ;		push	ax
  5415                                  ;		invoke	restudir
  5416                                  ;		pop	ax
  5417                                  ;		inc	al
  5418                                  ;		retnz
  5419                                  ;
  5420                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5421                                  ;		cmp	ax,error_file_not_found 
  5422                                  ;					;AN022; error file not found?
  5423                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5424                                  ;		cmp	ax,error_access_denied
  5425                                  ;					;AN022; error file not found?
  5426                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5427                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5428                                  ;
  5429                                  ;use_renerr:
  5430                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5431                                  ;ERRJ:
  5432                                  ;		jmp	Cerror
  5433                                  ;
  5434                                  ;ret56:		ret
  5435                                  
  5436                                  		; MSDOS 3.3
  5437 000011F0 BA[CD3C]                		mov	dx,BADARGSPTR
  5438 000011F3 E86207                  		call	SCANOFF
  5439 000011F6 3C0D                    		cmp	al,0Dh
  5440 000011F8 74D6                    		jz	short ERRJ2
  5441 000011FA E8FE07                  		call	PATHCRUNCH
  5442 000011FD BA[AC3C]                		mov	dx,BADCPMESPTR
  5443 00001200 74CE                    		jz	short ERRJ2
  5444 00001202 7309                    		jnb	short CRENAME_NO_PARSE_ERROR
  5445 00001204 803E[AC43]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5446 00001209 7402                    		jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5447 0000120B EBBF                    		jmp	short BADCDERR
  5448                                  
  5449                                  ;  Get first file name returned from parse into our buffer
  5450                                  
  5451                                  CRENAME_NO_PARSE_ERROR:
  5452 0000120D 8B36[0043]              		mov	si,[PATHPOS]
  5453 00001211 E84407                  		call	SCANOFF
  5454 00001214 3C0D                    		cmp	al,0Dh
  5455 00001216 BA[CD3C]                		mov	dx,BADARGSPTR
  5456 00001219 7443                    		jz	short ERRJ
  5457 0000121B B03A                    		mov	al,':'
  5458 0000121D BA[8239]                		mov	dx,BADPARMPTR
  5459 00001220 384401                  		cmp	[si+1],al
  5460 00001223 7439                    		jz	short ERRJ
  5461                                  
  5462                                  ;  Get second file name returned from parse into the FCB. Save
  5463                                  ;  character after file name so we can later check to make sure it
  5464                                  ;  isn't a path character.
  5465                                  
  5466                                  REN_NO_DRIVE:
  5467                                  		;mov	di,6Ch
  5468 00001225 BF6C00                  		mov	di,FCB+10h
  5469 00001228 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5470 0000122B CD21                    		int	21h	; DOS -	PARSE FILENAME
  5471                                  				; DS:SI	-> string to parse
  5472                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5473                                  				; AL = bit mask	to control parsing
  5474 0000122D B020                    		mov	al,' '
  5475                                  		;cmp	[6Dh],al
  5476 0000122F 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5477 00001233 7429                    		jz	short ERRJ	; Error if missing parameter
  5478 00001235 AC                      		lodsb
  5479 00001236 BA[4738]                		mov	dx,INORNOTPTR
  5480 00001239 E8AE07                  		call	PATHCHRCMP
  5481 0000123C 7420                    		jz	short ERRJ
  5482 0000123E B417                    		mov	ah,FCB_RENAME ; 17h
  5483 00001240 BA5C00                  		mov	dx,FCB ; 5Ch
  5484 00001243 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5485                                  				; DS:DX	-> FCB
  5486                                  				; FCB contains new name	starting at byte 17h.
  5487 00001245 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5488 00001247 750A                    		jnz	short RENAMEOK
  5489 00001249 F9                      		stc
  5490 0000124A BA[4537]                		mov	dx,RENERRPTR
  5491 0000124D E83F0C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5492 00001250 52                      		push	dx
  5493 00001251 B0FF                    		mov	al,0FFh		; Restore original error state
  5494                                  RENAMEOK:
  5495 00001253 50                      		push	ax
  5496 00001254 E82306                  		call	RESTUDIR
  5497 00001257 58                      		pop	ax
  5498 00001258 FEC0                    		inc	al
  5499 0000125A 7401                    		jz	short RENAME_ERR
  5500                                  RENAME_RETN:
  5501                                  TYPELP_RET:
  5502 0000125C C3                      		retn
  5503                                  RENAME_ERR:
  5504 0000125D 5A                      		pop	dx
  5505                                  ERRJ:					; Retro DOS v3.0
  5506 0000125E E8EA21                  		call	STD_EPRINTF
  5507 00001261 E9A0EE                  		jmp	TCOMMAND
  5508                                  
  5509                                  ; ---------------------------------------------------------------------------
  5510                                  
  5511                                  ;ERRJ:
  5512                                  ;		jmp	CERROR
  5513                                  
  5514                                  ; ---------------------------------------------------------------------------
  5515                                  
  5516                                  ;TYPELP_RET:
  5517                                  ;		retn
  5518                                  
  5519                                  ; ---------------------------------------------------------------------------
  5520                                  
  5521                                  ;****************************************************************
  5522                                  ;*
  5523                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5524                                  ;*		standard output device
  5525                                  ;*
  5526                                  ;* SYNTAX:	TYPE filespec
  5527                                  ;*
  5528                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5529                                  ;*		1Ah and display the contents to STDOUT.
  5530                                  ;*
  5531                                  ;* INPUT:	command line at offset 81H
  5532                                  ;*
  5533                                  ;* OUTPUT:	none
  5534                                  ;*
  5535                                  ;****************************************************************
  5536                                  
  5537                                  TYPEFIL:
  5538                                  		; MSDOS 6.0	
  5539                                  		;assume	ds:trangroup,es:trangroup
  5540                                  
  5541                                  ;		mov	si,81H
  5542                                  ;		mov	di,offset trangroup:parse_mrdir 
  5543                                  ;					;AN000; Get address of PARSE_MRDIR
  5544                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5545                                  ;		xor	dx,dx		;AN000;
  5546                                  ;		invoke	parse_with_msg	;AC018; call parser
  5547                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5548                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5549                                  ;
  5550                                  ;		push	si		;AC000; save position in line
  5551                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5552                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5553                                  ;		pop	si		;AC000; get position back
  5554                                  ;		mov	di,offset trangroup:parse_mrdir 
  5555                                  ;					;AC000; get address of parse_mrdir
  5556                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5557                                  ;		jz	gottarg 	;AC000; yes - continue
  5558                                  ;
  5559                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5560                                  ;		jmp	Cerror
  5561                                  ;
  5562                                  ;gottarg:
  5563                                  ;		invoke	setpath
  5564                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5565                                  ;		jz	nowilds 	; No, continue processing
  5566                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5567                                  ;		jmp	Cerror
  5568                                  ;nowilds:
  5569                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5570                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5571                                  ;		xor	cx,cx		;AN000; no special files
  5572                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5573                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5574                                  ;		int	21h
  5575                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5576                                  ;
  5577                                  ;Typerr: 				;AN022;
  5578                                  ;		push	cs		;AN022; make sure we have local segment
  5579                                  ;		pop	ds		;AN022;
  5580                                  ;		invoke	set_ext_error_msg ;AN022;
  5581                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5582                                  ;					;AC022; get address of failed string
  5583                                  ;		mov	Extend_buf_sub,one_subst
  5584                                  ;					;AC022; put number of subst in control block
  5585                                  ;		jmp	cerror		;AC022; exit
  5586                                  ;
  5587                                  ;typecont:
  5588                                  ;		mov	bx,ax		;AC000; get  Handle
  5589                                  ;;M043
  5590                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5591                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5592                                  ;;indicate it is a device.
  5593                                  ;;
  5594                                  ;		mov	ax,(IOCTL shl 8) or 0
  5595                                  ;		int	21h
  5596                                  ;
  5597                                  ;		test	dl,80h		;is it a device?
  5598                                  ;		jz	not_device	;no, a file
  5599                                  ;
  5600                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5601                                  ;		jmp	short dotype
  5602                                  ;not_device:
  5603                                  ;
  5604                                  ;;SR;
  5605                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5606                                  ;;start of file
  5607                                  ;;
  5608                                  ;		mov	ax,(LSEEK shl 8) or 2
  5609                                  ;		xor	dx,dx
  5610                                  ;		mov	cx,dx		;seek  to end of file
  5611                                  ;		int	21h
  5612                                  ;
  5613                                  ;		mov	word ptr TypeFilSiz,ax
  5614                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5615                                  ;
  5616                                  ;		mov	ax,(LSEEK shl 8) or 0
  5617                                  ;		xor	dx,dx
  5618                                  ;		int	21h	        ;reset file pointer to start
  5619                                  ;dotype:					;M043
  5620                                  ;		mov	zflag,0 	; Reset ^Z flag
  5621                                  ;		mov	ds,[TPA]
  5622                                  ;		xor	dx,dx
  5623                                  ;		;ASSUME	DS:NOTHING
  5624                                  ;
  5625                                  ;typelp:
  5626                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5627                                  ;		retnz			; Yes, return
  5628                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5629                                  ;;
  5630                                  ;;Update the filesize left to read
  5631                                  ;;
  5632                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5633                                  ;		je	typ_read	;yes, just read from it; M043
  5634                                  ;
  5635                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5636                                  ;		jz	lt64k		;no, do word subtraction
  5637                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5638                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5639                                  ;      		jmp	short typ_read	;do the read
  5640                                  ;lt64k:
  5641                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5642                                  ;		jbe	gtbuf		; yes, just update readsize
  5643                                  ;;
  5644                                  ;;Buffer size is larger than bytes to read
  5645                                  ;;
  5646                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5647                                  ;		jcxz	typelp_ret
  5648                                  ;		mov	word ptr cs:TypeFilSiz,0
  5649                                  ;		jmp	short typ_read
  5650                                  ;gtbuf:
  5651                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5652                                  ;typ_read:
  5653                                  ;		mov	ah,read
  5654                                  ;		int	21h		
  5655                                  ;		jnc	@f		;M043
  5656                                  ;		jmp	typerr		;M043
  5657                                  ;@@:					;M043
  5658                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5659                                  ;
  5660                                  ;		mov	cx,ax
  5661                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5662                                  ;		push	ds
  5663                                  ;		pop	es		; Check to see if a ^Z was read.
  5664                                  ;		;assume es:nothing
  5665                                  ;		xor	di,di
  5666                                  ;		push	ax
  5667                                  ;		mov	al,1ah
  5668                                  ;		repnz	scasb
  5669                                  ;		pop	ax
  5670                                  ;		xchg	ax,cx
  5671                                  ;		cmp	ax,0
  5672                                  ;		jnz	foundz		; Yes, handle it
  5673                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5674                                  ;		jnz	typecont2	; No ^Z, continue
  5675                                  ;
  5676                                  ;foundz:
  5677                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5678                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5679                                  ;		push	cs		;  will be typed.
  5680                                  ;		pop	es
  5681                                  ;		;assume es:trangroup
  5682                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5683                                  ;typecont2:				;  will quit after this write.
  5684                                  ;		push	bx
  5685                                  ;		mov	bx,1
  5686                                  ;		mov	ah,write
  5687                                  ;		int	21h
  5688                                  ;		pop	bx
  5689                                  ;		jc	Error_outputj
  5690                                  ;		cmp	ax,cx
  5691                                  ;		jnz	@f		;M043
  5692                                  ;		jmp	typelp		;M043
  5693                                  ;@@:					;M043
  5694                                  ;;M043;		jz	typelp
  5695                                  ;		dec	cx
  5696                                  ;		cmp	ax,cx
  5697                                  ;		retz			; One less byte OK (^Z)
  5698                                  ;Error_outputj:
  5699                                  ;		mov	bx,1
  5700                                  ;		mov	ax,IOCTL SHL 8
  5701                                  ;		int	21h
  5702                                  ;		test	dl,devid_ISDEV
  5703                                  ;		retnz			; If device, no error message
  5704                                  ;		jmp	error_output
  5705                                  ;typelp_ret:
  5706                                  ;		ret
  5707                                  
  5708                                  		; MSDOS 3.3
  5709 00001264 BE8100                  		mov	si,81h
  5710 00001267 E8EE06                  		call	SCANOFF		; Skip to first non-delim
  5711 0000126A 3C0D                    		cmp	al,0Dh
  5712 0000126C 7505                    		jnz	short GOTTARG
  5713 0000126E BA[CD3C]                		mov	dx,BADARGSPTR
  5714                                  
  5715                                  		;jmp	CERROR
  5716 00001271 EBEB                    		jmp	short ERRJ	; No args
  5717                                  GOTTARG:
  5718 00001273 E8C80A                  		call	SETPATH
  5719 00001276 F606[B043]02            		test	byte [DESTINFO],2
  5720 0000127B 7405                    		jz	short NOWILDS
  5721 0000127D BA[4738]                		mov	dx,INORNOTPTR
  5722                                  
  5723                                  		;jmp	CERROR
  5724 00001280 EBDC                    		jmp	short ERRJ
  5725                                  NOWILDS:
  5726 00001282 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5727 00001285 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5728                                  				; DS:DX	-> ASCIZ filename
  5729                                  				; AL = access mode
  5730                                  				; 0 - read
  5731 00001287 7311                    		jnc	short TYPECONT
  5732 00001289 BA[5837]                		mov	dx,FNOTFOUNDPTR
  5733 0000128C 83F802                  		cmp	ax,2
  5734 0000128F 74CD                    		jz	short ERRJ
  5735 00001291 BA[AC3C]                		mov	dx,BADCPMESPTR
  5736 00001294 F9                      		stc
  5737 00001295 E8F70B                  		call	GET_EXT_ERR_NUMBER
  5738                                  
  5739                                  		;jmp	CERROR
  5740 00001298 EBC4                    		jmp	short ERRJ
  5741                                  TYPECONT:
  5742 0000129A C606[374B]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5743 0000129F 89C3                    		mov	bx,ax		; Handle
  5744 000012A1 8E1E[B341]              		mov	ds,[TPA]
  5745 000012A5 31D2                    		xor	dx,dx
  5746                                  TYPELP:
  5747 000012A7 2E803E[374B]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5748 000012AD 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5749 000012AF 2E8B0E[D241]            		mov	cx,[cs:BYTCNT]	; No, continue
  5750 000012B4 B43F                    		mov	ah,READ ; 3Fh
  5751 000012B6 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5752                                  				; BX = file handle,CX = number	of bytes to read
  5753                                  				; DS:DX	-> buffer
  5754 000012B8 89C1                    		mov	cx,ax
  5755 000012BA E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5756                                  					; Check to see if a ^Z was read.
  5757 000012BC 1E                      		push	ds
  5758 000012BD 07                      		pop	es		
  5759 000012BE 31FF                    		xor	di,di
  5760 000012C0 50                      		push	ax
  5761 000012C1 B01A                    		mov	al,1Ah
  5762 000012C3 F2AE                    		repne scasb
  5763 000012C5 58                      		pop	ax
  5764 000012C6 91                      		xchg	ax,cx
  5765 000012C7 83F800                  		cmp	ax,0
  5766 000012CA 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5767 000012CC 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5768 000012D0 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5769                                  FOUNDZ:
  5770 000012D2 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5771 000012D4 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5772 000012D5 0E                      		push	cs		;  will be typed.
  5773 000012D6 07                      		pop	es
  5774 000012D7 2EF616[374B]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5775                                  					;  will quit after this write.
  5776                                  TYPECONT2:
  5777 000012DC 53                      		push	bx
  5778 000012DD BB0100                  		mov	bx,1
  5779 000012E0 B440                    		mov	ah,WRITE ; 40h
  5780 000012E2 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5781                                  				; BX = file handle, CX = number of bytes to write,
  5782                                  				; DS:DX -> buffer
  5783 000012E4 5B                      		pop	bx
  5784 000012E5 720A                    		jc	short ERROR_OUTPUTJ
  5785 000012E7 39C8                    		cmp	ax,cx
  5786 000012E9 74BC                    		jz	short TYPELP
  5787 000012EB 49                      		dec	cx
  5788 000012EC 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5789 000012EE 7501                    		jnz	short ERROR_OUTPUTJ
  5790                                  TYPEFIL_RETN:
  5791 000012F0 C3                      		retn
  5792                                  ERROR_OUTPUTJ:
  5793 000012F1 BB0100                  		mov	bx,1
  5794 000012F4 B80044                  		mov	ax,IOCTL*256 ; 4400h
  5795 000012F7 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5796                                  				; BX = file or device handle
  5797                                  		;test	dl,devid_ISDEV
  5798 000012F9 F6C280                  		test	dl,80h
  5799 000012FC 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5800 000012FE E9CF06                  		jmp	ERROR_OUTPUT
  5801                                  
  5802                                  ; ---------------------------------------------------------------------------
  5803                                  
  5804                                  ; VOLUME command displays the volume ID on the specified drive
  5805                                  
  5806                                  VOLUME:
  5807                                  		; MSDOS 6.0
  5808                                  		;mov	si,81H
  5809                                  		;mov	di,offset trangroup:parse_vol
  5810                                  		;			;AN000; Get address of PARSE_VOL
  5811                                  		;xor	cx,cx		;AN000; clear cx,dx
  5812                                  		;xor	dx,dx		;AN000;
  5813                                  		;invoke	parse_with_msg	;AC018; call parser
  5814                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5815                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5816                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5817                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5818                                  
  5819                                  ; We have parsed off the drive. See if there are any more chars left
  5820                                  
  5821                                  		;mov	di,offset trangroup:parse_vol	
  5822                                  					;AC000; get address of parse_vol
  5823                                  		;xor	dx,dx		;AC000;
  5824                                  		;invoke	parse_check_eol ;AC000; call parser
  5825                                  		;jz	OkVolArg	;AC000; yes, end of road
  5826                                  
  5827                                  ; The line was not interpretable. Report an error.
  5828                                  
  5829                                  ;badvolarg:
  5830                                  		;jmp	Cerror
  5831                                  
  5832                                  		; MSDOS 3.3
  5833 00001301 BE8100                  		mov	si,81h
  5834 00001304 E85106                  		call	SCANOFF		; Skip to first non-delim
  5835                                  		;mov	ah,[5Ch]
  5836 00001307 8A265C00                		mov	ah,[FCB]
  5837                                  		;mov	byte [5Ch],0
  5838 0000130B C6065C0000              		mov	byte [FCB],0
  5839 00001310 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5840 00001312 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5841                                  		;mov	[5Ch],ah
  5842 00001314 88265C00                		mov	[FCB],ah
  5843 00001318 AC                      		lodsb
  5844 00001319 AC                      		lodsb
  5845 0000131A 3C3A                    		cmp	al,':'
  5846 0000131C 7507                    		jnz	short VOLUME_ERR
  5847 0000131E E83706                  		call	SCANOFF
  5848 00001321 3C0D                    		cmp	al,0Dh
  5849 00001323 7406                    		jz	short OKVOLARG
  5850                                  VOLUME_ERR:
  5851 00001325 BA[A938]                		mov	dx,BADDRVPTR
  5852 00001328 E9D508                  		jmp	CERROR
  5853                                  
  5854                                  ; ---------------------------------------------------------------------------
  5855                                  
  5856                                  OKVOLARG:
  5857 0000132B E81D06                  		call	CRLF2
  5858 0000132E 1E                      		push	ds
  5859 0000132F 07                      		pop	es
  5860                                  		;mov	di,55h
  5861 00001330 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5862 00001333 B0FF                    		mov	al,-1
  5863 00001335 AA                      		stosb
  5864 00001336 31C0                    		xor	ax,ax
  5865 00001338 AB                      		stosw
  5866 00001339 AB                      		stosw
  5867 0000133A AA                      		stosb
  5868 0000133B B008                    		mov	al,8		; Look for volume label
  5869 0000133D AA                      		stosb
  5870 0000133E 47                      		inc	di		; Skip drive byte
  5871 0000133F B90B00                  		mov	cx,11
  5872 00001342 B03F                    		mov	al,'?'
  5873 00001344 F3AA                    		rep stosb
  5874 00001346 BA[AA42]                		mov	dx,DIRBUF
  5875 00001349 B41A                    		mov	ah,SET_DMA ; 1Ah
  5876 0000134B CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5877                                  				; DS:DX	-> disk	transfer buffer
  5878                                  		;mov	dx,55h
  5879 0000134D BA5500                  		mov	dx,FCB-7
  5880 00001350 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5881 00001352 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5882                                  				; DS:DX	-> FCB
  5883 00001354 E9AB15                  		jmp	PRINTVOL
  5884                                  
  5885                                  ;============================================================================
  5886                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5887                                  ;============================================================================
  5888                                  ; 08/10/2018 - Retro DOS v3.0
  5889                                  
  5890                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5891                                  
  5892                                  ; ---------------------------------------------------------------------------
  5893                                  
  5894                                  ; MSDOS 6.0
  5895                                  ;***	Version - display DOS version
  5896                                  ;
  5897                                  ;	SYNTAX	ver [/debug]
  5898                                  ;
  5899                                  ;		/debug - display additional DOS configuration info
  5900                                  ;
  5901                                  ;	ENTRY	command-line tail is in PSP
  5902                                  ;
  5903                                  ;	EXIT	if successful, nothing
  5904                                  ;		if parse fails,
  5905                                  ;		  parse error message is set up (for Std_EPrintf)
  5906                                  ;		    AX = system parser error code
  5907                                  ;		    DX = ptr to message block
  5908                                  ;		  we jump to CError
  5909                                  ;
  5910                                  ;	EFFECTS
  5911                                  ;	  If parse fails, a parse error message is displayed.
  5912                                  ;	  Otherwise, version message is displayed.
  5913                                  ;	  If /debug is specified, additional DOS info is displayed.
  5914                                  
  5915                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5916                                  ;
  5917                                  ;;	Parse command line for /debug switch.
  5918                                  ;
  5919                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5920                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5921                                  ;	xor	cx,cx				; CX = # positional param's found
  5922                                  ;	invoke	Parse_With_Msg
  5923                                  ;
  5924                                  ;	mov	bl,1			; BL = flag = /debug present
  5925                                  ;	cmp	ax,RESULT_NO_ERROR
  5926                                  ;	je	verPrintVer		; something parsed - must be /debug
  5927                                  ;	dec	bl			; BL = flag = no /debug present
  5928                                  ;	cmp	ax,END_OF_LINE
  5929                                  ;	je	verPrintVer		; reached end of line - ok
  5930                                  ;
  5931                                  ;;	The parse failed.  Error message has been set up.
  5932                                  ;
  5933                                  ;	jmp	CError
  5934                                  ;
  5935                                  ;verPrintVer:
  5936                                  ;	push	bx			; save /debug flag
  5937                                  ;	call	Crlf2
  5938                                  ;	call	Print_Version
  5939                                  ;	call	Crlf2
  5940                                  ;	pop	bx   			; BL = /debug flag
  5941                                  ;	or	bl,bl
  5942                                  ;	jz	verDone			; /debug is false - we're done
  5943                                  ;
  5944                                  ;;*	For /debug, display DOS internal revision and DOS location
  5945                                  ;;	(low memory, HMA, or ROM).
  5946                                  ;
  5947                                  ;;	Bugbug:	use symbols for bitmasks below.
  5948                                  ;
  5949                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5950                                  ;	int	21h
  5951                                  ;	mov	al,dl			;revision number in dl; M013
  5952                                  ;	mov	bh,dh			;flags in dh now; M013
  5953                                  ;;M032	and	al,7			; AL = DOS internal revision
  5954                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5955                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5956                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5957                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5958                                  ;	mov	One_Char_Val,al
  5959                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5960                                  ;	invoke	Std_Printf		; print DOS internal revision
  5961                                  ;
  5962                                  ;	mov	cl,4
  5963                                  ;	shr	bh,cl			; CY = DOS in ROM
  5964                                  ;	jc	verRom
  5965                                  ;	shr	bh,1			; CY = DOS in HMA
  5966                                  ;	jc	verHma
  5967                                  ;
  5968                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  5969                                  ;
  5970                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  5971                                  ;	jmp	short verPrintLoc
  5972                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  5973                                  ;	jmp	short verPrintLoc
  5974                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  5975                                  ;verPrintLoc:
  5976                                  ;	invoke	Std_Printf
  5977                                  ;verDone:
  5978                                  ;	jmp	Crlf2
  5979                                  
  5980                                  		; MSDOS 3.3
  5981                                  VERSION:
  5982 00001357 E8F105                  		call	CRLF2
  5983 0000135A E80300                  		call	PRINT_VERSION
  5984 0000135D E9EB05                  		jmp	CRLF2
  5985                                  
  5986                                  ; =============== S U B	R O U T	I N E =======================================
  5987                                  
  5988                                  PRINT_VERSION:
  5989 00001360 B430                    		mov	ah,GET_VERSION ; 30h
  5990 00001362 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  5991                                  				; Return: AL = major version number (00h for DOS 1.x)
  5992 00001364 50                      		push	ax
  5993 00001365 30E4                    		xor	ah,ah
  5994 00001367 A3[9D43]                		mov	[MAJOR_VER_NUM],ax
  5995 0000136A 58                      		pop	ax
  5996 0000136B 86E0                    		xchg	ah,al
  5997 0000136D 30E4                    		xor	ah,ah
  5998 0000136F A3[9F43]                		mov	[MINOR_VER_NUM],ax
  5999 00001372 BA[873A]                		mov	dx,VERMESPTR
  6000 00001375 E9DC20                  		jmp	STD_PRINTF
  6001                                  
  6002                                  ; =============== S U B	R O U T	I N E =======================================
  6003                                  
  6004                                  PRINT_PROMPT:
  6005 00001378 1E                      		push	ds
  6006 00001379 0E                      		push	cs
  6007 0000137A 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  6008 0000137B 06                      		push	es
  6009 0000137C E8F803                  		call	FIND_PROMPT	; Look for prompt string
  6010 0000137F 7206                    		jc	short PP0	; Can't find one	
  6011 00001381 26803D00                		cmp	byte [es:di],0
  6012 00001385 750A                    		jnz	short PP1
  6013                                  PP0:					; Use default prompt
  6014 00001387 E86D00                  		call	PRINT_DRIVE
  6015                                  		;mov	al,'>'
  6016 0000138A B03E                    		mov	al,SYM
  6017 0000138C E85500                  		call	PRINT_CHAR
  6018 0000138F EB38                    		jmp	short PP5
  6019                                  PP1:
  6020 00001391 268A05                  		mov	al,[es:di]	; Get a char
  6021 00001394 47                      		inc	di
  6022 00001395 08C0                    		or	al,al
  6023 00001397 7430                    		jz	short PP5	; Nul terminated
  6024                                  		;cmp	al,[DOLLAR]	; Meta character
  6025                                  		; 01/03/2023
  6026 00001399 3C24                    		cmp	al,dollar ; '$'
  6027 0000139B 7405                    		jz	short PP2	; Nope
  6028 0000139D E84400                  		call	PRINT_CHAR
  6029 000013A0 EBEF                    		jmp	short PP1
  6030                                  PP2:
  6031 000013A2 268A05                  		mov	al,[es:di]
  6032 000013A5 47                      		inc	di
  6033                                  		;mov	bx,CLSSTRING+2	; "[2J"
  6034 000013A6 BB[FC3C]                		mov	bx,PROMPT_TABLE-3
  6035 000013A9 08C0                    		or	al,al
  6036 000013AB 741C                    		jz	short PP5
  6037                                  PP3:
  6038 000013AD 83C303                  		add	bx,3
  6039                                  		;call	UPCONV
  6040 000013B0 E84E04                  		call	UPCONV_MAPCALL
  6041 000013B3 3A07                    		cmp	al,[bx]
  6042 000013B5 7407                    		jz	short PP4
  6043 000013B7 803F00                  		cmp	byte [bx],0
  6044 000013BA 75F1                    		jnz	short PP3
  6045 000013BC EBD3                    		jmp	short PP1
  6046                                  PP4:
  6047 000013BE 06                      		push	es
  6048 000013BF 57                      		push	di
  6049 000013C0 0E                      		push	cs
  6050 000013C1 07                      		pop	es
  6051 000013C2 FF5701                  		call	word [bx+1]
  6052 000013C5 5F                      		pop	di
  6053 000013C6 07                      		pop	es
  6054 000013C7 EBC8                    		jmp	short PP1
  6055                                  PP5:
  6056 000013C9 07                      		pop	es		; Restore segments
  6057 000013CA 1F                      		pop	ds
  6058 000013CB C3                      		retn
  6059                                  
  6060                                  ; ---------------------------------------------------------------------------
  6061                                  
  6062                                  PRINT_BACK:
  6063 000013CC BA[F43C]                		mov	dx,DBACKPTR
  6064 000013CF E98220                  		jmp	STD_PRINTF
  6065                                  
  6066                                  ; ---------------------------------------------------------------------------
  6067                                  
  6068                                  PRINT_EQ:
  6069 000013D2 B03D                    		mov	al,'='
  6070 000013D4 EB0E                    		jmp	short PRINT_CHAR
  6071                                  
  6072                                  ; ---------------------------------------------------------------------------
  6073                                  
  6074                                  PRINT_ESC:
  6075 000013D6 B01B                    		mov	al,1Bh
  6076 000013D8 EB0A                    		jmp	short PRINT_CHAR
  6077                                  
  6078                                  ; ---------------------------------------------------------------------------
  6079                                  
  6080                                  PRINT_G:
  6081                                  		;mov	al,[RABRACKET]
  6082                                  		; 01/03/2023
  6083 000013DA B03E                    		mov	al,rabracket  ; '>'
  6084 000013DC EB06                    		jmp	short PRINT_CHAR
  6085                                  
  6086                                  ; ---------------------------------------------------------------------------
  6087                                  
  6088                                  PRINT_L:
  6089                                  		;mov	al,[LABRACKET]
  6090                                  		; 01/03/2023
  6091 000013DE B03C                    		mov	al,labracket ; '<'
  6092 000013E0 EB02                    		jmp	short PRINT_CHAR
  6093                                  
  6094                                  ; ---------------------------------------------------------------------------
  6095                                  
  6096                                  PRINT_B:
  6097                                  		;mov	al,[VBAR]
  6098                                  		; 01/03/2023
  6099                                  		;mov	al,vbar
  6100                                  		;mov	al,'|'
  6101 000013E2 B07C                    		mov	al,ALTPIPECHR ; '|'
  6102                                  
  6103                                  ; =============== S U B	R O U T	I N E =======================================
  6104                                  
  6105                                  PRINT_CHAR:
  6106                                  		; MSDOS 6.0
  6107                                  
  6108                                  ;	Bugbug:	Why bother with ds,es here?
  6109                                  		
  6110                                  		;push	es
  6111                                  		;push	ds
  6112                                  		;pop	es
  6113                                  		;push	di
  6114                                  		;push	dx
  6115                                  		;mov	dl,al		;AC000; Get char into al
  6116                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6117                                  		;int	21h		;AC000;
  6118                                  		;pop	dx
  6119                                  		;pop	di
  6120                                  		;pop	es
  6121                                  		;retn
  6122                                  
  6123                                  		; MSDOS 3.3
  6124 000013E4 06                      		push	es
  6125 000013E5 1E                      		push	ds
  6126 000013E6 07                      		pop	es
  6127 000013E7 57                      		push	di
  6128 000013E8 52                      		push	dx
  6129 000013E9 BF[A143]                		mov	di,ONE_CHAR_VAL	
  6130 000013EC AA                      		stosb
  6131 000013ED BA[903A]                		mov	dx,ONECHRVALPTR
  6132 000013F0 E86120                  		call	STD_PRINTF
  6133 000013F3 5A                      		pop	dx
  6134 000013F4 5F                      		pop	di
  6135 000013F5 07                      		pop	es
  6136 000013F6 C3                      		retn
  6137                                  
  6138                                  ; ---------------------------------------------------------------------------
  6139                                  
  6140                                  PRINT_DRIVE:
  6141 000013F7 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6142 000013F9 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6143                                  		;add	al,'A'
  6144                                  		;add	al,[CAPITAL_A]
  6145                                  		; 01/03/2023
  6146 000013FB 0441                    		add	al,capital_A  ; add al,'A'
  6147                                  		;call	PRINT_CHAR
  6148                                  		;retn
  6149                                  		; 01/03/2023
  6150 000013FD EBE5                    		jmp	PRINT_CHAR	
  6151                                  
  6152                                  ; ---------------------------------------------------------------------------
  6153                                  
  6154                                  BUILD_DIR_FOR_PROMPT:
  6155 000013FF 30D2                    		xor	dl,dl
  6156 00001401 BE[AA42]                		mov	si,BWDBUF
  6157 00001404 89F7                    		mov	di,si
  6158 00001406 A0[C541]                		mov	al,[CURDRV]
  6159 00001409 0441                    		add	al,'A'
  6160 0000140B B43A                    		mov	ah,':'
  6161 0000140D AB                      		stosw
  6162 0000140E A0[B641]                		mov	al,[DIRCHAR]
  6163 00001411 AA                      		stosb
  6164 00001412 87F7                    		xchg	si,di
  6165 00001414 893E[8E43]              		mov	[STRING_PTR_2],di
  6166 00001418 B447                    		mov	ah,CURRENT_DIR ; 47h
  6167 0000141A CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6168                                  				; DL = drive (0=default,1=A,etc.)
  6169                                  				; DS:SI	points to 64-byte buffer area
  6170 0000141C BA[9F36]                		mov	dx,STRINGBUF2PTR
  6171 0000141F 7303                    		jnc	short DOPRINT
  6172 00001421 BA[4B39]                		mov	dx,BADCURDRVPTR
  6173                                  DOPRINT:
  6174                                  		;call	STD_PRINTF
  6175                                  		;retn
  6176                                  		; 01/03/2023
  6177 00001424 E92D20                  		jmp	STD_PRINTF
  6178                                  
  6179                                  ; =============== S U B	R O U T	I N E =======================================
  6180                                  
  6181                                  BUILD_DIR_FOR_CHDIR:
  6182 00001427 E80D00                  		call	BUILD_DIR_STRING
  6183 0000142A BA[AA42]                		mov	dx,DIRBUF
  6184 0000142D 8916[8E43]              		mov	[STRING_PTR_2],dx
  6185                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6186 00001431 BA[9F36]                		mov	dx,STRINGBUF2PTR
  6187                                  		;call	STD_PRINTF
  6188                                  		;retn
  6189                                  		; 01/03/2023
  6190 00001434 E91D20                  		jmp	STD_PRINTF
  6191                                  
  6192                                  
  6193                                  ; =============== S U B	R O U T	I N E =======================================
  6194                                  
  6195                                  BUILD_DIR_STRING:
  6196 00001437 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6197 0000143B 88D0                    		mov	al,dl
  6198 0000143D 0440                    		add	al,'@'
  6199 0000143F 3C40                    		cmp	al,'@'
  6200 00001441 7506                    		jnz	short GOTDRIVE
  6201 00001443 0206[C541]              		add	al,[CURDRV]
  6202 00001447 FEC0                    		inc	al
  6203                                  GOTDRIVE:
  6204 00001449 50                      		push	ax
  6205 0000144A BE[AD42]                		mov	si,BWDBUF+3
  6206 0000144D B447                    		mov	ah,CURRENT_DIR ; 47h
  6207 0000144F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6208                                  				; DL = drive (0=default,1=A,etc.)
  6209                                  				; DS:SI	points to 64-byte buffer area
  6210 00001451 7305                    		jnc	short DPBISOK
  6211 00001453 0E                      		push	cs
  6212 00001454 1F                      		pop	ds
  6213 00001455 E95D06                  		jmp	DRVBAD
  6214                                  DPBISOK:
  6215 00001458 BF[AA42]                		mov	di,BWDBUF
  6216 0000145B 89FA                    		mov	dx,di
  6217 0000145D 58                      		pop	ax
  6218 0000145E B43A                    		mov	ah,':'
  6219 00001460 AB                      		stosw
  6220 00001461 A0[B641]                		mov	al,[DIRCHAR]
  6221 00001464 AA                      		stosb
  6222 00001465 C3                      		retn
  6223                                  
  6224                                  ; ---------------------------------------------------------------------------
  6225                                  
  6226                                  PATH:
  6227                                  		; MSDOS 6.0
  6228                                  		;xor	al,al		;AN049; Set up holding buffer
  6229                                  		;mov	di,offset Trangroup:srcxname
  6230                                  					;AN049;   for PATH while parsing
  6231                                  		;stosb				;AN049; Initialize PATH to null
  6232                                  		;dec	di			;AN049; point to the start of buffer
  6233                                  		;invoke	PGetarg 		; Pre scan for arguments
  6234                                  		;jz	disppath		; Print the current path
  6235                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6236                                  		;jnz	pathslp 		;AC049;
  6237                                  		;inc	si			;AN049; point past semicolon
  6238                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6239                                  ;pathslp:					; Get the user specified path
  6240                                  		;lodsb				; Get a character
  6241                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6242                                  		;jz	path_eol		;AC049; yes - end of command
  6243                                  		;invoke	testkanj		;See if DBCS
  6244                                  		;jz	notkanj2		;No - continue
  6245                                  		;stosb				;AC049; Yes - store the first byte
  6246                                  		;lodsb				;skip second byte of DBCS
  6247                                  ;path_hold:					;AN049;
  6248                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6249                                  		;jmp	short pathslp		;continue parsing
  6250                                  ;notkanj2:
  6251                                  		;invoke	upconv			;upper case the character
  6252                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6253                                  		;jz	path_hold		;AC049; go store it
  6254                                  		;invoke	delim			;delimiter?
  6255                                  		;jnz	path_hold		;AC049; no - go store character
  6256                                  ;scan_white:					;AN049; make sure were at EOL
  6257                                  		;lodsb				;AN049; get a character
  6258                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6259                                  		;jz	path_eol		;AN049; yes - go set path
  6260                                  		;cmp	al,blank		;AN049; whitespace?
  6261                                  		;jz	scan_white		;AN049; yes - continue scanning
  6262                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6263                                  		;jz	scan_white		;AN049; yes - continue scanning
  6264                                  
  6265                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6266                                  						;AN049; no - set up error message
  6267                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6268                                  						;AN049; get "Too many parameters" message number
  6269                                  		;mov	msg_disp_class,parse_msg_class
  6270                                  						;AN049; set up parse error msg class
  6271                                  		;jmp	cerror			;AN049;
  6272                                  ;path_eol:					;AN049; Parsing was clean
  6273                                  		;xor	al,al			;AN049; null terminate the PATH
  6274                                  		;stosb				;AN049;    buffer
  6275                                  		;invoke	find_path		;AN049; Find PATH in environment
  6276                                  		;invoke	delete_path		;AC049; Delete any offending name
  6277                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6278                                  		;invoke	move_name		;AC049; move in PATH=
  6279                                  		;mov	si,offset Trangroup:srcxname	
  6280                                  						;AN049; Set up source as PATH buffer
  6281                                  ;store_path:					;AN049; Store the PATH in the environment
  6282                                  		;lodsb				;AN049; Get a character
  6283                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6284                                  		;jz	got_paths		;AN049; yes - exit
  6285                                  		;invoke	store_char		;AN049; no - store character
  6286                                  		;jmp	short store_path	;AN049; continue
  6287                                  ;got_paths:					;AN049; we're finished
  6288                                  		;xor	ax,ax			;	null terminate the PATH in
  6289                                  		;stosw				;    	the environment
  6290                                  		;return
  6291                                  ;disppath:
  6292                                  		;invoke	find_path		;AN049;
  6293                                  		;call	print_path
  6294                                  		;call	crlf2
  6295                                  		;retn
  6296                                  
  6297                                  		; MSDOS 3.3
  6298 00001466 E80903                  		call	FIND_PATH		; Find PATH in environment
  6299 00001469 E84409                  		call	PGETARG			; Pre scan for arguments
  6300 0000146C 742A                    		jz	short DISPPATH		; Print the current path
  6301 0000146E E8DF02                  		call	DELETE_PATH		; Delete any offending name
  6302 00001471 E86B03                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6303 00001474 E84903                  		call	MOVE_NAME		; Move in PATH=
  6304 00001477 E83609                  		call	PGETARG
  6305 0000147A 3C3B                    		cmp	al,';'
  6306 0000147C 7416                    		jz	short GOTPATHS
  6307                                  PATHSLP:
  6308 0000147E AC                      		lodsb
  6309 0000147F 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6310 00001481 7411                    		jz	short GOTPATHS		; yes - exit
  6311                                  		;call	UPCONV
  6312 00001483 E87B03                  		call	UPCONV_MAPCALL		; convert to uppercase
  6313 00001486 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6314 00001488 7405                    		jz	short NOTDELIM		; go set path
  6315 0000148A E8D304                  		call	DELIM			; is it delim/null char ?
  6316 0000148D 7405                    		jz	short GOTPATHS		; yes - exit
  6317                                  NOTDELIM:
  6318 0000148F E87F03                  		call	STORE_CHAR		; no - store character
  6319 00001492 EBEA                    		jmp	short PATHSLP
  6320                                  GOTPATHS:
  6321 00001494 31C0                    		xor	ax,ax			; null terminate the PATH
  6322 00001496 AB                      		stosw				; in the environment
  6323 00001497 C3                      		retn
  6324                                  DISPPATH:
  6325 00001498 E80400                  		call	PRINT_PATH
  6326 0000149B E8AD04                  		call	CRLF2
  6327 0000149E C3                      		retn
  6328                                  
  6329                                  ; =============== S U B	R O U T	I N E =======================================
  6330                                  
  6331                                  PRINT_PATH:
  6332 0000149F 26803D00                		cmp	byte [es:di],0
  6333 000014A3 750A                    		jnz	short PATH1
  6334                                  PATH0:
  6335 000014A5 BA[6B3B]                		mov	dx,NULLPATHPTR
  6336 000014A8 0E                      		push	cs
  6337 000014A9 07                      		pop	es
  6338 000014AA 0E                      		push	cs
  6339 000014AB 1F                      		pop	ds
  6340 000014AC E9A51F                  		jmp	STD_PRINTF
  6341                                  PATH1:
  6342 000014AF 06                      		push	es
  6343 000014B0 1F                      		pop	ds
  6344 000014B1 83EF05                  		sub	di,5
  6345 000014B4 89FE                    		mov	si,di
  6346 000014B6 E84003                  		call	SCASB2		; Look for null
  6347 000014B9 81F9FF00                		cmp	cx,0FFh
  6348 000014BD 74E6                    		jz	short PATH0
  6349 000014BF 0E                      		push	cs
  6350 000014C0 07                      		pop	es
  6351 000014C1 BF[0843]                		mov	di,ARG_BUF
  6352 000014C4 BA0001                  		mov	dx,100h
  6353 000014C7 29CA                    		sub	dx,cx
  6354 000014C9 87D1                    		xchg	dx,cx
  6355 000014CB F3A4                    		rep movsb
  6356 000014CD BA[8336]                		mov	dx,ARG_BUF_PTR
  6357 000014D0 0E                      		push	cs
  6358 000014D1 1F                      		pop	ds
  6359 000014D2 E97F1F                  		jmp	STD_PRINTF
  6360                                  
  6361                                  ; ---------------------------------------------------------------------------
  6362                                  
  6363                                  ; ****************************************************************
  6364                                  ; *
  6365                                  ; * ROUTINE:	 CLS
  6366                                  ; *
  6367                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6368                                  ; *		 installed, send a control string to clear the
  6369                                  ; *		 screen.
  6370                                  ; *
  6371                                  ; * INPUT:	 command line at offset 81H
  6372                                  ; *
  6373                                  ; * OUTPUT:	 none
  6374                                  ; *
  6375                                  ; ****************************************************************
  6376                                  
  6377                                  ; MSDOS 3.3
  6378                                  
  6379                                  CLS:
  6380 000014D5 BB0100                  		mov	bx,STDOUT ; 1
  6381 000014D8 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6382 000014DB CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6383                                  				; BX = file or device handle
  6384 000014DD F6C280                  		test	dl,80h	; devid_ISDEV
  6385 000014E0 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6386 000014E2 F6C210                  		test	dl,10h  ; devid_SPECIAL
  6387 000014E5 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6388                                  
  6389 000014E7 B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6390 000014EA CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6391                                  				; AL = interrupt number
  6392                                  				; Return: ES:BX	= value	of interrupt vector
  6393 000014EC 8CC2                    		mov	dx,es
  6394 000014EE B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6395 000014F1 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6396                                  				; AL = interrupt number
  6397                                  				; Return: ES:BX	= value	of interrupt vector
  6398 000014F3 8CC0                    		mov	ax,es
  6399 000014F5 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6400 000014F7 7735                    		ja	short ANSICLS
  6401                                  
  6402 000014F9 B40F                    		mov	ah,0Fh
  6403 000014FB CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6404                                  				; Return: AH = number of columns on screen
  6405                                  				; AL = current video mode
  6406                                  				; BH = current active display page
  6407 000014FD 3C03                    		cmp	al,3
  6408 000014FF 7609                    		jbe	short DOALPHA
  6409 00001501 3C07                    		cmp	al,7
  6410 00001503 7405                    		jz	short DOALPHA
  6411 00001505 B400                    		mov	ah,0
  6412 00001507 CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6413                                  				; AL = mode
  6414 00001509 C3                      		retn
  6415                                  
  6416                                  DOALPHA:
  6417 0000150A B40B                    		mov	ah,0Bh	; Set overscan to black
  6418 0000150C 31DB                    		xor	bx,bx
  6419 0000150E CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6420                                  				; BH = 00h, BL = border color
  6421                                  				; BH = 01h, BL = palette (0-3)
  6422 00001510 B40F                    		mov	ah,0Fh
  6423 00001512 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6424                                  				; Return: AH = number of columns on screen
  6425                                  				; AL = current video mode
  6426                                  				; BH = current active display page
  6427 00001514 88E2                    		mov	dl,ah
  6428 00001516 FECA                    		dec	dl
  6429 00001518 B618                    		mov	dh,24
  6430 0000151A 31C0                    		xor	ax,ax
  6431 0000151C 89C1                    		mov	cx,ax
  6432 0000151E BB0007                  		mov	bx,700h
  6433 00001521 B406                    		mov	ah,6
  6434 00001523 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6435                                  				; AL = number of lines to scroll window	
  6436                                  				;	(0 = blank whole window)
  6437                                  				; BH = attributes to be	used on	blanked	lines
  6438                                  				; CH,CL	= row,column of	upper left corner of window 
  6439                                  				;	  to scroll
  6440                                  				; DH,DL	= row,column of	lower right corner of window
  6441 00001525 31D2                    		xor	dx,dx
  6442 00001527 B700                    		mov	bh,0
  6443 00001529 B402                    		mov	ah,2
  6444 0000152B CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6445                                  				; DH,DL	= row,column (0,0 = upper left)
  6446                                  				; BH = page number
  6447 0000152D C3                      		retn
  6448                                  
  6449                                  ANSICLS:
  6450 0000152E BE[FA3C]                		mov	si,CLSSTRING
  6451 00001531 AC                      		lodsb
  6452 00001532 88C1                    		mov	cl,al
  6453 00001534 30ED                    		xor	ch,ch
  6454 00001536 B406                    		mov	ah,RAW_CON_IO ; 6
  6455                                  CLRLOOP:
  6456 00001538 AC                      		lodsb
  6457 00001539 88C2                    		mov	dl,al
  6458 0000153B CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6459                                  				; DL = character <> FFh
  6460                                  				;  Return: ZF set = no character
  6461                                  				;   ZF clear = character recieved, AL = character
  6462 0000153D E2F9                    		loop	CLRLOOP
  6463 0000153F C3                      		retn
  6464                                  
  6465                                  ; ---------------------------------------------------------------------------
  6466                                  
  6467                                  ; MSDOS 6.0
  6468                                  
  6469                                  ;ANSI_installed		equ    0ffh
  6470                                  ;
  6471                                  ;CLS:
  6472                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6473                                  ;	mov	al,0			;AN000;
  6474                                  ;	int	2fh			;AN000;
  6475                                  ;	cmp	al,ANSI_installed	;AN000;
  6476                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6477                                  ;
  6478                                  ;check_lines:
  6479                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6480                                  ;					;AN000; get lines per page on display
  6481                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6482                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6483                                  ;	mov	cl,get_generic		;AN000; get information
  6484                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6485                                  ;	int	21h			;AN000;
  6486                                  ;	jc	no_variable		;AN000; function had error, use default
  6487                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6488                                  ;	mov	dh,al			;AN000; set number of rows
  6489                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6490                                  ;	mov	dl,al			;AN000; set number of columns
  6491                                  ;	jmp	short regcls		;AN000; go do cls
  6492                                  ;
  6493                                  ;no_variable:
  6494                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6495                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6496                                  ;	int	21h			;AC000;
  6497                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6498                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6499                                  ;	test	dl,devid_SPECIAL	;AC000;
  6500                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6501                                  ;
  6502                                  ;ansicls:
  6503                                  ;	call	ansi_cls		;AN000; clear the screen
  6504                                  ;	jmp	short cls_ret		;AN000; exit
  6505                                  ;
  6506                                  ;;
  6507                                  ;; Get video mode
  6508                                  ;;
  6509                                  ;
  6510                                  ;cls_normal:				;AC000;
  6511                                  ;
  6512                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6513                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6514                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6515                                  ;	jbe	DoAlpha
  6516                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6517                                  ;	jz	DoAlpha
  6518                                  ;;
  6519                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6520                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6521                                  ;; screen too.
  6522                                  ;;
  6523                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6524                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6525                                  ;	jmp	short cls_ret		;AC000; exit
  6526                                  ;
  6527                                  ;DoAlpha:
  6528                                  ;;
  6529                                  ;; Get video mode and number of columns to scroll
  6530                                  ;;
  6531                                  ;
  6532                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6533                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6534                                  ;;M01   area
  6535                                  ;;M01   Commented out code here is the original
  6536                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6537                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6538                                  ;;M01	mov	dl,ah
  6539                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6540                                  ;
  6541                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6542                                  ;
  6543                                  ;	push	ds
  6544                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6545                                  ;	MOV	DS,AX			;  *			M01
  6546                                  ;	Assume	DS:ROMBIOS_DATA
  6547                                  ;
  6548                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6549                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6550                                  ;	pop	ds			;			M01
  6551                                  ;	Assume	DS:Trangroup
  6552                                  ;
  6553                                  ;	or	dh,dh			; Q:ZERO		M01
  6554                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6555                                  ;
  6556                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6557                                  ;
  6558                                  ;regcls:
  6559                                  ;	inc	dh			; height+1		M018
  6560                                  ;	call	reg_cls 		; go clear the screen
  6561                                  ;
  6562                                  ;cls_ret:
  6563                                  ;	ret				; exit
  6564                                  
  6565                                  ; ---------------------------------------------------------------------------
  6566                                  
  6567                                  ; MSDOS 6.0
  6568                                  
  6569                                  ; ****************************************************************
  6570                                  ; *
  6571                                  ; * ROUTINE:	 REG_CLS
  6572                                  ; *
  6573                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6574                                  ; *
  6575                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6576                                  ; *		 DH = NUMBER OF ROWS
  6577                                  ; *
  6578                                  ; * OUTPUT:	 none
  6579                                  ; *
  6580                                  ; ****************************************************************
  6581                                  
  6582                                  ;reg_cls proc	near
  6583                                  ;
  6584                                  ;;
  6585                                  ;; Set overscan to black.
  6586                                  ;;
  6587                                  ;	dec	dh			;  decrement rows and columns
  6588                                  ;	dec	dl			;     to zero base
  6589                                  ;	push	dx			;  save rows,columns
  6590                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6591                                  ;	xor	bx,bx
  6592                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6593                                  ;	pop	dx			;  retore rows,colums
  6594                                  ;
  6595                                  ;	xor	ax,ax			;  zero out ax
  6596                                  ;	mov	CX,ax			;     an cx
  6597                                  ;;
  6598                                  ;; Scroll active page
  6599                                  ;;
  6600                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6601                                  ;	mov	bh,video_attribute	; attribute for blank line
  6602                                  ;	xor	bl,bl			; set BL to 0
  6603                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6604                                  ;;
  6605                                  ;; Seek to cursor to 0,0
  6606                                  ;;
  6607                                  ;;M022 following two lines added
  6608                                  ;	mov	ah,get_video_state	; get current video page in BH
  6609                                  ;	int	video_io_int
  6610                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6611                                  ;	xor	dx,dx			; row and column 0
  6612                                  ;;M022	mov	bh.0
  6613                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6614                                  ;
  6615                                  ;	ret
  6616                                  ;
  6617                                  ;reg_cls endp
  6618                                  
  6619                                  ; ---------------------------------------------------------------------------
  6620                                  
  6621                                  ; MSDOS 6.0
  6622                                  
  6623                                  ; ****************************************************************
  6624                                  ; *
  6625                                  ; * ROUTINE:	 ANSI_CLS
  6626                                  ; *
  6627                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6628                                  ; *		 to STDOUT.
  6629                                  ; *
  6630                                  ; * INPUT:	 none
  6631                                  ; *
  6632                                  ; * OUTPUT:	 none
  6633                                  ; *
  6634                                  ; ****************************************************************
  6635                                  
  6636                                  ;ansi_cls proc	near			;AC000;
  6637                                  ;
  6638                                  ;	mov	si,offset trangroup:clsstring
  6639                                  ;	lodsb
  6640                                  ;	mov	cl,al
  6641                                  ;	xor	ch,ch
  6642                                  ;	mov	ah,Raw_CON_IO
  6643                                  ;clrloop:
  6644                                  ;	lodsb
  6645                                  ;	mov	DL,al
  6646                                  ;	int	21h
  6647                                  ;	loop	clrloop
  6648                                  ;	return
  6649                                  ;
  6650                                  ;ansi_cls	endp			;AC000;
  6651                                  
  6652                                  ;============================================================================
  6653                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6654                                  ;============================================================================
  6655                                  ; 08/10/2018 - Retro DOS v3.0
  6656                                  
  6657                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6658                                  
  6659                                  ; ---------------------------------------------------------------------------
  6660                                  
  6661                                  ; ****************************************************************
  6662                                  ; *
  6663                                  ; * ROUTINE:	 CTTY - Change console
  6664                                  ; *
  6665                                  ; * SYNTAX:	 CTTY device
  6666                                  ; *
  6667                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6668                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6669                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6670                                  ; *
  6671                                  ; * INPUT:	 command line at offset 81H
  6672                                  ; *
  6673                                  ; * OUTPUT:	 none
  6674                                  ; *
  6675                                  ; ****************************************************************
  6676                                  
  6677                                  CTTY:
  6678                                  		; MSDOS 6.0
  6679                                  		;push	ds			;AN000; Get local ES
  6680                                  		;pop	es			;AN000;
  6681                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6682                                  
  6683                                  		;mov	di,offset trangroup:parse_ctty	
  6684                                  						;AC000; Get address of PARSE_CTTY
  6685                                  		;xor	cx,cx			;AC000; clear cx,dx
  6686                                  		;xor	dx,dx			;AC000;
  6687                                  		;invoke	cmd_parse		;AC000; call parser
  6688                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6689                                  		;jz	ctty_error		;AN000; yes - error
  6690                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6691                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6692                                  
  6693                                  		;push	si			;AN000; save position in line
  6694                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6695                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6696                                  
  6697                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6698                                  		;lodsb				;AN000; get a char from buffer
  6699                                  		;stosb				;AN000; store in srcbuf
  6700                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6701                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6702                                  		;pop	si			;AN000; get line position back
  6703                                  		;mov	di,offset trangroup:parse_ctty	
  6704                                  						;AC000; Get address of PARSE_CTTY
  6705                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6706                                  		;jz	nocolon 		;AN000; yes - continue
  6707                                  
  6708                                  ;ctty_error:
  6709                                  		;jmp	short isbaddev		;AC000; yes - exit
  6710                                  
  6711                                  		; MSDOS 3.3
  6712 00001540 E8FB07                  		call	SETPATH
  6713 00001543 4E                      		dec	si
  6714 00001544 4E                      		dec	si
  6715 00001545 803C3A                  		cmp	byte [si],':'
  6716 00001548 7503                    		jnz	short NOCOLON
  6717 0000154A C60400                  		mov	byte [si],0
  6718                                  NOCOLON:
  6719                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6720                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6721 0000154D B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6722 00001550 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6723                                  				; DS:DX	-> ASCIZ filename
  6724                                  				; AL = access mode
  6725                                  				; 2 - read & write
  6726 00001552 7210                    		jc	short ISBADDEV
  6727 00001554 89C3                    			mov	bx,ax
  6728 00001556 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6729 00001559 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6730                                  				; BX = file or device handle
  6731 0000155B F6C280                  		test	dl,80h
  6732 0000155E 750C                    		jnz	short DEVISOK
  6733                                  CLOSEDEV:
  6734 00001560 B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6735 00001562 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6736                                  				; BX = file handle
  6737                                  ISBADDEV:
  6738 00001564 BA[B33B]                		mov	dx,BADDEVPTR
  6739 00001567 E8EA1E                  		call	STD_PRINTF
  6740 0000156A EB28                    		jmp	short RESRET
  6741                                  
  6742                                  		;nop
  6743                                  DEVISOK:
  6744                                  		; MSDOS 6.0
  6745                                  		;push	dx		;AN007; save device info
  6746                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6747                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6748                                  		;push	bx		;AN021; save handle
  6749                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6750                                  		;mov	dx,si		;AN021; get address into dx
  6751                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6752                                  		;mov	cx,2		;AN007; write two bytes
  6753                                  		;int	21h		;AN007;
  6754                                  		;pop	bx		;AN021; get back handle
  6755                                  		;pop	dx		;AN007; get back device info
  6756                                  		;jc	closedev	;AN007; if error, quit
  6757                                  
  6758                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6759 0000156C 30F6                    		xor	dh,dh
  6760 0000156E 80CA03                  		or	dl,3
  6761                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6762 00001571 B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6763 00001574 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6764                                  				; BX = device handle,DH = 0
  6765                                  				; DL = device information to set 
  6766                                  				;		(bits 0-7 from	function 0)
  6767 00001576 53                      		push	bx
  6768 00001577 B90300                  		mov	cx,3
  6769 0000157A 31DB                    		xor	bx,bx
  6770                                  
  6771                                  ICLLOOP:				; Close basic handles
  6772 0000157C B43E                    		mov	ah,CLOSE ; 3Eh
  6773 0000157E CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6774                                  				; BX = file handle
  6775 00001580 43                      		inc	bx
  6776 00001581 E2F9                    		loop	ICLLOOP
  6777 00001583 5B                      		pop	bx		; Get handle
  6778 00001584 B445                    		mov	ah,XDUP ; 45h
  6779 00001586 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6780                                  				; BX = file handle to duplicate
  6781 00001588 B445                    		mov	ah,XDUP ; 45h
  6782 0000158A CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6783                                  				; BX = file handle to duplicate
  6784 0000158C B445                    		mov	ah,XDUP ;45h
  6785 0000158E CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6786                                  				; BX = file handle to duplicate
  6787 00001590 B43E                    		mov	ah,CLOSE ; 3Eh
  6788 00001592 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6789                                  				; BX = file handle
  6790                                  RESRET:
  6791 00001594 8E1E[B141]              		mov	ds,[RESSEG]
  6792 00001598 1E                      		push	ds
  6793 00001599 A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6794 0000159C A3F10B                  		mov	[IO_SAVE],ax
  6795                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6796                                  		;mov	ax,31Eh ;  MSDOS 3.3
  6797 0000159F B81903                  		mov	ax,LODCOM1
  6798 000015A2 50                      		push	ax
  6799                                  
  6800 000015A3 CB                      		retf		; Far return
  6801                                  
  6802                                  ; ---------------------------------------------------------------------------
  6803                                  
  6804                                  ;****************************************************************
  6805                                  ;*
  6806                                  ;* ROUTINE:	CHCP - Change code page internal command
  6807                                  ;*		(added DOS 3.30 07/21/86)
  6808                                  ;*
  6809                                  ;* SYNTAX:	CHCP [xxx]
  6810                                  ;*		where xxx is a valid code page
  6811                                  ;*
  6812                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6813                                  ;*		6402H to set the code page to xxxx. If no parameters
  6814                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6815                                  ;*		to get global code page and display it to the user.
  6816                                  ;*
  6817                                  ;* INPUT:	command line at offset 81H
  6818                                  ;*
  6819                                  ;* OUTPUT:	none
  6820                                  ;*
  6821                                  ;****************************************************************
  6822                                  
  6823                                  ;NLSFUNC_installed equ  0FFh
  6824                                  set_global_cp	equ   2
  6825                                  get_global_cp	equ   1
  6826                                  
  6827                                  CHCP:
  6828                                  		; MSDOS 6.0
  6829                                  		;push	ds		;AN000; Get local ES
  6830                                  		;pop	es		;AN000;
  6831                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6832                                  
  6833                                  		;mov	di,offset trangroup:parse_chcp	
  6834                                  					;AN000; Get address of PARSE_CHCP
  6835                                  		;xor	cx,cx		;AC000; clear cx,dx
  6836                                  		;xor	dx,dx		;AC000;
  6837                                  		;call	parse_with_msg	;AC018; call parser
  6838                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6839                                  
  6840                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6841                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6842                                  ;setcp:
  6843                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6844                                  		;jne	cp_error	;AC018; yes - go issue message
  6845                                  
  6846                                  		;push	cx		;AN000; save positional count
  6847                                  		;mov	bx,offset trangroup:parse1_addr 
  6848                                  					;AN000; get number returned
  6849                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6850                                  		;mov	system_cpage,cx ;AN000; save user input number
  6851                                  		;pop	cx		;AC000; restore positional count
  6852                                  		;mov	di,offset trangroup:parse_chcp	
  6853                                  					;AN000; Get address of PARSE_CHCP
  6854                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6855                                  		;jnz	cp_error	;AC000; no - exit
  6856                                  ;okset:
  6857                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6858                                  		;mov	al,0		;AN000;
  6859                                  		;int	2fh		;AN000;
  6860                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6861                                  		;jz	got_NLS 	;AN000; Yes - continue
  6862                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6863                                  					;AN000; no - set up error message
  6864                                  		;jmp	short cp_error	;AN000; error exit
  6865                                  ;got_NLS:
  6866                                  
  6867                                  		; MSDOS 3.3
  6868 000015A4 BE8100                  		mov	si,81h
  6869 000015A7 E8AE03                  		call	SCANOFF
  6870 000015AA 3C0D                    		cmp	al,0Dh ; CR
  6871 000015AC 7502                    		jnz	short SETCP
  6872 000015AE EB72                    		jmp	short GETCP
  6873                                  
  6874                                  		;nop
  6875                                  SETCP:
  6876 000015B0 31DB                    		xor	bx,bx
  6877 000015B2 89D9                    		mov	cx,bx
  6878 000015B4 89D8                    		mov	ax,bx
  6879                                  GET_CP_DIGIT:
  6880 000015B6 AC                      		lodsb
  6881 000015B7 3C30                    		cmp	al,'0'
  6882 000015B9 721C                    		jb	short CHRNOTNUMBER
  6883 000015BB 3C39                    		cmp	al,'9'
  6884 000015BD 7718                    		ja	short CHRNOTNUMBER
  6885 000015BF 2C30                    		sub	al,'0'
  6886 000015C1 FEC1                    		inc	cl
  6887 000015C3 80F904                  		cmp	cl,4
  6888 000015C6 771B                    		ja	short CHCP_BADPARM
  6889 000015C8 89DA                    		mov	dx,bx
  6890 000015CA D1E2                    		shl	dx,1
  6891 000015CC D1E2                    		shl	dx,1
  6892 000015CE 01D3                    		add	bx,dx
  6893 000015D0 D1E3                    		shl	bx,1
  6894 000015D2 01C3                    		add	bx,ax
  6895 000015D4 EBE0                    		jmp	short GET_CP_DIGIT
  6896                                  CP_NEXTCHR:
  6897 000015D6 AC                      		lodsb
  6898                                  CHRNOTNUMBER:
  6899 000015D7 3C20                    		cmp	al,' '		; SPACE
  6900 000015D9 74FB                    		jz	short CP_NEXTCHR
  6901 000015DB 3C09                    		cmp	al,9		; TAB
  6902 000015DD 74F7                    		jz	short CP_NEXTCHR
  6903 000015DF 3C0D                    		cmp	al,0Dh		; CR
  6904 000015E1 7406                    		jz	short SET_CP_TBL_NUM
  6905                                  CHCP_BADPARM:
  6906 000015E3 BA[8239]                		mov	dx,BADPARMPTR
  6907 000015E6 E91706                  		jmp	CERROR
  6908                                  ;GOT_NLS:
  6909                                  SET_CP_TBL_NUM:
  6910                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6911 000015E9 891E[503E]              		mov	[SYSTEM_CPAGE],bx
  6912 000015ED B466                    		mov	ah,GETSETCDPG  ; 66h
  6913 000015EF B002                    		mov	al,set_global_cp ; 2
  6914 000015F1 CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6915                                  				; BX = active code page
  6916                                  				; DX = system code page	(active	page at	boot time)
  6917 000015F3 733D                    		jnc	short CHCP_RETURN
  6918                                  
  6919 000015F5 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6920 000015F8 7511                    		jnz	short CHCP_OTHER_ERROR
  6921                                  
  6922 000015FA B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6923 000015FC 31DB                    		xor	bx,bx
  6924 000015FE CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6925                                  				; BX = version code (0000h for DOS 3.x)
  6926 00001600 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6927 00001603 7417                    		jz	short NONE_SET
  6928 00001605 BA[5837]                		mov	dx,FNOTFOUNDPTR
  6929 00001608 E9F505                  		jmp	CERROR
  6930                                  CHCP_OTHER_ERROR:			; end of p716
  6931 0000160B B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6932 0000160D 31DB                    		xor	bx,bx
  6933 0000160F CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6934                                  				; BX = version code (0000h for DOS 3.x)
  6935 00001611 83F841                  		cmp	ax,65		;was it access denied?
  6936 00001614 7506                    		jnz	short NONE_SET	;no - assume all failed
  6937 00001616 BA[0839]                		mov	dx,CPNOTALLPTR	;set up message
  6938 00001619 E9E405                  		jmp	CERROR		;AC000; error exit
  6939                                  NONE_SET:
  6940 0000161C BA[D538]                		mov	dx,CPNOTSETPTR	;set up message
  6941                                  CP_ERROR:
  6942 0000161F E9DE05                  		jmp	CERROR		;exit
  6943                                  GETCP:
  6944 00001622 B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6945 00001624 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6946 00001626 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6947 00001628 891E[503E]              		mov	[SYSTEM_CPAGE],bx ;get active cp for output
  6948 0000162C BA[2639]                		mov	dx,CPACTIVEPTR
  6949 0000162F E8221E                  		call	STD_PRINTF	;print it out
  6950                                  CHCP_RETURN:
  6951 00001632 C3                      		retn
  6952                                  
  6953                                  ; ---------------------------------------------------------------------------
  6954                                  
  6955                                  ; ****************************************************************
  6956                                  ; *
  6957                                  ; * ROUTINE:	 TRUENAME
  6958                                  ; *
  6959                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  6960                                  ; *		 Parses the command line. If a path is found, set
  6961                                  ; *		 SRCXNAME to path.  If only a drive letter is
  6962                                  ; *		 found, set SRCXNAME to the drive letter.  If
  6963                                  ; *		 no path is found, set the path of SRCXNAME to
  6964                                  ; *		 dot (.) for current directory.  Use the NAME
  6965                                  ; *		 TRANSLATE system call to get the real name and
  6966                                  ; *		 then display the real name.  If an error occurs
  6967                                  ; *		 issue an error message and transfer control to
  6968                                  ; *		 CERROR.
  6969                                  ; *
  6970                                  ; * INPUT:	 command line at offset 81H
  6971                                  ; *
  6972                                  ; * OUTPUT:	 none
  6973                                  ; *
  6974                                  ; ****************************************************************
  6975                                  
  6976                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  6977                                  ;
  6978                                  ;TRUENAME:					;AN000; TRUENAME entry point
  6979                                  ;	push	ds				;AN000; Get local ES
  6980                                  ;	pop	es				;AN000;
  6981                                  ;	mov	si,81H				;AN000; Get command line
  6982                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get address of PARSE_CHDIR
  6983                                  ;	xor	cx,cx				;AN000; clear cx,dx
  6984                                  ;	xor	dx,dx				;AN000;
  6985                                  ;	call	parse_with_msg			;AC018; call parser
  6986                                  ;
  6987                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  6988                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  6989                                  ;	je	tn_eol				;AN000; yes - go process
  6990                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  6991                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  6992                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  6993                                  ;	je	tn_drive			;AN000; yes - go process
  6994                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  6995                                  ;
  6996                                  ;tn_eol: 					;AN000; no parameters on line
  6997                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  6998                                  ;	mov	al,dot_chr			;AN000;     for current dir
  6999                                  ;	stosw					;AN000; store in srcxname
  7000                                  ;	jmp	short tn_doit			;AN000; go do command
  7001                                  ;
  7002                                  ;tn_drive:					;AN000; a drive was entered
  7003                                  ;	push	si				;AN000; save position in line
  7004                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  7005                                  ;	lodsb					;AN000; get the drive number
  7006                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  7007                                  ;	stosb					;AN000; store it in srcxname
  7008                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  7009                                  ;	stosw					;AN000;    store in srcxname
  7010                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  7011                                  ;	stosb					;AN000;
  7012                                  ;	pop	si				;AN000; get line position back
  7013                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  7014                                  ;
  7015                                  ;tn_filespec:					;AN000; a filespec was entered
  7016                                  ;	push	si				;AN000; save position in line
  7017                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  7018                                  ;
  7019                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  7020                                  ;	lodsb					;AN000; get a char from buffer
  7021                                  ;	stosb					;AN000; store in srcxname
  7022                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  7023                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  7024                                  ;	pop	si				;AN000; get line position back
  7025                                  ;
  7026                                  ;tn_check_eol:					;AN000; make sure no extra parms
  7027                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  7028                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  7029                                  ;	je	tn_doit 			;AN000; Yes - do the command
  7030                                  ;
  7031                                  ;tn_parse_error: 				;AN000; A parse error occurred
  7032                                  ;	jmp	cerror				;AN000; Go to error routine
  7033                                  ;
  7034                                  ;tn_doit:					;AN000;
  7035                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  7036                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  7037                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  7038                                  ;	int	21h			;AN000;
  7039                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  7040                                  ;
  7041                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  7042                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  7043                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  7044                                  ;	jmp	cerror				;AN000; Go to error routine
  7045                                  ;
  7046                                  ;tn_print_xname: 				;AN000;
  7047                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  7048                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  7049                                  ;	invoke	crlf2				;AN000; print a crlf
  7050                                  ;	invoke	printf_crlf			;AN000; print it out
  7051                                  ;
  7052                                  ;	ret					;AN000;
  7053                                  ;
  7054                                  
  7055                                  ; ---------------------------------------------------------------------------
  7056                                  
  7057                                  _$EXIT:
  7058                                  		; MSDOS 3.3
  7059 00001633 8E06[B141]              		mov	es,[RESSEG]
  7060 00001637 26A18E0B                		mov	ax,[es:PARENT]
  7061                                  		;mov	[es:16h],ax
  7062 0000163B 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7063 0000163F 26A1900B                		mov	ax,[es:OLDTERM]
  7064                                  		;mov	[es:0Ah],ax
  7065 00001643 26A30A00                		mov	[es:PDB.EXIT],ax
  7066 00001647 26A1920B                		mov	ax,[es:OLDTERM+2]
  7067                                  		;mov	[es:0Ch],ax
  7068 0000164B 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7069 0000164F 06                      		push	es
  7070 00001650 8E06[C141]              		mov	es,[TRAN_TPA]
  7071 00001654 B449                    		mov	ah,DEALLOC ; 49h
  7072 00001656 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7073                                  				; ES = segment address of area to be freed
  7074 00001658 07                      		pop	es
  7075 00001659 B44C                    		mov	ah,EXIT ; 4Ch
  7076                                  		;mov	al,[0BEAh] ; MSDOS 3.3 COMMAND.cOm offset 168Ah
  7077 0000165B 26A0EC0B                		mov	al,[es:RETCODE]
  7078 0000165F CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7079                                  
  7080                                  ;;here:
  7081                                  ;;		jmp	short here
  7082                                  
  7083                                  		; MSDOS 6.0
  7084                                  		;push	ds			;AN000; save data segment
  7085                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7086                                  
  7087                                  		;assume	ds:resgroup		;AN000;
  7088                                  
  7089                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7090                                  		;jz	free_com		;AN045; no - free everything
  7091                                  
  7092                                  ;	We're a permanent command.
  7093                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7094                                  
  7095                                  		;cmp	[singlecom],-1		;M034
  7096                                  		;je	no_reset		;M034	;exit singlecom
  7097                                  
  7098                                  		;jmp	TCommand		;permanent command, recycle
  7099                                  
  7100                                  ;free_com:
  7101                                  		;mov	ax,(multdos shl 8 or message_2f)
  7102                                  						;AN060; reset parse message pointers
  7103                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7104                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7105                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7106                                  		;int	2fh			;AN000; go set it
  7107                                  ;no_reset:					;AN045;
  7108                                  		;pop	ds			;AN000; restore local data segment
  7109                                  
  7110                                  		;assume	ds:trangroup		;AN000;
  7111                                  ;
  7112                                  ;M040
  7113                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7114                                  ;this, restores user dir if flag is set and resets the flag.
  7115                                  ;
  7116                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7117                                  		;MOV	ES,[RESSEG]
  7118                                  
  7119                                  		;assume	es:resgroup
  7120                                  
  7121                                  		;MOV	AX,[PARENT]
  7122                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7123                                  		;MOV	AX,WORD PTR OldTerm
  7124                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7125                                  		;MOV	AX,WORD PTR OldTerm+2
  7126                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7127                                  
  7128                                  		;PUSH	ES
  7129                                  		;MOV	ES,[TRAN_TPA]
  7130                                  		;MOV	AH,DEALLOC
  7131                                  		;INT	21h			; Now running in "free" space
  7132                                  		;POP	ES
  7133                                  
  7134                                  		;MOV	AH,Exit
  7135                                  		;MOV	AL,BYTE PTR RetCode
  7136                                  		;INT	21h
  7137                                  
  7138                                  ; ---------------------------------------------------------------------------
  7139                                  
  7140                                  ; MSDOS 6.0
  7141                                  ; ****************************************************************
  7142                                  ; *
  7143                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7144                                  ; *
  7145                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7146                                  ; *		 If not end of line, set up to print parse
  7147                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7148                                  ; *		 EXPECTED!
  7149                                  ; *
  7150                                  ; * INPUT:	 DS:SI	  last output from parser
  7151                                  ; *		 ES:DI	  points to parse block
  7152                                  ; *		 CX	  last output from parser
  7153                                  ; *
  7154                                  ; * OUTPUT:	 AX	  parser return code
  7155                                  ; *
  7156                                  ; *		 if end of line found
  7157                                  ; *		     zero flag set
  7158                                  ; *		 else
  7159                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7160                                  ; *
  7161                                  ; ****************************************************************
  7162                                  
  7163                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7164                                  ;
  7165                                  ;parse_check_eol Proc near			;AN000;
  7166                                  ;
  7167                                  ;	xor	dx,dx				;AN000;
  7168                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7169                                  ;	invoke	cmd_parse			;AN000; call parser
  7170                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7171                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7172                                  ;
  7173                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7174                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7175                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7176                                  ;
  7177                                  ;ok_to_setup_pmsg:
  7178                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7179                                  ;
  7180                                  ;parse_good_eol:
  7181                                  ;	ret					;AN000;
  7182                                  ;
  7183                                  ;parse_check_eol endp				;AN000;
  7184                                  
  7185                                  ; ---------------------------------------------------------------------------
  7186                                  
  7187                                  ; MSDOS 6.0
  7188                                  ; ****************************************************************
  7189                                  ; *
  7190                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7191                                  ; *
  7192                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7193                                  ; *		 message is set up.
  7194                                  ; *
  7195                                  ; * INPUT:	 DS:SI	  last output from parser
  7196                                  ; *		 ES:DI	  points to parse block
  7197                                  ; *		 CX	  last output from parser
  7198                                  ; *
  7199                                  ; * OUTPUT:	 AX	  parser return code
  7200                                  ; *
  7201                                  ; *		 if no error
  7202                                  ; *		     outputs from parser
  7203                                  ; *		 else
  7204                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7205                                  ; *		     error message set up for STD_PRINTF
  7206                                  ; *
  7207                                  ; ****************************************************************
  7208                                  
  7209                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7210                                  ;
  7211                                  ;parse_with_msg	Proc near			;AN018;
  7212                                  ;
  7213                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7214                                  ;	invoke	cmd_parse			;AN018; call parser
  7215                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7216                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7217                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7218                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7219                                  ;
  7220                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7221                                  ;
  7222                                  ;parse_msg_good:
  7223                                  ;	ret					;AN018;
  7224                                  ;
  7225                                  ;parse_with_msg endp				;AN018;
  7226                                  
  7227                                  ; ---------------------------------------------------------------------------
  7228                                  
  7229                                  ; MSDOS 6.0
  7230                                  ; ****************************************************************
  7231                                  ; *
  7232                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7233                                  ; *
  7234                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7235                                  ; *		 message is set up.
  7236                                  ; *
  7237                                  ; * INPUT:	 AX	     Parse error number
  7238                                  ; *		 SI	     Set to past last parameter
  7239                                  ; *		 Parse_last  Set to start of last parameter
  7240                                  ; *
  7241                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7242                                  ; *		 error message set up for STD_PRINTF
  7243                                  ; *
  7244                                  ; ****************************************************************
  7245                                  
  7246                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7247                                  ;
  7248                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7249                                  ;
  7250                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7251                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7252                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7253                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7254                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7255                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7256                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7257                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7258                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7259                                  ;
  7260                                  ;setup_parse_msg_ret:
  7261                                  ;	inc	si				;AN018; make sure zero flag not set
  7262                                  ;
  7263                                  ;	ret					;AC018;
  7264                                  ;
  7265                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7266                                  
  7267                                  ;============================================================================
  7268                                  ; TENV.ASM, MSDOS 6.0, 1991
  7269                                  ;============================================================================
  7270                                  ; 08/10/2018 - Retro DOS v3.0
  7271                                  
  7272                                  ; TITLE	Part6 COMMAND Transient routines.
  7273                                  
  7274                                  ;	Environment utilities and misc. routines
  7275                                  
  7276                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7277                                  
  7278                                  ; ---------------------------------------------------------------------------
  7279                                  
  7280                                  ADD_PROMPT:
  7281 00001661 E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7282 00001664 E87801                  		call	SCAN_DOUBLE_NULL
  7283                                  
  7284                                  ADD_PROMPT2:
  7285 00001667 56                      		push	si
  7286 00001668 E86601                  		call	GETARG
  7287 0000166B 5E                      		pop	si
  7288 0000166C 7501                    		jnz	short ADD_PROMPT3
  7289                                  ADD_PROMPT_RETN:
  7290 0000166E C3                      		retn
  7291                                  ADD_PROMPT3:				; Pre scan for arguments
  7292 0000166F E84E01                  		call	MOVE_NAME	 ;Move in name
  7293 00001672 E85C01                  		call	GETARG
  7294 00001675 56                      		push	si
  7295 00001676 EB4F                    		jmp	short ADD_NAME
  7296                                  
  7297                                  ;break	The SET command
  7298                                  
  7299                                  ; Input: DS:SI points to a CR terminated string
  7300                                  ; Output: carry flag is set if no room
  7301                                  ;	  otherwise name is added to environment
  7302                                  
  7303                                  DISP_ENVJ:
  7304 00001678 E9B100                  		jmp	DISP_ENV
  7305                                  
  7306                                  ADD_NAME_TO_ENVIRONMENT:
  7307 0000167B E85301                  		call	GETARG
  7308 0000167E 74F8                    		jz	short DISP_ENVJ
  7309                                  
  7310                                  ; check if line contains exactly one equals sign
  7311                                  
  7312 00001680 31DB                    		xor	bx,bx		; = count is 0
  7313 00001682 56                      		push	si		; Save pointer to beginning of line
  7314                                  EQLP:
  7315 00001683 AC                      		lodsb			; Get a char
  7316 00001684 3C0D                    		cmp	al,13		; IF CR we're all done
  7317 00001686 740F                    		jz	short QUEQ	
  7318 00001688 3C3D                    		cmp	al,'='		; Look for = sign	
  7319 0000168A 75F7                    		jnz	short EQLP	; not there, get next char
  7320 0000168C FEC3                    		inc	bl		; Otherwise increment EQ count
  7321 0000168E 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7322 00001691 75F0                    		jnz	short EQLP
  7323 00001693 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7324 00001695 EBEC                    		jmp	short EQLP	; And look for more
  7325                                  QUEQ:
  7326 00001697 5E                      		pop	si		; Restore beginning of line
  7327 00001698 FECB                    		dec	bl		; Zero flag means only one EQ
  7328 0000169A 7406                    		jz	short ONEQ	; Good line
  7329 0000169C BA[D83B]                		mov	dx,SYNTMESPTR
  7330 0000169F E95E05                  		jmp	CERROR
  7331                                  ONEQ:
  7332 000016A2 53                      		push	bx
  7333 000016A3 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7334 000016A6 5B                      		pop	bx
  7335 000016A7 FECF                    		dec	bh
  7336 000016A9 74C3                    		jz	short ADD_PROMPT_RETN
  7337 000016AB E83101                  		call	SCAN_DOUBLE_NULL
  7338 000016AE 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7339 000016B0 E80D01                  		call	MOVE_NAME
  7340 000016B3 56                      		push	si
  7341 000016B4 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7342                                  					;  env var name
  7343                                  		
  7344                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7345                                  ; necessary in the resident for re-reading the transient. Let's look for
  7346                                  ; COMSPEC=
  7347                                  
  7348                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7349 000016B6 BE[793B]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7350 000016B9 B90400                  		mov	cx,4
  7351 000016BC F3A7                    		repe cmpsw
  7352 000016BE 7505                    		jnz	short NOT_COMSPEC
  7353                                  					; Zero set => exact match
  7354                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7355 000016C0 C606[E844]01            		mov	byte [COMSPEC_FLAG],1
  7356                                  NOT_COMSPEC:
  7357 000016C5 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7358                                  ADD_NAME:
  7359 000016C7 5E                      		pop	si		; Add the value of the new env var
  7360 000016C8 56                      		push	si		;  to the environment.
  7361                                  ADD_NAME1:
  7362 000016C9 AC                      		lodsb
  7363 000016CA 3C0D                    		cmp	al,13
  7364 000016CC 7405                    		jz	short ADD_NAME_RET
  7365 000016CE E84001                  		call	STORE_CHAR
  7366 000016D1 EBF6                    		jmp	short ADD_NAME1
  7367                                  ADD_NAME_RET:
  7368 000016D3 5E                      		pop	si
  7369 000016D4 803E[E844]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7370                                  ADD_NAME_JZ_RET:
  7371 000016D9 7493                    		jz	short ADD_PROMPT_RETN 
  7372                                  					;  copy the value into the
  7373                                  					;  comspec var in the resident
  7374                                  
  7375                                  ; We have changed the COMSPEC variable. We need to update the resident
  7376                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7377                                  
  7378 000016DB E87A02                  		call	SCANOFF
  7379 000016DE 8E06[B141]              		mov	es,[RESSEG]	;  comspec var in the resident
  7380                                  
  7381                                  ; Make sure that the printer knows where the beginning of the string is
  7382                                  
  7383 000016E2 BF9B0B                  		mov	di,COMSPEC
  7384 000016E5 89FB                    		mov	bx,di
  7385                                  
  7386                                  ; Generate drive letter for display
  7387                                  
  7388 000016E7 31C0                    		xor	ax,ax		;g assume no drive first
  7389 000016E9 26A2E60B                		mov	[es:COMDRV],al ;g
  7390 000016ED 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7391 000016F1 7512                    		jnz	short _GOTDRIVE
  7392 000016F3 8A04                    		mov	al,[si]		; get his specified drive
  7393                                  		;call	UPCONV
  7394 000016F5 E80901                  		call	UPCONV_MAPCALL	; convert to uppercase
  7395 000016F8 2C41                    		sub	al,'A'		; convert to 0-based
  7396 000016FA 83C702                  		add	di,2
  7397 000016FD FEC0                    		inc	al		; convert to 1-based number
  7398 000016FF 26A2E60B                		mov	[es:COMDRV],al
  7399                                  
  7400                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7401                                  ; done here..
  7402                                  		;add	al,40h
  7403 00001703 0440                    		add	al,'A'-1
  7404                                  _GOTDRIVE:
  7405                                  		;mov	[es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7406 00001705 26893EDB0B              		mov	[es:PUTBACKSUBSTPTR],di
  7407                                  					;g point to beginning of name after drive
  7408                                  		;mov	[es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7409 0000170A 26A2230A                		mov	[es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7410                                  
  7411                                  ; Copy chars until delim      	
  7412                                  
  7413 0000170E 89DF                    		mov	di,bx
  7414                                  COPY_COMSPEC:
  7415 00001710 AC                      		lodsb
  7416 00001711 E84C02                  		call	DELIM
  7417 00001714 7407                    		jz	short COPYDONE
  7418 00001716 3C0D                    		cmp	al,13
  7419 00001718 7403                    		jz	short COPYDONE
  7420 0000171A AA                      		stosb
  7421 0000171B EBF3                    		jmp	short COPY_COMSPEC
  7422                                  COPYDONE:
  7423 0000171D 30C0                    		xor	al,al		; Null terminate the string and quit
  7424 0000171F AA                      		stosb
  7425 00001720 C606[E844]00            		mov	byte [COMSPEC_FLAG],0
  7426 00001725 4F                      		dec	di
  7427 00001726 26893EDD0B              		mov	[es:COMSPEC_END],di
  7428 0000172B C3                      		retn
  7429                                  DISP_ENV:
  7430 0000172C 8E1E[B141]              		mov	ds,[RESSEG]
  7431 00001730 8E1E050D                		mov	ds,[ENVIRSEG]
  7432                                  		; assume ds:nothing
  7433 00001734 31F6                    		xor	si,si
  7434                                  PENVLP:
  7435 00001736 803C00                  		cmp	byte [si],0
  7436 00001739 749E                    		jz	short ADD_NAME_JZ_RET
  7437 0000173B BF[0843]                		mov	di,ARG_BUF
  7438                                  PENVLP2:
  7439 0000173E AC                      		lodsb
  7440 0000173F AA                      		stosb
  7441 00001740 08C0                    		or	al,al
  7442 00001742 75FA                    		jnz	short PENVLP2
  7443 00001744 BA[8336]                		mov	dx,ARG_BUF_PTR
  7444 00001747 1E                      		push	ds
  7445 00001748 06                      		push	es
  7446 00001749 1F                      		pop	ds
  7447                                  		; assume ds:nothing
  7448 0000174A E8F71C                  		call	PRINTF_CRLF
  7449 0000174D 1F                      		pop	ds
  7450 0000174E EBE6                    		jmp	short PENVLP
  7451                                  
  7452                                  ; =============== S U B	R O U T	I N E =======================================
  7453                                  
  7454                                  DELETE_PATH:
  7455 00001750 BE[6D3B]                		mov	si,PATH_TEXT ; "PATH="
  7456 00001753 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7457                                  
  7458                                  ; =============== S U B	R O U T	I N E =======================================
  7459                                  
  7460                                  DELETE_PROMPT:
  7461 00001755 BE[723B]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7462                                  
  7463                                  ; ---------------------------------------------------------------------------
  7464                                  
  7465                                  DELETE_NAME_IN_ENVIRONMENT:
  7466                                  
  7467                                  ; Input: DS:SI points to a "=" terminated string
  7468                                  ; Output: carry flag is set if name not found
  7469                                  ;	  otherwise name is deleted
  7470                                  
  7471 00001758 56                      		push	si
  7472 00001759 1E                      		push	ds
  7473 0000175A E82400                  		call	FIND		; ES:DI points to name
  7474 0000175D 7210                    		jc	short DEL1
  7475 0000175F 89FE                    		mov	si,di		; Save it
  7476 00001761 E89500                  		call	SCASB2		; Scan for the nul
  7477 00001764 87F7                    		xchg	si,di
  7478                                  ;SR;
  7479                                  ; If we have only one env string, then the double null is lost when the last
  7480                                  ;string is deleted and we have an invalid empty environment with only a 
  7481                                  ;single null. To avoid this, we will look for the double null case and then
  7482                                  ;move an extra null char.
  7483                                  ; Bugbug: The only possible problem is that the last pathstring 
  7484                                  ;will be followed by a triple null. Is this really a problem?
  7485                                  
  7486                                  		; MSDOS 6.0
  7487                                  		;cmp	byte ptr es:[si],0 ;null char?
  7488                                  		;jnz	not_dnull	   ;no, we are at a double null
  7489                                  		;dec	si		   ;point at the double null
  7490                                  ;not_dnull:
  7491                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7492 00001766 E8F000                  		call	GETENVSIZ
  7493 00001769 29F1                    		sub	cx,si
  7494 0000176B 06                      		push	es
  7495 0000176C 1F                      		pop	ds		; ES:DI points to name
  7496                                  					; DS:SI points to next name
  7497 0000176D F3A4                    		rep movsb
  7498                                  DEL1:
  7499 0000176F 1F                      		pop	ds
  7500 00001770 5E                      		pop	si
  7501                                  FIND_RETN:
  7502 00001771 C3                      		retn
  7503                                  
  7504                                  ; =============== S U B	R O U T	I N E =======================================
  7505                                  
  7506                                  FIND_PATH:
  7507 00001772 BE[6D3B]                		mov	si,PATH_TEXT ; "PATH="
  7508 00001775 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7509                                  
  7510                                  
  7511                                  ; =============== S U B	R O U T	I N E =======================================
  7512                                  
  7513                                  FIND_PROMPT:
  7514 00001777 BE[723B]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7515                                  
  7516                                  ; ---------------------------------------------------------------------------
  7517                                  
  7518                                  FIND_NAME_IN_ENVIRONMENT:
  7519                                  
  7520                                  ; Input: DS:SI points to a "=" terminated string
  7521                                  ; Output: ES:DI points to the arguments in the environment
  7522                                  ;	  zero is set if name not found
  7523                                  ;	  carry flag is set if name not valid format
  7524                                  
  7525 0000177A E80400                  		call	FIND		; Find the name
  7526 0000177D 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7527 0000177F EB74                    		jmp	short SCASB1	; Scan for = sign
  7528                                  
  7529                                  ; ---------------------------------------------------------------------------
  7530                                  		;nop
  7531                                  
  7532                                  ; =============== S U B	R O U T	I N E =======================================
  7533                                  
  7534                                  ; On return of FIND1, ES:DI points to beginning of name
  7535                                  
  7536                                  FIND:
  7537 00001781 FC                      		cld
  7538 00001782 E82D00                  		call	COUNT0		; CX = Length of name
  7539 00001785 8E06[B141]              		mov	es,[RESSEG]
  7540                                  		; assume es:RESGROUP
  7541 00001789 268E06050D              		mov	es,[es:ENVIRSEG]
  7542                                  		; assume es:NOTHING
  7543 0000178E 31FF                    		xor	di,di
  7544                                  FIND1:	
  7545 00001790 51                      		push	cx
  7546 00001791 56                      		push	si
  7547 00001792 57                      		push	di
  7548                                  FIND11:
  7549 00001793 AC                      		lodsb
  7550                                  		;call	UPCONV
  7551 00001794 E86A00                  		call	UPCONV_MAPCALL
  7552 00001797 47                      		inc	di
  7553 00001798 263A45FF                		cmp	al,[es:di-1]
  7554 0000179C 7502                    		jnz	short FIND12
  7555 0000179E E2F3                    		loop	FIND11
  7556                                  FIND12:
  7557 000017A0 5F                      		pop	di
  7558 000017A1 5E                      		pop	si
  7559 000017A2 59                      		pop	cx
  7560 000017A3 74CC                    		jz	short FIND_RETN
  7561 000017A5 51                      		push	cx
  7562 000017A6 E85000                  		call	SCASB2		; Scan for a nul
  7563 000017A9 59                      		pop	cx
  7564 000017AA 26803D00                		cmp	byte [es:di],0
  7565 000017AE 75E0                    		jnz	short FIND1
  7566 000017B0 F9                      		stc			; Indicate not found
  7567 000017B1 C3                      		retn
  7568                                  
  7569                                  ; =============== S U B	R O U T	I N E =======================================
  7570                                  
  7571                                  COUNT0:
  7572 000017B2 1E                      		push	ds
  7573 000017B3 07                      		pop	es
  7574                                  		; assume es:nothing
  7575 000017B4 89F7                    		mov	di,si
  7576                                  ;COUNT1:
  7577 000017B6 57                      		push	di		; Count number of chars until "="
  7578 000017B7 E83B00                  		call	SCASB1
  7579                                  		; 24/02/2023
  7580                                  		;jmp	short COUNTX
  7581                                  ;COUNT2:
  7582                                  ;		push	di		; Count number of chars until nul
  7583                                  ;		call	SCASB2
  7584                                  ;COUNTX:
  7585 000017BA 59                      		pop	cx
  7586 000017BB 29CF                    		sub	di,cx
  7587 000017BD 87F9                    		xchg	di,cx
  7588                                  MOVE_NAME_RETN:
  7589 000017BF C3                      		retn
  7590                                  
  7591                                  ; =============== S U B	R O U T	I N E =======================================
  7592                                  
  7593                                  MOVE_NAME:
  7594 000017C0 803C0D                  		cmp	byte [si],13
  7595 000017C3 74FA                    		jz	short MOVE_NAME_RETN
  7596 000017C5 AC                      		lodsb
  7597                                  		;call	UPCONV
  7598 000017C6 E83800                  		call	UPCONV_MAPCALL
  7599 000017C9 E84500                  		call	STORE_CHAR
  7600 000017CC 3C3D                    		cmp	al,'='
  7601 000017CE 75F0                    		jnz	short MOVE_NAME
  7602                                  GETARG_RETN:
  7603 000017D0 C3                      		retn
  7604                                  
  7605                                  ; =============== S U B	R O U T	I N E =======================================
  7606                                  
  7607                                  GETARG:
  7608 000017D1 BE8000                  		mov	si,80h
  7609 000017D4 AC                      		lodsb
  7610 000017D5 08C0                    		or	al,al
  7611 000017D7 74F7                    		jz	short GETARG_RETN
  7612 000017D9 E87C01                  		call	SCANOFF
  7613 000017DC 3C0D                    		cmp	al,13
  7614                                  SDN_RETN:
  7615 000017DE C3                      		retn
  7616                                  
  7617                                  ; =============== S U B	R O U T	I N E =======================================
  7618                                  
  7619                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7620                                  ; there is NO double NULL, merely a string that is empty.
  7621                                  
  7622                                  SCAN_DOUBLE_NULL:
  7623 000017DF 8E06[B141]              		mov	es,[RESSEG]
  7624                                  		; ASSUME ES:RESGROUP
  7625 000017E3 268E06050D              		mov	es,[es:ENVIRSEG]
  7626                                  		; ASSUME ES:NOTHING
  7627 000017E8 31FF                    		xor	di,di
  7628                                  
  7629                                  ; Top cycle-point. If the string here is empty, then we are done
  7630                                  
  7631                                  SDN1:
  7632 000017EA 26803D00                		cmp	byte [es:di],0	; nul string?
  7633 000017EE 74EE                    		jz	short SDN_RETN	; yep, all done
  7634 000017F0 E80600                  		call	SCASB2
  7635 000017F3 EBF5                    		jmp	short SDN1
  7636                                  
  7637                                  ; =============== S U B	R O U T	I N E =======================================
  7638                                  
  7639                                  SCASB1:
  7640 000017F5 B03D                    		mov	al,'='		; Scan for an =
  7641 000017F7 EB02                    		jmp	short SCASBX
  7642                                  
  7643                                  ; =============== S U B	R O U T	I N E =======================================
  7644                                  
  7645                                  SCASB2:
  7646 000017F9 30C0                    		xor	al,al		; Scan for a nul
  7647                                  
  7648                                  ; ---------------------------------------------------------------------------
  7649                                  
  7650                                  SCASBX:
  7651 000017FB B90001                  		mov	cx,256
  7652 000017FE F2AE                    		repne scasb
  7653 00001800 C3                      		retn
  7654                                  
  7655                                  ; =============== S U B	R O U T	I N E =======================================
  7656                                  
  7657                                  ; MSDOS 6.0
  7658                                  
  7659                                  ; ****************************************************************
  7660                                  ; *
  7661                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7662                                  ; *
  7663                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7664                                  ; *		 the character in AL from the file upper case table
  7665                                  ; *		 in DOS if character if above  ascii 128, else
  7666                                  ; *		 subtracts 20H if between "a" and "z".
  7667                                  ; *
  7668                                  ; * INPUT:	 AL	      char to be upper cased
  7669                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7670                                  ; *
  7671                                  ; * OUTPUT:	 AL	      upper cased character
  7672                                  ; *
  7673                                  ; ****************************************************************
  7674                                  
  7675                                  ;assume	ds:trangroup			;AN000;
  7676                                  ;
  7677                                  ;upconv	proc	near			;AN000;
  7678                                  ;
  7679                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7680                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7681                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7682                                  ;	push	ds			;AN000;
  7683                                  ;	push	bx			;AN000;
  7684                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7685                                  ;assume	ds:resgroup			;AN000;
  7686                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7687                                  ;	add	bx,2			;AN000;  skip over first word
  7688                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7689                                  ;	pop	bx			;AN000;
  7690                                  ;	pop	ds			;AN000;
  7691                                  ;assume	ds:trangroup			;AN000;
  7692                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7693                                  ;
  7694                                  ;oth_fucase:				;AN000;
  7695                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7696                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7697                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7698                                  ;	ja	upconv_end		;AC000;
  7699                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7700                                  ;
  7701                                  ;upconv_end:				;AN000;
  7702                                  ;	ret
  7703                                  ;
  7704                                  ;upconv	endp				;AN000;
  7705                                  
  7706                                  ; ---------------------------------------------------------------------------
  7707                                  
  7708                                  ; MSDOS 3.3
  7709                                  
  7710                                  UPCONV_MAPCALL:
  7711                                  					; If between "a" and "z"
  7712                                  		;cmp	al,[small_a]
  7713                                  		; 01/03/2023
  7714 00001801 3C61                    		cmp	al,'a' ; small_a
  7715 00001803 7206                    		jb	short UPCONV_END
  7716                                  		;cmp	al,[small_z]
  7717 00001805 3C7A                    		cmp	al,'z' ; small_z
  7718 00001807 7702                    		ja	short UPCONV_END
  7719 00001809 2C20                    		sub	al,20h		; Change lower-case to upper
  7720                                  UPCONV_END:
  7721 0000180B 2EFF1E[4A4C]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7722                                  					  ; 	  for (current) country
  7723 00001810 C3                      		retn
  7724                                  
  7725                                  ; =============== S U B	R O U T	I N E =======================================
  7726                                  
  7727                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7728                                  
  7729                                  STORE_CHAR:
  7730 00001811 51                      		push	cx
  7731 00001812 53                      		push	bx
  7732                                  
  7733                                  		; 16/10/2018
  7734                                  		; MSDOS 6.0
  7735                                  		;PUSH	ES		;AN056;*
  7736                                  		;PUSH	DS		;AN056; Save local DS
  7737                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7738                                  		;;ASSUME DS:RESGROUP	;AN056;
  7739                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7740                                  		;; ASSUME ES:NOTHING	;AN056;
  7741                                  		;POP	DS		;AN056; Get local segment back
  7742                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7743                                  
  7744                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7745 00001813 E84300                  		call	GETENVSIZ
  7746 00001816 89CB                    		mov	bx,cx		; Save room for double nul	
  7747 00001818 83EB02                  		sub	bx,2
  7748 0000181B 39DF                    		cmp	di,bx
  7749 0000181D 7231                    		jb	short STORE1
  7750                                  
  7751 0000181F 50                      		push	ax
  7752 00001820 51                      		push	cx
  7753 00001821 53                      		push	bx		; Save Size of environment
  7754 00001822 E83AEE                  		call	FREE_TPA
  7755 00001825 5B                      		pop	bx
  7756 00001826 83C302                  		add	bx,2		; Recover true environment size
  7757                                  
  7758 00001829 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7759 0000182D 7203                    		jb	short ENVSIZ_OK
  7760                                  BAD_ENV_SIZE:				;AN056;
  7761 0000182F F9                      		stc
  7762 00001830 EB09                    		jmp	short ENVNOSET
  7763                                  
  7764                                  		;nop
  7765                                  ENVSIZ_OK:
  7766 00001832 B104                    		mov	cl,4
  7767 00001834 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7768 00001836 43                      		inc	bx
  7769                                  
  7770                                  		; MSDOS 6.0
  7771                                  		;MOV	CX,ES		;AN056; Get environment segment
  7772                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7773                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7774                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7775                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7776                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7777                                  
  7778                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7779 00001837 B44A                    		mov	ah,SETBLOCK ; 4Ah
  7780 00001839 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7781                                  				; ES = segment address of block	to change
  7782                                  				; BX = new size	in paragraphs
  7783                                  ENVNOSET:
  7784 0000183B 9C                      		pushf
  7785 0000183C 06                      		push	es
  7786 0000183D 8E06[B141]              		mov	es,[RESSEG]
  7787                                  		;ASSUME ES:RESGROUP
  7788 00001841 E82BEE                  		call	ALLOC_TPA
  7789 00001844 07                      		pop	es
  7790 00001845 9D                      		popf
  7791 00001846 59                      		pop	cx
  7792 00001847 58                      		pop	ax
  7793                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7794 00001848 7306                    		jnc	short STORE1
  7795 0000184A BA[B637]                		mov	dx,ENVERRPTR
  7796 0000184D E9B003                  		jmp	CERROR
  7797                                  
  7798                                  STORE1:	
  7799 00001850 AA                      		stosb
  7800 00001851 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7801                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7802 00001856 5B                      		pop	bx
  7803 00001857 59                      		pop	cx
  7804 00001858 C3                      		retn
  7805                                  
  7806                                  ; =============== S U B	R O U T	I N E =======================================
  7807                                  
  7808                                  GETENVSIZ:
  7809                                  
  7810                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7811                                  ;ES has environment segment
  7812                                  ;Size returned in CX, all other registers preserved
  7813                                  
  7814 00001859 06                      		push	es
  7815 0000185A 50                      		push	ax
  7816 0000185B 8CC0                    		mov	ax,es
  7817 0000185D 48                      		dec	ax	;Point at arena	
  7818 0000185E 8EC0                    		mov	es,ax
  7819 00001860 26A10300                		mov	ax,[es:ARENA.size]
  7820 00001864 B104                    		mov	cl,4
  7821 00001866 D3E0                    		shl	ax,cl	;Convert to bytes
  7822 00001868 89C1                    		mov	cx,ax
  7823 0000186A 58                      		pop	ax
  7824 0000186B 07                      		pop	es
  7825                                  GETENVSIZ_RETN:
  7826 0000186C C3                      		retn
  7827                                  
  7828                                  ; =============== S U B	R O U T	I N E =======================================
  7829                                  
  7830                                  RESTUDIR1:
  7831 0000186D 1E                      		push	ds
  7832 0000186E 8E1E[B141]              		mov	ds,[RESSEG]
  7833                                  		;ASSUME	DS:RESGROUP
  7834 00001872 803EF30B00              		cmp	byte [RESTDIR],0
  7835 00001877 1F                      		pop	ds
  7836                                  		;ASSUME	DS:TRANGROUP
  7837 00001878 74F2                    		jz	short GETENVSIZ_RETN
  7838                                  
  7839                                  ; =============== S U B	R O U T	I N E =======================================
  7840                                  
  7841                                  RESTUDIR:
  7842 0000187A BA[9340]                		mov	dx,USERDIR1
  7843 0000187D B43B                    		mov	ah,CHDIR ; 3Bh
  7844 0000187F CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7845                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7846 00001881 30C0                    		xor	al,al
  7847 00001883 E84B06                  		call	SETREST
  7848 00001886 C3                      		retn
  7849                                  
  7850                                  ;============================================================================
  7851                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7852                                  ;============================================================================
  7853                                  ; 07/10/2018 - Retro DOS v3.0
  7854                                  
  7855                                  ; TITLE	Part6 COMMAND Transient routines.
  7856                                  
  7857                                  ;	Environment utilities and misc. routines
  7858                                  
  7859                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7860                                  
  7861                                  ; ---------------------------------------------------------------------------
  7862                                  
  7863                                  ; ****************************************************************
  7864                                  ; *
  7865                                  ; * ROUTINE:	 $CHDIR
  7866                                  ; *
  7867                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7868                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7869                                  ; *		 letter is found, get and display the current dir
  7870                                  ; *		 of the specified drive. If nothing is found, get
  7871                                  ; *		 and display the current dir of the default drive.
  7872                                  ; *
  7873                                  ; * INPUT:	 command line at offset 81H
  7874                                  ; *
  7875                                  ; * OUTPUT:	 none
  7876                                  ; *
  7877                                  ; ****************************************************************
  7878                                  
  7879                                  _$CHDIR:
  7880                                  		; MSDOS 6.0
  7881                                  		;mov	si,81H
  7882                                  		;mov	di,offset trangroup:parse_chdir 
  7883                                  		;			;AN000; Get address of PARSE_CHDIR
  7884                                  		;xor	cx,cx		;AN000; clear cx,dx
  7885                                  		;xor	dx,dx		;AN000;
  7886                                  		;invoke	parse_with_msg	;AC018; call parser
  7887                                  
  7888                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7889                                  		;jz	bwdJ		; No args
  7890                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7891                                  		;jnz	ChDirErr	;AC018; yes - exit
  7892                                  
  7893                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7894                                  		;jnz	REALCD		; no
  7895                                  ;;
  7896                                  ;; D: was found. See if there is anything more.
  7897                                  ;;
  7898                                  		;mov	di,offset trangroup:parse_chdir 
  7899                                  					;AC000; get address of parse_chdir
  7900                                  		;xor	dx,dx		;AC000;
  7901                                  		;invoke	parse_check_eol ;AC000; call parser
  7902                                  		;jnz	ChDirErr	;AC000;
  7903                                  	;bwdJ:
  7904                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7905                                  		;call	crlf2
  7906                                  		;return
  7907                                  
  7908                                  		; MSDOS 3.3
  7909 00001887 A1[C841]                		mov	ax,[COMSW]
  7910 0000188A 0B06[CE41]              		or	ax,[ALLSWITCH]
  7911 0000188E BA[8239]                		mov	dx,BADPARMPTR
  7912 00001891 7533                    		jnz	short CHDIR_ERR
  7913 00001893 BE8100                  		mov	si,81h
  7914 00001896 E8BF00                  		call	SCANOFF
  7915 00001899 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7916 0000189B 740F                    		je	short BWDJ	; No args
  7917 0000189D 46                      		inc	si
  7918 0000189E AC                      		lodsb
  7919 0000189F 3C3A                    		cmp	al,':'
  7920 000018A1 7510                    		jne	short REALCD
  7921 000018A3 56                      		push	si
  7922 000018A4 E8B100                  		call	SCANOFF
  7923 000018A7 5E                      		pop	si
  7924 000018A8 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7925 000018AA 7507                    		jne	short REALCD	; no
  7926                                  BWDJ:
  7927 000018AC E878FB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7928 000018AF E89900                  		call	CRLF2
  7929                                  CHDIR_RETN:
  7930 000018B2 C3                      		retn
  7931                                  
  7932                                  		; MSDOS 6.0
  7933                                  ;REALCD:
  7934                                  		;push	si		;AN000; save position in line
  7935                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7936                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7937                                  		;pop	si		;AN000; restore position in line
  7938                                  		;mov	di,offset trangroup:parse_chdir 
  7939                                  		;			;AC000; get address of parse_chdir
  7940                                  		;xor	dx,dx		;AC000;
  7941                                  		;invoke	parse_check_eol ;AC000; call parser
  7942                                  		;jnz	ChDirErr	;AC000;
  7943                                  		;
  7944                                  		;invoke	SETPATH
  7945                                  		;TEST	[DESTINFO],2
  7946                                  		;JNZ	BadChdir
  7947                                  		;MOV	AH,CHDIR
  7948                                  		;INT	21h
  7949                                  		;retnc
  7950                                  		;
  7951                                  		;invoke	get_ext_error_number
  7952                                  		;			;AN022; get the extended error
  7953                                  		;cmp	ax,error_path_not_found
  7954                                  		;			;AN022; see if path not found
  7955                                  		;jz	BadChDir	;AN022; yes - issue old message
  7956                                  ;;SR;
  7957                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  7958                                  ;;but is not a directory. The extended error returns "Access denied" which
  7959                                  ;;is kind of confusing. Issue the old message if access denied error is 
  7960                                  ;;returned
  7961                                  ;;
  7962                                  		;cmp	ax,error_access_denied
  7963                                  		;jz	BadChDir
  7964                                  		;
  7965                                  		;call	Set_Ext_Error_Subst ;AN022;
  7966                                  		;jmp	short  chdirerr ;AN022;
  7967                                  ;BadChDir:
  7968                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  7969                                  ;ChDirErr:
  7970                                  		;invoke	Std_Eprintf
  7971                                  		;return
  7972                                  
  7973                                  		; MSDOS 3.3
  7974                                  REALCD:
  7975 000018B3 E88804                  		call	SETPATH
  7976 000018B6 F606[B043]02            		test	byte [DESTINFO],2
  7977 000018BB 7506                    		jnz	short BADCHDIR
  7978 000018BD B43B                    		mov	ah,CHDIR ; 3Bh
  7979 000018BF CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7980                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7981 000018C1 73EF                    		jnc	short CHDIR_RETN
  7982                                  BADCHDIR:
  7983 000018C3 BA[D63A]                		mov	dx,BADCDPTR
  7984                                  CHDIR_ERR:
  7985 000018C6 E8821B                  		call	STD_EPRINTF
  7986                                  MKDIR_RETN:
  7987 000018C9 C3                      		retn
  7988                                  
  7989                                  ; ---------------------------------------------------------------------------
  7990                                  
  7991                                  _$MKDIR:
  7992                                  		; MSDOS 6.0
  7993                                  		;CALL	SETRMMK
  7994                                  		;JC	MkDirErr
  7995                                  		;MOV	AH,MKDIR
  7996                                  		;INT	21h
  7997                                  		;retnc
  7998                                  
  7999                                  		;invoke	get_ext_error_number	
  8000                                  		;			;AN022; get the extended error
  8001                                  		;cmp	ax,error_path_not_found 
  8002                                  		;			;AN022; see if path not found
  8003                                  		;jz	MD_other_err	;AN022; yes - issue old message
  8004                                  		;cmp	ax,error_access_denied
  8005                                  		;			;AN022; access denied?
  8006                                  		;jz	badmderr	;AN022; yes - see if file exists
  8007                                  		
  8008                                  		;call	Set_Ext_Error_Subst ;AN022;
  8009                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  8010                                  ;BADMDERR:
  8011                                  		;mov	dx,offset trangroup:srcxname	
  8012                                  		;			;AN006; Set Disk transfer address
  8013                                  		;mov	ah,Set_DMA	;AN006;
  8014                                  		;int	21h		;AN006;
  8015                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  8016                                  		;mov	cx,attr_directory ;AN006;   search for directory
  8017                                  		;INT	21h		;AN006;
  8018                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  8019                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  8020                                  		;test	dl,attr_directory ;AN006; was it a directory?
  8021                                  		;jz	MD_other_err	;AN006; no - must have been a file
  8022                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  8023                                  		;			;AN006; set up already exists error
  8024                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  8025                                  ;MD_other_err:				;AN006;
  8026                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  8027                                  ;MkDirErr:
  8028                                  		;invoke	Std_Eprintf
  8029                                  		;return
  8030                                  
  8031                                  		; MSDOS 3.3
  8032 000018CA E81200                  		call	SETRMMK
  8033 000018CD 720C                    		jb	short MKDIRERR
  8034 000018CF B439                    		mov	ah,MKDIR ; 39h
  8035 000018D1 CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  8036                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8037 000018D3 73F4                    		jnc	short MKDIR_RETN
  8038 000018D5 BA[F53A]                		mov	dx,BADMKDPTR
  8039 000018D8 E8B405                  		call	GET_EXT_ERR_NUMBER
  8040                                  MKDIRERR:
  8041 000018DB E86D1B                  		call	STD_EPRINTF
  8042 000018DE C3                      		retn
  8043                                  
  8044                                  ; =============== S U B	R O U T	I N E =======================================
  8045                                  
  8046                                  ; 	<Common MkDir/RmDir set up code>
  8047                                  ;****************************************************************
  8048                                  ;*
  8049                                  ;* ROUTINE:	SETRMMK
  8050                                  ;*
  8051                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  8052                                  ;*		commands. Parses the command line for a required
  8053                                  ;*		filespec.
  8054                                  ;*
  8055                                  ;* INPUT:	command line at offset 81H
  8056                                  ;*
  8057                                  ;* OUTPUT:	carry clear
  8058                                  ;*		    DS:DX points to ASCIIZ argument
  8059                                  ;*		carry set
  8060                                  ;*		    DS:DX has error message pointer
  8061                                  ;*
  8062                                  ;****************************************************************
  8063                                  
  8064                                  		; MSDOS 6.0
  8065                                  		;mov	si,81H
  8066                                  		;mov	di,offset trangroup:parse_mrdir 
  8067                                  					;AN000; Get address of PARSE_MRDIR
  8068                                  		;xor	cx,cx		;AN000; clear cx,dx
  8069                                  		;xor	dx,dx		;AN000;
  8070                                  		;invoke	parse_with_msg	;AC000; call parser
  8071                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8072                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8073                                  
  8074                                  		;mov	di,offset trangroup:srcxname
  8075                                  		;			;AN000; get address of srcxname
  8076                                  		;push	di		;AN000; save address
  8077                                  		;push	si		;AN000; save position in line
  8078                                  		;lds	si,parse1_addr	;AN000; get address of path
  8079                                  
  8080                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8081                                  		;lodsb			;get a char from buffer
  8082                                  		;stosb			;AN000; store in srcxname
  8083                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8084                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8085                                  		;pop	si		;AN000; get line position back
  8086                                  ;;
  8087                                  ;; we have scanned an argument.	See if any args beyond.
  8088                                  ;;
  8089                                  		;mov	di,offset trangroup:parse_mrdir 
  8090                                  		;			;AC000; get address of parse_mrdir
  8091                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8092                                  		;pop	dx		;AC000; get address of SRCXNAME
  8093                                  		;retz			;yes - return no error
  8094                                  ;NOARGERR:
  8095                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8096                                  		;			;AC000; get extended message pointer
  8097                                  		;XOR	AX,AX
  8098                                  		;STC
  8099                                  		;return
  8100                                  
  8101                                  		; MSDOS 3.3
  8102                                  SETRMMK:
  8103 000018DF BE8100                  		mov	si,81h
  8104 000018E2 E87300                  		call	SCANOFF
  8105 000018E5 3C0D                    		cmp	al,0Dh
  8106 000018E7 741E                    		je	short NOARGERR
  8107 000018E9 89F2                    		mov	dx,si
  8108                                  SETRMMK1:
  8109 000018EB AC                      		lodsb
  8110 000018EC E87100                  		call	DELIM
  8111 000018EF 7409                    		jz	short SETRMMK3
  8112 000018F1 3C0D                    		cmp	al,0Dh
  8113 000018F3 75F6                    		jne	short SETRMMK1
  8114 000018F5 C644FF00                		mov	byte [si-1],0
  8115                                  SETRMMK2:
  8116 000018F9 C3                      		retn
  8117                                  SETRMMK3:
  8118 000018FA C644FF00                		mov	byte [si-1],0
  8119 000018FE 56                      		push	si
  8120 000018FF E85600                  		call	SCANOFF
  8121 00001902 5E                      		pop	si
  8122 00001903 3C0D                    		cmp	al,0Dh
  8123 00001905 74F2                    		je	short SETRMMK2
  8124                                  NOARGERR:
  8125 00001907 BA[CD3C]                		mov	dx,BADARGSPTR
  8126 0000190A 31C0                    		xor	ax,ax
  8127 0000190C F9                      		stc
  8128                                  SETRMMK_RETN:
  8129 0000190D C3                      		retn
  8130                                  
  8131                                  ; ---------------------------------------------------------------------------
  8132                                  
  8133                                  _$RMDIR:
  8134 0000190E E8CEFF                  		call	SETRMMK
  8135 00001911 720E                    		jb	short RMDIRERR
  8136 00001913 7506                    		jnz	short BADRDERR
  8137 00001915 B43A                    		mov	ah,RMDIR ; 3Ah
  8138 00001917 CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8139                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8140 00001919 73F2                    		jnc	short SETRMMK_RETN
  8141                                  
  8142                                  		; MSDOS 6.0
  8143                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8144                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8145                                  		;jz	badrderr	;AN022; yes - issue old message
  8146                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8147                                  		;jz	badrderr	;AN022; yes - issue old message
  8148                                  
  8149                                  		;call	Set_Ext_Error_Subst ;AN022;
  8150                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8151                                  
  8152                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8153                                  BADRDERR:
  8154 0000191B BA[2E3B]                		mov	dx,BADRMDPTR
  8155 0000191E E86E05                  		call	GET_EXT_ERR_NUMBER
  8156                                  RMDIRERR:
  8157 00001921 E8271B                  		call	STD_EPRINTF
  8158                                  RMDIR_RETN:
  8159 00001924 C3                      		retn
  8160                                  
  8161                                  ; =============== S U B	R O U T	I N E =======================================
  8162                                  
  8163                                  ; MSDOS 6.0
  8164                                  
  8165                                  ;****************************************************************
  8166                                  ;*
  8167                                  ;* ROUTINE:	Set_ext_error_subst
  8168                                  ;*
  8169                                  ;* FUNCTION:	Sets up substitution for extended error
  8170                                  ;*
  8171                                  ;* INPUT:	AX - extended error number
  8172                                  ;*		DX - offset of string
  8173                                  ;*
  8174                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8175                                  ;*
  8176                                  ;****************************************************************
  8177                                  
  8178                                  ;Set_ext_error_subst  proc near		;AN022;
  8179                                  ;
  8180                                  ;	mov	msg_disp_class,ext_msg_class
  8181                                  ;					;AN022; set up extended error msg class
  8182                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8183                                  ;	mov	Extend_buf_sub,one_subst 
  8184                                  ;					;AN022; put number of subst in control block
  8185                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8186                                  ;					;AN022; get extended message pointer
  8187                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8188                                  ;
  8189                                  ;	ret				;AN022; return
  8190                                  ;
  8191                                  ;Set_ext_error_subst  endp		;AN022;
  8192                                  
  8193                                  ; =============== S U B	R O U T	I N E =======================================
  8194                                  
  8195                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8196                                  
  8197                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8198                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8199                                  ;   buffer
  8200                                  ;
  8201                                  ;   Inputs:	DL has 1-based drive number
  8202                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8203                                  ;   Outputs:	Carry Clear
  8204                                  ;		    DS = TranGroup
  8205                                  ;		Carry Set
  8206                                  ;		    AX has error code
  8207                                  ;   Registers Modified: AX, SI
  8208                                  
  8209                                  SAVUDIR:
  8210 00001925 BF[9340]                		mov	di,USERDIR1
  8211                                  
  8212                                  ; ---------------------------------------------------------------------------
  8213                                  
  8214                                  SAVUDIR1:
  8215 00001928 88D0                    		mov	al,dl
  8216 0000192A 0440                    		add	al,'@'
  8217 0000192C 3C40                    		cmp	al,'@'
  8218 0000192E 7506                    		jnz	short GOTUDRV
  8219 00001930 0206[C541]              		add	al,[CURDRV]
  8220 00001934 FEC0                    		inc	al		; A = 1
  8221                                  GOTUDRV:
  8222 00001936 AA                      		stosb
  8223 00001937 8A26[B641]              		mov	ah,[DIRCHAR]
  8224 0000193B B03A                    		mov	al,':'
  8225 0000193D AB                      		stosw
  8226 0000193E 06                      		push	es
  8227 0000193F 1F                      		pop	ds
  8228 00001940 89FE                    		mov	si,di
  8229 00001942 B447                    		mov	ah,CURRENT_DIR	; 47h
  8230 00001944 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8231                                  				; DL = drive (0=default,1=A,etc.)
  8232                                  				; DS:SI	points to 64-byte buffer area
  8233 00001946 72DC                    		jc	short RMDIR_RETN
  8234 00001948 0E                      		push	cs
  8235 00001949 1F                      		pop	ds
  8236 0000194A C3                      		retn
  8237                                  
  8238                                  ; =============== S U B	R O U T	I N E =======================================
  8239                                  
  8240                                  CRLF2:
  8241 0000194B 52                      		push	dx
  8242 0000194C BA[EE3C]                		mov	dx,ACRLFPTR
  8243 0000194F 1E                      		push	ds
  8244 00001950 0E                      		push	cs
  8245 00001951 1F                      		pop	ds
  8246 00001952 E8FF1A                  		call	STD_PRINTF
  8247 00001955 1F                      		pop	ds
  8248 00001956 5A                      		pop	dx
  8249 00001957 C3                      		retn
  8250                                  
  8251                                  ; =============== S U B	R O U T	I N E =======================================
  8252                                  
  8253                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8254                                  ; may NOT be TRANGROUP
  8255                                  
  8256                                  SCANOFF:
  8257 00001958 AC                      		lodsb
  8258 00001959 E80400                  		call	DELIM
  8259 0000195C 74FA                    		jz	short SCANOFF
  8260 0000195E 4E                      		dec	si		; Point to first non-delimiter
  8261                                  SCANOFF_RETN:
  8262 0000195F C3                      		retn
  8263                                  
  8264                                  ; ---------------------------------------------------------------------------
  8265                                  
  8266                                  ; Input:    AL is character to classify
  8267                                  ; Output:   Z set if delimiter
  8268                                  ;	    NZ set otherwise
  8269                                  ; Registers modified: none
  8270                                  
  8271                                  DELIM:
  8272 00001960 3C20                    		cmp	al,' '
  8273 00001962 74FB                    		jz	short SCANOFF_RETN
  8274 00001964 3C3D                    		cmp	al,'='
  8275 00001966 74F7                    		jz	short SCANOFF_RETN
  8276 00001968 3C2C                    		cmp	al,','
  8277 0000196A 74F3                    		jz	short SCANOFF_RETN
  8278 0000196C 3C3B                    		cmp	al,';'
  8279 0000196E 74EF                    		jz	short SCANOFF_RETN
  8280 00001970 3C09                    		cmp	al,9		; Check for TAB character
  8281 00001972 74EB                    		jz	short SCANOFF_RETN
  8282 00001974 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8283 00001976 C3                      		retn
  8284                                  
  8285                                  
  8286                                  ; =============== S U B	R O U T	I N E =======================================
  8287                                  
  8288                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8289 00001977 B90800                  		mov	cx,8
  8290                                  MAINNAME:
  8291 0000197A AC                      		lodsb
  8292 0000197B 3C20                    		cmp	al,' '
  8293 0000197D 7401                    		jz	short SKIPSPC
  8294 0000197F AA                      		stosb
  8295                                  SKIPSPC:
  8296 00001980 E2F8                    		loop	MAINNAME
  8297 00001982 AC                      		lodsb
  8298 00001983 3C20                    		cmp	al,' '
  8299 00001985 7412                    		jz	short GOTNAME
  8300 00001987 88C4                    		mov	ah,al
  8301                                  		;mov	al,'.'
  8302                                  		;mov	al,[DOT_CHR]
  8303                                  		; 01/03/2023
  8304 00001989 B02E                    		mov	al,dot_chr ; mov al,'.'
  8305 0000198B AA                      		stosb
  8306 0000198C 86C4                    		xchg	al,ah
  8307 0000198E AA                      		stosb
  8308 0000198F B102                    		mov	cl,2
  8309                                  EXTNAME:
  8310 00001991 AC                      		lodsb
  8311 00001992 3C20                    		cmp	al,' '
  8312 00001994 7403                    		jz	short GOTNAME
  8313 00001996 AA                      		stosb
  8314 00001997 E2F8                    		loop	EXTNAME
  8315                                  GOTNAME:
  8316 00001999 30C0                    		xor	al,al
  8317 0000199B AA                      		stosb
  8318                                  STRCOMP_RETN:
  8319 0000199C C3                      		retn
  8320                                  
  8321                                  ; =============== S U B	R O U T	I N E =======================================
  8322                                  
  8323                                  ; Compare ASCIZ DS:SI with ES:DI.
  8324                                  ; SI,DI destroyed.
  8325                                  
  8326                                  STRCOMP:	
  8327 0000199D A6                      		cmpsb
  8328 0000199E 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8329 000019A0 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8330 000019A4 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8331 000019A6 EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8332                                  
  8333                                  ; =============== S U B	R O U T	I N E =======================================
  8334                                  
  8335                                  CRPRINT:
  8336 000019A8 50                      		push	ax
  8337                                  		;mov	al,13
  8338 000019A9 B00D                    		mov	al,0Dh
  8339 000019AB 51                      		push	cx
  8340 000019AC 57                      		push	di
  8341 000019AD 89D7                    		mov	di,dx
  8342 000019AF B9FFFF                  		mov	cx,65535
  8343 000019B2 06                      		push	es
  8344 000019B3 1E                      		push	ds
  8345 000019B4 07                      		pop	es
  8346 000019B5 F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8347 000019B7 C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8348 000019BB 07                      		pop	es
  8349 000019BC 8916[8E43]              		mov	[STRING_PTR_2],dx
  8350 000019C0 BA[9F36]                		mov	dx,STRINGBUF2PTR
  8351 000019C3 E88E1A                  		call	STD_PRINTF
  8352                                  		;mov	byte [di-1],13
  8353 000019C6 C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8354 000019CA 7204                    		jb	short ERROR_OUTPUT
  8355 000019CC 5F                      		pop	di
  8356 000019CD 59                      		pop	cx
  8357 000019CE 58                      		pop	ax
  8358 000019CF C3                      		retn
  8359                                  
  8360                                  ; ---------------------------------------------------------------------------
  8361                                  
  8362                                  ERROR_OUTPUT:
  8363 000019D0 0E                      		push	cs
  8364 000019D1 1F                      		pop	ds
  8365 000019D2 8E06[B141]              		mov	es,[RESSEG]
  8366 000019D6 BA[9937]                		mov	dx,NOSPACEPTR
  8367 000019D9 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  8368 000019DF 7406                    		jz	short GO_TO_ERROR
  8369 000019E1 E84C09                  		call	PIPEOFF
  8370 000019E4 BA[323C]                		mov	dx,PIPEEMESPTR
  8371                                  GO_TO_ERROR:
  8372 000019E7 E91602                  		jmp	CERROR
  8373                                  
  8374                                  ; =============== S U B	R O U T	I N E =======================================
  8375                                  
  8376                                  ;---- Mod for path invocation ----
  8377                                  
  8378                                  PATHCHRCMP:
  8379 000019EA 50                      		push	ax
  8380 000019EB B42F                    		mov	ah,'/'
  8381 000019ED 3826[B541]              		cmp	[SWITCHAR],ah
  8382 000019F1 7404                    		jz	short NOSLASHT
  8383 000019F3 3C2F                    		cmp	al,'/'
  8384 000019F5 7402                    		jz	short PCCONT
  8385                                  NOSLASHT:
  8386 000019F7 3C5C                    		cmp	al,'\'
  8387                                  PCCONT:	
  8388 000019F9 58                      		pop	ax
  8389 000019FA C3                      		retn
  8390                                  
  8391                                  ; =============== S U B	R O U T	I N E =======================================
  8392                                  
  8393                                  ; PATHCRUNCH -
  8394                                  ;
  8395                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8396                                  ;       PathPos = ptr to string with pathname in it
  8397                                  ;       PathCnt = length of string
  8398                                  ;
  8399                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8400                                  ;       PathCnt = length left in string
  8401                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8402                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8403                                  ;       If path crunched successfully,
  8404                                  ;         CY = clear
  8405                                  ;         Current directory is changed to directory in pathname
  8406                                  ;         UserDir1 contains previous directory for use by RestUDir
  8407                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8408                                  ;         DestTail = ptr to beginning of filename
  8409                                  ;         If filename found in pathname,
  8410                                  ;           ZR = clear
  8411                                  ;           FCB filename fields contain filename
  8412                                  ;         If filename not found (pure directory path),
  8413                                  ;           ZR = set
  8414                                  ;           FCB filename fields are wildcarded with ?'s
  8415                                  ;       If pathcrunch failed (no ChDir's worked),
  8416                                  ;         CY = set
  8417                                  ;         Msg_Numb = extended error code
  8418                                  ;
  8419                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8420                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8421                                  ;       with the filename wildcarded.
  8422                                  
  8423                                  PATHCRUNCH:
  8424                                  		; MSDOS 6.0
  8425                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8426                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8427                                  		;mov	dl,[5CH]
  8428 000019FB 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8429 000019FF E823FF                  		call	SAVUDIR		; save current directory in UserDir1
  8430 00001A02 E83903                  		call	SETPATH
  8431                                  		; MSDOS 6.0
  8432                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8433                                  
  8434                                  ;       DX = ptr to pathname, NULL-terminated
  8435                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8436                                  
  8437                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8438 00001A05 F606[B043]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8439 00001A0A 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8440                                  
  8441 00001A0C B43B                    		mov	ah,CHDIR ; 3Bh
  8442 00001A0E CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8443                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8444                                  		; MSDOS 6.0
  8445                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8446                                  		;
  8447                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8448                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8449                                  		;jz	trypeel                 ;AC022;     keep trying
  8450                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8451                                  		;jz	trypeel                 ;AC022;     keep trying
  8452                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8453                                  		;jmp	peelfail                ;AN022; exit with other error
  8454                                  
  8455                                  		; MSDOS 3.3
  8456 00001A10 7210                    		jc	short TRYPEEL
  8457                                  ;chdir_worked:
  8458                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8459 00001A12 E8BA04                  		call	SETREST1	; set 'Restore Directory' flag true
  8460 00001A15 B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8461 00001A17 BF5D00                  		mov	di,5Dh
  8462 00001A1A B90B00                  		mov	cx,11
  8463 00001A1D F3AA                    		rep stosb
  8464 00001A1F 30C0                    		xor	al,al		; return carry clear, zero set
  8465 00001A21 C3                      		retn
  8466                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8467                                  		;jmp	pcrunch_cderr	;AN022;
  8468                                  TRYPEEL:
  8469 00001A22 8B36[0043]              		mov	si,[PATHPOS]
  8470 00001A26 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8471 00001A27 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8472 00001A2A E8BDFF                  		call	PATHCHRCMP
  8473 00001A2D 7423                    		jz	short PEELFAIL
  8474                                  DELLOOP:
  8475 00001A2F 39D6                    		cmp	si,dx
  8476 00001A31 742B                    		jz	short BADRET
  8477 00001A33 8A04                    		mov	al,[si]
  8478 00001A35 E8B2FF                  		call	PATHCHRCMP
  8479 00001A38 7403                    		jz	short TRYCD
  8480 00001A3A 4E                      		dec	si
  8481 00001A3B EBF2                    		jmp	short DELLOOP
  8482                                  TRYCD:
  8483 00001A3D 50                      		push	ax
  8484                                  		;mov	al,'.'
  8485                                  		;mov	al,[DOT_CHR]	; AL = '.'
  8486                                  		; 01/03/2023
  8487 00001A3E B02E                    		mov	al,dot_chr ; mov al,'.'
  8488                                  		
  8489                                  		; MSDOS 6.0
  8490                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8491                                  					;M019; allow continuation if '. ' or 
  8492                                  					;M019; '..' is not found.
  8493                                  		;jnz	@f		;M019; '.' not found
  8494                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8495                                  		;jz	@f		;M019; found '..'
  8496                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8497                                  ;@@:		;pop     ax
  8498                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8499                                  
  8500                                  		; MSDOS 3.3
  8501 00001A40 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8502 00001A43 58                      		pop	ax
  8503 00001A44 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8504                                  
  8505                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8506 00001A46 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8507 00001A49 3C3A                    		cmp	al,':'
  8508 00001A4B 7411                    		jz	short BADRET
  8509 00001A4D E89AFF                  		call	PATHCHRCMP
  8510 00001A50 7502                    		jnz	short NODOUBLESL
  8511                                  PEELFAIL:
  8512 00001A52 F9                      		stc
  8513 00001A53 C3                      		retn
  8514                                  NODOUBLESL:
  8515 00001A54 C60400                  		mov	byte [si],0
  8516 00001A57 B43B                    		mov	ah,CHDIR ; 3Bh
  8517 00001A59 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8518                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8519 00001A5B 7317                    		jnc	short CDSUCC
  8520                                  
  8521                                  		; MSDOS 6.0
  8522                                  ;pcrunch_cderr:
  8523                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8524                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8525                                  		;or	si,si		;AN022; set up zero flag to not zero
  8526                                  		;stc			;AN022; set up carry flag
  8527                                  		;return
  8528                                  		
  8529                                  		; MSDOS 3.3
  8530                                  PATHCRUNCH_RETN:
  8531 00001A5D C3                      		retn
  8532                                  
  8533                                  BADRET:
  8534 00001A5E 8A04                    		mov	al,[si]
  8535 00001A60 E887FF                  		call	PATHCHRCMP
  8536 00001A63 F9                      		stc
  8537 00001A64 75F7                    		jnz	short PATHCRUNCH_RETN
  8538 00001A66 30DB                    		xor	bl,bl
  8539 00001A68 865C01                  		xchg	bl,[si+1]
  8540 00001A6B B43B                    		mov	ah,CHDIR ; 3Bh
  8541 00001A6D CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8542                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8543 00001A6F 72EC                    		jb	short PATHCRUNCH_RETN
  8544 00001A71 885C01                  		mov	[si+1],	bl
  8545                                  CDSUCC:
  8546 00001A74 E85804                  		call	SETREST1
  8547 00001A77 46                      		inc	si
  8548 00001A78 8936[AE43]              		mov	[DESTTAIL],si
  8549                                  		; MSDOS 6.0
  8550                                  		;pushf			;AN015; save flags
  8551                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8552                                  		;jz	pcrunch_end	;AN015;
  8553                                  		;MOV	DI,FCB
  8554                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8555                                  					; Parse with default drive
  8556                                  		;INT	21h
  8557                                  ;pcrunch_end:
  8558                                  		;popf			;AN015; get flags back
  8559                                  		;return
  8560                                  
  8561                                  		; MSDOS 3.3
  8562 00001A7C BF5C00                  		mov	di,FCB ; 5Ch
  8563 00001A7F B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8564 00001A82 CD21                    		int	21h	; DOS -	PARSE FILENAME
  8565                                  				; DS:SI	-> string to parse
  8566                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8567                                  				; AL = bit mask	to control parsing
  8568 00001A84 C3                      		retn
  8569                                  
  8570                                  ;============================================================================
  8571                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8572                                  ;============================================================================
  8573                                  ; 05/10/2018 - Retro DOS v3.0
  8574                                  
  8575                                  ;TITLE	Part7 COMMAND Transient Routines
  8576                                  
  8577                                  ;	More misc routines
  8578                                  
  8579                                  ;---------------------------
  8580                                  ; We can get rid of this switch processing code if we can take
  8581                                  ; care of the remaining two calls to switch, later in the file.
  8582                                  ; However, I have not checked whether or not any other files use
  8583                                  ; switch -- after all, it IS public!
  8584                                  ;---------------------------
  8585                                  
  8586                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8587                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8588                                  
  8589                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8590                                  
  8591                                  ; ---------------------------------------------------------------------------
  8592                                  
  8593 00001A85 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8594 00001A86 C3                      		retn
  8595                                  
  8596                                  ; =============== S U B	R O U T	I N E =======================================
  8597                                  
  8598                                  SWITCH:
  8599 00001A87 31DB                    		xor	bx,bx		; Initialize - no switches set
  8600                                  SWLOOP:
  8601 00001A89 E8CCFE                  		call	SCANOFF		; Skip any delimiters
  8602 00001A8C 3A06[B541]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8603 00001A90 75F3                    		jnz	short RETSW	; No -- we're finished
  8604                                  		;or	bx,8000h
  8605 00001A92 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8606 00001A96 46                      		inc	si		; Skip over the switch character
  8607 00001A97 E8BEFE                  		call	SCANOFF
  8608 00001A9A 3C0D                    		cmp	al,0Dh
  8609 00001A9C 74E7                    		je	short RETSW	; Oops
  8610 00001A9E 46                      		inc	si
  8611                                  
  8612                                  		; Convert lower case input to upper case
  8613                                  
  8614                                  		;call	UPCONV
  8615 00001A9F E85FFD                  		call	UPCONV_MAPCALL
  8616                                  
  8617 00001AA2 BF[5E3E]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8618                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8619                                  		;mov	cx,5  ; MSDOS 3.3
  8620 00001AA5 B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8621                                  		
  8622                                  		;nop
  8623                                  		
  8624 00001AA8 F2AE                    		repne scasb		; Look for matching switch
  8625 00001AAA 7507                    		jnz	short BADSW
  8626 00001AAC B80100                  		mov	ax,1
  8627 00001AAF D3E0                    		shl	ax,cl		; Set a bit for the switch
  8628 00001AB1 09C3                    		or	bx,ax
  8629                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8630 00001AB3 EBD4                    		jmp	short SWLOOP
  8631                                  
  8632                                  ;BADSW:
  8633                                  		;jmp	short SWLOOP
  8634                                  
  8635                                  DRVBAD:
  8636 00001AB5 BA[A938]                		mov	dx,BADDRVPTR
  8637 00001AB8 E94501                  		jmp	CERROR
  8638                                  
  8639                                  EXTERNALJ:
  8640 00001ABB E9B100                  		jmp	EXTERNAL
  8641                                  
  8642                                  FNDCOM:					; search the internal command table
  8643 00001ABE 08C0                    		or	al,al		; Get real length of first arg
  8644 00001AC0 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8645                                  					;  to be external.
  8646                                  ; barryf code starts here
  8647                                  
  8648 00001AC2 E86802                  		call	TEST_APPEND	; see if APPEND installed
  8649 00001AC5 7421                    		jz	short CONTCOM	; not loaded
  8650                                  
  8651                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8652 00001AC7 8A0E[2B42]              		mov	cl,[IDLEN]
  8653 00001ACB B500                    		mov	ch,0
  8654 00001ACD 890E[0043]              		mov	[PATHPOS],cx
  8655                                  		
  8656                                  		; MSDOS 6.0
  8657                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8658                                  
  8659 00001AD1 E8F602                  		call	IOSET		; re-direct the o'l io
  8660                                  
  8661 00001AD4 BE[2B42]                		mov	si,IDLEN	; address command name, DS already set	
  8662 00001AD7 BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8663                                  		
  8664                                  		; MSDOS 6.0
  8665                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8666                                  					;AN010; Get the entry point for PARSE for APPEND
  8667                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8668 00001ADA B801AE                  		mov	ax,0AE01h
  8669 00001ADD CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8670                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8671                                  				; DX = FFFFh,[SI -> buffer
  8672                                  				; Return: buffer at DS:SI filled with a	length byte
  8673                                  				;		 followed by the uppercase
  8674                                  				; internal command to execute (if length not 0)
  8675 00001ADF 803E[2B42]00            		cmp	byte [IDLEN],0 ; execute requested
  8676 00001AE4 7502                    		jne	short CONTCOM
  8677 00001AE6 EB57                    		jmp	short CMD_DONE
  8678                                  
  8679                                  		;nop
  8680                                  CONTCOM:				; continue with internal scan
  8681 00001AE8 BF[433D]                		mov	di,COMTAB
  8682 00001AEB 31C9                    		xor	cx,cx
  8683                                  FINDCOM:
  8684 00001AED BE[2C42]                		mov	si,ID		; pointer to command argument
  8685 00001AF0 8A0D                    		mov	cl,[di]		; load length of internal command
  8686 00001AF2 47                      		inc	di		; advance past length
  8687 00001AF3 E3C6                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8688 00001AF5 3A0E[2B42]              		cmp	cl,[IDLEN]	; that of the command argument
  8689 00001AF9 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8690 00001AFB 890E[0043]              		mov	[PATHPOS],cx	; store length of command
  8691 00001AFF F3A6                    		repe cmpsb
  8692                                  ABCD:					
  8693 00001B01 9F                      		lahf			; save the good ol' flags
  8694 00001B02 01CF                    		add	di,cx		; skip over remaining internal, if any
  8695 00001B04 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8696 00001B06 A2[C341]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8697 00001B09 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8698 00001B0A 8B1D                    		mov	bx,[di]		; load internal command address
  8699 00001B0C 47                      		inc	di		; skip over the puppy
  8700 00001B0D 47                      		inc	di
  8701                                  		
  8702                                  		; MSDOS 6.0
  8703                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8704                                  		;inc     DI
  8705                                  		;inc     DI
  8706                                  		;sahf			; remember those flags?
  8707                                  		;jnz     findcom	; well, if all the cmps worked...
  8708                                  ;;
  8709                                  ;; All messages get redirected.
  8710                                  ;;
  8711                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8712                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8713                                  		;invoke  ioset		; re-direct the ol' i/o
  8714                                  
  8715                                  ;dont_set_io:					;AN041;
  8716                                  ;;
  8717                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8718                                  ;; respond to /? only if it is the only command-line argument.
  8719                                  ;;
  8720                                  		;mov     ax,[COMSW]	; AX = switches after command
  8721                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8722                                  		;and     ax,SwitchQues	
  8723                                  		;jz      drive_check	; /? not in command line
  8724                                  		;	
  8725                                  		;test    [CHKDRV],fLimitHelp
  8726                                  		;jz      do_help	; /? allowed in combination
  8727                                  ;;
  8728                                  ;; Make sure /? is the only argument on the command line.
  8729                                  ;;
  8730                                  		;cmp     [arg.argvcnt],2
  8731                                  		;jne     drive_check	; /? not only arg - ignore
  8732                                  ;;
  8733                                  ;; Note:  this is all the check we need, even against things like /??.
  8734                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8735                                  ;;
  8736                                  
  8737                                  ;do_help:
  8738                                  ;
  8739                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8740                                  
  8741                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8742                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8743                                  		;push    ax		; build subst block on stack
  8744                                  
  8745                                  ;next_help_msg:
  8746                                  		;lodsw			; AX = help msg # or zero
  8747                                  		;or      ax,ax
  8748                                  		;jz      help_done
  8749                                  		;push    ax		; SS:SP = ptr to subst block
  8750                                  					;  (msg # and no_subst byte)
  8751                                  ;; We assume DS = SS.
  8752                                  
  8753                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8754                                      		;invoke  Std_PrintF	; display help message
  8755                                      		;pop     ax		; remove msg # from stack
  8756                                     		;jmp     next_help_msg
  8757                                  
  8758                                  ;help_done:
  8759                                  		;pop     ax		; clean up stack
  8760                                  		;jmp     TCommand	
  8761                                  
  8762                                  		; MSDOS 3.3
  8763 00001B0E 9E                      		sahf			; remember those flags?
  8764 00001B0F 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8765 00001B11 E8B602                  		call	IOSET		; re-direct the ol' i/o
  8766                                  
  8767                                  DRIVE_CHECK:
  8768                                  		;test	byte [CHKDRV],1
  8769 00001B14 F606[C341]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8770                                  					; did we wanna check those drives?
  8771 00001B19 740D                    		jz	short NOCHECK
  8772 00001B1B A0[C641]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8773 00001B1E 0A06[C741]              		or	al,[PARM2]	; us whether those drives were OK
  8774 00001B22 3CFF                    		cmp	al,-1
  8775 00001B24 7502                    		jnz	short NOCHECK
  8776 00001B26 EB8D                    		jmp	short DRVBAD
  8777                                  
  8778                                  ; The user may have omitted the space between the command and its arguments.
  8779                                  ; We need to copy the remainder of the user's command line into the buffer.
  8780                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8781                                  ; into the command line at 80.
  8782                                  
  8783                                  NOCHECK:
  8784 00001B28 E8E501                  		call	CMD_COPY
  8785                                  SWITCHECK:
  8786                                  		;test	byte [CHKDRV],2
  8787 00001B2B F606[C341]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8788                                  					; Does the command take switches
  8789 00001B30 750B                    		jnz	short REALWORK	; Yes, process the command
  8790 00001B32 E82400                  		call	NOSWIT		; No, check to see if any switches
  8791 00001B35 7506                    		jnz	short REALWORK	; None, process the command
  8792                                  
  8793                                  		; MSDOS 6.0
  8794                                  		;mov	msg_disp_class,parse_msg_class	
  8795                                  		;			;AN000; set up parse error msg class
  8796                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8797                                  		;			;AC000; get extended message pointer
  8798                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8799                                  		;			;AN000; get "Invalid switch" message number
  8800                                  		;jmp	CERROR		; Print error and chill out...
  8801                                  
  8802                                  		; MSDOS 3.0
  8803 00001B37 BA[8239]                		mov	dx,BADPARMPTR
  8804 00001B3A E9C300                  		jmp	CERROR
  8805                                  
  8806                                  REALWORK:
  8807 00001B3D FFD3                    		call	bx		; do some real work, at last
  8808                                  
  8809                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8810                                  ; otherwise, go get another command.
  8811                                  
  8812                                  CMD_DONE:
  8813 00001B3F 0E                      		push	cs		; g  restore data segment
  8814 00001B40 1F                      		pop	ds		; g
  8815 00001B41 1E                      		push	ds
  8816 00001B42 8E1E[B141]              		mov	ds,[RESSEG]	; g  save data segment
  8817                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8818 00001B46 803E000C01              		cmp	byte [CALL_FLAG],call_in_progress
  8819 00001B4B C606000C00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8820 00001B50 1F                      		pop	ds		; g  get data segment back
  8821 00001B51 7403                    		jz	short INCALL	; G
  8822 00001B53 E9AEE5                  		jmp	TCOMMAND	; chill out...
  8823                                  INCALL:
  8824 00001B56 E954E7                  		jmp	DOCOM1
  8825                                  
  8826                                  ; =============== S U B	R O U T	I N E =======================================
  8827                                  
  8828                                  NOSWIT:
  8829 00001B59 57                      		push	di		; Save di
  8830 00001B5A BF8100                  		mov	di,81h		; di = ptr to command args
  8831 00001B5D BE8000                  		mov	si,80h		; Get address of length of command args
  8832 00001B60 AC                      		lodsb			; Load length
  8833 00001B61 88C1                    		mov	cl,al		; Move length to cl
  8834 00001B63 30ED                    		xor	ch,ch		; Zero ch
  8835 00001B65 2EA0[B541]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8836 00001B69 3C00                    		cmp	al,0		; Turn off ZF
  8837 00001B6B F2AE                    		repne scasb		; Scan for a switch character and return
  8838 00001B6D 5F                      		pop	di		;  with ZF set if one was found
  8839 00001B6E C3                      		retn
  8840                                  
  8841                                  ; ---------------------------------------------------------------------------
  8842                                  
  8843                                  EXTERNAL:
  8844 00001B6F E8BB01                  		call	TEST_APPEND	; check to see if append installed
  8845 00001B72 7406                    		jz	short NOT_BARRYF ; no - truly external command
  8846 00001B74 E950FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8847                                  
  8848                                  		; 25/02/2023
  8849                                  BATCOMJ:
  8850 00001B77 E96BEB                  		jmp	BATCOM
  8851                                  
  8852                                  NOT_BARRYF:
  8853 00001B7A 2EC606[C441]00          		mov	byte [cs:FILTYP],0
  8854 00001B80 2E8A16[D141]            		mov	dl,[cs:SPECDRV]
  8855 00001B85 2E8816[2B42]            		mov	[cs:IDLEN],dl
  8856 00001B8A 2EC606[A743]00          		mov	byte [cs:ROM_CALL],0
  8857 00001B90 52                      		push	dx
  8858 00001B91 BA[2B42]                		mov	dx,IDLEN
  8859 00001B94 E838E8                  		call	ROM_SCAN
  8860 00001B97 5A                      		pop	dx
  8861                                  		;jnc	short POSTSAVE
  8862 00001B98 7305                    		jnc	short DO_SCAN
  8863 00001B9A 2EFE06[A743]            		inc	byte [cs:ROM_CALL]
  8864                                  		;jmp	short POSTSAVE
  8865                                  
  8866                                  		;nop
  8867                                  DO_SCAN:
  8868                                  POSTSAVE:
  8869 00001B9F BF[D940]                		mov	di,EXECPATH
  8870 00001BA2 C60500                  		mov	byte [di],0	; Initialize to current directory
  8871                                  	
  8872 00001BA5 2E803E[A743]00          		cmp	byte [cs:ROM_CALL],0
  8873                                  		;jz	short RESEARCH
  8874                                  		;jmp	short NEOEXECUTE
  8875                                  		; 25/02/2023
  8876 00001BAB 750C                    		jnz	short NEOEXECUTE		
  8877                                  
  8878                                  		;nop
  8879                                  RESEARCH:
  8880 00001BAD E8E008                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8881 00001BB0 09C0                    		or	ax,ax		; did we find anything?
  8882                                  		;jz	short BADCOMJ45	; null means no (sob)
  8883                                  		; 25/02/2023
  8884 00001BB2 7447                    		jz	short BADCOM
  8885 00001BB4 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8886                                  					; fuckin' sixteen-bit machine ought
  8887 00001BB7 7CBE                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8888                                  					; DISPLACEMENT!!
  8889                                  		; 25/02/2023
  8890                                  		;;jmp	short NEOEXECUTE
  8891                                  		;jmp	short EXECUTE	
  8892                                  
  8893                                  
  8894                                  		; 02H is .bat
  8895                                  
  8896                                  		;nop
  8897                                  
  8898                                  		; 25/02/2023
  8899                                  ;BATCOMJ:
  8900                                  ;		jmp	BATCOM
  8901                                  ;
  8902                                  ;BADCOMJ45:
  8903                                  ;		jmp	short BADCOM
  8904                                  
  8905                                  		;nop
  8906                                  EXECUTE:
  8907                                  NEOEXECUTE:
  8908 00001BB9 E80E02                  		call	IOSET
  8909                                  
  8910                                  ; MSDOS 6.0
  8911                                  ;M051
  8912                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8913                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8914                                  ;After a close, this would still leave one open active resulting in sharing
  8915                                  ;errors on subsequent opens of the redirected file.
  8916                                  ;
  8917                                  ;LH_EXECUTE:				;M051	
  8918 00001BBC 8E06[C141]              		mov	es,[TRAN_TPA]
  8919 00001BC0 B449                    		mov	ah,DEALLOC ; 49h
  8920 00001BC2 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8921                                  				; ES = segment address of area to be freed
  8922                                  					; Now running in "free" space
  8923 00001BC4 8E06[B141]              		mov	es,[RESSEG]
  8924 00001BC8 26FE06EB0B              		inc	byte [es:EXTCOM] ; Indicate external command
  8925 00001BCD 26C606F30B00            		mov	byte [es:RESTDIR],0 
  8926                                  					; Since USERDIR1 is in transient, insure
  8927                                  					; this flag value for re-entry to COMMAND
  8928                                  		; MSDOS 6.0
  8929                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8930                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8931                                  		;MOV	CX,LenMsgOrPathBuf
  8932                                  		;CLD
  8933                                  		;REP	MOVSB		; copy program pathname to resident
  8934                                  
  8935                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8936 00001BD3 BF5C00                  		mov	di,FCB ; 5Ch
  8937 00001BD6 89FE                    		mov	si,di
  8938 00001BD8 B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8939 00001BDB F3A5                    		rep movsw		; Transfer parameters to resident header
  8940 00001BDD BA[D940]                		mov	dx,EXECPATH
  8941                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8942 00001BE0 BB050D                  		mov	bx,EXEC_BLOCK
  8943 00001BE3 B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8944 00001BE6 F606[A743]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8945 00001BEB 7403                    		jz	short OK_EXEC
  8946 00001BED E958E8                  		jmp	ROM_EXEC
  8947                                  OK_EXEC:
  8948                                  ;
  8949                                  ; we are now running in free space. Anything we do from here on may get
  8950                                  ; trashed. Move the stack (also in free space) to allocated space because
  8951                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  8952                                  ;
  8953 00001BF0 8CC1                    		mov	cx,es
  8954 00001BF2 8ED1                    		mov	ss,cx
  8955 00001BF4 BC3E08                  		mov	sp,RSTACK
  8956 00001BF7 FF2E[B741]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  8957                                  
  8958                                  ; ---------------------------------------------------------------------------
  8959                                  
  8960                                  BADCOM:
  8961 00001BFB 0E                      		push	cs
  8962 00001BFC 1F                      		pop	ds
  8963 00001BFD BA[1B37]                		mov	dx,BADNAMPTR
  8964                                  CERROR:		
  8965 00001C00 E84818                  		call	STD_EPRINTF
  8966 00001C03 E9FEE4                  		jmp	TCOMMAND
  8967                                  
  8968                                  
  8969                                  ; =============== S U B	R O U T	I N E =======================================
  8970                                  
  8971                                  ; Prescan converts the input buffer into a canonicalized form.
  8972                                  ; All redirections and pipes are removed.
  8973                                  
  8974                                  PRESCAN:
  8975 00001C06 31C9                    		xor	cx,cx
  8976 00001C08 8E06[B141]              		mov	es,[RESSEG]
  8977 00001C0C BE[1240]                		mov	si,COMBUF+2
  8978 00001C0F 89F7                    		mov	di,si
  8979                                  COUNTQUOTES:
  8980 00001C11 AC                      		lodsb			; get a byte
  8981 00001C12 3C22                    		cmp	al,22h		; is it a quote?
  8982 00001C14 7504                    		jne	short COUNTEND	; no, try for end of road
  8983 00001C16 FEC5                    		inc	ch		; bump count
  8984 00001C18 EBF7                    		jmp	short COUNTQUOTES ; go get next char
  8985                                  COUNTEND:
  8986 00001C1A 3C0D                    		cmp	al,0Dh		; end of road?
  8987 00001C1C 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  8988 00001C1E 89FE                    		mov	si,di		; restore pointer to begining
  8989                                  PRESCANLP:
  8990 00001C20 AC                      		lodsb
  8991 00001C21 3C22                    		cmp	al,'"'		; " character
  8992 00001C23 7510                    		jne	short TRYGREATER
  8993 00001C25 FECD                    		dec	ch
  8994 00001C27 740C                    		jz	short TRYGREATER
  8995                                  QLOOP:
  8996 00001C29 8805                    		mov	[di],al
  8997 00001C2B 47                      		inc	di
  8998 00001C2C FEC1                    		inc	cl
  8999 00001C2E AC                      		lodsb
  9000 00001C2F 3C22                    		cmp	al,'"'		; " character
  9001 00001C31 75F6                    		jne	short QLOOP
  9002 00001C33 FECD                    		dec	ch
  9003                                  TRYGREATER:
  9004                                  		;cmp	al,[RABRACKET]
  9005                                  		; 01/03/2023
  9006 00001C35 3C3E                    		cmp	al,rabracket  ; '>'
  9007 00001C37 753E                    		jne	short NOOUT
  9008                                  
  9009                                  ; We have found a ">" char. We need to see if there is another ">"
  9010                                  ; following it.
  9011                                  
  9012 00001C39 3804                    		cmp	[si],al
  9013 00001C3B 7506                    		jnz	short NOAPPND
  9014 00001C3D AC                      		lodsb
  9015 00001C3E 26FE060A0C              		inc	byte [es:RE_OUT_APP] ; Flag >>
  9016                                  NOAPPND:
  9017                                  ; Now we attempt to find the file name. First, scan off all whitespace
  9018                                  
  9019 00001C43 E812FD                  		call	SCANOFF
  9020                                  
  9021                                  		; MSDOS 6.0
  9022                                  		;;cmp	al,[LABRACKET]	   ;AN040; was there no filename?
  9023                                  		;cmp	al,labracket ; '<'
  9024                                  		;je	short REOUT_ERRSET ;AN040; yes - set up error
  9025                                  
  9026                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9027 00001C46 3C0D                    		cmp	al,0Dh
  9028 00001C48 750D                    		jnz	short GOTREOFIL
  9029                                  
  9030                                  ; There was no file present.  Set us up at end-of-line.
  9031                                  
  9032                                  REOUT_ERRSET:				;AN040; set up for an error
  9033 00001C4A C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  9034 00001C4D 26C7060B0C0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  9035 00001C54 E99000                  		jmp	PRESCANEND
  9036                                  
  9037                                  GOTREOFIL:
  9038 00001C57 57                      		push	di
  9039                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  9040 00001C58 BF0B0C                  		mov	di,RE_OUTSTR
  9041 00001C5B 89FB                    		mov	bx,di
  9042 00001C5D 06                      		push	es
  9043                                  
  9044                                  		; MSDOS 6.0
  9045                                  SETREOUTSTR:				; Get the output redirection name
  9046                                  					; MSKK06 07/14/89
  9047                                  		;push	cx		; save cx
  9048                                  		;mov	cx,64+13	; CX = max string length
  9049                                  ;SETREOUTSTR_LOOP:
  9050                                  		;LODSB
  9051                                  		;CMP	AL,0DH
  9052                                  		;JZ	GOTRESTR_J
  9053                                  		;INVOKE	DELIM
  9054                                  		;JZ	GOTRESTR_J
  9055                                  		;CMP	AL,[SWITCHAR]
  9056                                  		;JZ	GOTRESTR_J
  9057                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  9058                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  9059                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  9060                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  9061                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  9062                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  9063                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  9064                                  		;DEC	SI		;AN002; back up over symbol
  9065                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  9066                                  ;GOTRESTR_J:
  9067                                  		;pop	cx		; MSKK06 07/14/89
  9068                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  9069                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  9070                                  		;STOSB			; store it into resgroup
  9071                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  9072                                  		;jmp	GOTRESTR_j
  9073                                  ;PIPEERRSYNJ5_J:
  9074                                  		;pop	cx		; recover CX
  9075                                  		;jmp	short PIPEERRSYNJ5
  9076                                  
  9077                                  		; MSDOS 3.3
  9078                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  9079 00001C5E AC                      		lodsb
  9080 00001C5F 3C0D                    		cmp	al,0Dh
  9081 00001C61 7460                    		jz	short GOTRESTR
  9082 00001C63 E8FAFC                  		call	DELIM
  9083 00001C66 745B                    		jz	short GOTRESTR
  9084 00001C68 3A06[B541]              		cmp	al,[SWITCHAR]
  9085 00001C6C 7455                    		je	short GOTRESTR
  9086 00001C6E 3C22                    		cmp	al,'"'
  9087 00001C70 7502                    		jne	short NO_ABRACKET
  9088 00001C72 FECD                    		dec	ch
  9089                                  NO_ABRACKET:
  9090 00001C74 AA                      		stosb
  9091 00001C75 EBE7                    		jmp	short SETREOUTSTR_LOOP
  9092                                  NOOUT:
  9093                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9094                                  		;cmp	al,[LABRACKET]
  9095                                  		; 01/03/2023
  9096 00001C77 3C3C                    		cmp	al,labracket ; '<'
  9097 00001C79 751F                    		jnz	short CHKPIPE
  9098 00001C7B 89F3                    		mov	bx,si		; Save loc of "<"
  9099 00001C7D E8D8FC                  		call	SCANOFF
  9100                                  		; MSDOS 6.0
  9101                                  		;;cmp	al,[RABRACKET]	;AN040; was there no filename?
  9102                                  		;cmp	al,rabracket ; '>'
  9103                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9104                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9105 00001C80 3C0D                    		cmp	al,0Dh
  9106 00001C82 750B                    		jnz	short GOTREIFIL
  9107                                  REIN_ERRSET:				;AN040; set up for error
  9108 00001C84 C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9109 00001C87 C706[5C41]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9110 00001C8D EB58                    		jmp	short PRESCANEND
  9111                                  GOTREIFIL:
  9112 00001C8F 57                      		push	di
  9113 00001C90 BF[5C41]                		mov	di,RE_INSTR
  9114 00001C93 89FB                    		mov	bx,di
  9115 00001C95 06                      		push	es
  9116 00001C96 0E                      		push	cs
  9117 00001C97 07                      		pop	es		; store in TRANGROUP
  9118 00001C98 EBC4                    		jmp	short SETREOUTSTR_LOOP 
  9119                                  					; Get the input redirection name
  9120                                  CHKPIPE:
  9121 00001C9A 88C4                    		mov	ah,al
  9122                                  		;cmp	ah,'|'
  9123 00001C9C 80FC7C                  		cmp	ah,ALTPIPECHR
  9124                                  		; 01/03/2023
  9125                                  		;je	short ISPIPE3
  9126                                  		;;cmp	ah,[VBAR]
  9127                                  		;cmp	ah,vbar	; '|'
  9128 00001C9F 7539                    		jne	short CONTPRESCAN
  9129                                  ISPIPE3:
  9130                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9131                                  
  9132 00001CA1 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9133 00001CA7 7505                    		jne	short NOECHOPUSH
  9134 00001CA9 26D026EF0B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9135                                  NOECHOPUSH:
  9136 00001CAE 26FE065C0C              		inc	byte [es:PIPEFLAG]
  9137 00001CB3 E8A2FC                  		call	SCANOFF
  9138 00001CB6 3C0D                    		cmp	al,0Dh
  9139 00001CB8 7404                    		jz	short PIPEERRSYNJ5
  9140                                  		;cmp	al,'|'
  9141 00001CBA 3C7C                    		cmp	al,ALTPIPECHR
  9142                                  		; 01/03/2023
  9143                                  		;jz	short PIPEERRSYNJ5
  9144                                  		;;cmp	al,[VBAR]	; '|'
  9145                                  		;cmp	al,vbar
  9146 00001CBC 751C                    		jnz	short CONTPRESCAN
  9147                                  PIPEERRSYNJ5:
  9148 00001CBE 06                      		push	es
  9149 00001CBF 1F                      		pop	ds
  9150 00001CC0 E93802                  		jmp	PIPEERRSYN
  9151                                  
  9152                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9153                                  ; than just a : in the redir string.
  9154                                  
  9155                                  GOTRESTR:
  9156 00001CC3 86E0                    		xchg	ah,al
  9157 00001CC5 B03A                    		mov	al,':'
  9158 00001CC7 29FB                    		sub	bx,di		; compute negative of number of chars
  9159 00001CC9 83FBFF                  		cmp	bx,-1		; is there just a :?
  9160 00001CCC 7407                    		je	short NOTRAILCOL ; yep, don't change
  9161 00001CCE 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9162 00001CD2 7501                    		jne	short NOTRAILCOL
  9163 00001CD4 4F                      		dec	di		; Back up over trailing ':'
  9164                                  NOTRAILCOL:
  9165 00001CD5 30C0                    		xor	al,al
  9166 00001CD7 AA                      		stosb			; NUL terminate the string
  9167 00001CD8 07                      		pop	es
  9168 00001CD9 5F                      		pop	di		; Remember the start
  9169                                  CONTPRESCAN:
  9170 00001CDA 8825                    		mov	[di],ah		; "delete" the redirection string
  9171 00001CDC 47                      		inc	di
  9172 00001CDD 80FC0D                  		cmp	ah,0Dh
  9173 00001CE0 7405                    		je	short PRESCANEND
  9174 00001CE2 FEC1                    		inc	cl
  9175 00001CE4 E939FF                  		jmp	PRESCANLP
  9176                                  PRESCANEND:
  9177 00001CE7 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9178 00001CED 7414                    		je	short ISNOPIPE
  9179                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9180 00001CEF BF800C                  		mov	di,PIPESTR
  9181 00001CF2 26893E7E0C              		mov	[es:PIPEPTR],di
  9182 00001CF7 BE[1240]                		mov	si,COMBUF+2
  9183 00001CFA E85BFC                  		call	SCANOFF
  9184                                  PIPESETLP:				; Transfer the pipe into the resident
  9185 00001CFD AC                      		lodsb			; pipe buffer
  9186 00001CFE AA                      		stosb
  9187 00001CFF 3C0D                    		cmp	al,0Dh
  9188 00001D01 75FA                    		jnz	short PIPESETLP
  9189                                  ISNOPIPE:
  9190 00001D03 880E[1140]              		mov	[COMBUF+1],cl
  9191 00001D07 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9192 00001D0D 0E                      		push	cs
  9193 00001D0E 07                      		pop	es
  9194 00001D0F C3                      		retn
  9195                                  
  9196                                  ; =============== S U B	R O U T	I N E =======================================
  9197                                  
  9198                                  CMD_COPY:
  9199 00001D10 BE[1240]                		mov	si,COMBUF+2
  9200 00001D13 E842FC                  		call	SCANOFF		; advance past separators...
  9201 00001D16 0336[0043]              		add	si,[PATHPOS]
  9202 00001D1A BF8100                  		mov	di,81h
  9203 00001D1D 31C9                    		xor	cx,cx
  9204                                  CMDCOPY:
  9205 00001D1F AC                      		lodsb
  9206 00001D20 AA                      		stosb
  9207 00001D21 3C0D                    		cmp	al,0Dh
  9208 00001D23 7403                    		je	short COPY_DONE
  9209 00001D25 41                      		inc	cx
  9210 00001D26 EBF7                    		jmp	short CMDCOPY
  9211                                  COPY_DONE:
  9212 00001D28 880E8000                		mov	[80h],cl
  9213 00001D2C C3                      		retn
  9214                                  
  9215                                  ; =============== S U B	R O U T	I N E =======================================
  9216                                  
  9217                                  TEST_APPEND:
  9218 00001D2D BB[1040]                		mov	bx,COMBUF	; barry can address
  9219 00001D30 BE[2B42]                		mov	si,IDLEN	; address command name, DS already set 	
  9220 00001D33 BAFFFF                  		mov	dx,-1
  9221 00001D36 B800AE                  		mov	ax,0AE00h
  9222 00001D39 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9223                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9224                                  				; DX = FFFFh,[BX -> command line
  9225                                  				; Return: AL = FFh if this command is a TSR extension 
  9226                                  				;		   to COMMAND.COM
  9227                                  				; AL = 00h if the command should be executed as	usual
  9228 00001D3B 3C00                    		cmp	al,0
  9229 00001D3D C3                      		retn
  9230                                  
  9231                                  ;============================================================================
  9232                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9233                                  ;============================================================================
  9234                                  ; 05/10/2018 - Retro DOS v3.0
  9235                                  
  9236                                  ;	More misc routines
  9237                                  
  9238                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9239                                  
  9240                                  ; =============== S U B	R O U T	I N E =======================================
  9241                                  
  9242                                  SETPATH:
  9243                                  
  9244                                  ; ENTRY PathPos = ptr to string
  9245                                  ;       PathCnt = length of string
  9246                                  ;
  9247                                  ; EXIT  PathPos = ptr to string after pathname
  9248                                  ;       PathCnt = length of rest of string
  9249                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9250                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9251                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9252                                  ;
  9253                                  ;       A null character is dropped at the end of the pathname. If the
  9254                                  ;       character in that spot previously was CR, it is copied into the
  9255                                  ;       following byte. So there must be at least two two character 
  9256                                  ;       positions in the buffer following the pathname.
  9257                                  
  9258                                  		; MSDOS 6.0
  9259                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9260                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9261                                  
  9262                                  		; MSDOS 3.3
  9263 00001D3E BE8000                  		mov	si,80h
  9264 00001D41 AC                      		lodsb
  9265 00001D42 30E4                    		xor	ah,ah
  9266 00001D44 A3[FE42]                		mov	[PATHCNT],ax
  9267 00001D47 8936[0043]              		mov	[PATHPOS],si
  9268                                  GETPATH:
  9269                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9270 00001D4B C606[B043]00            		mov	byte [DESTINFO],0
  9271 00001D50 C606[AC43]00            		mov	byte [DESTVARS],0
  9272 00001D55 8B36[0043]              		mov	si,[PATHPOS]	; SI = ptr to string
  9273 00001D59 8B0E[FE42]              		mov	cx,[PATHCNT]	; CX = string length
  9274 00001D5D 89F2                    		mov	dx,si		; DX = ptr to string
  9275 00001D5F E33B                    		jcxz	PATHDONE	; string length is zero, we're done
  9276 00001D61 51                      		push	cx		; save string length
  9277 00001D62 56                      		push	si		; save ptr to string
  9278 00001D63 E821FD                  		call	SWITCH
  9279                                  
  9280                                  ;       After Switch, SI has been scanned past any switches, and
  9281                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9282                                  
  9283 00001D66 A3[0243]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9284 00001D69 5B                      		pop	bx		; BX = ptr to original string
  9285 00001D6A 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9286 00001D6C 59                      		pop	cx		; CX = string length
  9287 00001D6D 01D9                    		add	cx,bx		; CX = string length from current SI
  9288 00001D6F 89F2                    		mov	dx,si		; DX = ptr to current string
  9289                                  SKIPPATH:
  9290 00001D71 E329                    		jcxz	PATHDONE	; string length is zero, we're done
  9291 00001D73 49                      		dec	cx		; CX = length left after next char
  9292 00001D74 AC                      		lodsb			; AL = next char of string
  9293                                  					; SI = ptr to char after this one
  9294 00001D75 E872FC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9295 00001D78 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9296 00001D7A FE06[AC43]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9297                                  TESTPMETA:
  9298 00001D7E 3C3F                    		cmp	al,'?'
  9299 00001D80 7505                    		jne	short TESTPSTAR	; char is not '?'
  9300 00001D82 800E[B043]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9301                                  TESTPSTAR:
  9302                                  		;cmp	al,'*'
  9303                                  		;cmp	al,[STAR]
  9304                                  		; 01/03/2023
  9305 00001D87 3C2A                    		cmp	al,star ; cmp al,'*'
  9306 00001D89 7505                    		jne	short TESTPDELIM ; char is not '*'
  9307 00001D8B 800E[B043]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9308                                  TESTPDELIM:
  9309 00001D90 E8CDFB                  		call	DELIM		; compare AL to all delimiters
  9310 00001D93 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9311 00001D95 3A06[B541]              		cmp	al,[SWITCHAR]
  9312 00001D99 75D6                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9313                                  PATHDONEDEC:
  9314 00001D9B 4E                      		dec	si		; SI = ptr to char after pathname
  9315                                  PATHDONE:
  9316 00001D9C 30C0                    		xor	al,al		; AL = NULL
  9317 00001D9E 8604                    		xchg	al,[si]		; place NULL after pathname
  9318 00001DA0 46                      		inc	si		; SI = ptr to byte after NULL
  9319 00001DA1 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9320 00001DA3 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9321 00001DA5 8804                    		mov	[si],al		; save EOL after NULL
  9322                                  NOPSTORE:
  9323 00001DA7 8936[0043]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9324 00001DAB 890E[FE42]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9325                                  SETPATH_RETN:
  9326 00001DAF C3                      		retn
  9327                                  
  9328                                  ; ---------------------------------------------------------------------------
  9329                                  
  9330                                  PGETARG:
  9331 00001DB0 BE8000                  		mov	si,80h
  9332 00001DB3 AC                      		lodsb
  9333 00001DB4 08C0                    		or	al,al
  9334 00001DB6 74F7                    		jz	short SETPATH_RETN
  9335 00001DB8 E80300                  		call	PSCANOFF
  9336 00001DBB 3C0D                    		cmp	al,0Dh
  9337 00001DBD C3                      		retn
  9338                                  
  9339                                  ; ---------------------------------------------------------------------------
  9340                                  
  9341                                  PSCANOFF:
  9342 00001DBE AC                      		lodsb
  9343 00001DBF E89EFB                  		call	DELIM
  9344 00001DC2 7504                    		jnz	short PSCANOFFD
  9345 00001DC4 3C3B                    		cmp	al,';'
  9346 00001DC6 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9347                                  PSCANOFFD:
  9348 00001DC8 4E                      		dec	si		; Point to first non-delimiter
  9349 00001DC9 C3                      		retn
  9350                                  
  9351                                  ; =============== S U B	R O U T	I N E =======================================
  9352                                  
  9353                                  IOSET:
  9354                                  		; ALL REGISTERS PRESERVED
  9355 00001DCA 1E                      		push	ds
  9356 00001DCB 52                      		push	dx
  9357 00001DCC 50                      		push	ax
  9358 00001DCD 53                      		push	bx
  9359 00001DCE 51                      		push	cx
  9360 00001DCF 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  9361 00001DD4 803E5C0C00              		cmp	byte [PIPEFLAG],0
  9362 00001DD9 750D                    		jne	short NOREDIR
  9363 00001DDB F606FA0BFF              		test	byte [IFFLAG],0FFh
  9364 00001DE0 7506                    		jnz	short NOREDIR
  9365 00001DE2 E80900                  		call	TESTDOREIN
  9366 00001DE5 E85400                  		call	TESTDOREOUT
  9367                                  NOREDIR:
  9368 00001DE8 59                      		pop	cx
  9369 00001DE9 5B                      		pop	bx
  9370 00001DEA 58                      		pop	ax
  9371 00001DEB 5A                      		pop	dx
  9372 00001DEC 1F                      		pop	ds
  9373                                  IOSET_RETN:
  9374 00001DED C3                      		retn
  9375                                  
  9376                                  ; =============== S U B	R O U T	I N E =======================================
  9377                                  
  9378                                  TESTDOREIN:
  9379 00001DEE 2E803E[5C41]00          		cmp	byte [cs:RE_INSTR],0
  9380 00001DF4 74F7                    		jz	short IOSET_RETN
  9381 00001DF6 1E                      		push	ds
  9382 00001DF7 0E                      		push	cs
  9383 00001DF8 1F                      		pop	ds
  9384 00001DF9 BA[5C41]                		mov	dx,RE_INSTR
  9385 00001DFC B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9386 00001DFF 89C3                    		mov	bx,ax
  9387 00001E01 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9388                                  				; DS:DX	-> ASCIZ filename
  9389                                  				; AL = access mode
  9390                                  				; 0 - read
  9391 00001E03 1F                      		pop	ds
  9392 00001E04 720B                    		jb	short REDIRERR
  9393 00001E06 89C3                    		mov	bx,ax
  9394 00001E08 B0FF                    		mov	al,0FFh
  9395                                  
  9396                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9397                                  ; spot. We invalidate the new JFN we got.
  9398                                  
  9399                                  		;xchg	al,[bx+18h]
  9400 00001E0A 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9401 00001E0D A21800                  		mov	[PDB.JFN_TABLE],al
  9402 00001E10 C3                      		retn
  9403                                  
  9404                                  ; ---------------------------------------------------------------------------
  9405                                  
  9406                                  ; We had some kind of error on the redirection. Figure out what the
  9407                                  ; appropriate message should be; BX has the system call that failed
  9408                                  
  9409                                  REDIRERR:
  9410 00001E11 0E                      		push	cs
  9411 00001E12 1F                      		pop	ds
  9412                                  		;call	TriageError
  9413 00001E13 E87900                  		call	GET_EXT_ERR_NUMBER
  9414                                  
  9415                                  ; At this point, we have recognized the network-generated access denied error.
  9416                                  ; The correct message is in DX
  9417                                  
  9418 00001E16 83F841                  		cmp	ax,65
  9419 00001E19 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9420 00001E1B 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9421 00001E1E 7406                    		jz	short OPENERR
  9422 00001E20 BA[CE37]                		mov	dx,FULDIRPTR
  9423                                  _CERRORJ:
  9424 00001E23 E9DAFD                  		jmp	CERROR
  9425                                  
  9426                                  OPENERR:
  9427                                  ; The system call was an OPEN. Report either file not found or path not found.
  9428                                  
  9429                                  		; MSDOS 6.0
  9430                                  		;mov	msg_disp_class,ext_msg_class 
  9431                                  		;			;AN000; set up extended error msg class
  9432                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9433                                  		;			;AC000; get extended message pointer
  9434                                  		;mov	Extend_Buf_ptr,ax	
  9435                                  		;			;AN000; get message number in control block
  9436                                  		;JMP	CERROR
  9437                                  
  9438                                  		; MSDOS 3.3
  9439 00001E26 BA[5837]                		mov	dx,FNOTFOUNDPTR
  9440                                  		;cmp	ax,2
  9441 00001E29 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9442 00001E2C 74F5                    		je	short _CERRORJ
  9443 00001E2E BA[7D37]                		mov	dx,ACCDENPTR
  9444                                  		;cmp	ax,5 ; Access denied error
  9445 00001E31 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9446 00001E34 74ED                    		je	short _CERRORJ
  9447                                  			; ERROR_PATH_NOT_FOUND
  9448 00001E36 BA[6B37]                		mov	dx,PNOTFOUNDPTR
  9449 00001E39 E9C4FD                  		jmp	CERROR
  9450                                  
  9451                                  ; =============== S U B	R O U T	I N E =======================================
  9452                                  
  9453                                  TESTDOREOUT:
  9454 00001E3C 803E0B0C00              		cmp	byte [RE_OUTSTR],0
  9455 00001E41 743D                    		je	short NOREOUT
  9456                                  
  9457                                  REOUTEXISTS:
  9458 00001E43 803E0A0C00              		cmp	byte [RE_OUT_APP],0
  9459 00001E48 741F                    		je	short REOUTCRT
  9460                                  
  9461 00001E4A BA0B0C                  		mov	dx,RE_OUTSTR
  9462                                  
  9463                                  		; MSDOS 6.0
  9464                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9465                                  		;mov	ax,3D02h
  9466                                  
  9467                                  		; MSDOS 3.3
  9468 00001E4D B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9469                                  	
  9470                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9471 00001E50 50                      		push	ax
  9472 00001E51 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9473                                  				; DS:DX	-> ASCIZ filename
  9474                                  				; AL = access mode
  9475                                  				; 1 - write
  9476 00001E53 5B                      		pop	bx
  9477 00001E54 720D                    		jc	short OPENWRITEERROR
  9478                                  
  9479                                  		; MSDOS 6.0
  9480                                  		;MOV	BX,AX
  9481                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9482                                  		;INT	21h			;AN035;
  9483                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9484                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9485                                  		;
  9486                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9487                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9488                                  		;MOV	DX,CX			;AC011;
  9489                                  		;INT	21h
  9490                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9491                                  		;POP	DS			;AN011;
  9492                                  		;assume	DS:Trangroup		;AN011;
  9493                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9494                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9495                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9496                                  		;INT	21h			;AN011;
  9497                                  		;JC	OpenWriteError		;AN011; If error, exit
  9498                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9499                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9500                                  		;
  9501                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9502                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9503                                  		;assume	DS:Resgroup		;AN011;
  9504                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9505                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9506                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9507                                  		;MOV	DX,CX			;AN011;
  9508                                  		;INT	21h			;AN011;
  9509                                  		;JMP	SHORT SET_REOUT
  9510                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9511                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9512                                  		;assume	DS:Resgroup		;AN017;
  9513                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9514                                  		;XOR	CX,CX			;AN017; Offset is 0
  9515                                  		;MOV	DX,CX			;AN017;
  9516                                  		;INT	21h			;AN017;
  9517                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9518                                  
  9519                                  		; MSDOS 3.3
  9520 00001E56 31D2                    		xor	dx,dx
  9521 00001E58 31C9                    		xor	cx,cx
  9522 00001E5A 89C3                    		mov	bx,ax
  9523 00001E5C B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9524 00001E5F CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9525                                  				; AL = method: offset from end of file
  9526 00001E61 EB15                    		jmp	short SET_REOUT
  9527                                  		
  9528                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9529                                  OPENWRITEERROR:	
  9530                                  		;cmp	ax,5
  9531 00001E63 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9532 00001E66 F9                      		stc
  9533 00001E67 74A8                    		je	short REDIRERR
  9534                                  REOUTCRT:	
  9535 00001E69 BA0B0C                  		mov	dx,RE_OUTSTR
  9536 00001E6C 31C9                    		xor	cx,cx
  9537 00001E6E B43C                    		mov	ah,CREAT ; 3Ch
  9538 00001E70 50                      		push	ax
  9539 00001E71 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9540                                  				; CX = attributes for file
  9541                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9542 00001E73 5B                      		pop	bx
  9543 00001E74 729B                    		jc	short REDIRERR
  9544                                  NOREDIRERR:
  9545 00001E76 89C3                    		mov	bx,ax
  9546                                  SET_REOUT:
  9547                                  
  9548                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9549                                  ; spot. We invalidate the new JFN we got.
  9550                                  
  9551 00001E78 B0FF                    		mov	al,0FFh
  9552                                  		;xchg	al,[bx+18h]
  9553 00001E7A 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9554 00001E7D A21900                  		mov	[PDB.JFN_TABLE+1],al
  9555                                  NOREOUT:
  9556 00001E80 C3                      		retn
  9557                                  
  9558                                  ; =============== S U B	R O U T	I N E =======================================
  9559                                  
  9560                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9561                                  ; registers
  9562                                  
  9563                                  DSTRLEN:
  9564 00001E81 50                      		push	ax
  9565 00001E82 31C9                    		xor	cx,cx
  9566 00001E84 FC                      		cld
  9567                                  DLOOP:
  9568 00001E85 AC                      		lodsb
  9569 00001E86 41                      		inc	cx
  9570 00001E87 08C0                    		or	al,al
  9571 00001E89 75FA                    		jnz	short DLOOP
  9572 00001E8B 29CE                    		sub	si,cx
  9573 00001E8D 58                      		pop	ax
  9574                                  TRIAGEERR_RETN:
  9575 00001E8E C3                      		retn
  9576                                  
  9577                                  ; =============== S U B	R O U T	I N E =======================================
  9578                                  
  9579                                  ;Break	<Extended error support>
  9580                                  
  9581                                  TriageError:  ; MSDOS 6.0
  9582                                  
  9583                                  ;
  9584                                  ; TriageError will examine the return from a carry-set system call and
  9585                                  ; return the correct error if applicable.
  9586                                  ;
  9587                                  ;   Inputs:	outputs from a carry-settable system call
  9588                                  ;		No system calls may be done in the interrim
  9589                                  ;   Outputs:	If carry was set on input
  9590                                  ;		    carry set on output
  9591                                  ;		    DX contains trangroup offset to printf message
  9592                                  ;		else
  9593                                  ;		    No registers changed
  9594                                  ;
  9595                                  
  9596                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9597                                  
  9598                                  GET_EXT_ERR_NUMBER:
  9599 00001E8F 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9600 00001E91 9C                      		pushf
  9601 00001E92 53                      		push	bx
  9602 00001E93 51                      		push	cx
  9603 00001E94 56                      		push	si
  9604 00001E95 57                      		push	di
  9605 00001E96 55                      		push	bp
  9606 00001E97 06                      		push	es
  9607 00001E98 1E                      		push	ds
  9608 00001E99 50                      		push	ax
  9609 00001E9A 52                      		push	dx
  9610                                  		;mov	ah,59h
  9611 00001E9B B459                    		mov	ah,GETEXTENDEDERROR
  9612 00001E9D CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9613                                  				; BX = version code (0000h for DOS 3.x)
  9614 00001E9F 59                      		pop	cx
  9615 00001EA0 5B                      		pop	bx		; restore original AX
  9616 00001EA1 BA[7D37]                		mov	dx,ACCDENPTR
  9617 00001EA4 83F841                  		cmp	ax,65		; network access denied?
  9618 00001EA7 7404                    		je	short NOMOVE	; Yes, return it.
  9619 00001EA9 89D8                    		mov	ax,bx
  9620 00001EAB 89CA                    		mov	dx,cx
  9621                                  NOMOVE:
  9622 00001EAD 1F                      		pop	ds
  9623 00001EAE 07                      		pop	es
  9624 00001EAF 5D                      		pop	bp
  9625 00001EB0 5F                      		pop	di
  9626 00001EB1 5E                      		pop	si
  9627 00001EB2 59                      		pop	cx
  9628 00001EB3 5B                      		pop	bx
  9629 00001EB4 9D                      		popf
  9630 00001EB5 C3                      		retn
  9631                                  
  9632                                  ; =============== S U B	R O U T	I N E =======================================
  9633                                  
  9634                                  		; Far call from resident portion/segment of COMMAND.COM
  9635                                  
  9636                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9637                                  
  9638                                  TRIAGE_INIT:
  9639                                  		;call	TriageError
  9640 00001EB6 E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9641 00001EB9 CB                      		retf
  9642                                  
  9643                                  ;============================================================================
  9644                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9645                                  ;============================================================================
  9646                                  ; 03/10/2018 - Retro DOS v3.0
  9647                                  
  9648                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9649                                  
  9650                                  ; =============== S U B	R O U T	I N E =======================================
  9651                                  
  9652                                  SINGLETEST:
  9653 00001EBA 1E                      		push	ds
  9654 00001EBB 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  9655 00001EC0 833EF50B00              		cmp	word [SINGLECOM],0
  9656 00001EC5 7406                    		jz	short TESTDONE
  9657 00001EC7 813EF50BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9658                                  TESTDONE:
  9659 00001ECD 1F                      		pop	ds
  9660 00001ECE C3                      		retn
  9661                                  
  9662                                  ; =============== S U B	R O U T	I N E =======================================
  9663                                  
  9664                                  SETREST1:
  9665 00001ECF B001                    		mov	al,1
  9666                                  
  9667                                  ; ---------------------------------------------------------------------------
  9668                                  
  9669                                  SETREST:
  9670 00001ED1 1E                      		push	ds
  9671 00001ED2 8E1E[B141]              		mov	ds,[RESSEG]
  9672 00001ED6 A2F30B                  		mov	[RESTDIR],al
  9673 00001ED9 1F                      		pop	ds
  9674 00001EDA C3                      		retn
  9675                                  
  9676                                  ; =============== S U B	R O U T	I N E =======================================
  9677                                  
  9678                                  ; Note that we need to handle the same thing that RestDir handles: the
  9679                                  ; requirement that we try only once to restore the user's environment after
  9680                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9681                                  ; disappear, we just give up.
  9682                                  
  9683                                  PIPEDEL:
  9684 00001EDB 1E                      		push	ds
  9685 00001EDC 52                      		push	dx
  9686 00001EDD 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
  9687 00001EE2 BA5E0C                  		mov	dx,PIPE1	; Clean up in case ^C
  9688 00001EE5 B441                    		mov	ah,UNLINK ; 41h 
  9689 00001EE7 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9690                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9691                                  				;		(no wildcards allowed)
  9692 00001EE9 BA6E0C                  		mov	dx,PIPE2
  9693 00001EEC B441                    		mov	ah,UNLINK ; 41h
  9694 00001EEE CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9695                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9696                                  				;		(no wildcards allowed)
  9697 00001EF0 5A                      		pop	dx
  9698 00001EF1 E83C04                  		call	PIPEOFF
  9699 00001EF4 C6065D0C00              		mov	byte [PIPEFILES],0
  9700 00001EF9 1F                      		pop	ds
  9701 00001EFA C3                      		retn
  9702                                  
  9703                                  ; ---------------------------------------------------------------------------
  9704                                  
  9705                                  PIPEERRSYN:
  9706 00001EFB BA[D83B]                		mov	dx,SYNTMESPTR
  9707 00001EFE E8DAFF                  		call	PIPEDEL
  9708 00001F01 0E                      		push	cs
  9709 00001F02 1F                      		pop	ds
  9710 00001F03 E9FAFC                  		jmp	CERROR
  9711                                  
  9712                                  ; ---------------------------------------------------------------------------
  9713                                  
  9714                                  PIPERR:
  9715 00001F06 9C                      		pushf
  9716                                  		;invoke	TRIAGEERROR
  9717 00001F07 E885FF                  		call	GET_EXT_ERR_NUMBER
  9718 00001F0A 50                      		push	ax		; Save results from TriageError
  9719 00001F0B 52                      		push	dx
  9720 00001F0C BA[323C]                		mov	dx,PIPEEMESPTR
  9721 00001F0F E8C9FF                  		call	PIPEDEL
  9722 00001F12 0E                      		push	cs
  9723 00001F13 1F                      		pop	ds
  9724 00001F14 E83415                  		call	STD_EPRINTF
  9725 00001F17 5A                      		pop	dx		; Restore results from TriageError
  9726 00001F18 58                      		pop	ax
  9727 00001F19 9D                      		popf
  9728 00001F1A 83F841                  		cmp	ax,65
  9729 00001F1D 7503                    		jnz	short TCOMMANDJ
  9730 00001F1F E9DEFC                  		jmp	CERROR
  9731                                  
  9732                                  TCOMMANDJ:
  9733 00001F22 E9DFE1                  		jmp	TCOMMAND
  9734                                  
  9735                                  PIPEPROCSTRT:
  9736 00001F25 8E1E[B141]              		mov	ds,[RESSEG]
  9737 00001F29 FE065D0C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9738                                  
  9739                                  		; MSDOS 6.0
  9740                                  		;push	es
  9741                                  		;push	di
  9742                                  		;push	ds
  9743                                  		;push	si
  9744                                  		;
  9745                                  		;push	ds
  9746                                  		;push	es
  9747                                  		;pop	ds				;ds = TRANGROUP
  9748                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9749                                  ;
  9750                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9751                                  ;so the routine is not really general
  9752                                  ;
  9753                                  		;call	Find_Name_In_Environment	;es:di points at path
  9754                                  		;pop	ds				;ds = DATARES again
  9755                                  		;jc	no_temp_path
  9756                                  		;
  9757                                  		;push	ds
  9758                                  		;push	es
  9759                                  		;pop	ds
  9760                                  		;pop	es				;swap ds and es
  9761                                  		;mov	si,di				;ds:si points at path
  9762                                  		;
  9763                                  		;call	skip_white			;skip white space chars
  9764                                  ;
  9765                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9766                                  ;
  9767                                  		;call	copy_pipe_path			;copy the pipe path
  9768                                  		;
  9769                                  ;
  9770                                  ;Check if the TEMP path is valid
  9771                                  ;
  9772                                  		;push	es
  9773                                  		;pop	ds				;ds = DATARES
  9774                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9775                                  		;mov	ax, (CHMOD shl 8) or 0
  9776                                  		;int	21h
  9777                                  		;jc	no_temp_path
  9778                                  		;
  9779                                  		;test	cx,10h				;is it a directory?
  9780                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9781                                  		;
  9782                                  		;stc					;no, indicate fail
  9783                                  no_temp_path:
  9784                                  		;pop	si
  9785                                  		;pop	ds
  9786                                  		;pop	di
  9787                                  		;pop	es
  9788                                  		;jnc	crt_temp			;path found, create tempfiles
  9789                                  
  9790                                  		; MSDOS 3.3
  9791 00001F2D B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9792 00001F2F CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9793                                  		;add	al,[cs:CAPITAL_A]
  9794                                  		; 01/03/2023
  9795 00001F31 0441                    		add	al,capital_A  ; add al,'A'
  9796 00001F33 A26E0C                  		mov	[PIPE2],al		; Make pipe files in root of def drv
  9797 00001F36 BB5E0C                  		mov	bx,PIPE1
  9798 00001F39 8807                    		mov	[bx],al
  9799 00001F3B 30E4                    		xor	ah,ah			; nul terminate path names
  9800 00001F3D 8826610C                		mov	[PIPE1+3],ah
  9801 00001F41 8826710C                		mov	[PIPE2+3],ah
  9802                                  
  9803                                  		; MSDOS 6.0
  9804                                  ;SR;
  9805                                  ; We want to create temp files in the current directory rather than in the 
  9806                                  ;root of the drive. This is because the number of files that can be present
  9807                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9808                                  ;
  9809                                  		;mov	ah,'.'
  9810                                  		;mov	Pipe1,ah
  9811                                  		;mov	Pipe2,ah
  9812                                  		;xor	ah,ah
  9813                                  		;mov	Pipe1+1,ah
  9814                                  		;mov	Pipe2+1,ah		;create files in current dir
  9815                                  
  9816                                  ;crt_temp:
  9817                                  		; MSDOS 6.0
  9818                                  		;mov	dx,offset DATARES:Pipe1
  9819                                  		;mov	dx,PIPE1
  9820                                  	
  9821                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9822 00001F45 89DA                    		mov	dx,bx
  9823 00001F47 31C9                    		xor	cx,cx
  9824 00001F49 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9825 00001F4B CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9826                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9827                                  			; receive generated filename
  9828                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9829 00001F4D 72B7                    		jc	short PIPERR	; Couldn't create
  9830 00001F4F 89C3                    		mov	bx,ax
  9831 00001F51 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9832 00001F53 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9833                                  				; BX = file handle
  9834 00001F55 BA6E0C                  		mov	dx,PIPE2
  9835 00001F58 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9836 00001F5A CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9837                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9838                                  			; receive generated filename
  9839                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9840 00001F5C 72A8                    		jc	short PIPERR
  9841 00001F5E 89C3                    		mov	bx,ax
  9842 00001F60 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9843 00001F62 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9844                                  					; BX = file handle
  9845                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9846 00001F64 E887FE                  		call	TESTDOREIN
  9847 00001F67 8B367E0C                		mov	si,[PIPEPTR]
  9848 00001F6B 833EF50BFF              		cmp	word [SINGLECOM],-1
  9849 00001F70 7506                    		jne	short NOSINGP
  9850 00001F72 C706F50B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9851                                  NOSINGP:
  9852 00001F78 EB26                    		jmp	short FIRSTPIPE
  9853                                  
  9854                                  ; ---------------------------------------------------------------------------
  9855                                  
  9856                                  PIPEPROC:
  9857 00001F7A 8026EF0BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9858 00001F7F 8B367E0C                		mov	si,[PIPEPTR]
  9859 00001F83 AC                      		lodsb
  9860                                  		;cmp	al,'|'		
  9861 00001F84 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9862                                  		; 01/03/2023
  9863                                  		;je	short ISPIPE1	; Yes
  9864                                  		;;cmp	al,[cs:VBAR]
  9865                                  		;cmp	al,vbar  ; '|'
  9866                                  		; 01/03/2023
  9867                                  		;je	short ISPIPE1
  9868                                  		;jmp	PIPEEND		; Pipe done
  9869 00001F86 757A                    		jne	short PIPEEND
  9870                                  ISPIPE1:
  9871 00001F88 8B16010D                		mov	dx,[INPIPEPTR] ; Get the input file name
  9872 00001F8C B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9873 00001F8F CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9874                                  				; DS:DX	-> ASCIZ filename
  9875                                  				; AL = access mode
  9876                                  				; 0 - read
  9877                                  PIPEERRJ:
  9878 00001F91 7303                    		jnc	short NO_PIPEERR
  9879 00001F93 E970FF                  		jmp	PIPERR		; Lost the pipe file
  9880                                  NO_PIPEERR:
  9881 00001F96 89C3                    		mov	bx,ax
  9882 00001F98 B0FF                    		mov	al,0FFh
  9883                                  		;xchg	al,[bx+18h]
  9884 00001F9A 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9885 00001F9D A21800                  		mov	[PDB.JFN_TABLE],al ; Redirect
  9886                                  FIRSTPIPE:
  9887 00001FA0 BF[1240]                		mov	di,COMBUF+2
  9888 00001FA3 31C9                    		xor	cx,cx
  9889 00001FA5 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9890 00001FA8 7503                    		jne	short PIPEOK1
  9891                                  PIPEERRSYNJ:
  9892 00001FAA E94EFF                  		jmp	PIPEERRSYN
  9893                                  PIPEOK1:
  9894                                  		; 01/03/2023
  9895                                  		;;mov	al,[cs:VBAR]
  9896                                  		;mov	al,vbar ; '|'
  9897                                  		;cmp	[si],al		; '||'
  9898                                  		;je	short PIPEERRSYNJ
  9899                                  		;cmp	byte [si],'|'
  9900 00001FAD 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9901 00001FB0 74F8                    		je	short PIPEERRSYNJ
  9902                                  PIPECOMLP:
  9903 00001FB2 AC                      		lodsb
  9904 00001FB3 AA                      		stosb
  9905 00001FB4 3C0D                    		cmp	al,0Dh
  9906 00001FB6 7438                    		je	short LASTPIPE
  9907 00001FB8 41                      		inc	cx
  9908                                  		;cmp	al,'|'
  9909 00001FB9 3C7C                    		cmp	al,ALTPIPECHR
  9910                                  		; 01/03/2023
  9911                                  		;je	short ISPIPE2
  9912                                  		;;cmp	al,[cs:VBAR]
  9913                                  		;cmp	al,vbar ; '|'
  9914 00001FBB 75F5                    		jne	short PIPECOMLP
  9915                                  ISPIPE2:
  9916 00001FBD 26C645FF0D              		mov	byte [es:di-1],0Dh
  9917 00001FC2 49                      		dec	cx
  9918 00001FC3 2E880E[1140]            		mov	[cs:COMBUF+1],cl
  9919 00001FC8 4E                      		dec	si
  9920 00001FC9 89367E0C                		mov	[PIPEPTR],si	; On to next pipe element
  9921 00001FCD 8B16030D                		mov	dx,[OUTPIPEPTR]
  9922 00001FD1 51                      		push	cx
  9923 00001FD2 31C9                    		xor	cx,cx
  9924 00001FD4 B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9925 00001FD7 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9926                                  				; CX = attributes for file
  9927                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9928 00001FD9 59                      		pop	cx
  9929 00001FDA 72B5                    		jc	short PIPEERRJ		; Lost the file
  9930 00001FDC 89C3                    		mov	bx,ax
  9931 00001FDE B0FF                    		mov	al,0FFh
  9932                                  		;xchg	al,[bx+18h]
  9933 00001FE0 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9934 00001FE3 A21900                  		mov	[PDB.JFN_TABLE+1],al
  9935 00001FE6 8716010D                		xchg	dx,[INPIPEPTR]	; Swap for next element of pipe
  9936 00001FEA 8916030D                		mov	[OUTPIPEPTR],dx
  9937 00001FEE EB0D                    		jmp	short PIPECOM
  9938                                  LASTPIPE:
  9939 00001FF0 2E880E[1140]            		mov	[cs:COMBUF+1],cl 
  9940 00001FF5 4E                      		dec	si
  9941 00001FF6 89367E0C                		mov	[PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9942 00001FFA E83FFE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9943                                  PIPECOM:
  9944 00001FFD 0E                      		push	cs
  9945 00001FFE 1F                      		pop	ds
  9946 00001FFF E9B6E2                  		jmp	NOPIPEPROC	; Process the pipe element
  9947                                  PIPEEND:
  9948 00002002 E8D6FE                  		call	PIPEDEL
  9949 00002005 813EF50B00F0            		cmp	word [SINGLECOM],0F000h
  9950 0000200B 7506                    		jnz	short NOSINGP2
  9951 0000200D C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
  9952                                  NOSINGP2:
  9953 00002013 E9EEE0                  		jmp	TCOMMAND
  9954                                  
  9955                                  ; =============== S U B	R O U T	I N E =======================================
  9956                                  
  9957                                  ; Date and time are set during initialization and use
  9958                                  ; this routines since they need to do a long return
  9959                                  
  9960                                  DATINIT:
  9961 00002016 2E8C1E[B141]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
  9962 0000201B 06                      		push	es
  9963 0000201C 1E                      		push	ds		; Going to use the previous stack
  9964 0000201D 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
  9965 0000201F 8EC0                    		mov	es,ax
  9966 00002021 8ED8                    		mov	ds,ax
  9967                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
  9968 00002023 BA[384C]                		mov	dx,INTERNATVARS
  9969 00002026 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  9970 00002029 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9971                                  				; get current-country info
  9972                                  				; DS:DX	-> buffer for returned info
  9973                                  		; 20/10/2018
  9974 0000202B C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
  9975 00002031 C606[1040]80            		mov	byte [COMBUF],128 ; Init COMBUF
  9976 00002036 C706[1140]010D          		mov	word [COMBUF+1],0D01h
  9977 0000203C E86C00                  		call	DATE
  9978 0000203F E87C01                  		call	CTIME
  9979 00002042 1F                      		pop	ds
  9980 00002043 07                      		pop	es
  9981 00002044 CB                      		retf
  9982                                  
  9983                                  ; =============== S U B	R O U T	I N E =======================================
  9984                                  
  9985                                  ; MSDOS 6.0
  9986                                  
  9987                                  ; ****************************************************************
  9988                                  ; *
  9989                                  ; * ROUTINE:	 DATE - Set system date
  9990                                  ; *
  9991                                  ; * FUNCTION:	 If a date is specified, set the system date,
  9992                                  ; *		 otherwise display the current system date and
  9993                                  ; *		 prompt the user for a new date.  If an invalid
  9994                                  ; *		 date is specified, issue an error message and
  9995                                  ; *		 prompt for a new date.  If the user enters
  9996                                  ; *		 nothing when prompted for a date, terminate.
  9997                                  ; *
  9998                                  ; * INPUT:	 command line at offset 81H
  9999                                  ; *
 10000                                  ; * OUTPUT:	 none
 10001                                  ; *
 10002                                  ; ****************************************************************
 10003                                  
 10004                                  ;assume	ds:trangroup,es:trangroup
 10005                                  ;
 10006                                  ;DATE:
 10007                                  ;	MOV	SI,81H				; Accepting argument for date inline
 10008                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get address of PARSE_DATE
 10009                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10010                                  ;	xor	dx,dx				;AN000;
 10011                                  ;	invoke	cmd_parse			;AC000; call parser
 10012                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10013                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
 10014                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10015                                  ;	jne	daterr				;AN000; yes - go issue message
 10016                                  ;	JMP	short COMDAT			;AC000; we have a date
 10017                                  ;
 10018                                  ;PRMTDAT:
 10019                                  ;	; Print "Current date is
 10020                                  ;
 10021                                  ;	invoke	GetDate 			;AN000; get date  for output
 10022                                  ;	xchg	dh,dl				;AN000; switch month & day
 10023                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
 10024                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
 10025                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
 10026                                  ;	invoke	std_printf
 10027                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
 10028                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
 10029                                  ;
 10030                                  ;GET_NEW_DATE:					;AN000;
 10031                                  ;	call	getdat				;AC000; prompt user for date
 10032                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10033                                  ;	jz	date_end			;AC000; yes - exit
 10034                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10035                                  ;	jne	daterr				;AN000; yes - go issue message
 10036                                  ;COMDAT:
 10037                                  ;	mov	cx,date_year			;AC000; get parts of date in
 10038                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
 10039                                  ;	mov	dl,date_day			;AC000;    date function call.
 10040                                  ;	push	cx				;AC000; save date
 10041                                  ;	push	dx				;AC000;
 10042                                  ;	mov	cx,1				;AC000; set 1 positional entered
 10043                                  ;	xor	dx,dx				;AN029;
 10044                                  ;	invoke	cmd_parse			;AN029; call parser
 10045                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10046                                  ;	pop	dx				;AC000; retrieve date
 10047                                  ;	pop	cx				;AC000;
 10048                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
 10049                                  ;	MOV	AH,SET_DATE			;yes - set date
 10050                                  ;	INT	21h
 10051                                  ;	OR	AL,AL
 10052                                  ;	JNZ	DATERR
 10053                                  ;date_end:
 10054                                  ;	ret
 10055                                  ;
 10056                                  ;DATERR:
 10057                                  ;	invoke	crlf2				;AN028; print out a blank line
 10058                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
 10059                                  ;	invoke	std_printf
 10060                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
 10061                                  
 10062                                  ; =============== S U B	R O U T	I N E =======================================
 10063                                  
 10064                                  ; MSDOS 6.0
 10065                                  
 10066                                  ; TIME gets and sets the time
 10067                                  
 10068                                  ; ****************************************************************
 10069                                  ; *
 10070                                  ; * ROUTINE:	 TIME - Set system time
 10071                                  ; *
 10072                                  ; * FUNCTION:	 If a time is specified, set the system time,
 10073                                  ; *		 otherwise display the current system time and
 10074                                  ; *		 prompt the user for a new time.  If an invalid
 10075                                  ; *		 time is specified, issue an error message and
 10076                                  ; *		 prompt for a new time.  If the user enters
 10077                                  ; *		 nothing when prompted for a time, terminate.
 10078                                  ; *
 10079                                  ; * INPUT:	 command line at offset 81H
 10080                                  ; *
 10081                                  ; * OUTPUT:	 none
 10082                                  ; *
 10083                                  ; ****************************************************************
 10084                                  
 10085                                  ;assume	ds:trangroup,es:trangroup
 10086                                  ;
 10087                                  ;CTIME:
 10088                                  ;	MOV	SI,81H				; Accepting argument for time inline
 10089                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get address of PARSE_time
 10090                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10091                                  ;	xor	dx,dx				;AN000;
 10092                                  ;	invoke	cmd_parse			;AC000; call parser
 10093                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10094                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
 10095                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10096                                  ;	jne	timerr				;AN000; yes - go issue message
 10097                                  ;	JMP	short COMTIM			;AC000; we have a time
 10098                                  ;
 10099                                  ;PRMTTIM:
 10100                                  ;	;Printf "Current time is ... "
 10101                                  ;
 10102                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10103                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10104                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10105                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10106                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10107                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10108                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10109                                  ;	invoke	std_printf
 10110                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10111                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10112                                  ;
 10113                                  ;GET_NEW_TIME:
 10114                                  ;	call	gettim				;AC000;
 10115                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10116                                  ;	jz	time_end			;AC000;
 10117                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10118                                  ;	jne	timerr				;AN000; yes - go issue message
 10119                                  ;
 10120                                  ;COMTIM:
 10121                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10122                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10123                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10124                                  ;	mov	dl,time_fraction		;AC000;
 10125                                  ;	push	cx				;AC000; save time
 10126                                  ;	push	dx				;AC000;
 10127                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10128                                  ;	xor	dx,dx				;AN029;
 10129                                  ;	invoke	cmd_parse			;AN029; call parser
 10130                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10131                                  ;	pop	dx				;AC000; retieve time
 10132                                  ;	pop	cx				;AC000;
 10133                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10134                                  ;
 10135                                  ;SAVTIM:
 10136                                  ;	MOV	AH,SET_TIME
 10137                                  ;	INT	21h
 10138                                  ;	OR	AL,AL
 10139                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10140                                  ;
 10141                                  ;TIME_END:
 10142                                  ;
 10143                                  ;	ret
 10144                                  ;
 10145                                  ;TIMERR:
 10146                                  ;	invoke	crlf2				;AN028; print out a blank line
 10147                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10148                                  ;	invoke	std_printf			; Print error message
 10149                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10150                                  
 10151                                  ; =============== S U B	R O U T	I N E =======================================
 10152                                  
 10153                                  ; MSDOS 6.0
 10154                                  
 10155                                  ;
 10156                                  ; Set the special flag in the INIT flag to the value in CX.
 10157                                  ;
 10158                                  
 10159                                  ;SetInitFlag:
 10160                                  ;	mov	ds,[RESSEG]
 10161                                  ;assume ds:resgroup
 10162                                  ;	and	InitFlag,NOT initSpecial
 10163                                  ;	or	InitFlag,cL
 10164                                  ;	push	cs
 10165                                  ;	pop	ds
 10166                                  ;	return
 10167                                  ;
 10168                                  ;Public	PipeOff
 10169                                  ;PipeOff:
 10170                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10171                                  ;	SaveReg <DS,AX>
 10172                                  ;	MOV	DS,ResSeg
 10173                                  ;	ASSUME	DS:RESGroup
 10174                                  ;	XOR	AL,AL
 10175                                  ;	XCHG	PipeFlag,AL
 10176                                  ;	OR	AL,AL
 10177                                  ;	JZ	PipeOffDone
 10178                                  ;	SHR	EchoFlag,1
 10179                                  ;PipeOffDone:
 10180                                  ;	RestoreReg  <AX,DS>
 10181                                  ;	return
 10182                                  
 10183                                  ; =============== S U B	R O U T	I N E =======================================
 10184                                  
 10185                                  ; MSDOS 6.0
 10186                                  
 10187                                  ;PRINT_TIME:
 10188                                  ;
 10189                                  ;	MOV	AH,GET_TIME
 10190                                  ;	INT	21h			; Get time in CX:DX
 10191                                  ;
 10192                                  ;	PUSH	ES
 10193                                  ;	PUSH	CS
 10194                                  ;	POP	ES
 10195                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10196                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10197                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10198                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10199                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10200                                  ;	invoke	std_printf
 10201                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10202                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10203                                  ;
 10204                                  ;	POP	ES
 10205                                  ;	return
 10206                                  
 10207                                  ; =============== S U B	R O U T	I N E =======================================
 10208                                  
 10209                                  ; MSDOS 6.0
 10210                                  
 10211                                  ; ****************************************************************
 10212                                  ; *
 10213                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10214                                  ; *
 10215                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10216                                  ; *		 INFORMATION and issues the "Enter new date"
 10217                                  ; *		 message with the proper date format.  COMBUF
 10218                                  ; *		 is reset to get a date from the command line.
 10219                                  ; *		 The PARSE_DATE blocks are then reset and the
 10220                                  ; *		 PARSE function call is issued.
 10221                                  ; *
 10222                                  ; * INPUT:	 NONE
 10223                                  ; *
 10224                                  ; * OUTPUT:	 COMBUF
 10225                                  ; *		 PARSER RETURN CODES
 10226                                  ; *
 10227                                  ; ****************************************************************
 10228                                  
 10229                                  ;GETDAT	proc	near				;AC000;
 10230                                  ;
 10231                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10232                                  ;	mov	dx,5ch				;  should be entered in and
 10233                                  ;	int	21h			;  print a message describing it
 10234                                  ;	mov	si,dx
 10235                                  ;	lodsw
 10236                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10237                                  ;	dec	ax
 10238                                  ;	js	printformat
 10239                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10240                                  ;	jz	printformat
 10241                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10242                                  ;printformat:
 10243                                  ;	mov	ax,dx				;AN000; get message number of format
 10244                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10245                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10246                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10247                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10248                                  ;	invoke	std_printf
 10249                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10250                                  ;
 10251                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10252                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10253                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10254                                  ;	call	SetInitFlag			;  prompting for date.
 10255                                  ;	INT	21h			; Get input line
 10256                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10257                                  ;	call	SetInitFlag			;  prompting for date.
 10258                                  ;	invoke	CRLF2
 10259                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10260                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get address of PARSE_DATE
 10261                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10262                                  ;	xor	dx,dx				;AN000;
 10263                                  ;	invoke	cmd_parse			;AC000; call parser
 10264                                  ;
 10265                                  ;	ret
 10266                                  ;
 10267                                  ;GETDAT	endp					;AC000;
 10268                                  
 10269                                  ; =============== S U B	R O U T	I N E =======================================
 10270                                  
 10271                                  ; MSDOS 6.0
 10272                                  
 10273                                  ; ****************************************************************
 10274                                  ; *
 10275                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10276                                  ; *
 10277                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10278                                  ; *		 INFORMATION and issues the "Enter new time"
 10279                                  ; *		 message. COMBUF is reset to get a time from the
 10280                                  ; *		 command line.	The PARSE_TIME blocks are then
 10281                                  ; *		 reset and the PARSE function call is issued.
 10282                                  ; *
 10283                                  ; * INPUT:	 NONE
 10284                                  ; *
 10285                                  ; * OUTPUT:	 COMBUF
 10286                                  ; *		 PARSER RETURN CODES
 10287                                  ; *
 10288                                  ; ****************************************************************
 10289                                  
 10290                                  ;GETTIM	proc	near				;AC000;
 10291                                  ;
 10292                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10293                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10294                                  ;	invoke	std_printf
 10295                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10296                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10297                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10298                                  ;	call	SetInitFlag			;  prompting for time.
 10299                                  ;	INT	21h			; Get input line
 10300                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10301                                  ;	call	SetInitFlag			;  prompting for time.
 10302                                  ;	invoke	CRLF2
 10303                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10304                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get address of PARSE_TIME
 10305                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10306                                  ;	xor	dx,dx				;AN000;
 10307                                  ;	invoke	cmd_parse			;AC000; call parser
 10308                                  ;
 10309                                  ;	ret
 10310                                  ;
 10311                                  ;GETTIM	endp					;AC000;
 10312                                  
 10313                                  ; =============== S U B	R O U T	I N E =======================================
 10314                                  
 10315                                  ; MSDOS 6.0
 10316                                  
 10317                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10318                                  ;the '=' sign in the environment variable before the actual path.
 10319                                  ;
 10320                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10321                                  ;
 10322                                  ;	EXIT:	ds:si = start of the path
 10323                                  ;
 10324                                  ;	REGISTERS AFFECTED: ax
 10325                                  ;
 10326                                  
 10327                                  ;Skip_white	proc	near
 10328                                  ;
 10329                                  ;	cld
 10330                                  ;skw_lp:
 10331                                  ;	lodsb
 10332                                  ;	cmp	al,' '				;blank char?
 10333                                  ;	jz	skw_lp				;yes, skip it
 10334                                  ;	cmp	al,09				;tab char?
 10335                                  ;	jz	skw_lp				;yes, skip it
 10336                                  ;
 10337                                  ;	dec	si				;point at first non-white
 10338                                  ;
 10339                                  ;	ret
 10340                                  ;
 10341                                  ;Skip_white	endp
 10342                                  
 10343                                  ; =============== S U B	R O U T	I N E =======================================
 10344                                  
 10345                                  ; MSDOS 6.0
 10346                                  
 10347                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10348                                  ;variable into the path buffers Pipe1 & Pipe2.
 10349                                  ;
 10350                                  ;	ENTRY:	ds:si = path to be copied
 10351                                  ;		es = RESGROUP
 10352                                  ;
 10353                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10354                                  ;
 10355                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10356                                  ;
 10357                                  
 10358                                  ;Copy_pipe_path	proc	near
 10359                                  ;
 10360                                  ;	mov	cx,0ffffh
 10361                                  ;	xor	al,al
 10362                                  ;
 10363                                  ;	mov	di,si
 10364                                  ;	push	es			;save es
 10365                                  ;	push	ds
 10366                                  ;	pop	es			;es:di = path to be copied
 10367                                  ;	
 10368                                  ;	cld
 10369                                  ;	push	di
 10370                                  ;	repnz	scasb			;look for the null char
 10371                                  ;	pop	di
 10372                                  ;
 10373                                  ;	pop	es			;es = RESGROUP again
 10374                                  ;
 10375                                  ;	not	cx			;length including the null
 10376                                  ;
 10377                                  ;	mov	di,offset DATARES:Pipe1	
 10378                                  ;	push	di
 10379                                  ;	push	cx			
 10380                                  ;	rep	movsb			;copy path into Pipe1
 10381                                  ;	pop	cx
 10382                                  ;	pop	di
 10383                                  ;
 10384                                  ;	push	ds
 10385                                  ;	push	es
 10386                                  ;	pop	ds			;ds:si = Pipe1
 10387                                  ;	mov	si,di
 10388                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10389                                  ;	rep	movsb			;copy path into Pipe2
 10390                                  ;	pop	ds
 10391                                  ;
 10392                                  ;	ret				;
 10393                                  ;
 10394                                  ;Copy_pipe_path	endp
 10395                                  
 10396                                  ;============================================================================
 10397                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10398                                  ;============================================================================
 10399                                  ; 05/10/2018 - Retro DOS v3.0
 10400                                  
 10401                                  ; DATE - Gets and sets the time
 10402                                  
 10403                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10404                                  
 10405                                  ; =============== S U B	R O U T	I N E =======================================
 10406                                  
 10407                                  DATE_CXDX:
 10408 00002045 89CB                    		mov	bx,cx
 10409                                  
 10410                                  ; =============== S U B	R O U T	I N E =======================================
 10411                                  
 10412                                  P_DATE:
 10413 00002047 89D8                    		mov	ax,bx
 10414 00002049 89D1                    		mov	cx,dx
 10415 0000204B B264                    		mov	dl,100
 10416 0000204D F6F2                    		div	dl
 10417 0000204F 86C4                    		xchg	al,ah
 10418 00002051 92                      		xchg	ax,dx
 10419 00002052 B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10420                                  		;mov	ax,[INTERNATVARS]
 10421 00002054 A1[384C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10422 00002057 09C0                    		or	ax,ax
 10423 00002059 7415                    		jz	short USPDAT
 10424 0000205B 48                      		dec	ax
 10425 0000205C 7422                    		jz	short EUPDAT
 10426 0000205E B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10427 00002060 E83900                  		call	P_YR
 10428 00002063 E82B00                  		call	P_DSEP
 10429 00002066 E82200                  		call	P_MON
 10430 00002069 E82500                  		call	P_DSEP
 10431 0000206C E82700                  		call	P_DAY
 10432 0000206F C3                      		retn
 10433                                  
 10434                                  USPDAT:
 10435 00002070 E81800                  		call	P_MON
 10436 00002073 E81B00                  		call	P_DSEP
 10437 00002076 E81D00                  		call	P_DAY
 10438                                  PLST:
 10439 00002079 E81500                  		call	P_DSEP
 10440 0000207C E81D00                  		call	P_YR
 10441 0000207F C3                      		retn
 10442                                  
 10443                                  EUPDAT:
 10444 00002080 E81300                  		call	P_DAY
 10445 00002083 E80B00                  		call	P_DSEP
 10446 00002086 E80200                  		call	P_MON
 10447 00002089 EBEE                    		jmp	short PLST
 10448                                  
 10449                                  ; ---------------------------------------------------------------------------
 10450                                  
 10451                                  P_MON:
 10452 0000208B 88E8                    		mov	al,ch
 10453 0000208D E87F02                  		call	OUT2
 10454 00002090 C3                      		retn
 10455                                  
 10456                                  ; ---------------------------------------------------------------------------
 10457                                  
 10458                                  P_DSEP:
 10459                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10460 00002091 A0[434C]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10461 00002094 AA                      		stosb
 10462 00002095 C3                      		retn
 10463                                  
 10464                                  ; ---------------------------------------------------------------------------
 10465                                  
 10466                                  P_DAY:
 10467 00002096 88C8                    		mov	al,cl
 10468 00002098 E87402                  		call	OUT2
 10469 0000209B C3                      		retn
 10470                                  
 10471                                  ; ---------------------------------------------------------------------------
 10472                                  
 10473                                  P_YR:
 10474 0000209C 88F0                    		mov	al,dh
 10475 0000209E 08C0                    		or	al,al
 10476 000020A0 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10477 000020A2 E86A02                  		call	OUT2
 10478                                  TWODIGYR:
 10479 000020A5 88D0                    		mov	al,dl
 10480 000020A7 E86502                  		call	OUT2
 10481                                  DATE_RETN:
 10482 000020AA C3                      		retn
 10483                                  
 10484                                  ; =============== S U B	R O U T	I N E =======================================
 10485                                  
 10486                                  DATE:				 	; Accepting argument for date inline
 10487 000020AB BE8100                  		mov	si,81h
 10488 000020AE E8A7F8                  		call	SCANOFF
 10489 000020B1 3C0D                    		cmp	al,0Dh
 10490 000020B3 7402                    		jz	short PRMTDAT
 10491 000020B5 EB48                    		jmp	short COMDAT
 10492                                  
 10493                                  		;nop
 10494                                  
 10495                                  PRMTDAT:
 10496                                  		; MSDOS 3.3
 10497 000020B7 BA[BB39]                		mov	dx,CURDATPTR
 10498 000020BA E89713                  		call	STD_PRINTF	; Print "Current date is "	
 10499 000020BD E87D08                  		call	PRINT_DATE
 10500                                  
 10501                                  GETDAT:	
 10502 000020C0 BA[CF39]                		mov	dx,NEWDATPTR
 10503 000020C3 E88E13                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10504                                  
 10505 000020C6 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10506                                  					; Determine what format the date
 10507 000020C9 BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10508 000020CC CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10509                                  				; get current-country info
 10510                                  				; DS:DX	-> buffer for returned info
 10511 000020CE 89D6                    		mov	si,dx		;  print a message describing it
 10512 000020D0 AD                      		lodsw
 10513 000020D1 BA[DE39]                		mov	dx,USADATPTR	; get mm-dd-yy
 10514 000020D4 48                      		dec	ax
 10515 000020D5 7808                    		js	short PRINTFORMAT
 10516 000020D7 BA[ED39]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10517 000020DA 7403                    		jz	short PRINTFORMAT
 10518 000020DC BA[FC39]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10519                                  PRINTFORMAT:
 10520 000020DF E87213                  		call	STD_PRINTF
 10521 000020E2 B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10522 000020E4 BA[1040]                		mov	dx,COMBUF
 10523 000020E7 B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10524 000020EA E83302                  		call	SETINITFLAG	;  prompting for date.
 10525 000020ED CD21                    		int	21h		; Get input line
 10526 000020EF 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10527 000020F1 E82C02                  		call	SETINITFLAG	;  prompting for date.
 10528 000020F4 E854F8                  		call	CRLF2
 10529 000020F7 BE[1240]                		mov	si,COMBUF+2
 10530 000020FA 803C0D                  		cmp	byte [si],0Dh
 10531 000020FD 74AB                    		jz	short DATE_RETN
 10532                                  COMDAT:
 10533                                  		;mov	ax,[INTERNATVARS]
 10534 000020FF A1[384C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10535 00002102 09C0                    		or	ax,ax
 10536 00002104 7435                    		jz	short USSDAT
 10537 00002106 48                      		dec	ax
 10538 00002107 744B                    		jz	short EUSDAT
 10539 00002109 E86500                  		call	GET_YR
 10540 0000210C 7235                    		jc	short DATERRJ
 10541 0000210E E89E00                  		call	GET_DSEP
 10542 00002111 7230                    		jc	short DATERRJ
 10543 00002113 E84D00                  		call	GET_MON
 10544 00002116 722B                    		jc	short DATERRJ
 10545 00002118 E89400                  		call	GET_DSEP
 10546 0000211B 7226                    		jc	short DATERRJ
 10547 0000211D E84B00                  		call	GET_DAY
 10548                                  DAT_SET:
 10549 00002120 7303                    		jnc	short DATSET
 10550 00002122 E98100                  		jmp	DATERR
 10551                                  
 10552                                  ; ---------------------------------------------------------------------------
 10553                                  
 10554                                  DATSET:
 10555 00002125 AC                      		lodsb
 10556 00002126 3C20                    		cmp	al,' '
 10557 00002128 74FB                    		jz	short DATSET
 10558 0000212A 3C09                    		cmp	al,9
 10559 0000212C 74F7                    		jz	short DATSET
 10560 0000212E 3C0D                    		cmp	al,0Dh
 10561 00002130 7574                    		jnz	short DATERR
 10562 00002132 B42B                    		mov	ah,SET_DATE ; 2Bh
 10563 00002134 CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10564                                  				; DL = day,DH = month,	CX = year
 10565                                  				; Return: AL = 00h if no error 
 10566                                  				; 	     = FFh if bad value sent to routine
 10567 00002136 08C0                    		or	al,al
 10568 00002138 756C                    		jnz	short DATERR
 10569                                  DAT_SET_RETN:
 10570 0000213A C3                      		retn
 10571                                  
 10572                                  ; ---------------------------------------------------------------------------
 10573                                  
 10574                                  USSDAT:
 10575 0000213B E82500                  		call	GET_MON
 10576 0000213E 7266                    		jb	short DATERR
 10577 00002140 E86C00                  		call	GET_DSEP
 10578                                  DATERRJ:
 10579 00002143 7261                    		jc	short DATERR
 10580 00002145 E82300                  		call	GET_DAY
 10581                                  TGET:
 10582 00002148 725C                    		jc	short DATERR
 10583 0000214A E86200                  		call	GET_DSEP
 10584 0000214D 7257                    		jc	short DATERR
 10585 0000214F E81F00                  		call	GET_YR
 10586 00002152 EBCC                    		jmp	short DAT_SET
 10587                                  
 10588                                  ; ---------------------------------------------------------------------------
 10589                                  
 10590                                  EUSDAT:
 10591 00002154 E81400                  		call	GET_DAY
 10592 00002157 724D                    		jc	short DATERR
 10593 00002159 E85300                  		call	GET_DSEP
 10594 0000215C 7248                    		jc	short DATERR
 10595 0000215E E80200                  		call	GET_MON
 10596 00002161 EBE5                    		jmp	short TGET
 10597                                  
 10598                                  
 10599                                  ; =============== S U B	R O U T	I N E =======================================
 10600                                  
 10601                                  GET_MON:
 10602 00002163 E88901                  		call	GETNUM		; Get one or two digit number
 10603 00002166 72D2                    		jc	short DAT_SET_RETN
 10604 00002168 88E6                    		mov	dh,ah		; Put in position
 10605 0000216A C3                      		retn
 10606                                  
 10607                                  
 10608                                  ; =============== S U B	R O U T	I N E =======================================
 10609                                  
 10610                                  GET_DAY:
 10611 0000216B E88101                  		call	GETNUM
 10612 0000216E 88E2                    		mov	dl,ah		; Put in position
 10613                                  GET_DAY_RETN:
 10614 00002170 C3                      		retn
 10615                                  
 10616                                  ; =============== S U B	R O U T	I N E =======================================
 10617                                  
 10618                                  GET_YR:
 10619 00002171 E87B01                  		call	GETNUM
 10620 00002174 72FA                    		jc	short GET_DAY_RETN
 10621 00002176 B96C07                  		mov	cx,1900
 10622 00002179 E83300                  		call	GET_DSEP
 10623 0000217C 9C                      		pushf
 10624 0000217D 4E                      		dec	si
 10625 0000217E 9D                      		popf
 10626 0000217F 741E                    		jz	short BIAS
 10627 00002181 803C0D                  		cmp	byte [si],0Dh
 10628 00002184 7419                    		je	short BIAS
 10629 00002186 803C20                  		cmp	byte [si],' '
 10630 00002189 7414                    		je	short BIAS
 10631 0000218B 803C09                  		cmp	byte [si],9
 10632 0000218E 740F                    		je	short BIAS
 10633 00002190 53                      		push	bx
 10634 00002191 B364                    		mov	bl,100
 10635 00002193 88E0                    		mov	al,ah
 10636 00002195 F6E3                    		mul	bl
 10637 00002197 5B                      		pop	bx
 10638 00002198 89C1                    		mov	cx,ax
 10639 0000219A E85201                  		call	GETNUM
 10640 0000219D 72D1                    		jc	short GET_DAY_RETN
 10641                                  BIAS:
 10642 0000219F 88E0                    		mov	al,ah
 10643 000021A1 B400                    		mov	ah,0
 10644 000021A3 01C1                    		add	cx,ax
 10645                                  BIAS_RETN:
 10646 000021A5 C3                      		retn
 10647                                  
 10648                                  ; ---------------------------------------------------------------------------
 10649                                  
 10650                                  DATERR:
 10651 000021A6 BA[A839]                		mov	dx,BADDATPTR
 10652 000021A9 E8A812                  		call	STD_PRINTF
 10653 000021AC E911FF                  		jmp	GETDAT
 10654                                  
 10655                                  ; =============== S U B	R O U T	I N E =======================================
 10656                                  
 10657                                  GET_DSEP:
 10658 000021AF AC                      		lodsb
 10659 000021B0 3C2F                    		cmp	al,'/'
 10660 000021B2 74F1                    		je	short BIAS_RETN
 10661                                  		;cmp	al,'.'
 10662                                  		;cmp	al,[DOT_CHR]
 10663                                  		; 01/03/2023
 10664 000021B4 3C2E                    		cmp	al,dot_chr ; cmp al,'.'
 10665 000021B6 74ED                    		je	short BIAS_RETN
 10666                                  		; 01/03/2023
 10667 000021B8 3C2D                    		cmp	al,'-'
 10668                                  		;cmp	al,[CHAR_SUB]
 10669 000021BA 74E9                    		je	short BIAS_RETN
 10670 000021BC F9                      		stc
 10671 000021BD C3                      		retn
 10672                                  
 10673                                  ; =============== S U B	R O U T	I N E =======================================
 10674                                  
 10675                                  ; TIME gets and sets the time
 10676                                  
 10677                                  CTIME:
 10678 000021BE BE8100                  		mov	si,81h		; Accepting argument for time inline
 10679 000021C1 E894F7                  		call	SCANOFF
 10680 000021C4 3C0D                    		cmp	al,0Dh
 10681 000021C6 747C                    		je	short PRMTTIM
 10682 000021C8 BB3A2E                  		mov	bx,2E3Ah ; ":."
 10683 000021CB E80501                  		call	INLINE
 10684 000021CE E98A00                  		jmp	COMTIM
 10685                                  
 10686                                  ; =============== S U B	R O U T	I N E =======================================
 10687                                  
 10688                                  PRINT_TIME:
 10689 000021D1 B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10690 000021D3 CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10691                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10692                                  				; DL = hundredths of seconds
 10693 000021D5 57                      		push	di
 10694 000021D6 06                      		push	es
 10695 000021D7 0E                      		push	cs
 10696 000021D8 07                      		pop	es
 10697 000021D9 BF[DB41]                		mov	di,CHARBUF
 10698 000021DC B301                    		mov	bl,1	; Always 24 hour time
 10699 000021DE E81300                  		call	P_TIME
 10700 000021E1 31C0                    		xor	ax,ax
 10701 000021E3 AA                      		stosb
 10702 000021E4 BA[DB41]                		mov	dx,CHARBUF
 10703 000021E7 8916[8E43]              		mov	[STRING_PTR_2],dx
 10704 000021EB BA[9F36]                		mov	dx,STRINGBUF2PTR
 10705 000021EE E86312                  		call	STD_PRINTF
 10706 000021F1 07                      		pop	es
 10707 000021F2 5F                      		pop	di
 10708                                  P_TIME_RETN:
 10709 000021F3 C3                      		retn
 10710                                  
 10711                                  ; =============== S U B	R O U T	I N E =======================================
 10712                                  
 10713                                  P_TIME:
 10714 000021F4 88E8                    		mov	al,ch	
 10715 000021F6 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10716 000021F9 7512                    		jnz	short T24	; 24 hr time?
 10717 000021FB B761                    		mov	bh,'a'		; Assume A.M.
 10718 000021FD 3C0C                    		cmp	al,12		; In the afternoon?
 10719 000021FF 7206                    		jb	short MORN
 10720 00002201 B770                    		mov	bh,'p'
 10721 00002203 7402                    		jz	short MORN
 10722 00002205 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10723                                  MORN:
 10724 00002207 08C0                    		or	al,al		; Before 1 am?
 10725 00002209 7502                    		jnz	short T24
 10726 0000220B B00C                    		mov	al,12
 10727                                  T24:
 10728 0000220D 53                      		push	bx
 10729 0000220E B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10730 00002210 E8FC00                  		call	OUT2
 10731 00002213 E82900                  		call	P_TSEP
 10732 00002216 88C8                    		mov	al,cl
 10733 00002218 E8F400                  		call	OUT2
 10734 0000221B 5B                      		pop	bx
 10735 0000221C 53                      		push	bx
 10736 0000221D F6C380                  		test	bl,80h
 10737 00002220 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10738 00002222 B700                    		mov	bh,0		; Disable leading zero suppression
 10739 00002224 E81800                  		call	P_TSEP
 10740 00002227 88F0                    		mov	al,dh
 10741 00002229 E8E300                  		call	OUT2
 10742                                  		;mov	al,'.'
 10743 0000222C A0[414C]                		mov	al,[DECIMAL_SEP]
 10744 0000222F AA                      		stosb
 10745 00002230 88D0                    		mov	al,dl
 10746 00002232 E8DA00                  		call	OUT2
 10747                                  PAP:
 10748 00002235 5B                      		pop	bx
 10749 00002236 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10750 00002239 75B8                    		jnz	short P_TIME_RETN
 10751 0000223B 88F8                    		mov	al,bh
 10752 0000223D AA                      		stosb
 10753 0000223E C3                      		retn
 10754                                  
 10755                                  ; =============== S U B	R O U T	I N E =======================================
 10756                                  
 10757                                  P_TSEP:
 10758                                  		;mov	al,[TIME_SEP]
 10759 0000223F A0[454C]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10760 00002242 AA                      		stosb
 10761                                  P_TSEP_RETN:
 10762 00002243 C3                      		retn
 10763                                  
 10764                                  ; ---------------------------------------------------------------------------
 10765                                  
 10766                                  PRMTTIM:
 10767 00002244 BA[213A]                		mov	dx,CURTIMPTR
 10768 00002247 E80A12                  		call	STD_PRINTF	; Print "Current time is "
 10769 0000224A E884FF                  		call	PRINT_TIME
 10770                                  GETTIM:
 10771 0000224D 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10772 0000224F BA[363A]                		mov	dx,NEWTIMPTR
 10773 00002252 E8FF11                  		call	STD_PRINTF
 10774                                  		;mov	bx,':.'
 10775                                  		;mov	bx,[TIMECHARS] 
 10776                                  		; 01/03/2023
 10777 00002255 BB3A2E                  		mov	bx,dot_colon ; mov bx,2E3Ah ; mov bx,':.'
 10778 00002258 E85B00                  		call	GETBUF
 10779                                  COMTIM:
 10780 0000225B 74E6                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10781 0000225D 724F                    		jc	short TIMEERR
 10782 0000225F 89D1                    		mov	cx,dx
 10783 00002261 31D2                    		xor	dx,dx
 10784 00002263 AC                      		lodsb
 10785 00002264 3C0D                    		cmp	al,0Dh
 10786 00002266 743E                    		je	short SAVTIM
 10787 00002268 3C20                    		cmp	al,' '
 10788 0000226A 742D                    		je	short GOTSEC2
 10789 0000226C 3C09                    		cmp	al,9
 10790 0000226E 7429                    		je	short GOTSEC2
 10791 00002270 38D8                    		cmp	al,bl
 10792 00002272 7404                    		je	short GOTSEC
 10793 00002274 38F8                    		cmp	al,bh
 10794 00002276 7536                    		jne	short TIMEERR
 10795                                  GOTSEC:
 10796 00002278 E87400                  		call	GETNUM
 10797 0000227B 7231                    		jc	short TIMEERR
 10798 0000227D 88E6                    		mov	dh,ah		; Position seconds
 10799 0000227F AC                      		lodsb
 10800 00002280 3C0D                    		cmp	al,0Dh
 10801 00002282 7422                    		je	short SAVTIM
 10802 00002284 3C20                    		cmp	al,' '
 10803 00002286 7411                    		je	short GOTSEC2
 10804 00002288 3C09                    		cmp	al,9
 10805 0000228A 740D                    		je	short GOTSEC2
 10806                                  		;cmp	al,'.'
 10807 0000228C 3A06[414C]              		cmp	al,[DECIMAL_SEP]
 10808 00002290 751C                    		jne	short TIMEERR
 10809 00002292 E85A00                  		call	GETNUM
 10810 00002295 7217                    		jc	short TIMEERR
 10811 00002297 88E2                    		mov	dl,ah
 10812                                  GOTSEC2:
 10813 00002299 AC                      		lodsb
 10814 0000229A 3C20                    		cmp	al,' '
 10815 0000229C 74FB                    		je	short GOTSEC2
 10816 0000229E 3C09                    		cmp	al,9
 10817 000022A0 74F7                    		je	short GOTSEC2
 10818 000022A2 3C0D                    		cmp	al,0Dh
 10819 000022A4 7508                    		jne	short TIMEERR
 10820                                  SAVTIM:
 10821 000022A6 B42D                    		mov	ah,SET_TIME ; 2Dh
 10822 000022A8 CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10823                                  				; CH = hours,CL = minutes,DH = seconds,
 10824                                  				;		DL = hundredths of seconds
 10825                                  				; Return: AL = 00h if no error 
 10826                                  				;	     = FFh if bad value sent to routine
 10827 000022AA 08C0                    		or	al,al
 10828                                  P_TSEP_JRETN:
 10829 000022AC 7495                    		jz	short P_TSEP_RETN ; Error in time?
 10830                                  TIMEERR:
 10831 000022AE BA[0E3A]                		mov	dx,BADTIMPTR
 10832 000022B1 E8A011                  		call	STD_PRINTF	; Print "Enter new time: "
 10833 000022B4 EB97                    		jmp	short GETTIM
 10834                                  
 10835                                  ; =============== S U B	R O U T	I N E =======================================
 10836                                  
 10837                                  GETBUF:
 10838 000022B6 B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10839 000022B8 BA[1040]                		mov	dx,COMBUF
 10840 000022BB B90200                  		mov	cx,2
 10841 000022BE E85F00                  		call	SETINITFLAG
 10842 000022C1 CD21                    		int	21h		; Get input line
 10843 000022C3 31C9                    		xor	cx,cx
 10844 000022C5 E85800                  		call	SETINITFLAG
 10845 000022C8 E880F6                  		call	CRLF2
 10846 000022CB BE[1240]                		mov	si,COMBUF+2
 10847 000022CE 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10848 000022D1 74D9                    		jz	short P_TSEP_JRETN
 10849                                  
 10850                                  ; =============== S U B	R O U T	I N E =======================================
 10851                                  
 10852                                  INLINE:
 10853 000022D3 E81900                  		call	GETNUM		; Get one or two digit number
 10854 000022D6 7301                    		jnb	short INLINE1
 10855 000022D8 C3                      		retn
 10856                                  INLINE1:
 10857 000022D9 88E6                    		mov	dh,ah		; Put in position
 10858 000022DB AC                      		lodsb
 10859 000022DC 38D8                    		cmp	al,bl
 10860 000022DE 7409                    		jz	short NEXT
 10861 000022E0 38F8                    		cmp	al,bh
 10862 000022E2 7405                    		jz	short NEXT
 10863 000022E4 4E                      		dec	si		; Clears zero flag
 10864 000022E5 F8                      		clc
 10865 000022E6 B200                    		mov	dl,0
 10866 000022E8 C3                      		retn			; Time may have only an hour specified
 10867                                  NEXT:
 10868 000022E9 E80300                  		call	GETNUM
 10869 000022EC 88E2                    		mov	dl,ah		; Put in position
 10870                                  INLINE_RETN:
 10871 000022EE C3                      		retn
 10872                                  
 10873                                  ;============================================================================
 10874                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10875                                  ;============================================================================
 10876                                  ; 05/10/2018 - Retro DOS v3.0
 10877                                  
 10878                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10879                                  
 10880                                  ; =============== S U B	R O U T	I N E =======================================
 10881                                  
 10882                                  GETNUM:
 10883 000022EF E81000                  		call	INDIG
 10884 000022F2 72FA                    		jb	short INLINE_RETN
 10885 000022F4 88C4                    		mov	ah,al		; Save first digit
 10886 000022F6 E80900                  		call	INDIG		; Another digit?
 10887 000022F9 7204                    		jb	short OKRET
 10888 000022FB D50A                    		aad			; Convert unpacked BCD to decimal
 10889 000022FD 88C4                    		mov	ah,al
 10890                                  OKRET:
 10891 000022FF 0C01                    		or	al,1
 10892                                  GETNUM_RETN:
 10893 00002301 C3                      		retn
 10894                                  
 10895                                  ; =============== S U B	R O U T	I N E =======================================
 10896                                  
 10897                                  INDIG:
 10898 00002302 8A04                    		mov	al,[si]
 10899 00002304 2C30                    		sub	al,'0'
 10900 00002306 72F9                    		jc	short GETNUM_RETN
 10901 00002308 3C0A                    		cmp	al,10
 10902 0000230A F5                      		cmc
 10903 0000230B 72F4                    		jc	short GETNUM_RETN
 10904 0000230D 46                      		inc	si
 10905 0000230E C3                      		retn
 10906                                  
 10907                                  ; =============== S U B	R O U T	I N E =======================================
 10908                                  
 10909                                  OUT2:					; Output binary number as two ASCII digits
 10910 0000230F D40A                    		aam			; Convert binary to unpacked BCD
 10911 00002311 86C4                    		xchg	al,ah
 10912 00002313 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10913 00002316 3C30                    		cmp	al,'0'		; Is MSD zero?
 10914 00002318 7502                    		jnz	short NOSUP
 10915 0000231A 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10916                                  NOSUP:
 10917 0000231C B700                    		mov	bh,0		; Disable zero suppression
 10918 0000231E AB                      		stosw
 10919 0000231F C3                      		retn
 10920                                  
 10921                                  ; ---------------------------------------------------------------------------
 10922                                  		;stosb
 10923                                  		;retn
 10924                                  
 10925                                  ;============================================================================
 10926                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10927                                  ;============================================================================
 10928                                  ; 03/10/2018 - Retro DOS v3.0
 10929                                  
 10930                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10931                                  
 10932                                  ; =============== S U B	R O U T	I N E =======================================
 10933                                  
 10934                                  ; Set the special flag in the INIT flag to the value in CX.
 10935                                  
 10936                                  SETINITFLAG:
 10937 00002320 8E1E[B141]              		mov	ds,[RESSEG]
 10938                                  		;and	byte [INITFLAG],0FDh
 10939 00002324 80265B0CFD              		and	byte [INITFLAG],~INITSPECIAL
 10940 00002329 080E5B0C                		or	byte [INITFLAG],cl
 10941 0000232D 0E                      		push	cs
 10942 0000232E 1F                      		pop	ds
 10943 0000232F C3                      		retn
 10944                                  
 10945                                  ; =============== S U B	R O U T	I N E =======================================
 10946                                  
 10947                                  PIPEOFF:
 10948 00002330 1E                      		push	ds
 10949 00002331 50                      		push	ax
 10950 00002332 2E8E1E[B141]            		mov	ds,[cs:RESSEG]
 10951 00002337 30C0                    		xor	al,al
 10952 00002339 86065C0C                		xchg	al,[PIPEFLAG]
 10953 0000233D 08C0                    		or	al,al
 10954 0000233F 7404                    		jz	short PIPEOFFDONE
 10955 00002341 D02EEF0B                		shr	byte [ECHOFLAG],1
 10956                                  PIPEOFFDONE:
 10957 00002345 58                      		pop	ax
 10958 00002346 1F                      		pop	ds
 10959 00002347 C3                      		retn
 10960                                  
 10961                                  ; ---------------------------------------------------------------------------
 10962                                  		;db    0,0,0,0,0
 10963                                  		;times 5 db 0
 10964 00002348 90<rep 8h>              align 16
 10965                                  
 10966                                  ;============================================================================
 10967                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 10968                                  ;============================================================================
 10969                                  ; 03/10/2018 - Retro DOS v3.0
 10970                                  
 10971                                  ;----------------------------------------------------------------------------
 10972                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 10973                                  ; argv[argvcnt] array. The most important difference between this array and
 10974                                  ; the tradition UNIX format is the extra cparse information included with
 10975                                  ; each argument element.
 10976                                  ;---------------
 10977                                  ; ENTRY:
 10978                                  ;	BL	     special delimiter for cparse -- not implemented)
 10979                                  ;---------------
 10980                                  ; EXIT:
 10981                                  ;	CF	    set if error
 10982                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 10983                                  ;	argv[]	    array of cparse flags and pointers to arguments
 10984                                  ;	argvcnt     argument count
 10985                                  ;---------------
 10986                                  ; NOTE(S):
 10987                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 10988                                  ;	*   Parseflags record contains cparse flags, as follows:
 10989                                  ;		sw_flag 	--	was this arg a switch?
 10990                                  ;		wildcard	--	whether or not it contained a * or ?
 10991                                  ;		path_sep	--	maybe it was a pathname
 10992                                  ;		unused		--	for future expansion
 10993                                  ;		special_delim	--	was there an initial special delimiter?
 10994                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 10995                                  ;	*   Relationship between input, cparse output, and comtail can be
 10996                                  ;	    found in the following chart.  Despite the claim of the cparse
 10997                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 10998                                  ;	    tokens", such is not the case (see column two, row two).
 10999                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 11000                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 11001                                  ;	    STARTEL addresses) will be null. This is clearly just a
 11002                                  ;	    documentation error.
 11003                                  ;	*   cparse also returns a switch code in BP for each switch it
 11004                                  ;	    recognizes on the command line.
 11005                                  ;	*   arglen for each token does NOT include the terminating null.
 11006                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 11007                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 11008                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 11009                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 11010                                  ;	    line parsing may result in slightly different behavior than
 11011                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 11012                                  ;
 11013                                  ;	    Input		    Cparse		Command Line (80H)
 11014                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 11015                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 11016                                  ;	foo.bat 		foo.bat 		foo.bat
 11017                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 11018                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 11019                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 11020                                  
 11021                                  ; =============== S U B	R O U T	I N E =======================================
 11022                                  
 11023                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 11024                                  
 11025                                  PARSELINE:
 11026 00002350 50                      		push	ax			; most of these are clobbered
 11027 00002351 53                      		push	bx			; by cparse...
 11028 00002352 51                      		push	cx
 11029 00002353 52                      		push	dx
 11030 00002354 57                      		push	di
 11031 00002355 56                      		push	si
 11032 00002356 9C                      		pushf
 11033 00002357 C606[9643]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 11034 0000235C C706[AF4A]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 11035 00002362 31C0                    		xor	ax,ax
 11036                                  		;mov	cx,1348
 11037 00002364 B94405                  		mov	cx,ARG_UNIT.SIZE
 11038 00002367 BF[E944]                		mov	di,ARG
 11039 0000236A F3AA                    		rep stosb
 11040                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 11041 0000236C C706[2D4A][AD47]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 11042                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 11043 00002372 C706[AB47]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 11044                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 11045 00002378 C706[A947]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 11046 0000237E BE[1240]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 11047                                  
 11048                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 11049                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 11050                                  ; otherwise. This is done so that commands can get arg pointers into their
 11051                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 11052                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 11053                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 11054                                  ; the command to be repeated or the transient part of command has been
 11055                                  ; reloaded.
 11056                                  
 11057 00002381 1E                      		push	ds
 11058 00002382 8E1E[B141]              		mov	ds,[RESSEG]
 11059 00002386 803EFB0B00              		cmp	byte [FORFLAG],0
 11060 0000238B 1F                      		pop	ds
 11061 0000238C 7510                    		jnz	short PCONT
 11062                                  		;mov	di,ARG_ARGFORCOMBUF
 11063 0000238E BF[AD49]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 11064 00002391 30ED                    		xor	ch,ch
 11065 00002393 8A0E[1140]              		mov	cl,[COMBUF+1]
 11066 00002397 FEC1                    		inc	cl
 11067 00002399 F3A4                    		rep movsb
 11068                                  		;mov	si,ARG_ARGFORCOMBUF
 11069 0000239B BE[AD49]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 11070                                  PCONT:
 11071 0000239E BF[2F4A]                		mov	di,TPBUF	; destination is temporary token buffer	
 11072 000023A1 B320                    		mov	bl,' '		; no special delimiter, for now
 11073                                  PARSELOOP:
 11074 000023A3 8936[B14A]              		mov	[COMPTR],si	; save ptr into original command buffer
 11075 000023A7 31ED                    		xor	bp,bp		; switch information put here by cparse
 11076 000023A9 C606[E744]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 11077 000023AE E8A7F5                  		call	SCANOFF		; skip leading blanks...
 11078 000023B1 E8EB0E                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 11079 000023B4 730B                    		jnb	short MORE_PRSE
 11080 000023B6 09ED                    		or	bp,bp		; Check for trailing switch character
 11081 000023B8 7403                    		jz	short PARSEDONE
 11082 000023BA E81700                  		call	NEWARG		; We hit CR but BP is non-zero. The
 11083                                  					;   typical cause of this is that a
 11084                                  					;   switch char IMMEDIATELY preceeds
 11085                                  					;   the CR. We have an argument, but it
 11086                                  					;   is sort of an error.
 11087                                  		;jmp	short PARSEDONE	; We're done (found the CR).
 11088                                  		; 01/03/2023
 11089                                  PARSEDONE:
 11090 000023BD 9D                      		popf
 11091 000023BE F8                      		clc
 11092 000023BF EB0C                    		jmp	short PARSE_EXIT
 11093                                  
 11094                                  MORE_PRSE:
 11095 000023C1 C606[9643]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 11096 000023C6 E80B00                  		call	NEWARG		; add to argv array (CX has char count)
 11097 000023C9 73D8                    		jnb	short PARSELOOP	; was everything OK?
 11098                                  		;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 11099                                  		; 01/03/2023
 11100                                  ;PARSEDONE:
 11101                                  		;popf
 11102                                  		;clc
 11103                                  		;jmp	short PARSE_EXIT
 11104                                  
 11105                                  PARSE_ERROR:				; error entry (er, exit) point
 11106 000023CB 9D                      		popf
 11107 000023CC F9                      		stc
 11108                                  PARSE_EXIT:				; depend on not changing CF
 11109 000023CD 5E                      		pop	si
 11110 000023CE 5F                      		pop	di
 11111 000023CF 5A                      		pop	dx
 11112 000023D0 59                      		pop	cx
 11113 000023D1 5B                      		pop	bx
 11114 000023D2 58                      		pop	ax
 11115 000023D3 C3                      		retn
 11116                                  
 11117                                  ; =============== S U B	R O U T	I N E =======================================
 11118                                  
 11119                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11120                                  ;
 11121                                  ; ENTRY:
 11122                                  ;   BH			argflags
 11123                                  ;   CX			character count in argstring
 11124                                  ;   DI			pointer to argstring
 11125                                  ;   comptr		ptr to starting loc of current token in original command
 11126                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11127                                  ; EXIT:
 11128                                  ;   argbufptr		points to next free section of argbuffer
 11129                                  ;   arg.argbuf		contains null-terminated argument strings
 11130                                  ;   arg.argvcnt 	argument count
 11131                                  ;   arg.argv[]		array of flags and pointers
 11132                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11133                                  ;   CF			set if error
 11134                                  ;   AL			carry set:  error code; otherwise, zero
 11135                                  
 11136                                  NEWARG:
 11137 000023D4 53                      		push	bx
 11138 000023D5 51                      		push	cx
 11139 000023D6 52                      		push	dx
 11140 000023D7 57                      		push	di
 11141 000023D8 56                      		push	si
 11142 000023D9 9C                      		pushf
 11143 000023DA E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11144                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11145                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11146                                  
 11147                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11148 000023DD 833E[A947]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11149 000023E2 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11150 000023E4 88FE                    		mov	dh,bh			
 11151                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11152 000023E6 8B1E[A947]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11153                                  		;inc	word [ARG_ARGVCNT]
 11154 000023EA FF06[A947]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11155                                  		;mov	ax,ARG_ARGV
 11156 000023EE B8[E944]                		mov	ax,ARG+ARG_UNIT.argv
 11157 000023F1 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11158                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11159                                  		;mov	word [bx+7],0
 11160 000023F4 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11161                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11162                                  		;mov	[bx+5],cx
 11163 000023F9 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11164                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11165                                  		;mov	[bx+2],dh
 11166 000023FC 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11167 000023FF 8B36[2D4A]              		mov	si,[ARGBUFPTR]
 11168                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11169                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11170 00002403 8937                    		mov	[bx],si			
 11171 00002405 0336[D744]              		add	si,[STARTEL]		; save startel from new location
 11172 00002409 29FE                    		sub	si,di			; form pointer into argbuf
 11173                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11174                                  		;mov	[bx+3],si
 11175 0000240B 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11176 0000240E 8B36[B14A]              		mov	si,[COMPTR]
 11177                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11178                                  		;mov	[bx+9],si
 11179 00002412 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11180                                  
 11181 00002415 89FE                    		mov	si,di			; now save argstring in argbuffer
 11182 00002417 8B3E[2D4A]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11183 0000241B 01CF                    		add	di,cx			; sure we're not about to run off
 11184                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11185                                  		;cmp	di,ARG_ARGBUF+255
 11186 0000241D 81FF[AC48]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11187 00002421 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11188 00002423 29CF                    		sub	di,cx
 11189 00002425 FC                      		cld
 11190 00002426 F3A4                    		rep movsb
 11191 00002428 B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11192 0000242A AA                      		stosb
 11193 0000242B 893E[2D4A]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11194                                  
 11195                                  NEWARG_DONE:
 11196 0000242F 9D                      		popf
 11197 00002430 F8                      		clc
 11198 00002431 EB0A                    		jmp	short NEWARG_EXIT
 11199                                  
 11200                                  TO_MANY_ARGS:
 11201 00002433 B80100                  		mov	ax,1
 11202 00002436 EB03                    		jmp	short NEWARG_ERROR
 11203                                  
 11204                                  BUF_OVFLOW:
 11205 00002438 B80200                  		mov	ax,2
 11206                                  NEWARG_ERROR:
 11207 0000243B 9D                      		popf
 11208 0000243C F9                      		stc
 11209                                  NEWARG_EXIT:
 11210 0000243D 5E                      		pop	si
 11211 0000243E 5F                      		pop	di
 11212 0000243F 5A                      		pop	dx
 11213 00002440 59                      		pop	cx
 11214 00002441 5B                      		pop	bx
 11215 00002442 C3                      		retn
 11216                                  
 11217                                  ; =============== S U B	R O U T	I N E =======================================
 11218                                  
 11219                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11220                                  ; event that it is, and we can recognize
 11221                                  ;
 11222                                  ; ENTRY:
 11223                                  ;   As in <newarg>.
 11224                                  ; EXIT:
 11225                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11226                                  ; NOTE(S):
 11227                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11228                                  ;	on the order of definition in the <switch_list> variable and the
 11229                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11230                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11231                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11232                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11233                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11234                                  ;   *	An ugly routine.
 11235                                  
 11236                                  ARG_SWITCH:
 11237 00002443 50                      		push	ax
 11238 00002444 53                      		push	bx
 11239 00002445 51                      		push	cx
 11240 00002446 57                      		push	di
 11241 00002447 9C                      		pushf
 11242 00002448 F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11243 0000244B 741C                    		jz	short ARG_NO_SWITCH0
 11244 0000244D 833E[AF4A]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11245 00002452 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11246 00002454 8B1E[AF4A]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11247                                  		;mov	ax,offset TRANGROUP:arg.argv
 11248                                  		;mov	ax,ARG_ARGV
 11249 00002458 B8[E944]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11250 0000245B E81800                  		call	ARGV_CALC
 11251                                  		;or	[BX].argsw_word,BP
 11252                                  		;or	[bx+7],bp
 11253 0000245E 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11254                                  		;or	arg.argswinfo,BP
 11255                                  		;or	[ARG_ARGSWINFO],bp
 11256 00002461 092E[AB47]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11257                                  ARG_YES_SWITCH:
 11258 00002465 9D                      		popf
 11259 00002466 F9                      		stc
 11260 00002467 EB08                    		jmp	short ARG_SWITCH_EXIT
 11261                                  
 11262                                  ARG_NO_SWITCH0:
 11263                                  		;mov	ax,[ARG_ARGVCNT]
 11264 00002469 A1[A947]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11265 0000246C A3[AF4A]                		mov	[LASTARG],ax
 11266                                  ARG_NO_SWITCH1:
 11267 0000246F 9D                      		popf
 11268 00002470 F8                      		clc
 11269                                  ARG_SWITCH_EXIT:
 11270 00002471 5F                      		pop	di
 11271 00002472 59                      		pop	cx
 11272 00002473 5B                      		pop	bx
 11273 00002474 58                      		pop	ax
 11274 00002475 C3                      		retn
 11275                                  
 11276                                  ; =============== S U B	R O U T	I N E =======================================
 11277                                  
 11278                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11279                                  ; the supplied array.  Method used for computing the address is:
 11280                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11281                                  ; ENTRY:
 11282                                  ;   AX	    --	    base of array
 11283                                  ;   BX	    --	    array index
 11284                                  ; EXIT:
 11285                                  ;   BX	    --	    byte offset
 11286                                  
 11287                                  ARGV_CALC:
 11288 00002476 50                      		push	ax		; Save base
 11289 00002477 88D8                    		mov	al,bl		; al = array index
 11290                                  		;mov	bl,11
 11291 00002479 B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11292 0000247B F6E3                    		mul	bl		; ax = base offset
 11293 0000247D 5B                      		pop	bx		; Get base
 11294 0000247E 01D8                    		add	ax,bx		; Add in base offset
 11295 00002480 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11296 00002481 C3                      		retn
 11297                                  
 11298                                  ; ---------------------------------------------------------------------------
 11299                                  	
 11300                                  		;db 0Ah dup(0)
 11301                                  		;times 10 db 0
 11302 00002482 90<rep Eh>              align 16
 11303                                  
 11304                                  ;============================================================================
 11305                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11306                                  ;============================================================================
 11307                                  ; 03/10/2018 - Retro DOS v3.0
 11308                                  
 11309                                  ;----------------------------------------------------------------------------
 11310                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11311                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11312                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11313                                  ;    file on disk. Directories specified in the user's search path will be
 11314                                  ;    searched for a matching file, if a match is not found in the current
 11315                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11316                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11317                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11318                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11319                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11320                                  ;    (easily) modified to make no assumptions about where its input is found.
 11321                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11322                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11323                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11324                                  ;    else that wants to save the whole shebang and then process other command
 11325                                  ;    lines.
 11326                                  ;
 11327                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11328                                  ;
 11329                                  ; ENTRY:
 11330                                  ;   <Path_Search>:	    argv[0].
 11331                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11332                                  ; EXIT:
 11333                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11334                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11335                                  ; NOTE(S):
 11336                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11337                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11338                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11339                                  ;	does not function as specified; see <Parseline> for more details.
 11340                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11341                                  ;	need to know about. This extra information is stored in a switch_flag
 11342                                  ;	word with each command-line argument; the switches themselves will not
 11343                                  ;	appear in the resulting arg structure.
 11344                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11345                                  ;----------------------------------------------------------------------------
 11346                                  
 11347                                  ; =============== S U B	R O U T	I N E =======================================
 11348                                  
 11349                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11350                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11351                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11352                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11353                                  ; have a match, either in the current working directory if we were handed
 11354                                  ; a filename, or in the specified directory, given a pathname. If this call
 11355                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11356                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11357                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11358                                  ; either the first invocation of search or on one of the succeeding calls
 11359                                  ; sets up the appropriate information for copying the successful pathname
 11360                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11361                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11362                                  ;
 11363                                  ; ENTRY:
 11364                                  ;   argv[0]		--	command name and associated information
 11365                                  ; EXIT:
 11366                                  ;   AX			--	non-zero indicates type of file found
 11367                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11368                                  ; NOTE(S):
 11369                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11370                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11371                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11372                                  ;	if search returns an .exe or .bat.
 11373                                  ;   5)	Clobbers dma address.
 11374                                  
 11375                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11376                                  PATH_SEP_CHAR	EQU	';'
 11377                                  
 11378                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11379                                  
 11380                                  		;special_delim equ 128
 11381                                  		;path_sep equ 4
 11382                                  		;wildcard equ 2
 11383                                  		;sw_flag  equ 1
 11384                                  
 11385                                  ;----------------------------------------------------------------------------
 11386                                  
 11387                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11388                                  
 11389                                  PATH_SEARCH:
 11390 00002490 53                      		push	bx
 11391 00002491 51                      		push	cx
 11392 00002492 52                      		push	dx		; could use a "stack 'em" instruction
 11393 00002493 56                      		push	si
 11394 00002494 57                      		push	di
 11395 00002495 55                      		push	bp
 11396 00002496 9C                      		pushf
 11397                                  
 11398                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11399                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11400 00002497 F606[EB44]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11401 0000249C 7403                    		jz	short PATH_SEARCH_OK
 11402                                  
 11403                                  PATH_FAILURE_JMP:
 11404 0000249E E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11405                                  
 11406                                  PATH_SEARCH_OK:
 11407 000024A1 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11408 000024A4 BA[B34A]                		mov	dx,FBUF		; clobber old dma value with
 11409 000024A7 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11410 000024AA CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11411                                  				; DS:DX	-> disk	transfer buffer
 11412 000024AC 06                      		push	es
 11413 000024AD E8C2F2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11414 000024B0 8C06[DE4A]              		mov	[PATHINFO+0],es	; and squirrel it away
 11415 000024B4 893E[E04A]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11416 000024B8 893E[E24A]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11417 000024BC 07                      		pop	es
 11418                                  		
 11419 000024BD BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11420 000024C0 BE[D940]                		mov	si,EXECPATH
 11421 000024C3 E84B02                  		call	STRIP
 11422 000024C6 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11423                                  		
 11424 000024C8 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11425 000024CA C706[334B][A938]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11426 000024D0 E88301                  		call	PSEARCH		; must do at least one search
 11427 000024D3 09C0                    		or	ax,ax		; find anything?
 11428 000024D5 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11429                                  		
 11430 000024D7 89C5                    		mov	bp,ax		; success... save filetype code	
 11431 000024D9 BF[D940]                		mov	di,EXECPATH
 11432                                  		;mov	si,ds:arg.argv[0].argpointer
 11433                                  		;mov	si,[ARG_ARGV]
 11434 000024DC 8B36[E944]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11435                                  		;mov	cx,ds:arg.argv[0].argstartel
 11436                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11437 000024E0 8B0E[EC44]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11438 000024E4 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11439                                  
 11440                                  ; We have the number of bytes in the prefix (up to the final component).
 11441                                  ; We need to form the complete pathname including leading drive and current
 11442                                  ; directory.
 11443                                  ;
 11444                                  ; Is there a drive letter present?
 11445                                  
 11446 000024E6 B43A                    		mov	ah,':'
 11447 000024E8 83F902                  		cmp	cx,2		; room for drive letter?
 11448 000024EB 7205                    		jb	short ADDDRIVE	; no, stick it in
 11449 000024ED 386401                  		cmp	[si+1],	ah	; colon present?
 11450 000024F0 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11451                                  ADDDRIVE:
 11452 000024F2 A0[C541]                		mov	al,[CURDRV]	; get current drive
 11453 000024F5 0441                    		add	al,'A'		; convert to uppercase letter
 11454 000024F7 AB                      		stosw			; store d:
 11455 000024F8 EB05                    		jmp	short CHECKPATH
 11456                                  
 11457                                  MOVEDRIVE:
 11458 000024FA AD                      		lodsw			; move d:
 11459 000024FB AB                      		stosw
 11460 000024FC 83E902                  		sub	cx,2		; 2 bytes less to move
 11461                                  CHECKPATH:
 11462 000024FF 0C20                    		or	al,20h
 11463 00002501 88C2                    		mov	dl,al		
 11464                                  		;sub	dl,60h
 11465 00002503 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11466                                  
 11467                                  ; Stick in beginning path char
 11468                                  
 11469 00002506 A0[E44A]                		mov	al,[PSEP_CHAR]
 11470 00002509 AA                      		stosb
 11471                                  
 11472                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11473                                  ; Otherwise, get current dir for DL.
 11474                                  
 11475 0000250A 83F901                  		cmp	cx,1		; is there room for path char?
 11476 0000250D 720A                    		jb	short ADDPATH	; no, go add path
 11477 0000250F AC                      		lodsb
 11478 00002510 49                      		dec	cx
 11479 00002511 3A06[E44A]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11480 00002515 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11481 00002517 41                      		inc	cx
 11482 00002518 4E                      		dec	si		; undo the lodsb
 11483                                  ADDPATH:
 11484 00002519 56                      		push	si
 11485 0000251A 89FE                    		mov	si,di		; remainder of buffer
 11486 0000251C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11487 0000251F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11488                                  				; DL = drive (0=default,1=A,etc.)
 11489                                  				; DS:SI	points to 64-byte buffer area
 11490                                  
 11491                                  ; The previous current dir will succeed a previous find_first already worked.
 11492                                  ;
 11493                                  ; Find end of string.
 11494                                  
 11495 00002521 89F7                    		mov	di,si
 11496 00002523 5E                      		pop	si
 11497 00002524 A0[E44A]                		mov	al,[PSEP_CHAR]
 11498 00002527 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11499 0000252A 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11500                                  SCANEND:
 11501 0000252C 803D00                  		cmp	byte [di],0	; end of string?
 11502 0000252F 7403                    		jz	short FOUNDEND
 11503 00002531 47                      		inc	di
 11504 00002532 EBF8                    		jmp	short SCANEND
 11505                                  
 11506                                  ; Stick in a trailing path char.
 11507                                  
 11508                                  FOUNDEND:
 11509 00002534 AA                      		stosb
 11510                                  
 11511                                  ; Move remaining part of path.	Skip leading path char if present.
 11512                                  
 11513                                  MOVEPATH:
 11514 00002535 3804                    		cmp	[si],al		; first char a path char?
 11515 00002537 7502                    		jnz	short COPYPATH
 11516 00002539 46                      		inc	si		; move past leading char
 11517 0000253A 49                      		dec	cx		; drop from count
 11518                                  COPYPATH:
 11519 0000253B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11520 0000253D F3A4                    		rep movsb
 11521                                  _COPYDONE:
 11522 0000253F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11523                                  
 11524                                  PATH_NOINIT:
 11525                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11526                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11527 00002542 F606[EB44]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11528 00002547 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11529                                  		;mov	bh,';'
 11530 00002549 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11531                                  		;mov	dx,ds:arg.argv[0].argstartel
 11532                                  					; this is where the last element starts
 11533                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11534 0000254B 8B16[EC44]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11535                                  		;sub	dx,ds:arg.argv[0].argpointer
 11536                                  					; form pointer into EXECPATH,
 11537                                  		;sub	dx,[ARG_ARGV]
 11538 0000254F 2B16[E944]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11539 00002553 81C2[D940]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11540                                  PATH_LOOP:
 11541 00002557 E89A00                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11542 0000255A 89C5                    		mov	bp,ax		; save filetype code
 11543 0000255C 9F                      		lahf			; save flags, just in case
 11544 0000255D 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11545 0000255F 7507                    		jnz	short PATH_FOUND 
 11546 00002561 9E                      		sahf			; see?	needed those flags, after all!
 11547 00002562 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11548                                  PATH_FAILURE:
 11549 00002564 31C0                    		xor	ax,ax
 11550 00002566 EB70                    		jmp	short PATH_EXIT
 11551                                  
 11552                                  PATH_FOUND:				; pathinfo[] points to winner
 11553 00002568 BF[D940]                		mov	di,EXECPATH
 11554                                  		;mov	cx,pathinfo[4] 
 11555 0000256B 8B0E[E24A]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11556                                  		;mov	SI,pathinfo[2]
 11557 0000256F 8B36[E04A]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11558                                  
 11559                                  ;	BAS Nov 20/84
 11560                                  ;   Look at the pathname and expand . and .. if they are the first element
 11561                                  ;   in the pathname (after the drive letter)
 11562                                  
 11563 00002573 06                      		push	es
 11564                                  		;push	pathinfo[0]
 11565 00002574 FF36[DE4A]              		push	word [PATHINFO+0]
 11566 00002578 07                      		pop	es
 11567                                  ;SR;
 11568                                  ; Oops! Gets fooled if path= \;..
 11569                                  ; We should also check if a drive letter is really present
 11570                                  ;
 11571 00002579 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11572 0000257E 7534                    		jnz	short PATH_CPY
 11573                                  
 11574                                  		; MSDOS 6.0
 11575                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11576                                  		;jnz	path_cpy	       ;no, copy the path string
 11577                                  
 11578 00002580 51                      		push	cx		; Save pointer to end of string
 11579 00002581 268A04                  		mov	al,[es:si]
 11580 00002584 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11581 00002586 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11582 0000258A 884501                  		mov	[di+1],al
 11583 0000258D A0[E44A]                		mov	al,[PSEP_CHAR]
 11584 00002590 884502                  		mov	[di+2],	al
 11585 00002593 56                      		push	si		; Save pointer to begining of string
 11586 00002594 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11587 00002597 80CA20                  		or	dl,20h
 11588                                  		;sub	dl,60h
 11589 0000259A 80EA60                  		sub	dl,'a'-1
 11590 0000259D 89FE                    		mov	si,di		; pointer to EXECPATH
 11591 0000259F 83C603                  		add	si,3		; Don't wipe out drive and root info
 11592 000025A2 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11593 000025A5 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11594                                  				; DL = drive (0=default,1=A,etc.)
 11595                                  				; DS:SI	points to 64-byte buffer area
 11596 000025A7 E8D7F8                  		call	DSTRLEN		; Determine length of present info
 11597 000025AA 01CE                    		add	si,cx		; Don't copy over drive and root info
 11598 000025AC 4E                      		dec	si
 11599 000025AD 89F7                    		mov	di,si		; Point to end of target string
 11600 000025AF 5E                      		pop	si		; Restore pointer to begining of string
 11601 000025B0 83C603                  		add	si,3		; Point past drive letter, :, .
 11602 000025B3 59                      		pop	cx		; Restore pointer to end of string
 11603                                  PATH_CPY:
 11604 000025B4 07                      		pop	es
 11605 000025B5 29F1                    		sub	cx,si		; yields character count
 11606 000025B7 1E                      		push	ds		; time to switch segments
 11607 000025B8 FF36[DE4A]              		push	word [PATHINFO+0] ; string lives in this segment
 11608 000025BC 1F                      		pop	ds
 11609 000025BD FC                      		cld
 11610 000025BE F3A4                    		rep movsb
 11611 000025C0 1F                      		pop	ds		; return to our segment
 11612 000025C1 4F                      		dec	di		; overwrite terminator
 11613 000025C2 A0[E44A]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11614 000025C5 3A45FF                  		cmp	al,[di-1]
 11615 000025C8 7401                    		jz	short PATH_SUCCESS
 11616 000025CA AA                      		stosb
 11617                                  PATH_SUCCESS:
 11618 000025CB BE[E64A]                		mov	si,SEARCH_BEST_BUF
 11619 000025CE 31C9                    		xor	cx,cx
 11620                                  PATH_SUCC_LOOP:
 11621 000025D0 AC                      		lodsb			; append winning filename to path
 11622 000025D1 AA                      		stosb			; (including terminating null)	
 11623 000025D2 08C0                    		or	al,al
 11624 000025D4 75FA                    		jnz	short PATH_SUCC_LOOP
 11625 000025D6 89E8                    		mov	ax,bp		; retrieve filetype code
 11626                                  PATH_EXIT:
 11627 000025D8 9D                      		popf
 11628 000025D9 5D                      		pop	bp
 11629 000025DA 5F                      		pop	di
 11630 000025DB 5E                      		pop	si		; chill out...
 11631 000025DC 5A                      		pop	dx
 11632 000025DD 59                      		pop	cx
 11633 000025DE 5B                      		pop	bx
 11634 000025DF C3                      		retn
 11635                                  
 11636                                  
 11637                                  ; =============== S U B	R O U T	I N E =======================================
 11638                                  
 11639                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11640                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11641                                  ;
 11642                                  ; ENTRY:
 11643                                  ; EXIT:
 11644                                  ; NOTE(S):
 11645                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11646                                  
 11647                                  STORE_PCHAR:
 11648 000025E0 50                      		push	ax
 11649 000025E1 B02F                    		mov	al,'/'		; is the pathname-element separator
 11650 000025E3 E804F4                  		call	PATHCHRCMP	; a regular slash?
 11651 000025E6 7407                    		jz	short STORE_SLASH ; if yes, remember slash
 11652 000025E8 B05C                    		mov	al,'\'
 11653 000025EA A2[E44A]                		mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11654 000025ED 58                      		pop	ax
 11655 000025EE C3                      		retn
 11656                                  STORE_SLASH:
 11657 000025EF A2[E44A]                		mov	[PSEP_CHAR],al
 11658 000025F2 58                      		pop	ax
 11659 000025F3 C3                      		retn
 11660                                  
 11661                                  ; =============== S U B	R O U T	I N E =======================================
 11662                                  
 11663                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11664                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11665                                  ; additional separator to use for breaking up the path-string. Null is the
 11666                                  ; default. Once the user-string has been formed, search is invoked to see
 11667                                  ; what's out there.
 11668                                  ;
 11669                                  ; ENTRY:
 11670                                  ;   BH			--	additional terminator character
 11671                                  ;   SI			--	pointer into pathstring to be dissected
 11672                                  ;   DX			--	pointer to stripped filename
 11673                                  ; EXIT:
 11674                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11675                                  ;   SI			--	moves along pathstring from call to call
 11676                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11677                                  ;   [tpbuf]		--	clobbered
 11678                                  ; NOTE(S):
 11679                                  ;   *	Implicit in this code is the ability to specify when to search
 11680                                  ;	the current directory (if at all) through the PATH defined by
 11681                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11682                                  ;	current directory before the bin and etc directories of drive c).
 11683                                  
 11684                                  PATH_CRUNCH:
 11685 000025F4 53                      		push	bx
 11686 000025F5 51                      		push	cx
 11687 000025F6 52                      		push	dx
 11688 000025F7 57                      		push	di
 11689 000025F8 56                      		push	si
 11690 000025F9 9C                      		pushf
 11691 000025FA E8E3FF                  		call	STORE_PCHAR	; figure out pathname separator
 11692 000025FD BF[2F4A]                		mov	di,TPBUF	; destination of concatenated string
 11693 00002600 8B36[E24A]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11694 00002604 8936[E04A]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11695 00002608 1E                      		push	ds		; save old segment pointer
 11696 00002609 FF36[DE4A]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11697 0000260D 1F                      		pop	ds		; segment		
 11698                                  PATH_CR_COPY:
 11699 0000260E AC                      		lodsb			; get a pathname byte
 11700 0000260F 08C0                    		or	al,al		; check for terminator(s)
 11701 00002611 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11702 00002613 38F8                    		cmp	al,bh
 11703 00002615 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11704 00002617 AA                      		stosb
 11705 00002618 EBF4                    		jmp	short PATH_CR_COPY
 11706                                  
 11707                                  PATH_SEG:
 11708 0000261A 1F                      		pop	ds		; restore old data segment
 11709 0000261B 8936[E24A]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11710 0000261F 88C3                    		mov	bl,al		; remember if we saw null or not...
 11711                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11712 00002621 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11713 00002623 81FF[2F4A]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11714 00002627 741D                    		jz	short PATH_CR_LEAVE 
 11715                                  					; if nothing was copied, pathstr empty
 11716                                  PATH_CR_LOOK:
 11717 00002629 A0[E44A]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11718 0000262C 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11719 0000262F 7401                    		jz	short PATH_CR_L1
 11720 00002631 AA                      		stosb
 11721                                  PATH_CR_L1:
 11722 00002632 89D6                    		mov	si,dx
 11723                                  PATH_CR_L2:
 11724 00002634 AC                      		lodsb			; tack the stripped filename onto
 11725 00002635 AA                      		stosb			; the end of the path, up to and
 11726 00002636 08C0                    		or	al,al		; including the terminating null
 11727 00002638 75FA                    		jnz	short PATH_CR_L2
 11728 0000263A BA[2F4A]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11729 0000263D C706[334B][A03B]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11730                                  		;invoke search
 11731 00002643 E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11732                                  
 11733                                  PATH_CR_LEAVE:
 11734 00002646 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11735 00002648 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11736 0000264A 9D                      		popf			; otherwise, plenty left
 11737 0000264B F8                      		clc
 11738 0000264C EB02                    		jmp	short PATH_CR_EXIT
 11739                                  
 11740                                  PATH_CR_EMPTY:
 11741 0000264E 9D                      		popf
 11742 0000264F F9                      		stc
 11743                                  PATH_CR_EXIT:
 11744 00002650 5E                      		pop	si
 11745 00002651 5F                      		pop	di
 11746 00002652 5A                      		pop	dx
 11747 00002653 59                      		pop	cx
 11748 00002654 5B                      		pop	bx
 11749 00002655 C3                      		retn
 11750                                  
 11751                                  ;============================================================================
 11752                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11753                                  ;============================================================================
 11754                                  ; 02/10/2018 - Retro DOS v3.0
 11755                                  
 11756                                  ;----------------------------------------------------------------------------
 11757                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11758                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11759                                  ; lowest priority). Where conflicts arise, the extension with
 11760                                  ; the highest priority is favored.
 11761                                  ; ENTRY:
 11762                                  ;   DX		--	pointer to null-terminated pathname
 11763                                  ;   fbuf	--	dma buffer for findfirst/next
 11764                                  ; EXIT:
 11765                                  ;   AX		--	8)  file found with .com extension
 11766                                  ;			4)  file found with .exe extension
 11767                                  ;			2)  file found with .bat extension
 11768                                  ;			0)  no such file to be found
 11769                                  ;   (if AX is non-zero:)
 11770                                  ;   [search_best]	identical to AX
 11771                                  ;   [search_best_buf]	null-terminated filename
 11772                                  ; NOTES:
 11773                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11774                                  ;---------------
 11775                                  ; CONSTANTS:
 11776                                  ;---------------
 11777                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11778                                  SEARCH_COM		EQU	8
 11779                                  SEARCH_EXE		EQU	4
 11780                                  SEARCH_BAT		EQU	2
 11781                                  FNAME_LEN		EQU	8
 11782                                  FNAME_MAX_LEN		EQU	13
 11783                                  DOT			EQU	'.'
 11784                                  WILDCHAR		EQU	'?'
 11785                                  
 11786                                  
 11787                                  ; =============== S U B	R O U T	I N E =======================================
 11788                                  
 11789                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11790                                  
 11791                                  PSEARCH:
 11792 00002656 51                      		push	cx
 11793 00002657 52                      		push	dx
 11794 00002658 57                      		push	di
 11795 00002659 56                      		push	si
 11796 0000265A 9C                      		pushf
 11797 0000265B 52                      		push	dx		; check drivespec (save pname ptr)
 11798 0000265C 89D7                    		mov	di,dx		; working copy of pathname
 11799 0000265E BE[F34A]                		mov	si,SEARCH_CURDIR_BUF
 11800 00002661 31D2                    		xor	dx,dx		; zero means current drive
 11801 00002663 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11802 00002667 7508                    		jne	short SEARCH_DIR_CHECK
 11803 00002669 8A15                    		mov	dl,[di]		; get the drive byte
 11804 0000266B 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11805 0000266E 80EA40                  		sub	dl,'@'		; and convert to drive number
 11806                                  SEARCH_DIR_CHECK:
 11807 00002671 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11808 00002674 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11809                                  				; DL = drive (0=default,1=A,etc.)
 11810                                  				; DS:SI	points to 64-byte buffer area
 11811 00002676 5A                      		pop	dx		; directory? If we can't we'll		
 11812 00002677 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11813 00002679 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11814 0000267C B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11815 0000267F CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11816                                  				; CX = search attributes
 11817                                  				; DS:DX	-> ASCIZ filespec
 11818                                  				; (drive,path,	and wildcards allowed)
 11819 00002681 723C                    		jc	short SEARCH_NO_FILE
 11820 00002683 C606[E54A]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11821 00002688 C606[E64A]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11822                                  SEARCH_LOOP:
 11823 0000268D E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11824 00002690 3A06[E54A]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11825 00002694 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11826 00002696 A2[E54A]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11827                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11828                                  		;mov	si,FBUF_PNAME
 11829 00002699 BE[D14A]                		mov	si,FBUF+FIND_BUF.PNAME
 11830 0000269C BF[E64A]                		mov	di,SEARCH_BEST_BUF
 11831 0000269F B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11832 000026A2 FC                      		cld
 11833 000026A3 F3A4                    		rep movsb		; save complete pathname representation
 11834 000026A5 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11835 000026A7 740A                    		je	short SEARCH_DONE
 11836                                  SEARCH_NEXT:				; keep on looking
 11837 000026A9 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11838 000026AC B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11839 000026AF CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11840                                  				; [DTA]	= data block from
 11841                                  				; last AH = 4Eh/4Fh call
 11842 000026B1 73DA                    		jnc	short SEARCH_LOOP
 11843                                  SEARCH_DONE:				; it's all over with...
 11844 000026B3 A0[E54A]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11845                                  		; MSDOS 6.0
 11846                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11847                                  		;jz	search_exit	;AN005; no - exit
 11848                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11849                                  		;mov	search_best,al	;AN005; save the real file type
 11850                                  		;
 11851 000026B6 EB0A                    		jmp	short SEARCH_EXIT
 11852                                  
 11853                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11854 000026B8 8B16[334B]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11855 000026BC E8950D                  		call	STD_PRINTF	 ; and pretend no file found
 11856                                  
 11857                                  SEARCH_NO_FILE:				; couldn't find a match
 11858 000026BF B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11859                                  
 11860                                  SEARCH_EXIT:
 11861 000026C2 9D                      		popf
 11862 000026C3 5E                      		pop	si
 11863 000026C4 5F                      		pop	di
 11864 000026C5 5A                      		pop	dx
 11865 000026C6 59                      		pop	cx
 11866 000026C7 C3                      		retn
 11867                                  
 11868                                  ; =============== S U B	R O U T	I N E =======================================
 11869                                  
 11870                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11871                                  ;
 11872                                  ; ENTRY:
 11873                                  ;   fbuf    --	    dma buffer containing filename
 11874                                  ; EXIT:
 11875                                  ;   AX	    --	    file code, as given in search header
 11876                                  ; NOTE(S):
 11877                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11878                                  
 11879                                  SEARCH_FTYPE:
 11880 000026C8 57                      		push	di
 11881 000026C9 56                      		push	si
 11882 000026CA B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11883                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11884                                  		;mov	di,FBUF_PNAME
 11885 000026CD BF[D14A]                		mov	di,FBUF+FIND_BUF.PNAME
 11886 000026D0 B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11887 000026D3 FC                      		cld
 11888 000026D4 F2AE                    		repnz scasb		; search for the terminating null
 11889 000026D6 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11890 000026D8 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11891                                  
 11892                                  		; Compare .COM
 11893                                  
 11894 000026DB BE[523E]                		mov	si,COMEXT ; ".COM"
 11895 000026DE 89F8                    		mov	ax,di
 11896 000026E0 A7                      		cmpsw
 11897 000026E1 7508                    		jnz	short FTYPE_EXE
 11898 000026E3 A7                      		cmpsw
 11899 000026E4 7505                    		jnz	short FTYPE_EXE
 11900                                  		;mov	ax,8
 11901 000026E6 B80800                  		mov	ax,SEARCH_COM	; success!
 11902 000026E9 EB23                    		jmp	short FTYPE_EXIT
 11903                                  
 11904                                  		; Compare .EXE
 11905                                  FTYPE_EXE:				; still looking... now for '.exe'
 11906 000026EB 89C7                    		mov	di,ax
 11907 000026ED BE[563E]                		mov	si,EXEEXT ; ".EXE"
 11908 000026F0 A7                      		cmpsw
 11909 000026F1 7508                    		jnz	short FTYPE_BAT
 11910 000026F3 A7                      		cmpsw
 11911 000026F4 7505                    		jnz	short FTYPE_BAT
 11912                                  		;mov	ax,4
 11913 000026F6 B80400                  		mov	ax,SEARCH_EXE	; success!
 11914 000026F9 EB13                    		jmp	short FTYPE_EXIT
 11915                                  
 11916                                  		; Compare .BAT
 11917                                  FTYPE_BAT:				; still looking... now for '.bat'
 11918 000026FB 89C7                    		mov	di,ax
 11919 000026FD BE[5A3E]                		mov	si,BATEXT ; ".BAT"
 11920 00002700 A7                      		cmpsw
 11921 00002701 7508                    		jnz	short FTYPE_FAIL
 11922 00002703 A7                      		cmpsw
 11923 00002704 7505                    		jnz	short FTYPE_FAIL
 11924                                  		;mov	ax,2
 11925 00002706 B80200                  		mov	ax,SEARCH_BAT	; success!
 11926 00002709 EB03                    		jmp	short FTYPE_EXIT
 11927                                  
 11928                                  FTYPE_FAIL:				; file doesn't match what we need
 11929 0000270B B80000                  		mov	ax,ANULL ; 0
 11930                                  
 11931                                  FTYPE_EXIT:
 11932                                  		; MSDOS 6.0
 11933                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11934                                  		;jz	ftype_done	;AN005; no - exit
 11935                                  		;cmp	ax,ANULL	;AN005; was any match found
 11936                                  		;jz	ftype_done	;AN005; no - exit
 11937                                  		;mov	ext_entered,al	;AN005; save the match type found
 11938                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11939                                  ;ftype_done:
 11940 0000270E 5E                      		pop	si
 11941 0000270F 5F                      		pop	di
 11942 00002710 C3                      		retn
 11943                                  
 11944                                  ; =============== S U B	R O U T	I N E =======================================
 11945                                  
 11946                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 11947                                  ; replacing any extension with wildcards.
 11948                                  ;
 11949                                  ; ENTRY:
 11950                                  ;	BX		--		maximum length of destination buffer
 11951                                  ;	DS:SI		--		address of destination buffer
 11952                                  ;	argv[0] 	--		command name to be stripped
 11953                                  ; EXIT:
 11954                                  ;	CF		--		set if failure, clear if successful
 11955                                  ; NOTE(S):
 11956                                  
 11957                                  
 11958                                  STRIP:
 11959 00002711 50                      		push	ax
 11960 00002712 53                      		push	bx
 11961 00002713 51                      		push	cx
 11962 00002714 52                      		push	dx
 11963 00002715 57                      		push	di
 11964 00002716 56                      		push	si
 11965 00002717 9C                      		pushf
 11966                                  		
 11967                                  		; MSDOS 6.0
 11968                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 11969                                  
 11970                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11971                                  		;mov	dx,[ARG_ARGV]
 11972                                  		;mov	dx,ds:arg.argv[0].argpointer
 11973                                  					; save pointer to beginning of argstring
 11974                                  		;mov	dx,[ARGV0_ARGPOINTER]
 11975 00002718 8B16[E944]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 11976                                  		;mov	di,ds:arg.argv[0].argstartel
 11977                                  					; beginning of last pathname element
 11978                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 11979 0000271C 8B3E[EC44]              		mov	di,[ARG+ARGV_ELE.argstartel]
 11980 00002720 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 11981 00002723 742E                    		je	short STRIP_ERROR
 11982 00002725 89D1                    		mov	cx,dx		; compute where end of argstring lies
 11983                                  		;add	cx,ds:arg.argv[0].arglen
 11984                                  		;add	cx,[ARGV0_ARGLEN]
 11985 00002727 030E[EE44]              		add	cx,[ARG+ARGV_ELE.arglen]
 11986 0000272B 29F9                    		sub	cx,di		; and then find length of last element
 11987 0000272D 41                      		inc	cx		; include null as well
 11988                                  		;mov	al,'.'
 11989 0000272E B02E                    		mov	al,DOT		; let's find the filetype extension
 11990 00002730 FC                      		cld
 11991 00002731 F2AE                    		repnz scasb		; wind up pointing to either null or dot
 11992                                  
 11993                                  		; MSDOS 6.0
 11994                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 11995                                  		;mov	ext_entered,0	;AN005; we found an extension
 11996                                  		;mov	al,ANULL	;AN005; continue scanning until the
 11997                                  		;repnz	scasb		;AN005;    end of line is reached.
 11998                                  PROCESS_EXT:
 11999                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12000 00002733 89F9                    		mov	cx,di		; pointer to end of argstring yields
 12001 00002735 29D1                    		sub	cx,dx		; number of bytes to be copied
 12002 00002737 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 12003 0000273A 39D9                    		cmp	cx,bx
 12004 0000273C 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 12005 0000273E 89F7                    		mov	di,si		; destination buffer
 12006 00002740 89D6                    		mov	si,dx		; source is beginning of pathname
 12007 00002742 FC                      		cld
 12008 00002743 F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 12009                                  
 12010                                  		; MSDOS 6.0
 12011                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 12012                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 12013                                  
 12014                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12015 00002745 4F                      		dec	di		; overwrite null or dot
 12016 00002746 AA                      		stosb			; with a dot
 12017                                  		;mov	al,'?'
 12018 00002747 B03F                    		mov	al,WILDCHAR	; now add wildcards
 12019 00002749 AA                      		stosb
 12020 0000274A AA                      		stosb
 12021 0000274B AA                      		stosb
 12022                                  		;mov	al,0
 12023 0000274C B000                    		mov	al,ANULL	; and a terminating null	
 12024 0000274E AA                      		stosb
 12025                                  SKIP_WILDS:
 12026 0000274F 9D                      		popf
 12027 00002750 F8                      		clc
 12028 00002751 EB02                    		jmp	short STRIP_EXIT ; chill out...
 12029                                  
 12030                                  STRIP_ERROR:
 12031 00002753 9D                      		popf
 12032 00002754 F9                      		stc
 12033                                  STRIP_EXIT:
 12034 00002755 5E                      		pop	si
 12035 00002756 5F                      		pop	di
 12036 00002757 5A                      		pop	dx
 12037 00002758 59                      		pop	cx
 12038 00002759 5B                      		pop	bx
 12039 0000275A 58                      		pop	ax
 12040 0000275B C3                      		retn
 12041                                  
 12042                                  ; =============== S U B	R O U T	I N E =======================================
 12043                                  
 12044                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 12045                                  ;
 12046                                  ; structure in newly allocated memory. The argv[] structure is found at the
 12047                                  ; beginning of this area. The caller indicates how much extra space is
 12048                                  ; needed in the resulting structure; Save_Args returns a segment number and
 12049                                  ; an offset into that area, indicating where the caller may preserve its own
 12050                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 12051                                  ; ENTRY:
 12052                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 12053                                  ; EXIT:
 12054                                  ;   AX	    --	    segment of new area.
 12055                                  ;   CF	    --	    set if unable to save a copy.
 12056                                  ; NOTE(S):
 12057                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 12058                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 12059                                  ;	paragraphs.
 12060                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 12061                                  ;	as the caller of Save_Args requests.
 12062                                  ;   3)	AX is undefined if CF indicates an error.
 12063                                  
 12064                                  SAVE_ARGS:
 12065 0000275C 53                      		push	bx
 12066 0000275D 51                      		push	cx
 12067 0000275E 52                      		push	dx
 12068 0000275F 57                      		push	di
 12069 00002760 56                      		push	si
 12070 00002761 55                      		push	bp
 12071 00002762 9C                      		pushf
 12072                                  		;add	bx,1363		; space for arg structure, round up
 12073 00002763 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 12074 00002767 B104                    		mov	cl,4		; to paragraph size and convert
 12075 00002769 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 12076 0000276B B80048                  		mov	ax,ALLOC*256 ; 4800h
 12077 0000276E CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 12078                                  				; BX = number of 16-byte paragraphs desired
 12079 00002770 7244                    		jc	short SAVE_ERROR
 12080 00002772 89C5                    		mov	bp,ax		; save segment id
 12081 00002774 06                      		push	es		; save TRANGROUP address
 12082 00002775 8EC0                    		mov	es,ax		; switch to new memory segment
 12083                                  		; assume es:nothing
 12084                                  		;mov	cx,1348		; get back structure size
 12085 00002777 B94405                  		mov	cx,ARG_UNIT.SIZE
 12086 0000277A 31FF                    		xor	di,di		; destination is new memory area
 12087                                  		;mov	si,ARG_ARGV
 12088 0000277C BE[E944]                		mov	si,ARG		; source is arg structure
 12089 0000277F F3A4                    		rep movsb		; move that sucker!
 12090                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 12091                                  		;mov	cx,[ARG_ARGVCNT]
 12092 00002781 8B0E[A947]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 12093 00002785 31C0                    		xor	ax,ax		; base address for argv_calc
 12094                                  
 12095                                  	;	Bugbug:	What did they mean by this?
 12096                                  	;	Note that the replacement line produces exactly the same code.
 12097                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 12098                                  	;	mov	SI, OFFSET TRANGROUP:arg
 12099                                  
 12100                                  		;mov	si,ARG_ARGV
 12101 00002787 BE[E944]                		mov	si,ARG	
 12102                                  SAVE_PTR_LOOP:
 12103 0000278A 49                      		dec	cx		; exhausted all args?
 12104 0000278B 7C24                    		jl	short SAVE_DONE
 12105 0000278D 89CB                    		mov	bx,cx		; get arg index and
 12106 0000278F E8E4FC                  		call	ARGV_CALC	; convert to a pointer
 12107                                  		;mov	dx,ds:arg.argv[bx].argpointer
 12108                                  		;mov	dx,[ARG_ARGV+bx]
 12109 00002792 8B97[E944]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 12110 00002796 29F2                    		sub	dx,si		; adjust argpointer
 12111                                  		;mov	es:argv[BX].argpointer,dx
 12112                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12113 00002798 268917                  		mov	[es:bx],dx
 12114                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12115                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12116 0000279B 8B97[EC44]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12117 0000279F 29F2                    		sub	dx,si		; and adjust argstartel
 12118                                  		;mov	es:argv[bx].argstartel,dx
 12119                                  		;mov	[es:bx+3],dx
 12120 000027A1 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12121                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12122                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12123 000027A5 8B97[F244]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12124 000027A9 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12125                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12126                                  		;mov	[es:bx+9],dx
 12127 000027AB 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12128 000027AF EBD9                    		jmp	short SAVE_PTR_LOOP
 12129                                  SAVE_DONE:
 12130 000027B1 07                      		pop	es		; back we go to TRANGROUP
 12131                                  		; assume es:nothing
 12132 000027B2 89E8                    		mov	ax,bp		; restore segment id
 12133 000027B4 EB04                    		jmp	short SAVE_OK
 12134                                  
 12135                                  SAVE_ERROR:
 12136 000027B6 9D                      		popf
 12137 000027B7 F9                      		stc
 12138 000027B8 EB02                    		jmp	short SAVE_EXIT
 12139                                  
 12140                                  SAVE_OK:
 12141 000027BA 9D                      		popf
 12142 000027BB F8                      		clc
 12143                                  SAVE_EXIT:
 12144 000027BC 5D                      		pop	bp
 12145 000027BD 5E                      		pop	si
 12146 000027BE 5F                      		pop	di
 12147 000027BF 5A                      		pop	dx
 12148 000027C0 59                      		pop	cx
 12149 000027C1 5B                      		pop	bx
 12150 000027C2 C3                      		retn
 12151                                  
 12152                                  ;============================================================================
 12153                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12154                                  ;============================================================================
 12155                                  ; 02/10/2018 - Retro DOS v3.0
 12156                                  
 12157                                  ; Title	COMMAND Language midifiable Code Transient
 12158                                  
 12159                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12160                                  
 12161                                  ; =============== S U B	R O U T	I N E =======================================
 12162                                  
 12163                                  ; ****************************************************************
 12164                                  ; *
 12165                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12166                                  ; *
 12167                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12168                                  ; *		 user for Y/N if necessary. If an error occurs,
 12169                                  ; *		 set up an error message and go to CERROR.
 12170                                  ; *
 12171                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12172                                  ; *		 Current directory set to entered directory
 12173                                  ; *
 12174                                  ; * OUTPUT:	 none
 12175                                  ; *
 12176                                  ; ****************************************************************
 12177                                  ;
 12178                                  ; ARE YOU SURE prompt when deleting *.*
 12179                                  
 12180                                  NOTEST2:
 12181 000027C3 B90B00                  		mov	cx,11
 12182 000027C6 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12183                                  AMBSPEC:
 12184 000027C9 AC                      		lodsb
 12185 000027CA 3C3F                    		cmp	al,'?'
 12186 000027CC 7502                    		jnz	short ALLFIL
 12187 000027CE E2F9                    		loop	AMBSPEC
 12188                                  ALLFIL:
 12189 000027D0 83F900                  		cmp	cx,0
 12190 000027D3 7531                    		jnz	short NOPRMPT
 12191                                  ASKAGN:	
 12192 000027D5 BA[4C3A]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12193 000027D8 E8790C                  		call	STD_PRINTF
 12194 000027DB BE8000                  		mov	si,80h
 12195 000027DE 89F2                    		mov	dx,si
 12196 000027E0 C7047800                		mov	word [si],120	; zero length
 12197                                  		;mov	ax,0C0Ah
 12198 000027E4 B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12199 000027E7 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12200                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12201 000027E9 AD                      		lodsw
 12202 000027EA 08E4                    		or	ah,ah
 12203 000027EC 74E7                    		jz	short ASKAGN
 12204 000027EE E867F1                  		call	SCANOFF
 12205                                  		; MSDOS 6.0
 12206                                  		;call	char_in_xlat	; Convert to upper case
 12207                                  		;retc			; return if function not supported
 12208                                  		; MSDOS 3.3
 12209 000027F1 E87C01                  		call	UPCONV
 12210                                  		
 12211                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12212 000027F4 3A06[F93C]              		cmp	al,[CAPITAL_N]
 12213 000027F8 7501                    		jne	short CHECK_Y
 12214 000027FA C3                      		retn
 12215                                  CHECK_Y:
 12216 000027FB 3A06[F83C]              		cmp	al,[CAPITAL_Y]
 12217 000027FF 9C                      		pushf
 12218 00002800 E848F1                  		call	CRLF2
 12219 00002803 9D                      		popf
 12220 00002804 75CF                    		jne	short ASKAGN
 12221                                  NOPRMPT:
 12222 00002806 B413                    		mov	ah,FCB_DELETE ; 13h
 12223 00002808 BA5C00                  		mov	dx,FCB ; 5Ch
 12224 0000280B CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12225                                  				; DS:DX	-> FCB with filename field filled with
 12226                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12227                                  				; Return: AL = 00h file	found,FFh file	not found
 12228 0000280D FEC0                    		inc	al
 12229 0000280F 7404                    		jz	short ERAERR
 12230 00002811 E866F0                  		call	RESTUDIR
 12231 00002814 C3                      		retn
 12232                                  
 12233                                  		; MSDOS 6.0
 12234                                  ;eraerr:
 12235                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12236                                  		;push	dx			;AN022; save message
 12237                                  		;invoke	RESTUDIR
 12238                                  		;pop	dx			;AN022; restore message
 12239                                  		;
 12240                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12241                                  		;				;AN022; convert no more files to
 12242                                  		;jnz	cerrorj2		;AN022; 	file not found
 12243                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12244                                  		;			;AN000; get message number in control block
 12245                                  ;cerrorj2:
 12246                                  		;jmp	cerror
 12247                                  	
 12248                                  		; MSDOS 3.3
 12249                                  ERAERR:	
 12250 00002815 B41A                    		mov	ah,SET_DMA ; 1Ah
 12251 00002817 BA5C00                  		mov	dx,FCB ; 5Ch
 12252 0000281A CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12253                                  					; DS:DX	-> disk	transfer buffer
 12254 0000281C B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12255 0000281E CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12256                                  					; DS:DX	-> FCB
 12257 00002820 50                      		push	ax
 12258 00002821 E856F0                  		call	RESTUDIR
 12259 00002824 58                      		pop	ax
 12260 00002825 BA[5837]                		mov	dx,FNOTFOUNDPTR
 12261 00002828 FEC0                    		inc	al
 12262 0000282A 743D                    		jz	short CERRORJ
 12263 0000282C BA[7D37]                		mov	dx,ACCDENPTR
 12264 0000282F E9CEF3                  		jmp	CERROR
 12265                                  
 12266                                  ; =============== S U B	R O U T	I N E =======================================
 12267                                  
 12268                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12269                                  
 12270                                  ECHO:
 12271 00002832 E89400                  		call	ON_OFF
 12272 00002835 7212                    		jb	short DOEMES
 12273 00002837 8E1E[B141]              		mov	ds,[RESSEG]
 12274 0000283B 7506                    		jnz	short ECH_OFF
 12275 0000283D 800EEF0B01              		or	byte [ECHOFLAG],1
 12276 00002842 C3                      		retn
 12277                                  
 12278                                  ECH_OFF:
 12279 00002843 8026EF0BFE              		and	byte [ECHOFLAG],0FEh
 12280 00002848 C3                      		retn
 12281                                  
 12282                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12283                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12284                                  
 12285                                  DOEMES:
 12286                                  		; MSDOS 6.0
 12287                                  		;cmp	cl,0		;AC000; was anything on the line?
 12288                                  		;jz	PECHO		; just display current state.
 12289                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12290                                  		;invoke	CRPRINT
 12291                                  		;JMP	CRLF2
 12292                                  
 12293                                  		; MSDOS 3.3
 12294 00002849 E82000                  		call	MOVE_TO_FIRST_ARG
 12295 0000284C 7409                    		jz	short PECHO
 12296 0000284E BA8200                  		mov	dx,82h
 12297 00002851 E854F1                  		call	CRPRINT
 12298 00002854 E9F4F0                  		jmp	CRLF2
 12299                                  
 12300                                  PECHO:
 12301                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12302 00002857 8E1E[B141]              		mov	ds,[RESSEG]
 12303 0000285B 8A1EEF0B                		mov	bl,[ECHOFLAG]
 12304 0000285F 0E                      		push	cs
 12305 00002860 1F                      		pop	ds
 12306 00002861 80E301                  		and	bl,1
 12307 00002864 BA[7F3C]                		mov	dx,ECHOMESPTR
 12308 00002867 EB2E                    		jmp	short PYN
 12309                                  
 12310                                  ; ---------------------------------------------------------------------------
 12311                                  
 12312                                  		; MSDOS 3.3
 12313                                  CERRORJ:
 12314 00002869 E994F3                  		jmp	CERROR
 12315                                  
 12316                                  
 12317                                  ; =============== S U B	R O U T	I N E =======================================
 12318                                  
 12319                                  MOVE_TO_FIRST_ARG:
 12320 0000286C BE8100                  		mov	si,81h
 12321 0000286F E8E6F0                  		call	SCANOFF
 12322 00002872 3C0D                    		cmp	al,0Dh
 12323 00002874 C3                      		retn
 12324                                  
 12325                                  ; =============== S U B	R O U T	I N E =======================================
 12326                                  
 12327                                  CNTRLC:
 12328 00002875 E85100                  		call	ON_OFF
 12329 00002878 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12330 0000287B 720C                    		jc	short PCNTRLC
 12331 0000287D 7505                    		jnz	short CNTRLC_OFF
 12332 0000287F B201                    		mov	dl,1
 12333 00002881 CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12334                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12335                                  				; DL = 00h for OFF or 01h for ON
 12336 00002883 C3                      		retn
 12337                                  
 12338                                  ; ---------------------------------------------------------------------------
 12339                                  
 12340                                  CNTRLC_OFF:
 12341 00002884 30D2                    		xor	dl,dl
 12342 00002886 CD21                    		int	21h		; Turn off ^C check
 12343 00002888 C3                      		retn
 12344                                  
 12345                                  ; ---------------------------------------------------------------------------
 12346                                  
 12347                                  PCNTRLC:
 12348                                  		; MSDOS 6.0
 12349                                  		;CMP	CL,0		;AC000; rest of line blank?
 12350                                  		;JNZ	CERRORJ 	; no, oops!
 12351                                  
 12352                                  		; MSDOS 3.3
 12353 00002889 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12354 0000288C 75DB                    		jnz	short CERRORJ
 12355                                  ;pccont:
 12356                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12357 0000288E 30C0                    		xor	al,al
 12358 00002890 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12359 00002892 88D3                    		mov	bl,dl
 12360 00002894 BA[673C]                		mov	dx,CTRLMESPTR
 12361                                  
 12362                                  ; ---------------------------------------------------------------------------
 12363                                  
 12364                                  PYN:		; write "ON" or "OFF" state 
 12365                                  
 12366 00002897 E8BA0B                  		call	STD_PRINTF
 12367 0000289A BA[8E3C]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12368 0000289D 08DB                    		or	bl,bl
 12369 0000289F 7503                    		jnz	short PRINTVAL
 12370 000028A1 BA[873C]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12371                                  
 12372                                  PRINTVAL:
 12373                                  		; MSDOS 3.3
 12374 000028A4 E9AD0B                  		jmp	STD_PRINTF
 12375                                  
 12376                                  		; MSDOS 6.0
 12377                                  		;push	dx		;AN000; save offset of message block
 12378                                  		;mov	bx,dx		;AN000; save offset value
 12379                                  		;lodsw			;AN000; get message number of on or off
 12380                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12381                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12382                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12383                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12384                                  		;pop	dx		;AN000; get message back
 12385                                  		;invoke	std_printf	;AC000; go print message
 12386                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12387                                  		;
 12388                                  		;ret			;AN000; exit
 12389                                  
 12390                                  ; =============== S U B	R O U T	I N E =======================================
 12391                                  
 12392                                  VERIFY:
 12393 000028A7 E81F00                  		call	ON_OFF
 12394 000028AA B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12395 000028AD 720A                    		jc	short PVERIFY
 12396 000028AF 7503                    		jnz	short VER_OFF
 12397 000028B1 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12398                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12399 000028B3 C3                      		retn
 12400                                  
 12401                                  ; ---------------------------------------------------------------------------
 12402                                  
 12403                                  VER_OFF:
 12404 000028B4 FEC8                    		dec	al
 12405 000028B6 CD21                    		int	21h		; Turn off verify after write
 12406 000028B8 C3                      		retn
 12407                                  
 12408                                  ; ---------------------------------------------------------------------------
 12409                                  
 12410                                  PVERIFY:
 12411                                  		; MSDOS 6.0
 12412                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12413                                  		;JNZ	CERRORJ 	; nope...
 12414                                  
 12415                                  		; MSDOS 3.3
 12416 000028B9 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12417 000028BC 75AB                    		jnz	short CERRORJ
 12418                                  
 12419 000028BE B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12420 000028C0 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12421                                  					; Return: AL = 00h if flag OFF
 12422                                  					; AL = 01h if flag ON
 12423 000028C2 88C3                    		mov	bl,al
 12424 000028C4 BA[743C]                		mov	dx,VERIMESPTR
 12425 000028C7 EBCE                    		jmp	short PYN
 12426                                  
 12427                                  ; =============== S U B	R O U T	I N E =======================================
 12428                                  
 12429                                  ; ****************************************************************
 12430                                  ; *
 12431                                  ; * ROUTINE:	 ON_OFF
 12432                                  ; *
 12433                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12434                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12435                                  ; *		 routines.
 12436                                  ; *
 12437                                  ; * INPUT:	 command line at offset 81H
 12438                                  ; *		 PARSE_BREAK control block
 12439                                  ; *
 12440                                  ; * OUTPUT:	 If carry is clear
 12441                                  ; *		    If ON is found
 12442                                  ; *		       Zero flag set
 12443                                  ; *		    If OFF is found
 12444                                  ; *		       Zero flag clear
 12445                                  ; *		 If carry set
 12446                                  ; *		    If nothing on command line
 12447                                  ; *		       CL set to zero
 12448                                  ; *		    If error
 12449                                  ; *		       CL contains error value from parse
 12450                                  ; *
 12451                                  ; ****************************************************************
 12452                                  
 12453                                  ON_OFF:
 12454 000028C9 BE8100                  		mov	si,81h
 12455                                  
 12456                                  		; MSDOS 3.3
 12457 000028CC E889F0                  		call	SCANOFF		; scan off leading blanks & equal
 12458 000028CF 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12459 000028D1 742A                    		je	short BAD_ONF	; yes, return error
 12460 000028D3 AD                      		lodsw
 12461 000028D4 0D2020                  		or	ax,2020h	; convert to lowercase
 12462 000028D7 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12463 000028DA 7410                    		je	short ON_CHECK
 12464 000028DC 3D6F66                  		cmp	ax,666Fh ;'of'
 12465 000028DF 751C                    		jne	short BAD_ONF
 12466 000028E1 AC                      		lodsb
 12467 000028E2 0C20                    		or	al,20h		; convert to lowercase		
 12468 000028E4 3C66                    		cmp	al,66h	 ; 'f'
 12469 000028E6 7515                    		jne	short BAD_ONF	
 12470 000028E8 0C66                    		or	al,66h ; or al,'f'
 12471 000028EA EB02                    		jmp	short OFF_CHECK
 12472                                  ON_CHECK:
 12473 000028EC 30C0                    		xor	al,al
 12474                                  OFF_CHECK:
 12475 000028EE 9F                      		lahf
 12476 000028EF 89C3                    		mov	bx,ax
 12477 000028F1 E864F0                  		call	SCANOFF		; scan off leading blanks & equal
 12478 000028F4 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12479 000028F6 7505                    		jne	short BAD_ONF	; no, return error
 12480 000028F8 89D8                    		mov	ax,bx
 12481 000028FA 9E                      		sahf
 12482 000028FB F8                      		clc
 12483 000028FC C3                      		retn
 12484                                  
 12485                                  		; MSDOS 6.0
 12486                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12487                                  ;		lodsb			;AN032; get a char
 12488                                  ;		cmp	al,blank	;AN032; if whitespace
 12489                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12490                                  ;		cmp	al,tab_chr	;AN032; if tab
 12491                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12492                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12493                                  ;		jz	parse_on_off	;AN032;    start parsing
 12494                                  ;		dec	si		;AN032; if none of above - back up
 12495                                  ;
 12496                                  ;parse_on_off:				;AN032;    and start parsing
 12497                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get address of PARSE_BREAK
 12498                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12499                                  ;		xor	dx,dx		;AN000;
 12500                                  ;		invoke	cmd_parse	;AC000; call parser
 12501                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12502                                  ;		jz	BADONF		;AC000; yes, return error
 12503                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12504                                  ;		jz	on_off_there	;AN000; no - continue
 12505                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12506                                  ;		jmp	short BADONF	;AN000; return error
 12507                                  ;
 12508                                  ;on_off_there:
 12509                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12510                                  ;		jnz	good_on_off	;AN014; yes - continue
 12511                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12512                                  ;		jmp	short BADONF	;AN014; return error
 12513                                  ;
 12514                                  ;good_on_off:				;AN014;
 12515                                  ;		xor	ax,ax		;AC000; set up return code for
 12516                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12517                                  ;		pushf			;AN000; save flags
 12518                                  ;		mov	di,offset trangroup:parse_break
 12519                                  ;					;AN000; Get address of PARSE_BREAK
 12520                                  ;		xor	dx,dx		;AN000;
 12521                                  ;		invoke	cmd_parse	;AN000; call parser
 12522                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12523                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12524                                  ;		popf			;AN000; restore flags
 12525                                  ;		clc			;AC000; no error
 12526                                  ;		jmp	short on_off_end ;AN000; return to caller
 12527                                  ;
 12528                                  ;BADONF_flags:
 12529                                  ;		mov	cx,ax
 12530                                  ;		popf
 12531                                  
 12532                                  ; ---------------------------------------------------------------------------
 12533                                  
 12534                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12535                                  ; and return the error
 12536                                  
 12537                                  BAD_ONF:
 12538 000028FD BA[493B]                		mov	dx,BADONOFFPTR
 12539 00002900 F9                      		stc
 12540                                  ;on_off_end:
 12541 00002901 C3                      		retn
 12542                                  
 12543                                  ;============================================================================
 12544                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12545                                  ;============================================================================
 12546                                  ; 02/10/2018 - Retro DOS v3.0
 12547                                  
 12548                                  ; Print volume ID info
 12549                                  
 12550                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12551                                  
 12552                                  ; ---------------------------------------------------------------------------
 12553                                  
 12554                                  PRINTVOL:
 12555 00002902 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12556 00002903 A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12557 00002906 0440                    		add	al,'@'
 12558 00002908 3C40                    		cmp	al,'@'
 12559 0000290A 7505                    		jnz	short DRVOK
 12560 0000290C A0[C541]                		mov	al,[CURDRV]
 12561                                  		;add	al,[CAPITAL_A]
 12562                                  		; 01/03/2023
 12563 0000290F 0441                    		add	al,capital_A  ; add al,'A'
 12564                                  DRVOK:
 12565 00002911 A2[A443]                		mov	[VOL_DRV],al	; get drive letter into argument
 12566 00002914 58                      		pop	ax		; get return code back
 12567 00002915 BA[B53A]                		mov	dx,NOVOL ; "has	no label" 
 12568 00002918 08C0                    		or	al,al		; volume label found?
 12569 0000291A 7517                    		jnz	short PRINTVOL2	; print no volume message
 12570                                  GOODVOL:
 12571                                  		; MSDOS 3.3
 12572 0000291C BF[DB41]                		mov	di,CHARBUF
 12573 0000291F 89FA                    		mov	dx,di
 12574 00002921 BE[B13A]                		mov	si,IS	; "is "
 12575 00002924 E85CDF                  		call	STRCPY
 12576 00002927 4F                      		dec	di
 12577 00002928 BE[B242]                		mov	si,DIRBUF+8
 12578 0000292B B90B00                  		mov	cx,11
 12579 0000292E F3A4                    		rep movsb
 12580 00002930 31C0                    		xor	ax,ax
 12581                                  		;xor	al,al  ; MSDOS 6.0
 12582 00002932 AA                      		stosb			; store a zero to terminate the string
 12583                                  PRINTVOL2:
 12584 00002933 8916[A243]              		mov	[VOLNAME_ADDR],dx
 12585 00002937 BA[AB3A]                		mov	dx,VOLMESPTR
 12586 0000293A E9070B                  		jmp	PRINTF_CRLF
 12587                                  
 12588                                  		; MSDOS 6.0
 12589                                  ;drvok:
 12590                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12591                                  ;		pop	ax		;AC000; get return code back
 12592                                  ;		or	al,al		;AC000; volume label found?
 12593                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12594                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12595                                  ;					;AC000; set up no volume message
 12596                                  ;		jmp	short print_serial	;AC000; go print it
 12597                                  ;
 12598                                  ;Get_vol_name:
 12599                                  ;		mov	di,offset trangroup:charbuf
 12600                                  ;		mov	dx,di
 12601                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12602                                  ;		mov	cx,11				;AN000;  3/3/KK
 12603                                  ;		rep	movsb				;AN000;  3/3/KK
 12604                                  ;
 12605                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12606                                  ;		stosb
 12607                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12608                                  ;
 12609                                  ;PRINT_SERIAL:
 12610                                  ;
 12611                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12612                                  ;; occurs, do not print volume serial number.
 12613                                  ;
 12614                                  ;		push	dx		;AN000; save message offset
 12615                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12616                                  ;					;AC036; Get the volume serial info
 12617                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12618                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12619                                  ;		int	21h		;AN000; do the call
 12620                                  ;		pop	dx		;AN000; get message offset back
 12621                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12622                                  ;		call	std_printf	;AC000; go print volume message
 12623                                  ;		mov	al,blank	;AN051; Print out a blank
 12624                                  ;		invoke	print_char	;AN051;   before volume message
 12625                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12626                                  ;					;AN000; get serial number message
 12627                                  ;printvol_end:
 12628                                  ;		jmp	std_printf	;AC000; go print and exit
 12629                                  
 12630                                  ;============================================================================
 12631                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12632                                  ;============================================================================
 12633                                  ; 02/10/2018 - Retro DOS v3.0
 12634                                  
 12635                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12636                                  
 12637                                  ; =============== S U B	R O U T	I N E =======================================
 12638                                  
 12639                                  PRINT_DATE:
 12640                                  		; MSDOS 3.3
 12641 0000293D 06                      		push	es
 12642 0000293E 57                      		push	di
 12643 0000293F 0E                      		push	cs
 12644 00002940 07                      		pop	es
 12645 00002941 BF[0843]                		mov	di,ARG_BUF
 12646 00002944 B42A                    		mov	ah,GET_DATE ; 2Ah
 12647 00002946 CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12648                                  				; Return: DL = day,DH = month,	CX = year
 12649                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12650 00002948 98                      		cbw
 12651 00002949 E80F00                  		call	GETDATE
 12652 0000294C E8F8F6                  		call	P_DATE
 12653 0000294F 30C0                    		xor	al,al
 12654 00002951 AA                      		stosb
 12655 00002952 BA[8336]                		mov	dx,ARG_BUF_PTR
 12656 00002955 E8FC0A                  		call	STD_PRINTF
 12657 00002958 07                      		pop	es
 12658 00002959 5F                      		pop	di
 12659 0000295A C3                      		retn
 12660                                  
 12661                                  		; MSDOS 6.0
 12662                                  		;PUSH	ES
 12663                                  		;PUSH	DI
 12664                                  		;PUSH	CS
 12665                                  		;POP	ES
 12666                                  		;CALL	GetDate 		; get date
 12667                                  		;xchg	dh,dl			;AN000; switch month & day
 12668                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12669                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12670                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12671                                  		;invoke	std_printf
 12672                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12673                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12674                                  		;POP	DI			;AC000; restore di,es
 12675                                  		;POP	ES			;AC000;
 12676                                  		;return
 12677                                  
 12678                                  ; ---------------------------------------------------------------------------
 12679                                  
 12680                                  GETDATE:
 12681                                  		; MSDOS 3.3
 12682 0000295B 89C6                    		mov	si,ax
 12683 0000295D D1E6                    		shl	si,1
 12684 0000295F 01C6                    		add	si,ax
 12685 00002961 81C6[8439]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12686 00002965 89CB                    		mov	bx,cx
 12687 00002967 B90300                  		mov	cx,3
 12688 0000296A F3A4                    		rep movsb
 12689 0000296C B020                    		mov	al,' '
 12690 0000296E AA                      		stosb
 12691 0000296F C3                      		retn
 12692                                  
 12693                                  		; MSDOS 6.0
 12694                                  
 12695                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12696                                  ; for output.  Date will be returned in CX,DX.
 12697                                  
 12698                                  ;GetDate:
 12699                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12700                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12701                                  		;INT	21h			;AC000; Get date in CX:DX
 12702                                  		;CBW				;AC000;
 12703                                  		;
 12704                                  		;push	cx			;AN000; save date returned in
 12705                                  		;push	dx			;AN000;      CX:DX
 12706                                  		;MOV	SI,AX
 12707                                  		;
 12708                                  		;SHL	SI,1
 12709                                  		;ADD	SI,AX			; SI=AX*3
 12710                                  		;
 12711                                  		;mov	cx,si			;AN000; save si
 12712                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12713                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12714                                  		;push	di			;AN000; save argument buffer
 12715                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12716                                  		;pop	di			;AN000; retrieve argument buffer
 12717                                  		;add	si,cx			;AC000; get day of week
 12718                                  		;
 12719                                  		;MOV	CX,3
 12720                                    		;REP	MOVSB
 12721                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12722                                  		;stosb
 12723                                  		;pop	dx			;AN000; get back date
 12724                                  		;pop	cx			;AN000;
 12725                                  		;
 12726                                  		;return
 12727                                  
 12728                                  ; =============== S U B	R O U T	I N E =======================================
 12729                                  
 12730                                  		; MSDOS 6.0
 12731                                  
 12732                                  ; This routine determines whether the character in AL is a
 12733                                  ; Yes or No character. On return, if AL=0, the character is
 12734                                  ; No, if AL=1, the character is Yes.
 12735                                  
 12736                                  ;		assume	ds:trangroup
 12737                                  
 12738                                  ;char_in_xlat	proc	near
 12739                                  ;
 12740                                  ;		mov	dl,al			;AC000; get character into DX
 12741                                  ;		xor	dh,dh			;AC000;
 12742                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12743                                  ;		int	21h			;AC000;
 12744                                  ;
 12745                                  ;		ret
 12746                                  ;
 12747                                  ;char_in_xlat	endp
 12748                                  
 12749                                  ;============================================================================
 12750                                  ; TENV.ASM, MSDOS 6.0, 1991
 12751                                  ;============================================================================
 12752                                  ; 02/10/2018 - Retro DOS v3.0
 12753                                  
 12754                                  ;	Environment utilities and misc. routines
 12755                                  
 12756                                  ; MSDOS 6.0
 12757                                  ; ****************************************************************
 12758                                  ; *
 12759                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12760                                  ; *
 12761                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12762                                  ; *		 the character in AL from the file upper case table
 12763                                  ; *		 in DOS if character if above  ascii 128, else
 12764                                  ; *		 subtracts 20H if between "a" and "z".
 12765                                  ; *
 12766                                  ; * INPUT:	 AL	      char to be upper cased
 12767                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12768                                  ; *
 12769                                  ; * OUTPUT:	 AL	      upper cased character
 12770                                  ; *
 12771                                  ; ****************************************************************
 12772                                  ;
 12773                                  ;assume	ds:trangroup				;AN000;
 12774                                  ;
 12775                                  ;upconv	proc	near				;AN000;
 12776                                  ;
 12777                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12778                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12779                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12780                                  ;	push	ds				;AN000;
 12781                                  ;	push	bx				;AN000;
 12782                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12783                                  ;assume	ds:resgroup				;AN000;
 12784                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12785                                  ;	add	bx,2				;AN000;  skip over first word
 12786                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12787                                  ;	pop	bx				;AN000;
 12788                                  ;	pop	ds				;AN000;
 12789                                  ;assume	ds:trangroup				;AN000;
 12790                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12791                                  ;
 12792                                  ;oth_fucase:					;AN000;
 12793                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12794                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12795                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12796                                  ;	ja	upconv_end			;AC000;
 12797                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12798                                  ;
 12799                                  ;upconv_end:					;AN000;
 12800                                  ;	ret
 12801                                  ;
 12802                                  ;upconv	endp					;AN000;
 12803                                  
 12804                                  
 12805                                  ; =============== S U B	R O U T	I N E =======================================
 12806                                  
 12807                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12808                                  
 12809                                  UPCONV:
 12810 00002970 3C80                    		cmp	al,80h
 12811 00002972 7214                    		jb	short OTH_UCASE
 12812 00002974 2C80                    		sub	al,80h
 12813 00002976 1E                      		push	ds
 12814 00002977 53                      		push	bx
 12815 00002978 8E1E[B141]              		mov	ds,[RESSEG]
 12816 0000297C C51E060C                		lds	bx,[UPPERCASETBL]
 12817 00002980 83C302                  		add	bx,2
 12818 00002983 D7                      		xlat
 12819 00002984 5B                      		pop	bx
 12820 00002985 1F                      		pop	ds
 12821 00002986 EB0A                    		jmp	short UPCONV_RETN
 12822                                  
 12823                                  OTH_UCASE:
 12824 00002988 3C61                    		cmp	al,'a'
 12825 0000298A 7206                    		jb	short UPCONV_RETN
 12826 0000298C 3C7A                    		cmp	al,'z'
 12827 0000298E 7702                    		ja	short UPCONV_RETN
 12828 00002990 2C20                    		sub	al,20h
 12829                                  
 12830                                  UPCONV_RETN:
 12831 00002992 C3                      		retn
 12832                                  
 12833                                  ;============================================================================
 12834                                  ; COPY.ASM, MSDOS 6.0, 1991
 12835                                  ;============================================================================
 12836                                  ; 01/10/2018 - Retro DOS v3.0
 12837                                  
 12838                                  ;	title	COMMAND COPY routines.
 12839                                  
 12840                                  ;/*
 12841                                  ; *                      Microsoft Confidential
 12842                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12843                                  ; *                      All Rights Reserved.
 12844                                  ; */
 12845                                  
 12846                                  ;***	COPY.ASM
 12847                                  
 12848                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12849                                  
 12850                                  
 12851                                  ;***	MODIFICATION HISTORY
 12852                                  
 12853                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12854                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12855                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12856                                  ;	     to tokens which begin with path characters so that PARSELINE
 12857                                  ;	     will work correctly.
 12858                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12859                                  ;	     individual tokens.  That distinction is no longer needed for
 12860                                  ;	     FOR loop processing.
 12861                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12862                                  ;	     1 when Cparse is called from COPY.
 12863                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12864                                  ;	     mod.  It now is conditional on flag like previous mod.
 12865                                  ;11/21/83 NP  Added printf
 12866                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12867                                  ;	     be added to a token.
 12868                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12869                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12870                                  ;	     special values:  -1 meaning destination was never opened and
 12871                                  ;	     0 which means that the destination has been openned and
 12872                                  ;	     closed.
 12873                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12874                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12875                                  ;	     lost on large and multiple file (wildcard) copies.
 12876                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12877                                  ;	     destination are not equal.
 12878                                  ;
 12879                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12880                                  ;	     first source file AND we run out of disk space before
 12881                                  ;	     completing the concatenation, restore the first source
 12882                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12883                                  ;
 12884                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12885                                  ;		instead of compatibility mode. This gives lesser sharing
 12886                                  ;		violations when files are opened for read on a copy.
 12887                                  
 12888                                  ; ---------------------------------------------------------------------------
 12889                                  ;***	COPY CODE
 12890                                  ; ---------------------------------------------------------------------------
 12891                                  
 12892                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12893                                  
 12894                                  COPY:
 12895                                  	; 	Initialize internal variables.
 12896                                  
 12897 00002993 31C0                    		xor	ax,ax		; AX = 0
 12898 00002995 A3[9043]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12899 00002998 A3[C544]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12900 0000299B A3[1144]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12901 0000299E A2[D041]                		mov	[CFLAG],al	; 'destination file created' = false
 12902 000029A1 A3[D441]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12903 000029A4 A3[CC41]                		mov	[DESTSWITCH],ax	; destination switches = none
 12904 000029A7 A3[D744]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12905 000029AA A3[AE43]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12906 000029AD A2[D141]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12907 000029B0 A2[AD43]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12908 000029B3 A2[1044]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12909 000029B6 A2[B043]                		mov	[DESTINFO],al	; destination pathname flags = none
 12910 000029B9 A2[1344]                		mov	[SRCINFO],al	; source pathname flags = none
 12911 000029BC A2[C744]                		mov	[INEXACT],al	; 'inexact copy' = false
 12912 000029BF A2[AC43]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12913 000029C2 A2[0F44]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12914 000029C5 A2[9340]                		mov	[USERDIR1],al	; saved working directory = null
 12915 000029C8 A2[C944]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12916 000029CB A2[C441]                		mov	[RDEOF],al	; 'read end of file' = false
 12917 000029CE A3[6B44]                		mov	[SRCHAND],ax	; source handle = 0
 12918 000029D1 A3[D144]                		mov	[CPDATE],ax	; copy date = 0
 12919 000029D4 A3[D344]                		mov	[CPTIME],ax	; copy time = 0
 12920 000029D7 A2[6D44]                		mov	[SRCISDEV],al	; 'source is device' = false
 12921                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12922                                  		;mov	[OFilePtr_Lo],ax
 12923                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12924 000029DA A2[CD44]                		mov	[TERMREAD],al	; 'terminate read' = false
 12925 000029DD A2[0643]                		mov	[COMMA],al	; '"+,," found' = false
 12926 000029E0 A2[0743]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12927 000029E3 A3[CE41]                		mov	[ALLSWITCH],ax	; all switches = none
 12928 000029E6 A2[C741]                		mov	[ARGC],al	; source/dest argument count = 0
 12929 000029E9 A2[CF44]                		mov	[PLUS],al	; '"+" in command line' = false
 12930 000029EC A2[CA44]                		mov	[BINARY],al	; 'binary copy' = false
 12931 000029EF A2[CE44]                		mov	[ASCII],al	; 'ascii copy' = false
 12932 000029F2 A3[D941]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12933 000029F5 A3[CB44]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12934 000029F8 A2[C641]                		mov	[CONCAT],al	; 'concatenating' = false
 12935 000029FB A2[0C44]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12936 000029FE A3[0D44]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12937                                  
 12938                                  	;	Initialize buffers with double-nulls.
 12939                                  
 12940 00002A01 A3[6E44]                		mov	[SCANBUF],ax
 12941 00002A04 A3[B143]                		mov	[DESTBUF],ax
 12942 00002A07 A3[1444]                		mov	[SRCBUF],ax
 12943 00002A0A A3[F042]                		mov	[SDIRBUF],ax
 12944 00002A0D A3[AA42]                		mov	[DIRBUF],ax
 12945 00002A10 A3[6742]                		mov	[DESTFCB],ax
 12946                                  
 12947 00002A13 A2[D044]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 12948                                  		
 12949 00002A16 48                      		dec	ax		; AX = 0FFFFh
 12950 00002A17 A3[0844]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 12951 00002A1A A2[D641]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 12952 00002A1D A2[0B44]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 12953 00002A20 A2[AC43]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 12954                                  		
 12955 00002A23 BE8100                  		mov	si,81h		; SI = ptr to command line
 12956                                  		;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 12957                                  		; 01/03/2023
 12958                                  		;mov	bl,'+'
 12959 00002A26 B32B                    		mov	bl,plus_chr
 12960 00002A28 FE06[E744]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 12961 00002A2C C606[9643]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 12962                                  
 12963                                  	;*	Scan the command line for destination information.
 12964                                  
 12965                                  DESTSCAN:
 12966 00002A31 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 12967 00002A33 BF[6E44]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 12968                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 12969 00002A36 E86608                  		call	CPARSE			; parse next object
 12970 00002A39 9C                      		pushf				; save CParse flags
 12971 00002A3A FE06[D044]              		inc	byte [OBJCNT]		; count object
 12972 00002A3E F6C780                  		test	bh,80h
 12973 00002A41 7405                    		jz	short NOCOPY		; no "+" delimiter
 12974 00002A43 C606[CF44]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 12975                                  NOCOPY:
 12976 00002A48 F6C701                  		test	bh,1
 12977 00002A4B 740D                    		jz	short TESTP2		; not a switch
 12978                                  
 12979                                  	;	Found a switch.
 12980                                  
 12981                                  		; MSDOS 6.0
 12982                                  		;test	bp,SwitchV		;AN038; Verify requested?
 12983                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12984                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 12985                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12986                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 12987                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 12988                                  
 12989                                  NOT_SLASHV:
 12990 00002A4D 092E[CC41]              		or	[DESTSWITCH],bp		; assume destination
 12991 00002A51 092E[CE41]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 12992                                  
 12993                                  		; MSDOS 6.0
 12994                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 12995                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 12996                                  		;popf				;AN018; fix up stack
 12997                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 12998                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 12999                                  		;jmp	CError			;AC018; exit
 13000                                  
 13001                                  NOT_BAD_SWITCH:
 13002 00002A55 9D                      		popf				; restore CParse flags
 13003 00002A56 7233                    		jc	short CHECKDONE		; found CR
 13004 00002A58 EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 13005                                  
 13006                                  TESTP2:
 13007 00002A5A 9D                      		popf				; restore CParse flags
 13008 00002A5B 722E                    		jc	short CHECKDONE		; found CR
 13009 00002A5D F6C780                  		test	bh,80h
 13010 00002A60 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 13011 00002A62 FE06[C741]              		inc	byte [ARGC]		; count independent pathname args
 13012                                  GOTPLUS:
 13013 00002A66 56                      		push	si			; save cmd line ptr
 13014 00002A67 A1[D744]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 13015 00002A6A BE[6E44]                		mov	si,SCANBUF		; SI = ptr to path string
 13016 00002A6D 29F0                    		sub	ax,si			; AX = offset of last element
 13017 00002A6F BF[B143]                		mov	di,DESTBUF		; DI = ptr to destination buf
 13018 00002A72 01F8                    		add	ax,di			; AX = ptr to last element in
 13019                                  						;  destination path buffer
 13020 00002A74 A3[AE43]                		mov	[DESTTAIL],ax		; save ptr to last element
 13021 00002A77 880E[AD43]              		mov	[DESTSIZ],cl		; save path string length
 13022 00002A7B 41                      		inc	cx			; CX = mov length (incl null)
 13023 00002A7C F3A4                    		rep movsb			; DestBuf = possible destination path
 13024 00002A7E 883E[B043]              		mov	[DESTINFO],bh		; save CParse info flags
 13025 00002A82 C706[CC41]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13026 00002A88 5E                      		pop	si			; SI = ptr into cmd line again
 13027 00002A89 EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 13028                                  
 13029                                  CHECKDONE:
 13030                                  
 13031                                  	;	We reached the CR. The destination scan is finished.
 13032                                  
 13033                                  	;	Disallow "copy file1+" as file overwriting itself.
 13034                                  	;
 13035                                  	;	(Note that "copy file1+file2+" will be accepted, and
 13036                                  	;	equivalent to "copy file1+file2".)
 13037                                  
 13038                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 13039                                  	;	through this check, since the switch would count
 13040                                  	;	as another object in ObjCnt.
 13041                                  
 13042 00002A8B 803E[CF44]01            		cmp	byte [PLUS],1		; "+" with
 13043 00002A90 7514                    		jnz	short CDCONT
 13044 00002A92 803E[C741]01            		cmp	byte [ARGC],1		; one arg,
 13045 00002A97 750D                    		jnz	short CDCONT
 13046 00002A99 803E[D044]02            		cmp	byte [OBJCNT],2		; two objects..
 13047 00002A9E 7506                    		jnz	short CDCONT
 13048 00002AA0 BA[F437]                		mov	dx,OVERWRPTR
 13049 00002AA3 E9AA05                  		jmp	COPYERR			; is file overwrite
 13050                                  
 13051                                  CDCONT:
 13052 00002AA6 A0[CF44]                		mov	al,[PLUS]		; AL = '"+" occurred'
 13053 00002AA9 A2[C641]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 13054 00002AAC D0E0                    		shl	al,1
 13055 00002AAE D0E0                    		shl	al,1
 13056 00002AB0 A2[C744]                		mov	[INEXACT],al		; therefore making an inexact copy
 13057 00002AB3 BA[CD3C]                		mov	dx,BADARGSPTR
 13058 00002AB6 A0[C741]                		mov	al,[ARGC]		; AL = # independent arguments
 13059 00002AB9 08C0                    		or	al,al
 13060 00002ABB 7404                    		jz	short CERROR4J
 13061                                  
 13062                                  		; MSDOS 6.0
 13063                                  		;or	al,al
 13064                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 13065                                  		
 13066                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 13067                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 13068                                  		;jmp	short CError_ParseJ		; take parse error exit		
 13069                                  
 13070                                  	; more than 0 args; check if too many
 13071                                  
 13072                                  TRY_TOO_MANY:
 13073 00002ABD 3C02                    		cmp	al,2
 13074 00002ABF 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 13075                                  
 13076                                  		; MSDOS 6.0
 13077                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 13078                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 13079                                  ;CError_ParseJ:
 13080                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 13081                                  
 13082                                  CERROR4J:
 13083 00002AC1 E93CF1                  		jmp	CERROR
 13084                                  
 13085                                  ACOUNTOK:
 13086 00002AC4 BD[AC43]                		mov	bp,DESTVARS		; BP = base of dest variables
 13087                                  
 13088 00002AC7 3C01                    		cmp	al,1
 13089 00002AC9 7520                    		jnz	short GOT2ARGS
 13090                                  
 13091                                  	;	Only one independent pathname argument on command line.
 13092                                  	;	Set destination to d:*.*, where d: is current drive.
 13093                                  
 13094                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 13095                                  	;	The two files would be appended as d:file1, rather than x:file1.
 13096                                  
 13097 00002ACB A0[C541]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 13098                                  		;add	al,[CAPITAL_A]		; AL = current drive letter
 13099                                  		; 01/03/2023
 13100 00002ACE 0441                    		add	al,capital_A  ; add al,'A'
 13101 00002AD0 B43A                    		mov	ah,':'			; AX = "d:"
 13102                                  		;mov	byte [bp+1],2
 13103 00002AD2 C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 13104                                  
 13105 00002AD6 BF[B143]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 13106 00002AD9 AB                      		stosw				; store "d:"
 13107                                  		
 13108 00002ADA C706[CC41]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13109                                  		;mov	byte [bp+4],2		
 13110 00002AE0 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13111                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13112                                  		;mov	byte [bp+0],0		
 13113 00002AE4 C6460000                		mov	byte [bp],0
 13114 00002AE8 E88407                  		call	SETSTARS		; add wildcards
 13115                                  GOT2ARGS:
 13116                                  
 13117                                  	;	If destination pathname is "d:", add full wildcard filename
 13118                                  
 13119                                  		;cmp	byte [bp+1],2
 13120 00002AEB 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13121 00002AEF 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13122 00002AF1 B03A                    		mov	al,':'
 13123 00002AF3 3806[B243]              		cmp	[DESTBUF+1],al
 13124 00002AF7 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13125                                  		;or	byte [bp+4],2
 13126 00002AF9 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13127 00002AFD BF[B343]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13128                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13129                                  		;mov	byte [bp+0],0		
 13130 00002B00 C6460000                		mov	byte [bp],0
 13131 00002B04 E86807                  		call	SETSTARS		; add wildcards
 13132                                  
 13133                                  NOTSHORTDEST:
 13134                                  
 13135                                  	;	If destination pathname ends with "\", try to make
 13136                                  	;	sure it's "d:\".
 13137                                  
 13138                                  		;mov	di,[bp+2]
 13139 00002B07 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13140 00002B0A 803D00                  		cmp	byte [di],0
 13141 00002B0D 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13142                                  
 13143 00002B0F BA[D63A]                		mov	dx,BADCDPTR
 13144 00002B12 B03A                    		mov	al,':'
 13145 00002B14 3845FE                  		cmp	[di-2],al
 13146 00002B17 75A8                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13147                                  		;mov	byte [bp+0],2
 13148                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13149 00002B19 C6460002                		mov	byte [bp],2
 13150                                  		;or	byte [bp+4],6
 13151 00002B1D 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13152                                  						  ;  path character
 13153 00002B21 E84B07                  		call	SETSTARS		; add wildcards
 13154                                  
 13155                                  CHKSWTCHES:
 13156                                  
 13157                                  	;	We have enough information about the destination for now.
 13158                                  
 13159                                  	;	Turn on verify if requested. Save the current verify flag.
 13160                                  
 13161 00002B24 BA[8239]                		mov	dx,BADPARMPTR
 13162 00002B27 A1[CE41]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13163                                  
 13164                                  		; MSDOS 3.3
 13165                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13166 00002B2A A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13167 00002B2D 7592                    		jnz	short CERROR4J
 13168                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13169 00002B2F A91000                  		test	ax,SWITCHV ; 10h
 13170 00002B32 7414                    		jz	short NOVERIF		; no /v, no verify
 13171                                  
 13172 00002B34 B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13173 00002B36 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13174                                  					; Return: AL = 00h if flag OFF
 13175                                  					; AL = 01h if flag ON
 13176 00002B38 1E                      		push	ds
 13177 00002B39 8E1E[B141]              		mov	ds,[RESSEG]
 13178 00002B3D 30E4                    		xor	ah,ah
 13179 00002B3F A3F70B                  		mov	[VERVAL],ax	; save current verify flag
 13180 00002B42 1F                      		pop	ds
 13181 00002B43 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13182 00002B46 CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13183                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13184                                  NOVERIF:
 13185                                  		;*	Scan for first source.
 13186                                  
 13187 00002B48 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13188 00002B4A BE8100                  		mov	si,81h			; SI = ptr into command line
 13189                                  		;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13190                                  		; 01/03/2023
 13191 00002B4D B32B                    		mov	bl,plus_chr  ; mov bl,'+'
 13192                                  SCANFSRC:
 13193 00002B4F BF[6E44]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13194 00002B52 E84A07                  		call	CPARSE			; parse first source pathname
 13195 00002B55 F6C701                  		test	bh,1			; switch?
 13196 00002B58 75F5                    		jnz	short SCANFSRC		; yes, try again
 13197 00002B5A 092E[CC41]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13198                                  
 13199                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13200                                  
 13201                                  		;test	bp,8
 13202 00002B5E F7C50800                		test	bp,SWITCHB
 13203 00002B62 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13204 00002B64 803E[C641]00            		cmp	byte [CONCAT],0
 13205 00002B69 7405                    		je	short NOSETCASC		; we're not concatenating
 13206                                  		;mov	byte [ASCII],4
 13207 00002B6B C606[CE44]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13208                                  NOSETCASC:
 13209 00002B70 E88F03                  		call	SOURCE_SET		; set source variables
 13210 00002B73 E83B00                  		call	FRSTSRC			; set up first source copy
 13211 00002B76 E98C00                  		jmp	FIRSTENT		; jump into the copy loop
 13212                                  
 13213                                  ; ---------------------------------------------------------------------------
 13214                                  
 13215                                  ENDCOPY:
 13216                                  
 13217                                  	;*	End of the road. Close destination, display # files
 13218                                  	;	copied (meaning # destinations), and go back to main
 13219                                  	;	transient COMMAND code.
 13220                                  
 13221 00002B79 E8A002                  		call	CLOSEDEST
 13222                                  ENDCOPY2:
 13223 00002B7C BA[5E38]                		mov	dx,COPIEDPTR
 13224 00002B7F 8B36[D941]              		mov	si,[FILECNT]
 13225 00002B83 8936[9043]              		mov	[COPY_NUM],si
 13226 00002B87 E8CA08                  		call	STD_PRINTF
 13227 00002B8A E977D5                  		jmp	TCOMMAND		; stack could be messed up
 13228                                  
 13229                                  ; ---------------------------------------------------------------------------
 13230                                  
 13231                                  SRCNONEXIST:
 13232                                  
 13233                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13234                                  	;	Otherwise, say 'file not found' and quit.
 13235                                  
 13236 00002B8D 803E[C641]00            		cmp	byte [CONCAT],0
 13237 00002B92 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13238                                  
 13239                                  		; MSDOS 3.3
 13240 00002B94 BA[1444]                		mov	dx,SRCBUF
 13241 00002B97 8916[8843]              		mov	[STRING_PTR_1],dx
 13242 00002B9B BA[8D36]                		mov	dx,STRINGBUF1PTR
 13243 00002B9E E8B308                  		call	STD_PRINTF
 13244 00002BA1 BA[5837]                		mov	dx,FNOTFOUNDPTR
 13245 00002BA4 E9A904                  		jmp	COPYERR
 13246                                  
 13247                                  		; MSDOS 6.0
 13248                                  	;	Set up error message.
 13249                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13250                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13251                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13252                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13253                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13254                                  		;
 13255                                  		;jmp	CopErr			; print msg and clean up
 13256                                  
 13257                                  ; ---------------------------------------------------------------------------
 13258                                  
 13259                                  SOURCEPROC:
 13260                                  
 13261                                  	;*	Preparatory processing for each source file.
 13262                                  	;	Called at FrstSrc for first source file.
 13263                                  
 13264 00002BA7 E85803                  		call	SOURCE_SET		; set source variables & ascii/binary
 13265 00002BAA 803E[C641]00            		cmp	byte [CONCAT],0
 13266 00002BAF 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13267                                  
 13268                                  ; ---------------------------------------------------------------------------
 13269                                  
 13270                                  FRSTSRC:
 13271 00002BB1 31C0                    		xor	ax,ax
 13272 00002BB3 A2[D041]                		mov	[CFLAG],al		; 'destination not created'
 13273 00002BB6 A3[D441]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13274 00002BB9 A2[D141]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13275                                  
 13276                                  LEAVECFLAG:
 13277 00002BBC 8936[C544]              		mov	[SRCPT],si		; save cmd-line ptr
 13278 00002BC0 BF[9340]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13279                                  						;   current dir
 13280 00002BC3 BD[0F44]                		mov	bp,SRCVARS		; BP = base of source variables
 13281 00002BC6 E8CE05                  		call	BUILDPATH		; cd to source dir, figure
 13282                                  						;   out stuff about source
 13283 00002BC9 8B36[1144]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13284 00002BCD C3                      		retn
 13285                                  
 13286                                  ; ---------------------------------------------------------------------------
 13287                                  
 13288                                  NEXTSRC:
 13289                                  
 13290                                  	;*	Next source. Come here after handling each pathname.
 13291                                  	;	We're done unless there are additional source pathnames
 13292                                  	;	to be appended.
 13293                                  	;
 13294                                  	;	Note that all files matching an ambiguous pathname
 13295                                  	;	are processed before coming here.
 13296                                  
 13297 00002BCE 803E[CF44]00            		cmp	byte [PLUS],0
 13298                                  		;jne	short MORECP		; copying "+" sources - keep going
 13299                                  		; 01/03/2023
 13300 00002BD3 74A4                    		je	short ENDCOPY
 13301                                  ;ENDCOPYJ2:
 13302                                  		;jmp	short ENDCOPY
 13303                                  MORECP:
 13304 00002BD5 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13305 00002BD7 8B36[C544]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13306                                  		;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13307                                  		; 01/03/2023
 13308 00002BDB B32B                    		mov	bl,plus_chr ; mov bl,'+'
 13309                                  SCANSRC:
 13310 00002BDD BF[6E44]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13311 00002BE0 E8BC06                  		call	CPARSE			; parse first source name
 13312                                  		;jb	short ENDCOPYJ2		; CR found - we're done
 13313                                  		; 01/03/2023
 13314 00002BE3 7294                    		jb	short ENDCOPY
 13315                                  
 13316 00002BE5 F6C780                  		test	bh,80h
 13317                                  		;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13318                                  		; 01/03/2023
 13319 00002BE8 748F                    		jz	short ENDCOPY
 13320                                  
 13321 00002BEA F6C701                  		test	bh,1
 13322 00002BED 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13323                                  
 13324                                  	;	ScanBuf contains the next source pathname.
 13325                                  
 13326 00002BEF E8B5FF                  		call	SOURCEPROC		; prepare this source
 13327 00002BF2 803E[0643]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13328 00002BF7 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13329 00002BF9 C606[0743]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13330 00002BFE EB8D                    		jmp	short SRCNONEXIST	; we know we won't find it
 13331                                  NOSTAMP:
 13332 00002C00 C606[0743]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13333                                  
 13334                                  ; ---------------------------------------------------------------------------
 13335                                  
 13336                                  FIRSTENT:
 13337                                  
 13338                                  ;M047
 13339                                  ; The only case we need to worry about is when the source is wildcarded and
 13340                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13341                                  ;concatenation. We check for this case.
 13342                                  ;
 13343                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13344                                  ;right place to do this check.
 13345                                  
 13346                                  	;	This is where we enter the loop with the first source.
 13347                                  
 13348 00002C05 BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13349 00002C08 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13350 00002C0B CD21                    		int	21h		; DOS -	PARSE FILENAME
 13351                                  					; DS:SI	-> string to parse
 13352                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13353                                  					; AL = bit mask	to control parsing
 13354 00002C0D 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13355 00002C10 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13356 00002C12 A1[1444]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13357 00002C15 80FC3A                  		cmp	ah,':'
 13358 00002C18 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13359 00002C1A B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13360                                  DRVSPEC1:
 13361 00002C1C 0C20                    		or	al,20h			; AL = lowercase drive letter
 13362 00002C1E 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13363                                  		;mov	[5Ch],al
 13364 00002C20 A25C00                  		mov	[FCB],al		; put drive id in FCB
 13365                                  
 13366                                  	;	FCB contains drive and filename to search.
 13367                                  		
 13368 00002C23 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13369 00002C25 E80301                  		call	SEARCH
 13370                                  SRCHDONE:
 13371 00002C28 9C                      		pushf				; save flags from Search
 13372 00002C29 E841EC                  		call	RESTUDIR1		; restore users current directory
 13373 00002C2C 9D                      		popf				; restore flags from search
 13374 00002C2D 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13375 00002C2F E95BFF                  		jmp	SRCNONEXIST		; didn't find the source
 13376                                  
 13377                                  NEXTAMBIG0:
 13378 00002C32 30C0                    		xor	al,al
 13379 00002C34 8606[D641]              		xchg	al,[FRSTSRCH]
 13380 00002C38 08C0                    		or	al,al
 13381 00002C3A 740B                    		jz	short NEXTAMBIG
 13382                                  SETNMEL:
 13383 00002C3C B90C00                  		mov	cx,12
 13384 00002C3F BF[F042]                		mov	di,SDIRBUF
 13385 00002C42 BE[AA42]                		mov	si,DIRBUF
 13386 00002C45 F3A4                    		rep movsb			; save very first source name
 13387                                  NEXTAMBIG:
 13388 00002C47 30C0                    		xor	al,al
 13389 00002C49 A2[C944]                		mov	[NOWRITE],al		; turn off nowrite
 13390 00002C4C 8B3E[1144]              		mov	di,[SRCTAIL]
 13391 00002C50 BE[AB42]                		mov	si,DIRBUF+1
 13392 00002C53 E821ED                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13393                                  MELDO:
 13394 00002C56 803E[C641]00            		cmp	byte [CONCAT],0
 13395 00002C5B 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13396 00002C5D F606[1344]02            		test	byte [SRCINFO],2	; wildcard - show name
 13397 00002C62 7410                    		jz	short DOREAD
 13398                                  SHOWCPNAM:
 13399 00002C64 BA[1444]                		mov	dx,SRCBUF
 13400 00002C67 8916[8E43]              		mov	[STRING_PTR_2],dx
 13401 00002C6B BA[9F36]                		mov	dx,STRINGBUF2PTR
 13402 00002C6E E8E307                  		call	STD_PRINTF
 13403 00002C71 E8D7EC                  		call	CRLF2
 13404                                  DOREAD:
 13405 00002C74 E8C500                  		call	DOCOPY
 13406 00002C77 803E[C641]00            		cmp	byte [CONCAT],0
 13407 00002C7C 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13408                                  
 13409 00002C7E E89B01                  		call	CLOSEDEST		; close current destination
 13410 00002C81 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13411                                  
 13412 00002C83 C606[D041]00            		mov	byte [CFLAG],0		; 'destination not created'
 13413                                  NODCLOSE:
 13414 00002C88 803E[C641]00            		cmp	byte [CONCAT],0		
 13415 00002C8D 740A                    		jz	short NOFLUSH
 13416                                  
 13417                                  ;	Concatenating - flush output between source files so LostErr
 13418                                  ;	stuff works correctly.
 13419                                  
 13420                                  		;invoke	FlshFil  ; MSDOS 6.0
 13421                                  
 13422 00002C8F E8A602                  		call	FLUSHFIL ; MSDOS 3.3
 13423 00002C92 F606[0C44]FF            		test	byte [MELCOPY],0FFh
 13424                                  		;jz	short NOFLUSH
 13425                                  		;jmp	short DOMELCOPY
 13426                                  		; 01/03/2023
 13427 00002C97 750C                    		jnz	short DOMELCOPY
 13428                                  NOFLUSH:
 13429 00002C99 E88300                  		call	SEARCHNEXT		; try next match
 13430 00002C9C 755D                    		jnz	short NEXTSRCJ		; not found - finished with 
 13431                                  						;   this source spec
 13432 00002C9E C606[D141]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13433                                  
 13434 00002CA3 EBA2                    		jmp	short NEXTAMBIG		; do next ambig match
 13435                                  DOMELCOPY:
 13436 00002CA5 803E[0C44]FF            		cmp	byte [MELCOPY],0FFh
 13437 00002CAA 740D                    		je	short CONTMEL
 13438 00002CAC 8B36[C544]              		mov	si,[SRCPT]
 13439 00002CB0 8936[0D44]              		mov	[MELSTART],si
 13440 00002CB4 C606[0C44]FF            		mov	byte [MELCOPY],0FFh
 13441                                  CONTMEL:
 13442 00002CB9 31ED                    		xor	bp,bp
 13443 00002CBB 8B36[C544]              		mov	si,[SRCPT]
 13444                                  		;mov	bl,[PLUS_CHR]
 13445                                  		; 01/03/2023
 13446 00002CBF B32B                    		mov	bl,plus_chr ; mov bl,'+'
 13447                                  SCANSRC2:
 13448 00002CC1 BF[6E44]                		mov	di,SCANBUF
 13449 00002CC4 E8D805                  		call	CPARSE
 13450 00002CC7 F6C780                  		test	bh,80h
 13451 00002CCA 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13452 00002CCC F6C701                  		test	bh,1
 13453 00002CCF 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13454 00002CD1 E8D3FE                  		call	SOURCEPROC
 13455 00002CD4 E896EB                  		call	RESTUDIR1
 13456 00002CD7 BF[2B42]                		mov	di,DESTFCB2
 13457 00002CDA B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13458 00002CDD CD21                    		int	21h		; DOS -	PARSE FILENAME
 13459                                  					; DS:SI	-> string to parse
 13460                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13461                                  					; AL = bit mask	to control parsing
 13462 00002CDF BB[F142]                		mov	bx,SDIRBUF+1
 13463 00002CE2 BE[2C42]                		mov	si,DESTFCB2+1
 13464 00002CE5 8B3E[1144]              		mov	di,[SRCTAIL]
 13465                                  
 13466 00002CE9 E87B04                  		call	BUILDNAME
 13467                                  
 13468 00002CEC 803E[C641]00            		cmp	byte [CONCAT],0
 13469 00002CF1 7405                    		je	short MELDOJ		; not concatenating - continue
 13470                                  
 13471                                  	;	Yes, turn off nowrite because this part of the code 
 13472                                  	;	is only reached after the first file has been dealt with.
 13473                                  
 13474 00002CF3 C606[C944]00            		mov	byte [NOWRITE],0
 13475                                  MELDOJ:
 13476 00002CF8 E95BFF                  		jmp	MELDO
 13477                                  
 13478                                  NEXTSRCJ:
 13479 00002CFB E9D0FE                  		jmp	NEXTSRC
 13480                                  
 13481                                  NEXTMEL:
 13482 00002CFE E81B01                  		call	CLOSEDEST
 13483 00002D01 31C0                    		xor	ax,ax
 13484 00002D03 A2[D041]                		mov	[CFLAG],al
 13485 00002D06 A3[D441]                		mov	[NXTADD],ax
 13486 00002D09 A2[D141]                		mov	[SPECDRV],al
 13487 00002D0C 8B36[0D44]              		mov	si,[MELSTART]
 13488 00002D10 8936[C544]              		mov	[SRCPT],si
 13489 00002D14 E80800                  		call	SEARCHNEXT
 13490 00002D17 7403                    		jz	short SETNMELJ
 13491 00002D19 E960FE                  		jmp	ENDCOPY2
 13492                                  
 13493                                  SETNMELJ:
 13494 00002D1C E91DFF                  		jmp	SETNMEL
 13495                                  
 13496                                  ; ---------------------------------------------------------------------------
 13497                                  
 13498                                  SEARCHNEXT:
 13499 00002D1F B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13500 00002D21 F606[1344]02            		test	byte [SRCINFO],2
 13501 00002D26 7503                    		jnz	short SEARCH		; do search-next if ambig
 13502 00002D28 08E4                    		or	ah,ah			; reset zero flag
 13503 00002D2A C3                      		retn
 13504                                  
 13505                                  ; ---------------------------------------------------------------------------
 13506                                  
 13507                                  SEARCH:
 13508 00002D2B 50                      		push	ax
 13509 00002D2C B41A                    		mov	ah,SET_DMA ; 1Ah
 13510 00002D2E BA[AA42]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13511 00002D31 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13512                                  				; DS:DX	-> disk	transfer buffer
 13513 00002D33 58                      		pop	ax		; restore search first/next command
 13514 00002D34 BA5C00                  		mov	dx,FCB ; 5Ch
 13515 00002D37 CD21                    		int	21h		; Do the search
 13516 00002D39 08C0                    		or	al,al
 13517 00002D3B C3                      		retn
 13518                                  
 13519                                  ; ---------------------------------------------------------------------------
 13520                                  
 13521                                  DOCOPY:
 13522 00002D3C BE[1444]                		mov	si,SRCBUF	; do name translate of source
 13523 00002D3F BF[DF3E]                		mov	di,SRCXNAME	; save for name comparison
 13524 00002D42 B460                    		mov	ah,XNAMETRANS ; 60h
 13525 00002D44 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13526                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13527                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13528 00002D46 C606[C441]00            		mov	byte [RDEOF],0	; no EOF yet
 13529                                  
 13530                                  		; MSDOS 6.0
 13531                                  		;mov	ax,EXTOPEN shl 8	; open the file
 13532                                  ;M046
 13533                                  ; For reads, the sharing mode should be deny none so that any process can
 13534                                  ;open this file again in any other sharing mode. This is mainly to allow
 13535                                  ;multiple command.com's to access the same file without getting sharing
 13536                                  ;violations
 13537                                  ;
 13538                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE
 13539                                  						; open mode for COPY ;M046
 13540                                  		;xor	cx,cx			; no special files
 13541                                  		;mov	dx,READ_OPEN_FLAG	; set up open flags
 13542                                  		;int	21h
 13543                                  		;
 13544                                  		;jnc	OpenOk
 13545                                  
 13546                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 13547                                  	;	They asked for it...
 13548                                  
 13549                                  		;jmp	short Error_On_Source 	;AC022; clean up and exit
 13550                                  
 13551                                  		; MSDOS 3.3
 13552 00002D4B BA[1444]                		mov	dx,SRCBUF
 13553 00002D4E B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13554 00002D51 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13555                                  					; DS:DX	-> ASCIZ filename
 13556                                  					; AL = access mode
 13557                                  					; 0 - read
 13558 00002D53 7311                    		jnc	short OPENOK
 13559 00002D55 E837F1                  		call	GET_EXT_ERR_NUMBER
 13560 00002D58 9C                      		pushf
 13561 00002D59 83F841                  		cmp	ax,65
 13562 00002D5C 7506                    		jnz	short DOCOPY_ERR
 13563 00002D5E BA[7D37]                		mov	dx,ACCDENPTR
 13564 00002D61 E8F006                  		call	STD_PRINTF
 13565                                  DOCOPY_ERR:
 13566 00002D64 9D                      		popf
 13567 00002D65 C3                      		retn
 13568                                  
 13569                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13570                                  OPENOK:
 13571 00002D66 89C3                    		mov	bx,ax
 13572 00002D68 891E[6B44]              		mov	[SRCHAND],bx		; save handle
 13573 00002D6C B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13574 00002D6F CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13575                                  					; BX = file handle
 13576                                  
 13577                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13578                                  
 13579 00002D71 8916[D144]              		mov	[CPDATE],dx		; save date
 13580 00002D75 890E[D344]              		mov	[CPTIME],cx		; save time
 13581                                  
 13582                                  		; MSDOS 6.0
 13583                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13584                                  
 13585                                  ;Error_On_Source:				;AN022; we have a BAD error
 13586                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13587                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13588                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13589                                  		;invoke	Std_EprintF		;AN022; print it
 13590                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13591                                  		;je	No_Close_Src		;AN022; no - don't close
 13592                                  		;call	CloseSrc		;AN022; clean up
 13593                                  ;No_Close_Src:					;AN022;
 13594                                  		;cmp	CFlag,0			;AN022; was destination created?
 13595                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13596                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13597                                  ;EndCopyJ3:					;AN022;
 13598                                  		;jmp	EndCopy2		;AN022;
 13599                                  ;No_Copy_Xa:
 13600                                  		;mov	bx,SrcHand		;AN022; get handle back
 13601                                  
 13602                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13603 00002D79 B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13604 00002D7C CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13605                                  					; BX = file or device handle
 13606 00002D7E 80E280                  		and	dl,devid_ISDEV ; 80h
 13607 00002D81 8816[6D44]              		mov	[SRCISDEV],dl		; set source info
 13608 00002D85 740D                    		jz	short COPYLP		; source not a device
 13609 00002D87 803E[CA44]00            		cmp	byte [BINARY],0
 13610 00002D8C 7406                    		je	short COPYLP		; ascii device ok
 13611 00002D8E BA[5B3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13612 00002D91 E9BC02                  		jmp	COPYERR
 13613                                  
 13614                                  COPYLP:
 13615 00002D94 8B1E[6B44]              		mov	bx,[SRCHAND]
 13616 00002D98 8B0E[D241]              		mov	cx,[BYTCNT]
 13617 00002D9C 8B16[D441]              		mov	dx,[NXTADD]
 13618 00002DA0 29D1                    		sub	cx,dx			; compute available space
 13619 00002DA2 750E                    		jnz	short GOTROOM
 13620                                  		;invoke	FlshFil   ; MSDOS 6.0
 13621 00002DA4 E89101                  		call	FLUSHFIL  ; MSDOS 3.3
 13622 00002DA7 803E[CD44]00            		cmp	byte [TERMREAD],0
 13623 00002DAC 7565                    		jne	short CLOSESRC		; give up
 13624 00002DAE 8B0E[D241]              		mov	cx,[BYTCNT]
 13625                                  GOTROOM:
 13626 00002DB2 1E                      		push	ds
 13627 00002DB3 8E1E[B341]              		mov	ds,[TPA]
 13628 00002DB7 B43F                    		mov	ah,READ ; 3Fh
 13629 00002DB9 CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13630                                  					; BX = file handle,CX = number	of bytes to read
 13631                                  					; DS:DX	-> buffer
 13632 00002DBB 1F                      		pop	ds
 13633 00002DBC 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13634                                  		;jc	Error_On_Source ; MSDOS 6.0
 13635 00002DBE 89C1                    		mov	cx,ax			; get count
 13636 00002DC0 E351                    		jcxz	CLOSESRC		; no more to read
 13637 00002DC2 803E[6D44]00            		cmp	byte [SRCISDEV],0
 13638 00002DC7 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13639 00002DC9 803E[CE44]00            		cmp	byte [ASCII],0
 13640 00002DCE 741B                    		je	short BINREAD
 13641                                  NOTESTA:
 13642 00002DD0 89CA                    		mov	dx,cx
 13643 00002DD2 8B3E[D441]              		mov	di,[NXTADD]
 13644 00002DD6 B01A                    		mov	al,1Ah
 13645 00002DD8 06                      		push	es
 13646 00002DD9 8E06[B341]              		mov	es,[TPA]		; scan for EOF
 13647 00002DDD F2AE                    		repne scasb
 13648 00002DDF 07                      		pop	es
 13649 00002DE0 7505                    		jnz	short USEALL
 13650 00002DE2 FE06[C441]              		inc	byte [RDEOF]
 13651 00002DE6 41                      		inc	cx
 13652                                  USEALL:
 13653 00002DE7 29CA                    		sub	dx,cx
 13654 00002DE9 89D1                    		mov	cx,dx
 13655                                  BINREAD:
 13656 00002DEB 030E[D441]              		add	cx,[NXTADD]
 13657 00002DEF 890E[D441]              		mov	[NXTADD],cx
 13658 00002DF3 3B0E[D241]              		cmp	cx,[BYTCNT]		; is buffer full?
 13659 00002DF7 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13660                                  		;invoke	FlshFil
 13661 00002DF9 E83C01                  		call	FLUSHFIL
 13662 00002DFC 803E[CD44]00            		cmp	byte [TERMREAD],0
 13663 00002E01 7510                    		jne	short CLOSESRC		; give up
 13664 00002E03 EB8F                    		jmp	short COPYLP
 13665                                  TESTDEV:
 13666 00002E05 803E[6D44]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13667 00002E0A 7407                    		je	short CLOSESRC
 13668 00002E0C 803E[C441]00            		cmp	byte [RDEOF],0
 13669 00002E11 7481                    		je	short COPYLP		; on device, go till ^Z
 13670                                  CLOSESRC:
 13671 00002E13 8B1E[6B44]              		mov	bx,[SRCHAND]
 13672 00002E17 B43E                    		mov	ah,CLOSE ; 3Eh
 13673 00002E19 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13674                                  					; BX = file handle
 13675                                  CLOSESRCDEST_RETN:
 13676 00002E1B C3                      		retn
 13677                                  
 13678                                  ; ---------------------------------------------------------------------------
 13679                                  
 13680                                  CLOSEDEST:
 13681                                  
 13682                                  	;	We are called to close the destination.
 13683                                  	;	We need to note whether or not there is any internal data left
 13684                                  	;	to be flushed out.
 13685                                  
 13686 00002E1C 803E[D141]00            		cmp	byte [DESTCLOSED],0
 13687 00002E21 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13688 00002E23 A0[CC41]                		mov	al,[DESTSWITCH]
 13689 00002E26 E86602                  		call	SETASC			; check for b or a switch
 13690 00002E29 7434                    		jz	short BINCLOS		;   on destination
 13691 00002E2B 8B1E[D441]              		mov	bx,[NXTADD]
 13692                                  ;
 13693                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13694                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13695                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13696                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13697                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13698                                  ;performance overhead on single ASCII file copies which now always involve
 13699                                  ;2 writes instead of 1 before. Is this really that important?
 13700                                  ;
 13701                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13702                                  ;M048;	jne	PutZ
 13703                                  
 13704                                  		; MSDOS 3.3
 13705 00002E2F 3B1E[D241]              		cmp	bx,[BYTCNT]	; is memory full?
 13706 00002E33 7509                    		jne	short PUTZ
 13707                                  
 13708 00002E35 E8F300                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13709 00002E38 7402                    		jz	short NOCONC
 13710                                  CONCHNG:
 13711 00002E3A F9                      		stc
 13712 00002E3B C3                      		retn
 13713                                  
 13714                                  NOCONC:	
 13715 00002E3C 31DB                    		xor	bx,bx
 13716                                  PUTZ:
 13717 00002E3E 1E                      		push	ds
 13718 00002E3F 8E1E[B341]              		mov	ds,[TPA]
 13719 00002E43 C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13720 00002E47 1F                      		pop	ds
 13721 00002E48 FF06[D441]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13722 00002E4C C606[C944]00            		mov	byte [NOWRITE],0
 13723 00002E51 A1[CB44]                		mov	ax,[WRITTEN]
 13724 00002E54 0306[D441]              		add	ax,[NXTADD]
 13725 00002E58 7205                    		jc	short BINCLOS	; > 1
 13726 00002E5A 83F801                  		cmp	ax,1
 13727 00002E5D 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13728                                  BINCLOS:
 13729 00002E5F E8C900                  		call	TRYFLUSH
 13730 00002E62 75D6                    		jnz	short CONCHNG
 13731                                  
 13732 00002E64 803E[CB44]00            		cmp	byte [WRITTEN],0
 13733                                  FORGETITJ:
 13734 00002E69 747D                    		jz	short FORGETIT	; never wrote nothing
 13735                                  NO_FORGET:				; wrote something
 13736 00002E6B 8B1E[0844]              		mov	bx,[DESTHAND]
 13737 00002E6F 8B0E[D344]              		mov	cx,[CPTIME]
 13738 00002E73 8B16[D144]              		mov	dx,[CPDATE]
 13739 00002E77 803E[C744]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13740 00002E7C 7431                    		je	short DODCLOSE	; if no, copy date & time
 13741 00002E7E B42C                    		mov	ah,GET_TIME ; 2Ch
 13742 00002E80 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13743                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13744                                  					; DL = hundredths of seconds
 13745 00002E82 D0E1                    		shl	cl,1
 13746 00002E84 D0E1                    		shl	cl,1		; left justify min in cl
 13747 00002E86 D1E1                    		shl	cx,1
 13748 00002E88 D1E1                    		shl	cx,1
 13749 00002E8A D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13750 00002E8C D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13751 00002E8E 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13752 00002E90 51                      		push	cx		; save packed time
 13753 00002E91 B42A                    		mov	ah,GET_DATE ; 2Ah
 13754 00002E93 CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13755                                  					; Return: DL = day,DH = month,	CX = year
 13756                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13757 00002E95 81E9BC07                		sub	cx,1980
 13758 00002E99 86E9                    		xchg	ch,cl
 13759 00002E9B D1E1                    		shl	cx,1		; year to high 7 bits
 13760 00002E9D D0E6                    		shl	dh,1		; month to high 3 bits
 13761 00002E9F D0E6                    		shl	dh,1
 13762 00002EA1 D0E6                    		shl	dh,1
 13763 00002EA3 D0E6                    		shl	dh,1
 13764 00002EA5 D0E6                    		shl	dh,1		; most sig bit of month in carry
 13765 00002EA7 80D500                  		adc	ch,0		; put that bit next to year
 13766 00002EAA 08F2                    		or	dl,dh		; or low three of month into day
 13767 00002EAC 88EE                    		mov	dh,ch		; get year and high bit of month
 13768 00002EAE 59                      		pop	cx
 13769                                  DODCLOSE:
 13770 00002EAF 83FB00                  		cmp	bx,0
 13771 00002EB2 7E2A                    		jle	short CLOSEDONE
 13772 00002EB4 B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13773 00002EB7 CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13774                                  					; BX = file handle,CX = time to be set
 13775                                  					; DX = date to be set
 13776                                  		; MSDOS 6.0
 13777                                  		;jc	Cleanup_Err	;AN022; handle error
 13778                                  
 13779                                  	;	See if the destination has *anything* in it.
 13780                                  	;	If not, just close and delete it.
 13781                                  
 13782 00002EB9 B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13783 00002EBC 31D2                    		xor	dx,dx
 13784 00002EBE 89D1                    		mov	cx,dx
 13785 00002EC0 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13786                                  					; AL = method: offset from end of file
 13787                                  	;	DX:AX is file size
 13788                                  
 13789 00002EC2 09C2                    		or	dx,ax
 13790 00002EC4 9C                      		pushf
 13791 00002EC5 B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13792 00002EC8 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13793                                  					; BX = file or device handle
 13794 00002ECA 52                      		push	dx			; save them away
 13795 00002ECB B43E                    		mov	ah,CLOSE ; 3Eh
 13796 00002ECD CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13797                                  					; BX = file handle
 13798 00002ECF 5A                      		pop	dx
 13799                                  
 13800                                  		; MSDOS 6.0
 13801                                  		;jnc	Close_Cont	;AN022; handle error on close
 13802                                  		;popf			;AN022; get the flags back
 13803                                  ;Cleanup_Err: 				;AN022;
 13804                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13805                                  		;call	DestDelete	;AN022; attempt to delete the target
 13806                                  		;jmp	short FileClosed ;AN022; close the file
 13807                                  ;Close_Cont:				;AN022; no error - co
 13808                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13809 00002ED0 9D                      		popf
 13810 00002ED1 750B                    		jnz	short CLOSEDONE
 13811 00002ED3 F7C28000                		test	dx,80h		; is the destination a device?
 13812 00002ED7 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13813 00002ED9 E81E00                  		call	DESTDELETE
 13814 00002EDC EB04                    		jmp	short FILECLOSED
 13815                                  CLOSEDONE:
 13816 00002EDE FF06[D941]              		inc	word [FILECNT]
 13817                                  FILECLOSED:
 13818 00002EE2 FE06[D141]              		inc	byte [DESTCLOSED]
 13819                                  RET50:
 13820 00002EE6 F8                      		clc
 13821 00002EE7 C3                      		retn
 13822                                  
 13823                                  FORGETIT:
 13824 00002EE8 8B1E[0844]              		mov	bx,[DESTHAND]
 13825 00002EEC E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13826 00002EEF E80800                  		call	DESTDELETE
 13827 00002EF2 C706[D941]0000          		mov	word [FILECNT],0 ; no files transferred
 13828 00002EF8 EBEC                    		jmp	short RET50
 13829                                  
 13830                                  ; ---------------------------------------------------------------------------
 13831                                  
 13832                                  DESTDELETE:
 13833 00002EFA BA[B143]                		mov	dx,DESTBUF
 13834 00002EFD B441                    		mov	ah,UNLINK ; 41h
 13835 00002EFF CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13836                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13837                                  				;		(no wildcards allowed)
 13838 00002F01 C3                      		retn
 13839                                  
 13840                                  ; ---------------------------------------------------------------------------
 13841                                  
 13842                                  SOURCE_SET:
 13843 00002F02 56                      		push	si
 13844 00002F03 A1[D744]                		mov	ax,[STARTEL]
 13845 00002F06 BE[6E44]                		mov	si,SCANBUF	; adjust to copy
 13846 00002F09 29F0                    		sub	ax,si
 13847 00002F0B BF[1444]                		mov	di,SRCBUF
 13848 00002F0E 01F8                    		add	ax,di
 13849 00002F10 A3[1144]                		mov	[SRCTAIL],ax
 13850 00002F13 880E[1044]              		mov	[SRCSIZ],cl	; save its size
 13851 00002F17 41                      		inc	cx		; include the nul
 13852 00002F18 F3A4                    		rep movsb		; save this source
 13853 00002F1A 883E[1344]              		mov	[SRCINFO],bh	; save info about it
 13854 00002F1E 5E                      		pop	si
 13855 00002F1F 89E8                    		mov	ax,bp		; switches so far
 13856 00002F21 E86B01                  		call	SETASC		; set a,b switches accordingly
 13857 00002F24 E860EB                  		call	SWITCH		; get any more switches on this arg
 13858 00002F27 E86501                  		call	SETASC		; set
 13859 00002F2A C3                      		retn
 13860                                  
 13861                                  ; =============== S U B	R O U T	I N E =======================================
 13862                                  
 13863                                  ; MSDOS 6.0
 13864                                  
 13865                                  ;****************************************************************
 13866                                  ;*
 13867                                  ;* ROUTINE:	CleanupErr
 13868                                  ;*
 13869                                  ;* FUNCTION:	Issues extended error message for destination
 13870                                  ;*		if not alreay issued
 13871                                  ;*
 13872                                  ;* INPUT:	return from INT 21
 13873                                  ;*
 13874                                  ;* OUTPUT:	none
 13875                                  ;*
 13876                                  ;****************************************************************
 13877                                  
 13878                                  ;CleanupErr	proc	near		;AN022;
 13879                                  ;
 13880                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13881                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13882                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13883                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13884                                  ;					;AN022; get address of failed string
 13885                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13886                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13887                                  ;
 13888                                  ;CleanupErr_Cont:			;AN022;
 13889                                  ;	ret				;AN022; return to caller
 13890                                  ;
 13891                                  ;CleanupErr	endp			;AN022;
 13892                                  
 13893                                  ;============================================================================
 13894                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13895                                  ;============================================================================
 13896                                  ; 01/10/2018 - Retro DOS v3.0
 13897                                  
 13898                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13899                                  
 13900                                  ; =============== S U B	R O U T	I N E =======================================
 13901                                  
 13902                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13903                                  ;
 13904                                  ;	EXIT	ZR set if concatenate flag unchanged
 13905                                  
 13906                                  TRYFLUSH:
 13907 00002F2B A0[C641]                		mov	al,[CONCAT]
 13908 00002F2E 50                      		push	ax
 13909 00002F2F E80600                  		call	FLUSHFIL
 13910 00002F32 58                      		pop	ax
 13911 00002F33 3A06[C641]              		cmp	al,[CONCAT]
 13912 00002F37 C3                      		retn
 13913                                  
 13914                                  ; =============== S U B	R O U T	I N E =======================================
 13915                                  
 13916                                  FLUSHFIL:
 13917 00002F38 A0[CA44]                		mov	al,[BINARY]
 13918 00002F3B 8A26[CE44]              		mov	ah,[ASCII]
 13919 00002F3F 50                      		push	ax
 13920 00002F40 E80900                  		call	FLSHFIL
 13921 00002F43 58                      		pop	ax
 13922 00002F44 8826[CE44]              		mov	[ASCII],ah
 13923 00002F48 A2[CA44]                		mov	[BINARY],al
 13924 00002F4B C3                      		retn
 13925                                  
 13926                                  ; =============== S U B	R O U T	I N E =======================================
 13927                                  
 13928                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13929                                  ;
 13930                                  ;	Inputs:
 13931                                  ;	  [NXTADD] = No. of bytes to write
 13932                                  ;	  [CFLAG] <> 0 if file has been created
 13933                                  ;	Outputs:
 13934                                  ;	  [NXTADD] = 0
 13935                                  
 13936                                  FLSHFIL:
 13937 00002F4C C606[CD44]00            		mov	byte [TERMREAD],0
 13938 00002F51 803E[D041]00            		cmp	byte [CFLAG],0
 13939 00002F56 7403                    		jz	short NOTEXISTS
 13940 00002F58 E98300                  		jmp	EXISTS
 13941                                  
 13942                                  NOTEXISTS:
 13943 00002F5B E84B01                  		call	BUILDDEST	; find out all about the destination
 13944 00002F5E E82A03                  		call	COMPNAME	; source and dest. the same?
 13945 00002F61 7516                    		jnz	short PROCDEST	; if not, go ahead
 13946 00002F63 803E[6D44]00            		cmp	byte [SRCISDEV],0
 13947 00002F68 750F                    		jnz	short PROCDEST	; same name on device ok
 13948 00002F6A 803E[C641]00            		cmp	byte [CONCAT],0	; concatenation?
 13949 00002F6F BA[F437]                		mov	dx,OVERWRPTR
 13950 00002F72 745E                    		je	short COPERR	; not concatenating - overwrite error
 13951                                  		
 13952                                  ;No_Concat_Err:	; concatenating
 13953 00002F74 C606[C944]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 13954                                  PROCDEST:
 13955                                  		; MSDOS 6.0
 13956                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13957                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 13958                                  ;M046
 13959                                  ; For writes, we want to deny writes by anyone else at the same time that we
 13960                                  ;are writing to it. For instance, on a network, 2 workstations could try
 13961                                  ;writing to the same file. Also, because we opened the source file with
 13962                                  ;DENY NONE, it is fine if the source and destination files are the same as
 13963                                  ;would happen when we append to an existing file.
 13964                                  ;
 13965                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 13966                                  		;xor	cx,cx				; no special files
 13967                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 13968                                  		;
 13969                                  		;cmp	NoWrite,0
 13970                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 13971                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 13972                                  
 13973 00002F79 B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 13974 00002F7C 803E[C944]00            		cmp	byte [NOWRITE],0
 13975 00002F81 7504                    		jne	short DODESTOPEN
 13976 00002F83 B43C                    		mov	ah,CREAT ; 3Ch
 13977 00002F85 31C9                    		xor	cx,cx
 13978                                  DODESTOPEN:
 13979 00002F87 BA[B143]                		mov	dx,DESTBUF
 13980 00002F8A CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 13981                                  				; CX = attributes for file
 13982                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 13983                                  		
 13984                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 13985                                  		;mov	dx,FULDIRPTR
 13986                                  		;call	GET_EXT_ERR_NUMBER
 13987                                  		;jc	short COPERR
 13988                                  
 13989                                  		; 01/10/2018
 13990                                  		;jnc	short DEST_OPEN_OKAY
 13991                                  		
 13992                                  		;mov	dx,FULDIRPTR
 13993                                  		;call	GET_EXT_ERR_NUMBER
 13994                                  		;jmp	short COPERR
 13995                                  
 13996 00002F8C 723E                    		jc	short DEST_OPEN_ERROR
 13997                                  
 13998                                  ;DEST_OPEN_OKAY:
 13999 00002F8E A3[0844]                		mov	[DESTHAND],ax	; save handle
 14000 00002F91 C606[D041]01            		mov	byte [CFLAG],1	; destination now exists
 14001 00002F96 89C3                    		mov	bx,ax
 14002 00002F98 B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 14003 00002F9B CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 14004                                  				   	; BX = file or device handle
 14005                                  
 14006 00002F9D 8816[0A44]              		mov	[DESTISDEV],dl	; set dest info
 14007                                  		;test	dl,80h
 14008 00002FA1 F6C280                  		test	dl,devid_ISDEV
 14009 00002FA4 7438                    		jz	short EXISTS	; Dest not a device
 14010                                  
 14011                                  ;	Destination is device.
 14012                                  
 14013 00002FA6 A0[CC41]                		mov	al,[DESTSWITCH]
 14014                                  		;and	al,0Ch
 14015 00002FA9 240C                    		and	al,SWITCHA+SWITCHB
 14016 00002FAB 7509                    		jnz	short TESTBOTH
 14017 00002FAD A0[CE44]                		mov	al,[ASCII]	; neither set, use current setting
 14018 00002FB0 0A06[CA44]              		or	al,[BINARY]
 14019 00002FB4 741E                    		jz	short EXSETA	; neither set, default to ascii
 14020                                  TESTBOTH:
 14021 00002FB6 7A26                    		jpe	short EXISTS	; both are set, ignore
 14022                                  		;test	al,8
 14023 00002FB8 A808                    		test	al,SWITCHB
 14024 00002FBA 7422                    		jz	short EXISTS
 14025                                  		;mov	ax,(IOCTL shl 8) or 1
 14026 00002FBC B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 14027 00002FBF 30F6                    		xor	dh,dh
 14028                                  		;or	dl,20h
 14029 00002FC1 80CA20                  		or	dl,devid_RAW
 14030 00002FC4 8816[0A44]              		mov	[DESTISDEV],dl
 14031 00002FC8 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 14032                                  				; BX = device handle,DH = 0
 14033                                  				; DL = device information to set (bits 0-7 from	function 0)
 14034 00002FCA EB12                    		jmp	short EXISTS
 14035                                  
 14036                                  		; 01/10/2018 - Retro DOS v3.0 modification
 14037                                  DEST_OPEN_ERROR:
 14038 00002FCC BA[CE37]                		mov	dx,FULDIRPTR
 14039 00002FCF E8BDEE                  		call	GET_EXT_ERR_NUMBER
 14040                                  COPERR:
 14041 00002FD2 EB7C                    		jmp	short COPYERR
 14042                                  
 14043                                  EXSETA:
 14044                                  
 14045                                  ;	What we read in may have been in binary mode, flag zapped write OK
 14046                                  
 14047                                  		;mov	byte [ASCII],4
 14048 00002FD4 C606[CE44]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 14049                                  		;or	byte [INEXACT],4
 14050 00002FD9 800E[C744]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 14051                                  EXISTS:
 14052 00002FDE 803E[C944]00            		cmp	byte [NOWRITE],0
 14053 00002FE3 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 14054 00002FE5 803E[0743]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 14055 00002FEA 741D                    		jz	short NOCHECKING
 14056 00002FEC E89C02                  		call	COMPNAME		; source and dest. the same?
 14057 00002FEF 7518                    		jnz	short NOCHECKING	; if not, go ahead
 14058 00002FF1 803E[6D44]00            		cmp	byte [SRCISDEV],0
 14059 00002FF6 7511                    		jne	short NOCHECKING	; same name on device ok
 14060                                  
 14061                                  ;	At this point we know in append (would have gotten overwrite error
 14062                                  ;	on first destination create otherwise), and user trying to specify
 14063                                  ;	destination which has been scribbled already (if dest had been named
 14064                                  ;	first, NoWrite would be set).
 14065                                  
 14066 00002FF8 BA[2038]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 14067                                  		;invoke	Std_EprintF		;ac022;
 14068 00002FFB E85604                  		call	STD_PRINTF
 14069 00002FFE C706[D441]0000          		mov	word [NXTADD],0		; set return
 14070 00003004 FE06[CD44]              		inc	byte [TERMREAD]		; tell read to give up
 14071                                  RET60:
 14072 00003008 C3                      		retn
 14073                                  
 14074                                  NOCHECKING:
 14075 00003009 8B1E[0844]              		mov	bx,[DESTHAND]		; get handle
 14076 0000300D 31C9                    		xor	cx,cx
 14077 0000300F 870E[D441]              		xchg	cx,[NXTADD]
 14078 00003013 E3F3                    		jcxz	RET60			; if nothing to write, forget it
 14079 00003015 FF06[CB44]              		inc	word [WRITTEN]		; flag that we wrote something
 14080 00003019 803E[C944]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 14081 0000301E 755A                    		jnz	short SEEKEND
 14082 00003020 31D2                    		xor	dx,dx
 14083 00003022 1E                      		push	ds
 14084 00003023 8E1E[B341]              		mov	ds,[TPA]
 14085 00003027 B440                    		mov	ah,WRITE ; 40h
 14086 00003029 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14087                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14088 0000302B 1F                      		pop	ds
 14089 0000302C BA[9937]                		mov	dx,NOSPACEPTR
 14090 0000302F 7222                    		jc	short COPERRP		; failure
 14091 00003031 29C1                    		sub	cx,ax
 14092 00003033 74D3                    		jz	short RET60		; wrote all supposed to
 14093 00003035 F606[0A44]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 14094 0000303A 7414                    		jz	short COPYERR		; is a file, error
 14095 0000303C F606[0A44]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 14096 00003041 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 14097 00003043 803E[C744]00            		cmp	byte [INEXACT],0
 14098 00003048 75BE                    		jnz	short RET60		; inexact so ok
 14099 0000304A 49                      		dec	cx
 14100                                  RETZ60:
 14101 0000304B 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 14102                                  
 14103                                  DEVWRTERR:
 14104 0000304D BA[E93C]                		mov	dx,DEVWMESPTR
 14105                                  
 14106                                  COPYERR:
 14107                                  		;invoke	Std_EPrintF		;AC022;
 14108 00003050 E80104                  		call	STD_PRINTF
 14109                                  COPERRP:
 14110 00003053 FE06[D141]              		inc	byte [DESTCLOSED]
 14111 00003057 803E[D041]00            		cmp	byte [CFLAG],0
 14112 0000305C 7419                    		jz	short ENDCOPYJ		; never actually got it open
 14113 0000305E 8B1E[0844]              		mov	bx,[DESTHAND]
 14114 00003062 83FB00                  		cmp	bx,0
 14115 00003065 7E04                    		jle	short NOCLOSE
 14116                                  
 14117                                  ;	Check to see if we should save part of the destination file.
 14118                                  
 14119                                  		; MSDOS 6.0
 14120                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 14121                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 14122                                  			
 14123                                  		;mov	ax,cx
 14124                                  		;or	ax,dx
 14125                                  		;jz	ceClose			; null file ptr means nothing to save
 14126                                  
 14127                                  ;	Destination was also the first source.  Do the best we can to
 14128                                  ;	restore it.  Truncate it back to the size we took from it (which
 14129                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14130                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14131                                  
 14132                                  		;mov	ax,LSEEK shl 8
 14133                                  		;int	21h
 14134                                  
 14135                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14136                                  		;mov	ah,WRITE
 14137                                  		;int	21h			; truncate file
 14138                                  
 14139                                  		;cmp	OCtrlZ,0
 14140                                  		;je	@f			; no ctrl-z removed from original
 14141                                  		;inc	cx			; CX = # bytes to write = 1
 14142                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14143                                  		;mov	ah,WRITE
 14144                                  		;int	21h			; write ctrl-z
 14145                                  ;@@:
 14146                                  		;mov	ah,CLOSE
 14147                                  		;int	21h			; close it
 14148                                  ;;		;mov	CFlag,0
 14149                                  		;jmp	EndCopy			; and go home
 14150                                  
 14151                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14152                                  CECLOSE:
 14153 00003067 B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14154 00003069 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14155                                  					; BX = file handle
 14156                                  NOCLOSE:
 14157 0000306B BA[B143]                		mov	dx,DESTBUF
 14158 0000306E B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14159 00003070 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14160                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14161 00003072 C606[D041]00            		mov	byte [CFLAG],0
 14162                                  ENDCOPYJ:
 14163 00003077 E9FFFA                  		jmp	ENDCOPY
 14164                                  
 14165                                  SEEKEND:
 14166 0000307A 31D2                    		xor	dx,dx
 14167 0000307C 87D1                    		xchg	dx,cx
 14168                                  		;mov	ax,(LSEEK shl 8) or 1
 14169 0000307E B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14170 00003081 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14171                                  					; AL = method: offset from present location
 14172 00003083 803E[C441]00            		cmp	byte [RDEOF],0
 14173 00003088 74C1                    		jz	short RETZ60
 14174                                  
 14175                                  ;	^Z has been read - we must set the file size to the current
 14176                                  ;	file pointer location
 14177                                  
 14178 0000308A B440                    		mov	ah,WRITE ; 40h
 14179 0000308C CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14180                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14181                                  
 14182                                  		; MSDOS 6.0
 14183                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14184                                  
 14185                                  ;	Make note that ^Z was removed, in case the
 14186                                  ;	copy should fail and we need to restore the file.
 14187                                  
 14188                                  		;mov	OCtrlZ,1Ah
 14189                                  
 14190 0000308E C3                      		retn
 14191                                  
 14192                                  ;============================================================================
 14193                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14194                                  ;============================================================================
 14195                                  ; 01/10/2018 - Retro DOS v3.0
 14196                                  
 14197                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14198                                  
 14199                                  ; =============== S U B	R O U T	I N E =======================================
 14200                                  
 14201                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14202                                  ;
 14203                                  ;	Given switch vector in AX,
 14204                                  ;	  Set Ascii flag if /a is set
 14205                                  ;	  Clear Ascii flag if /b is set
 14206                                  ;	  Binary set if /b specified
 14207                                  ;	  Leave Ascii unchanged if neither or both are set
 14208                                  ; 	Also sets Inexact if Ascii is ever set. 
 14209                                  ;	AL = Ascii on exit, flags set
 14210                                  
 14211                                  SETASC:
 14212 0000308F 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14213 00003091 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14214 00003093 50                      		push	ax
 14215 00003094 2408                    		and	al,SWITCHB  ; 8
 14216 00003096 A2[CA44]                		mov	[BINARY],al
 14217 00003099 58                      		pop	ax
 14218 0000309A 2404                    		and	al,4
 14219 0000309C A2[CE44]                		mov	[ASCII],al
 14220 0000309F 0806[C744]              		or	[INEXACT],al
 14221                                  LOADSW:
 14222 000030A3 A0[CE44]                		mov	al,[ASCII]
 14223 000030A6 08C0                    		or	al,al
 14224 000030A8 C3                      		retn
 14225                                  
 14226                                  ; =============== S U B	R O U T	I N E =======================================
 14227                                  
 14228                                  BUILDDEST:
 14229 000030A9 803E[AC43]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14230 000030AE 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14231 000030B0 BF[9340]                		mov	di,USERDIR1
 14232 000030B3 BD[AC43]                		mov	bp,DESTVARS
 14233 000030B6 E8DE00                  		call	BUILDPATH
 14234 000030B9 E8B1E7                  		call	RESTUDIR1
 14235                                  
 14236                                  ;	We now know all about the destination
 14237                                  
 14238                                  KNOWABOUTDEST:
 14239 000030BC 30C0                    		xor	al,al
 14240 000030BE 8606[0B44]              		xchg	al,[FIRSTDEST]
 14241 000030C2 08C0                    		or	al,al
 14242 000030C4 7503                    		jnz	short FIRSTDST
 14243 000030C6 E98A00                  		jmp	NOFIRSTDEST
 14244                                  FIRSTDST:
 14245                                  
 14246                                  ;	Create an fcb of the original dest.
 14247                                  
 14248 000030C9 8B36[AE43]              		mov	si,[DESTTAIL]
 14249 000030CD BF[6742]                		mov	di,DESTFCB
 14250 000030D0 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14251 000030D3 CD21                    		int	21h		; DOS -	PARSE FILENAME
 14252                                  					; DS:SI	-> string to parse
 14253                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14254                                  					; AL = bit mask	to control parsing
 14255 000030D5 803C00                  		cmp	byte [si],0
 14256 000030D8 7404                    		jz	short GOODPARSE
 14257 000030DA C645017C                		mov	byte [di+1],'|'
 14258                                  		; MSDOS 6.0
 14259                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14260                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14261                                  		;jmp	CopErr				;AN052;
 14262                                  GOODPARSE:
 14263 000030DE A1[B143]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14264 000030E1 80FC3A                  		cmp	ah,':'
 14265 000030E4 7402                    		jz	short DRVSPEC4
 14266 000030E6 B040                    		mov	al,'@'
 14267                                  DRVSPEC4:
 14268                                  
 14269                                  ;	AX = "d:" for following FCB drive computation
 14270                                  
 14271 000030E8 8A0E[CE44]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14272 000030EC 0C20                    		or	al,20h
 14273 000030EE 2C60                    		sub	al,60h
 14274 000030F0 A2[6742]                		mov	[DESTFCB],al		; store drive # in FCB
 14275                                  
 14276                                  ;*	Figure out what copy mode we're in.
 14277                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14278                                  ;	+n stands for additional sources delimited by +'s.
 14279                                  ;
 14280                                  ;	copy a b	not concatenating
 14281                                  ;	copy a *	not concatenating
 14282                                  ;	copy * a	concatenating
 14283                                  ;	copy * *	not concatenating
 14284                                  ;	copy a+n b	concatenating
 14285                                  ;	copy *+n a	concatenating
 14286                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14287                                  
 14288                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14289                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14290                                  
 14291 000030F3 A0[B043]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14292 000030F6 8A26[1344]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14293 000030FA 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14294 000030FD 08C0                    		or	al,al
 14295 000030FF 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14296                                  
 14297                                  ;	Destination is wildcarded.
 14298                                  	
 14299 00003101 38E0                    		cmp	al,ah
 14300 00003103 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14301                                  
 14302                                  ;	Source and destination are both wildcarded.
 14303                                  
 14304 00003105 803E[CF44]00            		cmp	byte [PLUS],0
 14305 0000310A 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14306                                  
 14307                                  ;	Source and destination are wildcarded, and source includes +'s.
 14308                                  ;	It's Mel Hallorman copy time.
 14309                                  
 14310 0000310C FE06[0C44]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14311 00003110 30C0                    		xor	al,al
 14312 00003112 EB06                    		jmp	short SETCONC
 14313                                  
 14314                                  NOTMELCOPY:
 14315 00003114 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14316 00003116 20E0                    		and	al,ah
 14317 00003118 D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14318                                  				;   (implies concatenation)
 14319                                  SETCONC:
 14320 0000311A 0A06[CF44]              		or	al,[PLUS]	; "+" always infers concatenation
 14321                                  
 14322                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14323                                  
 14324 0000311E A2[C641]                		mov	[CONCAT],al
 14325 00003121 D0E0                    		shl	al,1
 14326 00003123 D0E0                    		shl	al,1
 14327 00003125 A2[C744]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14328 00003128 803E[CA44]00            		cmp	byte [BINARY],0
 14329 0000312D 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14330                                  
 14331 0000312F A2[CE44]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14332 00003132 08C9                    		or	cl,cl
 14333 00003134 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14334 00003136 08C0                    		or	al,al
 14335 00003138 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14336                                  
 14337                                  ;	At this point there may already be binary read data in the read
 14338                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14339                                  ;	amount of data in the buffer correctly.
 14340                                  
 14341 0000313A 8B0E[D441]              		mov	cx,[NXTADD]
 14342 0000313E E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14343 00003140 B01A                    		mov	al,1Ah
 14344 00003142 06                      		push	es
 14345 00003143 31FF                    		xor	di,di
 14346 00003145 8E06[B341]              		mov	es,[TPA]
 14347 00003149 F2AE                    		repne scasb		; scan for EOF
 14348 0000314B 07                      		pop	es
 14349 0000314C 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14350 0000314E 4F                      		dec	di		; point at ^z
 14351 0000314F 893E[D441]              		mov	[NXTADD],di	; new buffer length
 14352                                  
 14353                                  NOFIRSTDEST:
 14354 00003153 BB[AB42]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14355 00003156 803E[C641]00            		cmp	byte [CONCAT],0
 14356 0000315B 7403                    		jz	short GOTCHRSRC	; Not a concat
 14357 0000315D BB[F142]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14358                                  GOTCHRSRC:
 14359 00003160 BE[6842]                		mov	si,DESTFCB+1	; Original dest name
 14360 00003163 8B3E[AE43]              		mov	di,[DESTTAIL]	; Where to put result
 14361                                  
 14362                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14363                                  
 14364                                  BUILDNAME:
 14365 00003167 B90800                  		mov	cx,8
 14366                                  BUILDMAIN:
 14367 0000316A AC                      		lodsb
 14368 0000316B 3C3F                    		cmp	al,'?'
 14369 0000316D 7502                    		jnz	short NOTAMBIG
 14370 0000316F 8A07                    		mov	al,[bx]
 14371                                  NOTAMBIG:
 14372 00003171 3C20                    		cmp	al,' '
 14373 00003173 7401                    		jz	short NOSTORE
 14374 00003175 AA                      		stosb
 14375                                  NOSTORE:
 14376 00003176 43                      		inc	bx
 14377 00003177 E2F1                    		loop	BUILDMAIN
 14378 00003179 B103                    		mov	cl,3
 14379 0000317B B020                    		mov	al,' '
 14380 0000317D 3804                    		cmp	[si],al
 14381 0000317F 7412                    		jz	short ENDDEST	; No extension
 14382                                  		;mov	al,[DOT_CHR]
 14383                                  		; 01/03/2023
 14384 00003181 B02E                    		mov	al,dot_chr ; mov al,'.'
 14385 00003183 AA                      		stosb
 14386                                  BUILDEXT:
 14387 00003184 AC                      		lodsb
 14388 00003185 3C3F                    		cmp	al,'?'
 14389 00003187 7502                    		jnz	short NOTAMBIGE
 14390 00003189 8A07                    		mov	al,[bx]
 14391                                  NOTAMBIGE:
 14392 0000318B 3C20                    		cmp	al,' '
 14393 0000318D 7401                    		jz	short NOSTOREE
 14394 0000318F AA                      		stosb
 14395                                  NOSTOREE:
 14396 00003190 43                      		inc	bx
 14397 00003191 E2F1                    		loop	BUILDEXT
 14398                                  ENDDEST:
 14399 00003193 30C0                    		xor	al,al
 14400 00003195 AA                      		stosb			; NUL terminate
 14401 00003196 C3                      		retn
 14402                                  
 14403                                  ; =============== S U B	R O U T	I N E =======================================
 14404                                  
 14405                                  BUILDPATH:
 14406 00003197 F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14407 0000319B 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14408 0000319D 89EA                    		mov	dx,bp		; Set DX to spec
 14409 0000319F 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14410                                  
 14411                                  		; MSDOS 6.0
 14412                                  		;push	di				;AN000;
 14413                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14414                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14415                                  		;xor	cx,cx				;AN000; no special files
 14416                                  		;mov	si,dx				;AN030; get file name offset
 14417                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14418                                  		;INT	21h
 14419                                  		;pop	di				;AN000;
 14420                                  		;jnc	pure_file			;AN022; is pure file
 14421                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14422                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14423                                  		;jz	notpfile			;AN022;
 14424                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14425                                  		;jz	notpfile			;AN022;
 14426                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14427                                  		;jz	notpfile			;AN022;
 14428                                  		;jmp	extend_setup			;AN022; exit with error
 14429                                  ;pure_file:
 14430                                  		; MSDOS 3.3
 14431 000031A2 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14432 000031A5 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14433                                  					; DS:DX	-> ASCIZ filename
 14434                                  					; AL = access mode
 14435                                  					; 0 - read
 14436 000031A7 7216                    		jc	short NOTPFILE
 14437                                  ;PURE_FILE:
 14438 000031A9 89C3                    		mov	bx,ax
 14439 000031AB B80044                  		mov	ax,IOCTL*256 ; 4400h
 14440 000031AE CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14441                                  					; BX = file or device handle
 14442 000031B0 B43E                    		mov	ah,CLOSE ;3Eh
 14443 000031B2 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14444                                  					; BX = file handle
 14445 000031B4 F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14446 000031B7 7545                    		jnz	short ISADEV
 14447 000031B9 F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14448 000031BD 743F                    		jz	short ISADEV
 14449                                  
 14450                                  NOTPFILE:
 14451 000031BF 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14452                                  		
 14453                                  		;MSDOS 6.0
 14454                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14455                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14456                                  
 14457 000031C2 80FE3A                  		cmp	dh,':'
 14458 000031C5 7402                    		je	short DRVSPEC5
 14459                                  
 14460                                  SET_DRIVE_SPEC:
 14461 000031C7 B240                    		mov	dl,'@'
 14462                                  
 14463                                  DRVSPEC5:
 14464 000031C9 80CA20                  		or	dl,20h
 14465 000031CC 80EA60                  		sub	dl,60h		; A = 1
 14466 000031CF E856E7                  		call	SAVUDIR1
 14467                                  	
 14468                                  		; MSDOS 6.0
 14469                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14470                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14471                                  		;jmp	extend_setup		;AN022; exit with error
 14472                                  
 14473                                  CURDIR_OK:
 14474 000031D2 89EA                    		mov	dx,bp
 14475                                  		;add	dx,5
 14476 000031D4 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14477                                  		;mov	bh,[bp+4]
 14478 000031D7 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14479 000031DA 80E706                  		and	bh,6
 14480 000031DD 80FF06                  		cmp	bh,6			; Ambig and path ?
 14481 000031E0 7517                    		jne	short CHECKAMB		; jmp if no
 14482                                  		;mov	si,[bp+2]
 14483 000031E2 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14484 000031E5 B33A                    		mov	bl,':'
 14485 000031E7 385CFE                  		cmp	[si-2],bl
 14486 000031EA 7506                    		jne	short KNOWNOTSPEC
 14487                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14488                                  		;mov	byte [bp+0],2
 14489 000031EC C6460002                		mov	byte [bp],2
 14490 000031F0 EB05                    		jmp	short DOPCDJ
 14491                                  
 14492                                  KNOWNOTSPEC:
 14493                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14494                                  		;mov	byte [bp+0],1		
 14495 000031F2 C6460001                		mov	byte [bp],1
 14496 000031F6 4E                      		dec	si
 14497                                  DOPCDJ:
 14498 000031F7 EB5E                    		jmp	short DOPCD
 14499                                  
 14500                                  CHECKAMB:
 14501 000031F9 80FF02                  		cmp	bh,2
 14502 000031FC 7505                    		jnz	short CHECKCD
 14503                                  ISSIMPFILE:
 14504                                  ISADEV:
 14505                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14506                                  		;mov	byte [bp+0],0		
 14507 000031FE C6460000                		mov	byte [bp],0
 14508 00003202 C3                      		retn
 14509                                  
 14510                                  CHECKCD:
 14511 00003203 E8C9EC                  		call	SETREST1
 14512 00003206 B43B                    		mov	ah,CHDIR ; 3Bh
 14513 00003208 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14514                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14515 0000320A 7223                    		jb	short NOTPDIR
 14516 0000320C 89D7                    		mov	di,dx
 14517 0000320E 31C0                    		xor	ax,ax
 14518 00003210 89C1                    		mov	cx,ax
 14519 00003212 49                      		dec	cx
 14520 00003213 F2AE                    		repne scasb
 14521                                  DONE:
 14522 00003215 4F                      		dec	di
 14523 00003216 A0[B641]                		mov	al,[DIRCHAR]
 14524                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14525                                  		;mov	byte [bp+0],2
 14526 00003219 C6460002                		mov	byte [bp],2
 14527 0000321D 3A45FF                  		cmp	al,[di-1]
 14528 00003220 7405                    		jz	short GOTSRCSLSH
 14529                                  _STORE_PCHAR:
 14530 00003222 AA                      		stosb
 14531                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14532                                  		;mov	byte [bp+0],1
 14533 00003223 C6460001                		mov	byte [bp],1
 14534                                  GOTSRCSLSH:
 14535                                  		;or	byte [bp+4],6
 14536 00003227 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14537 0000322B E84100                  		call	SETSTARS
 14538                                  NOTPDIR_RETN:
 14539 0000322E C3                      		retn
 14540                                  
 14541                                  NOTPDIR:
 14542                                  		; MSDOS 6.0
 14543                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14544                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14545                                  		;jz	notpdir_try		;AN022;
 14546                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14547                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14548                                  ;notpdir_try:
 14549                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14550                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14551                                  		;mov	byte [bp+0],0
 14552 0000322F C6460000                		mov	byte [bp],0
 14553                                  		;mov	bh,[bp+4]
 14554 00003233 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14555 00003236 F6C704                  		test	bh,4
 14556 00003239 74F3                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14557                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14558                                  		;mov	byte [bp+0],2		
 14559 0000323B C6460002                		mov	byte [bp],2
 14560                                  		;mov	si,[bp+2]
 14561 0000323F 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14562 00003242 803C00                  		cmp	byte [si],0
 14563 00003245 7424                    		je	short BADCDERRJ2	; Trailing '/'	
 14564                                  		;;mov	bl,[DOT_CHR]
 14565                                  		; 01/03/2023
 14566                                  		;mov	bl,dot_chr  ; mov bl,'.'
 14567                                  		;cmp	[si],bl
 14568 00003247 803C2E                  		cmp	byte [si],dot_chr ; '.'
 14569 0000324A 741F                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14570                                  		;mov	bl,':'
 14571                                  		;cmp	[si-2],bl
 14572                                  		; 01/03/2023
 14573 0000324C 807CFE3A                		cmp	byte [si-2],':'
 14574 00003250 7405                    		je	short DOPCD		   ; Know d:/file
 14575                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14576                                  		;mov	byte [bp+0],1
 14577 00003252 C6460001                		mov	byte [bp],1
 14578 00003256 4E                      		dec	si			; Point at last '/'
 14579                                  DOPCD:
 14580 00003257 30DB                    		xor	bl,bl
 14581 00003259 861C                    		xchg	bl,[si]			; Stick in a NUL
 14582 0000325B E871EC                  		call	SETREST1
 14583 0000325E 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14584 00003261 7408                    		je	short BADCDERRJ2
 14585 00003263 B43B                    		mov	ah,CHDIR ; 3Bh
 14586 00003265 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14587                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14588 00003267 861C                    		xchg	bl,[si]
 14589 00003269 73C3                    		jnc	short NOTPDIR_RETN
 14590                                  		
 14591                                  		; MSDOS 3.3
 14592                                  BADCDERRJ2:
 14593 0000326B F9                      		stc
 14594 0000326C E95DDF                  		jmp	BADCDERR
 14595                                  
 14596                                  		; MSDOS 6.0
 14597                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14598                                  ;EXTEND_SETUPJ:					;AN022;
 14599                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14600                                  ;BADCDERRJ2:
 14601                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14602                                  
 14603                                  ; =============== S U B	R O U T	I N E =======================================
 14604                                  
 14605                                  SETSTARS:
 14606                                  		;mov	[bp+2],di
 14607 0000326F 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14608                                  		;add	byte [bp+1],12
 14609 00003272 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14610                                  		;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14611                                  		; 01/03/2023
 14612 00003276 B83F2E                  		mov	ax,dot_qmark ; '?.' (mov ax,2E3Fh)
 14613 00003279 B90800                  		mov	cx,8
 14614 0000327C F3AA                    		rep stosb
 14615 0000327E 86C4                    		xchg	al,ah
 14616 00003280 AA                      		stosb
 14617 00003281 86C4                    		xchg	al,ah
 14618 00003283 B103                    		mov	cl,3
 14619 00003285 F3AA                    		rep stosb
 14620 00003287 30C0                    		xor	al,al
 14621 00003289 AA                      		stosb
 14622 0000328A C3                      		retn
 14623                                  
 14624                                  ; =============== S U B	R O U T	I N E =======================================
 14625                                  
 14626                                  COMPNAME:
 14627 0000328B BE[B143]                		mov	si,DESTBUF	; do name translate of target
 14628 0000328E BF[363F]                		mov	di,TRGXNAME	; save for name comparison
 14629 00003291 B460                    		mov	ah,XNAMETRANS ; 60h
 14630 00003293 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14631                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14632                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14633 00003295 BE[DF3E]                		mov	si,SRCXNAME	; get name translate of source
 14634 00003298 BF[363F]                		mov	di,TRGXNAME	; get name translate of target
 14635 0000329B E8FFE6                  		call	STRCOMP
 14636 0000329E C3                      		retn
 14637                                  
 14638                                  ;============================================================================
 14639                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14640                                  ;============================================================================
 14641                                  ; 30/09/2018 - Retro DOS v3.0
 14642                                  
 14643                                  ;-----------------------------------------------------------------------;
 14644                                  ; ENTRY:								;
 14645                                  ;	DS:SI	Points input buffer					;
 14646                                  ;	ES:DI	Points to the token buffer				;
 14647                                  ;	BL	Special delimiter for this call 			;
 14648                                  ;		    Always checked last 				;
 14649                                  ;		    set it to space if there is no special delimiter	;
 14650                                  ; EXIT: 								;
 14651                                  ;	DS:SI	Points to next char in the input buffer 		;
 14652                                  ;	ES:DI	Points to the token buffer				;
 14653                                  ;	[STARTEL] Points to start of last element of path in token	;
 14654                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14655                                  ;	CX	Character count 					;
 14656                                  ;	BH	Condition Code						;
 14657                                  ;			Bit 1H of BH set if switch character		;
 14658                                  ;				Token buffer contains char after	;
 14659                                  ;				switch character			;
 14660                                  ;				BP has switch bits set (ORing only)	;
 14661                                  ;			Bit 2H of BH set if ? or * in token		;
 14662                                  ;				if * found element ? filled		;
 14663                                  ;			Bit 4H of BH set if path sep in token		;
 14664                                  ;			Bit 80H of BH set if the special delimiter	;
 14665                                  ;			   was skipped at the start of this token	;
 14666                                  ;		Token buffer always starts d: for non switch tokens	;
 14667                                  ;	CARRY SET							;
 14668                                  ;	    if CR on input						;
 14669                                  ;		token buffer not altered				;
 14670                                  ;									;
 14671                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14672                                  ; MODIFIES:								;
 14673                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14674                                  ;									;
 14675                                  ;-----------------------------------------------------------------------;
 14676                                  
 14677                                  ; Modifications to cparse: recognition of right and left parentheses
 14678                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14679                                  ;
 14680                                  ; Both modifications were installed in the course of adding a coherent
 14681                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14682                                  ; structure for command-line arguments. This parser relies on cparse to
 14683                                  ; recognize individual tokens.
 14684                                  ;
 14685                                  ; To process for-loops correctly, parentheses must therefore be
 14686                                  ; recognized as tokens. The upper-case conversion code was removed so
 14687                                  ; that commands (such as for and echo) would be able to use the "original"
 14688                                  ; text of the command line.
 14689                                  ;
 14690                                  ; Note also the modification to prevent the automatic conversion of colons
 14691                                  ; into spaces WITHIN THE SOURCE TEXT!
 14692                                  ;
 14693                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14694                                  ; on the command line.
 14695                                  ;
 14696                                  ; Alan L, OS/MSDOS				    14 August 1983
 14697                                  
 14698                                  ; ---------------------------------------------------------------------------
 14699                                  
 14700                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14701                                  
 14702                                  ;FSWITCH	EQU	8000h
 14703                                  ;FBADSWITCH	EQU	4000h
 14704                                  
 14705                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14706                                  
 14707                                  ; =============== S U B	R O U T	I N E =======================================
 14708                                  
 14709                                  CPARSE:
 14710 0000329F 31C0                    		xor	ax,ax
 14711 000032A1 893E[D744]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14712 000032A5 A2[DA44]                		mov	[ELPOS],al		; Start in 8 char prefix
 14713 000032A8 A2[DB44]                		mov	[SOURCE],al		; No skip delimiter yet
 14714 000032AB 88C7                    		mov	bh,al			; Init nothing
 14715 000032AD 9C                      		pushf				; save flags
 14716 000032AE 57                      		push	di			; save the token buffer addrss
 14717 000032AF 31C9                    		xor	cx,cx			; no chars in token buffer
 14718 000032B1 880E[0643]              		mov	[COMMA],cl		; reset comma flag
 14719                                  
 14720                                  MOREDELIM:
 14721 000032B5 AC                      		lodsb
 14722 000032B6 E8A7E6                  		call	DELIM
 14723 000032B9 751D                    		jnz	short SCANCDONE
 14724 000032BB 3C20                    		cmp	al,' '
 14725 000032BD 74F6                    		jz	short MOREDELIM
 14726 000032BF 3C09                    		cmp	al,9
 14727 000032C1 74F2                    		jz	short MOREDELIM
 14728 000032C3 8606[DB44]              		xchg	al,[SOURCE]
 14729 000032C7 08C0                    		or	al,al
 14730 000032C9 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14731 000032CB F6C780                  		test	bh,80h			; has a special char been found?
 14732 000032CE 7405                    		jz	short NO_COMMA		; no - just exit
 14733 000032D0 C606[0643]01            		mov	byte [COMMA],1		; set comma flag
 14734                                  
 14735                                  NO_COMMA:
 14736 000032D5 E91801                  		jmp	X_DONE			; Nul argument
 14737                                  
 14738                                  SCANCDONE:
 14739 000032D8 803E[9643]01            		cmp	byte [CPYFLAG],1
 14740 000032DD 7503                    		jnz	short CPCONT1
 14741 000032DF E81FE5                  		call	UPCONV_MAPCALL
 14742                                  CPCONT1:
 14743 000032E2 38D8                    		cmp	al,bl			; Special delimiter?
 14744 000032E4 7505                    		jnz	short NOSPEC
 14745 000032E6 80CF80                  		or	bh,80h
 14746 000032E9 EBCA                    		jmp	short MOREDELIM
 14747                                  
 14748                                  NOSPEC:
 14749 000032EB 3C0D                    		cmp	al,0Dh			; a CR?
 14750 000032ED 7503                    		jnz	short NCPERROR
 14751 000032EF E9F900                  		jmp	CPERROR
 14752                                  
 14753                                  NCPERROR:
 14754 000032F2 3A06[B541]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14755 000032F6 7503                    		jnz	short NA_SWITCH		; yes, process...
 14756 000032F8 E9F800                  		jmp	A_SWITCH
 14757                                  
 14758                                  NA_SWITCH:
 14759 000032FB B23A                    		mov	dl,':'
 14760 000032FD 3814                    		cmp	[si],dl
 14761 000032FF 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14762 00003301 E83501                  		call	MOVE_CHAR
 14763 00003304 AC                      		lodsb				; Get the ':'
 14764 00003305 E83101                  		call	MOVE_CHAR
 14765 00003308 893E[D744]              		mov	[STARTEL],di
 14766 0000330C C606[D944]00            		mov	byte [ELCNT],0
 14767 00003311 E99A00                  		jmp	ANUM_TEST
 14768                                  
 14769                                  ANUM_CHARD:
 14770 00003314 893E[D744]              		mov	[STARTEL],di
 14771 00003318 C606[D944]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14772 0000331D 803E[9643]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14773 00003322 751D                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14774 00003324 E8C3E6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14775 00003327 7518                    		jnz	short ANUM_CHAR		; no
 14776 00003329 50                      		push	ax
 14777 0000332A A0[C541]                		mov	al,[CURDRV]		; Insert drive spec
 14778                                  		;add	al,[CAPITAL_A]
 14779                                  		; 01/03/2023
 14780 0000332D 0441                    		add	al,capital_A  ; add al,'A'
 14781 0000332F E80701                  		call	MOVE_CHAR
 14782 00003332 B03A                    		mov	al,':'
 14783 00003334 E80201                  		call	MOVE_CHAR
 14784 00003337 58                      		pop	ax
 14785 00003338 893E[D744]              		mov	[STARTEL],di
 14786 0000333C C606[D944]00            		mov	byte [ELCNT],0
 14787                                  
 14788                                  ANUM_CHAR:
 14789                                  		;cmp	al,[DOT_CHR]
 14790                                  		; 01/03/2023
 14791 00003341 3C2E                    		cmp	al,dot_chr  ; cmp al,'.'
 14792 00003343 7509                    		jnz	short TESTQUEST
 14793 00003345 FE06[DA44]              		inc	byte [ELPOS]		; flag in extension
 14794 00003349 C606[D944]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14795                                  TESTQUEST:
 14796 0000334E 3C3F                    		cmp	al,'?'
 14797 00003350 7503                    		jnz	short TESTSPLAT
 14798 00003352 80CF02                  		or	bh,2
 14799                                  TESTSPLAT:
 14800                                  		;cmp	al,[STAR]
 14801                                  		; 01/03/2023
 14802 00003355 3C2A                    		cmp	al,star ; cmp al,'*'
 14803 00003357 752C                    		jnz	short TESTPATH
 14804 00003359 80CF02                  		or	bh,2
 14805 0000335C 803E[E744]00            		cmp	byte [EXPAND_STAR],0
 14806                                  		;jnz	short EXPAND_FILENAME
 14807                                  		;jmp	short TESTPATH
 14808                                  		; 01/03/2023
 14809 00003361 7422                    		jz	short TESTPATH
 14810                                  ;BADPERR2J:
 14811                                  		;jmp	BADPERR2
 14812                                  
 14813                                  		;db	0E9h
 14814                                  		;db	7Eh	
 14815                                  		;db	0
 14816                                  
 14817                                  EXPAND_FILENAME:
 14818 00003363 B407                    		mov	ah,7
 14819 00003365 803E[DA44]00            		cmp	byte [ELPOS],0
 14820 0000336A 7402                    		jz	short GOTELCNT
 14821 0000336C B402                    		mov	ah,2
 14822                                  GOTELCNT:
 14823 0000336E B03F                    		mov	al,'?'
 14824 00003370 2A26[D944]              		sub	ah,[ELCNT]
 14825                                  		;jb	short BADPERR2J
 14826                                  		; 01/03/2023
 14827 00003374 726C                    		jb	short BADPERR2
 14828 00003376 86E1                    		xchg	ah,cl
 14829 00003378 E309                    		jcxz	TESTPATHX
 14830                                  QMOVE:
 14831 0000337A 86E1                    		xchg	ah,cl
 14832 0000337C E8BA00                  		call	MOVE_CHAR
 14833 0000337F 86E1                    		xchg	ah,cl
 14834 00003381 E2F7                    		loop	QMOVE
 14835                                  TESTPATHX:
 14836 00003383 86E1                    		xchg	ah,cl
 14837                                  TESTPATH:
 14838 00003385 E862E6                  		call	PATHCHRCMP
 14839 00003388 7521                    		jnz	short NOTSPECIAL
 14840 0000338A 80CF04                  		or	bh,4
 14841 0000338D 803E[E744]00            		cmp	byte [EXPAND_STAR],0
 14842 00003392 7405                    		jz	short NO_ERR_CHECK
 14843 00003394 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14844 00003397 754F                    		jnz	short BADPERR
 14845                                  NO_ERR_CHECK:
 14846 00003399 893E[D744]              		mov	[STARTEL],di	  ; New element
 14847 0000339D FF06[D744]              		inc	word [STARTEL]	  ; Point to char after /
 14848 000033A1 C606[D944]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14849 000033A6 C606[DA44]00            		mov	byte [ELPOS],0
 14850                                  NOTSPECIAL:
 14851 000033AB E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14852                                  ANUM_TEST:
 14853 000033AE AC                      		lodsb
 14854 000033AF 803E[9643]01            		cmp	byte [CPYFLAG],1
 14855 000033B4 7503                    		jnz	short CPCONT3
 14856 000033B6 E848E4                  		call	UPCONV_MAPCALL
 14857                                  CPCONT3:
 14858 000033B9 E8A4E5                  		call	DELIM
 14859 000033BC 7432                    		jz	short X_DONE
 14860 000033BE 3C0D                    		cmp	al,0Dh
 14861 000033C0 742E                    		jz	short X_DONE
 14862 000033C2 3A06[B541]              		cmp	al,[SWITCHAR]
 14863 000033C6 7428                    		jz	short X_DONE
 14864 000033C8 38D8                    		cmp	al,bl
 14865 000033CA 7424                    		jz	short X_DONE
 14866 000033CC 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14867 000033CE 750F                    		jnz	short ANUM_CHARJ
 14868                                  
 14869                                  ; Modification made for parseline.
 14870                                  ; Why would it be necessary to change colons to spaces? In this
 14871                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14872                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14873                                  
 14874 000033D0 803E[9643]02            		cmp	byte [CPYFLAG],2
 14875 000033D5 7505                    		jnz	short CPCONT4
 14876 000033D7 E85F00                  		call	MOVE_CHAR
 14877 000033DA EBD2                    		jmp	short ANUM_TEST
 14878                                  
 14879                                  CPCONT4:
 14880 000033DC 46                      		inc	si		;Skip the ':'
 14881 000033DD EB11                    		jmp	short X_DONE
 14882                                  
 14883                                  ANUM_CHARJ:
 14884 000033DF E95FFF                  		jmp	ANUM_CHAR
 14885                                  
 14886                                  BADPERR2:
 14887 000033E2 BA[AC3C]                		mov	dx,BADCPMESPTR
 14888 000033E5 E918E8                  		jmp	CERROR
 14889                                  
 14890                                  BADPERR:
 14891 000033E8 E9E1DD                  		jmp	BADCDERR  ; MSDOS 3.3	
 14892                                  
 14893                                  CPERROR:
 14894 000033EB 4E                      		dec	si		; adjust the pointer
 14895 000033EC 5F                      		pop	di		; retrive token buffer address
 14896 000033ED 9D                      		popf			; restore flags
 14897 000033EE F9                      		stc			; set the carry bit
 14898 000033EF C3                      		retn
 14899                                  
 14900                                  X_DONE:
 14901 000033F0 4E                      		dec	si		; adjust for next round
 14902                                  
 14903                                  ; Mod to recognize right and left parens as integral tokens.
 14904                                  ;X_DONE2:
 14905 000033F1 EB3F                    		jmp	short OUT_TOKEN
 14906                                  
 14907                                  A_SWITCH:
 14908 000033F3 80CF01                  		or	bh,1		; Indicate switch
 14909 000033F6 81CD0080                		or	bp,FSWITCH ; 8000h
 14910 000033FA E85BE5                  		call	SCANOFF
 14911 000033FD 46                      		inc	si
 14912 000033FE 3C0D                    		cmp	al,0Dh
 14913 00003400 7509                    		jnz	short STORE_SWT
 14914 00003402 B000                    		mov	al,0
 14915 00003404 AA                      		stosb
 14916 00003405 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14917 00003409 EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14918                                  					;   BP = fSwitch but no switch
 14919                                  					;   bit is set (unknown switch)
 14920                                  
 14921                                  STORE_SWT:
 14922 0000340B E82B00                  		call	MOVE_CHAR	; store the character
 14923                                  
 14924                                  ; This upconv call must stay.  It is used to identify copy-switches
 14925                                  ; on the command line, and won't store anything into the output buffer.
 14926                                  
 14927 0000340E E8F0E3                  		call	UPCONV_MAPCALL
 14928 00003411 06                      		push	es
 14929 00003412 57                      		push	di
 14930 00003413 51                      		push	cx
 14931 00003414 0E                      		push	cs
 14932 00003415 07                      		pop	es
 14933 00003416 BF[5E3E]                		mov	di,SWITCH_LIST ; "VBAPW"
 14934 00003419 B90500                  		mov	cx,SWCOUNT ; 5
 14935 0000341C 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14936 00003420 F2AE                    		repne scasb
 14937 00003422 750B                    		jnz	short OUT_TOKENP
 14938 00003424 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14939 00003428 B80100                  		mov	ax,1
 14940 0000342B D3E0                    		shl	ax,cl
 14941 0000342D 09C5                    		or	bp,ax
 14942                                  OUT_TOKENP:
 14943 0000342F 59                      		pop	cx
 14944 00003430 5F                      		pop	di
 14945 00003431 07                      		pop	es
 14946                                  OUT_TOKEN:
 14947 00003432 B000                    		mov	al,0		; null at the end
 14948 00003434 AA                      		stosb
 14949 00003435 5F                      		pop	di		; restore token buffer pointer	
 14950 00003436 9D                      		popf
 14951 00003437 F8                      		clc			; clear carry flag
 14952 00003438 C3                      		retn
 14953                                  
 14954                                  ; =============== S U B	R O U T	I N E =======================================
 14955                                  
 14956                                  MOVE_CHAR:
 14957 00003439 AA                      		stosb			; store char in token buffer
 14958 0000343A 41                      		inc	cx		; increment char count
 14959 0000343B FE06[D944]              		inc	byte [ELCNT]	; increment element count for * substi
 14960 0000343F C3                      		retn
 14961                                  
 14962                                  ;============================================================================
 14963                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 14964                                  ;============================================================================
 14965                                  ; 30/09/2018 - Retro DOS v3.0
 14966                                  
 14967                                  ; BREAK	<Message Printing Routine>
 14968                                  
 14969                                  ;
 14970                                  ;	MSDOS V3.00 PRINT
 14971                                  ;
 14972                                  ;	Message Printing Routine
 14973                                  ;
 14974                                  
 14975                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 14976                                  ;
 14977                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 14978                                  ;
 14979                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 14980                                  ;
 14981                                  ; Characters are output to PFHandle according to the
 14982                                  ; specifications contained in the Control String.
 14983                                  ;
 14984                                  ; The conversion characters are as follow:
 14985                                  ;
 14986                                  ;               %c - output the next argument as a character
 14987                                  ;               %s - output the next argument as a string
 14988                                  ;               %x - output the next argument as a hexidecimal number
 14989                                  ;                    using abcedf
 14990                                  ;               %X - output the next argument as a hexidecimal number
 14991                                  ;                    using ABCDEF
 14992                                  ;               %d - output the next argument as a decimal number
 14993                                  ;
 14994                                  ;
 14995                                  ; Other format specifiers that may precede the conversion character are:
 14996                                  ;
 14997                                  ;               - (minus sign) - causes the field to be left-adjusted
 14998                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 14999                                  ;               n - digit specifing the minimum field width (default to 1)
 15000                                  ;               L - specifing a long integer
 15001                                  ;
 15002                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 15003                                  ;   to an argument list.
 15004                                  ;
 15005                                  ;   ____________________
 15006                                  ;   |   Ret Addr       |      <= SP
 15007                                  ;   --------------------
 15008                                  ;   |  Ptr to Arg List |
 15009                                  ;   --------------------
 15010                                  ;
 15011                                  ;   And the argument list contains the following:
 15012                                  ;
 15013                                  ;       String_ptr                  (a pointer to the control string)
 15014                                  ;       Arg 1
 15015                                  ;       Arg 2
 15016                                  ;         .
 15017                                  ;         .
 15018                                  ;         .
 15019                                  ;       Arg n-1
 15020                                  ;       Arg n
 15021                                  ;
 15022                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 15023                                  ;   or character.
 15024                                  ;
 15025                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 15026                                  
 15027                                  
 15028                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 15029                                  
 15030                                  ; =============== S U B	R O U T	I N E =======================================
 15031                                  
 15032                                  PRINTF_INIT:
 15033 00003440 E81100                  		call	STD_PRINTF
 15034 00003443 CB                      		retf
 15035                                  
 15036                                  ; =============== S U B	R O U T	I N E =======================================
 15037                                  
 15038                                  PRINTF_CRLF:
 15039 00003444 E80D00                  		call	STD_PRINTF
 15040 00003447 E801E5                  		call	CRLF2
 15041 0000344A C3                      		retn
 15042                                  
 15043                                  ; =============== S U B	R O U T	I N E =======================================
 15044                                  
 15045                                  STD_EPRINTF:
 15046 0000344B 2EC706[793E]0200        		mov	word [cs:PRINTF_HANDLE],2
 15047 00003452 EB07                    		jmp	short NEW_PRINTF
 15048                                  
 15049                                  ; =============== S U B	R O U T	I N E =======================================
 15050                                  
 15051                                  STD_PRINTF:
 15052                                  
 15053                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 15054                                  
 15055 00003454 2EC706[793E]0100        		mov	word [cs:PRINTF_HANDLE],1
 15056                                  
 15057                                  NEW_PRINTF:				;Save the callers' registers
 15058 0000345B FC                      		cld
 15059 0000345C 52                      		push	dx
 15060 0000345D 55                      		push	bp
 15061 0000345E 89E5                    		mov	bp,sp
 15062 00003460 51                      		push	cx
 15063 00003461 53                      		push	bx
 15064 00003462 50                      		push	ax
 15065 00003463 57                      		push	di
 15066 00003464 56                      		push	si
 15067 00003465 06                      		push	es
 15068 00003466 1E                      		push	ds
 15069 00003467 0E                      		push	cs
 15070 00003468 07                      		pop	es		;ES points to Printf segment
 15071 00003469 BF[7B3E]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 15072 0000346C 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 15073                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 15074 0000346F 3E8B7600                		mov	si,[ds:bp] ; bp
 15075 00003473 83C502                  		add	bp,2
 15076 00003476 31DB                    		xor	bx,bx
 15077 00003478 E8D401                  		call	CLEAR_FLAGS	; initialize the world
 15078                                  
 15079                                  GET_CHAR:
 15080 0000347B AC                      		lodsb			;Get a character
 15081 0000347C 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 15082 0000347E 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 15083 00003480 08C0                    		or	al,al		;Is it the end of the control string?
 15084 00003482 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 15085                                  PRINTF_PERCENT:				
 15086 00003484 E86301                  		call	OUTCHR		;Otherwise store the character
 15087 00003487 EBF2                    		jmp	short GET_CHAR	;And go get another
 15088                                  
 15089                                  PRINTF_DONE:
 15090 00003489 E86601                  		call	FLUSH
 15091 0000348C 1F                      		pop	ds
 15092 0000348D 07                      		pop	es
 15093 0000348E 5E                      		pop	si
 15094 0000348F 5F                      		pop	di
 15095 00003490 58                      		pop	ax
 15096 00003491 5B                      		pop	bx
 15097 00003492 59                      		pop	cx
 15098 00003493 5D                      		pop	bp
 15099 00003494 5A                      		pop	dx
 15100 00003495 C3                      		retn
 15101                                  
 15102                                  CONV_CHAR:
 15103 00003496 2EC606[703E]00          		mov	byte [cs:PRINTF_LEFT],0
 15104                                  
 15105                                  NXT_CONV_CHAR:	
 15106                                  		;Look for any format specifiers preceeding the conversion character
 15107 0000349C AC                      		lodsb
 15108 0000349D 3C25                    		cmp	al,'%'			;Just print the %
 15109 0000349F 74E3                    		jz	short PRINTF_PERCENT
 15110                                  		;cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 15111                                  		; 01/03/2023
 15112 000034A1 3C2D                    		cmp	al,'-'
 15113 000034A3 743C                    		jz	short LEFT_ADJ
 15114                                  		;cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 15115 000034A5 3C2B                    		cmp	al,plus_chr ; cmp al,'+'
 15116 000034A7 74ED                    		jz	short CONV_CHAR
 15117                                  		;cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 15118 000034A9 3C4C                    		cmp	al,'L'
 15119 000034AB 743C                    		jz	short LONG_INT
 15120                                  		;cmp	al,[cs:char_l]	 ; "l"		
 15121 000034AD 3C6C                    		cmp	al,'l'
 15122 000034AF 7438                    		jz	short LONG_INT
 15123 000034B1 3C30                    		cmp	al,'0'			;Is it a precision specification
 15124 000034B3 723C                    		jb	short LOOK_CONV_CHAR
 15125 000034B5 3C39                    		cmp	al,'9'
 15126 000034B7 7738                    		ja	short LOOK_CONV_CHAR
 15127 000034B9 3C30                    		cmp	al,'0'
 15128 000034BB 750C                    		jnz	short NOT_PAD
 15129 000034BD 2E833E[743E]00          		cmp	word [cs:PRINTF_WIDTH],0
 15130 000034C3 7504                    		jnz	short NOT_PAD
 15131                                  		;mov	ah,'0'
 15132                                  		;mov	[cs:PAD_CHAR],ah
 15133                                  		; 01/03/2023
 15134 000034C5 2EA2[783E]              		mov	[cs:PAD_CHAR],al ; '0'
 15135                                  NOT_PAD:					;Adjust decimal place on precision
 15136 000034C9 50                      		push	ax
 15137 000034CA 2EA1[743E]              		mov	ax,[cs:PRINTF_WIDTH]
 15138 000034CE B90A00                  		mov	cx,10
 15139 000034D1 F7E1                    		mul	cx
 15140 000034D3 5A                      		pop	dx
 15141 000034D4 30F6                    		xor	dh,dh
 15142 000034D6 80EA30                  		sub	dl,'0'
 15143 000034D9 01D0                    		add	ax,dx
 15144 000034DB 2EA3[743E]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 15145 000034DF EBBB                    		jmp	short NXT_CONV_CHAR
 15146                                  
 15147                                  LEFT_ADJ:
 15148 000034E1 2EC606[703E]01          		mov	byte [cs:PRINTF_LEFT],1
 15149 000034E7 EBB3                    		jmp	short NXT_CONV_CHAR
 15150                                  
 15151                                  LONG_INT:
 15152 000034E9 2E800E[713E]01          		or	byte [cs:PRINTF_LONG],1
 15153 000034EF EBAB                    		jmp	short NXT_CONV_CHAR
 15154                                  
 15155                                  LOOK_CONV_CHAR:
 15156 000034F1 24DF                    		and	al,0DFh
 15157                                  		; 01/03/2023
 15158                                  		;cmp	al,[cs:CHAR_X]	 ; "X"
 15159 000034F3 3C58                    		cmp	al,'X'
 15160 000034F5 7431                    		jz	short HEX_UP
 15161                                  		;cmp	al,[cs:CHAR_D]	 ; "D"
 15162 000034F7 3C44                    		cmp	al,'D'
 15163 000034F9 7436                    		jz	short DECIMAL
 15164                                  		;cmp	al,[cs:CHAR_C]	 ; "C"
 15165 000034FB 3C43                    		cmp	al,'C'
 15166 000034FD 743B                    		jz	short C_PUT_CHAR
 15167                                  		;cmp	al,[cs:CHAR_S]	 ; "S"
 15168 000034FF 3C53                    		cmp	al,'S'
 15169                                  		;jz	short S_PUT_STRG
 15170                                  		;call	CLEAR_FLAGS
 15171                                  		;jmp	GET_CHAR
 15172                                  		; 01/03/2023
 15173 00003501 753F                    		jnz	short S_PUT_5
 15174                                  		;jmp	short S_PUT_STRG ; -->
 15175                                  
 15176                                  		; 01/03/2023
 15177                                  ;HEX_UP:
 15178                                  ;		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15179                                  ;		jmp	short CONV_TO_NUM
 15180                                  ;DECIMAL:
 15181                                  ;		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15182                                  ;		jmp	short CONV_TO_NUM
 15183                                  ;
 15184                                  ;C_PUT_CHAR:
 15185                                  ;		call	NEXT_CHRS
 15186                                  ;		mov	al,dl
 15187                                  ;		call	OUTCHR
 15188                                  ;		call	CLEAR_FLAGS
 15189                                  ;		jmp	GET_CHAR
 15190                                  
 15191                                  ; -->
 15192                                  S_PUT_STRG:
 15193 00003503 56                      		push	si			;Save pointer to control string
 15194 00003504 E83B01                  		call	NEXT_CHRS
 15195 00003507 89D6                    		mov	si,dx
 15196                                  S_PUT_1:
 15197 00003509 2E8B0E[743E]            		mov	cx,[cs:PRINTF_WIDTH]
 15198 0000350E 09C9                    		or	cx,cx
 15199 00003510 740B                    		jz	short S_PUT_2
 15200 00003512 2E803E[703E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15201 00003518 7503                    		jnz	short S_PUT_2
 15202 0000351A E84300                  		call	PAD_STRING
 15203                                  S_PUT_2:
 15204 0000351D 56                      		push	si
 15205                                  S_PUT_3:
 15206 0000351E AC                      		lodsb
 15207 0000351F 08C0                    		or	al,al
 15208 00003521 7425                    		jz	short S_PUT_4
 15209 00003523 E8C400                  		call	OUTCHR			;Put it into our buffer
 15210 00003526 EBF6                    		jmp	short S_PUT_3
 15211                                  
 15212                                  		; 01/03/2023
 15213                                  HEX_UP:
 15214 00003528 2EC706[763E]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15215 0000352F EB43                    		jmp	short CONV_TO_NUM
 15216                                  DECIMAL:
 15217 00003531 2EC706[763E]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15218 00003538 EB3A                    		jmp	short CONV_TO_NUM
 15219                                  C_PUT_CHAR:
 15220 0000353A E80501                  		call	NEXT_CHRS
 15221 0000353D 88D0                    		mov	al,dl
 15222 0000353F E8A800                  		call	OUTCHR
 15223                                  S_PUT_5: ; 01/03/2023
 15224 00003542 E80A01                  		call	CLEAR_FLAGS
 15225 00003545 E933FF                  		jmp	GET_CHAR
 15226                                  S_PUT_4:
 15227 00003548 5E                      		pop	si
 15228 00003549 2E803E[703E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15229 0000354F 740C                    		jz	short C_S_END
 15230 00003551 2E8B0E[743E]            		mov	cx,[cs:PRINTF_WIDTH]
 15231 00003556 09C9                    		or	cx,cx
 15232 00003558 7403                    		jz	short C_S_END
 15233 0000355A E80300                  		call	PAD_STRING
 15234                                  C_S_END:
 15235 0000355D 5E                      		pop	si			;Restore control string pointer
 15236                                  		;call	CLEAR_FLAGS
 15237                                  		;jmp	GET_CHAR		;Go get another character	
 15238                                  		; 01/03/2023
 15239 0000355E EBE2                    		jmp	short S_PUT_5
 15240                                  
 15241                                  
 15242                                  ; =============== S U B	R O U T	I N E =======================================
 15243                                  
 15244                                  PAD_STRING:
 15245 00003560 31D2                    		xor	dx,dx
 15246 00003562 56                      		push	si
 15247                                  COUNT_LOOP:
 15248 00003563 AC                      		lodsb
 15249 00003564 08C0                    		or	al,al
 15250 00003566 7403                    		jz	short COUNT_DONE
 15251 00003568 42                      		inc	dx
 15252 00003569 EBF8                    		jmp	short COUNT_LOOP
 15253                                  COUNT_DONE:
 15254 0000356B 5E                      		pop	si
 15255 0000356C 29D1                    		sub	cx,dx
 15256 0000356E 7603                    		jbe	short COUNT_RET
 15257 00003570 E86700                  		call	PAD
 15258                                  COUNT_RET:
 15259 00003573 C3                      		retn
 15260                                  
 15261                                  ; ---------------------------------------------------------------------------
 15262                                  
 15263                                  CONV_TO_NUM:
 15264 00003574 E8CB00                  		call	NEXT_CHRS
 15265 00003577 89D0                    		mov	ax,dx
 15266 00003579 31D2                    		xor	dx,dx
 15267 0000357B 2E803E[713E]00          		cmp	byte [cs:PRINTF_LONG],0 
 15268                                  				;Is this is a short or long integer?
 15269 00003581 7403                    		jz	short NOT_LONG_INT
 15270 00003583 E8BC00                  		call	NEXT_CHRS
 15271                                  NOT_LONG_INT:
 15272 00003586 53                      		push	bx
 15273 00003587 56                      		push	si
 15274 00003588 2E8B36[763E]            		mov	si,[cs:PRINTF_BASE]
 15275 0000358D 2E8B0E[743E]            		mov	cx,[cs:PRINTF_WIDTH]
 15276 00003592 E80B00                  		call	PNUM
 15277 00003595 5E                      		pop	si
 15278 00003596 5B                      		pop	bx
 15279 00003597 E84000                  		call	PAD
 15280 0000359A E8B200                  		call	CLEAR_FLAGS
 15281 0000359D E9DBFE                  		jmp	GET_CHAR
 15282                                  
 15283                                  
 15284                                  ; =============== S U B	R O U T	I N E =======================================
 15285                                  
 15286                                  PNUM:
 15287 000035A0 49                      		dec	cx
 15288 000035A1 50                      		push	ax
 15289 000035A2 89D0                    		mov	ax,dx
 15290 000035A4 31D2                    		xor	dx,dx
 15291 000035A6 F7F6                    		div	si
 15292 000035A8 89C3                    		mov	bx,ax
 15293 000035AA 58                      		pop	ax
 15294 000035AB F7F6                    		div	si
 15295 000035AD 87DA                    		xchg	bx,dx
 15296 000035AF 50                      		push	ax
 15297 000035B0 09D0                    		or	ax,dx
 15298 000035B2 58                      		pop	ax
 15299 000035B3 7407                    		jz	short DO_PAD
 15300 000035B5 53                      		push	bx
 15301 000035B6 E8E7FF                  		call	PNUM
 15302 000035B9 5B                      		pop	bx
 15303 000035BA EB0B                    		jmp	short REM
 15304                                  
 15305                                  DO_PAD:
 15306 000035BC 2E803E[703E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15307 000035C2 7503                    		jnz	short REM
 15308 000035C4 E81300                  		call	PAD
 15309                                  REM:
 15310 000035C7 80FB0A                  		cmp	bl,10
 15311 000035CA 7203                    		jb	short NOT_HEX
 15312 000035CC 83C306                  		add	bx,6
 15313                                  NOT_HEX:
 15314 000035CF 2E8A87[7036]            		mov	al,[cs:PRINTF_TABLE+bx]	; "0123456789ABCDEF"
 15315 000035D4 51                      		push	cx
 15316 000035D5 E81200                  		call	OUTCHR
 15317 000035D8 59                      		pop	cx
 15318 000035D9 C3                      		retn
 15319                                  
 15320                                  ; =============== S U B	R O U T	I N E =======================================
 15321                                  
 15322                                  PAD:
 15323 000035DA 09C9                    		or	cx,cx
 15324 000035DC 7E0B                    		jle	short PAD_DONE
 15325 000035DE 2EA0[783E]              		mov	al,[cs:PAD_CHAR]
 15326                                  PAD_LOOP:
 15327 000035E2 51                      		push	cx
 15328 000035E3 E80400                  		call	OUTCHR
 15329 000035E6 59                      		pop	cx
 15330 000035E7 E2F9                    		loop	PAD_LOOP
 15331                                  PAD_DONE:
 15332 000035E9 C3                      		retn
 15333                                  
 15334                                  ; =============== S U B	R O U T	I N E =======================================
 15335                                  
 15336                                  OUTCHR:
 15337 000035EA AA                      		stosb
 15338 000035EB 81FF[DF3E]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15339 000035EF 7401                    		je	short FLUSH
 15340                                  OUTCHR_RETN:
 15341 000035F1 C3                      		retn
 15342                                  
 15343                                  ; =============== S U B	R O U T	I N E =======================================
 15344                                  
 15345                                  FLUSH:
 15346 000035F2 B9[7B3E]                		mov	cx,PRINTF_BUF
 15347 000035F5 87CF                    		xchg	cx,di
 15348 000035F7 29F9                    		sub	cx,di
 15349 000035F9 74F6                    		jz	short OUTCHR_RETN
 15350                                  WRITE_CHARS:
 15351 000035FB 53                      		push	bx
 15352 000035FC 2E8B1E[793E]            		mov	bx,[cs:PRINTF_HANDLE]
 15353 00003601 1E                      		push	ds
 15354 00003602 0E                      		push	cs
 15355 00003603 1F                      		pop	ds
 15356 00003604 BA[7B3E]                		mov	dx,PRINTF_BUF
 15357 00003607 B440                    		mov	ah,WRITE ; 40h
 15358 00003609 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15359                                  					; BX = file handle, CX = number	of bytes to write,
 15360                                  					; DS:DX -> buffer
 15361 0000360B 730A                    		jnb	short FOOB2_1
 15362 0000360D E87FE8                  		call	GET_EXT_ERR_NUMBER
 15363 00003610 83F806                  		cmp	ax,6
 15364 00003613 742A                    		jz	short FOOB2_4
 15365 00003615 EB04                    		jmp	short FOOB2_2
 15366                                  
 15367                                  FOOB2_1:
 15368 00003617 39C1                    		cmp	cx,ax
 15369 00003619 7424                    		jz	short FOOB2_4
 15370                                  FOOB2_2:
 15371 0000361B 89D3                    		mov	bx,dx
 15372 0000361D 01C3                    		add	bx,ax
 15373 0000361F 803F1A                  		cmp	byte [bx],1Ah
 15374 00003622 741B                    		jz	short FOOB2_4
 15375 00003624 1F                      		pop	ds
 15376 00003625 5B                      		pop	bx
 15377 00003626 2E8E06[B141]            		mov	es,[cs:RESSEG]
 15378 0000362B BA[9937]                		mov	dx,NOSPACEPTR
 15379 0000362E 26F6065C0CFF            		test	byte [es:PIPEFLAG],0FFh
 15380 00003634 7406                    		jz	short PRINT_ERR_EXIT
 15381 00003636 E8F7EC                  		call	PIPEOFF
 15382 00003639 BA[323C]                		mov	dx,PIPEEMESPTR
 15383                                  PRINT_ERR_EXIT:	
 15384 0000363C E9C1E5                  		jmp	CERROR
 15385                                  
 15386                                  FOOB2_4:
 15387 0000363F 1F                      		pop	ds
 15388 00003640 5B                      		pop	bx
 15389 00003641 C3                      		retn
 15390                                  
 15391                                  ; =============== S U B	R O U T	I N E =======================================
 15392                                  
 15393                                  NEXT_CHRS:
 15394 00003642 56                      		push	si		;Save pointer to control string
 15395 00003643 89DE                    		mov	si,bx		;Get index into argument list
 15396 00003645 83C302                  		add	bx,2		;Increment the index
 15397 00003648 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15398 0000364B 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15399 0000364D 5E                      		pop	si
 15400 0000364E C3                      		retn
 15401                                  
 15402                                  ; =============== S U B	R O U T	I N E =======================================
 15403                                  
 15404                                  CLEAR_FLAGS:
 15405 0000364F 31C0                    		xor	ax,ax
 15406 00003651 2EA2[703E]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15407 00003655 2EA2[713E]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15408 00003659 2EA3[743E]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15409 0000365D B020                    		mov	al,' '			
 15410 0000365F 2EA2[783E]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15411 00003663 C3                      		retn
 15412                                  
 15413                                  ; ---------------------------------------------------------------------------
 15414                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15415                                  
 15416                                  		; times 7 db 0
 15417                                  
 15418                                  ;============================================================================
 15419                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15420                                  ;============================================================================
 15421                                  ; 30/09/2018 - Retro DOS v3.0
 15422                                  
 15423                                  ; TITLE	COMMAND Transient Initialized DATA
 15424                                  
 15425                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15426                                  ;initial values at the beginning of each command cycle. It is
 15427                                  ;included in the transient checksum area. If values in TRANDATA
 15428                                  ;change, the transient will be reloaded for the next command cycle.
 15429                                  
 15430 00003664 90<rep Ch>              align 16
 15431                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15432                                  
 15433 00003670 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15433 00003679 39414243444546     
 15434 00003680 255300                  _3740h:		db '%S',0
 15435 00003683 [8036]                  ARG_BUF_PTR:	dw _3740h
 15436 00003685 [8736]                  		dw _3747h
 15437 00003687 [0843]                  _3747h:		dw ARG_BUF ; _43E8h
 15438 00003689 25532000                _3749h:		db '%S ',0
 15439 0000368D [8936]                  STRINGBUF1PTR:	dw _3749h
 15440 0000368F [8843]                  		dw STRING_PTR_1 ; _4468h
 15441 00003691 25396C6400              _3751h:		db '%9ld',0
 15442 00003696 [9136]                  FSIZEMESPTR:	dw _3751h
 15443 00003698 [8A43]                  		dw FILESIZE_L ; _446Ah
 15444 0000369A [8C43]                  		dw FILESIZE_H ; _446Ch
 15445 0000369C 255300                  _375Ch:		db '%S',0
 15446 0000369F [9C36]                  STRINGBUF2PTR:	dw _375Ch
 15447 000036A1 [8E43]                  		dw STRING_PTR_2 ; _446Eh
 15448 000036A3 0900                    _3763h:		db 9,0
 15449 000036A5 [A336]                  TABPTR:		dw _3763h
 15450 000036A7 0D0A                    _3767h:		db 0Dh,0Ah
 15451 000036A9 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15451 000036B2 65206D697373696E67-
 15451 000036BB 0D0A00             
 15452 000036BE [A736]                  BADPATHPTR:	dw _3767h
 15453 000036C0 0D0A                    _3780h:		db 0Dh,0Ah
 15454 000036C2 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15454 000036CB 736B20776974682062-
 15454 000036D4 617463682066696C65-
 15454 000036DD 0D0A               
 15455 000036DF 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15455 000036E8 20616E79206B657920-
 15455 000036F1 7768656E2072656164-
 15455 000036FA 790D0A00           
 15456 000036FE [C036]                  INSERTDSKPTR:	dw _3780h
 15457 00003700 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15457 00003709 6E64206F722066696C-
 15457 00003712 65206E616D650D0A00 
 15458 0000371B [0037]                  BADNAMPTR:	dw _37C0h
 15459 0000371D 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15459 00003726 2066696C65206E616D-
 15459 0000372F 65206F722046696C65-
 15459 00003738 206E6F7420666F756E-
 15459 00003741 640D0A00           
 15460 00003745 [1D37]                  RENERRPTR:	dw _37DDh
 15461 00003747 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15461 00003750 666F756E640D0A00   
 15462 00003758 [4737]                  FNOTFOUNDPTR:	dw _3807h
 15463 0000375A 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15463 00003763 666F756E640D0A00   
 15464 0000376B [5A37]                  PNOTFOUNDPTR:	dw _381Ah
 15465 0000376D 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15465 00003776 6E6965640D0A00     
 15466 0000377D [6D37]                  ACCDENPTR:	dw _382Dh
 15467 0000377F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15467 00003788 656E74206469736B20-
 15467 00003791 73706163650D0A00   
 15468 00003799 [7F37]                  NOSPACEPTR:	dw _383Fh
 15469 0000379B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15469 000037A4 7669726F6E6D656E74-
 15469 000037AD 2073706163650D0A00 
 15470 000037B6 [9B37]                  ENVERRPTR:	dw _385Bh
 15471 000037B8 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15471 000037C1 74696F6E206572726F-
 15471 000037CA 720D0A00           
 15472 000037CE 7838                    FULDIRPTR:	dw 3878h
 15473 000037D0 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15473 000037D9 6F7420626520636F70-
 15473 000037E2 696564206F6E746F20-
 15473 000037EB 697473656C660D0A00 
 15474 000037F4 [D037]                  OVERWRPTR:	dw _3890h
 15475 000037F6 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15475 000037FF 662064657374696E61-
 15475 00003808 74696F6E206C6F7374-
 15475 00003811 206265666F72652063-
 15475 0000381A 6F70790D0A00       
 15476 00003820 [F637]                  LOSTERRPTR:	dw _38B6h
 15477 00003822 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15477 0000382B 696C656E616D65206F-
 15477 00003834 722066696C65206E6F-
 15477 0000383D 7420666F756E640D0A-
 15477 00003846 00                 
 15478 00003847 [2238]                  INORNOTPTR:	dw _38E2h
 15479 00003849 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15479 00003852 732920636F70696564-
 15479 0000385B 0D0A00             
 15480 0000385E [4938]                  COPIEDPTR:	dw _3909h
 15481 00003860 [9043]                  		dw COPY_NUM ; _4470h
 15482 00003862 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15482 0000386B 73292000           
 15483 0000386F [6238]                  DIRMESPTR:	dw _3922h
 15484 00003871 [9743]                  		dw DIR_NUM  ; _4477h
 15485 00003873 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15485 0000387C 7320667265650D0A00 
 15486 00003885 [7338]                  BYTEMESPTR:	dw _3933h
 15487 00003887 [9943]                  		dw BYTES_FREE   ; _4479h
 15488 00003889 [9B43]                  		dw BYTES_FREE+2 ; _447Bh
 15489 0000388B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15489 00003894 726976652073706563-
 15489 0000389D 696669636174696F6E-
 15489 000038A6 0D0A00             
 15490 000038A9 [8B38]                  BADDRVPTR:	dw _394Bh
 15491 000038AB 0D0A                    _396Bh:		db 0Dh,0Ah
 15492 000038AD 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15492 000038B6 20253564206E6F7420-
 15492 000038BF 707265706172656420-
 15492 000038C8 666F72207379737465-
 15492 000038D1 6D0D0A00           
 15493 000038D5 [AB38]                  CPNOTSETPTR:	dw _396Bh
 15494 000038D7 [503E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15495 000038D9 0D0A                    _3999h:		db 0Dh,0Ah
 15496 000038DB 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15496 000038E4 20253564206E6F7420-
 15496 000038ED 707265706172656420-
 15496 000038F6 666F7220616C6C2064-
 15496 000038FF 6576696365730D0A00 
 15497 00003908 [D938]                  CPNOTALLPTR:	dw _3999h
 15498 0000390A [503E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15499 0000390C 0D0A                    _39CCh:		db 0Dh,0Ah
 15500 0000390E 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15500 00003917 646520706167653A20-
 15500 00003920 2535640D0A00       
 15501 00003926 [0C39]                  CPACTIVEPTR:	dw _39CCh
 15502 00003928 [503E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15503 0000392A 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15503 00003933 72697665206973206E-
 15503 0000393C 6F206C6F6E67657220-
 15503 00003945 76616C696400       
 15504 0000394B [2A39]                  BADCURDRVPTR:	dw _39EAh
 15505 0000394D 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15505 00003956 6B6579207768656E20-
 15505 0000395F 7265616479202E202E-
 15505 00003968 202E2000           
 15506 0000396C [4D39]                  PAUSEMESPTR:	dw _3A0Dh
 15507 0000396E 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15507 00003977 6172616D657465720D-
 15507 00003980 0A00               
 15508 00003982 [6E39]                  BADPARMPTR:	dw _3A2Eh
 15509 00003984 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15509 0000398D 576564546875467269-
 15509 00003996 536174             
 15510 00003999 0D0A                    _3A59h:		db 0Dh,0Ah
 15511 0000399B 496E76616C69642064-     		db 'Invalid date',0
 15511 000039A4 61746500           
 15512 000039A8 [9939]                  BADDATPTR:	dw _3A59h
 15513 000039AA 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15513 000039B3 6174652069732000   
 15514 000039BB [AA39]                  CURDATPTR:	dw _3A6Ah
 15515 000039BD 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15516 000039BF 456E746572206E6577-     		db 'Enter new date ',0
 15516 000039C8 20646174652000     
 15517 000039CF [BD39]                  NEWDATPTR:	dw _3A7Dh
 15518 000039D1 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15518 000039DA 293A2000           
 15519 000039DE [D139]                  USADATPTR:	dw _3A91h
 15520 000039E0 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15520 000039E9 293A2000           
 15521 000039ED [E039]                  EURDATPTR:	dw _3AA0h
 15522 000039EF 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15522 000039F8 293A2000           
 15523 000039FC [EF39]                  JAPDATPTR:	dw _3AAFh
 15524 000039FE 0D0A                    _3ABEh:		db 0Dh,0Ah
 15525 00003A00 496E76616C69642074-     		db 'Invalid time ',0
 15525 00003A09 696D652000         
 15526 00003A0E [FE39]                  BADTIMPTR:	dw _3ABEh
 15527 00003A10 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15527 00003A19 696D652069732000   
 15528 00003A21 [103A]                  CURTIMPTR:	dw _3AD0h
 15529 00003A23 0D0A                    _3AE3h:		db 0Dh,0Ah
 15530 00003A25 456E746572206E6577-     		db 'Enter new time: ',0
 15530 00003A2E 2074696D653A2000   
 15531 00003A36 [233A]                  NEWTIMPTR:	dw _3AE3h
 15532 00003A38 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15532 00003A41 7572652028592F4E29-
 15532 00003A4A 3F00               
 15533 00003A4C [383A]                  SUREMESPTR:	dw _3AF8h
 15534 00003A4E 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15534 00003A57 00                 
 15535 00003A58 [4E3A]                  DMESPTR:	dw _3B0Eh
 15536 00003A5A 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15536 00003A63 7273696F6E20253164-
 15536 00003A6C 2E2530326420202020-
 15536 00003A75 202020202020202020-
 15536 00003A7E 202020202020202000 
 15537 00003A87 [5A3A]                  VERMESPTR:	dw _3B1Ah
 15538 00003A89 [9D43]                  		dw MAJOR_VER_NUM ; _447Dh
 15539 00003A8B [9F43]                  		dw MINOR_VER_NUM ; _447Fh
 15540 00003A8D 254300                  _3B4Dh:		db '%C',0
 15541 00003A90 [8D3A]                  ONECHRVALPTR:	dw _3B4Dh
 15542 00003A92 [A143]                  		dw ONE_CHAR_VAL	; _4481h
 15543 00003A94 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15543 00003A9D 6E2064726976652025-
 15543 00003AA6 6320257300         
 15544 00003AAB [943A]                  VOLMESPTR:	dw _3B54h
 15545 00003AAD [A443]                  		dw VOL_DRV ; _4484h
 15546 00003AAF [A243]                  		dw VOLNAME_ADDR ; _4482h
 15547 00003AB1 69732000                IS:		db 'is ',0
 15548 00003AB5 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15548 00003ABE 62656C00           
 15549 00003AC2 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15549 00003ACB 69726563746F72790D-
 15549 00003AD4 0A00               
 15550 00003AD6 [C23A]                  BADCDPTR:	dw _3B82h
 15551 00003AD8 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15551 00003AE1 206372656174652064-
 15551 00003AEA 69726563746F72790D-
 15551 00003AF3 0A00               
 15552 00003AF5 [D83A]                  BADMKDPTR:	dw _3B98h
 15553 00003AF7 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15553 00003B00 6174682C206E6F7420-
 15553 00003B09 6469726563746F7279-
 15553 00003B12 2C0D0A             
 15554 00003B15 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15554 00003B1E 6F7279206E6F742065-
 15554 00003B27 6D7074790D0A00     
 15555 00003B2E [F73A]                  BADRMDPTR:	dw _3BB7h
 15556 00003B30 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15556 00003B39 696679204F4E206F72-
 15556 00003B42 204F46460D0A00     
 15557 00003B49 [303B]                  BADONOFFPTR:	dw _3BF0h
 15558 00003B4B 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15558 00003B54 79206F66202025530D-
 15558 00003B5D 0A00               
 15559 00003B5F [4B3B]                  DIRHEADPTR:	dw _3C0Bh
 15560 00003B61 [A543]                  		dw VOL_DIR ; _4485h
 15561 00003B63 4E6F205061746800        _3C23h:		db 'No Path',0
 15562 00003B6B [633B]                  NULLPATHPTR:	dw _3C23h
 15563 00003B6D 504154483D              PATH_TEXT:	db 'PATH='
 15564 00003B72 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15565 00003B79 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15566 00003B81 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15566 00003B8A 7269766520696E2073-
 15566 00003B93 656172636820706174-
 15566 00003B9C 680D0A00           
 15567 00003BA0 [813B]                  BADPMESPTR:	dw _3C41h
 15568 00003BA2 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15568 00003BAB 65766963650D0A00   
 15569 00003BB3 [A23B]                  BADDEVPTR:	dw _3C62h
 15570 00003BB5 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15570 00003BBE 20666F756E640D0A00 
 15571 00003BC7 [B53B]                  BADLABPTR:	dw _3C75h
 15572 00003BC9 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15572 00003BD2 726F720D0A00       
 15573 00003BD8 [C93B]                  SYNTMESPTR:	dw _3C89h
 15574 00003BDA 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15574 00003BE3 6F74206265206E6573-
 15574 00003BEC 7465640D0A00       
 15575 00003BF2 [DA3B]                  FORNESTMESTR:	dw _3C9Ah
 15576 00003BF4 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15576 00003BFD 656E74206D656D6F72-
 15576 00003C06 790D0A00           
 15577 00003C0A [F43B]                  INSFMEMMESPTR:	dw _3CB4h
 15578 00003C0C 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15578 00003C15 6174652066696C6520-
 15578 00003C1E 6572726F7220647572-
 15578 00003C27 696E6720706970650D-
 15578 00003C30 0A00               
 15579 00003C32 [0C3C]                  PIPEEMESPTR:	dw _3CCCh
 15580 00003C34 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15580 00003C3D 2062696E6172792072-
 15580 00003C46 656164732066726F6D-
 15580 00003C4F 206120646576696365-
 15580 00003C58 0D0A00             
 15581 00003C5B [343C]                  INBDEVPTR:	dw _3CF4h
 15582 00003C5D 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15582 00003C66 00                 
 15583 00003C67 [5D3C]                  CTRLMESPTR:	dw _3D1Dh
 15584 00003C69 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15584 00003C72 2000               
 15585 00003C74 [693C]                  VERIMESPTR:	dw _3D29h
 15586 00003C76 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15587 00003C7F [763C]                  ECHOMESPTR:	dw _3D36h
 15588 00003C81 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15589 00003C87 [813C]                  OFFMESPTR:	dw _3D41h
 15590 00003C89 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15591 00003C8E [893C]                  ONMESPTR:	dw _3D49h
 15592 00003C90 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15592 00003C99 617468206F72206669-
 15592 00003CA2 6C65206E616D650D0A-
 15592 00003CAB 00                 
 15593 00003CAC [903C]                  BADCPMESPTR:	dw _3D50h
 15594 00003CAE 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15594 00003CB7 756D626572206F6620-
 15594 00003CC0 706172616D65746572-
 15594 00003CC9 730D0A00           
 15595 00003CCD [AE3C]                  BADARGSPTR:	dw _3D6Eh
 15596 00003CCF 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15596 00003CD8 74696E6720746F2064-
 15596 00003CE1 65766963650D0A00   
 15597 00003CE9 [CF3C]                  DEVWMESPTR:	dw _3D8Fh
 15598 00003CEB 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15599 00003CEE [EB3C]                  ACRLFPTR:	dw _3DABh
 15600 00003CF0 08                      _3DB0h:		db 8
 15601 00003CF1 20                      		db 20h
 15602 00003CF2 08                      		db 8
 15603 00003CF3 00                      		db 0
 15604 00003CF4 [F03C]                  DBACKPTR:	dw _3DB0h
 15605 00003CF6 79                      small_y:	db 'y'
 15606 00003CF7 6E                      small_n:	db 'n'
 15607 00003CF8 59                      CAPITAL_Y:	db 'Y'
 15608 00003CF9 4E                      CAPITAL_N:	db 'N'
 15609 00003CFA 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15610                                  PROMPT_TABLE:
 15611 00003CFF 42                      		db 'B' ; 42h
 15612 00003D00 [E213]                  		dw PRINT_B
 15613 00003D02 44                      		db 'D' ; 44h
 15614 00003D03 [3D29]                  		dw PRINT_DATE
 15615 00003D05 45                      		db 'E' ; 45h
 15616 00003D06 [D613]                  		dw PRINT_ESC
 15617 00003D08 47                      		db 'G' ; 47h
 15618 00003D09 [DA13]                  		dw PRINT_G
 15619 00003D0B 48                      		db 'H' ; 48h
 15620 00003D0C [CC13]                  		dw PRINT_BACK
 15621 00003D0E 4C                      		db 'L' ; 4Ch
 15622 00003D0F [DE13]                  		dw PRINT_L
 15623 00003D11 4E                      		db 'N' ; 4Eh
 15624 00003D12 [F713]                  		dw PRINT_DRIVE
 15625 00003D14 50                      		db 'P' ; 50h
 15626 00003D15 [FF13]                  		dw BUILD_DIR_FOR_PROMPT
 15627 00003D17 51                      		db 'Q' ; 51h
 15628 00003D18 [D213]                  		dw PRINT_EQ
 15629 00003D1A 54                      		db 'T' ; 54h
 15630 00003D1B [D121]                  		dw PRINT_TIME
 15631 00003D1D 56                      		db 'V' ; 56h
 15632 00003D1E [6013]                  		dw PRINT_VERSION
 15633 00003D20 5F                      		db '_' ; 5Fh
 15634 00003D21 [4B19]                  		dw CRLF2
 15635 00003D23 24                      		db '$' ; 24h
 15636 00003D24 [E413]                  		dw PRINT_CHAR
 15637 00003D26 00                      		db 0
 15638                                  
 15639                                  		; Table of IF conditionals
 15640                                  IFTAB:
 15641 00003D27 03                      		db 3	; First byte is count
 15642 00003D28 4E4F54                  		db 'NOT'
 15643 00003D2B [7E09]                  		dw IFNOT
 15644 00003D2D 0A                      		db 10
 15645 00003D2E 4552524F524C455645-     		db 'ERRORLEVEL'
 15645 00003D37 4C                 
 15646 00003D38 [410A]                  		dw IFERLEV
 15647 00003D3A 05                      		db 5
 15648 00003D3B 4558495354              		db 'EXIST'
 15649 00003D40 [D509]                  		dw IFEXISTS
 15650 00003D42 00                      		db 0
 15651                                  
 15652                                  		; Table for internal command names
 15653                                  
 15654 00003D43 03                      COMTAB:		db 3
 15655 00003D44 444952                  		db 'DIR'
 15656 00003D47 03                      		db 3
 15657 00003D48 [B00E]                  		dw CATALOG
 15658 00003D4A 04                      		db 4
 15659 00003D4B 43414C4C                		db 'CALL'
 15660 00003D4F 02                      		db 2
 15661 00003D50 [B60A]                  		dw _$CALL
 15662 00003D52 04                      		db 4
 15663 00003D53 43484350                		db 'CHCP'
 15664 00003D57 02                      		db 2
 15665 00003D58 [A415]                  		dw CHCP
 15666 00003D5A 06                      		db 6
 15667 00003D5B 52454E414D45            		db 'RENAME'
 15668 00003D61 01                      		db 1
 15669 00003D62 [F011]                  		dw CRENAME
 15670 00003D64 03                      		db 3
 15671 00003D65 52454E                  		db 'REN'
 15672 00003D68 01                      		db 1
 15673 00003D69 [F011]                  		dw CRENAME
 15674 00003D6B 05                      		db 5
 15675 00003D6C 4552415345              		db 'ERASE'
 15676 00003D71 01                      		db 1
 15677 00003D72 [8711]                  		dw ERASE
 15678 00003D74 03                      		db 3
 15679 00003D75 44454C                  		db 'DEL'
 15680 00003D78 01                      		db 1
 15681 00003D79 [8711]                  		dw ERASE
 15682 00003D7B 04                      		db 4
 15683 00003D7C 54595045                		db 'TYPE'
 15684 00003D80 01                      		db 1
 15685 00003D81 [6412]                  		dw TYPEFIL
 15686 00003D83 03                      		db 3
 15687 00003D84 52454D                  		db 'REM'
 15688 00003D87 02                      		db 2
 15689 00003D88 [0401]                  		dw TCOMMAND
 15690 00003D8A 04                      		db 4
 15691 00003D8B 434F5059                		db 'COPY'
 15692 00003D8F 03                      		db 3
 15693 00003D90 [9329]                  		dw COPY
 15694 00003D92 05                      		db 5
 15695 00003D93 5041555345              		db 'PAUSE'
 15696 00003D98 02                      		db 2
 15697 00003D99 [7A11]                  		dw PAUSE
 15698 00003D9B 04                      		db 4
 15699 00003D9C 44415445                		db 'DATE'
 15700 00003DA0 02                      		db 2
 15701 00003DA1 [AB20]                  		dw DATE
 15702 00003DA3 04                      		db 4
 15703 00003DA4 54494D45                		db 'TIME'
 15704 00003DA8 00                      		db 0
 15705 00003DA9 [BE21]                  		dw CTIME
 15706 00003DAB 03                      		db 3
 15707 00003DAC 564552                  		db 'VER'
 15708 00003DAF 00                      		db 0
 15709 00003DB0 [5713]                  		dw VERSION
 15710 00003DB2 03                      		db 3
 15711 00003DB3 564F4C                  		db 'VOL'
 15712 00003DB6 01                      		db 1
 15713 00003DB7 [0113]                  		dw VOLUME
 15714 00003DB9 02                      		db 2
 15715 00003DBA 4344                    		db 'CD'
 15716 00003DBC 01                      		db 1
 15717 00003DBD [8718]                  		dw _$CHDIR
 15718 00003DBF 05                      		db 5
 15719 00003DC0 4348444952              		db 'CHDIR'
 15720 00003DC5 01                      		db 1
 15721 00003DC6 [8718]                  		dw _$CHDIR
 15722 00003DC8 02                      		db 2
 15723 00003DC9 4D44                    		db 'MD'
 15724 00003DCB 01                      		db 1
 15725 00003DCC [CA18]                  		dw _$MKDIR
 15726 00003DCE 05                      		db 5
 15727 00003DCF 4D4B444952              		db 'MKDIR'
 15728 00003DD4 01                      		db 1
 15729 00003DD5 [CA18]                  		dw _$MKDIR
 15730 00003DD7 02                      		db 2
 15731 00003DD8 5244                    		db 'RD'
 15732 00003DDA 01                      		db 1
 15733 00003DDB [0E19]                  		dw _$RMDIR
 15734 00003DDD 05                      		db 5
 15735 00003DDE 524D444952              		db 'RMDIR'
 15736 00003DE3 01                      		db 1
 15737 00003DE4 [0E19]                  		dw _$RMDIR
 15738 00003DE6 05                      		db 5
 15739 00003DE7 425245414B              		db 'BREAK'
 15740 00003DEC 00                      		db 0
 15741 00003DED [7528]                  		dw CNTRLC
 15742 00003DEF 06                      		db 6
 15743 00003DF0 564552494659            		db 'VERIFY'
 15744 00003DF6 00                      		db 0
 15745 00003DF7 [A728]                  		dw VERIFY
 15746 00003DF9 03                      		db 3
 15747 00003DFA 534554                  		db 'SET'
 15748 00003DFD 02                      		db 2
 15749 00003DFE [7B16]                  		dw ADD_NAME_TO_ENVIRONMENT
 15750 00003E00 06                      		db 6
 15751 00003E01 50524F4D5054            		db 'PROMPT'
 15752 00003E07 02                      		db 2
 15753 00003E08 [6116]                  		dw ADD_PROMPT
 15754 00003E0A 04                      		db 4
 15755 00003E0B 50415448                		db 'PATH'
 15756 00003E0F 02                      		db 2
 15757 00003E10 [6614]                  		dw PATH
 15758 00003E12 04                      		db 4
 15759 00003E13 45584954                		db 'EXIT'
 15760 00003E17 00                      		db 0
 15761 00003E18 [3316]                  		dw _$EXIT
 15762 00003E1A 04                      		db 4
 15763 00003E1B 43545459                		db 'CTTY'
 15764 00003E1F 03                      		db 3
 15765 00003E20 [4015]                  		dw CTTY
 15766 00003E22 04                      		db 4
 15767 00003E23 4543484F                		db 'ECHO'
 15768 00003E27 02                      		db 2
 15769 00003E28 [3228]                  		dw ECHO
 15770 00003E2A 04                      		db 4
 15771 00003E2B 474F544F                		db 'GOTO'
 15772 00003E2F 02                      		db 2
 15773 00003E30 [EA0A]                  		dw GOTO
 15774 00003E32 05                      		db 5
 15775 00003E33 5348494654              		db 'SHIFT'
 15776 00003E38 02                      		db 2
 15777 00003E39 [6F0A]                  		dw SHIFT
 15778 00003E3B 02                      		db 2
 15779 00003E3C 4946                    		db 'IF'
 15780 00003E3E 02                      		db 2
 15781 00003E3F [2E09]                  		dw _$IF
 15782 00003E41 03                      		db 3
 15783 00003E42 464F52                  		db 'FOR'
 15784 00003E45 02                      		db 2
 15785 00003E46 [430D]                  		dw _$FOR
 15786 00003E48 03                      		db 3
 15787 00003E49 434C53                  		db 'CLS'
 15788 00003E4C 00                      		db 0
 15789 00003E4D [D514]                  		dw CLS
 15790 00003E4F 00                      		db 0
 15791                                  
 15792                                  ; 01/03/2023
 15793                                  ;CAPITAL_A:	db 'A'
 15794                                  ;VBAR:		db '|'
 15795                                  ;LABRACKET:	db '<' ; 3Ch
 15796                                  ;RABRACKET:	db '>' ; 3Eh
 15797                                  ;DOLLAR:	db '$'
 15798                                  ;LPAREN:	db '('
 15799                                  ;RPAREN:	db ')'
 15800                                  ;NULLRPAREN:	db ')' ; 29h
 15801                                  ;		db 0
 15802                                  ;IN_WORD:	db 'I','N'
 15803                                  ;DO_WORD:	db 'D','O'
 15804                                  ;STAR:		db '*'
 15805                                  ;CHAR_SUB:	db '-' 
 15806                                  ;PLUS_CHR:	db '+'
 15807                                  ;CHAR_L:	db 'L'
 15808                                  ;char_l:	db 'l'
 15809                                  ;small_a:	db 'a'
 15810                                  ;small_z:	db 'z'
 15811                                  ;CHAR_D:	db 'D'
 15812                                  ;CHAR_C:	db 'C'
 15813                                  ;CHAR_S:	db 'S'
 15814                                  ;CHAR_X:	db 'X'
 15815                                  ;DOT_CHR:	db '.' 
 15816                                  ;DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15817                                  ;		db ','
 15818                                  ;TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15819                                  ;MNCHR:		db 'p'
 15820                                  
 15821 00003E50 0000                    SYSTEM_CPAGE:	dw 0
 15822                                  
 15823 00003E52 2E434F4D                COMEXT:		db '.COM'
 15824 00003E56 2E455845                EXEEXT:		db '.EXE'
 15825 00003E5A 2E424154                BATEXT:		db '.BAT'
 15826 00003E5E 5642415057              SWITCH_LIST:	db 'VBAPW'
 15827 00003E63 2000                    BATBUFLEN:	dw BATLEN ; 32
 15828                                  
 15829                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15830                                  
 15831                                  TRANDATAEND:
 15832                                  
 15833                                  ;============================================================================
 15834                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15835                                  ;============================================================================
 15836                                  ; 29/09/2018 - Retro DOS v3.0
 15837                                  
 15838                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15839                                  
 15840                                  ;The TRANSPACE segment contains variable data that is considered
 15841                                  ;volatile between command cycles, and therefore is not included in the
 15842                                  ;transient checksum area. Contents of these variables MUST be
 15843                                  ;initialized before use, and must not be relied upon from command
 15844                                  ;cycle to command cycle.
 15845                                  ;
 15846                                  ;No constant data values should be stored here.
 15847                                  
 15848                                  ; ---------------------------------------------------------------------------
 15849                                  ; START OF UNITIALIZED DATA
 15850                                  ; ---------------------------------------------------------------------------	
 15851                                  
 15852                                  ;	times 12 db 0
 15853                                  
 15854 00003E65 90<rep Bh>              align 16
 15855                                  
 15856                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15857                                  
 15858 00003E70 00                      PRINTF_LEFT:	db 0
 15859 00003E71 00                      PRINTF_LONG:	db 0
 15860 00003E72 00                      PRINTF_HEX:	db 0
 15861 00003E73 00                      TABLE_INDEX:	db 0
 15862 00003E74 0000                    PRINTF_WIDTH:	dw 0
 15863 00003E76 0000                    PRINTF_BASE:	dw 0
 15864 00003E78 00                      PAD_CHAR:	db 0
 15865 00003E79 0000                    PRINTF_HANDLE:	dw 0
 15866 00003E7B 00<rep 64h>             PRINTF_BUF: times 100 db 0
 15867                                  PRINTF_BUF_END: ; 30/09/2018
 15868                                  
 15869                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15870                                  
 15871 00003EDF 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15872 00003F36 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15873 00003F8D 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15874 00004010 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15875 00004093 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15876 000040D9 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15877 0000415C 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15878                                  
 15879                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15880 000041AF 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15881 000041B1 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15882 000041B3 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15883 000041B5 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15884 000041B6 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15885 000041B7 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15886                                  					; MYSEG1    (dw 0)	
 15887 000041BB 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15888                                  					; MYSEG2    (dw 0)	
 15889 000041BF 0000                    		dw 0			; RESTEST   (dw 0)	
 15890 000041C1 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15891                                  
 15892 000041C3 00                      CHKDRV:		db 0
 15893                                  IFNOTFLAG:
 15894                                  FILTYP:
 15895 000041C4 00                      RDEOF:		db 0			; Misc flags
 15896 000041C5 00                      CURDRV:		db 0
 15897                                  PARM1:
 15898 000041C6 00                      CONCAT:		db 0
 15899                                  PARM2:
 15900 000041C7 00                      ARGC:		db 0
 15901 000041C8 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15902 000041CA 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15903                                  ARG2S:					; Switches after 2nd arg		
 15904 000041CC 0000                    DESTSWITCH:	dw 0
 15905                                  ARGTS:
 15906 000041CE 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15907 000041D0 00                      CFLAG:		db 0
 15908                                  DESTCLOSED:
 15909 000041D1 00                      SPECDRV:	db 0
 15910 000041D2 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15911 000041D4 0000                    NXTADD:		dw 0
 15912 000041D6 00                      FRSTSRCH:	db 0
 15913                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15914                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15915 000041D7 00                      LINCNT:		db 0
 15916 000041D8 00                      LINLEN:		db 0
 15917                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15918 000041D9 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15919                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15920                                  
 15921                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15922                                  ;
 15923                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15924                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15925                                  
 15926                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15927                                  
 15928 000041DB 00<rep 50h>             CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15929                                  DESTFCB2:
 15930 0000422B 00                      IDLEN:		db 0
 15931 0000422C 00<rep 8h>              ID:	  times	8  db 0
 15932 00004234 00<rep 3h>              COM:	  times	3  db 0 
 15933 00004237 00<rep 25h>             DEST:	  times 37 db 0
 15934 0000425C 00<rep Bh>              DESTNAME: times 11 db 0
 15935                                  DESTDIR:
 15936 00004267 00<rep 43h>             DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15937                                  GOTOLEN:	; word
 15938                                  BWDBUF: 	; byte
 15939                                  EXEFCB: 	; word
 15940 000042AA 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15941                                  
 15942                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15943                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15944                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15945                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15946                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15947                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15948                                  
 15949 000042F0 00<rep Ch>              SDIRBUF:  times 12 db 0	
 15950 000042FC 0000                    _BITS:		dw 0
 15951 000042FE 0000                    PATHCNT:	dw 0
 15952 00004300 0000                    PATHPOS:	dw 0
 15953 00004302 0000                    PATHSW:		dw 0
 15954                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15955                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15956 00004304 00                      LINPERPAG:	db 0
 15957 00004305 00                      		db 0
 15958 00004306 00                      COMMA:		db 0			; flag set if +,, occurs
 15959 00004307 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 15960                                  
 15961                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 15962                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 15963                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 15964                                  
 15965 00004308 00<rep 80h>             ARG_BUF:  times 128 db 0   ; _43E8h	
 15966 00004388 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 15967 0000438A 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 15968 0000438C 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 15969 0000438E 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 15970                                  
 15971 00004390 0000                    COPY_NUM:	dw 0
 15972 00004392 00<rep 4h>              	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 15973 00004396 00                      CPYFLAG:	db 0
 15974 00004397 0000                    DIR_NUM:	dw 0
 15975 00004399 0000                    BYTES_FREE:	dw 0
 15976 0000439B 0000                    		dw 0
 15977 0000439D 0000                    MAJOR_VER_NUM:	dw 0
 15978 0000439F 0000                    MINOR_VER_NUM:	dw 0
 15979 000043A1 00                      ONE_CHAR_VAL:	db 0
 15980                                  		;db 0
 15981 000043A2 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 15982 000043A4 00                      VOL_DRV:	db 0
 15983 000043A5 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 15984                                  
 15985 000043A7 00                      ROM_CALL:	db 0			; flag for rom function
 15986 000043A8 0000                    ROM_IP:		dw 0
 15987 000043AA 0000                    ROM_CS:		dw 0
 15988                                  
 15989                                  DESTVARS:
 15990 000043AC 00                      DESTISDIR:	db 0
 15991 000043AD 00                      DESTSIZ:	db 0
 15992 000043AE 0000                    DESTTAIL:	dw 0
 15993 000043B0 00                      DESTINFO:	db 0
 15994 000043B1 00<rep 57h>             DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 15995                                  ENDDESTBUF:
 15996                                  
 15997 00004408 0000                    DESTHAND:	dw 0
 15998 0000440A 00                      DESTISDEV:	db 0
 15999 0000440B 00                      FIRSTDEST:	db 0
 16000 0000440C 00                      MELCOPY:	db 0
 16001 0000440D 0000                    MELSTART:	dw 0
 16002                                  
 16003                                  SRCVARS:
 16004 0000440F 00                      SRCISDIR:	db 0
 16005 00004410 00                      SRCSIZ:		db 0
 16006 00004411 0000                    SRCTAIL:	dw 0
 16007 00004413 00                      SRCINFO:	db 0
 16008 00004414 00<rep 57h>             SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 16009                                  
 16010 0000446B 0000                    SRCHAND:	dw 0
 16011 0000446D 00                      SRCISDEV:	db 0
 16012                                  
 16013 0000446E 00<rep 57h>             SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 16014                                  
 16015 000044C5 0000                    SRCPT:		dw 0
 16016 000044C7 00                      INEXACT:	db 0
 16017 000044C8 00                      		db 0 ; MSDOS 3.3 
 16018 000044C9 00                      NOWRITE:	db 0
 16019 000044CA 00                      BINARY:		db 0
 16020 000044CB 0000                    WRITTEN:	dw 0
 16021 000044CD 00                      TERMREAD:	db 0
 16022 000044CE 00                      ASCII:		db 0
 16023 000044CF 00                      PLUS:		db 0
 16024 000044D0 00                      OBJCNT:		db 0			; Used in copy
 16025 000044D1 0000                    CPDATE:		dw 0
 16026 000044D3 0000                    CPTIME:		dw 0
 16027                                  
 16028                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 16029                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 16030                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 16031                                  
 16032 000044D5 0000                    BATHAND:	dw 0			; Batch handle
 16033 000044D7 0000                    STARTEL:	dw 0
 16034 000044D9 00                      ELCNT:		db 0
 16035 000044DA 00                      ELPOS:		db 0
 16036 000044DB 00<rep Bh>              SOURCE:   times	11 db 0
 16037                                  
 16038 000044E6 00                      ext_entered:	db 0			;AN005;
 16039                                  
 16040                                  ;display_ioctl	db 0			;AN000; info level
 16041                                  ;		db 0			;AN000; reserved
 16042                                  ;		dw crt_ioctl_ln		;AN000; length of data
 16043                                  ;		dw 0			;AN000; control flags
 16044                                  ;display_mode:	db 0			;AN000; display mode, colors
 16045                                  ;		db 0			;AN000; reserved
 16046                                  ;		dw 0			;AN023; colors
 16047                                  ;		dw 0			;AN000; display width (PELS)
 16048                                  ;		dw 0			;AN000; display length (PELS)
 16049                                  ;display_width:	dw 0			;AN000; display width
 16050                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 16051                                  ;
 16052                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 16053                                  ;		dw 0			;AN000; info level
 16054                                  ;vol_serial:	dd 0			;AN000; volume serial number
 16055                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 16056                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 16057                                  
 16058 000044E7 00                      EXPAND_STAR:	db 0
 16059                                  
 16060                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 16061                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 16062                                  ;append_exec:	db 0			;AN041; set if internal append executed
 16063                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 16064                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 16065                                  
 16066 000044E8 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 16067                                  
 16068                                  ; Data declarations taken out of parse.asm
 16069                                  
 16070                                  ; MSDOS 6.0
 16071                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 16072                                  ;argbufptr	dw	?		; index for argv[].argpointer
 16073                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 16074                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 16075                                  ;comptr		dw	?		; ptr into combuf
 16076                                  
 16077                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 16078                                  ARG:
 16079                                  ARG_ARGV:
 16080 000044E9 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 16081 000044EB 00                      ARGV0_ARG_FLAGS:  db 0
 16082 000044EC 0000                    ARGV0_ARGSTARTEL: dw 0
 16083 000044EE 0000                    ARGV0_ARGLEN:	  dw 0
 16084 000044F0 0000                    ARGV0_ARGSW_WORD: dw 0
 16085 000044F2 0000                    ARGV0_OCOMPTR:	  dw 0
 16086                                  
 16087 000044F4 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 16088 000044F6 00<rep 5h>              	  times 5 db 0
 16089 000044FB 0000                    ARGV1_ARGSW_WORD: dw 0
 16090 000044FD 0000                    		  dw 0
 16091                                  
 16092 000044FF 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 16093 00004501 00<rep 5h>              	  times 5 db 0
 16094 00004506 0000                    ARGV2_ARGSW_WORD: dw 0
 16095 00004508 0000                    		  dw 0
 16096                                  
 16097 0000450A 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 16098                                  	
 16099 000047A9 0000                    ARG_ARGVCNT:	dw 0
 16100 000047AB 0000                    ARG_ARGSWINFO:	dw 0
 16101                                  
 16102 000047AD 0000<rep 100h>          ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 16103 000049AD 00<rep 80h>             ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 16104                                  
 16105                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 16106                                  
 16107 00004A2D 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 16108 00004A2F 00<rep 80h>             TPBUF:    times 128 db 0		; temporary buffer
 16109 00004AAF 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 16110 00004AB1 0000                    COMPTR:		dw 0			; ptr into combuf
 16111                                  
 16112                                  ; Data declarations taken out of path.asm
 16113                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 16114                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 16115                                  ;psep_char	DB	?			; '/' or '\'
 16116                                  ;search_best	DB	(?)			; best code, best filename so far
 16117                                  ;fname_max_len	equ	13
 16118                                  ;search_best_buf DB	fname_max_len DUP (?)
 16119                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 16120                                  ;search_error	DW	(?)			; address of error message to be printed
 16121                                  
 16122                                  FINDBUFLEN equ FIND_BUF.size ; 43
 16123                                  
 16124                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 16125                                  
 16126 00004AB3 00<rep 2Bh>             FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 16127                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 16128                                  PATHINFO:
 16129 00004ADE 0000                    PATHINFO_0:	dw 0
 16130 00004AE0 0000                    PATHINFO_2:	dw 0
 16131 00004AE2 0000                    PATHINFO_4:	dw 0
 16132 00004AE4 00                      PSEP_CHAR:	db 0
 16133 00004AE5 00                      SEARCH_BEST:	db 0
 16134                                  ;FNAME_MAX_LEN equ 13
 16135 00004AE6 00<rep Dh>              SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 16136 00004AF3 00<rep 40h>             SEARCH_CURDIR_BUF: times 64 db 0
 16137 00004B33 0000                    SEARCH_ERROR:	dw 0
 16138                                  
 16139                                  ; Data declarations taken out of tbatch.asm
 16140                                  
 16141                                  ;if_not_count	DW	?
 16142                                  ;
 16143                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 16144                                  ;
 16145                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 16146                                  ;STACK		LABEL	WORD
 16147                                  
 16148                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 16149                                  
 16150 00004B35 0000                    IF_NOT_COUNT:	dw 0
 16151 00004B37 00                      ZFLAG:		db 0
 16152 00004B38 00<rep 100h>            	  times 256 db 0 	
 16153                                  STACK:
 16154                                  
 16155                                  ;INTERNATVARS	internat_block <>
 16156                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 16157                                  ;
 16158                                  ;;		Buffer for DOS function 64h (Get extended country information)
 16159                                  ;;		subfunctions 2, 4, 6, or 7:
 16160                                  ;
 16161                                  ;CountryPtrInfo	label	byte
 16162                                  ;CountryPtrId	db	?
 16163                                  ;CountryPtr	dd	?
 16164                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 16165                                  
 16166                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 16167                                  
 16168                                  INTERNATVARS:	
 16169 00004C38 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 16170 00004C3A 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 16171 00004C3F 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 16172 00004C41 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 16173 00004C43 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 16174 00004C45 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 16175 00004C47 00                      BIT_FIELD:	db 0			; Bit values
 16176                                  					;   Bit 0 = 0 if currency symbol first
 16177                                  					;	  = 1 if currency symbol last
 16178                                  					;   Bit 1 = 0 if No space after currency symbol
 16179                                  					;	  = 1 if space after currency symbol
 16180 00004C48 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16181 00004C49 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16182 00004C4A 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16183                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16184                                  					;  in pieces.
 16185 00004C4E 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16186                                  
 16187 00004C50 00<rep 8h>              		times 8 db 0
 16188                                  ;
 16189                                  ; Max size of the block returned by the INTERNATIONAL call
 16190                                  ;
 16191                                  INTERNAT_BLOCK_SIZE EQU	32
 16192                                  
 16193                                  BATLEN equ 32
 16194                                  	
 16195                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16196                                  
 16197 00004C58 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16198                                  
 16199 00004C5A 00<rep 20h>             BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16200                                  
 16201 00004C7A 0000                    BATBUFEND:	dw 0
 16202                                  
 16203                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16204                                  
 16205                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
