     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 20/03/2023 ((Prev: 20/10/2018))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   309 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   315 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   316 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 ??                      .ISDIR:		RESB	1
   623 00000001 ??                      .SIZ:		RESB	1
   624 00000002 ????                    .TTAIL:		RESW	1
   625 00000004 ??                      .INFO:		RESB	1
   626 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 ??                      .BatType:	RESB	1		; signature
   660 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   691 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   735 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   736 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   737 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   738 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   739 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   740 00000015 ??                      .ATTR:	    resb 1	; attribute found
   741 00000016 ????                    .TIMR:	    resw 1	; time
   742 00000018 ????                    .DATE:	    resw 1	; date
   743 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   744 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   745 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 ??                                      resb 1
   766 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   768 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   782 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 ????                    .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 ??????????              .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 ????                    .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 ????                    .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B ????                    .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D ????                    .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F ??                      .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 ??                      .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 ??                      .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 ????                    .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 ????                                      RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 ????                    .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 ????                      .owner:	resw 1		; owner of arena item
   917 00000003 ????                      .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  ;LODCOM1   equ	0318h	; 13/10/2018
   962                                  LODCOM1    equ	0319h	; 24/02/2023
   963                                  
   964                                  ; EXEC call addresses in resident portion for calling from transient portion
   965                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   966                                  
   967                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   968                                  ;PUTBACKDRV equ 0A21h	; 14/10/2018
   969                                  PUTBACKDRV equ	0A11h	; 03/03/2023
   970                                  
   971                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   972                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   973                                  
   974                                  ; Resident portion stack address  
   975                                  ;RSTACK	   equ	083Ch
   976                                  RSTACK	   equ	082Ch	; 03/03/2023 
   977                                  
   978                                  ;RETRABASE equ  0B86h	; 13/10/2018 (Base addr for following common params.)
   979                                  RETRABASE  equ  0B70h	; 03/03/2023	
   980                                  
   981                                  ; RESGROUP       [RESSEG]
   982                                  ; DATA		  offset
   983                                  ; --------     	------------
   984                                  PARENT	  equ	RETRABASE+6	; 0B76h	; 02/03/2023
   985                                  OLDTERM	  equ	RETRABASE+8	; 0B78h
   986                                  BATCH	  equ	RETRABASE+17	; 0B81h
   987                                  COMSPEC	  equ	RETRABASE+19	; 0B83h
   988                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BC3h
   989                                  COMSPEC_END equ	RETRABASE+85	; 0BC5h
   990                                  IN_BATCH  equ	RETRABASE+92	; 0BCCh
   991                                  BATCH_ABORT equ	RETRABASE+93	; 0BCDh
   992                                  COMDRV	  equ	RETRABASE+94	; 0BCEh
   993                                  EXTCOM	  equ	RETRABASE+99	; 0BD3h
   994                                  RETCODE	  equ	RETRABASE+100	; 0BD4h
   995                                  ECHOFLAG  equ	RETRABASE+103	; 0BD7h
   996                                  SUPPRESS  equ	RETRABASE+104	; 0BD8h
   997                                  IO_SAVE	  equ	RETRABASE+105	; 0BD9h
   998                                  RESTDIR	  equ	RETRABASE+107	; 0BDBh
   999                                  PERMCOM	  equ	RETRABASE+108	; 0BDCh
  1000                                  SINGLECOM equ	RETRABASE+109	; 0BDDh
  1001                                  VERVAL	  equ	RETRABASE+111	; 0BDFh
  1002                                  IFFLAG	  equ	RETRABASE+114	; 0BE2h	
  1003                                  FORFLAG	  equ	RETRABASE+115	; 0BE3h
  1004                                  FORPTR	  equ	RETRABASE+116	; 0BE4h 	
  1005                                  NEST	  equ	RETRABASE+118	; 0BE6h
  1006                                  CALL_FLAG equ	RETRABASE+120	; 0BE8h
  1007                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BE9h
  1008                                  NEXT_BATCH equ	RETRABASE+122 	; 0BEAh
  1009                                  NULLFLAG  equ	RETRABASE+124	; 0BECh
  1010                                  UPPERCASETBL equ RETRABASE+126	; 0BEEh
  1011                                  RE_OUT_APP equ	RETRABASE+130	; 0BF2h
  1012                                  RE_OUTSTR equ	RETRABASE+131	; 0BF3h
  1013                                  INITFLAG  equ	RETRABASE+211	; 0C43h	
  1014                                  PIPEFLAG  equ	RETRABASE+212	; 0C44h
  1015                                  PIPEFILES equ	RETRABASE+213	; 0C45h
  1016                                  PIPE1	  equ	RETRABASE+214	; 0C46h	
  1017                                  PIPE2	  equ	RETRABASE+230	; 0C56h
  1018                                  PIPEPTR	  equ	RETRABASE+246	; 0C66h
  1019                                  PIPESTR	  equ	RETRABASE+248	; 0C68h
  1020                                  INPIPEPTR equ	RETRABASE+377	; 0CE9h
  1021                                  OUTPIPEPTR equ	RETRABASE+379	; 0CEBh
  1022                                  ENVIRSEG  equ	RETRABASE+381	; 0CEDh
  1023                                  EXEC_BLOCK equ	RETRABASE+381 	; 0CEDh  ; ENVIRSEG
  1024                                  LTPA	  equ	RETRABASE+399	; 0CFFh
  1025                                  RES_TPA	  equ	RETRABASE+413	; 0D0Dh
  1026                                  
  1027                                  ;=============================================================================
  1028                                  					
  1029                                  ; (command3.s -> offset TRANGOUP)
  1030                                  
  1031                                  TRANGROUP:
  1032                                  
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; START OF TRANSIENT PORTION
  1035                                  ; ----------------------------------------------------------------------------
  1036                                  ; SEGMENT - TRANSCODE
  1037                                  ; ----------------------------------------------------------------------------
  1038                                  ; 13/10/2018 - Retro DOS v3.0
  1039                                  
  1040                                  ;[BITS 16]
  1041                                  ;[ORG 0]
  1042 00000000 00<rep 100h>            		times 256 db 0
  1043                                  
  1044                                  ;============================================================================
  1045                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1046                                  ;============================================================================
  1047                                  ; 12/10/2018 - Retro DOS v3.0
  1048                                  
  1049                                  ;[ORG 100h]
  1050                                  
  1051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1052                                  
  1053                                  ; ---------------------------------------------------------------------------
  1054                                  
  1055                                  SETDRV:					; Allow for 100H parameter area
  1056 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1057 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1058                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1059                                  				; Return: AL = number of logical drives
  1060                                  
  1061                                  ; ---------------------------------------------------------------------------
  1062                                  
  1063                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1064                                  ; No registers (CS:IP) no flags, nothing.
  1065                                  
  1066                                  TCOMMAND:
  1067 00000104 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  1068 00000109 B8FFFF                  		mov	ax,-1
  1069 0000010C 8706DF0B                		xchg	ax,[VERVAL]
  1070 00000110 83F8FF                  		cmp	ax,-1
  1071 00000113 7404                    		jz	short NOSETVER2
  1072 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1073 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1074                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1075                                  NOSETVER2:
  1076 00000119 2EFF1E[5441]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1077 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1078 00000120 833EDD0BFF              		cmp	word [SINGLECOM],-1
  1079 00000125 7505                    		jnz	short COMMAND
  1080                                  _$EXITPREP:
  1081 00000127 0E                      		push	cs
  1082 00000128 1F                      		pop	ds
  1083 00000129 E9F614                  		jmp	_$EXIT		; Have finished the single command
  1084                                  
  1085                                  ; ---------------------------------------------------------------------------
  1086                                  ;
  1087                                  ; Main entry point from resident portion.
  1088                                  ;
  1089                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1090                                  ;   just beginning the processing of another command.
  1091                                  ;
  1092                                  ; ---------------------------------------------------------------------------
  1093                                  
  1094                                  ; We are not always sure of the state of the world at this time. We presume
  1095                                  ; worst case and initialize the relevant registers: segments and stack.
  1096                                  
  1097                                  COMMAND:
  1098 0000012C FC                      		cld
  1099 0000012D 8CC8                    		mov	ax,cs
  1100 0000012F FA                      		cli
  1101 00000130 8ED0                    		mov	ss,ax
  1102                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1103 00000132 BC[DE4B]                		mov	sp,STACK
  1104 00000135 FB                      		sti
  1105                                  		
  1106 00000136 8EC0                    		MOV	ES,AX
  1107                                  		
  1108                                  		; MSDOS 6.0
  1109                                  		;MOV	DS,AX		;AN000; set DS to transient
  1110                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1111                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1112                                  		;mov	append_exec,0	;AN041; set internal append state off
  1113                                  
  1114                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1115 00000138 368E1E[5641]            		mov	ds,[ss:RESSEG]
  1116 0000013D 36C606[323F]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1117 00000143 36C606[B53F]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1118                                  
  1119                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1120                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1121                                  ; I guess not:  the only circumstances in which we reload the command processor
  1122                                  ; is after a transient program execution. In this case, we let the current
  1123                                  ; directory lie where it may.
  1124                                  
  1125 00000149 09ED                    		or	bp,bp		; See if just read
  1126 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1127 0000014D 36C706[333F]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1128 00000154 EB17                    		jmp	short NOSETBUF
  1129                                  TESTRDIR:
  1130 00000156 803EDB0B00              		cmp	byte [RESTDIR],0
  1131 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1132 0000015D 1E                      		push	ds
  1133                                  
  1134                                  ; We have an unusual situation to handle. The user *may* have changed his
  1135                                  ; directory as a result of an internal command that got aborted. Restoring it
  1136                                  ; twice may not help us: the problem may never go away. We just attempt it
  1137                                  ; once and give up.
  1138                                  
  1139 0000015E C606DB0B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1140                                  
  1141                                  		; Restore users directory
  1142 00000163 0E                      		push	cs
  1143 00000164 1F                      		pop	ds
  1144 00000165 BA[3840]                		mov	dx,USERDIR1
  1145 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1146 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1147                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1148 0000016C 1F                      		pop	ds
  1149                                  NOSETBUF:
  1150 0000016D 803E450C00              		cmp	byte [PIPEFILES],0
  1151 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1152 00000174 803E440C00              		cmp	byte [PIPEFLAG],0
  1153 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1154 0000017B E8431D                  		call	PIPEDEL
  1155                                  NOPCLOSE:
  1156                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1157 0000017E C606D30B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1158 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1159 00000185 8ED8                    		mov	ds,ax
  1160 00000187 50                      		push	ax
  1161 00000188 BA[DE4B]                		mov	dx,INTERNATVARS
  1162 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1163 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1164                                  				; get current-country info
  1165                                  				; DS:DX	-> buffer for returned info
  1166 00000190 58                      		pop	ax
  1167 00000191 2B06[5841]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1168 00000195 53                      		push	bx
  1169 00000196 BB1000                  		mov	bx,16
  1170 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1171 0000019B 5B                      		pop	bx
  1172 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1173 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1174 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1175                                  SAVSIZ:
  1176                                  
  1177                                  ; AX is the number of bytes free in the buffer between the resident and the
  1178                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1179                                  
  1180 000001A3 3D0002                  		cmp	ax,512
  1181 000001A6 7603                    		jbe	short GOTSIZE
  1182                                  		;and	ax,~1FFh
  1183 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1184                                  GOTSIZE:
  1185 000001AB A3[7741]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1186 000001AE 8E1E[5641]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1187                                  
  1188 000001B2 F606D70B01              		test	byte [ECHOFLAG],1 
  1189 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1190 000001B9 E8E41C                  		call	SINGLETEST
  1191 000001BC 7219                    		jb	short GETCOM
  1192 000001BE F606440CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1193 000001C3 7512                    		jnz	short GETCOM
  1194                                  					; G  Don't print prompt in FOR
  1195 000001C5 F606E30BFF              		test	byte [FORFLAG],0FFh ; -1
  1196 000001CA 750B                    		jnz	short GETCOM
  1197                                  					; G  Don't print prompt if in batch
  1198 000001CC F706810BFFFF            		test	word [BATCH],0FFFFh ; -1
  1199 000001D2 7503                    		jnz	short GETCOM
  1200 000001D4 E85E17                  		call	CRLF2
  1201                                  GETCOM:
  1202 000001D7 C606E80B00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1203 000001DC C606E90B00              		mov	byte [CALL_BATCH_FLAG],0
  1204 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1205 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1206 000001E5 36A2[6A41]              		mov	[ss:CURDRV],al
  1207 000001E9 F606440CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1208 000001EE 7403                    		jz	short NOPIPE
  1209 000001F0 E96D1D                  		jmp	PIPEPROC	; Continue the pipeline
  1210                                  NOPIPE:
  1211 000001F3 F606D70B01              		test	byte [ECHOFLAG],1
  1212 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1213 000001FA E8A31C                  		call	SINGLETEST
  1214 000001FD 7212                    		jb	short NOPDRV
  1215 000001FF F606E30BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1216 00000204 750B                    		jnz	short NOPDRV
  1217 00000206 F706810BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1218 0000020C 750D                    		jnz	short TESTFORBAT
  1219 0000020E E85911                  		call	PRINT_PROMPT	; Prompt the user
  1220                                  NOPDRV:
  1221 00000211 F606E30BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1222 00000216 7403                    		jz	short TESTFORBAT
  1223 00000218 E9F509                  		jmp	FORPROC		; Continue the FOR
  1224                                  
  1225                                  TESTFORBAT:
  1226 0000021B 36C606[0141]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1227 00000221 C606F30B00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1228 00000226 C606F20B00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1229 0000022B C606E20B00              		mov	byte [IFFLAG],0	; no more ifs...
  1230 00000230 F706810BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1231 00000236 7429                    		jz	short ISNOBAT
  1232                                  
  1233                                  		; MSDOS 6.0
  1234                                  
  1235                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1236                                  
  1237                                  		;push	es			;AN000; save ES
  1238                                  		;push	ds			;AN000; save DS
  1239                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1240                                  		;mov	es,[batch]		;AN000; get batch segment
  1241                                  		;mov	di,batfile		;AN000; get batch file name
  1242                                  		;push	cs			;AN000; get local segment to DS
  1243                                  		;pop	ds			;AN000;
  1244                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1245                                  		;int	2fh			;AN000; call the shell
  1246                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1247                                  		;pop	ds			;AN000; restore DS
  1248                                  		;pop	es			;AN000; restore ES
  1249                                  		;jz	jdocom1 		;AN000; yes - go process command
  1250                                  
  1251                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1252 00000238 1E                      		push	ds
  1253 00000239 E8BB02                  		call	READBAT			; Continue BATCH
  1254 0000023C 1F                      		pop	ds
  1255 0000023D C606EC0B00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1256 00000242 F706810BFFFF            		test	word [BATCH],0FFFFh
  1257 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1258 0000024A 8B1EEA0B                		mov	bx,[NEXT_BATCH]
  1259 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1260 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1261 00000253 891E810B                		mov	[BATCH],bx		;G get segment of next batch file
  1262 00000257 C706EA0B0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1263                                  JDOCOM1:
  1264 0000025D 0E                      		push	cs
  1265 0000025E 1F                      		pop	ds
  1266 0000025F EB4C                    		jmp	short DOCOM1
  1267                                  
  1268 00000261 833EDD0B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1269 00000266 741C                    		jz	short REGCOM
  1270                                  		;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  1271 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1272 0000026B 8736DD0B                		xchg	si,[SINGLECOM]
  1273 0000026F BF[B73F]                		mov	di,COMBUF+2
  1274 00000272 31C9                    		xor	cx,cx
  1275                                  SINGLELOOP:
  1276 00000274 AC                      		lodsb
  1277 00000275 AA                      		stosb
  1278 00000276 41                      		inc	cx
  1279 00000277 3C0D                    		cmp	al,0Dh
  1280 00000279 75F9                    		jnz	short SINGLELOOP
  1281 0000027B 49                      		dec	cx
  1282 0000027C 0E                      		push	cs
  1283 0000027D 1F                      		pop	ds
  1284 0000027E 880E[B63F]              		mov	[COMBUF+1],cl
  1285                                  
  1286                                  ; do NOT issue a trailing CRLF...
  1287                                  
  1288 00000282 EB29                    		jmp	short DOCOM1
  1289                                  
  1290                                  		;nop
  1291                                  
  1292                                  ; We have a normal command.  
  1293                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1294                                  ; sometimes they aren't. At this point, we automatically close all spool
  1295                                  ; files and turn on truncation mode.
  1296                                  
  1297                                  REGCOM:
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1299                                  		;mov	ax,5D09h
  1300 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1301 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1302                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1303                                  		;mov	ax,5D08h
  1304 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1305 0000028C B201                    		mov	dl,1
  1306 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1307                                  				; DL = 00h redirected output is	combined
  1308                                  				;      01h redirected output placed in separate	jobs
  1309                                  				; start	new print job now
  1310 00000290 0E                      		push	cs
  1311 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1312 00000292 BA[323F]                		mov	dx,UCOMBUF
  1313                                  
  1314                                  		; MSDOS 6.0
  1315                                  ;	Try to read interactive command line via DOSKey.
  1316                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1317                                  
  1318                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1319                                  		;int	2fh
  1320                                  		;or	ax,ax
  1321                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1322                                  
  1323                                  		;mov	ah,0Ah
  1324 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1325 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1326                                  				; DS:DX	-> buffer
  1327                                  ;GOTCOM:
  1328 00000299 8A0E[323F]              		mov	cl,[UCOMBUF]
  1329 0000029D 30ED                    		xor	ch,ch
  1330 0000029F 83C103                  		add	cx,3
  1331 000002A2 BE[323F]                		mov	si,UCOMBUF
  1332 000002A5 BF[B53F]                		mov	di,COMBUF
  1333 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1334                                  DOCOM:
  1335 000002AA E88816                  		call	CRLF2
  1336                                  DOCOM1:
  1337 000002AD E83C19                  		call	PRESCAN		; Cook the input buffer
  1338 000002B0 7406                    		jz	short NOPIPEPROC
  1339 000002B2 E9561C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1340                                  NULLCOMJ:
  1341 000002B5 E9F900                  		jmp	NULLCOM
  1342                                  NOPIPEPROC:
  1343 000002B8 E86920                  		call	PARSELINE
  1344 000002BB 730B                    		jnb	short OKPARSE	; user error? or maybe we goofed?
  1345                                  BADPARSE:
  1346 000002BD 0E                      		push	cs
  1347 000002BE 1F                      		pop	ds
  1348 000002BF BA[CB36]                		mov	dx,BADNAMPTR
  1349 000002C2 E84631                  		call	STD_EPRINTF
  1350 000002C5 E93CFE                  		jmp	TCOMMAND
  1351                                  OKPARSE:
  1352                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1353 000002C8 F606[9044]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1354 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1355                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1356 000002CF 833E[4E47]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1357 000002D4 74DF                    		jz	short NULLCOMJ
  1358                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1359 000002D6 833E[9344]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1360 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1361                                  
  1362 000002DD BE[B73F]                		mov	si,COMBUF+2
  1363 000002E0 BF[D041]                		mov	di,IDLEN
  1364                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1365                                  					; Make FCB with blank scan-off
  1366 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1367                                  		;mov	ax,2901h
  1368 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1369                                  				; DS:SI	-> string to parse
  1370                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1371                                  				; AL = bit mask	to control parsing
  1372                                  		;mov	bx,[ARG_ARGV]
  1373 000002E8 8B1E[8E44]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1374 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1375 000002F0 751B                    		jne	short DRVGD	; no, use default of zero...
  1376 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1377                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1378                                  		;and	dl,~20h
  1379 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1380                                  		;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1381                                  		; 01/03/2023
  1382 000002F7 80EA41                  		sub	dl,capital_A  ; sub dl,'A'
  1383 000002FA 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1384 000002FC 740C                    		jz	short DRVBADJ	; It was invalid.
  1385                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1386 000002FE 8B3E[9144]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1387 00000302 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1388 00000305 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1389 00000307 E9F6FD                  		jmp	SETDRV		; and set drive to new drive spec
  1390                                  DRVBADJ:
  1391 0000030A E99217                  		jmp	DRVBAD
  1392                                  DRVGD:
  1393 0000030D 8A05                    		mov	al,[di]
  1394 0000030F A2[7641]                		mov	[SPECDRV],al
  1395 00000312 B020                    		mov	al,' '
  1396 00000314 B90900                  		mov	cx,9
  1397 00000317 47                      		inc	di
  1398 00000318 F2AE                    		repne scasb		; Count number of letters in command name
  1399 0000031A B008                    		mov	al,8
  1400 0000031C 28C8                    		sub	al,cl
  1401 0000031E A2[D041]                		mov	[IDLEN],al	; IDLEN is truly the length
  1402 00000321 BF8100                  		mov	di,81h
  1403 00000324 56                      		push	si
  1404 00000325 BE[B73F]                		mov	si,COMBUF+2	; Skip over all leading delims
  1405 00000328 E81716                  		call	SCANOFF
  1406                                  
  1407                                  		; MSDOS 6.0
  1408                                  ;SR;
  1409                                  ; We are going to skip over the first char always. The logic is that the
  1410                                  ;command tail can never start from the first character. The code below is 
  1411                                  ;trying to figure out the command tail and copy it to the command line 
  1412                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1413                                  ;character and the user given command line is a full 128 bytes, we try to
  1414                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1415                                  ;char overwrites the code and leads to a crash on future commands.
  1416                                  ;
  1417                                  		;inc	si ;  MSDOS 6.0
  1418                                  DO_SKIPCOM:
  1419 0000032B AC                      		lodsb			; move command line pointer over
  1420 0000032C E81B16                  		call	DELIM		; pathname -- have to do it ourselves
  1421 0000032F 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1422 00000331 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1423 00000333 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1424 00000335 3A06[5A41]              		cmp	al,[SWITCHAR]	; specified command string
  1425 00000339 75F0                    		jnz	short DO_SKIPCOM 
  1426                                  DO_SKIPPED:
  1427 0000033B 4E                      		dec	si
  1428 0000033C 31C9                    		xor	cx,cx
  1429                                  COMTAIL:
  1430 0000033E AC                      		lodsb
  1431 0000033F AA                      		stosb			; Move command tail to 80h
  1432 00000340 3C0D                    		cmp	al,0Dh
  1433 00000342 E0FA                    		loopne	COMTAIL
  1434 00000344 4F                      		dec	di
  1435 00000345 89FD                    		mov	bp,di
  1436 00000347 F6D1                    		not	cl
  1437 00000349 880E8000                		mov	[80h],cl
  1438 0000034D 5E                      		pop	si
  1439                                  ;-----
  1440                                  ; Some of these comments are sadly at odds with this brave new code.
  1441                                  ;-----
  1442                                  ; If the command has 0 parameters must check here for
  1443                                  ; any switches that might be present.
  1444                                  ; SI -> first character after the command.
  1445                                  
  1446                                  		;mov	di, arg.argv[0].argsw_word
  1447                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1448 0000034E 8B3E[9544]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1449 00000352 893E[6D41]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1450                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1451                                  					; s = argv[1];
  1452                                  		;mov	si,[ARGV1_ARGPOINTER]
  1453 00000356 8B36[9944]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1454 0000035A 09F6                    		or	si,si		;   if (s == NULL)
  1455 0000035C 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1456 0000035E 89EE                    		mov	si,bp
  1457                                  DOPARSE:
  1458 00000360 BF5C00                  		mov	di,FCB ; 5Ch
  1459                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1460                                  		;mov	ax,2901h
  1461 00000363 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1462 00000366 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1463                                  				; DS:SI	-> string to parse
  1464                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1465                                  				; AL = bit mask	to control parsing
  1466 00000368 A2[6B41]                		mov	[PARM1],al	; Save result of parse
  1467                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1468                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1469 0000036B 8B3E[A044]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1470 0000036F 893E[6F41]              		mov	[ARG1S],di
  1471                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1472                                  					; s = argv[2];
  1473                                  		;mov	si,[ARGV2_ARGPOINTER]
  1474 00000373 8B36[A444]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1475 00000377 09F6                    		or	si,si		;   if (s == NULL)
  1476 00000379 7502                    		jnz	short DOPARSE2
  1477 0000037B 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1478                                  DOPARSE2:			
  1479 0000037D BF6C00                  		mov	di,FCB+10H ; 6Ch
  1480                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1481                                  		;mov	ax,2901h
  1482 00000380 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1483 00000383 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1484                                  				; DS:SI	-> string to parse
  1485                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1486                                  				; AL = bit mask	to control parsing
  1487 00000385 A2[6C41]                		mov	[PARM2],al	; Save result
  1488                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1489                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1490 00000388 8B3E[AB44]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1491 0000038C 893E[7141]              		mov	[ARG2S],di
  1492                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1493                                  		;mov	di,arg.argv[0].argsw_word
  1494 00000390 8B3E[9544]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1495 00000394 F7D7                    		not	di		; ARGTS doesn't include the flags
  1496                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1497                                  		;and	di,arg.argswinfo	
  1498 00000396 233E[5047]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1499 0000039A 893E[7341]              		mov	[ARGTS],di
  1500                                  
  1501 0000039E A0[D041]                		mov	al,[IDLEN]
  1502 000003A1 8A16[7641]              		mov	dl,[SPECDRV]
  1503 000003A5 08D2                    		or	dl,dl		; if a drive was specified...
  1504 000003A7 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1505 000003A9 FEC8                    		dec	al		; (I don't know why -- old code did it)
  1506 000003AB E9FA16                  		jmp	FNDCOM		; otherwise, check internal com table
  1507                                  EXTERNALJ1:
  1508 000003AE E9A417                  		jmp	EXTERNAL
  1509                                  NULLCOM:
  1510 000003B1 8E1E[5641]              		mov	ds,[RESSEG]
  1511 000003B5 F706810BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1512 000003BB 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1513                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1514 000003BD C606EC0B01              		mov	byte [NULLFLAG],nullcommand ; 1
  1515                                  NOSETFLAG:
  1516 000003C2 833EDD0BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1517 000003C7 7403                    		jz	short EXITJ
  1518 000003C9 E90BFE                  		jmp	GETCOM
  1519                                  EXITJ:
  1520 000003CC E958FD                  		jmp	_$EXITPREP
  1521                                  
  1522                                  ;============================================================================
  1523                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1524                                  ;============================================================================
  1525                                  ; 12/10/2018 - Retro DOS v3.0
  1526                                  
  1527                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1528                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1529                                  ;   there is a header that describes a block of rom program.  This header
  1530                                  ;   contains information needed to initialize a module and to provide PCDOS
  1531                                  ;   with a set of reserved names for execution.
  1532                                  ;
  1533                                  ;   This header has the following format:
  1534                                  ;
  1535                                  ;   rom_header	STRUC
  1536                                  ;	Signature1  DB	55h
  1537                                  ;	Signature2  DB	AAh
  1538                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1539                                  ;	init_jmp    DB	3 dup (?)
  1540                                  ;	name_list   name_struc <>
  1541                                  ;   rom_header	ENDS
  1542                                  ;
  1543                                  ;   name_struc	STRUC
  1544                                  ;	name_len    DB	?
  1545                                  ;	name_text   DB	? DUP (?)
  1546                                  ;	name_jmp    DB	3 DUP (?)
  1547                                  ;   name_struc	ENDS
  1548                                  ;
  1549                                  ;   The name list is a list of names that are reserved by a particular section
  1550                                  ;   of a module.  This list of names is terminated by a null name (length
  1551                                  ;   is zero).
  1552                                  ;
  1553                                  ;   Consider now, the PCDOS action when a user enters a command:
  1554                                  ;
  1555                                  ;	COMMAND.COM has control.
  1556                                  ;	o   If location FFFFEh has FDh then
  1557                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1558                                  ;		    by AAh, stop scan if we get above or = F0000H
  1559                                  ;	o	When we've found one, compare the name entered by the user
  1560                                  ;		    with the one found in the rom.  If we have a match, then
  1561                                  ;		    set up the environment for execution and do a long jump
  1562                                  ;		    to the near jump after the found name.
  1563                                  ;	o	If no more names in the list, then continue scanning the module
  1564                                  ;		    for more 55h followed by AAh.
  1565                                  ;	o   We get to this point only if there is no matching name in the
  1566                                  ;		rom.  We now look on disk for the command.
  1567                                  ;
  1568                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1569                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1570                                  ;   want to be invisible to the DOS should not have any names in their lists
  1571                                  ;   (i.e. they have a single null name).
  1572                                  ;
  1573                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1574                                  ;   Clearly this version will be available on disk.  How does a user actually
  1575                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1576                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1577                                  ;   solution:
  1578                                  ;
  1579                                  ;   o	Keep things consistent and force the user to have his software named
  1580                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1581                                  
  1582                                  struc ROM_HEADER
  1583 00000000 ??                          .signature1: resb 1
  1584 00000001 ??                          .signature2: resb 1
  1585 00000002 ??                          .rom_length: resb 1
  1586 00000003 ??????                      .init_jmp:	 resb 3
  1587 00000006 ??                          .name_list:	 resb 1
  1588                                      .size:
  1589                                  endstruc
  1590                                  
  1591                                  struc NAME_STRUC
  1592 00000000 ??                          .name_len:	resb 1
  1593 00000001 ??                          .name_text:	resb 1
  1594 00000002 ??????                      .name_jmp:	resb 3
  1595                                      .size:	
  1596                                  endstruc
  1597                                  
  1598                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1599                                  
  1600                                  ; =============== S U B	R O U T	I N E =======================================
  1601                                  
  1602                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1603                                  
  1604                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1605                                  
  1606                                  ROM_SCAN:
  1607 000003CF 06                      		push	es
  1608 000003D0 56                      		push	si
  1609 000003D1 57                      		push	di
  1610 000003D2 51                      		push	cx
  1611 000003D3 50                      		push	ax
  1612 000003D4 53                      		push	bx
  1613                                  
  1614                                  		; check for PC Jr signature in rom
  1615                                  
  1616 000003D5 B800F0                  		mov	ax,0F000h
  1617 000003D8 8EC0                    		mov	es,ax
  1618 000003DA 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1619 000003E0 7408                    		je	short SCAN_IT
  1620                                  NO_ROM:
  1621 000003E2 F8                      		clc
  1622                                  ROM_RET:
  1623 000003E3 5B                      		pop	bx
  1624 000003E4 58                      		pop	ax
  1625 000003E5 59                      		pop	cx
  1626 000003E6 5F                      		pop	di
  1627 000003E7 5E                      		pop	si
  1628 000003E8 07                      		pop	es
  1629 000003E9 C3                      		retn
  1630                                  
  1631                                  SCAN_IT:	; start scanning at C000h
  1632                                  
  1633 000003EA B800C0                  		mov	ax,0C000h
  1634                                  SCAN_ONE:
  1635 000003ED 8EC0                    		mov	es,ax
  1636 000003EF 31FF                    		xor	di,di
  1637                                  
  1638                                  SCAN_MODULE:	; check for a valid header
  1639                                  
  1640 000003F1 26813D55AA              		cmp	word [es:di],0AA55h
  1641 000003F6 740A                    		jz	short SCAN_LIST
  1642 000003F8 058000                  		add	ax,80h
  1643                                  SCAN_END:
  1644 000003FB 3D00F0                  		cmp	ax,0F000h
  1645 000003FE 72ED                    		jb	short SCAN_ONE
  1646 00000400 EBE0                    		jmp	short NO_ROM
  1647                                  
  1648                                  		; trundle down list of names
  1649                                  SCAN_LIST:
  1650                                  		;mov	bl,[es:di+2]
  1651                                  					; number of 512-byte jobbers
  1652 00000402 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1653 00000406 30FF                    		xor	bh,bh		; nothing in the high byte
  1654 00000408 D1E3                    		shl	bx,1
  1655 0000040A D1E3                    		shl	bx,1		; number of paragraphs
  1656 0000040C 83C37F                  		add	bx,7Fh
  1657 0000040F 83E380                  		and	bx,0FF80h	; round to 2k	
  1658                                  		;mov	di,6
  1659 00000412 BF0200                  		mov	di,ROM_HEADER.rom_length
  1660                                  
  1661                                  		;nop
  1662                                  SCAN_NAME:
  1663 00000415 268A0D                  		mov	cl,[es:di]	; length of name
  1664 00000418 47                      		inc	di		; point to name
  1665 00000419 30ED                    		xor	ch,ch
  1666 0000041B 09C9                    		or	cx,cx		; zero length name
  1667 0000041D 7504                    		jnz	short SCAN_TEST	; nope... compare
  1668 0000041F 01D8                    		add	ax,bx		; yep, skip to next block
  1669 00000421 EBD8                    		jmp	short SCAN_END
  1670                                  
  1671                                  SCAN_TEST:	; compare a single name
  1672                                  
  1673 00000423 89D6                    		mov	si,dx
  1674 00000425 46                      		inc	si
  1675 00000426 F3A6                    		repe cmpsb		 ; compare name
  1676 00000428 7407                    		jz	short SCAN_FOUND ; success!
  1677                                  SCAN_NEXT:
  1678 0000042A 01CF                    		add	di,cx		; failure, next name piece
  1679 0000042C 83C703                  		add	di,3
  1680 0000042F EBE4                    		jmp	short SCAN_NAME
  1681                                  
  1682                                  SCAN_FOUND:	; found a name. save entry location
  1683                                  
  1684 00000431 803C3F                  		cmp	byte [si],'?'
  1685 00000434 7405                    		jz	short SCAN_SAVE
  1686 00000436 803C20                  		cmp	byte [si],' '
  1687 00000439 75EF                    		jnz	short SCAN_NEXT
  1688                                  SCAN_SAVE:
  1689 0000043B 2E8C06[4F43]            		mov	[cs:ROM_CS],es
  1690 00000440 2E893E[4D43]            		mov	[cs:ROM_IP],di
  1691 00000445 F9                      		stc
  1692 00000446 EB9B                    		jmp	short ROM_RET
  1693                                  
  1694                                  ; ---------------------------------------------------------------------------
  1695                                  
  1696                                  ; execute a rom-placed body of code. allocate largest block
  1697                                  
  1698                                  ROM_EXEC:
  1699 00000448 BBFFFF                  		mov	bx,0FFFFh
  1700 0000044B B448                    		mov	ah,ALLOC ; 48h
  1701 0000044D CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1702                                  				; BX = number of 16-byte paragraphs desired
  1703 0000044F B448                    		mov	ah,ALLOC ; 48h
  1704 00000451 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1705                                  				; BX = number of 16-byte paragraphs desired
  1706 00000453 53                      		push	bx
  1707 00000454 50                      		push	ax
  1708                                  
  1709                                  		; set terminate addresses
  1710                                  
  1711                                  		;mov	ax,2522h
  1712                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1713 00000455 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1714 00000458 1E                      		push	ds
  1715 00000459 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  1716                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1717                                  		;mov	dx,131h ; MSDOS 3.3
  1718 0000045E BA3101                  		mov	dx,EXEC_WAIT
  1719 00000461 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1720                                  				; AL = interrupt number
  1721                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1722 00000463 8CDA                    		mov	dx,ds
  1723 00000465 8EC2                    		mov	es,dx
  1724 00000467 1F                      		pop	ds
  1725                                  		
  1726                                  		; and create program header and dup all jfn's
  1727                                  
  1728 00000468 5A                      		pop	dx
  1729 00000469 B455                    		mov	ah,DUP_PDB ; 55h
  1730 0000046B CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1731                                  				; DX = segment number at which to set up PSP
  1732                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1733                                  		
  1734                                  		; set up dma address
  1735                                  
  1736 0000046D 8EDA                    		mov	ds,dx
  1737 0000046F BA8000                  		mov	dx,80h
  1738 00000472 B41A                    		mov	ah,SET_DMA ; 1Ah
  1739 00000474 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1740                                  				; DS:DX	-> disk	transfer buffer
  1741                                  
  1742                                  		; copy in environment info
  1743                                  
  1744 00000476 26A1ED0C                		mov	ax,[es:ENVIRSEG]
  1745 0000047A A32C00                  		mov	[PDB.ENVIRON],	ax
  1746                                  
  1747                                  		; set up correct size of block
  1748                                  
  1749 0000047D 5B                      		pop	bx		; BX has size, DS has segment
  1750 0000047E 8CDA                    		mov	dx,ds
  1751 00000480 01DA                    		add	dx,bx
  1752                                  		;mov	[2],dx
  1753 00000482 89160200                		mov	[PDB.BLOCK_LEN],dx
  1754                                  
  1755                                  		; change ownership of block
  1756                                  
  1757 00000486 8CDA                    		mov	dx,ds
  1758 00000488 4A                      		dec	dx
  1759 00000489 8EDA                    		mov	ds,dx
  1760 0000048B 42                      		inc	dx	
  1761                                  		;mov	[1],dx
  1762 0000048C 89160100                		mov	[ARENA.owner],dx
  1763 00000490 8EDA                    		mov	ds,dx
  1764                                  
  1765                                  		; set up correct stack
  1766                                  
  1767 00000492 81FB0010                		cmp	bx,1000h
  1768 00000496 7202                    		jb	short GOT_STACK
  1769 00000498 31DB                    		xor	bx,bx
  1770                                  GOT_STACK:
  1771 0000049A B104                    		mov	cl,4
  1772 0000049C D3E3                    		shl	bx,cl
  1773 0000049E 8CDA                    		mov	dx,ds
  1774 000004A0 8ED2                    		mov	ss,dx
  1775 000004A2 89DC                    		mov	sp,bx
  1776 000004A4 31C0                    		xor	ax,ax
  1777 000004A6 50                      		push	ax
  1778                                  
  1779                                  		; set up initial registers and go to the guy
  1780                                  
  1781 000004A7 F7D0                    		not	ax
  1782 000004A9 2EFF36[4F43]            		push	word [cs:ROM_CS]
  1783 000004AE 2EFF36[4D43]            		push	word [cs:ROM_IP]
  1784 000004B3 8EC2                    		mov	es,dx
  1785 000004B5 CB                      		retf	; far return
  1786                                  
  1787                                  ;============================================================================
  1788                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1789                                  ;============================================================================
  1790                                  ; 12/10/2018 - Retro DOS v3.0
  1791                                  
  1792                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1793                                  
  1794                                  ; =============== S U B	R O U T	I N E =======================================
  1795                                  
  1796                                  ;Break	<PromptBat - Open or wait for batch file>
  1797                                  
  1798                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1799                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1800                                  ; file. Leave segment registers alone.
  1801                                  
  1802                                  PROMPTBAT:
  1803 000004B6 E8E706                  		call	BATOPEN
  1804 000004B9 7201                    		jc	short PROMPTBAT1
  1805 000004BB C3                      		retn
  1806                                  PROMPTBAT1:
  1807                                  		; MSDOS 6.0 COMMAND.COM
  1808                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1809                                  		;jz	Bat_Remcheck		;AN022;
  1810                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1811                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1812                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1813                                  		;jmp	short BatDie		;AN022;
  1814                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1815                                  		;call	[RCH_ADDR]		; DX has error number
  1816                                  		;jz	AskForBat		; Media is removable
  1817                                  
  1818                                  		; MSDOS 3.3 COMMAND.COM
  1819 000004BC 81FA[2D37]              		cmp	dx,ACCDENPTR
  1820 000004C0 7413                    		jz	short BATDIE
  1821                                  
  1822                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1823                                  BAT_REMCHECK:				; Go see if media is removable
  1824 000004C2 2EFF1E[6041]            		call	far [cs:RCH_ADDR] ; DX has error number
  1825 000004C7 7417                    		jz	short ASKFORBAT	; Media is removable
  1826                                  
  1827                                  ; The media is not changeable. Turn everything off.
  1828                                  
  1829 000004C9 E8B509                  		call	FOROFF
  1830 000004CC E83D1E                  		call	PIPEOFF
  1831 000004CF A2E20B                  		mov	[IFFLAG],al	; No If in progress.	
  1832 000004D2 BA[6E36]                		mov	dx,BADPATHPTR
  1833                                  BATDIE:
  1834 000004D5 E84903                  		call	BATCHOFF
  1835 000004D8 0E                      		push	cs
  1836 000004D9 1F                      		pop	ds
  1837                                  		;invoke	std_eprintf	;AC022; display message ; MSDOS 6.0
  1838 000004DA E8372F                  		call	STD_PRINTF	; MSDOS 3.3
  1839                                  
  1840                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1841                                  
  1842 000004DD E924FC                  		jmp	TCOMMAND
  1843                                  
  1844                                  ; Ask the user to reinsert the batch file
  1845                                  
  1846                                  ASKFORBAT:
  1847 000004E0 1E                      		push	ds
  1848 000004E1 0E                      		push	cs
  1849 000004E2 1F                      		pop	ds
  1850                                  
  1851                                  		; MSDOS 6.0
  1852                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1853                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1854                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1855                                  		;;invoke std_eprintf		;AN000; get second part of message
  1856                                  						;AN000; print it to stderr
  1857                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1858 000004E3 E8252F                  		call	STD_EPRINTF
  1859 000004E6 E80300                  		call	GETKEYSTROKE
  1860 000004E9 1F                      		pop	ds
  1861 000004EA EBCA                    		jmp	short PROMPTBAT
  1862                                  
  1863                                  ; MSDOS 6.0
  1864                                  ;****************************************************************
  1865                                  ;*
  1866                                  ;* ROUTINE:	Output_batch_name
  1867                                  ;*
  1868                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1869                                  ;*
  1870                                  ;* INPUT:	DX - extended error number
  1871                                  ;*
  1872                                  ;* OUTPUT:	Ready to call print routine
  1873                                  ;*
  1874                                  ;****************************************************************
  1875                                  ;
  1876                                  ;public	output_batch_name			;AN022;
  1877                                  ;
  1878                                  ;Output_batch_name    proc near			;AN022;
  1879                                  ;
  1880                                  ;		push	ds			;AN022; save resident segment
  1881                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1882                                  ;	assume	DS:nothing			;AN022;
  1883                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1884                                  ;		invoke	dstrlen 		;AN022; get length of string
  1885                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1886                                  ;		rep	movsb			;AN022; move the name
  1887                                  ;
  1888                                  ;		push	cs			;AN022; get local segment
  1889                                  ;		pop	ds			;AN022;
  1890                                  ;	assume	DS:trangroup			;AN022;
  1891                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1892                                  ;		mov	msg_disp_class,ext_msg_class
  1893                                  ;						;AN022; set up extended error msg class
  1894                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1895                                  ;						;AN022; get extended message pointer
  1896                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1897                                  ;						;AN022; point to substitution
  1898                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1899                                  ;		pop	ds			;AN022; restore data segment
  1900                                  ;
  1901                                  ;		ret				;AN022; return
  1902                                  ;
  1903                                  ;Output_batch_name    endp			;AN022;
  1904                                  
  1905                                  
  1906                                  ; =============== S U B	R O U T	I N E =======================================
  1907                                  
  1908                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1909                                  
  1910                                  ; Read the next keystroke. Since there may be several characters in the queue
  1911                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1912                                  ; AFTER waiting.
  1913                                  
  1914                                  GETKEYSTROKE:
  1915                                  		; MSDOS 3.3
  1916                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1917                                  		;mov	ax,0C08h
  1918 000004EC B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1919 000004EF CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1920                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1921                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1922                                  		;mov	ax,0C00h
  1923 000004F1 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1924 000004F4 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1925                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1926 000004F6 C3                      		retn
  1927                                  
  1928                                  		; MSDOS 6.0
  1929                                  		;PUSH	DX				;AN000;  3/3/KK
  1930                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1931                                  		;INT	21h				;AN000;  3/3/KK
  1932                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1933                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1934                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1935                                  		;INT	21h				;AN000;  3/3/KK
  1936                                  		;
  1937                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1938                                  		;INT	21h		; Get character with KB buffer flush
  1939                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1940                                  		;INT	21h
  1941                                  		;
  1942                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1943                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1944                                  		;INT	21h				;AN000;  3/3/KK
  1945                                  		;POP	DX				;AN000;  3/3/KK
  1946                                  		;
  1947                                  		;return
  1948                                  
  1949                                  ; =============== S U B	R O U T	I N E =======================================
  1950                                  
  1951                                  ; Break	<ReadBat - read 1 line from batch file>
  1952                                  
  1953                                  ; ReadBat - read a single line from the batch file. 
  1954                                  ; Perform all substitutions as appropriate.
  1955                                  
  1956                                  READBAT:
  1957                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1958                                  		
  1959                                  		;mov	byte [SUPPRESS],1
  1960                                  					; initialize line suppress status
  1961 000004F7 C606D80B01              		mov	byte [SUPPRESS],YES_ECHO 
  1962 000004FC F606CD0BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1963 00000501 7508                    		jnz	short TRYING_TO_ABORT
  1964 00000503 C606CC0B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1965                                  
  1966                                  		; MSDOS 6.0
  1967                                  ;
  1968                                  ;M037; Start of changes
  1969                                  ; We check here if we have set the flag indicating that the batchfile is at
  1970                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1971                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1972                                  ;batch file gets closed etc. and then return as if everything is done.
  1973                                  ;
  1974                                  		;push	ds
  1975                                  		;mov	ds,Batch
  1976                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1977                                  		;pop	ds
  1978                                  		;jz	contbat		; no, continue normal processing
  1979                                  		;invoke	GetBatByt	; frees up batchseg
  1980                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1981                                  		;			; as a dummy command
  1982                                  		;invoke CrLf2		; print a CR-LF
  1983                                  		;return			; done batch processing
  1984                                  
  1985                                  ;M037; End of changes
  1986                                  		
  1987                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1988                                  CONTBAT:
  1989 00000508 E8ABFF                  		call	PROMPTBAT
  1990                                  TRYING_TO_ABORT:
  1991 0000050B BF[B73F]                		mov	di,COMBUF+2
  1992                                  
  1993                                  ; Save position and try to scan for first non delimiter.
  1994                                  
  1995                                  TESTNOP:
  1996 0000050E 8CD8                    		mov	ax,ds
  1997 00000510 8E1E810B                		mov	ds,[BATCH]
  1998 00000514 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  1999 00000518 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  2000 0000051C 8ED8                    		mov	ds,ax
  2001 0000051E E87905                  		call	SKIPDELIM	; skip to first non-delim
  2002                                  
  2003                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2004                                  ; beginning and read the line.
  2005                                  
  2006 00000521 3C3A                    		cmp	al,':'		; is it a label?
  2007 00000523 59                      		pop	cx
  2008 00000524 5A                      		pop	dx		; restore position in bat file
  2009 00000525 7413                    		jz	short NOPLINE	; yes, resync everything.
  2010 00000527 F706810BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2011 0000052D 7436                    		jz	short RDBAT	; no, go read batch file
  2012                                  
  2013                                  		;cmp	al,'@'
  2014 0000052F 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2015 00000531 7516                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2016                                  		;mov	byte [SUPPRESS],0
  2017 00000533 C606D80B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2018 00000538 EB2B                    		jmp	short RDBAT	; go read batch file
  2019                                  
  2020                                  		;nop
  2021                                  ; 02/03/2023
  2022                                  ;SET_BAT_POS:
  2023                                  ;		push	ds
  2024                                  ;		mov	ds,[BATCH]
  2025                                  ;		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2026                                  ;		mov	[BATCHSEGMENT.BatSeek+2],cx
  2027                                  ;		pop	ds
  2028                                  ;		;MOV	AX,(LSEEK SHL 8) + 0
  2029                                  ;		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2030                                  ;		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2031                                  ;				; AL = method: offset from beginning of	file
  2032                                  ;		;mov	word [cs:BATBUFPOS],0FFFFh
  2033                                  ;		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2034                                  ;		xor	cx,cx		; Initialize line length to zero
  2035                                  ;		jmp	short RDBAT
  2036                                  
  2037                                  		;nop
  2038                                  
  2039                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2040                                  ; We eat characters until a CR is seen.
  2041                                  
  2042                                  NOPLINE:
  2043 0000053A E80E01                  		call	SKIPTOEOL
  2044 0000053D E84403                  		call	GETBATBYT	; eat trailing LF
  2045                                  		;test	word [BATCH],0FFFFh
  2046 00000540 F706810BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2047 00000546 75C6                    		jnz	short TESTNOP	; no, go get another line
  2048                                  READBAT_RETN:				; Hit EOF			
  2049 00000548 C3                      		retn
  2050                                  
  2051                                  ; 02/03/2023
  2052                                  SET_BAT_POS:
  2053 00000549 1E                      		push	ds
  2054 0000054A 8E1E810B                		mov	ds,[BATCH]
  2055 0000054E 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2056 00000552 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2057 00000556 1F                      		pop	ds
  2058                                  		;mov	ax,(LSEEK SHL 8) + 0
  2059 00000557 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2060 0000055A CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2061                                  				; AL = method: offset from beginning of	file
  2062                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2063 0000055C 2EC706[FE4B]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2064 00000563 31C9                    		xor	cx,cx		; Initialize line length to zero
  2065                                  		; 02/03/2023
  2066                                  		;jmp	short RDBAT
  2067                                  
  2068                                  ; ---------------------------------------------------------------------------
  2069                                  
  2070                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2071                                  ; input, we are to consider two special cases:
  2072                                  ;
  2073                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2074                                  ;   %sym%	This is a symbol from the environment
  2075                                  
  2076                                  RDBAT:
  2077 00000565 E81C03                  		call	GETBATBYT
  2078 00000568 41                      		inc	cx		; Inc the line length
  2079                                  RDBAT1:
  2080 00000569 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2081 0000056D 7343                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2082                                  
  2083                                  ; See if we have a parameter character.
  2084                                  
  2085 0000056F 3C25                    		cmp	al,'%'		; Check for parameter
  2086 00000571 7449                    		jz	short NEEDPARM
  2087                                  
  2088                                  ; no parameter character. Store it as usual and see if we are done.
  2089                                  
  2090                                  SAVBATBYT:
  2091 00000573 AA                      		stosb			; End of line found?
  2092 00000574 3C0D                    		cmp	al,0Dh
  2093 00000576 75ED                    		jnz	short RDBAT	; no, go for more
  2094                                  
  2095                                  ; We have read in an entire line. 
  2096                                  ; Decide whether we should echo the command line or not.
  2097                                  
  2098                                  FOUND_EOL:
  2099 00000578 81EF[B83F]              		sub	di,COMBUF+3
  2100 0000057C 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2101 0000057E 26A2[B63F]              		mov	[es:COMBUF+1],al ; Set length of line
  2102 00000582 E8FF02                  		call	GETBATBYT	; Eat linefeed
  2103 00000585 E80406                  		call	BATCLOSE
  2104 00000588 803ED80B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2105 0000058D 7407                    		jz	short RESET
  2106 0000058F F606D70B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2107 00000594 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2108                                  RESET:
  2109 00000596 0E                      		push	cs
  2110 00000597 1F                      		pop	ds		; Go back to local segment
  2111 00000598 74AE                    		jz	short READBAT_RETN ; no echoing here...
  2112                                  TRY_NEXTFLAG:
  2113 0000059A 803EEC0B01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2114                                  					;G was there a command last time?
  2115 0000059F 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2116 000005A1 E89113                  		call	CRLF2		;G  Print out prompt
  2117                                  NO_CRLF_PRINT:
  2118 000005A4 E8C30D                  		call	PRINT_PROMPT
  2119 000005A7 0E                      		push	cs		;G change data segment
  2120 000005A8 1F                      		pop	ds
  2121 000005A9 BA[B73F]                		mov	dx,COMBUF+2	; get command line for echoing
  2122 000005AC E8E313                  		call	CRPRINT
  2123                                  		;call	CRLF2
  2124                                  		;retn
  2125                                  		; 03/03/2023
  2126 000005AF E98313                  		jmp	CRLF2
  2127                                  
  2128                                  ; The line was too long. Eat remainder of input text up until the CR
  2129                                  
  2130                                  TOOLONG:
  2131 000005B2 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2132 000005B4 7403                    		jz	short LTLCONT	; Yes, continue
  2133 000005B6 E89200                  		call	SKIPTOEOL	; Eat remainder of line	
  2134                                  LTLCONT:
  2135 000005B9 AA                      		stosb			; Terminate the command
  2136 000005BA EBBC                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2137                                  
  2138                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2139                                  
  2140                                  NEEDPARM:
  2141 000005BC E8C502                  		call	GETBATBYT	; get next character
  2142 000005BF 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2143 000005C1 74B0                    		jz	short SAVBATBYT	; if so, replace with a single %
  2144 000005C3 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2145 000005C5 74AC                    		jz	short SAVBATBYT	; yes, treat it normally
  2146                                  
  2147                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2148                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2149                                  ; see if the <something> has a terminating % and then look up the contents
  2150                                  ; in the environment.
  2151                                  
  2152                                  PAROK:
  2153 000005C7 2C30                    		sub	al,'0'
  2154 000005C9 7238                    		jb	short NEEDENV	; look for parameter in the environment
  2155 000005CB 3C09                    		cmp	al,9
  2156 000005CD 7734                    		ja	short NEEDENV
  2157                                  
  2158                                  ; We have found %<number>. This is taken from the parameters in the
  2159                                  ; allocated batch area.
  2160                                  
  2161 000005CF 98                      		cbw
  2162 000005D0 89C3                    		mov	bx,ax		; move index into AX
  2163 000005D2 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2164 000005D4 06                      		push	es
  2165 000005D5 8E06810B                		mov	es,[BATCH]
  2166                                  ;
  2167                                  ; The structure of the batch area is:
  2168                                  ;
  2169                                  ;   BYTE    type of segment
  2170                                  ;   DWORD   offset for next line
  2171                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2172                                  ;   ASCIZ   file name (with . and ..)
  2173                                  ;   BYTES   CR-terminated parameters
  2174                                  ;   BYTE    0 flag to indicate end of parameters
  2175                                  ;
  2176                                  ; Get pointer to BX'th argument
  2177                                  ;
  2178                                  		;mov	si,[es:bx+0Bh]
  2179 000005D9 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2180 000005DD 07                      		pop	es
  2181                                  
  2182                                  ; Is there a parameter here?
  2183                                  
  2184 000005DE 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2185 000005E1 7502                    		jnz	short YES_THERE_IS ; Yes go get it
  2186 000005E3 EB80                    		jmp	RDBAT		; Ignore if it doesn't
  2187                                  
  2188                                  ; Copy in the found parameter from batch segment
  2189                                  
  2190                                  YES_THERE_IS:
  2191 000005E5 1E                      		push	ds
  2192 000005E6 8E1E810B                		mov	ds,[BATCH]
  2193 000005EA 49                      		dec	cx		; Don't count '%' in line length
  2194                                  COPYPARM:
  2195 000005EB AC                      		lodsb			; From resident segment
  2196 000005EC 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2197 000005EE 740F                    		jz	short ENDPARAM
  2198 000005F0 41                      		inc	cx		; Inc the line length
  2199 000005F1 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2200 000005F5 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2201 000005F7 AA                      		stosb
  2202 000005F8 EBF1                    		jmp	short COPYPARM
  2203                                  
  2204                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2205                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2206                                  ; believing that we are at EOL. Clobber AL too.
  2207                                  
  2208                                  LINETOOL:
  2209 000005FA 30C0                    		xor	al,al
  2210 000005FC 1F                      		pop	ds
  2211 000005FD EBB3                    		jmp	short TOOLONG
  2212                                  
  2213                                  ; We have copied in an entire parameter. Go back for more
  2214                                  
  2215                                  ENDPARAM:
  2216 000005FF 1F                      		pop	ds
  2217 00000600 E962FF                  		jmp	RDBAT
  2218                                  
  2219                                  ; We have found % followed by something other than 0-9. We presume that there
  2220                                  ; will be a following % character. In between is an environment variable that
  2221                                  ; we will fetch and replace in the batch line with its value.
  2222                                  
  2223                                  NEEDENV:
  2224                                  		; MSDOS 6.0 COMMAND.COM 
  2225                                  		;dec     cx 		;AN070; Don't count "%"
  2226                                  
  2227                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2228 00000603 1E                      		push	ds
  2229 00000604 57                      		push	di
  2230                                  					; temp spot for name
  2231 00000605 BF[D141]                		mov	di,ID
  2232 00000608 0430                    		add	al,'0'		; reconvert character
  2233 0000060A AA                      		stosb			; store it in appropriate place
  2234                                  
  2235                                  ; loop getting characters until the next % is found or until EOL
  2236                                  
  2237                                  GETENV1:
  2238 0000060B E87602                  		call	GETBATBYT	; get the byte
  2239 0000060E AA                      		stosb			; store it
  2240 0000060F 3C0D                    		cmp	al,0Dh		; EOL?
  2241 00000611 7513                    		jnz	short GETENV15	; no, see if it the term char
  2242                                  
  2243                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2244                                  
  2245 00000613 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2246 00000618 BE[D141]                		mov	si,ID 		; point to buffer
  2247 0000061B 5F                      		pop	di		; point to line buffer
  2248 0000061C 0E                      		push	cs
  2249 0000061D 1F                      		pop	ds
  2250 0000061E E85A02                  		call	STRCPY
  2251                                  		;jc	short LineTooL	; MSDOS 6.0 COMMAND.COM
  2252 00000621 4F                      		dec	di  		; MSDOS 3.3 COMMAND.COM	
  2253 00000622 1F                      		pop	ds
  2254 00000623 E94DFF                  		jmp	SAVBATBYT
  2255                                  GETENV15:
  2256 00000626 3C25                    		cmp	al,'%'		; terminating %?
  2257 00000628 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2258                                  
  2259                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2260                                  ; This was the source of bug #1.
  2261                                  ;		dec	cx		;AN070; Don't count "%"
  2262                                  
  2263 0000062A B03D                    		mov	al,'='		; terminate  with =
  2264 0000062C 268845FF                		mov	[es:di-1],al
  2265                                  
  2266                                  ; ID now either has a =-terminated string which we are to find in the
  2267                                  ; environment or a non =-terminated string which will not be found in the
  2268                                  ; environment.
  2269                                  
  2270                                  GETENV2:
  2271 00000630 BE[D141]                		mov	si,ID
  2272 00000633 0E                      		push	cs
  2273 00000634 1F                      		pop	ds		; DS:SI points to name
  2274 00000635 51                      		push	cx
  2275 00000636 E83011                  		call	FIND_NAME_IN_ENVIRONMENT
  2276 00000639 59                      		pop	cx
  2277 0000063A 06                      		push	es
  2278 0000063B 1F                      		pop	ds
  2279 0000063C 0E                      		push	cs
  2280 0000063D 07                      		pop	es
  2281 0000063E 89FE                    		mov	si,di
  2282 00000640 5F                      		pop	di		; get back pointer to command line
  2283                                  
  2284                                  ; If the parameter was not found, there is no need to perform any replacement.
  2285                                  ; We merely pretend that we've copied the parameter.
  2286                                  
  2287 00000641 7204                    		jc	short GETENV6
  2288                                  
  2289                                  ; ES:DI points to command line being built
  2290                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2291                                  
  2292 00000643 E83502                  		call	STRCPY		; (let RdBat handle overflow)
  2293 00000646 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2294                                  GETENV6:
  2295 00000647 1F                      		pop	ds
  2296 00000648 E91AFF                  		jmp	RDBAT		; go back to batch file
  2297                                  
  2298                                  ; =============== S U B	R O U T	I N E =======================================
  2299                                  
  2300                                  ;   SkipToEOL - read from batch file until end of line
  2301                                  
  2302                                  SKIPTOEOL:
  2303 0000064B F706810BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2304                                  		
  2305                                  		;jnz	short SKIPTOEOL1  	
  2306                                  		;retn			; no batch file in effect
  2307                                  		
  2308 00000651 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2309                                  SKIPTOEOL1:
  2310 00000653 E82E02                  		call	GETBATBYT
  2311 00000656 3C0D                    		cmp	al,0Dh		; eol character?
  2312 00000658 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2313                                  SKIPTOEOL2:
  2314 0000065A C3                      		retn
  2315                                  
  2316                                  ; =============== S U B	R O U T	I N E =======================================
  2317                                  
  2318                                  ;Break	<Allocate and deallocate the transient portion>
  2319                                  
  2320                                  ; Free Transient. Modify ES,AX,flags
  2321                                  
  2322                                  FREE_TPA:
  2323 0000065B 06                      		push	es
  2324 0000065C 8E06[5641]              		mov	es,[RESSEG]
  2325 00000660 268E060D0D              		mov	es,[es:RES_TPA]
  2326 00000665 B449                    		mov	ah,DEALLOC ; 49h
  2327 00000667 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2328                                  				; ES = segment address of area to be freed
  2329 00000669 07                      		pop	es
  2330 0000066A C3                      		retn
  2331                                  
  2332                                  ; =============== S U B	R O U T	I N E =======================================
  2333                                  
  2334                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2335                                  
  2336                                  ALLOC_TPA:
  2337 0000066B 06                      		push	es
  2338 0000066C 8E06[5641]              		mov	es,[RESSEG]
  2339 00000670 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2340 00000673 B448                    		mov	ah,ALLOC ; 48h
  2341 00000675 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2342                                  				; BX = number of 16-byte paragraphs desired
  2343 00000677 53                      		push	bx	  	; Save size of block
  2344 00000678 B448                    		mov	ah,ALLOC ; 48h
  2345 0000067A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2346                                  				; BX = number of 16-byte paragraphs desired
  2347                                  
  2348                                  ; Attempt to align TPA on 64K boundary
  2349                                  
  2350 0000067C 5B                      		pop	bx		; Restore size of block
  2351 0000067D 26A30D0D                		mov	[es:RES_TPA],ax ; Save segment to beginning of block
  2352 00000681 A3[6641]                		mov	[TRAN_TPA],ax
  2353                                  
  2354                                  ; Is the segment already aligned on a 64K boundary
  2355                                  
  2356 00000684 89C2                    		mov	dx,ax		; Save segment
  2357 00000686 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2358 00000689 7507                    		jnz	short CALC_TPA
  2359 0000068B 89D0                    		mov	ax,dx
  2360 0000068D 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2361 00000690 7523                    		jnz	short NOROUND
  2362                                  CALC_TPA:
  2363 00000692 89D0                    		mov	ax,dx
  2364 00000694 2500F0                  		and	ax,0F000h
  2365 00000697 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2366 0000069A 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2367                                  
  2368                                  ; Make sure that new boundary is within allocated range
  2369                                  
  2370 0000069C 268B160D0D              		mov	dx,[es:RES_TPA]
  2371 000006A1 01DA                    		add	dx,bx		; Compute maximum address
  2372 000006A3 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2373 000006A5 720E                    		jb	short NOROUND
  2374                                  
  2375                                  ; Make sure that we won't overwrite the transient
  2376                                  
  2377 000006A7 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2378 000006A9 39C3                    		cmp	bx,ax
  2379 000006AB 7208                    		jb	short NOROUND
  2380                                  
  2381                                  ; The area from the 64K boundary to the beginning of the transient must
  2382                                  ; be at least 64K.
  2383                                  
  2384 000006AD 29C3                    		sub	bx,ax
  2385                                  		;cmp	bx,4096
  2386 000006AF 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2387 000006B3 7304                    		jnb	short ROUNDDONE
  2388                                  NOROUND:
  2389 000006B5 26A10D0D                		mov	ax,[es:RES_TPA]
  2390                                  ROUNDDONE:
  2391 000006B9 26A3FF0C                		mov	[es:LTPA],ax ; Re-compute everything
  2392 000006BD A3[5841]                		mov	[TPA],ax
  2393 000006C0 89C3                    		mov	bx,ax
  2394 000006C2 8CC8                    		mov	ax,cs
  2395 000006C4 29D8                    		sub	ax,bx
  2396 000006C6 53                      		push	bx
  2397 000006C7 BB1000                  		mov	bx,16
  2398 000006CA F7E3                    		mul	bx
  2399 000006CC 5B                      		pop	bx
  2400 000006CD 09D2                    		or	dx,dx
  2401 000006CF 7403                    		jz	short SAVSIZ2
  2402 000006D1 B8FFFF                  		mov	ax,-1
  2403                                  SAVSIZ2:
  2404                                  
  2405                                  ; AX is the number of bytes free in the buffer between the resident and the
  2406                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2407                                  
  2408 000006D4 3D0002                  		cmp	ax,512
  2409 000006D7 7603                    		jbe	short GOTSIZE2
  2410                                  		;and	ax,~1FFh
  2411 000006D9 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2412                                  GOTSIZE2:
  2413 000006DC A3[7741]                		mov	[BYTCNT],ax
  2414 000006DF 07                      		pop	es
  2415 000006E0 C3                      		retn
  2416                                  
  2417                                  ; =============== S U B	R O U T	I N E =======================================
  2418                                  
  2419                                  ;Break	<BatCom - enter a batch file>
  2420                                  
  2421                                  ; The exec search has determined that the user has requested a batch file for
  2422                                  ; execution. We parse the arguments, create the batch segment, and signal
  2423                                  ; batch processing.
  2424                                  
  2425                                  BATCOM:	
  2426                                  
  2427                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2428                                  
  2429                                  ; Batch parameters are read with ES set to segment of resident part
  2430                                  
  2431                                  		; MSDOS 6.0
  2432                                  		;mov	es,[RESSEG]
  2433                                  		;ASSUME	ES:RESGROUP
  2434                                  		;cmp	es:[call_batch_flag],call_in_progress
  2435                                  		;				;AN043; If in CALL,
  2436                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2437                                  		;invoke	IOSET			; Set up any redirection
  2438                                  ;skip_ioset:					;AN043;
  2439                                  		;call	FREE_TPA		; G
  2440                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2441                                  		;jz	getecho 		; G if we're in a call, don't execute
  2442                                  
  2443                                  		; MSDOS 3.3
  2444 000006E1 E8CC16                  		call	IOSET
  2445 000006E4 8E06[5641]              		mov	es,[RESSEG]
  2446 000006E8 E870FF                  		call	FREE_TPA
  2447                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2448 000006EB 26803EE90B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2449 000006F1 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2450                                  
  2451                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2452                                  
  2453                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2454                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2455                                  ; Don't execute if in call
  2456                                  
  2457 000006F3 E88B07                  		call	FOROFF
  2458                                  GETECHO:
  2459 000006F6 E8131C                  		call	PIPEOFF
  2460 000006F9 26A0D70B                		mov	al,[es:ECHOFLAG] ; preserve echo state for chaining
  2461 000006FD 2401                    		and	al,1		; Save current echo state
  2462                                  
  2463 000006FF 50                      		push	ax
  2464 00000700 31C0                    		xor	ax,ax
  2465 00000702 26F706810BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2466 00000709 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2467 0000070B 26A1810B                		mov	ax,[es:BATCH]	; Get current batch segment
  2468                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2469 0000070F 26803EE90B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2470 00000715 7408                    		jz	short LEAVEBAT
  2471                                  
  2472                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2473                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2474                                  
  2475 00000717 06                      		push	es
  2476 00000718 8EC0                    		mov	es,ax		; Get current batch segment
  2477                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2478                                  					; Get previous batch segment
  2479 0000071A 26A10200                		mov	ax,[es:BATCHSEGMENT.BatLast]
  2480 0000071E 07                      		pop	es
  2481                                  LEAVEBAT:
  2482 0000071F 50                      		push	ax		; Keep segment until new one created
  2483 00000720 26803EE90B01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2484 00000726 7403                    		jz	short STARTBAT
  2485 00000728 E8F600                  		call	BATCHOFF
  2486                                  
  2487                                  ; Find length of batch file
  2488                                  
  2489                                  STARTBAT:
  2490 0000072B 26C606E90B00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2491 00000731 BE[7E40]                		mov	si,EXECPATH
  2492                                  
  2493                                  		; MSDOS 6.0
  2494                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2495                                  		;int	2fh		;AN042;    was found with APPEND
  2496                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2497                                  		;mov	dx,si		;AN042; Get the string
  2498                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2499                                  		;int	21h		;AN042;
  2500                                  
  2501                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2502 00000734 E83017                  		call	DSTRLEN
  2503                                  ;
  2504                                  ; Allocate batch area:
  2505                                  ;   BYTE    type of segment
  2506                                  ;   WORD    segment of last batch file
  2507                                  ;   WORD    segment for FOR command
  2508                                  ;   BYTE    FOR flag state on entry to batch file
  2509                                  ;   DWORD   offset for next line
  2510                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2511                                  ;   ASCIZ   file name (with . and ..)
  2512                                  ;   BYTES   CR-terminated parameters
  2513                                  ;   BYTE    0 flag to indicate end of parameters
  2514                                  ;
  2515                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2516                                  ; later when we've squeezed out the extra
  2517                                  ;
  2518 00000737 89CB                    		mov	bx,cx		; length of file name.
  2519                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2520 00000739 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2521                                  					; structure + max len + round up
  2522 0000073D 51                      		push	cx
  2523 0000073E B104                    		mov	cl,4
  2524 00000740 D3EB                    		shr	bx,cl		; convert to paragraphs
  2525 00000742 53                      		push	bx		; Save size of batch segment
  2526 00000743 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2527 00000745 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2528                                  				; BX = number of 16-byte paragraphs desired
  2529 00000747 5B                      		pop	bx		; Get size of batch segment
  2530                                  
  2531                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2532                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2533                                  ; G This error will occur with nesting of batch files. We also need to
  2534                                  ; G make sure that we don't overlay the transient.
  2535                                  
  2536 00000748 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2537                                  
  2538 0000074A 50                      		push	ax		;G save batch segment
  2539 0000074B 01D8                    		add	ax,bx		;G get end of batch segment
  2540 0000074D 83C020                  		add	ax,20h		;G add some tpa work area
  2541 00000750 8CCB                    		mov	bx,cs		;G get the transient segment
  2542                                  
  2543                                  		; MSDOS 6.0
  2544                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2545                                  ; M006; batchseg is always above the transient. We need to change this code
  2546                                  ; M006; to only check for an overlap
  2547                                  ;
  2548                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2549                                  		;add	dx,15		;round up para; M006
  2550                                  		;shr	dx,cl		;para size of transient; M006
  2551                                  		;add	dx,bx		;dx = top of transient; M006
  2552                                  
  2553                                  		;cmp	ax,bx		; M006
  2554                                  		;jb	enough_mem	; Batchseg below transient
  2555                                  					; enough memory ; M006
  2556                                  		;cmp	ax,dx		; M006
  2557                                  		;ja	enough_mem	; Batchseg above transient
  2558                                  					; enough memory ; M006
  2559                                  ;
  2560                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2561                                  ;
  2562                                  		;pop	ax		; restore ax; M006
  2563                                  
  2564                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2565                                  ;M006;		pop	ax		;G get batch segment back
  2566                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2567                                  
  2568                                  		; MSDOS 3.3
  2569 00000752 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2570 00000754 58                      		pop	ax		; get batch segment back
  2571 00000755 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2572                                  
  2573                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2574 00000757 06                      		push	es		;G no we're hitting the transient
  2575 00000758 8EC0                    		mov	es,ax
  2576 0000075A B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2577 0000075D CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2578                                  				; ES = segment address of area to be freed
  2579 0000075F 07                      		pop	es
  2580                                  MEM_ERROR:
  2581 00000760 E9B200                  		jmp	NO_MEMORY	;G Set up for message and exit
  2582                                  
  2583                                  ENOUGH_MEM:
  2584                                  		; MSDOS 6.0
  2585                                  		;pop	ax		; restore ax; M006
  2586                                  
  2587                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2588 00000763 26A3810B                		mov	[es:BATCH],ax
  2589 00000767 E801FF                  		call	ALLOC_TPA
  2590                                  
  2591                                  ; Initialize batch segment
  2592                                  
  2593 0000076A 5A                      		pop	dx		; length of name
  2594 0000076B 58                      		pop	ax		;G get saved batch segment back
  2595 0000076C 26FF06E60B              		inc	word [es:NEST]	;G increment # batch files in progress
  2596 00000771 06                      		push	es
  2597 00000772 268E06810B              		mov	es,[es:BATCH]
  2598                                  		;mov	byte [es:0],0
  2599                                  					; signal batch file type
  2600 00000777 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2601                                  		;mov	[es:2],ax ; MSDOS 3.3
  2602                                  					;G save segment of last batch file
  2603 0000077D 26A30200                		mov	[es:BATCHSEGMENT.BatLast],ax
  2604 00000781 1E                      		push	ds
  2605 00000782 8E1E[5641]              		mov	ds,[RESSEG]	;G set to resident data
  2606                                  
  2607 00000786 31C0                    		xor	ax,ax
  2608 00000788 8A1EE30B                		mov	bl,[FORFLAG]	;G get the current FOR state
  2609                                  		;mov	[es:6],bl ; MSDOS 3.3
  2610                                  					;G save it in the batch segment
  2611 0000078C 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2612 00000791 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2613 00000794 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2614 00000796 A1E40B                  		mov	ax,[FORPTR]	;G yes, get current FOR segment	
  2615 00000799 C606E30B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2616                                  FOR_NOT_ON:
  2617                                  		;mov	[es:4],ax ; MSDOS 3.3
  2618                                  					;G save FOR segment in batch segment
  2619 0000079E 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2620 000007A2 31C0                    		xor	ax,ax
  2621 000007A4 A3E40B                  		mov	[FORPTR],ax	;G make sure for segment is not active
  2622 000007A7 8A1ED70B                		mov	bl,[ECHOFLAG]
  2623 000007AB 1F                      		pop	ds
  2624                                  		;mov	[es:1],bl 
  2625                                  					;G save echo state of parent
  2626 000007AC 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2627                                  ;SR;
  2628                                  ; Initialize the new BatchEOF flag we have added to 0
  2629                                  ;
  2630                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2631                                  
  2632 000007B1 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2633 000007B5 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2634                                  
  2635                                  ; Initialize pointers
  2636                                  
  2637 000007B9 48                      		dec	ax		; put -1 into AX
  2638                                  		;mov	di,0Bh  ; MSDOS 3.3
  2639                                  					; point to parm area
  2640 000007BA BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2641 000007BD 89FB                    		mov	bx,di
  2642 000007BF B90A00                  		mov	cx,10
  2643 000007C2 F3AB                    		rep stosw		; Init to no parms
  2644                                  
  2645                                  ; Move in batch file name
  2646                                  
  2647 000007C4 89D1                    		mov	cx,dx
  2648 000007C6 F3A4                    		rep movsb
  2649                                  
  2650                                  ; Now copy the command line into batch segment, parsing the arguments along
  2651                                  ; the way. Segment will look like this:
  2652                                  ;
  2653                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2654                                  ;
  2655                                  ; or, in the case of fewer arguments:
  2656                                  ;
  2657                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2658                                  ;
  2659 000007C8 BE[B73F]                		mov	si,COMBUF+2
  2660 000007CB B90A00                  		mov	cx,10		; at most 10 arguments
  2661                                  EACHPARM:
  2662 000007CE E87111                  		call	SCANOFF		; skip to argument
  2663                                  
  2664                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2665                                  
  2666 000007D1 3C0D                    		cmp	al,0Dh		; end of road?
  2667 000007D3 7413                    		jz	short HAVPARM	; yes, no more arguments
  2668                                  
  2669                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2670                                  
  2671 000007D5 E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2672                                  
  2673                                  ; Go into allocated piece and stick in new argument pointer.
  2674                                  
  2675 000007D7 26893F                  		mov	[es:bx],di	; store batch pointer
  2676 000007DA 83C302                  		add	bx,2		; advance arg counter
  2677                                  
  2678                                  ; Move the parameter into batch segment
  2679                                  
  2680                                  MOVPARM:
  2681 000007DD AC                      		lodsb			; get byte
  2682 000007DE E86911                  		call	DELIM		; if delimiter
  2683 000007E1 742A                    		jz	short ENDPARM	; then done with parm
  2684 000007E3 AA                      		stosb			; store byte
  2685 000007E4 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2686                                  		;jz	short HAVPARM	; but end of parm list, finish
  2687                                  		;jmp	short MOVPARM
  2688                                  		; 02/03/2023
  2689 000007E6 75F5                    		jnz	short MOVPARM
  2690                                  
  2691                                  ; 02/03/2023
  2692                                  ;; We have copied a parameter up until the first separator.
  2693                                  ;; Terminate it with CR.
  2694                                  ;
  2695                                  ;ENDPARM:
  2696                                  ;		mov	al,0Dh
  2697                                  ;		stosb
  2698                                  ;		jcxz	EACHPARM	; if no parameters, don't dec
  2699                                  ;		dec	cx		; remember that we've seen one.	
  2700                                  ;		jmp	short EACHPARM
  2701                                  
  2702                                  ; We have parsed the entire line. Terminate the arg list
  2703                                  
  2704                                  HAVPARM:
  2705 000007E8 30C0                    		xor	al,al		; Nul terminate the parms
  2706 000007EA AA                      		stosb
  2707                                  
  2708                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2709                                  ; into paragraphs and setblock to the appropriate size
  2710                                  
  2711 000007EB 8D5D0F                  		lea	bx,[di+15]
  2712 000007EE B104                    		mov	cl,4
  2713 000007F0 D3EB                    		shr	bx,cl
  2714 000007F2 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2715 000007F4 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2716                                  				; ES = segment address of block	to change
  2717                                  				; BX = new size	in paragraphs
  2718 000007F6 07                      		pop	es
  2719 000007F7 06                      		push	es
  2720 000007F8 1F                      		pop	ds		; Simply batch FCB setup
  2721 000007F9 833EDD0BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2722 000007FE 7506                    		jnz	short NOBATSING
  2723 00000800 C706DD0BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2724                                  NOBATSING:
  2725                                  
  2726                                  ; Enter the batch file with the current echo state
  2727                                  
  2728 00000806 58                      		pop	ax		; Get original echo state
  2729 00000807 A2D70B                  		mov	[ECHOFLAG],al	; restore it
  2730 0000080A E9F7F8                  		jmp	TCOMMAND
  2731                                  
  2732                                  ; 02/03/2023
  2733                                  ; We have copied a parameter up until the first separator.
  2734                                  ; Terminate it with CR.
  2735                                  
  2736                                  ENDPARM:
  2737 0000080D B00D                    		mov	al,0Dh
  2738 0000080F AA                      		stosb
  2739 00000810 E3BC                    		jcxz	EACHPARM	; if no parameters, don't dec
  2740 00000812 49                      		dec	cx		; remember that we've seen one.	
  2741 00000813 EBB9                    		jmp	short EACHPARM
  2742                                  
  2743                                  ; The following is executed if there isn't enough memory for batch segment
  2744                                  
  2745                                  NO_MEMORY:
  2746 00000815 5A                      		pop	dx		; even up our stack 
  2747 00000816 58                      		pop	ax
  2748 00000817 58                      		pop	ax
  2749 00000818 E850FE                  		call	ALLOC_TPA	; reallocate memory
  2750                                  
  2751                                  		; MSDOS 3.3
  2752 0000081B BA[BA3B]                		mov	dx,INSFMEMMESPTR
  2753 0000081E E9C513                  		jmp	CERROR
  2754                                  
  2755                                  		; MSDOS 6.0
  2756                                  		;mov	msg_disp_class,ext_msg_class
  2757                                  		;			;AN000; set up extended error msg class
  2758                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2759                                  		;			;AC000; get extended message pointer
  2760                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2761                                  		;			;AN000; get message number in control block
  2762                                  		;jmp	cerror		;g print error message and go...
  2763                                  
  2764                                  ; =============== S U B	R O U T	I N E =======================================
  2765                                  
  2766                                  BATCHOFF:
  2767 00000821 50                      		push	ax
  2768 00000822 06                      		push	es
  2769 00000823 1E                      		push	ds
  2770 00000824 53                      		push	bx
  2771                                  
  2772                                  		;mov	es,[cs:RESSEG]
  2773                                  		;mov	ds,[cs:RESSEG]
  2774                                  		; 03/03/2023
  2775 00000825 2EA1[5641]              		mov	ax,[cs:RESSEG]
  2776 00000829 8EC0                    		mov	es,ax
  2777 0000082B 8ED8                    		mov	ds,ax
  2778 0000082D A1810B                  		mov	ax,[BATCH]	; Free the batch segment
  2779 00000830 09C0                    		or	ax,ax
  2780 00000832 7442                    		jz	short NOTFREE
  2781                                  
  2782 00000834 06                      		push	es
  2783 00000835 8EC0                    		mov	es,ax
  2784 00000837 F606D70B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2785 0000083C 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2786                                  		;mov	byte [SUPPRESS],0
  2787 0000083E C606D80B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2788                                  ECHO_LAST_LINE:
  2789                                  		;mov	bl,[es:1]
  2790 00000843 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2791 00000848 881ED70B                		mov	[ECHOFLAG],bl	; G and restore it
  2792                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2793 0000084C 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2794 00000851 891EE40B                		mov	[FORPTR],bx	;G  and restore it
  2795                                  		;mov	bl,[es:6]
  2796 00000855 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2797 0000085A 881EE30B                		mov	[FORFLAG],bl	;G  and restore it
  2798                                  		;mov	bx,[es:2] ; MSDOS 3.3
  2799 0000085E 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast] ;G  Get old batch segment
  2800                                  
  2801 00000863 B449                    		mov	ah,DEALLOC ; 49h
  2802 00000865 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2803                                  				; ES = segment address of area to be freed
  2804 00000867 07                      		pop	es
  2805 00000868 891EEA0B                		mov	[NEXT_BATCH],bx	;G  reset batch segment	
  2806 0000086C 26FF0EE60B              		dec	word [es:NEST]
  2807 00000871 31C0                    		xor	ax,ax
  2808 00000873 A3810B                  		mov	[BATCH],ax	; No batch in progress
  2809                                  NOTFREE:
  2810 00000876 5B                      		pop	bx
  2811 00000877 1F                      		pop	ds
  2812 00000878 07                      		pop	es
  2813 00000879 58                      		pop	ax
  2814 0000087A C3                      		retn
  2815                                  
  2816                                  ; =============== S U B	R O U T	I N E =======================================
  2817                                  
  2818                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2819                                  ;	Entry : DS:SI ==> source string
  2820                                  ;		ES:DI ==> destination string
  2821                                  ;		CX = current length of destination string
  2822                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2823                                  
  2824                                  		; MSDOS 3.3
  2825                                  STRCPY:
  2826 0000087B 50                      		push	ax
  2827                                  CCYCLE:
  2828 0000087C AC                      		lodsb
  2829 0000087D AA                      		stosb
  2830 0000087E 08C0                    		or	al,al
  2831 00000880 75FA                    		jnz	short CCYCLE
  2832 00000882 58                      		pop	ax
  2833 00000883 C3                      		retn
  2834                                  
  2835                                  		; MSDOS 6.0
  2836                                  ;Procedure StrCpy,NEAR
  2837                                  		;push	ax
  2838                                  ;ccycle:
  2839                                  		;lodsb
  2840                                  		;inc	cx
  2841                                  		;cmp	cx,COMBUFLEN
  2842                                  		;jb	ccopy
  2843                                  		;stc			; set carry to signal error
  2844                                  		;jmp	short ccend
  2845                                  ;ccopy:
  2846                                  		;stosb
  2847                                  		;or	al,al
  2848                                  		;jnz	ccycle
  2849                                  ;ccend:
  2850                                  		;dec	cx		; discount extra byte
  2851                                  		;dec	di		; back up pointer
  2852                                  		;pop	ax
  2853                                  		;return			; return carry clear
  2854                                  ;EndProc StrCpy
  2855                                  
  2856                                  ;============================================================================
  2857                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2858                                  ;============================================================================
  2859                                  ; 12/10/2018 - Retro DOS v3.0
  2860                                  
  2861                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2862                                  
  2863                                  ; =============== S U B	R O U T	I N E =======================================
  2864                                  
  2865                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2866                                  
  2867                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2868                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2869                                  ; AH, DX destroyed.
  2870                                  
  2871                                  GETBATBYT:
  2872 00000884 53                      		push	bx
  2873 00000885 51                      		push	cx
  2874 00000886 1E                      		push	ds
  2875 00000887 F606CD0BFF              		test	byte [BATCH_ABORT],-1
  2876 0000088C 755E                    		jnz	short BATEOF
  2877 0000088E F706810BFFFF            		test	word [BATCH],-1
  2878 00000894 7456                    		jz	short BATEOF
  2879 00000896 06                      		push	es
  2880 00000897 8E06810B                		mov	es,[BATCH]
  2881                                  
  2882                                  		; MSDOS 6.0
  2883                                  ;M020;
  2884                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2885                                  ;try to read from the batchfile again.
  2886                                  ;
  2887                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2888                                  		;jz	not_eof		;no, read batch file	;M020
  2889                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2890                                  ;not_eof:							;M020
  2891                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2892 0000089B 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2893 000008A1 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2894 000008A7 07                      		pop	es
  2895                                  
  2896                                  ; See if we have bytes buffered...
  2897                                  
  2898 000008A8 8CC8                    		mov	ax,cs
  2899 000008AA 8ED8                    		mov	ds,ax
  2900 000008AC 8B1E[FE4B]              		mov	bx,[BATBUFPOS]
  2901 000008B0 83FBFF                  		cmp	bx,-1
  2902 000008B3 751D                    		jnz	short UNBUF
  2903                                  
  2904                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2905                                  
  2906 000008B5 BA[004C]                		mov	dx,BATBUF
  2907 000008B8 8B0E[133E]              		mov	cx,[BATBUFLEN] ; max to read.
  2908 000008BC 8B1E[7A44]              		mov	bx,[BATHAND]
  2909 000008C0 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2910 000008C2 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2911                                  				; BX = file handle,CX = number	of bytes to read
  2912                                  				; DS:DX	-> buffer
  2913                                  		; MSDOS 6.0
  2914                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2915                                  		;invoke	get_ext_error_number	;AN022; get the error
  2916                                  		;push	ds			;AN022; save local segment
  2917                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2918                                  		;assume ds:resgroup		;AN022;
  2919                                  		;mov	dx,ax			;AN022; put error in DX
  2920                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2921                                  		;pop	ds			;AN022;
  2922                                  		;assume	ds:trangroup		;AN022;
  2923                                  		;invoke	std_eprintf		;AN022; print out the error
  2924                                  		;mov	byte ptr combuf+2,end_of_line_in
  2925                                  		;				;AN022; terminate the batch line for parsing
  2926                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2927                                  		;				;AN022; terminate the batch line for output
  2928                                  ;M020;
  2929                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2930                                  ;error is never hit (and it shouldn't be)
  2931                                  ;
  2932                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2933                                  		;
  2934                                  		;jmp	short bateof		;AN022; terminate the batch file
  2935                                  ;bat_read_ok:					;AN022;
  2936                                  
  2937                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2938 000008C4 89C1                    		mov	cx,ax
  2939 000008C6 E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2940                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2941 000008C8 890E[204C]              		mov	[BATBUFEND],cx
  2942 000008CC 31DB                    		xor	bx,bx
  2943 000008CE 891E[FE4B]              		mov	[BATBUFPOS],bx
  2944                                  
  2945                                  ; Buffered bytes!
  2946                                  
  2947                                  UNBUF:
  2948 000008D2 8A87[004C]              		mov	al,[BATBUF+bx]		; get next byte
  2949 000008D6 43                      		inc	bx
  2950 000008D7 3B1E[204C]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2951 000008DB 7203                    		jb	short SETBUFPOS
  2952 000008DD BBFFFF                  		mov	bx,-1
  2953                                  SETBUFPOS:
  2954 000008E0 891E[FE4B]              		mov	[BATBUFPOS],bx
  2955 000008E4 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2956 000008E6 7533                    		jnz	short GETBYTEDONE
  2957                                  
  2958                                  ;We get here only when we hit an EOF
  2959                                  		
  2960                                  		; MSDOS 6.0
  2961                                  ;BatEOFDS:
  2962                                  ;SR;
  2963                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2964                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2965                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2966                                  ;batch processing is turned off before the last line is processed and so 
  2967                                  ;this line would never be executed. 
  2968                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2969                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2970                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2971                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2972                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2973                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2974                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2975                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2976                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2977                                  ;another redundant CR-LF. There is no work-around I can think of.
  2978                                  ; 	I would love to restructure this entire routine and its caller to
  2979                                  ;make the flow really easy to understand but I guess this will have to wait.
  2980                                  ;
  2981                                  		;push	es
  2982                                  		;mov	es,ResSeg
  2983                                  ;SR;
  2984                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2985                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2986                                  ;
  2987                                  		;mov	es,es:Batch
  2988                                  		;cmp	es:BatchEOF,0
  2989                                  		;jnz	crpresent
  2990                                  
  2991                                  		;inc	es:BatchEOF		;match the dec following
  2992                                  		;mov	bx,BatBufEnd
  2993                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2994                                  		;je	crpresent		;yes, no need to fake it
  2995                                  
  2996                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2997                                  
  2998                                  ;crpresent:
  2999                                  ;;;		;pop	es
  3000                                  
  3001                                  		;ASSUME	DS:TranGroup
  3002                                  		;MOV	DS,ResSeg
  3003                                  		;ASSUME	DS:ResGroup
  3004                                  
  3005                                  ;SR;
  3006                                  ; The shift operation is done here to replace the decrement. This is because
  3007                                  ;we can jump to this label directly from above when bogus calls are made to
  3008                                  ;this routine even after batch processing is turned off. The shift ensures
  3009                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  3010                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  3011                                  ;calls.
  3012                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  3013                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  3014                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  3015                                  ;turning batch processing off.
  3016                                  
  3017                                  ;At_EOF:						;new label added ;M020
  3018                                  		;shr	es:BatchEOF,1		;decrement the flag
  3019                                  		;jz	turn_off		;zero,turn batch off
  3020                                  		;cmp	es:BatchEOF,1				
  3021                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  3022                                  ;
  3023                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  3024                                  ;
  3025                                  		;mov	al,0dh			;return fake CR.
  3026                                  		;pop	es
  3027                                  		;jmp	short GetByteDone
  3028                                  ;ret_lf:
  3029                                  		;mov	al,0ah			;return fake LF
  3030                                  		;pop	es
  3031                                  		;jmp	short GetByteDone			
  3032                                  ;turn_off:
  3033                                  		;pop	es
  3034                                  
  3035                                  ;BATEOF:
  3036                                  
  3037                                  		; MSDOS 3.3
  3038                                  TURN_OFF:
  3039 000008E8 8E1E[5641]              		mov	ds,[RESSEG]
  3040                                  
  3041                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3042                                  BATEOF:
  3043 000008EC E832FF                  		call	BATCHOFF
  3044 000008EF E89A02                  		call	BATCLOSE
  3045                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3046                                  
  3047                                  ;SR; BugBug
  3048                                  ; There is a good reason why this carriage return is being returned here. 
  3049                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3050                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3051                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3052                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3053                                  ;the batchfile already had a CR-LF. 
  3054                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3055                                  ;the end-of-line. This CR is to mark the end-of-file.
  3056                                  
  3057 000008F2 B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3058 000008F4 F606CD0BFF              		test	byte [BATCH_ABORT],-1
  3059 000008F9 C606CD0B00              		mov	byte [BATCH_ABORT],0
  3060 000008FE 7407                    		jz	short CONT_GET_BYT
  3061 00000900 BF[B73F]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3062 00000903 31C9                    		xor	cx,cx		; zero line length
  3063 00000905 EB14                    		jmp	short GETBYTEDONE
  3064                                  CONT_GET_BYT:
  3065 00000907 833EDD0BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3066 0000090C 750D                    		jnz	short GETBYTEDONE
  3067 0000090E 833EE60B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3068 00000913 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3069 00000915 C706DD0BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3070                                  GETBYTEDONE:
  3071 0000091B 1F                      		pop	ds
  3072 0000091C 59                      		pop	cx
  3073 0000091D 5B                      		pop	bx
  3074 0000091E C3                      		retn
  3075                                  
  3076                                  ; ---------------------------------------------------------------------------
  3077                                  
  3078                                  ;break	<$If - conditional execution>
  3079                                  
  3080                                  IFERRORP:
  3081 0000091F 58                      		pop	ax
  3082                                  IFERROR:
  3083                                  FORERROR:
  3084 00000920 BA[883B]                		mov	dx,SYNTMESPTR
  3085 00000923 E9C012                  		jmp	CERROR
  3086                                  
  3087                                  ; ---------------------------------------------------------------------------
  3088                                  
  3089                                  _$IF:
  3090                                  		; MSDOS 6.0
  3091                                  ; Turn off any pipes in progress.
  3092                                  		;push	ds			;AN004; save local DS
  3093                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3094                                  		;assume	ds:resgroup		;AN004;
  3095                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3096                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3097                                  		;invoke	PipeDel 		;AN004; turn off piping
  3098                                  ;IFNoPipe:					;AN004;
  3099                                  		;pop	ds			;AN004; get local DS back
  3100                                  		;assume	ds:trangroup		;AN004;
  3101                                  
  3102                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3103 00000926 C606[6941]00            		mov	byte [IFNOTFLAG],0
  3104 0000092B C706[DA4A]0000          		mov	word [IF_NOT_COUNT],0
  3105 00000931 BE8100                  		mov	si,81h
  3106                                  IFREENT:
  3107 00000934 E80B10                  		call	SCANOFF
  3108 00000937 3C0D                    		cmp	al,0Dh
  3109 00000939 74E5                    		jz	short IFERROR
  3110 0000093B 89F5                    		mov	bp,si
  3111 0000093D BF[D73C]                		mov	di,IFTAB	; Prepare to search if table	
  3112 00000940 B500                    		mov	ch,0
  3113                                  IFINDCOM:
  3114 00000942 89EE                    		mov	si,bp
  3115 00000944 8A0D                    		mov	cl,[di]
  3116 00000946 47                      		inc	di
  3117 00000947 E337                    		jcxz	IFSTRING
  3118 00000949 EB02                    		jmp	short FIRSTCOMP
  3119                                  IFCOMP:
  3120 0000094B 7510                    		jnz	short IF_DIF
  3121                                  FIRSTCOMP:
  3122 0000094D AC                      		lodsb
  3123 0000094E 268A25                  		mov	ah,[es:di]
  3124 00000951 47                      		inc	di
  3125 00000952 38E0                    		cmp	al,ah
  3126 00000954 7405                    		jz	short IFLP
  3127 00000956 80CC20                  		or	ah,20h		; Try lower case
  3128 00000959 38E0                    		cmp	al,ah
  3129                                  IFLP:
  3130 0000095B E2EE                    		loop	IFCOMP
  3131                                  IF_DIF:
  3132 0000095D 9F                      		lahf
  3133 0000095E 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3134 00000960 8B1D                    		mov	bx,[di]		; Get handler address
  3135 00000962 47                      		inc	di
  3136 00000963 47                      		inc	di
  3137 00000964 9E                      		sahf
  3138 00000965 75DB                    		jnz	short IFINDCOM
  3139 00000967 AC                      		lodsb
  3140 00000968 3C0D                    		cmp	al,0Dh
  3141                                  IFERRJ:
  3142 0000096A 74B4                    		jz	short IFERROR
  3143 0000096C E8DB0F                  		call	DELIM
  3144 0000096F 75D1                    		jnz	short IFINDCOM
  3145 00000971 E8CE0F                  		call	SCANOFF
  3146 00000974 FFE3                    		jmp	bx
  3147                                  IFNOT:
  3148 00000976 F616[6941]              		not	byte [IFNOTFLAG]
  3149 0000097A FF06[DA4A]              		inc	word [IF_NOT_COUNT]
  3150 0000097E EBB4                    		jmp	short IFREENT
  3151                                  
  3152                                  ; We are comparing two strings for equality. First, find the end of the
  3153                                  ; first string.
  3154                                  
  3155                                  IFSTRING:
  3156 00000980 56                      		push	si		; save away pointer for later compare
  3157 00000981 31C9                    		xor	cx,cx		; count of chars in first string
  3158                                  FIRST_STRING:
  3159 00000983 AC                      		lodsb			; get character
  3160 00000984 3C0D                    		cmp	al,0Dh		; end of line?
  3161 00000986 7497                    		jz	short IFERRORP	; yes => error
  3162 00000988 E8BF0F                  		call	DELIM		; is it a delimiter?
  3163 0000098B 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3164 0000098D 41                      		inc	cx		; remember 1 byte for the length
  3165 0000098E EBF3                    		jmp	short FIRST_STRING ; go back for more
  3166                                  EQUAL_CHECK:
  3167 00000990 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3168 00000992 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3169 00000994 3C0D                    		cmp	al,0Dh		; end of line?
  3170 00000996 7487                    		jz	short IFERRORP	; yes, syntax error
  3171 00000998 AC                      		lodsb			; get next char
  3172 00000999 EBF5                    		jmp	short EQUAL_CHECK
  3173                                  
  3174                                  ; The first = has been found. The next char had better be an = too.
  3175                                  
  3176                                  EQUAL_CHECK2:
  3177 0000099B AC                      		lodsb			; get potential = char
  3178 0000099C 3C3D                    		cmp	al,'='		; is it good?	
  3179 0000099E 7520                    		jnz	short IFERRPJ	; no, error
  3180                                  
  3181                                  ; Find beginning of second string.
  3182                                  
  3183 000009A0 E89F0F                  		call	SCANOFF
  3184 000009A3 3C0D                    		cmp	al,0Dh
  3185 000009A5 7419                    		jz	short IFERRPJ
  3186 000009A7 5F                      		pop	di
  3187                                  
  3188                                  ; DS:SI points to second string
  3189                                  ; CX has number of chars in first string
  3190                                  ; ES:DI points to first string
  3191                                  
  3192 000009A8 F3A6                    		repe cmpsb
  3193 000009AA 7417                    		jz	short MATCH	; match found!
  3194                                  
  3195                                  ; No match.  Let's find out what was wrong. The character that did not match
  3196                                  ; has been advanced over. Let's back up to it.
  3197                                  
  3198 000009AC 4E                      		dec	si
  3199                                  
  3200                                  ; If it is EOL, then syntax error
  3201                                  
  3202 000009AD 803C0D                  		cmp	byte [si],0Dh
  3203 000009B0 74B8                    		jz	short IFERRJ
  3204                                  
  3205                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3206                                  
  3207                                  SKIPSTRINGEND:
  3208 000009B2 AC                      		lodsb
  3209                                  NOTMATCH:
  3210 000009B3 3C0D                    		cmp	al,0Dh
  3211                                  IFERRORJ2:
  3212 000009B5 74B3                    		jz	short IFERRJ
  3213 000009B7 E8900F                  		call	DELIM
  3214 000009BA 75F6                    		jnz	short SKIPSTRINGEND
  3215                                  
  3216                                  ; Signal that we did NOT have a match
  3217                                  
  3218 000009BC B0FF                    		mov	al,-1
  3219 000009BE EB3A                    		jmp	short IFRET
  3220                                  IFERRPJ:
  3221 000009C0 E95CFF                  		jmp	IFERRORP
  3222                                  
  3223                                  ; The compare succeeded. Was the second string longer than the first?
  3224                                  ; We do this by seeing if the next char is a delimiter.
  3225                                  
  3226                                  MATCH:
  3227 000009C3 AC                      		lodsb
  3228 000009C4 E8830F                  		call	DELIM
  3229 000009C7 75EA                    		jnz	short NOTMATCH ; not same.
  3230 000009C9 30C0                    		xor	al,al
  3231 000009CB EB2D                    		jmp	short IFRET
  3232                                  
  3233                                  ; ---------------------------------------------------------------------------
  3234                                  
  3235                                  IFEXISTS:
  3236                                  
  3237                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3238                                  
  3239                                  ;MOREDELIM:
  3240 000009CD AC                      		lodsb
  3241 000009CE E8790F                  		call	DELIM
  3242 000009D1 75FA                    		jnz	short IFEXISTS
  3243                                  		;jnz	short MOREDELIM
  3244                                  
  3245 000009D3 BA[4F42]                		mov	dx,DIRBUF
  3246 000009D6 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3247 000009D9 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3248                                  				; DS:DX	-> disk	transfer buffer
  3249 000009DB BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3250 000009DE 031E[DA4A]              		add	bx,[IF_NOT_COUNT]
  3251                                  		;mov	ax,ARG_ARGV
  3252                                  		;mov	ax,ARG+ARG_UNIT.argv
  3253 000009E2 B8[8E44]                		mov	ax,ARG
  3254 000009E5 E8621A                  		call	ARGV_CALC	; convert arg index to pointer
  3255 000009E8 8B17                    		mov	dx,[bx]
  3256                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3257                                  		;mov	cx,6
  3258 000009EA B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3259 000009ED B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3260 000009F0 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3261                                  				; CX = search attributes
  3262                                  				; DS:DX	-> ASCIZ filespec
  3263                                  				; (drive,path, and wildcards allowed)
  3264 000009F2 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3265 000009F4 30C0                    		xor	al,al
  3266 000009F6 EB02                    		jmp	short IFRET
  3267                                  
  3268                                  		;nop
  3269                                  IF_EX_C:
  3270 000009F8 B0FF                    		mov	al,-1		; false 'n' fall through...
  3271                                  IFRET:
  3272 000009FA F606[6941]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3273 000009FF 7402                    		jz	short REALTEST
  3274 00000A01 F6D0                    		not	al
  3275                                  REALTEST:
  3276 00000A03 08C0                    		or	al,al
  3277 00000A05 7403                    		jz	short IFTRUE
  3278 00000A07 E9FAF6                  		jmp	TCOMMAND
  3279                                  
  3280                                  IFTRUE:
  3281 00000A0A E8350F                  		call	SCANOFF
  3282 00000A0D 89F1                    		mov	cx,si
  3283 00000A0F 81E98100                		sub	cx,81h
  3284 00000A13 280E8000                		sub	[80h],cl
  3285 00000A17 8A0E8000                		mov	cl,[80h]
  3286 00000A1B 880E[B63F]              		mov	[COMBUF+1],cl
  3287 00000A1F BF[B73F]                		mov	di,COMBUF+2
  3288 00000A22 FC                      		cld
  3289 00000A23 F3A4                    		rep movsb
  3290 00000A25 B00D                    		mov	al,0Dh
  3291 00000A27 AA                      		stosb
  3292                                  
  3293                                  ; Signal that an IF was done. 
  3294                                  ; This prevents the redirections from getting lost.
  3295                                  
  3296 00000A28 1E                      		push	ds
  3297 00000A29 8E1E[5641]              		mov	ds,[RESSEG]
  3298 00000A2D C606E20BFF              		mov	byte [IFFLAG],-1
  3299 00000A32 1F                      		pop	ds
  3300                                  
  3301                                  ; Go do the command
  3302                                  
  3303 00000A33 E977F8                  		jmp	DOCOM1
  3304                                  
  3305                                  ; ---------------------------------------------------------------------------
  3306                                  
  3307                                  IFERRORJ3:
  3308 00000A36 E97CFF                  		jmp	IFERRORJ2
  3309                                  
  3310                                  IFERLEV:
  3311 00000A39 B70A                    		mov	bh,10
  3312 00000A3B 30DB                    		xor	bl,bl
  3313                                  GETNUMLP:
  3314 00000A3D AC                      		lodsb
  3315 00000A3E 3C0D                    		cmp	al,0Dh
  3316 00000A40 74F4                    		jz	short IFERRORJ3
  3317 00000A42 E8050F                  		call	DELIM
  3318 00000A45 740C                    		jz	short GOTNUM
  3319 00000A47 2C30                    		sub	al,'0'
  3320 00000A49 86C3                    		xchg	al,bl
  3321 00000A4B F6E7                    		mul	bh
  3322 00000A4D 00D8                    		add	al,bl
  3323 00000A4F 86C3                    		xchg	al,bl
  3324 00000A51 EBEA                    		jmp	short GETNUMLP
  3325                                  GOTNUM:
  3326 00000A53 1E                      		push	ds
  3327 00000A54 8E1E[5641]              		mov	ds,[RESSEG]
  3328 00000A58 8A26D40B                		mov	ah,[RETCODE]	; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3329 00000A5C 1F                      		pop	ds
  3330 00000A5D 30C0                    		xor	al,al
  3331 00000A5F 38DC                    		cmp	ah,bl
  3332 00000A61 7397                    		jnb	short IFRET
  3333 00000A63 FEC8                    		dec	al
  3334 00000A65 EB93                    		jmp	short IFRET
  3335                                  
  3336                                  ; ---------------------------------------------------------------------------
  3337                                  
  3338                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3339                                  ; This is a NOP if no batch in progress.
  3340                                  
  3341                                  SHIFT:
  3342 00000A67 8E1E[5641]              		mov	ds,[RESSEG]
  3343 00000A6B A1810B                  		mov	ax,[BATCH]	; get batch pointer
  3344 00000A6E 09C0                    		or	ax,ax		; in batch mode?
  3345 00000A70 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3346                                  SHIFT_RETN:				; no, done.
  3347 00000A72 C3                      		retn
  3348                                  SHIFT1:
  3349 00000A73 8EC0                    		mov	es,ax
  3350 00000A75 8ED8                    		mov	ds,ax
  3351                                  
  3352                                  ; Now move the batch args down by 1 word
  3353                                  
  3354                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3355 00000A77 BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3356 00000A7A 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3357 00000A7D B90900                  		mov	cx,9		; move 9 parameters
  3358 00000A80 F3A5                    		rep movsw		; SHIFT down
  3359                                  
  3360                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3361                                  ; We have copied it into the previous position.
  3362                                  
  3363 00000A82 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3364 00000A85 74EB                    		jz	short SHIFT_RETN ; No new parm
  3365                                  
  3366                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3367                                  ; Assume, first, that there is no next argument.
  3368                                   
  3369 00000A87 8B35                    		mov	si,[di]
  3370 00000A89 C705FFFF                		mov	word [di],-1	; Assume no parm
  3371                                  
  3372                                  ; The parameters are CR separated. Scan for end of this parm.
  3373                                  
  3374                                  SKIPCRLP:
  3375 00000A8D AC                      		lodsb
  3376 00000A8E 3C0D                    		cmp	al,0Dh
  3377 00000A90 75FB                    		jnz	short SKIPCRLP
  3378                                  
  3379                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3380                                  ; are finished. There are no more parms and the pointer has been previously
  3381                                  ; initialized to indicate it.
  3382                                  
  3383 00000A92 803C00                  		cmp	byte [si],0
  3384 00000A95 74DB                    		jz	short SHIFT_RETN ; End of parms
  3385 00000A97 8935                    		mov	[di],si		; Pointer to next parm as %9
  3386 00000A99 C3                      		retn
  3387                                  
  3388                                  ; =============== S U B	R O U T	I N E =======================================
  3389                                  
  3390                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3391                                  ; returns char in AL, carry set -> eof
  3392                                  
  3393                                  SKIPDELIM:
  3394 00000A9A F706810BFFFF            		test	word [BATCH],-1	; batch file empty. OOPS!
  3395 00000AA0 740A                    		jz	short SKIPERR
  3396 00000AA2 E8DFFD                  		call	GETBATBYT	; get a char
  3397 00000AA5 E8A20E                  		call	DELIM		; check for ignoreable chars
  3398 00000AA8 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3399 00000AAA F8                      		clc
  3400 00000AAB C3                      		retn
  3401                                  SKIPERR:
  3402 00000AAC F9                      		stc
  3403                                  GOTO_RETN:
  3404 00000AAD C3                      		retn
  3405                                  
  3406                                  ; ---------------------------------------------------------------------------
  3407                                  
  3408                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3409                                  ;  .com file. This routine strips the CALL off the command line, sets
  3410                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3411                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3412                                  ;  being CALLed.
  3413                                  
  3414                                  _$CALL:
  3415                                  
  3416                                  ;  strip off CALL from command line
  3417                                  
  3418                                  		;ASSUME DS:trangroup,ES:trangroup
  3419                                  
  3420 00000AAE 56                      		push	si
  3421 00000AAF 57                      		push	di
  3422 00000AB0 50                      		push	ax
  3423 00000AB1 51                      		push	cx
  3424 00000AB2 BE[B73F]                		mov	si,COMBUF+2
  3425 00000AB5 E88A0E                  		call	SCANOFF		;get to first non-delimeter
  3426                                  		;add	si,4
  3427 00000AB8 83C604                  		add	si,length_call	;point to char past CALL
  3428 00000ABB BF[B73F]                		mov	di,COMBUF+2
  3429                                  		;mov	cx,124		
  3430 00000ABE B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3431 00000AC1 F3A4                    		rep movsb		;move it
  3432 00000AC3 59                      		pop	cx
  3433 00000AC4 58                      		pop	ax
  3434 00000AC5 5F                      		pop	di
  3435 00000AC6 5E                      		pop	si
  3436                                  
  3437                                  ;  set call flag to indicate call in progress
  3438                                  
  3439 00000AC7 1E                      		push	ds
  3440 00000AC8 8E1E[5641]              		mov	ds,[RESSEG]
  3441 00000ACC C606E80B01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3442 00000AD1 C606E90B01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3443                                  
  3444                                  ; Turn off any pipes in progress.
  3445                                  
  3446 00000AD6 803E450C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3447 00000ADB 7403                    		jz	short _NOPIPE
  3448 00000ADD E8E113                  		call	PIPEDEL
  3449                                  _NOPIPE:
  3450 00000AE0 1F                      		pop	ds
  3451 00000AE1 C3                      		retn
  3452                                  
  3453                                  ; ---------------------------------------------------------------------------
  3454                                  
  3455                                  GOTO:
  3456 00000AE2 8E1E[5641]              		mov	ds,[RESSEG]
  3457 00000AE6 F706810BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3458 00000AEC 74BF                    		jz	short GOTO_RETN
  3459 00000AEE 31D2                    		xor	dx,dx
  3460 00000AF0 1E                      		push	ds
  3461 00000AF1 8E1E810B                		mov	ds,[BATCH]
  3462 00000AF5 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3463 00000AF9 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3464                                  
  3465                                  		; MSDOS 6.0
  3466                                  ;M037
  3467                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3468                                  ;
  3469                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3470                                  
  3471                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3472                                  
  3473 00000AFD 1F                      		pop	ds
  3474                                  GOTOOPEN:
  3475 00000AFE E8B5F9                  		call	PROMPTBAT
  3476                                  		;mov	di,5Dh
  3477 00000B01 BF5D00                  		mov	di,FCB+1	; Get the label
  3478 00000B04 B90B00                  		mov	cx,11
  3479 00000B07 B020                    		mov	al,' '
  3480 00000B09 F2AE                    		repne scasb
  3481 00000B0B 7501                    		jnz	short NOINC
  3482 00000B0D 41                      		inc	cx
  3483                                  NOINC:
  3484 00000B0E 83E90B                  		sub	cx,11
  3485 00000B11 F7D9                    		neg	cx
  3486 00000B13 2E890E[4F42]            		mov	[cs:GOTOLEN],cx
  3487                                  
  3488                                  ; At beginning of file. Skip to first non-delimiter char
  3489                                  
  3490 00000B18 E87FFF                  		call	SKIPDELIM
  3491 00000B1B 721C                    		jb	short BADGOTO
  3492 00000B1D 3C3A                    		cmp	al,':'
  3493 00000B1F 7423                    		jz	short CHKLABEL
  3494                                  LABLKLP:				; Look for the label
  3495 00000B21 E860FD                  		call	GETBATBYT
  3496 00000B24 3C0A                    		cmp	al,0Ah
  3497 00000B26 7509                    		jnz	short LABLKTST
  3498                                  
  3499                                  ; At beginning of line.  Skip to first non-delimiter char
  3500                                  
  3501 00000B28 E86FFF                  		call	SKIPDELIM
  3502 00000B2B 720C                    		jb	short BADGOTO
  3503 00000B2D 3C3A                    		cmp	al,':'
  3504 00000B2F 7413                    		jz	short CHKLABEL
  3505                                  LABLKTST:
  3506 00000B31 F706810BFFFF            		test	word [BATCH],0FFFFh ; -1
  3507 00000B37 75E8                    		jnz	short LABLKLP
  3508                                  BADGOTO:
  3509 00000B39 E85000                  		call	BATCLOSE
  3510                                  
  3511                                  		; MSDOS 6.0
  3512                                  ;SR;
  3513                                  ; At this point we are terminating without freeing up any nested batch 
  3514                                  ;segments i.e if the error occurred within a called batch file. This routine
  3515                                  ;will traverse the linked list of batch segments and free all of them.
  3516                                  ;
  3517                                  		;call	free_batch	;free up nested batch segments
  3518                                  
  3519                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3520 00000B3C 0E                      		push	cs
  3521 00000B3D 1F                      		pop	ds
  3522 00000B3E BA[773B]                		mov	dx,BADLABPTR
  3523 00000B41 E9A210                  		jmp	CERROR
  3524                                  
  3525                                  ; Found the :.	Skip to first non-delimiter char
  3526                                  
  3527                                  CHKLABEL:
  3528 00000B44 E853FF                  		call	SKIPDELIM
  3529 00000B47 72F0                    		jb	short BADGOTO
  3530 00000B49 BF5D00                  		mov	di,FCB+1 ; 5Dh
  3531 00000B4C 2E8B0E[4F42]            		mov	cx,[cs:GOTOLEN]
  3532 00000B51 EB05                    		jmp	short GOTBYTE
  3533                                  NEXTCHRLP:
  3534 00000B53 51                      		push	cx
  3535 00000B54 E82DFD                  		call	GETBATBYT
  3536 00000B57 59                      		pop	cx
  3537                                  GOTBYTE:
  3538 00000B58 0C20                    		or	al,20h
  3539 00000B5A 263A05                  		cmp	al,[es:di]
  3540 00000B5D 7502                    		jnz	short TRYUPPER
  3541 00000B5F EB07                    		jmp	short NEXTLABCHR
  3542                                  TRYUPPER:
  3543 00000B61 2C20                    		sub	al,20h
  3544 00000B63 263A05                  		cmp	al,[es:di]
  3545 00000B66 75C9                    		jnz	short LABLKTST
  3546                                  NEXTLABCHR:
  3547 00000B68 47                      		inc	di
  3548 00000B69 E2E8                    		loop	NEXTCHRLP
  3549 00000B6B E816FD                  		call	GETBATBYT
  3550 00000B6E 2E833E[4F42]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3551 00000B74 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3552 00000B76 3C20                    		cmp	al,' '
  3553 00000B78 77B7                    		ja	short LABLKTST
  3554                                  GOTOCONT:
  3555 00000B7A 3C0D                    		cmp	al,0Dh
  3556 00000B7C 7407                    		jz	short SKIPLFEED
  3557                                  TONEXTBATLIN:
  3558 00000B7E E803FD                  		call	GETBATBYT
  3559 00000B81 3C0D                    		cmp	al,0Dh
  3560 00000B83 75F9                    		jnz	short TONEXTBATLIN
  3561                                  SKIPLFEED:
  3562 00000B85 E8FCFC                  		call	GETBATBYT
  3563                                  
  3564                                  		; MSDOS 6.0
  3565                                  ;SR;
  3566                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3567                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3568                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3569                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3570                                  ;all other cases, EOF will be hit while trying to read the next line and
  3571                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3572                                  ;
  3573                                  		;push	es
  3574                                  		;mov	es,Batch
  3575                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3576                                  		;pop	es
  3577                                  
  3578                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3579 00000B88 E80100                  		call	BATCLOSE
  3580 00000B8B C3                      		retn
  3581                                  
  3582                                  ; =============== S U B	R O U T	I N E =======================================
  3583                                  
  3584                                  BATCLOSE:
  3585 00000B8C 2E8B1E[7A44]            		mov	bx,[cs:BATHAND]
  3586 00000B91 83FB05                  		cmp	bx,5
  3587 00000B94 7204                    		jb	short CLOSERETURN
  3588 00000B96 B43E                    		mov	ah,CLOSE ; 3Eh
  3589 00000B98 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3590                                  				; BX = file handle
  3591                                  CLOSERETURN:
  3592 00000B9A C606CC0B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3593 00000B9F C3                      		retn
  3594                                  
  3595                                  ; =============== S U B	R O U T	I N E =======================================
  3596                                  
  3597                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3598                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3599                                  
  3600                                  BATOPEN:
  3601 00000BA0 1E                      		push	ds
  3602 00000BA1 8E1E810B                		mov	ds,[BATCH]
  3603                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3604 00000BA5 BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3605 00000BA8 B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3606 00000BAB CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3607                                  				; DS:DX	-> ASCIZ filename
  3608                                  				; AL = access mode
  3609                                  				; 0 - read
  3610 00000BAD 721C                    		jb	short SETERRDL
  3611 00000BAF 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3612 00000BB3 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3613 00000BB7 1F                      		pop	ds
  3614 00000BB8 2EA3[7A44]              		mov	[cs:BATHAND],ax
  3615 00000BBC 89C3                    		mov	bx,ax
  3616 00000BBE B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3617 00000BC1 CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3618                                  				; AL = method: offset from beginning of	file
  3619                                  
  3620 00000BC3 2EC706[FE4B]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3621                                  BATOPEN_RETN:
  3622 00000BCA C3                      		retn
  3623                                  
  3624                                  SETERRDL:
  3625 00000BCB 89D3                    		mov	bx,dx
  3626                                  		; MSDOS 6.0
  3627                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3628                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3629                                  
  3630                                  		; MSDOS 3.3
  3631 00000BCD BA[AE36]                		mov	dx,INSERTDSKPTR
  3632 00000BD0 E8A212                  		call	GET_EXT_ERR_NUMBER
  3633                                  
  3634                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3635 00000BD3 8A07                    		mov	al,[bx]		; Get drive spec
  3636 00000BD5 2C40                    		sub	al,'@'		; A = 1
  3637 00000BD7 1F                      		pop	ds
  3638 00000BD8 F9                      		stc			; SUB mucked over carry
  3639 00000BD9 C3                      		retn
  3640                                  
  3641                                  ;============================================================================
  3642                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3643                                  ;============================================================================
  3644                                  ; 10/10/2018 - Retro DOS v3.0
  3645                                  
  3646                                  ; All batch proccessing has DS set to segment of resident portion
  3647                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3648                                  
  3649                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3650                                  
  3651                                  ; ---------------------------------------------------------------------------
  3652                                  
  3653                                  FORTERM:
  3654                                  		; MSDOS 6.0
  3655                                  		;push	cs		;AN037; Get local segment into
  3656                                  		;pop	ds		;AN037;    DS, ES
  3657                                  		;push	cs		;AN037;
  3658                                  		;pop	es		;AN037;
  3659                                  
  3660                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3661 00000BDA E8A402                  		call	FOROFF
  3662 00000BDD 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  3663 00000BE2 813EDD0B00FF            		cmp	word [SINGLECOM],0FF00h
  3664 00000BE8 750F                    		jne	short BAT_CRLF
  3665 00000BEA 833EE60B00              		cmp	word [NEST],0	;See if we have nested batch files
  3666 00000BEF 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3667 00000BF1 C706DD0BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3668 00000BF7 EB12                    		jmp	short NOFORP2
  3669                                  BAT_CRLF:
  3670 00000BF9 F606D70B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3671 00000BFE 740B                    		jz	short NOFORP2	; no - exit
  3672 00000C00 F706810BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3673 00000C06 7403                    		jz	short NOFORP2
  3674 00000C08 E82A0D                  		call	CRLF2
  3675                                  NOFORP2:
  3676 00000C0B E9F6F4                  		jmp	TCOMMAND
  3677                                  
  3678                                  ; ---------------------------------------------------------------------------
  3679                                  
  3680                                  ;------
  3681                                  ;   For-loop processing.  For loops are of the form:
  3682                                  ;	    for %<loop-variable> in (<list>) do <command>
  3683                                  ; where <command> may contain references of the form %<variable>, which are
  3684                                  ; later substituted with the items in <list>. The for-loop structure is
  3685                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3686                                  ; <command> once for each item in <list>. All of the information needed for
  3687                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3688                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3689                                  ; a complete copy of the original command-line structure as parsed by
  3690                                  ; 'parseline', loop control variables, and a dma buffer for the
  3691                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3692                                  ; processing has completed, this chunk of memory is returned to the system.
  3693                                  ;
  3694                                  ;   All of the previously defined variables, in 'datares', used for loop
  3695                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3696                                  ;
  3697                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3698                                  ; containing all of the other error messages.
  3699                                  ;
  3700                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3701                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3702                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3703                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3704                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3705                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3706                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3707                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3708                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3709                                  ; instead of
  3710                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3711                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3712                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3713                                  ; doesn't matter whether we put brackets around the location or not -- the
  3714                                  ; assembler is "smart" enough to know that we want an address instead of the
  3715                                  ; contents of that location.
  3716                                  ;
  3717                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3718                                  ; One method would be to have a link field in each for-structure pointing to
  3719                                  ; its parent.  Variable references that couldn't be resolved in the local
  3720                                  ; frame would cause a search of prior frames. For-structures would still be
  3721                                  ; allocated and released in exactly the same fashion. The only limit on the
  3722                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3723                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3724                                  ; maintained in the resident data area. This structure would be an array of
  3725                                  ; control-variable names and pointers to for-structure blocks. This would
  3726                                  ; greatly speed up the resolution of non-local variable references. However,
  3727                                  ; since space in the resident is precious, we would have to compromise on a
  3728                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3729                                  ; allocation and de-allocation would have to be modified slightly to take this
  3730                                  ; new structure into account.
  3731                                  ;
  3732                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3733                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3734                                  ; it may be easier to allocate it as part of 'for_segment'.
  3735                                  ;------
  3736                                  
  3737                                  		; include fordata.asm
  3738                                  
  3739                                  ; Data structure definitions included by tfor.asm
  3740                                  
  3741                                  struc FOR_INFO
  3742 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3743 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
  3744 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3745 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
  3746 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
  3747 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
  3748 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
  3749 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
  3750                                    .size:
  3751                                  endstruc
  3752                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3753                                  _$FOR_EXIT:
  3754 00000C0E EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3755                                  
  3756                                  ; ---------------------------------------------------------------------------
  3757                                  
  3758                                  FORPROC:
  3759 00000C10 A1E40B                  		mov	ax,[FORPTR]
  3760 00000C13 8ED8                    		mov	ds,ax
  3761 00000C15 8EC0                    		mov	es,ax		; operate in for-info area
  3762 00000C17 BACB05                  		mov	dx,FOR_INFO.FORDMA
  3763 00000C1A B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3764 00000C1D CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3765                                  				; DS:DX	-> disk	transfer buffer
  3766                                  FOR_BEGIN:
  3767 00000C1F 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3768 00000C24 7404                    		jz	short FOR_BEGIN1
  3769                                  					; non-zero for_expand equals FALSE
  3770 00000C26 FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3771                                  
  3772                                  FOR_BEGIN1:
  3773 00000C2A 8B1E4705                		mov	bx,[FOR_INFO.FOR_MINARG]
  3774                                  					; current item in <list> to examine
  3775 00000C2E 3B1E4905                		cmp	bx,[FOR_INFO.FOR_MAXARG]	; [549h]
  3776 00000C32 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3777                                  		;mov	ax,0
  3778 00000C34 B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3779 00000C37 E81018                  		call	ARGV_CALC	; compute argv[x] address
  3780                                  		;mov	cx,[bx+3]
  3781 00000C3A 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3782 00000C3D 8B17                    		mov	dx,[bx]
  3783                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3784                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3785 00000C3F F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3786 00000C43 7514                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3787 00000C45 8B37                    		mov	si,[bx]
  3788                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3789                                  
  3790                                  		;mov	al,[cs:LPAREN]
  3791                                  		; 01/03/2023
  3792 00000C47 B028                    		mov	al,lparen ; '('
  3793 00000C49 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3794 00000C4C 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3795 00000C4E 41                      		inc	cx		;  the opening paren as its first char,
  3796                                  					;  the argstartel ptr needs to be
  3797                                  					;  advanced passed it before the prefix
  3798                                  					;  length is computed.
  3799 00000C4F B03A                    		mov	al,':'
  3800 00000C51 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3801 00000C54 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3802 00000C56 83C102                  		add	cx,2		;  rest of the prefix as well.
  3803                                  FORSUB:
  3804 00000C59 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3805 00000C5B 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3806 00000C60 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3807                                  		;test	byte [bx+2],2
  3808 00000C62 F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3809 00000C66 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3810                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3811 00000C68 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3812 00000C6B EB1F                    		jmp	short FOR_SMOOSH
  3813                                  
  3814                                  		;nop
  3815                                  FOR_FIND_FIRST:
  3816 00000C6D 51                      		push	cx
  3817 00000C6E 31C9                    		xor	cx,cx
  3818 00000C70 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3819 00000C73 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3820                                  				; CX = search attributes
  3821                                  				; DS:DX	-> ASCIZ filespec
  3822                                  				; (drive,path, and wildcards allowed)
  3823 00000C75 59                      		pop	cx
  3824 00000C76 EB05                    		jmp	short FOR_RESULT
  3825                                  
  3826                                  		;nop
  3827                                  FOR_FIND_NEXT:
  3828 00000C78 B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3829 00000C7B CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3830                                  				; [DTA]	= data block from
  3831                                  				; last AH = 4Eh/4Fh call
  3832                                  FOR_RESULT:
  3833 00000C7D B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3834 00000C80 7203                    		jc	short FOR_CHECK
  3835 00000C82 B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3836                                  FOR_CHECK:				; record success of findfirst/next
  3837 00000C85 A34505                  		mov	[FOR_INFO.FOR_EXPAND],ax
  3838 00000C88 09C0                    		or	ax,ax	; anything out there?
  3839 00000C8A 7593                    		jnz	short FOR_BEGIN	; if not, try next arg
  3840                                  FOR_SMOOSH:
  3841                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3842 00000C8C 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3843 00000C8E BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3844 00000C91 F3A4                    		rep movsb		; arg, some days just the path prefix
  3845                                  					
  3846 00000C93 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3847                                  					; if we're not expanding, we can
  3848 00000C98 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3849                                  
  3850                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3851 00000C9A BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3852                                  FOR_MORE:
  3853 00000C9D 803C00                  		cmp	byte [si],0	; tack on matching filename
  3854 00000CA0 7403                    		jz	short FOR_MAKE_COM
  3855 00000CA2 A4                      		movsb
  3856 00000CA3 75F8                    		jnz	short FOR_MORE
  3857                                  FOR_MAKE_COM:
  3858 00000CA5 30C0                    		xor	al,al		; tack a null byte onto the end
  3859 00000CA7 AA                      		stosb			; of the substitute string
  3860 00000CA8 31C9                    		xor	cx,cx		; character count for command line
  3861 00000CAA F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3862 00000CAC 31DB                    		xor	bx,bx		; argpointer
  3863 00000CAE BF[B73F]                		mov	di,COMBUF+2
  3864 00000CB1 8A1E4405                		mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
  3865 00000CB5 8A364B06                		mov	dh,[FOR_INFO.FOR_VAR] 
  3866                                  					; %<for-var> is replaced by [forbuf]
  3867 00000CB9 0E                      		push	cs		; time to form the <command> string
  3868 00000CBA 07                      		pop	es
  3869                                  		;assume ES:trangroup
  3870                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3871 00000CBB B80000                  		mov	ax,0		; translate offset to pointer
  3872 00000CBE E88917                  		call	ARGV_CALC
  3873                                  		;mov	si,[bx+9]
  3874 00000CC1 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3875                                  					; mov ptr passed beginning space
  3876 00000CC4 46                      		inc	si
  3877                                  FOR_MAKE_LOOP:
  3878 00000CC5 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3879 00000CC7 46                      		inc	si
  3880 00000CC8 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3881 00000CCA 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3882 00000CCC 3834                    		cmp	[si],dh		; got the right <variable>?
  3883 00000CCE 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3884 00000CD0 46                      		inc	si		; skip over <for-variable>
  3885                                  
  3886 00000CD1 56                      		push	si
  3887 00000CD2 BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3888                                  					; to make a final <command> to execute
  3889                                  SLOOP:					
  3890 00000CD5 AC                      		lodsb			; grab all those <item> bytes, and
  3891 00000CD6 AA                      		stosb			; add 'em to the <command> string,
  3892 00000CD7 08C0                    		or	al,al		; until we run into a null
  3893 00000CD9 E0FA                    		loopne	SLOOP
  3894 00000CDB 4F                      		dec	di		; adjust length and <command> pointer
  3895 00000CDC 41                      		inc	cx		; so we can overwrite the null
  3896 00000CDD 5E                      		pop	si
  3897 00000CDE EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3898                                  FOR_STOSB:
  3899 00000CE0 AA                      		stosb			; take a byte from the <command> arg
  3900 00000CE1 49                      		dec	cx		; and put it into the <command> to be
  3901                                  					; executed (and note length, too)
  3902 00000CE2 3C0D                    		cmp	al,0Dh		
  3903 00000CE4 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3904                                  FOR_MADE_COM:
  3905 00000CE6 F6D1                    		not	cl
  3906 00000CE8 2E880E[B63F]            		mov	[cs:COMBUF+1],cl
  3907                                  
  3908 00000CED 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  3909                                  		;assume DS:resgroup
  3910 00000CF2 F606D70B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3911 00000CF7 742F                    		jz	short NOECHO3
  3912                                  		;cmp	byte [NULLFLAG],nullcommand
  3913 00000CF9 803EEC0B01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3914 00000CFE 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3915                                  
  3916 00000D00 E8320C                  		call	CRLF2		  ;G  Print out prompt
  3917                                  NO_CRLF_PR:
  3918 00000D03 C606EC0B00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3919 00000D08 0E                      		push	cs
  3920 00000D09 1F                      		pop	ds
  3921 00000D0A 57                      		push	di
  3922 00000D0B E85C06                  		call	PRINT_PROMPT	  ;G Prompt the user
  3923 00000D0E 5F                      		pop	di
  3924                                  
  3925 00000D0F 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3926 00000D14 C706[3343][B73F]        		mov	word [STRING_PTR_2],COMBUF+2
  3927 00000D1A BA[4F36]                		mov	dx,STRINGBUF2PTR
  3928 00000D1D E8F426                  		call	STD_PRINTF
  3929 00000D20 26C645FF0D              		mov	byte [es:di-1],0Dh
  3930 00000D25 E982F5                  		jmp	DOCOM		  ; run silent, run deep...
  3931                                  NOECHO3:
  3932 00000D28 C606EC0B00              		mov	byte [NULLFLAG],0
  3933 00000D2D 0E                      		push	cs
  3934 00000D2E 1F                      		pop	ds
  3935 00000D2F E97BF5                  		jmp	DOCOM1
  3936                                  
  3937                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3938 00000D32 E84C01                  		call	FOROFF
  3939 00000D35 E92F01                  		jmp	FORNESTERR
  3940                                  
  3941                                  ; ---------------------------------------------------------------------------
  3942                                  
  3943                                  FORERRORJ:
  3944 00000D38 E9E5FB                  		jmp	FORERROR
  3945                                  
  3946                                  ; ---------------------------------------------------------------------------
  3947                                  
  3948                                  _$FOR:
  3949 00000D3B 8E06[5641]              		mov	es,[RESSEG]
  3950 00000D3F 26803EE30B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3951 00000D45 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3952                                  
  3953                                  ; Turn off any pipes in progress.
  3954                                  
  3955 00000D47 26803E450C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3956 00000D4D 7403                    		jz	short NO_PIPE
  3957 00000D4F E86F11                  		call	PIPEDEL
  3958                                  NO_PIPE:
  3959 00000D52 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3960 00000D54 E8FA00                  		call	NEXTARG		; move to next argv[n]
  3961 00000D57 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3962 00000D59 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3963 00000D5B 75DB                    		jnz	short FORERRORJ
  3964 00000D5D 89C5                    		mov	bp,ax		; save forloop variable
  3965 00000D5F AC                      		lodsb
  3966 00000D60 08C0                    		or	al,al		; and MUST end immediately...
  3967 00000D62 75D4                    		jnz	short FORERRORJ
  3968 00000D64 E8EA00                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3969 00000D67 72CF                    		jb	short FORERRORJ
  3970                                  		;and	ax,0DFDFh
  3971 00000D69 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3972                                  		;cmp	ax,[IN_WORD]
  3973                                  		; 01/03/2023
  3974 00000D6C 3D494E                  		cmp	ax,in_word ; cmp ax,'IN'
  3975 00000D6F 75C7                    		jnz	short FORERRORJ
  3976 00000D71 AC                      		lodsb
  3977                                  
  3978                                  		; MSDOS 3.3
  3979 00000D72 08C0                    		or	al,al		; it, too, must end right away
  3980 00000D74 7414                    		jz	short CHECKLPAREN
  3981                                  		;cmp	al,[LPAREN]
  3982                                  		; 01/03/2023
  3983 00000D76 3C28                    		cmp	al,lparen ; '('
  3984 00000D78 75BE                    		jnz	short FORERRORJ
  3985                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3986 00000D7A 830702                  		add	word [bx],2
  3987                                  		;add	word [bx+9],2
  3988 00000D7D 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3989                                  		;sub	word [bx+5],2
  3990 00000D81 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3991 00000D85 8B44FF                  		mov	ax,[si-1]
  3992 00000D88 EB05                    		jmp	short LPCHECK
  3993                                  
  3994                                  		; MSDOS 6.0
  3995                                  ;; Compaq bug fix -- exit from this loop on error
  3996                                  ;
  3997                                  ;		or	al,al
  3998                                  ;		jne	forerrorj	; jump on error
  3999                                  ;
  4000                                  ;;;		je	CheckLParen
  4001                                  ;;
  4002                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  4003                                  ;;   FOR %i in(foo bar...
  4004                                  ;; Check for the Lparen here
  4005                                  ;;
  4006                                  ;;;		CMP	AL,lparen
  4007                                  ;;;		JNZ	forerrorj
  4008                                  ;;
  4009                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  4010                                  ;; being there in the first place.
  4011                                  ;;
  4012                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  4013                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  4014                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  4015                                  ;;
  4016                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  4017                                  ;; current value.
  4018                                  ;;
  4019                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  4020                                  ;;;		jmp	short lpcheck
  4021                                  ;;
  4022                                  ;; end of Compaq bug fix
  4023                                  
  4024                                  ; ---------------------------------------------------------------------------
  4025                                  
  4026                                  		; MSDOS 3.3 (& MSDOS 6.0)
  4027                                  CHECKLPAREN:
  4028 00000D8A E8C400                  		call	NEXTARG		; lparen delimits beginning of <list>
  4029 00000D8D 72A9                    		jc	short FORERRORJ
  4030                                  LPCHECK:
  4031                                  		;cmp	al,[LPAREN]
  4032                                  		; 01/03/2023
  4033 00000D8F 3C28                    		cmp	al,lparen ; '('
  4034 00000D91 75A5                    		jne	short FORERRORJ
  4035                                  		;cmp	ah,0
  4036                                  		;je	short FOR_PAREN_TOKEN
  4037 00000D93 08E4                    		or	ah,ah ; 0 ?
  4038 00000D95 7408                    		jz	short FOR_PAREN_TOKEN
  4039                                  		;cmp	ah,[RPAREN]	; special case:  null list	
  4040 00000D97 80FC29                  		cmp	ah,rparen ; ')'
  4041 00000D9A 7510                    		jne	short FOR_LIST_NOT_EMPTY
  4042 00000D9C E93BFE                  		jmp	FORTERM
  4043                                  
  4044                                  		; 01/03/2023
  4045                                  FOR_PAREN_TOKEN:
  4046 00000D9F E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4047 00000DA2 7294                    		jc	short FORERRORJ
  4048                                  		;
  4049                                  		;;cmp	ax,[RPAREN+1]	
  4050                                  		;cmp	ax,[NULLRPAREN]	; special case: null list
  4051                                  		; 01/03/2023
  4052 00000DA4 83F829                  		cmp	ax,nullrparen ; 0029h  ; db ')',0
  4053 00000DA7 7509                    		jne	short FOR_LIST
  4054 00000DA9 E92EFE                  		jmp	FORTERM
  4055                                  
  4056                                  FOR_LIST_NOT_EMPTY:
  4057                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4058 00000DAC FF07                    		inc	word [bx]	; Advance ptr past "("
  4059                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4060 00000DAE FF4F05                  		dec	word [bx+ARGV_ELE.arglen] ; to agree.
  4061 00000DB1 46                      		inc	si		; Inc si so check for ")" works
  4062                                  		; 01/03/2023
  4063                                  		;jmp	short FOR_LIST ;-->
  4064                                  
  4065                                  		;nop
  4066                                  
  4067                                  		; 01/03/2023
  4068                                  ;FOR_PAREN_TOKEN:
  4069                                  		;call	NEXTARG		; what have we in our <list>?
  4070                                  		;jc	short FORERRORJ
  4071                                  		;;;cmp	ax,[RPAREN+1]	
  4072                                  		;;cmp	ax,[NULLRPAREN]	; special case: null list
  4073                                  		;cmp	ax,nullrparen ; 0029h  ; db ')',0
  4074                                  		;jne	short FOR_LIST
  4075                                  		;jmp	FORTERM
  4076                                  		; 01/03/2023
  4077                                  ;FORERORJJ:
  4078                                  		;jmp	FORERROR
  4079                                  ; -->
  4080                                  FOR_LIST:				; skip over rest of <list>
  4081 00000DB2 89D1                    		mov	cx,dx		; first arg of <list>
  4082                                  
  4083                                  SKIP_LIST:
  4084                                  		;add	si,[bx+5]
  4085 00000DB4 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4086 00000DB7 83EE03                  		sub	si,3		; si = ptr to last char of token
  4087                                  		;mov	al,[RPAREN]
  4088                                  		; 01/03/2023
  4089 00000DBA B029                    		mov	al,rparen ; ')'
  4090 00000DBC 3804                    		cmp	[si],al		; Is this the last element in <list>
  4091 00000DBE 7408                    		je	short FOR_END_LIST ; Yes, exit loop.
  4092 00000DC0 E88E00                  		call	NEXTARG		; No, get next arg <list>
  4093                                  		;jc	short FORERORJJ	; If no more and no rparen, error.
  4094                                  		;jmp	short SKIP_LIST
  4095                                  		; 01/03/2023
  4096 00000DC3 73EF                    		jnc	short SKIP_LIST
  4097                                  FORERORJJ:
  4098 00000DC5 E958FB                  		jmp	FORERROR
  4099                                  FOR_END_LIST:
  4100 00000DC8 89D7                    		mov	di,dx		; record position of last arg in <list>
  4101 00000DCA C60400                  		mov	byte [si],0	; Zap the rparen
  4102                                  		;;cmp	ax,[RPAREN+1]	
  4103                                  		;cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4104 00000DCD 83F829                  		cmp	ax,nullrparen ; 0029h  ; db ')',0
  4105 00000DD0 7401                    		je	short FOR_DO	; Yes, continue
  4106 00000DD2 47                      		inc	di		; No, inc position of last arg
  4107                                  FOR_DO:
  4108 00000DD3 E87B00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4109 00000DD6 72ED                    		jc	short FORERORJJ
  4110                                  		;and	ax,0DFDFh	
  4111 00000DD8 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4112                                  		;cmp	ax,[DO_WORD]
  4113                                  		; 01/03/2023
  4114 00000DDB 3D444F                  		cmp	ax,do_word ; cmp ax,'DO'
  4115 00000DDE 75E5                    		jne	short FORERORJJ
  4116 00000DE0 AC                      		lodsb
  4117 00000DE1 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4118 00000DE3 75E0                    		jnz	short FORERORJJ
  4119                                  		
  4120 00000DE5 E86900                  		call	NEXTARG		; on to the beginning of <command>
  4121 00000DE8 72DB                    		jc	short FORERORJJ	; null <command> not legal
  4122                                  
  4123 00000DEA 50                      		push	ax
  4124 00000DEB 53                      		push	bx
  4125 00000DEC 51                      		push	cx
  4126 00000DED 52                      		push	dx		; preserve registers against disaster
  4127 00000DEE 57                      		push	di
  4128 00000DEF 56                      		push	si
  4129 00000DF0 55                      		push	bp
  4130 00000DF1 E867F8                  		call	FREE_TPA	; need to make free memory, first
  4131 00000DF4 E88A00                  		call	FOROFF
  4132                                  		;mov	bx,264
  4133 00000DF7 BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4134 00000DFA E82A19                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4135 00000DFD 9C                      		pushf
  4136 00000DFE 26A3E40B                		mov	[es:FORPTR],ax
  4137 00000E02 E866F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4138 00000E05 9D                      		popf
  4139 00000E06 5D                      		pop	bp
  4140 00000E07 5E                      		pop	si
  4141 00000E08 5F                      		pop	di
  4142 00000E09 5A                      		pop	dx
  4143 00000E0A 59                      		pop	cx
  4144 00000E0B 5B                      		pop	bx
  4145 00000E0C 58                      		pop	ax
  4146 00000E0D 723C                    		jc	short FOR_ALLOC_ERR
  4147                                  
  4148 00000E0F 06                      		push	es		; save resgroup seg...
  4149 00000E10 26FF36E40B              		push	word [es:FORPTR]
  4150 00000E15 07                      		pop	es
  4151                                  		;assume ES:for_segment	
  4152 00000E16 49                      		dec	cx		; forproc wants min pointing before
  4153 00000E17 4F                      		dec	di		; first arg, max right at last one
  4154 00000E18 26890E4705              		mov	[es:FOR_INFO.FOR_MINARG],cx
  4155 00000E1D 26893E4905              		mov	[es:FOR_INFO.FOR_MAXARG],di
  4156 00000E22 2688164405              		mov	[es:FOR_INFO.FOR_COM_START],dl
  4157 00000E27 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4158 00000E2E 89E8                    		mov	ax,bp
  4159 00000E30 2688264B06              		mov	[es:FOR_INFO.FOR_VAR],ah
  4160 00000E35 07                      		pop	es
  4161                                  		;assume ES:resgroup	
  4162 00000E36 26FE06E30B              		inc	byte [es:FORFLAG]
  4163 00000E3B 26833EDD0BFF            		cmp	word [es:SINGLECOM],-1
  4164 00000E41 7507                    		jne	short FOR_RET
  4165 00000E43 26C706DD0B00FF          		mov	word [es:SINGLECOM],0FF00h
  4166                                  FOR_RET:
  4167 00000E4A C3                      		retn
  4168                                  
  4169                                  FOR_ALLOC_ERR:
  4170                                  		; MSDOS 3.3
  4171 00000E4B BA[BA3B]                		mov	dx,INSFMEMMESPTR
  4172 00000E4E E9950D                  		jmp	CERROR
  4173                                  
  4174                                  		; MSDOS 6.0
  4175                                  		;mov	msg_disp_class,ext_msg_class	
  4176                                  		;			;AN000; set up extended error msg class
  4177                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4178                                  		;			;AC000; get extended message pointer
  4179                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4180                                  		;			;AN000; get message number in control block
  4181                                  		;jmp	cerror
  4182                                  
  4183                                  
  4184                                  ; =============== S U B	R O U T	I N E =======================================
  4185                                  
  4186                                  NEXTARG:
  4187 00000E51 42                      		inc	dx		; next argv[n]
  4188                                  		;cmp	dx,[ARG_ARGVCNT]
  4189 00000E52 3B16[4E47]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4190 00000E56 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4191 00000E58 89D3                    		mov	bx,dx
  4192                                  		;mov	ax,ARG_ARGV
  4193                                  		;mov	ax,ARG+ARG_UNIT.argv
  4194 00000E5A B8[8E44]                		mov	ax,ARG
  4195 00000E5D E8EA15                  		call	ARGV_CALC	; convert array index to pointer
  4196 00000E60 8B37                    		mov	si,[bx]		; load pointer to argstring
  4197                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4198 00000E62 AD                      		lodsw			; and load first two chars
  4199 00000E63 F8                      		clc
  4200 00000E64 C3                      		retn
  4201                                  NEXTARG_ERR:
  4202 00000E65 F9                      		stc
  4203 00000E66 C3                      		retn
  4204                                  
  4205                                  ; ---------------------------------------------------------------------------
  4206                                  
  4207                                  FORNESTERR:
  4208 00000E67 1E                      		push	ds
  4209 00000E68 8E1E[5641]              		mov	ds,[RESSEG]
  4210                                  		;ASSUME DS:RESGROUP
  4211 00000E6C BA[A23B]                		mov	dx,FORNESTMESTR
  4212 00000E6F 813EDD0B00FF            		cmp	word [SINGLECOM],0FF00h
  4213 00000E75 7506                    		jnz	short NOFORP3
  4214 00000E77 C706DD0BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4215                                  NOFORP3:
  4216 00000E7D 1F                      		pop	ds
  4217 00000E7E E9650D                  		jmp	CERROR
  4218                                  
  4219                                  ; =============== S U B	R O U T	I N E =======================================
  4220                                  
  4221                                  ; General routine called to free the for segment. We also clear the forflag
  4222                                  ; too. Change no registers.
  4223                                  
  4224                                  FOROFF:
  4225 00000E81 50                      		push	ax
  4226 00000E82 06                      		push	es
  4227 00000E83 2E8E06[5641]            		mov	es,[cs:RESSEG]
  4228 00000E88 26A1E40B                		mov	ax,[es:FORPTR]
  4229 00000E8C 09C0                    		or	ax,ax
  4230 00000E8E 7408                    		jz	short FREEDONE
  4231 00000E90 06                      		push	es
  4232 00000E91 8EC0                    		mov	es,ax
  4233 00000E93 B449                    		mov	ah,DEALLOC ; 49h
  4234 00000E95 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4235                                  				; ES = segment address of area to be freed
  4236 00000E97 07                      		pop	es
  4237                                  FREEDONE:
  4238 00000E98 26C706E40B0000          		mov	word [es:FORPTR],0
  4239 00000E9F 26C606E30B00            		mov	byte [es:FORFLAG],0
  4240 00000EA5 07                      		pop	es
  4241 00000EA6 58                      		pop	ax
  4242 00000EA7 C3                      		retn
  4243                                  
  4244                                  ;============================================================================
  4245                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4246                                  ;============================================================================
  4247                                  ; 09/10/2018 - Retro DOS v3.0
  4248                                  
  4249                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4250                                  
  4251                                  ; ---------------------------------------------------------------------------
  4252                                  
  4253                                  ; The DIR command displays the contents of a directory.
  4254                                  ;
  4255                                  ; ****************************************************************
  4256                                  ; *
  4257                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4258                                  ; *
  4259                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4260                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4261                                  ; *		 If an error occurs issue and error message and
  4262                                  ; *		 transfer control to CERROR.
  4263                                  ; *
  4264                                  ; * INPUT:	 command line at offset 81H
  4265                                  ; *
  4266                                  ; * OUTPUT:	 none
  4267                                  ; *
  4268                                  ; ****************************************************************
  4269                                  
  4270                                  CATALOG:
  4271                                  		; MSDOS 3.3
  4272                                  
  4273                                  		;mov	ax,ARG_ARGV
  4274                                  		;mov	ax,ARG+ARG_UNIT.argv
  4275 00000EA8 B8[8E44]                		mov	ax,ARG
  4276 00000EAB BAFFFF                  		mov	dx,0FFFFh
  4277 00000EAE 31C9                    		xor	cx,cx
  4278 00000EB0 31F6                    		xor	si,si
  4279                                  DIR1:
  4280                                  		;cmp	cx,[ARG_ARGVCNT]
  4281 00000EB2 3B0E[4E47]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4282 00000EB6 733D                    		jnb	short DIR6 ; No more arguments
  4283 00000EB8 89CB                    		mov	bx,cx
  4284 00000EBA E88D15                  		call	ARGV_CALC
  4285                                  		;or	si,[bx+7]
  4286 00000EBD 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4287 00000EC0 F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4288 00000EC4 7529                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4289                                  		;test	byte [bx+2],1
  4290 00000EC6 F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4291                                  		;jz	short DIR3
  4292                                  		;jmp	short DIR5
  4293                                  		; 02/03/2023
  4294 00000ECA 7520                    		jnz	short DIR5
  4295                                  ; 02/03/2023
  4296                                  ;DIR2:
  4297                                  ;		mov	dx,BADPARMPTR
  4298                                  ;		jmp	CERROR
  4299                                  DIR3:
  4300 00000ECC 09C9                    		or	cx,cx
  4301 00000ECE 7515                    		jnz	short DIR4	
  4302                                  		;cmp	word [bx+5],3
  4303 00000ED0 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4304 00000ED4 7416                    		jz	short DIR5
  4305                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4306 00000ED6 830703                  		add	word [bx],3
  4307                                  		;add	word [bx+9],3
  4308 00000ED9 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4309                                  		;add	word [bx+3],3
  4310 00000EDD 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4311                                  		;sub	word [bx+5],3
  4312 00000EE1 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4313                                  DIR4:
  4314 00000EE5 83FAFF                  		cmp	dx,0FFFFh
  4315 00000EE8 7505                    		jnz	short DIR2
  4316 00000EEA 89DA                    		mov	dx,bx
  4317                                  DIR5:		
  4318 00000EEC 41                      		inc	cx
  4319 00000EED EBC3                    		jmp	short DIR1
  4320                                  
  4321                                  		; 02/03/2023
  4322                                  DIR2:
  4323 00000EEF BA[3239]                		mov	dx,BADPARMPTR
  4324 00000EF2 E9F10C                  		jmp	CERROR
  4325                                  DIR6:
  4326 00000EF5 8936[6D41]              		mov	[COMSW],si
  4327 00000EF9 52                      		push	dx
  4328 00000EFA 30C0                    		xor	al,al
  4329 00000EFC 83FAFF                  		cmp	dx,0FFFFh
  4330 00000EFF 7410                    		jz	short DIR7
  4331 00000F01 89D3                    		mov	bx,dx
  4332                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4333 00000F03 8B3F                    		mov	di,[bx]
  4334 00000F05 807D013A                		cmp	byte [di+1],':'
  4335 00000F09 7506                    		jnz	short DIR7
  4336 00000F0B 8A05                    		mov	al,[di]
  4337 00000F0D 0C20                    		or	al,20h		; Lowercase drive name	
  4338 00000F0F 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4339                                  DIR7:
  4340                                  		;mov	[5CH],al
  4341 00000F11 A25C00                  		mov	[FCB],al
  4342 00000F14 E80604                  		call	OKVOLARG
  4343 00000F17 B03F                    		mov	al,'?'		; *.* is default file spec.
  4344                                  		;mov	di,5Dh
  4345 00000F19 BF5D00                  		mov	di,FCB+1
  4346 00000F1C B90B00                  		mov	cx,11
  4347 00000F1F F3AA                    		rep stosb
  4348                                  
  4349                                  ; Begin by processing any switches that may have been specified.
  4350                                  ; BITS will contain any information about switches that was
  4351                                  ; found when the command line was parsed.
  4352                                  
  4353 00000F21 A1[6D41]                		mov	ax,[COMSW]	; Get switches from command
  4354 00000F24 A3[A142]                		mov	[_BITS],ax	; initialize switches
  4355 00000F27 C706[6D41]0000          		mov	word [COMSW],0	; initialize flags
  4356 00000F2D C606[A942]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4357                                  		;test	al,1
  4358 00000F32 A801                    		test	al,SWITCHW	; /W ?
  4359                                  		;mov	al,1
  4360 00000F34 B001                    		mov	al,NORMPERLIN
  4361 00000F36 7402                    		jz	short DIR8
  4362                                  		;mov	al,5
  4363 00000F38 B005                    		mov	al,WIDEPERLIN
  4364                                  DIR8:
  4365 00000F3A A2[7D41]                		mov	[LINLEN],al	; Set number of entries per line
  4366 00000F3D A2[7C41]                		mov	[LINCNT],al
  4367 00000F40 C706[7E41]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4368 00000F46 BA[4F42]                		mov	dx,DIRBUF
  4369 00000F49 B41A                    		mov	ah,SET_DMA ; 1Ah
  4370 00000F4B CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4371                                  				; DS:DX	-> disk	transfer buffer
  4372                                  		;mov	dl,[5Ch]
  4373 00000F4D 8A165C00                		mov	dl,[FCB]
  4374 00000F51 E8BB09                  		call	SAVUDIR
  4375 00000F54 5B                      		pop	bx
  4376 00000F55 83FBFF                  		cmp	bx,0FFFFh
  4377 00000F58 7415                    		jz	short DIR9
  4378                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4379 00000F5A 8B17                    		mov	dx,[bx]
  4380                                  
  4381                                  ; The user may have specified a device. Search for the path and see if the
  4382                                  ; attributes indicate a device.
  4383                                  
  4384 00000F5C B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4385 00000F5E CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4386                                  				; CX = search attributes
  4387                                  				; DS:DX	-> ASCIZ filespec
  4388                                  				; (drive,path, and wildcards allowed)
  4389 00000F60 720F                    		jc	short DIR10
  4390                                  				; Check device atrribute..
  4391                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4392                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4393                                  		; 14/10/2018
  4394                                  		;test	byte [DIRBUF+21],40h
  4395 00000F62 F606[6442]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4396 00000F67 7408                    		jz	short DIR10	; no, go do normal operation
  4397 00000F69 C706[6D41]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4398                                  DIR9:
  4399 00000F6F EB7B                    		jmp	short DOHEADER
  4400                                  DIR10:
  4401                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4402 00000F71 8B17                    		mov	dx,[bx]
  4403 00000F73 B43B                    		mov	ah,CHDIR ; 3Bh
  4404 00000F75 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4405                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4406 00000F77 7373                    		jnc	short DOHEADER
  4407                                  		;mov	si,[bx+3]
  4408 00000F79 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4409 00000F7C 39F2                    		cmp	dx,si
  4410 00000F7E 7449                    		jz	short DIR_NO_DRIVE
  4411 00000F80 30C9                    		xor	cl,cl
  4412 00000F82 860C                    		xchg	cl,[si]
  4413 00000F84 B43B                    		mov	ah,CHDIR ; 3Bh
  4414 00000F86 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4415                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4416 00000F88 860C                    		xchg	cl,[si]
  4417 00000F8A 733D                    		jnc	short DIR_NO_DRIVE
  4418 00000F8C 8A44FF                  		mov	al,[si-1]
  4419 00000F8F E8420A                  		call	PATHCHRCMP
  4420 00000F92 7514                    		jnz	short DIR11
  4421 00000F94 8A44FE                  		mov	al,[si-2]
  4422 00000F97 E83A0A                  		call	PATHCHRCMP
  4423 00000F9A 741E                    		jz	short DIR12
  4424 00000F9C 864CFF                  		xchg	cl,[si-1]
  4425 00000F9F B43B                    		mov	ah,CHDIR ; 3Bh
  4426 00000FA1 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4427                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4428 00000FA3 864CFF                  		xchg	cl,[si-1]
  4429 00000FA6 7321                    		jnc	short DIR_NO_DRIVE
  4430                                  DIR11:
  4431 00000FA8 B53A                    		mov	ch,':'
  4432 00000FAA 3A6CFF                  		cmp	ch,[si-1]
  4433 00000FAD 750B                    		jnz	short DIR12
  4434                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4435 00000FAF 8B0F                    		mov	cx,[bx]
  4436 00000FB1 87CE                    		xchg	cx,si
  4437 00000FB3 29F1                    		sub	cx,si
  4438 00000FB5 83F902                  		cmp	cx,2
  4439 00000FB8 740F                    		jz	short DIR_NO_DRIVE
  4440                                  DIR12:
  4441 00000FBA BA[863A]                		mov	dx,BADCDPTR
  4442                                  		;test	byte [bx+2],4
  4443 00000FBD F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4444 00000FC1 7503                    		jnz	short DIRERROR
  4445                                  DIRNF:
  4446 00000FC3 BA[0837]                		mov	dx,FNOTFOUNDPTR
  4447                                  DIRERROR:
  4448 00000FC6 E91D0C                  		jmp	CERROR
  4449                                  DIR_NO_DRIVE:
  4450 00000FC9 813C2E2E                		cmp	word [si],'..'
  4451 00000FCD 750C                    		jnz	short DOREALPARSE
  4452 00000FCF 807C0200                		cmp	byte [si+2],0
  4453 00000FD3 7506                    		jnz	short DOREALPARSE
  4454 00000FD5 FF06[6D41]              		inc	word [COMSW]
  4455 00000FD9 EB11                    		jmp	short DOHEADER
  4456                                  DOREALPARSE:
  4457 00000FDB BF5C00                  		mov	di,FCB ; 5Ch	
  4458                                  		;mov	ax,290Eh
  4459 00000FDE B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4460 00000FE1 CD21                    		int	21h	; DOS -	PARSE FILENAME
  4461                                  				; DS:SI	-> string to parse
  4462                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4463                                  				; AL = bit mask	to control parsing
  4464 00000FE3 803C00                  		cmp	byte [si],0
  4465 00000FE6 7404                    		jz	short DOHEADER
  4466 00000FE8 FF0E[6D41]              		dec	word [COMSW]
  4467                                  DOHEADER:
  4468                                  
  4469                                  ; Display the header
  4470                                  
  4471 00000FEC 53                      		push	bx
  4472 00000FED E83904                  		call	BUILD_DIR_STRING
  4473 00000FF0 BA[4F42]                		mov	dx,DIRBUF
  4474 00000FF3 8916[4A43]              		mov	[VOL_DIR],dx
  4475 00000FF7 BA[0F3B]                		mov	dx,DIRHEADPTR
  4476 00000FFA E80824                  		call	PRINTF_CRLF
  4477 00000FFD 5B                      		pop	bx
  4478 00000FFE 83FBFF                  		cmp	bx,0FFFFh
  4479 00001001 7417                    		jz	short DOSEARCH
  4480                                  
  4481                                  ; If there were chars left after parse or device, then invalid file name
  4482                                  
  4483 00001003 833E[6D41]00            		cmp	word [COMSW],0
  4484 00001008 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4485 0000100A 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4486 0000100C E85A08                  		call	RESTUDIR
  4487 0000100F BA[863A]                		mov	dx,BADCDPTR
  4488 00001012 E9D10B                  		jmp	CERROR		; was .. => error directory not found
  4489                                  DIRNFFIX:
  4490 00001015 E85108                  		call	RESTUDIR
  4491 00001018 EBA9                    		jmp	short DIRNF
  4492                                  
  4493                                  ; We are assured that everything is correct. Let's go and search. Use
  4494                                  ; attributes that will include finding directories. Perform the first search
  4495                                  ; and reset our directory afterward.
  4496                                  
  4497                                  DOSEARCH:
  4498                                  		;mov	byte [55h],0FFh
  4499 0000101A C6065500FF              		mov	byte [FCB-7],0FFh
  4500                                  		;mov	byte [5Bh],10h
  4501 0000101F C6065B0010              		mov	byte [FCB-1],10h
  4502                                  
  4503                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4504                                  ; the directory information as an extended FCB. We must bias all fetches into
  4505                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4506                                  
  4507 00001024 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4508 00001026 BA5500                  		mov	dx,FCB-7 ; 55h
  4509 00001029 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4510                                  				; DS:DX	-> FCB
  4511                                  
  4512                                  ; Restore the user's directory. We preserve, though, the return from the
  4513                                  ; previous system call for later checking.
  4514                                  
  4515                                  FOUND_FIRST_FILE:
  4516 0000102B 50                      		push	ax		; save return state
  4517 0000102C E83A08                  		call	RESTUDIR	; restore user's dir	
  4518 0000102F 58                      		pop	ax		; get return state back
  4519                                  
  4520                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4521                                  ; no more.
  4522                                  
  4523                                  DIRSTART:
  4524 00001030 FEC0                    		inc	al		; 0FFh = file not found
  4525 00001032 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4526 00001034 E9D200                  		jmp	CHKCNT
  4527                                  DISPLAY:
  4528 00001037 FF06[7E41]              		inc	word [FILECNT]	; Keep track of how many we find
  4529 0000103B BE[5742]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4530                                  		;call	SHONAME
  4531 0000103E E80C01                  		call	DISPLAYNAME
  4532                                  		;test	byte [_BITS],1
  4533 00001041 F606[A142]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4534 00001046 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4535 00001048 E98800                  		jmp	NEXENT
  4536                                  DIRTEST:
  4537                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4538                                  		; 14/10/2018
  4539                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4540                                  		;test	byte [DIRBUF+19],10h
  4541 0000104B F606[6242]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4542 00001050 7408                    		jz	short FILEENT
  4543 00001052 BA[083A]                		mov	dx,DMESPTR
  4544 00001055 E8BC23                  		call	STD_PRINTF
  4545 00001058 EB16                    		jmp	short NOFSIZ
  4546                                  FILEENT:
  4547                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4548                                  		;mov	dx,[DIRBUF+36]
  4549 0000105A 8B16[7342]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4550 0000105E 8916[2F43]              		mov	[FILESIZE_L],dx
  4551                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4552                                  		;mov	dx,[DIRBUF+38]
  4553 00001062 8B16[7542]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4554 00001066 8916[3143]              		mov	[FILESIZE_H],dx
  4555 0000106A BA[4636]                		mov	dx,FSIZEMESPTR
  4556 0000106D E8A423                  		call	STD_PRINTF	; Print size of file
  4557                                  NOFSIZ:
  4558                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4559                                  		;mov	ax,[DIRBUF+32]
  4560 00001070 A1[6F42]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4561 00001073 09C0                    		or	ax,ax
  4562 00001075 745C                    		jz	short NEXENT	; Skip if no date
  4563 00001077 BF[8041]                		mov	di,CHARBUF
  4564 0000107A 50                      		push	ax
  4565 0000107B B82020                  		mov	ax,'  '
  4566 0000107E AB                      		stosw
  4567 0000107F 58                      		pop	ax
  4568 00001080 89C3                    		mov	bx,ax
  4569 00001082 83E01F                  		and	ax,1Fh		; Get day
  4570 00001085 88C2                    		mov	dl,al
  4571 00001087 89D8                    		mov	ax,bx
  4572 00001089 B105                    		mov	cl,5
  4573 0000108B D3E8                    		shr	ax,cl		; Align month
  4574 0000108D 240F                    		and	al,0Fh		; Get month
  4575 0000108F 88C6                    		mov	dh,al
  4576 00001091 88F9                    		mov	cl,bh
  4577 00001093 D0E9                    		shr	cl,1		; Align year
  4578 00001095 30ED                    		xor	ch,ch
  4579 00001097 83C150                  		add	cx,80		; Relative 1980
  4580 0000109A 80F964                  		cmp	cl,100
  4581 0000109D 7203                    		jb	short MILLENIUM
  4582 0000109F 80E964                  		sub	cl,100
  4583                                  MILLENIUM:
  4584 000010A2 E8860F                  		call	DATE_CXDX
  4585                                  		;mov	cx,[DIRBUF_FTIME]
  4586                                  		;mov	cx,[DIRBUF+30]
  4587 000010A5 8B0E[6D42]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4588 000010A9 E318                    		jcxz	PRBUF		; Time field present?
  4589 000010AB B82020                  		mov	ax,2020h
  4590 000010AE AB                      		stosw
  4591 000010AF D1E9                    		shr	cx,1
  4592 000010B1 D1E9                    		shr	cx,1
  4593 000010B3 D1E9                    		shr	cx,1
  4594 000010B5 D0E9                    		shr	cl,1
  4595 000010B7 D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4596 000010B9 8A1E[EF4B]              		mov	bl,[TIME_24]
  4597 000010BD 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4598 000010C0 E80E11                  		call	P_TIME		; Don't care about DX, never used with DIR
  4599                                  PRBUF:
  4600 000010C3 31C0                    		xor	ax,ax
  4601 000010C5 AA                      		stosb
  4602 000010C6 BA[8041]                		mov	dx,CHARBUF
  4603 000010C9 8916[3343]              		mov	[STRING_PTR_2],dx
  4604 000010CD BA[4F36]                		mov	dx,STRINGBUF2PTR
  4605 000010D0 E84123                  		call	STD_PRINTF
  4606                                  NEXENT:
  4607 000010D3 FE0E[7C41]              		dec	byte [LINCNT]
  4608 000010D7 7520                    		jnz	short SAMLIN
  4609                                  NEXLIN:
  4610 000010D9 A0[7D41]                		mov	al,[LINLEN]
  4611 000010DC A2[7C41]                		mov	[LINCNT],al
  4612 000010DF E85308                  		call	CRLF2
  4613 000010E2 FE0E[A942]              		dec	byte [LINPERPAG]
  4614 000010E6 7517                    		jnz	short SCROLL
  4615                                  		;test	byte [_BITS],2
  4616 000010E8 F606[A142]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4617 000010ED 7410                    		jz	short SCROLL	; If not, just continue
  4618 000010EF C606[A942]17            		mov	byte [LINPERPAG],23
  4619 000010F4 E87800                  		call	PAUSE
  4620 000010F7 EB06                    		jmp	short SCROLL
  4621                                  SAMLIN:
  4622 000010F9 BA[5536]                		mov	dx,TABPTR	; Output a tab
  4623 000010FC E81523                  		call	STD_PRINTF
  4624                                  SCROLL:
  4625 000010FF B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4626                                  		;mov	dx,55h
  4627 00001101 BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4628 00001104 CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4629                                  				; DS:DX	-> FCB
  4630                                  				; Return: AL = status
  4631 00001106 E927FF                  		jmp	DIRSTART
  4632                                  CHKCNT:
  4633 00001109 F706[7E41]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4634 0000110F 7503                    		jnz	short TRAILER
  4635 00001111 E9AFFE                  		jmp	DIRNF
  4636                                  TRAILER:
  4637 00001114 A0[7D41]                		mov	al,[LINLEN]
  4638 00001117 3A06[7C41]              		cmp	al,[LINCNT]
  4639 0000111B 7403                    		jz	short MMESSAGE
  4640 0000111D E81508                  		call	CRLF2
  4641                                  MMESSAGE:
  4642 00001120 BA[1F38]                		mov	dx,DIRMESPTR
  4643 00001123 8B36[7E41]              		mov	si,[FILECNT]
  4644 00001127 8936[3C43]              		mov	[DIR_NUM],si
  4645 0000112B E8E622                  		call	STD_PRINTF
  4646                                  DTFREE:
  4647 0000112E B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4648                                  		;mov	dl,[5Ch]
  4649 00001130 8A165C00                		mov	dl,[FCB]
  4650 00001134 CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4651                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4652 00001136 83F8FF                  		cmp	ax,-1
  4653 00001139 7501                    		jnz	short DTFREE1
  4654                                  DTRET:
  4655 0000113B C3                      		retn
  4656                                  DTFREE1:
  4657 0000113C F7E1                    		mul	cx
  4658 0000113E F7E3                    		mul	bx
  4659 00001140 A3[3E43]                		mov	[BYTES_FREE],ax
  4660 00001143 8916[4043]              		mov	[BYTES_FREE+2],dx
  4661 00001147 BA[3538]                		mov	dx,BYTEMESPTR
  4662 0000114A E9C722                  		jmp	STD_PRINTF
  4663                                  
  4664                                  	; MSDOS 6.0
  4665                                  ;CATALOG:
  4666                                  
  4667                                  ;;
  4668                                  ;; Set up DTA for dir search firsts
  4669                                  ;;
  4670                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4671                                  ;	mov	ah,Set_DMA			;AC000;
  4672                                  ;	int	int_command			;AC000;
  4673                                  ;;
  4674                                  ;; Set up defaults for switches and parse the command line.
  4675                                  ;;
  4676                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4677                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4678                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4679                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4680                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4681                                  ;	stosb					;AN000;
  4682                                  ;	mov	al,end_of_line_in		;AN000;
  4683                                  ;	stosb					;AN000;
  4684                                  ;	mov	si,81H				;AN000; Get command line
  4685                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get address of PARSE_DIR
  4686                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4687                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4688                                  ;	mov	bits,cx 			;AC000; initialize switches
  4689                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4690                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4691                                  ;	mov	lincnt,normperlin		;AC000;
  4692                                  ;
  4693                                  ;dirscan:
  4694                                  ;	xor	dx,dx				;AN000;
  4695                                  ;	invoke	parse_with_msg			;AC018; call parser
  4696                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4697                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4698                                  ;	jmp	scandone			;AN000; yes - go process
  4699                                  ;
  4700                                  ;dirscan_cont:
  4701                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4702                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4703                                  ;	jmp	badparm 			;AN000; yes - exit
  4704                                  ;
  4705                                  ;dirscan_cont2:
  4706                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4707                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4708                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4709                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4710                                  ;;
  4711                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4712                                  ;;
  4713                                  ;	push	si				;AC000; save position in line
  4714                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4715                                  ;	push	si				;AN000; save address
  4716                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4717                                  ;	pop	dx				;AC000; get address in DX
  4718                                  ;
  4719                                  ;;
  4720                                  ;; The user may have specified a device. Search for the path and see if the
  4721                                  ;; attributes indicate a device.
  4722                                  ;;
  4723                                  ;	mov	ah,Find_First			;AC000; find the file
  4724                                  ;	int	int_command			;AC000;
  4725                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4726                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4727                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4728                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4729                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4730                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4731                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4732                                  ;
  4733                                  ;dir_check_device:				;AN022;
  4734                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4735                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4736                                  ;	mov	ComSw,-2			;AC000; signal device
  4737                                  ;
  4738                                  ;dir_fspec_end:
  4739                                  ;	pop	si				;AC000; restore position in line
  4740                                  ;	jmp	short dirscan			;AC000; keep parsing
  4741                                  ;
  4742                                  ;set_dir_width:
  4743                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4744                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4745                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4746                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4747                                  ;	jmp	badparm 			;AN018; exit
  4748                                  ;
  4749                                  ;ok_set_width:
  4750                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4751                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4752                                  ;	mov	lincnt,wideperlin		;AC000;
  4753                                  ;	jmp	short dirscan			;AC000; keep parsing
  4754                                  ;
  4755                                  ;set_dir_pause:
  4756                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4757                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4758                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4759                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4760                                  ;	jmp	badparm 			;AN018; exit
  4761                                  ;
  4762                                  ;ok_set_pause:
  4763                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4764                                  ;	push	cx				;AN000; save necessary registers
  4765                                  ;	push	si				;AN000;
  4766                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4767                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4768                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4769                                  ;	mov	cl,get_generic			;AN000; get information
  4770                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4771                                  ;	int	int_command			;AN000;
  4772                                  ;
  4773                                  ;lines_set:
  4774                                  ;	dec	linperpag			;AN000; lines per actual page should
  4775                                  ;	dec	linperpag			;AN000;     two less than the max
  4776                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4777                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4778                                  ;	pop	si				;AN000; restore registers
  4779                                  ;	pop	cx				;AN000;
  4780                                  ;	jmp	dirscan 			;AC000; keep parsing
  4781                                  ;
  4782                                  ;;
  4783                                  ;; The syntax is incorrect. Report only message we can.
  4784                                  ;;
  4785                                  ;BadParm:
  4786                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4787                                  ;
  4788                                  ;ScanDone:
  4789                                  ;
  4790                                  ;;
  4791                                  ;; Find and display the volume ID on the drive.
  4792                                  ;;
  4793                                  ;
  4794                                  ;	invoke	okvolarg			;AC000;
  4795                                  ;;
  4796                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4797                                  ;; in the HeadFix routine, after we're done.
  4798                                  ;;
  4799                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4800                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4801                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4802                                  ;
  4803                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4804                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4805                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4806                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4807                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4808                                  ;	mov	si,[desttail]			;AN015; get filename back
  4809                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4810                                  ;
  4811                                  ;DirCheckPath:
  4812                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4813                                  ;	cmp	ax,0				;AN022; Is there a message?
  4814                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4815                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4816                                  ;	jz	doparse 			;AC000; no - no problem
  4817                                  ;	inc	comsw				;AC000; indicate error
  4818                                  ;	jmp	short doheader			;AC000; go print header
  4819                                  ;
  4820                                  ;DirNF:
  4821                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4822                                  ;
  4823                                  ;dir_err_setup:
  4824                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4825                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4826                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4827                                  ;
  4828                                  ;DirError:
  4829                                  ;	jmp	Cerror
  4830                                  ;
  4831                                  ;;
  4832                                  ;; We have changed to something. We also have a file. Parse it into a
  4833                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4834                                  ;; filename alone. We need to special case ... If we are at the root, the
  4835                                  ;; parse will fail and it will give us a file not found instead of file not
  4836                                  ;; found.
  4837                                  ;;
  4838                                  ;DoParse:
  4839                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4840                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4841                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4842                                  ;	lodsw					;AN000; bypass drive
  4843                                  ;
  4844                                  ;dir_no_drive:
  4845                                  ;	cmp	[si],".."
  4846                                  ;	jnz	DoRealParse
  4847                                  ;	cmp	byte ptr [si+2],0
  4848                                  ;	jnz	DoRealParse
  4849                                  ;	inc	ComSw
  4850                                  ;	jmp	short DoHeader
  4851                                  ;
  4852                                  ;DoRealParse:
  4853                                  ;	mov	di,FCB			; where to put the file name
  4854                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4855                                  ;	int	int_command
  4856                                  ;
  4857                                  ;;
  4858                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4859                                  ;; off.	This will be reset in the HEADFIX routine
  4860                                  ;;
  4861                                  ;
  4862                                  ;DoHeader:
  4863                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4864                                  ;
  4865                                  ;;
  4866                                  ;; Display the header
  4867                                  ;;
  4868                                  ;
  4869                                  ;DoHeaderCont:
  4870                                  ;	mov	al,blank			;AN051; Print out a blank
  4871                                  ;	invoke	print_char			;AN051;   before DIR header
  4872                                  ;	invoke	build_dir_string		; get current dir string
  4873                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4874                                  ;	invoke	printf_crlf			; bang!
  4875                                  ;
  4876                                  ;;
  4877                                  ;; If there were chars left after parse or device, then invalid file name
  4878                                  ;;
  4879                                  ;	cmp	ComSw,0
  4880                                  ;	jz	DoSearch			; nothing left; good parse
  4881                                  ;	jl	DirNFFix			; not .. => error file not found
  4882                                  ;	invoke	RestUDir
  4883                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4884                                  ;	jmp	Cerror				; was .. => error directory not found
  4885                                  ;DirNFFix:
  4886                                  ;	invoke	RestUDir
  4887                                  ;	jmp	DirNF
  4888                                  ;;
  4889                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4890                                  ;; attributes that will include finding directories.  perform the first search
  4891                                  ;; and reset our directory afterward.
  4892                                  ;;
  4893                                  ;DoSearch:
  4894                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4895                                  ;	mov	byte ptr DS:[FCB-1],010H
  4896                                  ;;
  4897                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4898                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4899                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4900                                  ;;
  4901                                  ;	mov	ah,Dir_Search_First
  4902                                  ;	mov	dx,FCB-7
  4903                                  ;	int	int_command
  4904                                  ;
  4905                                  ;	push	ax				;AN022; save return state
  4906                                  ;	inc	al				;AN022; did an error occur?
  4907                                  ;	pop	ax				;AN022; get return state back
  4908                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4909                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4910                                  ;	push	dx				;AN022; save message
  4911                                  ;	invoke	restudir			;AN022; restore user's dir
  4912                                  ;	pop	dx				;AN022; restore message
  4913                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4914                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4915                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4916                                  ;
  4917                                  ;DirCerrorJ:					;AN022;
  4918                                  ;	jmp	Cerror				;AN022; exit
  4919                                  ;
  4920                                  ;;
  4921                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4922                                  ;; previous system call for later checking.
  4923                                  ;;
  4924                                  ;
  4925                                  ;found_first_file:
  4926                                  ;	push	ax
  4927                                  ;	invoke	restudir
  4928                                  ;	pop	ax
  4929                                  ;;
  4930                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4931                                  ;; no more.
  4932                                  ;;
  4933                                  ;DIRSTART:
  4934                                  ;	inc	al				; FF = file not found
  4935                                  ;	jnz	Display
  4936                                  ;	jmp	DirDone 			; Either an error or we are finished
  4937                                  ;;
  4938                                  ;; Note that we've seen a file and display the found file.
  4939                                  ;;
  4940                                  ;
  4941                                  ;Display:
  4942                                  ;	inc	[filecnt]			; Keep track of how many we find
  4943                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4944                                  ;	call	shoname
  4945                                  ;;
  4946                                  ;; If we are displaying in wide mode, do not output the file info
  4947                                  ;;
  4948                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4949                                  ;	jz	DirTest
  4950                                  ;	jmp	nexent				; If so, no size, date, or time
  4951                                  ;
  4952                                  ;;
  4953                                  ;; Test for directory.
  4954                                  ;;
  4955                                  ;DirTest:
  4956                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4957                                  ;	jz	fileent
  4958                                  ;;
  4959                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4960                                  ;;
  4961                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4962                                  ;	call	std_printf
  4963                                  ;	jmp	short nofsiz
  4964                                  ;;
  4965                                  ;; We have a file.  Display the file size
  4966                                  ;;
  4967                                  ;fileent:
  4968                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4969                                  ;	mov	file_size_low,dx
  4970                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4971                                  ;	mov	file_size_high,dx
  4972                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4973                                  ;	call	std_printf
  4974                                  ;;
  4975                                  ;; Display time and date of last modification
  4976                                  ;;
  4977                                  ;nofsiz:
  4978                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4979                                  ;;
  4980                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4981                                  ;; date/time fields as 1.x did not have them.
  4982                                  ;;
  4983                                  ;	or	ax,ax
  4984                                  ;	jz	nexent				; Skip if no date
  4985                                  ;	mov	bx,ax
  4986                                  ;	and	ax,1FH				; get day
  4987                                  ;	mov	dl,al
  4988                                  ;	mov	ax,bx
  4989                                  ;	mov	cl,5
  4990                                  ;	shr	ax,cl				; Align month
  4991                                  ;	and	al,0FH				; Get month
  4992                                  ;	mov	dh,al
  4993                                  ;	mov	cl,bh
  4994                                  ;	shr	cl,1				; Align year
  4995                                  ;	xor	ch,ch
  4996                                  ;	add	cx,80				; Relative 1980
  4997                                  ;	cmp	cl,100
  4998                                  ;	jb	millenium
  4999                                  ;	sub	cl,100
  5000                                  ;
  5001                                  ;millenium:
  5002                                  ;	xchg	dh,dl				;AN000; switch month & day
  5003                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  5004                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  5005                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  5006                                  ;	jcxz	prbuf				; Time field present?
  5007                                  ;	shr	cx,1
  5008                                  ;	shr	cx,1
  5009                                  ;	shr	cx,1
  5010                                  ;	shr	cl,1
  5011                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  5012                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  5013                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  5014                                  ;
  5015                                  ;prbuf:
  5016                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  5017                                  ;	call	std_printf
  5018                                  ;	invoke	crlf2				;AC066;end the line
  5019                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  5020                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  5021                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  5022                                  ;	endif04:				;AN066;
  5023                                  ;	jmp	scroll				; If not, just continue
  5024                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  5025                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  5026                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  5027                                  ;;
  5028                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  5029                                  ;; is only for /W case.
  5030                                  ;;
  5031                                  ;nexent:
  5032                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  5033                                  ;	dec	[lincnt]			      ;count this entry on the line
  5034                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  5035                                  ;	   mov	   al,[linlen]
  5036                                  ;	   mov	   [lincnt],al
  5037                                  ;	   invoke  crlf2
  5038                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  5039                                  ;	   jnz	   endif02			;AN066;
  5040                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  5041                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  5042                                  ;	   jmp	   short endif01		;AN066;
  5043                                  ;	else01: 				;AN066;ELSE since screen not full
  5044                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  5045                                  ;	   jne	   endif03			;	     count the line
  5046                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  5047                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  5048                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  5049                                  ;	   call    std_printf
  5050                                  ;	endif01:				;AX066;
  5051                                  ;;
  5052                                  ;; All we need to do now is to get the next directory entry.
  5053                                  ;;
  5054                                  ;scroll:
  5055                                  ;	mov	ah,Dir_Search_Next
  5056                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  5057                                  ;	int	int_command			; Search for a file to match FCB
  5058                                  ;	jmp	DirStart
  5059                                  ;;
  5060                                  ;; If no files have been found, display a not-found message
  5061                                  ;;
  5062                                  ;DirDone:
  5063                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  5064                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  5065                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  5066                                  ;	test	[filecnt],-1
  5067                                  ;	jnz	Trailer
  5068                                  ;	mov	ax,error_file_not_found 	;AN022;
  5069                                  ;
  5070                                  ;dir_err_setup_jmp:				;AN022;
  5071                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  5072                                  ;;
  5073                                  ;; If we have printed the maximum number of files per line, terminate it with
  5074                                  ;; CRLF.
  5075                                  ;;
  5076                                  ;Trailer:
  5077                                  ;	mov	al,[linlen]
  5078                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5079                                  ;	jz	mmessage
  5080                                  ;	invoke	crlf2
  5081                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5082                                  ;	jnz	endif06 			;AN066;   pause before going on
  5083                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5084                                  ;	endif06:				;AN066;   displays
  5085                                  ;
  5086                                  ;mmessage:
  5087                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5088                                  ;	mov	si,[filecnt]
  5089                                  ;	mov	dir_num,si
  5090                                  ;	call	std_printf
  5091                                  ;	mov	ah,Get_Drive_Freespace
  5092                                  ;	mov	dl,byte ptr DS:[FCB]
  5093                                  ;	int	int_command
  5094                                  ;	cmp	ax,-1
  5095                                  ;	retz
  5096                                  ;	mul	cx				; AX is bytes per cluster
  5097                                  ;	mul	bx
  5098                                  ;	mov	bytes_free,ax			;AC000;
  5099                                  ;	mov	bytes_free+2,dx 		;AC000;
  5100                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5101                                  ;	jmp	std_printf
  5102                                  ;
  5103                                  ;shoname:
  5104                                  ;	mov	di,offset trangroup:charbuf
  5105                                  ;	mov	cx,8
  5106                                  ;	rep	movsb
  5107                                  ;	mov	al,' '
  5108                                  ;	stosb
  5109                                  ;	mov	cx,3
  5110                                  ;	rep	movsb
  5111                                  ;	xor	ax,ax
  5112                                  ;	stosb
  5113                                  ;	push	dx
  5114                                  ;	mov	dx,offset trangroup:charbuf
  5115                                  ;	mov	string_ptr_2,dx
  5116                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5117                                  ;	call	std_printf
  5118                                  ;	pop	DX
  5119                                  ;	return
  5120                                  ;
  5121                                  ;check_for_P    PROC  NEAR		;AN066;
  5122                                  ;
  5123                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5124                                  ;	jz	endif05 		;AN066;
  5125                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5126                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5127                                  ;   	invoke  Pause
  5128                                  ;endif05:
  5129                                  ;	ret				;AN066;
  5130                                  ;
  5131                                  ;check_for_P    ENDP			;AN066;
  5132                                  
  5133                                  ; =============== S U B	R O U T	I N E =======================================
  5134                                  
  5135                                  SHONAME:
  5136                                  DISPLAYNAME:
  5137                                  		; MSDOS 3.3
  5138 0000114D BF[8041]                		mov	di,CHARBUF
  5139 00001150 B90800                  		mov	cx,8
  5140 00001153 F3A4                    		rep movsb
  5141 00001155 B020                    		mov	al,' '
  5142 00001157 AA                      		stosb
  5143                                  		;mov	cx,3
  5144                                  		; 02/03/2023
  5145 00001158 B103                    		mov	cl,3
  5146 0000115A F3A4                    		rep movsb
  5147 0000115C 31C0                    		xor	ax,ax
  5148 0000115E AA                      		stosb
  5149 0000115F 52                      		push	dx
  5150 00001160 BA[8041]                		mov	dx,CHARBUF
  5151 00001163 8916[3343]              		mov	[STRING_PTR_2],dx
  5152 00001167 BA[4F36]                		mov	dx,STRINGBUF2PTR
  5153 0000116A E8A722                  		call	STD_PRINTF
  5154 0000116D 5A                      		pop	dx
  5155 0000116E C3                      		retn
  5156                                  
  5157                                  ;============================================================================
  5158                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5159                                  ;============================================================================
  5160                                  ; 09/10/2018 - Retro DOS v3.0
  5161                                  
  5162                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5163                                  
  5164                                  
  5165                                  ; =============== S U B	R O U T	I N E =======================================
  5166                                  
  5167                                  PAUSE:
  5168 0000116F BA[1C39]                		mov	dx,PAUSEMESPTR
  5169 00001172 E89F22                  		call	STD_PRINTF
  5170 00001175 E874F3                  		call	GETKEYSTROKE
  5171                                  		;call	CRLF2
  5172                                  		;retn
  5173                                  		; 02/03/2023
  5174 00001178 E9BA07                  		jmp	CRLF2
  5175                                  
  5176                                  ; ---------------------------------------------------------------------------
  5177                                  
  5178                                  ;****************************************************************
  5179                                  ;*
  5180                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5181                                  ;*
  5182                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5183                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5184                                  ;*		up an error message and transfer control to CERROR.
  5185                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5186                                  ;*		entered or SLASHP_ERASE if /P entered.
  5187                                  ;*
  5188                                  ;* INPUT:	command line at offset 81H
  5189                                  ;*
  5190                                  ;* OUTPUT:	if no error:
  5191                                  ;*		FCB at 5ch set up with filename(s) entered
  5192                                  ;*		Current directory set to entered directory
  5193                                  ;*
  5194                                  ;****************************************************************
  5195                                  
  5196                                  ERASE:
  5197                                  		; MSDOS 6.0
  5198                                  
  5199                                  ;assume	ds:trangroup,es:trangroup
  5200                                  
  5201                                  ;		mov	si,81H		;AC000; get command line
  5202                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5203                                  ;		mov	di,offset trangroup:parse_erase
  5204                                  ;					;AN000; Get address of PARSE_erase
  5205                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5206                                  ;erase_scan:
  5207                                  ;		xor	dx,dx		;AN000;
  5208                                  ;		invoke	parse_with_msg	;AC018; call parser
  5209                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5210                                  ;		jz	good_line	;AN000; yes - done parsing
  5211                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5212                                  ;		jnz	errj2		;AC000; yes exit
  5213                                  ;
  5214                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5215                                  ;					;AN000; was /P entered?
  5216                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5217                                  ;;
  5218                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5219                                  ;;
  5220                                  ;		push	si		;AC000; save position in line
  5221                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5222                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5223                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5224                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5225                                  ;					;AC000; was only drive entered?
  5226                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5227                                  ;		mov	ax,error_file_not_found 
  5228                                  ;					;AN022; get message number in control block
  5229                                  ;		jmp	short extend_setup ;AC000; exit
  5230                                  ;
  5231                                  ;erase_drive_ok:
  5232                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5233                                  ;		pop	si		;AC000; get position back
  5234                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5235                                  ;
  5236                                  ;set_erase_prompt:
  5237                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5238                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5239                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5240                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5241                                  ;		jmp	short errj2	;AN018; exit
  5242                                  ;
  5243                                  ;ok_to_set_erase_prompt: 		;AN018;
  5244                                  ;		inc	comsw		;AN000; indicate /p specified
  5245                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5246                                  ;
  5247                                  ;good_line:				;G  We know line is good
  5248                                  ;		invoke	pathcrunch
  5249                                  ;		jnc	checkdr
  5250                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5251                                  ;		cmp	ax,0		;AN022; was message flag set?
  5252                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5253                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5254                                  ;		jnz	badpath_err	;AC022; see if they should have
  5255                                  ;
  5256                                  ;checkdr:
  5257                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5258                                  ;		jz	notest2j	;AN000; no - go to notest2
  5259                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5260                                  ;
  5261                                  ;notest2j:
  5262                                  ;		jmp	notest2
  5263                                  ;
  5264                                  ;badpath_err:				;AN022; "Path not found" message
  5265                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5266                                  ;
  5267                                  ;extend_setup:				;AN022;
  5268                                  ;		mov	msg_disp_class,ext_msg_class
  5269                                  ;					;AN022; set up extended error msg class
  5270                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5271                                  ;					;AC022; get extended message pointer
  5272                                  ;		mov	Extend_Buf_ptr,ax
  5273                                  ;					;AN022; get message number in control block
  5274                                  ;errj2:					;AC022; exit jump
  5275                                  ;		jmp	Cerror		;AN022;
  5276                                  
  5277                                  		; MSDOS 3.3
  5278 0000117B BA[7D3C]                		mov	dx,BADARGSPTR
  5279 0000117E BE8000                  		mov	si,80h
  5280 00001181 AC                      		lodsb
  5281 00001182 08C0                    		or	al,al
  5282 00001184 743E                    		jz	short ERRJ2
  5283 00001186 E8B907                  		call	SCANOFF
  5284 00001189 3C0D                    		cmp	al,0Dh		; Return key
  5285 0000118B 7437                    		jz	short ERRJ2	; If so no parameters specified
  5286 0000118D 52                      		push	dx
  5287 0000118E 56                      		push	si
  5288 0000118F BA[0837]                		mov	dx,FNOTFOUNDPTR
  5289                                  ERASE_SCAN:
  5290 00001192 AC                      		lodsb
  5291 00001193 E8B407                  		call	DELIM
  5292 00001196 7406                    		jz	short ERASE_CHKDELIMCHR
  5293 00001198 3C0D                    		cmp	al,0Dh
  5294 0000119A 7415                    		jz	short GOOD_LINE
  5295 0000119C EBF4                    		jmp	short ERASE_SCAN
  5296                                  ERASE_CHKDELIMCHR:
  5297 0000119E 3C20                    		cmp	al,20h
  5298 000011A0 7F22                    		jg	short ERRJ2
  5299 000011A2 AC                      		lodsb
  5300 000011A3 E8A407                  		call	DELIM
  5301 000011A6 74F6                    		jz	short ERASE_CHKDELIMCHR
  5302 000011A8 3C0D                    		cmp	al,0Dh
  5303 000011AA 7405                    		jz	short GOOD_LINE
  5304 000011AC BA[7D3C]                		mov	dx,BADARGSPTR
  5305 000011AF EB13                    		jmp	short ERRJ2
  5306                                  GOOD_LINE:
  5307 000011B1 5E                      		pop	si
  5308 000011B2 5A                      		pop	dx
  5309 000011B3 56                      		push	si
  5310 000011B4 E82E08                  		call	PATHCRUNCH
  5311 000011B7 730E                    		jnc	short CHECKDR
  5312 000011B9 803E[5143]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5313 000011BE 7407                    		jz	short CHECKDR	   ; see if they should have
  5314                                  BADCDERR:
  5315 000011C0 5E                      		pop	si
  5316 000011C1 BA[863A]                		mov	dx,BADCDPTR
  5317                                  ERRJ2:
  5318 000011C4 E91F0A                  		jmp	CERROR
  5319                                  CHECKDR:
  5320 000011C7 BA[0837]                		mov	dx,FNOTFOUNDPTR
  5321 000011CA 59                      		pop	cx
  5322 000011CB B020                    		mov	al,' '
  5323                                  		;cmp	[5Dh],al
  5324 000011CD 38065D00                		cmp	[FCB+1],al
  5325 000011D1 74F1                    		jz	short ERRJ2
  5326 000011D3 83C103                  		add	cx,3
  5327 000011D6 39CE                    		cmp	si,cx
  5328 000011D8 7507                    		jnz	short NOTEST2J
  5329 000011DA B03A                    		mov	al,':'
  5330 000011DC 3844FE                  		cmp	[si-2],al
  5331 000011DF 74E3                    		jz	short ERRJ2
  5332                                  NOTEST2J:
  5333 000011E1 E9AA15                  		jmp	NOTEST2
  5334                                  
  5335                                  ; ---------------------------------------------------------------------------
  5336                                  
  5337                                  ; ****************************************************************
  5338                                  ; *
  5339                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5340                                  ; *
  5341                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5342                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5343                                  ; *		 Make sure the second filespec only contains a
  5344                                  ; *		 filename.  If both openands are valid, attempt
  5345                                  ; *		 to rename the file.
  5346                                  ; *
  5347                                  ; * INPUT:	 command line at offset 81H
  5348                                  ; *
  5349                                  ; * OUTPUT:	 none
  5350                                  ; *
  5351                                  ; ****************************************************************
  5352                                  
  5353                                  CRENAME:
  5354                                  		; MSDOS 6.0
  5355                                  		;assume	ds:trangroup,es:trangroup
  5356                                  ;
  5357                                  ;		mov	si,81H		;AC000; Point to command line
  5358                                  ;		mov	di,offset trangroup:parse_rename
  5359                                  ;					;AN000; Get address of PARSE_RENAME
  5360                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5361                                  ;		xor	dx,dx		;AN000;
  5362                                  ;		invoke	parse_with_msg	;AC018; call parser
  5363                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5364                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5365                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5366                                  ;;
  5367                                  ;;  Get first file name returned from parse into our buffer
  5368                                  ;;
  5369                                  ;crename_no_parse_error:
  5370                                  ;		push	si		;AN000; save position in line
  5371                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5372                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5373                                  ;		pop	si		;AN000; restore position in line
  5374                                  ;
  5375                                  ;		xor	dx,dx		;AN000; clear dx
  5376                                  ;		invoke	parse_with_msg	;AC018; call parser
  5377                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5378                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5379                                  ;;
  5380                                  ;;  Check the second file name for drive letter colon
  5381                                  ;;
  5382                                  ;		push	si		;AN000; save position in line
  5383                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5384                                  ;
  5385                                  ;		mov	al,':'		;AC000;
  5386                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5387                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5388                                  ;		mov	msg_disp_class,parse_msg_class
  5389                                  ;					;AN000; set up parse error msg class
  5390                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5391                                  ;					;AC000; get extended message pointer
  5392                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5393                                  ;					;AN000; get "Invalid parameter" message number
  5394                                  ;		pop	si		;AN000;
  5395                                  ;crename_parse_error:			;AC022;
  5396                                  ;		jmp	short errj	;AC000;
  5397                                  ;
  5398                                  ;;  Get second file name returned from parse into the fCB. Save
  5399                                  ;;  character after file name so we can later check to make sure it
  5400                                  ;;  isn't a path character.
  5401                                  ;
  5402                                  ;
  5403                                  ;ren_no_drive:
  5404                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5405                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5406                                  ;		int	21h		;AC000; do the function
  5407                                  ;		lodsb			;AC000; Load char after filename
  5408                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5409                                  ;		pop	si		;AN000; get line position back
  5410                                  ;
  5411                                  ;;
  5412                                  ;; We have source and target.  See if any args beyond.
  5413                                  ;;
  5414                                  ;
  5415                                  ;		mov	di,offset trangroup:parse_rename
  5416                                  ;					;AC000; get address of parse_rename
  5417                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5418                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5419                                  ;
  5420                                  ;		invoke	pathcrunch
  5421                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5422                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5423                                  ;		jnc	notest3
  5424                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5425                                  ;		cmp	ax,0		;AN022; was message flag set?
  5426                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5427                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5428                                  ;		jz	notest3 	; see if they should have
  5429                                  ;		Jmp	badpath_err	;AC022; set up error
  5430                                  ;
  5431                                  ;notest3:
  5432                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5433                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5434                                  ;					; Load invalid fname error ptr
  5435                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5436                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5437                                  ;					;  filename only.
  5438                                  ;		mov	ah,FCB_Rename
  5439                                  ;		mov	dx,FCB
  5440                                  ;		int	21h
  5441                                  ;		cmp	al, 0FFH	; Did an error occur??
  5442                                  ;		jnz	renameok
  5443                                  ;
  5444                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5445                                  ;		SaveReg <AX>		;AC022; Save results
  5446                                  ;		mov	al, 0FFH	; Restore original error state
  5447                                  ;
  5448                                  ;renameok:
  5449                                  ;		push	ax
  5450                                  ;		invoke	restudir
  5451                                  ;		pop	ax
  5452                                  ;		inc	al
  5453                                  ;		retnz
  5454                                  ;
  5455                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5456                                  ;		cmp	ax,error_file_not_found 
  5457                                  ;					;AN022; error file not found?
  5458                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5459                                  ;		cmp	ax,error_access_denied
  5460                                  ;					;AN022; error file not found?
  5461                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5462                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5463                                  ;
  5464                                  ;use_renerr:
  5465                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5466                                  ;ERRJ:
  5467                                  ;		jmp	Cerror
  5468                                  ;
  5469                                  ;ret56:		ret
  5470                                  
  5471                                  		; MSDOS 3.3
  5472 000011E4 BA[7D3C]                		mov	dx,BADARGSPTR
  5473 000011E7 E85807                  		call	SCANOFF
  5474 000011EA 3C0D                    		cmp	al,0Dh
  5475 000011EC 74D6                    		jz	short ERRJ2
  5476 000011EE E8F407                  		call	PATHCRUNCH
  5477 000011F1 BA[5C3C]                		mov	dx,BADCPMESPTR
  5478 000011F4 74CE                    		jz	short ERRJ2
  5479 000011F6 7307                    		jnb	short CRENAME_NO_PARSE_ERROR
  5480 000011F8 803E[5143]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5481                                  		;jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5482                                  		;jmp	short BADCDERR
  5483                                  		; 02/03/2023
  5484 000011FD 75C1                    		jnz	short BADCDERR
  5485                                  
  5486                                  ;  Get first file name returned from parse into our buffer
  5487                                  
  5488                                  CRENAME_NO_PARSE_ERROR:
  5489 000011FF 8B36[A542]              		mov	si,[PATHPOS]
  5490 00001203 E83C07                  		call	SCANOFF
  5491 00001206 3C0D                    		cmp	al,0Dh
  5492 00001208 BA[7D3C]                		mov	dx,BADARGSPTR
  5493 0000120B 7443                    		jz	short ERRJ
  5494 0000120D B03A                    		mov	al,':'
  5495 0000120F BA[3239]                		mov	dx,BADPARMPTR
  5496 00001212 384401                  		cmp	[si+1],al
  5497 00001215 7439                    		jz	short ERRJ
  5498                                  
  5499                                  ;  Get second file name returned from parse into the FCB. Save
  5500                                  ;  character after file name so we can later check to make sure it
  5501                                  ;  isn't a path character.
  5502                                  
  5503                                  REN_NO_DRIVE:
  5504                                  		;mov	di,6Ch
  5505 00001217 BF6C00                  		mov	di,FCB+10h
  5506 0000121A B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5507 0000121D CD21                    		int	21h	; DOS -	PARSE FILENAME
  5508                                  				; DS:SI	-> string to parse
  5509                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5510                                  				; AL = bit mask	to control parsing
  5511 0000121F B020                    		mov	al,' '
  5512                                  		;cmp	[6Dh],al
  5513 00001221 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5514 00001225 7429                    		jz	short ERRJ	; Error if missing parameter
  5515 00001227 AC                      		lodsb
  5516 00001228 BA[F737]                		mov	dx,INORNOTPTR
  5517 0000122B E8A607                  		call	PATHCHRCMP
  5518 0000122E 7420                    		jz	short ERRJ
  5519 00001230 B417                    		mov	ah,FCB_RENAME ; 17h
  5520 00001232 BA5C00                  		mov	dx,FCB ; 5Ch
  5521 00001235 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5522                                  				; DS:DX	-> FCB
  5523                                  				; FCB contains new name	starting at byte 17h.
  5524 00001237 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5525 00001239 750A                    		jnz	short RENAMEOK
  5526 0000123B F9                      		stc
  5527 0000123C BA[F536]                		mov	dx,RENERRPTR
  5528 0000123F E8330C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5529 00001242 52                      		push	dx
  5530 00001243 B0FF                    		mov	al,0FFh		; Restore original error state
  5531                                  RENAMEOK:
  5532 00001245 50                      		push	ax
  5533 00001246 E82006                  		call	RESTUDIR
  5534 00001249 58                      		pop	ax
  5535 0000124A FEC0                    		inc	al
  5536 0000124C 7401                    		jz	short RENAME_ERR
  5537                                  RENAME_RETN:
  5538                                  TYPELP_RET:
  5539 0000124E C3                      		retn
  5540                                  RENAME_ERR:
  5541 0000124F 5A                      		pop	dx
  5542                                  ERRJ:					; Retro DOS v3.0
  5543 00001250 E8B821                  		call	STD_EPRINTF
  5544 00001253 E9AEEE                  		jmp	TCOMMAND
  5545                                  
  5546                                  ; ---------------------------------------------------------------------------
  5547                                  
  5548                                  ;ERRJ:
  5549                                  ;		jmp	CERROR
  5550                                  
  5551                                  ; ---------------------------------------------------------------------------
  5552                                  
  5553                                  ;TYPELP_RET:
  5554                                  ;		retn
  5555                                  
  5556                                  ; ---------------------------------------------------------------------------
  5557                                  
  5558                                  ;****************************************************************
  5559                                  ;*
  5560                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5561                                  ;*		standard output device
  5562                                  ;*
  5563                                  ;* SYNTAX:	TYPE filespec
  5564                                  ;*
  5565                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5566                                  ;*		1Ah and display the contents to STDOUT.
  5567                                  ;*
  5568                                  ;* INPUT:	command line at offset 81H
  5569                                  ;*
  5570                                  ;* OUTPUT:	none
  5571                                  ;*
  5572                                  ;****************************************************************
  5573                                  
  5574                                  TYPEFIL:
  5575                                  		; MSDOS 6.0	
  5576                                  		;assume	ds:trangroup,es:trangroup
  5577                                  
  5578                                  ;		mov	si,81H
  5579                                  ;		mov	di,offset trangroup:parse_mrdir 
  5580                                  ;					;AN000; Get address of PARSE_MRDIR
  5581                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5582                                  ;		xor	dx,dx		;AN000;
  5583                                  ;		invoke	parse_with_msg	;AC018; call parser
  5584                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5585                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5586                                  ;
  5587                                  ;		push	si		;AC000; save position in line
  5588                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5589                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5590                                  ;		pop	si		;AC000; get position back
  5591                                  ;		mov	di,offset trangroup:parse_mrdir 
  5592                                  ;					;AC000; get address of parse_mrdir
  5593                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5594                                  ;		jz	gottarg 	;AC000; yes - continue
  5595                                  ;
  5596                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5597                                  ;		jmp	Cerror
  5598                                  ;
  5599                                  ;gottarg:
  5600                                  ;		invoke	setpath
  5601                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5602                                  ;		jz	nowilds 	; No, continue processing
  5603                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5604                                  ;		jmp	Cerror
  5605                                  ;nowilds:
  5606                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5607                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5608                                  ;		xor	cx,cx		;AN000; no special files
  5609                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5610                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5611                                  ;		int	21h
  5612                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5613                                  ;
  5614                                  ;Typerr: 				;AN022;
  5615                                  ;		push	cs		;AN022; make sure we have local segment
  5616                                  ;		pop	ds		;AN022;
  5617                                  ;		invoke	set_ext_error_msg ;AN022;
  5618                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5619                                  ;					;AC022; get address of failed string
  5620                                  ;		mov	Extend_buf_sub,one_subst
  5621                                  ;					;AC022; put number of subst in control block
  5622                                  ;		jmp	cerror		;AC022; exit
  5623                                  ;
  5624                                  ;typecont:
  5625                                  ;		mov	bx,ax		;AC000; get  Handle
  5626                                  ;;M043
  5627                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5628                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5629                                  ;;indicate it is a device.
  5630                                  ;;
  5631                                  ;		mov	ax,(IOCTL shl 8) or 0
  5632                                  ;		int	21h
  5633                                  ;
  5634                                  ;		test	dl,80h		;is it a device?
  5635                                  ;		jz	not_device	;no, a file
  5636                                  ;
  5637                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5638                                  ;		jmp	short dotype
  5639                                  ;not_device:
  5640                                  ;
  5641                                  ;;SR;
  5642                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5643                                  ;;start of file
  5644                                  ;;
  5645                                  ;		mov	ax,(LSEEK shl 8) or 2
  5646                                  ;		xor	dx,dx
  5647                                  ;		mov	cx,dx		;seek  to end of file
  5648                                  ;		int	21h
  5649                                  ;
  5650                                  ;		mov	word ptr TypeFilSiz,ax
  5651                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5652                                  ;
  5653                                  ;		mov	ax,(LSEEK shl 8) or 0
  5654                                  ;		xor	dx,dx
  5655                                  ;		int	21h	        ;reset file pointer to start
  5656                                  ;dotype:					;M043
  5657                                  ;		mov	zflag,0 	; Reset ^Z flag
  5658                                  ;		mov	ds,[TPA]
  5659                                  ;		xor	dx,dx
  5660                                  ;		;ASSUME	DS:NOTHING
  5661                                  ;
  5662                                  ;typelp:
  5663                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5664                                  ;		retnz			; Yes, return
  5665                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5666                                  ;;
  5667                                  ;;Update the filesize left to read
  5668                                  ;;
  5669                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5670                                  ;		je	typ_read	;yes, just read from it; M043
  5671                                  ;
  5672                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5673                                  ;		jz	lt64k		;no, do word subtraction
  5674                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5675                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5676                                  ;      		jmp	short typ_read	;do the read
  5677                                  ;lt64k:
  5678                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5679                                  ;		jbe	gtbuf		; yes, just update readsize
  5680                                  ;;
  5681                                  ;;Buffer size is larger than bytes to read
  5682                                  ;;
  5683                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5684                                  ;		jcxz	typelp_ret
  5685                                  ;		mov	word ptr cs:TypeFilSiz,0
  5686                                  ;		jmp	short typ_read
  5687                                  ;gtbuf:
  5688                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5689                                  ;typ_read:
  5690                                  ;		mov	ah,read
  5691                                  ;		int	21h		
  5692                                  ;		jnc	@f		;M043
  5693                                  ;		jmp	typerr		;M043
  5694                                  ;@@:					;M043
  5695                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5696                                  ;
  5697                                  ;		mov	cx,ax
  5698                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5699                                  ;		push	ds
  5700                                  ;		pop	es		; Check to see if a ^Z was read.
  5701                                  ;		;assume es:nothing
  5702                                  ;		xor	di,di
  5703                                  ;		push	ax
  5704                                  ;		mov	al,1ah
  5705                                  ;		repnz	scasb
  5706                                  ;		pop	ax
  5707                                  ;		xchg	ax,cx
  5708                                  ;		cmp	ax,0
  5709                                  ;		jnz	foundz		; Yes, handle it
  5710                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5711                                  ;		jnz	typecont2	; No ^Z, continue
  5712                                  ;
  5713                                  ;foundz:
  5714                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5715                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5716                                  ;		push	cs		;  will be typed.
  5717                                  ;		pop	es
  5718                                  ;		;assume es:trangroup
  5719                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5720                                  ;typecont2:				;  will quit after this write.
  5721                                  ;		push	bx
  5722                                  ;		mov	bx,1
  5723                                  ;		mov	ah,write
  5724                                  ;		int	21h
  5725                                  ;		pop	bx
  5726                                  ;		jc	Error_outputj
  5727                                  ;		cmp	ax,cx
  5728                                  ;		jnz	@f		;M043
  5729                                  ;		jmp	typelp		;M043
  5730                                  ;@@:					;M043
  5731                                  ;;M043;		jz	typelp
  5732                                  ;		dec	cx
  5733                                  ;		cmp	ax,cx
  5734                                  ;		retz			; One less byte OK (^Z)
  5735                                  ;Error_outputj:
  5736                                  ;		mov	bx,1
  5737                                  ;		mov	ax,IOCTL SHL 8
  5738                                  ;		int	21h
  5739                                  ;		test	dl,devid_ISDEV
  5740                                  ;		retnz			; If device, no error message
  5741                                  ;		jmp	error_output
  5742                                  ;typelp_ret:
  5743                                  ;		ret
  5744                                  
  5745                                  		; MSDOS 3.3
  5746 00001256 BE8100                  		mov	si,81h
  5747 00001259 E8E606                  		call	SCANOFF		; Skip to first non-delim
  5748 0000125C 3C0D                    		cmp	al,0Dh
  5749 0000125E 7505                    		jnz	short GOTTARG
  5750 00001260 BA[7D3C]                		mov	dx,BADARGSPTR
  5751                                  
  5752                                  		;jmp	CERROR
  5753 00001263 EBEB                    		jmp	short ERRJ	; No args
  5754                                  GOTTARG:
  5755 00001265 E8BC0A                  		call	SETPATH
  5756 00001268 F606[5543]02            		test	byte [DESTINFO],2
  5757 0000126D 7405                    		jz	short NOWILDS
  5758 0000126F BA[F737]                		mov	dx,INORNOTPTR
  5759                                  
  5760                                  		;jmp	CERROR
  5761 00001272 EBDC                    		jmp	short ERRJ
  5762                                  NOWILDS:
  5763 00001274 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5764 00001277 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5765                                  				; DS:DX	-> ASCIZ filename
  5766                                  				; AL = access mode
  5767                                  				; 0 - read
  5768 00001279 7311                    		jnc	short TYPECONT
  5769 0000127B BA[0837]                		mov	dx,FNOTFOUNDPTR
  5770 0000127E 83F802                  		cmp	ax,2
  5771 00001281 74CD                    		jz	short ERRJ
  5772 00001283 BA[5C3C]                		mov	dx,BADCPMESPTR
  5773 00001286 F9                      		stc
  5774 00001287 E8EB0B                  		call	GET_EXT_ERR_NUMBER
  5775                                  
  5776                                  		;jmp	CERROR
  5777 0000128A EBC4                    		jmp	short ERRJ
  5778                                  TYPECONT:
  5779 0000128C C606[DC4A]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5780 00001291 89C3                    		mov	bx,ax		; Handle
  5781 00001293 8E1E[5841]              		mov	ds,[TPA]
  5782 00001297 31D2                    		xor	dx,dx
  5783                                  TYPELP:
  5784 00001299 2E803E[DC4A]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5785 0000129F 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5786 000012A1 2E8B0E[7741]            		mov	cx,[cs:BYTCNT]	; No, continue
  5787 000012A6 B43F                    		mov	ah,READ ; 3Fh
  5788 000012A8 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5789                                  				; BX = file handle,CX = number	of bytes to read
  5790                                  				; DS:DX	-> buffer
  5791 000012AA 89C1                    		mov	cx,ax
  5792 000012AC E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5793                                  					; Check to see if a ^Z was read.
  5794 000012AE 1E                      		push	ds
  5795 000012AF 07                      		pop	es		
  5796 000012B0 31FF                    		xor	di,di
  5797 000012B2 50                      		push	ax
  5798 000012B3 B01A                    		mov	al,1Ah
  5799 000012B5 F2AE                    		repne scasb
  5800 000012B7 58                      		pop	ax
  5801 000012B8 91                      		xchg	ax,cx
  5802 000012B9 83F800                  		cmp	ax,0
  5803 000012BC 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5804 000012BE 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5805 000012C2 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5806                                  FOUNDZ:
  5807 000012C4 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5808 000012C6 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5809 000012C7 0E                      		push	cs		;  will be typed.
  5810 000012C8 07                      		pop	es
  5811 000012C9 2EF616[DC4A]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5812                                  					;  will quit after this write.
  5813                                  TYPECONT2:
  5814 000012CE 53                      		push	bx
  5815 000012CF BB0100                  		mov	bx,1
  5816 000012D2 B440                    		mov	ah,WRITE ; 40h
  5817 000012D4 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5818                                  				; BX = file handle, CX = number of bytes to write,
  5819                                  				; DS:DX -> buffer
  5820 000012D6 5B                      		pop	bx
  5821 000012D7 720A                    		jc	short ERROR_OUTPUTJ
  5822 000012D9 39C8                    		cmp	ax,cx
  5823 000012DB 74BC                    		jz	short TYPELP
  5824 000012DD 49                      		dec	cx
  5825 000012DE 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5826 000012E0 7501                    		jnz	short ERROR_OUTPUTJ
  5827                                  TYPEFIL_RETN:
  5828 000012E2 C3                      		retn
  5829                                  ERROR_OUTPUTJ:
  5830 000012E3 BB0100                  		mov	bx,1
  5831 000012E6 B80044                  		mov	ax,IOCTL*256 ; 4400h
  5832 000012E9 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5833                                  				; BX = file or device handle
  5834                                  		;test	dl,devid_ISDEV
  5835 000012EB F6C280                  		test	dl,80h
  5836 000012EE 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5837 000012F0 E9C706                  		jmp	ERROR_OUTPUT
  5838                                  
  5839                                  ; ---------------------------------------------------------------------------
  5840                                  
  5841                                  ; VOLUME command displays the volume ID on the specified drive
  5842                                  
  5843                                  VOLUME:
  5844                                  		; MSDOS 6.0
  5845                                  		;mov	si,81H
  5846                                  		;mov	di,offset trangroup:parse_vol
  5847                                  		;			;AN000; Get address of PARSE_VOL
  5848                                  		;xor	cx,cx		;AN000; clear cx,dx
  5849                                  		;xor	dx,dx		;AN000;
  5850                                  		;invoke	parse_with_msg	;AC018; call parser
  5851                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5852                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5853                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5854                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5855                                  
  5856                                  ; We have parsed off the drive. See if there are any more chars left
  5857                                  
  5858                                  		;mov	di,offset trangroup:parse_vol	
  5859                                  					;AC000; get address of parse_vol
  5860                                  		;xor	dx,dx		;AC000;
  5861                                  		;invoke	parse_check_eol ;AC000; call parser
  5862                                  		;jz	OkVolArg	;AC000; yes, end of road
  5863                                  
  5864                                  ; The line was not interpretable. Report an error.
  5865                                  
  5866                                  ;badvolarg:
  5867                                  		;jmp	Cerror
  5868                                  
  5869                                  		; MSDOS 3.3
  5870 000012F3 BE8100                  		mov	si,81h
  5871 000012F6 E84906                  		call	SCANOFF		; Skip to first non-delim
  5872                                  		;mov	ah,[5Ch]
  5873 000012F9 8A265C00                		mov	ah,[FCB]
  5874                                  		;mov	byte [5Ch],0
  5875 000012FD C6065C0000              		mov	byte [FCB],0
  5876 00001302 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5877 00001304 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5878                                  		;mov	[5Ch],ah
  5879 00001306 88265C00                		mov	[FCB],ah
  5880 0000130A AC                      		lodsb
  5881 0000130B AC                      		lodsb
  5882 0000130C 3C3A                    		cmp	al,':'
  5883 0000130E 7507                    		jnz	short VOLUME_ERR
  5884 00001310 E82F06                  		call	SCANOFF
  5885 00001313 3C0D                    		cmp	al,0Dh
  5886 00001315 7406                    		jz	short OKVOLARG
  5887                                  VOLUME_ERR:
  5888 00001317 BA[5938]                		mov	dx,BADDRVPTR
  5889 0000131A E9C908                  		jmp	CERROR
  5890                                  
  5891                                  ; ---------------------------------------------------------------------------
  5892                                  
  5893                                  OKVOLARG:
  5894 0000131D E81506                  		call	CRLF2
  5895 00001320 1E                      		push	ds
  5896 00001321 07                      		pop	es
  5897                                  		;mov	di,55h
  5898 00001322 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5899 00001325 B0FF                    		mov	al,-1
  5900 00001327 AA                      		stosb
  5901 00001328 31C0                    		xor	ax,ax
  5902 0000132A AB                      		stosw
  5903 0000132B AB                      		stosw
  5904 0000132C AA                      		stosb
  5905 0000132D B008                    		mov	al,8		; Look for volume label
  5906 0000132F AA                      		stosb
  5907 00001330 47                      		inc	di		; Skip drive byte
  5908 00001331 B90B00                  		mov	cx,11
  5909 00001334 B03F                    		mov	al,'?'
  5910 00001336 F3AA                    		rep stosb
  5911 00001338 BA[4F42]                		mov	dx,DIRBUF
  5912 0000133B B41A                    		mov	ah,SET_DMA ; 1Ah
  5913 0000133D CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5914                                  				; DS:DX	-> disk	transfer buffer
  5915                                  		;mov	dx,55h
  5916 0000133F BA5500                  		mov	dx,FCB-7
  5917 00001342 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5918 00001344 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5919                                  				; DS:DX	-> FCB
  5920 00001346 E98215                  		jmp	PRINTVOL
  5921                                  
  5922                                  ;============================================================================
  5923                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5924                                  ;============================================================================
  5925                                  ; 08/10/2018 - Retro DOS v3.0
  5926                                  
  5927                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5928                                  
  5929                                  ; ---------------------------------------------------------------------------
  5930                                  
  5931                                  ; MSDOS 6.0
  5932                                  ;***	Version - display DOS version
  5933                                  ;
  5934                                  ;	SYNTAX	ver [/debug]
  5935                                  ;
  5936                                  ;		/debug - display additional DOS configuration info
  5937                                  ;
  5938                                  ;	ENTRY	command-line tail is in PSP
  5939                                  ;
  5940                                  ;	EXIT	if successful, nothing
  5941                                  ;		if parse fails,
  5942                                  ;		  parse error message is set up (for Std_EPrintf)
  5943                                  ;		    AX = system parser error code
  5944                                  ;		    DX = ptr to message block
  5945                                  ;		  we jump to CError
  5946                                  ;
  5947                                  ;	EFFECTS
  5948                                  ;	  If parse fails, a parse error message is displayed.
  5949                                  ;	  Otherwise, version message is displayed.
  5950                                  ;	  If /debug is specified, additional DOS info is displayed.
  5951                                  
  5952                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5953                                  ;
  5954                                  ;;	Parse command line for /debug switch.
  5955                                  ;
  5956                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5957                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5958                                  ;	xor	cx,cx				; CX = # positional param's found
  5959                                  ;	invoke	Parse_With_Msg
  5960                                  ;
  5961                                  ;	mov	bl,1			; BL = flag = /debug present
  5962                                  ;	cmp	ax,RESULT_NO_ERROR
  5963                                  ;	je	verPrintVer		; something parsed - must be /debug
  5964                                  ;	dec	bl			; BL = flag = no /debug present
  5965                                  ;	cmp	ax,END_OF_LINE
  5966                                  ;	je	verPrintVer		; reached end of line - ok
  5967                                  ;
  5968                                  ;;	The parse failed.  Error message has been set up.
  5969                                  ;
  5970                                  ;	jmp	CError
  5971                                  ;
  5972                                  ;verPrintVer:
  5973                                  ;	push	bx			; save /debug flag
  5974                                  ;	call	Crlf2
  5975                                  ;	call	Print_Version
  5976                                  ;	call	Crlf2
  5977                                  ;	pop	bx   			; BL = /debug flag
  5978                                  ;	or	bl,bl
  5979                                  ;	jz	verDone			; /debug is false - we're done
  5980                                  ;
  5981                                  ;;*	For /debug, display DOS internal revision and DOS location
  5982                                  ;;	(low memory, HMA, or ROM).
  5983                                  ;
  5984                                  ;;	Bugbug:	use symbols for bitmasks below.
  5985                                  ;
  5986                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5987                                  ;	int	21h
  5988                                  ;	mov	al,dl			;revision number in dl; M013
  5989                                  ;	mov	bh,dh			;flags in dh now; M013
  5990                                  ;;M032	and	al,7			; AL = DOS internal revision
  5991                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5992                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5993                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5994                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5995                                  ;	mov	One_Char_Val,al
  5996                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5997                                  ;	invoke	Std_Printf		; print DOS internal revision
  5998                                  ;
  5999                                  ;	mov	cl,4
  6000                                  ;	shr	bh,cl			; CY = DOS in ROM
  6001                                  ;	jc	verRom
  6002                                  ;	shr	bh,1			; CY = DOS in HMA
  6003                                  ;	jc	verHma
  6004                                  ;
  6005                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  6006                                  ;
  6007                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  6008                                  ;	jmp	short verPrintLoc
  6009                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  6010                                  ;	jmp	short verPrintLoc
  6011                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  6012                                  ;verPrintLoc:
  6013                                  ;	invoke	Std_Printf
  6014                                  ;verDone:
  6015                                  ;	jmp	Crlf2
  6016                                  
  6017                                  		; MSDOS 3.3
  6018                                  VERSION:
  6019 00001349 E8E905                  		call	CRLF2
  6020 0000134C E80300                  		call	PRINT_VERSION
  6021 0000134F E9E305                  		jmp	CRLF2
  6022                                  
  6023                                  ; =============== S U B	R O U T	I N E =======================================
  6024                                  
  6025                                  PRINT_VERSION:
  6026 00001352 B430                    		mov	ah,GET_VERSION ; 30h
  6027 00001354 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  6028                                  				; Return: AL = major version number (00h for DOS 1.x)
  6029 00001356 50                      		push	ax
  6030 00001357 30E4                    		xor	ah,ah
  6031 00001359 A3[4243]                		mov	[MAJOR_VER_NUM],ax
  6032 0000135C 58                      		pop	ax
  6033 0000135D 86E0                    		xchg	ah,al
  6034 0000135F 30E4                    		xor	ah,ah
  6035 00001361 A3[4443]                		mov	[MINOR_VER_NUM],ax
  6036 00001364 BA[373A]                		mov	dx,VERMESPTR
  6037 00001367 E9AA20                  		jmp	STD_PRINTF
  6038                                  
  6039                                  ; =============== S U B	R O U T	I N E =======================================
  6040                                  
  6041                                  PRINT_PROMPT:
  6042 0000136A 1E                      		push	ds
  6043 0000136B 0E                      		push	cs
  6044 0000136C 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  6045 0000136D 06                      		push	es
  6046 0000136E E8F503                  		call	FIND_PROMPT	; Look for prompt string
  6047 00001371 7206                    		jc	short PP0	; Can't find one	
  6048 00001373 26803D00                		cmp	byte [es:di],0
  6049 00001377 750A                    		jnz	short PP1
  6050                                  PP0:					; Use default prompt
  6051 00001379 E86D00                  		call	PRINT_DRIVE
  6052                                  		;mov	al,'>'
  6053 0000137C B03E                    		mov	al,SYM
  6054 0000137E E85500                  		call	PRINT_CHAR
  6055 00001381 EB38                    		jmp	short PP5
  6056                                  PP1:
  6057 00001383 268A05                  		mov	al,[es:di]	; Get a char
  6058 00001386 47                      		inc	di
  6059 00001387 08C0                    		or	al,al
  6060 00001389 7430                    		jz	short PP5	; Nul terminated
  6061                                  		;cmp	al,[DOLLAR]	; Meta character
  6062                                  		; 01/03/2023
  6063 0000138B 3C24                    		cmp	al,dollar ; '$'
  6064 0000138D 7405                    		jz	short PP2	; Nope
  6065 0000138F E84400                  		call	PRINT_CHAR
  6066 00001392 EBEF                    		jmp	short PP1
  6067                                  PP2:
  6068 00001394 268A05                  		mov	al,[es:di]
  6069 00001397 47                      		inc	di
  6070                                  		;mov	bx,CLSSTRING+2	; "[2J"
  6071 00001398 BB[AC3C]                		mov	bx,PROMPT_TABLE-3
  6072 0000139B 08C0                    		or	al,al
  6073 0000139D 741C                    		jz	short PP5
  6074                                  PP3:
  6075 0000139F 83C303                  		add	bx,3
  6076                                  		;call	UPCONV
  6077 000013A2 E84B04                  		call	UPCONV_MAPCALL
  6078 000013A5 3A07                    		cmp	al,[bx]
  6079 000013A7 7407                    		jz	short PP4
  6080 000013A9 803F00                  		cmp	byte [bx],0
  6081 000013AC 75F1                    		jnz	short PP3
  6082 000013AE EBD3                    		jmp	short PP1
  6083                                  PP4:
  6084 000013B0 06                      		push	es
  6085 000013B1 57                      		push	di
  6086 000013B2 0E                      		push	cs
  6087 000013B3 07                      		pop	es
  6088 000013B4 FF5701                  		call	word [bx+1]
  6089 000013B7 5F                      		pop	di
  6090 000013B8 07                      		pop	es
  6091 000013B9 EBC8                    		jmp	short PP1
  6092                                  PP5:
  6093 000013BB 07                      		pop	es		; Restore segments
  6094 000013BC 1F                      		pop	ds
  6095 000013BD C3                      		retn
  6096                                  
  6097                                  ; ---------------------------------------------------------------------------
  6098                                  
  6099                                  PRINT_BACK:
  6100 000013BE BA[A43C]                		mov	dx,DBACKPTR
  6101 000013C1 E95020                  		jmp	STD_PRINTF
  6102                                  
  6103                                  ; ---------------------------------------------------------------------------
  6104                                  
  6105                                  PRINT_EQ:
  6106 000013C4 B03D                    		mov	al,'='
  6107 000013C6 EB0E                    		jmp	short PRINT_CHAR
  6108                                  
  6109                                  ; ---------------------------------------------------------------------------
  6110                                  
  6111                                  PRINT_ESC:
  6112 000013C8 B01B                    		mov	al,1Bh
  6113 000013CA EB0A                    		jmp	short PRINT_CHAR
  6114                                  
  6115                                  ; ---------------------------------------------------------------------------
  6116                                  
  6117                                  PRINT_G:
  6118                                  		;mov	al,[RABRACKET]
  6119                                  		; 01/03/2023
  6120 000013CC B03E                    		mov	al,rabracket  ; '>'
  6121 000013CE EB06                    		jmp	short PRINT_CHAR
  6122                                  
  6123                                  ; ---------------------------------------------------------------------------
  6124                                  
  6125                                  PRINT_L:
  6126                                  		;mov	al,[LABRACKET]
  6127                                  		; 01/03/2023
  6128 000013D0 B03C                    		mov	al,labracket ; '<'
  6129 000013D2 EB02                    		jmp	short PRINT_CHAR
  6130                                  
  6131                                  ; ---------------------------------------------------------------------------
  6132                                  
  6133                                  PRINT_B:
  6134                                  		;mov	al,[VBAR]
  6135                                  		; 01/03/2023
  6136                                  		;mov	al,vbar
  6137                                  		;mov	al,'|'
  6138 000013D4 B07C                    		mov	al,ALTPIPECHR ; '|'
  6139                                  
  6140                                  ; =============== S U B	R O U T	I N E =======================================
  6141                                  
  6142                                  PRINT_CHAR:
  6143                                  		; MSDOS 6.0
  6144                                  
  6145                                  ;	Bugbug:	Why bother with ds,es here?
  6146                                  		
  6147                                  		;push	es
  6148                                  		;push	ds
  6149                                  		;pop	es
  6150                                  		;push	di
  6151                                  		;push	dx
  6152                                  		;mov	dl,al		;AC000; Get char into al
  6153                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6154                                  		;int	21h		;AC000;
  6155                                  		;pop	dx
  6156                                  		;pop	di
  6157                                  		;pop	es
  6158                                  		;retn
  6159                                  
  6160                                  		; MSDOS 3.3
  6161 000013D6 06                      		push	es
  6162 000013D7 1E                      		push	ds
  6163 000013D8 07                      		pop	es
  6164 000013D9 57                      		push	di
  6165 000013DA 52                      		push	dx
  6166 000013DB BF[4643]                		mov	di,ONE_CHAR_VAL	
  6167 000013DE AA                      		stosb
  6168 000013DF BA[403A]                		mov	dx,ONECHRVALPTR
  6169 000013E2 E82F20                  		call	STD_PRINTF
  6170 000013E5 5A                      		pop	dx
  6171 000013E6 5F                      		pop	di
  6172 000013E7 07                      		pop	es
  6173 000013E8 C3                      		retn
  6174                                  
  6175                                  ; ---------------------------------------------------------------------------
  6176                                  
  6177                                  PRINT_DRIVE:
  6178 000013E9 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6179 000013EB CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6180                                  		;add	al,'A'
  6181                                  		;add	al,[CAPITAL_A]
  6182                                  		; 01/03/2023
  6183 000013ED 0441                    		add	al,capital_A  ; add al,'A'
  6184                                  		;call	PRINT_CHAR
  6185                                  		;retn
  6186                                  		; 01/03/2023
  6187 000013EF EBE5                    		jmp	PRINT_CHAR	
  6188                                  
  6189                                  ; ---------------------------------------------------------------------------
  6190                                  
  6191                                  BUILD_DIR_FOR_PROMPT:
  6192 000013F1 30D2                    		xor	dl,dl
  6193 000013F3 BE[4F42]                		mov	si,BWDBUF
  6194 000013F6 89F7                    		mov	di,si
  6195 000013F8 A0[6A41]                		mov	al,[CURDRV]
  6196 000013FB 0441                    		add	al,'A'
  6197 000013FD B43A                    		mov	ah,':'
  6198 000013FF AB                      		stosw
  6199 00001400 A0[5B41]                		mov	al,[DIRCHAR]
  6200 00001403 AA                      		stosb
  6201 00001404 87F7                    		xchg	si,di
  6202 00001406 893E[3343]              		mov	[STRING_PTR_2],di
  6203 0000140A B447                    		mov	ah,CURRENT_DIR ; 47h
  6204 0000140C CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6205                                  				; DL = drive (0=default,1=A,etc.)
  6206                                  				; DS:SI	points to 64-byte buffer area
  6207 0000140E BA[4F36]                		mov	dx,STRINGBUF2PTR
  6208 00001411 7303                    		jnc	short DOPRINT
  6209 00001413 BA[FB38]                		mov	dx,BADCURDRVPTR
  6210                                  DOPRINT:
  6211                                  		;call	STD_PRINTF
  6212                                  		;retn
  6213                                  		; 01/03/2023
  6214 00001416 E9FB1F                  		jmp	STD_PRINTF
  6215                                  
  6216                                  ; =============== S U B	R O U T	I N E =======================================
  6217                                  
  6218                                  BUILD_DIR_FOR_CHDIR:
  6219 00001419 E80D00                  		call	BUILD_DIR_STRING
  6220 0000141C BA[4F42]                		mov	dx,DIRBUF
  6221 0000141F 8916[3343]              		mov	[STRING_PTR_2],dx
  6222                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6223 00001423 BA[4F36]                		mov	dx,STRINGBUF2PTR
  6224                                  		;call	STD_PRINTF
  6225                                  		;retn
  6226                                  		; 01/03/2023
  6227 00001426 E9EB1F                  		jmp	STD_PRINTF
  6228                                  
  6229                                  
  6230                                  ; =============== S U B	R O U T	I N E =======================================
  6231                                  
  6232                                  BUILD_DIR_STRING:
  6233 00001429 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6234 0000142D 88D0                    		mov	al,dl
  6235 0000142F 0440                    		add	al,'@'
  6236 00001431 3C40                    		cmp	al,'@'
  6237 00001433 7506                    		jnz	short GOTDRIVE
  6238 00001435 0206[6A41]              		add	al,[CURDRV]
  6239 00001439 FEC0                    		inc	al
  6240                                  GOTDRIVE:
  6241 0000143B 50                      		push	ax
  6242 0000143C BE[5242]                		mov	si,BWDBUF+3
  6243 0000143F B447                    		mov	ah,CURRENT_DIR ; 47h
  6244 00001441 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6245                                  				; DL = drive (0=default,1=A,etc.)
  6246                                  				; DS:SI	points to 64-byte buffer area
  6247 00001443 7305                    		jnc	short DPBISOK
  6248 00001445 0E                      		push	cs
  6249 00001446 1F                      		pop	ds
  6250 00001447 E95506                  		jmp	DRVBAD
  6251                                  DPBISOK:
  6252 0000144A BF[4F42]                		mov	di,BWDBUF
  6253 0000144D 89FA                    		mov	dx,di
  6254 0000144F 58                      		pop	ax
  6255 00001450 B43A                    		mov	ah,':'
  6256 00001452 AB                      		stosw
  6257 00001453 A0[5B41]                		mov	al,[DIRCHAR]
  6258 00001456 AA                      		stosb
  6259 00001457 C3                      		retn
  6260                                  
  6261                                  ; ---------------------------------------------------------------------------
  6262                                  
  6263                                  PATH:
  6264                                  		; MSDOS 6.0
  6265                                  		;xor	al,al		;AN049; Set up holding buffer
  6266                                  		;mov	di,offset Trangroup:srcxname
  6267                                  					;AN049;   for PATH while parsing
  6268                                  		;stosb				;AN049; Initialize PATH to null
  6269                                  		;dec	di			;AN049; point to the start of buffer
  6270                                  		;invoke	PGetarg 		; Pre scan for arguments
  6271                                  		;jz	disppath		; Print the current path
  6272                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6273                                  		;jnz	pathslp 		;AC049;
  6274                                  		;inc	si			;AN049; point past semicolon
  6275                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6276                                  ;pathslp:					; Get the user specified path
  6277                                  		;lodsb				; Get a character
  6278                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6279                                  		;jz	path_eol		;AC049; yes - end of command
  6280                                  		;invoke	testkanj		;See if DBCS
  6281                                  		;jz	notkanj2		;No - continue
  6282                                  		;stosb				;AC049; Yes - store the first byte
  6283                                  		;lodsb				;skip second byte of DBCS
  6284                                  ;path_hold:					;AN049;
  6285                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6286                                  		;jmp	short pathslp		;continue parsing
  6287                                  ;notkanj2:
  6288                                  		;invoke	upconv			;upper case the character
  6289                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6290                                  		;jz	path_hold		;AC049; go store it
  6291                                  		;invoke	delim			;delimiter?
  6292                                  		;jnz	path_hold		;AC049; no - go store character
  6293                                  ;scan_white:					;AN049; make sure were at EOL
  6294                                  		;lodsb				;AN049; get a character
  6295                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6296                                  		;jz	path_eol		;AN049; yes - go set path
  6297                                  		;cmp	al,blank		;AN049; whitespace?
  6298                                  		;jz	scan_white		;AN049; yes - continue scanning
  6299                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6300                                  		;jz	scan_white		;AN049; yes - continue scanning
  6301                                  
  6302                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6303                                  						;AN049; no - set up error message
  6304                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6305                                  						;AN049; get "Too many parameters" message number
  6306                                  		;mov	msg_disp_class,parse_msg_class
  6307                                  						;AN049; set up parse error msg class
  6308                                  		;jmp	cerror			;AN049;
  6309                                  ;path_eol:					;AN049; Parsing was clean
  6310                                  		;xor	al,al			;AN049; null terminate the PATH
  6311                                  		;stosb				;AN049;    buffer
  6312                                  		;invoke	find_path		;AN049; Find PATH in environment
  6313                                  		;invoke	delete_path		;AC049; Delete any offending name
  6314                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6315                                  		;invoke	move_name		;AC049; move in PATH=
  6316                                  		;mov	si,offset Trangroup:srcxname	
  6317                                  						;AN049; Set up source as PATH buffer
  6318                                  ;store_path:					;AN049; Store the PATH in the environment
  6319                                  		;lodsb				;AN049; Get a character
  6320                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6321                                  		;jz	got_paths		;AN049; yes - exit
  6322                                  		;invoke	store_char		;AN049; no - store character
  6323                                  		;jmp	short store_path	;AN049; continue
  6324                                  ;got_paths:					;AN049; we're finished
  6325                                  		;xor	ax,ax			;	null terminate the PATH in
  6326                                  		;stosw				;    	the environment
  6327                                  		;return
  6328                                  ;disppath:
  6329                                  		;invoke	find_path		;AN049;
  6330                                  		;call	print_path
  6331                                  		;call	crlf2
  6332                                  		;retn
  6333                                  
  6334                                  		; MSDOS 3.3
  6335 00001458 E80603                  		call	FIND_PATH		; Find PATH in environment
  6336 0000145B E83809                  		call	PGETARG			; Pre scan for arguments
  6337 0000145E 742A                    		jz	short DISPPATH		; Print the current path
  6338 00001460 E8DC02                  		call	DELETE_PATH		; Delete any offending name
  6339 00001463 E86803                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6340 00001466 E84603                  		call	MOVE_NAME		; Move in PATH=
  6341 00001469 E82A09                  		call	PGETARG
  6342 0000146C 3C3B                    		cmp	al,';'
  6343 0000146E 7416                    		jz	short GOTPATHS
  6344                                  PATHSLP:
  6345 00001470 AC                      		lodsb
  6346 00001471 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6347 00001473 7411                    		jz	short GOTPATHS		; yes - exit
  6348                                  		;call	UPCONV
  6349 00001475 E87803                  		call	UPCONV_MAPCALL		; convert to uppercase
  6350 00001478 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6351 0000147A 7405                    		jz	short NOTDELIM		; go set path
  6352 0000147C E8CB04                  		call	DELIM			; is it delim/null char ?
  6353 0000147F 7405                    		jz	short GOTPATHS		; yes - exit
  6354                                  NOTDELIM:
  6355 00001481 E87C03                  		call	STORE_CHAR		; no - store character
  6356 00001484 EBEA                    		jmp	short PATHSLP
  6357                                  GOTPATHS:
  6358 00001486 31C0                    		xor	ax,ax			; null terminate the PATH
  6359 00001488 AB                      		stosw				; in the environment
  6360 00001489 C3                      		retn
  6361                                  DISPPATH:
  6362 0000148A E80300                  		call	PRINT_PATH
  6363                                  		;call	CRLF2
  6364                                  		;retn
  6365                                  		; 02/03/2023
  6366 0000148D E9A504                  		jmp	CRLF2
  6367                                  
  6368                                  ; =============== S U B	R O U T	I N E =======================================
  6369                                  
  6370                                  PRINT_PATH:
  6371 00001490 26803D00                		cmp	byte [es:di],0
  6372 00001494 750A                    		jnz	short PATH1
  6373                                  PATH0:
  6374 00001496 BA[1B3B]                		mov	dx,NULLPATHPTR
  6375 00001499 0E                      		push	cs
  6376 0000149A 07                      		pop	es
  6377 0000149B 0E                      		push	cs
  6378 0000149C 1F                      		pop	ds
  6379 0000149D E9741F                  		jmp	STD_PRINTF
  6380                                  PATH1:
  6381 000014A0 06                      		push	es
  6382 000014A1 1F                      		pop	ds
  6383 000014A2 83EF05                  		sub	di,5
  6384 000014A5 89FE                    		mov	si,di
  6385 000014A7 E83E03                  		call	SCASB2		; Look for null
  6386 000014AA 81F9FF00                		cmp	cx,0FFh
  6387 000014AE 74E6                    		jz	short PATH0
  6388 000014B0 0E                      		push	cs
  6389 000014B1 07                      		pop	es
  6390 000014B2 BF[AD42]                		mov	di,ARG_BUF
  6391 000014B5 BA0001                  		mov	dx,100h
  6392 000014B8 29CA                    		sub	dx,cx
  6393 000014BA 87D1                    		xchg	dx,cx
  6394 000014BC F3A4                    		rep movsb
  6395 000014BE BA[3336]                		mov	dx,ARG_BUF_PTR
  6396 000014C1 0E                      		push	cs
  6397 000014C2 1F                      		pop	ds
  6398 000014C3 E94E1F                  		jmp	STD_PRINTF
  6399                                  
  6400                                  ; ---------------------------------------------------------------------------
  6401                                  
  6402                                  ; ****************************************************************
  6403                                  ; *
  6404                                  ; * ROUTINE:	 CLS
  6405                                  ; *
  6406                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6407                                  ; *		 installed, send a control string to clear the
  6408                                  ; *		 screen.
  6409                                  ; *
  6410                                  ; * INPUT:	 command line at offset 81H
  6411                                  ; *
  6412                                  ; * OUTPUT:	 none
  6413                                  ; *
  6414                                  ; ****************************************************************
  6415                                  
  6416                                  ; MSDOS 3.3
  6417                                  
  6418                                  CLS:
  6419 000014C6 BB0100                  		mov	bx,STDOUT ; 1
  6420 000014C9 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6421 000014CC CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6422                                  				; BX = file or device handle
  6423 000014CE F6C280                  		test	dl,80h	; devid_ISDEV
  6424 000014D1 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6425 000014D3 F6C210                  		test	dl,10h  ; devid_SPECIAL
  6426 000014D6 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6427                                  
  6428 000014D8 B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6429 000014DB CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6430                                  				; AL = interrupt number
  6431                                  				; Return: ES:BX	= value	of interrupt vector
  6432 000014DD 8CC2                    		mov	dx,es
  6433 000014DF B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6434 000014E2 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6435                                  				; AL = interrupt number
  6436                                  				; Return: ES:BX	= value	of interrupt vector
  6437 000014E4 8CC0                    		mov	ax,es
  6438 000014E6 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6439 000014E8 7735                    		ja	short ANSICLS
  6440                                  
  6441 000014EA B40F                    		mov	ah,0Fh
  6442 000014EC CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6443                                  				; Return: AH = number of columns on screen
  6444                                  				; AL = current video mode
  6445                                  				; BH = current active display page
  6446 000014EE 3C03                    		cmp	al,3
  6447 000014F0 7609                    		jbe	short DOALPHA
  6448 000014F2 3C07                    		cmp	al,7
  6449 000014F4 7405                    		jz	short DOALPHA
  6450 000014F6 B400                    		mov	ah,0
  6451 000014F8 CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6452                                  				; AL = mode
  6453 000014FA C3                      		retn
  6454                                  
  6455                                  DOALPHA:
  6456 000014FB B40B                    		mov	ah,0Bh	; Set overscan to black
  6457 000014FD 31DB                    		xor	bx,bx
  6458 000014FF CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6459                                  				; BH = 00h, BL = border color
  6460                                  				; BH = 01h, BL = palette (0-3)
  6461 00001501 B40F                    		mov	ah,0Fh
  6462 00001503 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6463                                  				; Return: AH = number of columns on screen
  6464                                  				; AL = current video mode
  6465                                  				; BH = current active display page
  6466 00001505 88E2                    		mov	dl,ah
  6467 00001507 FECA                    		dec	dl
  6468 00001509 B618                    		mov	dh,24
  6469 0000150B 31C0                    		xor	ax,ax
  6470 0000150D 89C1                    		mov	cx,ax
  6471 0000150F BB0007                  		mov	bx,700h
  6472 00001512 B406                    		mov	ah,6
  6473 00001514 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6474                                  				; AL = number of lines to scroll window	
  6475                                  				;	(0 = blank whole window)
  6476                                  				; BH = attributes to be	used on	blanked	lines
  6477                                  				; CH,CL	= row,column of	upper left corner of window 
  6478                                  				;	  to scroll
  6479                                  				; DH,DL	= row,column of	lower right corner of window
  6480 00001516 31D2                    		xor	dx,dx
  6481 00001518 B700                    		mov	bh,0
  6482 0000151A B402                    		mov	ah,2
  6483 0000151C CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6484                                  				; DH,DL	= row,column (0,0 = upper left)
  6485                                  				; BH = page number
  6486 0000151E C3                      		retn
  6487                                  
  6488                                  ANSICLS:
  6489 0000151F BE[AA3C]                		mov	si,CLSSTRING
  6490 00001522 AC                      		lodsb
  6491 00001523 88C1                    		mov	cl,al
  6492 00001525 30ED                    		xor	ch,ch
  6493 00001527 B406                    		mov	ah,RAW_CON_IO ; 6
  6494                                  CLRLOOP:
  6495 00001529 AC                      		lodsb
  6496 0000152A 88C2                    		mov	dl,al
  6497 0000152C CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6498                                  				; DL = character <> FFh
  6499                                  				;  Return: ZF set = no character
  6500                                  				;   ZF clear = character recieved, AL = character
  6501 0000152E E2F9                    		loop	CLRLOOP
  6502 00001530 C3                      		retn
  6503                                  
  6504                                  ; ---------------------------------------------------------------------------
  6505                                  
  6506                                  ; MSDOS 6.0
  6507                                  
  6508                                  ;ANSI_installed		equ    0ffh
  6509                                  ;
  6510                                  ;CLS:
  6511                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6512                                  ;	mov	al,0			;AN000;
  6513                                  ;	int	2fh			;AN000;
  6514                                  ;	cmp	al,ANSI_installed	;AN000;
  6515                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6516                                  ;
  6517                                  ;check_lines:
  6518                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6519                                  ;					;AN000; get lines per page on display
  6520                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6521                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6522                                  ;	mov	cl,get_generic		;AN000; get information
  6523                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6524                                  ;	int	21h			;AN000;
  6525                                  ;	jc	no_variable		;AN000; function had error, use default
  6526                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6527                                  ;	mov	dh,al			;AN000; set number of rows
  6528                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6529                                  ;	mov	dl,al			;AN000; set number of columns
  6530                                  ;	jmp	short regcls		;AN000; go do cls
  6531                                  ;
  6532                                  ;no_variable:
  6533                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6534                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6535                                  ;	int	21h			;AC000;
  6536                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6537                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6538                                  ;	test	dl,devid_SPECIAL	;AC000;
  6539                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6540                                  ;
  6541                                  ;ansicls:
  6542                                  ;	call	ansi_cls		;AN000; clear the screen
  6543                                  ;	jmp	short cls_ret		;AN000; exit
  6544                                  ;
  6545                                  ;;
  6546                                  ;; Get video mode
  6547                                  ;;
  6548                                  ;
  6549                                  ;cls_normal:				;AC000;
  6550                                  ;
  6551                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6552                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6553                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6554                                  ;	jbe	DoAlpha
  6555                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6556                                  ;	jz	DoAlpha
  6557                                  ;;
  6558                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6559                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6560                                  ;; screen too.
  6561                                  ;;
  6562                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6563                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6564                                  ;	jmp	short cls_ret		;AC000; exit
  6565                                  ;
  6566                                  ;DoAlpha:
  6567                                  ;;
  6568                                  ;; Get video mode and number of columns to scroll
  6569                                  ;;
  6570                                  ;
  6571                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6572                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6573                                  ;;M01   area
  6574                                  ;;M01   Commented out code here is the original
  6575                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6576                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6577                                  ;;M01	mov	dl,ah
  6578                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6579                                  ;
  6580                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6581                                  ;
  6582                                  ;	push	ds
  6583                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6584                                  ;	MOV	DS,AX			;  *			M01
  6585                                  ;	Assume	DS:ROMBIOS_DATA
  6586                                  ;
  6587                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6588                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6589                                  ;	pop	ds			;			M01
  6590                                  ;	Assume	DS:Trangroup
  6591                                  ;
  6592                                  ;	or	dh,dh			; Q:ZERO		M01
  6593                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6594                                  ;
  6595                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6596                                  ;
  6597                                  ;regcls:
  6598                                  ;	inc	dh			; height+1		M018
  6599                                  ;	call	reg_cls 		; go clear the screen
  6600                                  ;
  6601                                  ;cls_ret:
  6602                                  ;	ret				; exit
  6603                                  
  6604                                  ; ---------------------------------------------------------------------------
  6605                                  
  6606                                  ; MSDOS 6.0
  6607                                  
  6608                                  ; ****************************************************************
  6609                                  ; *
  6610                                  ; * ROUTINE:	 REG_CLS
  6611                                  ; *
  6612                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6613                                  ; *
  6614                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6615                                  ; *		 DH = NUMBER OF ROWS
  6616                                  ; *
  6617                                  ; * OUTPUT:	 none
  6618                                  ; *
  6619                                  ; ****************************************************************
  6620                                  
  6621                                  ;reg_cls proc	near
  6622                                  ;
  6623                                  ;;
  6624                                  ;; Set overscan to black.
  6625                                  ;;
  6626                                  ;	dec	dh			;  decrement rows and columns
  6627                                  ;	dec	dl			;     to zero base
  6628                                  ;	push	dx			;  save rows,columns
  6629                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6630                                  ;	xor	bx,bx
  6631                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6632                                  ;	pop	dx			;  retore rows,colums
  6633                                  ;
  6634                                  ;	xor	ax,ax			;  zero out ax
  6635                                  ;	mov	CX,ax			;     an cx
  6636                                  ;;
  6637                                  ;; Scroll active page
  6638                                  ;;
  6639                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6640                                  ;	mov	bh,video_attribute	; attribute for blank line
  6641                                  ;	xor	bl,bl			; set BL to 0
  6642                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6643                                  ;;
  6644                                  ;; Seek to cursor to 0,0
  6645                                  ;;
  6646                                  ;;M022 following two lines added
  6647                                  ;	mov	ah,get_video_state	; get current video page in BH
  6648                                  ;	int	video_io_int
  6649                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6650                                  ;	xor	dx,dx			; row and column 0
  6651                                  ;;M022	mov	bh.0
  6652                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6653                                  ;
  6654                                  ;	ret
  6655                                  ;
  6656                                  ;reg_cls endp
  6657                                  
  6658                                  ; ---------------------------------------------------------------------------
  6659                                  
  6660                                  ; MSDOS 6.0
  6661                                  
  6662                                  ; ****************************************************************
  6663                                  ; *
  6664                                  ; * ROUTINE:	 ANSI_CLS
  6665                                  ; *
  6666                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6667                                  ; *		 to STDOUT.
  6668                                  ; *
  6669                                  ; * INPUT:	 none
  6670                                  ; *
  6671                                  ; * OUTPUT:	 none
  6672                                  ; *
  6673                                  ; ****************************************************************
  6674                                  
  6675                                  ;ansi_cls proc	near			;AC000;
  6676                                  ;
  6677                                  ;	mov	si,offset trangroup:clsstring
  6678                                  ;	lodsb
  6679                                  ;	mov	cl,al
  6680                                  ;	xor	ch,ch
  6681                                  ;	mov	ah,Raw_CON_IO
  6682                                  ;clrloop:
  6683                                  ;	lodsb
  6684                                  ;	mov	DL,al
  6685                                  ;	int	21h
  6686                                  ;	loop	clrloop
  6687                                  ;	return
  6688                                  ;
  6689                                  ;ansi_cls	endp			;AC000;
  6690                                  
  6691                                  ;============================================================================
  6692                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6693                                  ;============================================================================
  6694                                  ; 08/10/2018 - Retro DOS v3.0
  6695                                  
  6696                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6697                                  
  6698                                  ; ---------------------------------------------------------------------------
  6699                                  
  6700                                  ; ****************************************************************
  6701                                  ; *
  6702                                  ; * ROUTINE:	 CTTY - Change console
  6703                                  ; *
  6704                                  ; * SYNTAX:	 CTTY device
  6705                                  ; *
  6706                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6707                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6708                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6709                                  ; *
  6710                                  ; * INPUT:	 command line at offset 81H
  6711                                  ; *
  6712                                  ; * OUTPUT:	 none
  6713                                  ; *
  6714                                  ; ****************************************************************
  6715                                  
  6716                                  CTTY:
  6717                                  		; MSDOS 6.0
  6718                                  		;push	ds			;AN000; Get local ES
  6719                                  		;pop	es			;AN000;
  6720                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6721                                  
  6722                                  		;mov	di,offset trangroup:parse_ctty	
  6723                                  						;AC000; Get address of PARSE_CTTY
  6724                                  		;xor	cx,cx			;AC000; clear cx,dx
  6725                                  		;xor	dx,dx			;AC000;
  6726                                  		;invoke	cmd_parse		;AC000; call parser
  6727                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6728                                  		;jz	ctty_error		;AN000; yes - error
  6729                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6730                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6731                                  
  6732                                  		;push	si			;AN000; save position in line
  6733                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6734                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6735                                  
  6736                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6737                                  		;lodsb				;AN000; get a char from buffer
  6738                                  		;stosb				;AN000; store in srcbuf
  6739                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6740                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6741                                  		;pop	si			;AN000; get line position back
  6742                                  		;mov	di,offset trangroup:parse_ctty	
  6743                                  						;AC000; Get address of PARSE_CTTY
  6744                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6745                                  		;jz	nocolon 		;AN000; yes - continue
  6746                                  ;ctty_error:
  6747                                  		;jmp	short isbaddev		;AC000; yes - exit
  6748                                  
  6749                                  		; MSDOS 3.3
  6750 00001531 E8F007                  		call	SETPATH
  6751 00001534 4E                      		dec	si
  6752 00001535 4E                      		dec	si
  6753 00001536 803C3A                  		cmp	byte [si],':'
  6754 00001539 7503                    		jnz	short NOCOLON
  6755 0000153B C60400                  		mov	byte [si],0
  6756                                  NOCOLON:
  6757                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6758                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6759 0000153E B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6760 00001541 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6761                                  				; DS:DX	-> ASCIZ filename
  6762                                  				; AL = access mode
  6763                                  				; 2 - read & write
  6764 00001543 7210                    		jc	short ISBADDEV
  6765 00001545 89C3                    			mov	bx,ax
  6766 00001547 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6767 0000154A CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6768                                  				; BX = file or device handle
  6769 0000154C F6C280                  		test	dl,80h
  6770 0000154F 750C                    		jnz	short DEVISOK
  6771                                  CLOSEDEV:
  6772 00001551 B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6773 00001553 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6774                                  				; BX = file handle
  6775                                  ISBADDEV:
  6776 00001555 BA[633B]                		mov	dx,BADDEVPTR
  6777 00001558 E8B91E                  		call	STD_PRINTF
  6778 0000155B EB28                    		jmp	short RESRET
  6779                                  
  6780                                  		;nop
  6781                                  DEVISOK:
  6782                                  		; MSDOS 6.0
  6783                                  		;push	dx		;AN007; save device info
  6784                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6785                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6786                                  		;push	bx		;AN021; save handle
  6787                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6788                                  		;mov	dx,si		;AN021; get address into dx
  6789                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6790                                  		;mov	cx,2		;AN007; write two bytes
  6791                                  		;int	21h		;AN007;
  6792                                  		;pop	bx		;AN021; get back handle
  6793                                  		;pop	dx		;AN007; get back device info
  6794                                  		;jc	closedev	;AN007; if error, quit
  6795                                  
  6796                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6797 0000155D 30F6                    		xor	dh,dh
  6798 0000155F 80CA03                  		or	dl,3
  6799                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6800 00001562 B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6801 00001565 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6802                                  				; BX = device handle,DH = 0
  6803                                  				; DL = device information to set 
  6804                                  				;		(bits 0-7 from	function 0)
  6805 00001567 53                      		push	bx
  6806 00001568 B90300                  		mov	cx,3
  6807 0000156B 31DB                    		xor	bx,bx
  6808                                  
  6809                                  ICLLOOP:				; Close basic handles
  6810 0000156D B43E                    		mov	ah,CLOSE ; 3Eh
  6811 0000156F CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6812                                  				; BX = file handle
  6813 00001571 43                      		inc	bx
  6814 00001572 E2F9                    		loop	ICLLOOP
  6815 00001574 5B                      		pop	bx		; Get handle
  6816 00001575 B445                    		mov	ah,XDUP ; 45h
  6817 00001577 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6818                                  				; BX = file handle to duplicate
  6819 00001579 B445                    		mov	ah,XDUP ; 45h
  6820 0000157B CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6821                                  				; BX = file handle to duplicate
  6822 0000157D B445                    		mov	ah,XDUP ;45h
  6823 0000157F CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6824                                  				; BX = file handle to duplicate
  6825 00001581 B43E                    		mov	ah,CLOSE ; 3Eh
  6826 00001583 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6827                                  				; BX = file handle
  6828                                  RESRET:
  6829 00001585 8E1E[5641]              		mov	ds,[RESSEG]
  6830 00001589 1E                      		push	ds
  6831 0000158A A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6832 0000158D A3D90B                  		mov	[IO_SAVE],ax
  6833                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6834                                  		;mov	ax,31Eh ; MSDOS 3.3
  6835 00001590 B81903                  		mov	ax,LODCOM1
  6836 00001593 50                      		push	ax
  6837                                  
  6838 00001594 CB                      		retf		; Far return
  6839                                  
  6840                                  ; ---------------------------------------------------------------------------
  6841                                  
  6842                                  ;****************************************************************
  6843                                  ;*
  6844                                  ;* ROUTINE:	CHCP - Change code page internal command
  6845                                  ;*		(added DOS 3.30 07/21/86)
  6846                                  ;*
  6847                                  ;* SYNTAX:	CHCP [xxx]
  6848                                  ;*		where xxx is a valid code page
  6849                                  ;*
  6850                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6851                                  ;*		6402H to set the code page to xxxx. If no parameters
  6852                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6853                                  ;*		to get global code page and display it to the user.
  6854                                  ;*
  6855                                  ;* INPUT:	command line at offset 81H
  6856                                  ;*
  6857                                  ;* OUTPUT:	none
  6858                                  ;*
  6859                                  ;****************************************************************
  6860                                  
  6861                                  ;NLSFUNC_installed equ  0FFh
  6862                                  set_global_cp	equ   2
  6863                                  get_global_cp	equ   1
  6864                                  
  6865                                  CHCP:
  6866                                  		; MSDOS 6.0
  6867                                  		;push	ds		;AN000; Get local ES
  6868                                  		;pop	es		;AN000;
  6869                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6870                                  
  6871                                  		;mov	di,offset trangroup:parse_chcp	
  6872                                  					;AN000; Get address of PARSE_CHCP
  6873                                  		;xor	cx,cx		;AC000; clear cx,dx
  6874                                  		;xor	dx,dx		;AC000;
  6875                                  		;call	parse_with_msg	;AC018; call parser
  6876                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6877                                  
  6878                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6879                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6880                                  ;setcp:
  6881                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6882                                  		;jne	cp_error	;AC018; yes - go issue message
  6883                                  
  6884                                  		;push	cx		;AN000; save positional count
  6885                                  		;mov	bx,offset trangroup:parse1_addr 
  6886                                  					;AN000; get number returned
  6887                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6888                                  		;mov	system_cpage,cx ;AN000; save user input number
  6889                                  		;pop	cx		;AC000; restore positional count
  6890                                  		;mov	di,offset trangroup:parse_chcp	
  6891                                  					;AN000; Get address of PARSE_CHCP
  6892                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6893                                  		;jnz	cp_error	;AC000; no - exit
  6894                                  ;okset:
  6895                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6896                                  		;mov	al,0		;AN000;
  6897                                  		;int	2fh		;AN000;
  6898                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6899                                  		;jz	got_NLS 	;AN000; Yes - continue
  6900                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6901                                  					;AN000; no - set up error message
  6902                                  		;jmp	short cp_error	;AN000; error exit
  6903                                  ;got_NLS:
  6904                                  
  6905                                  		; MSDOS 3.3
  6906 00001595 BE8100                  		mov	si,81h
  6907 00001598 E8A703                  		call	SCANOFF
  6908 0000159B 3C0D                    		cmp	al,0Dh ; CR
  6909                                  		;jnz	short SETCP
  6910                                  		;jmp	short GETCP
  6911                                  		; 02/03/2023
  6912 0000159D 7472                    		jz	short GETCP
  6913                                  
  6914                                  		;nop
  6915                                  SETCP:
  6916 0000159F 31DB                    		xor	bx,bx
  6917 000015A1 89D9                    		mov	cx,bx
  6918 000015A3 89D8                    		mov	ax,bx
  6919                                  GET_CP_DIGIT:
  6920 000015A5 AC                      		lodsb
  6921 000015A6 3C30                    		cmp	al,'0'
  6922 000015A8 721C                    		jb	short CHRNOTNUMBER
  6923 000015AA 3C39                    		cmp	al,'9'
  6924 000015AC 7718                    		ja	short CHRNOTNUMBER
  6925 000015AE 2C30                    		sub	al,'0'
  6926 000015B0 FEC1                    		inc	cl
  6927 000015B2 80F904                  		cmp	cl,4
  6928 000015B5 771B                    		ja	short CHCP_BADPARM
  6929 000015B7 89DA                    		mov	dx,bx
  6930 000015B9 D1E2                    		shl	dx,1
  6931 000015BB D1E2                    		shl	dx,1
  6932 000015BD 01D3                    		add	bx,dx
  6933 000015BF D1E3                    		shl	bx,1
  6934 000015C1 01C3                    		add	bx,ax
  6935 000015C3 EBE0                    		jmp	short GET_CP_DIGIT
  6936                                  CP_NEXTCHR:
  6937 000015C5 AC                      		lodsb
  6938                                  CHRNOTNUMBER:
  6939 000015C6 3C20                    		cmp	al,' '		; SPACE
  6940 000015C8 74FB                    		jz	short CP_NEXTCHR
  6941 000015CA 3C09                    		cmp	al,9		; TAB
  6942 000015CC 74F7                    		jz	short CP_NEXTCHR
  6943 000015CE 3C0D                    		cmp	al,0Dh		; CR
  6944 000015D0 7406                    		jz	short SET_CP_TBL_NUM
  6945                                  CHCP_BADPARM:
  6946 000015D2 BA[3239]                		mov	dx,BADPARMPTR
  6947 000015D5 E90E06                  		jmp	CERROR
  6948                                  ;GOT_NLS:
  6949                                  SET_CP_TBL_NUM:
  6950                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6951 000015D8 891E[003E]              		mov	[SYSTEM_CPAGE],bx
  6952 000015DC B466                    		mov	ah,GETSETCDPG  ; 66h
  6953 000015DE B002                    		mov	al,set_global_cp ; 2
  6954 000015E0 CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6955                                  				; BX = active code page
  6956                                  				; DX = system code page	(active	page at	boot time)
  6957 000015E2 733D                    		jnc	short CHCP_RETURN
  6958                                  
  6959 000015E4 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6960 000015E7 7511                    		jnz	short CHCP_OTHER_ERROR
  6961                                  
  6962 000015E9 B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6963 000015EB 31DB                    		xor	bx,bx
  6964 000015ED CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6965                                  				; BX = version code (0000h for DOS 3.x)
  6966 000015EF 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6967 000015F2 7417                    		jz	short NONE_SET
  6968 000015F4 BA[0837]                		mov	dx,FNOTFOUNDPTR
  6969 000015F7 E9EC05                  		jmp	CERROR
  6970                                  CHCP_OTHER_ERROR:			; end of p716
  6971 000015FA B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6972 000015FC 31DB                    		xor	bx,bx
  6973 000015FE CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6974                                  				; BX = version code (0000h for DOS 3.x)
  6975 00001600 83F841                  		cmp	ax,65		;was it access denied?
  6976 00001603 7506                    		jnz	short NONE_SET	;no - assume all failed
  6977 00001605 BA[B838]                		mov	dx,CPNOTALLPTR	;set up message
  6978 00001608 E9DB05                  		jmp	CERROR		;AC000; error exit
  6979                                  NONE_SET:
  6980 0000160B BA[8538]                		mov	dx,CPNOTSETPTR	;set up message
  6981                                  CP_ERROR:
  6982 0000160E E9D505                  		jmp	CERROR		;exit
  6983                                  GETCP:
  6984 00001611 B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6985 00001613 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6986 00001615 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6987 00001617 891E[003E]              		mov	[SYSTEM_CPAGE],bx ;get active cp for output
  6988 0000161B BA[D638]                		mov	dx,CPACTIVEPTR
  6989 0000161E E8F31D                  		call	STD_PRINTF	;print it out
  6990                                  CHCP_RETURN:
  6991 00001621 C3                      		retn
  6992                                  
  6993                                  ; ---------------------------------------------------------------------------
  6994                                  
  6995                                  ; ****************************************************************
  6996                                  ; *
  6997                                  ; * ROUTINE:	 TRUENAME
  6998                                  ; *
  6999                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  7000                                  ; *		 Parses the command line. If a path is found, set
  7001                                  ; *		 SRCXNAME to path.  If only a drive letter is
  7002                                  ; *		 found, set SRCXNAME to the drive letter.  If
  7003                                  ; *		 no path is found, set the path of SRCXNAME to
  7004                                  ; *		 dot (.) for current directory.  Use the NAME
  7005                                  ; *		 TRANSLATE system call to get the real name and
  7006                                  ; *		 then display the real name.  If an error occurs
  7007                                  ; *		 issue an error message and transfer control to
  7008                                  ; *		 CERROR.
  7009                                  ; *
  7010                                  ; * INPUT:	 command line at offset 81H
  7011                                  ; *
  7012                                  ; * OUTPUT:	 none
  7013                                  ; *
  7014                                  ; ****************************************************************
  7015                                  
  7016                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  7017                                  ;
  7018                                  ;TRUENAME:					;AN000; TRUENAME entry point
  7019                                  ;	push	ds				;AN000; Get local ES
  7020                                  ;	pop	es				;AN000;
  7021                                  ;	mov	si,81H				;AN000; Get command line
  7022                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get address of PARSE_CHDIR
  7023                                  ;	xor	cx,cx				;AN000; clear cx,dx
  7024                                  ;	xor	dx,dx				;AN000;
  7025                                  ;	call	parse_with_msg			;AC018; call parser
  7026                                  ;
  7027                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  7028                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  7029                                  ;	je	tn_eol				;AN000; yes - go process
  7030                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  7031                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  7032                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  7033                                  ;	je	tn_drive			;AN000; yes - go process
  7034                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  7035                                  ;
  7036                                  ;tn_eol: 					;AN000; no parameters on line
  7037                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  7038                                  ;	mov	al,dot_chr			;AN000;     for current dir
  7039                                  ;	stosw					;AN000; store in srcxname
  7040                                  ;	jmp	short tn_doit			;AN000; go do command
  7041                                  ;
  7042                                  ;tn_drive:					;AN000; a drive was entered
  7043                                  ;	push	si				;AN000; save position in line
  7044                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  7045                                  ;	lodsb					;AN000; get the drive number
  7046                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  7047                                  ;	stosb					;AN000; store it in srcxname
  7048                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  7049                                  ;	stosw					;AN000;    store in srcxname
  7050                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  7051                                  ;	stosb					;AN000;
  7052                                  ;	pop	si				;AN000; get line position back
  7053                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  7054                                  ;
  7055                                  ;tn_filespec:					;AN000; a filespec was entered
  7056                                  ;	push	si				;AN000; save position in line
  7057                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  7058                                  ;
  7059                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  7060                                  ;	lodsb					;AN000; get a char from buffer
  7061                                  ;	stosb					;AN000; store in srcxname
  7062                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  7063                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  7064                                  ;	pop	si				;AN000; get line position back
  7065                                  ;
  7066                                  ;tn_check_eol:					;AN000; make sure no extra parms
  7067                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  7068                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  7069                                  ;	je	tn_doit 			;AN000; Yes - do the command
  7070                                  ;
  7071                                  ;tn_parse_error: 				;AN000; A parse error occurred
  7072                                  ;	jmp	cerror				;AN000; Go to error routine
  7073                                  ;
  7074                                  ;tn_doit:					;AN000;
  7075                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  7076                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  7077                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  7078                                  ;	int	21h			;AN000;
  7079                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  7080                                  ;
  7081                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  7082                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  7083                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  7084                                  ;	jmp	cerror				;AN000; Go to error routine
  7085                                  ;
  7086                                  ;tn_print_xname: 				;AN000;
  7087                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  7088                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  7089                                  ;	invoke	crlf2				;AN000; print a crlf
  7090                                  ;	invoke	printf_crlf			;AN000; print it out
  7091                                  ;
  7092                                  ;	ret					;AN000;
  7093                                  ;
  7094                                  
  7095                                  ; ---------------------------------------------------------------------------
  7096                                  
  7097                                  _$EXIT:
  7098                                  		; MSDOS 3.3
  7099 00001622 8E06[5641]              		mov	es,[RESSEG]
  7100 00001626 26A1760B                		mov	ax,[es:PARENT]
  7101                                  		;mov	[es:16h],ax
  7102 0000162A 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7103 0000162E 26A1780B                		mov	ax,[es:OLDTERM]
  7104                                  		;mov	[es:0Ah],ax
  7105 00001632 26A30A00                		mov	[es:PDB.EXIT],ax
  7106 00001636 26A17A0B                		mov	ax,[es:OLDTERM+2]
  7107                                  		;mov	[es:0Ch],ax
  7108 0000163A 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7109 0000163E 06                      		push	es
  7110 0000163F 8E06[6641]              		mov	es,[TRAN_TPA]
  7111 00001643 B449                    		mov	ah,DEALLOC ; 49h
  7112 00001645 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7113                                  				; ES = segment address of area to be freed
  7114 00001647 07                      		pop	es
  7115 00001648 B44C                    		mov	ah,EXIT ; 4Ch
  7116                                  		;mov	al,[0BEAh] ; MSDOS 3.3 COMMAND.cOm offset 168Ah
  7117 0000164A 26A0D40B                		mov	al,[es:RETCODE]
  7118 0000164E CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7119                                  
  7120                                  ;;here:
  7121                                  ;;		jmp	short here
  7122                                  
  7123                                  		; MSDOS 6.0
  7124                                  		;push	ds			;AN000; save data segment
  7125                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7126                                  
  7127                                  		;assume	ds:resgroup		;AN000;
  7128                                  
  7129                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7130                                  		;jz	free_com		;AN045; no - free everything
  7131                                  
  7132                                  ;	We're a permanent command.
  7133                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7134                                  
  7135                                  		;cmp	[singlecom],-1		;M034
  7136                                  		;je	no_reset		;M034	;exit singlecom
  7137                                  
  7138                                  		;jmp	TCommand		;permanent command, recycle
  7139                                  
  7140                                  ;free_com:
  7141                                  		;mov	ax,(multdos shl 8 or message_2f)
  7142                                  						;AN060; reset parse message pointers
  7143                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7144                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7145                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7146                                  		;int	2fh			;AN000; go set it
  7147                                  ;no_reset:					;AN045;
  7148                                  		;pop	ds			;AN000; restore local data segment
  7149                                  
  7150                                  		;assume	ds:trangroup		;AN000;
  7151                                  ;
  7152                                  ;M040
  7153                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7154                                  ;this, restores user dir if flag is set and resets the flag.
  7155                                  ;
  7156                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7157                                  		;MOV	ES,[RESSEG]
  7158                                  
  7159                                  		;assume	es:resgroup
  7160                                  
  7161                                  		;MOV	AX,[PARENT]
  7162                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7163                                  		;MOV	AX,WORD PTR OldTerm
  7164                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7165                                  		;MOV	AX,WORD PTR OldTerm+2
  7166                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7167                                  
  7168                                  		;PUSH	ES
  7169                                  		;MOV	ES,[TRAN_TPA]
  7170                                  		;MOV	AH,DEALLOC
  7171                                  		;INT	21h			; Now running in "free" space
  7172                                  		;POP	ES
  7173                                  
  7174                                  		;MOV	AH,Exit
  7175                                  		;MOV	AL,BYTE PTR RetCode
  7176                                  		;INT	21h
  7177                                  
  7178                                  ; ---------------------------------------------------------------------------
  7179                                  
  7180                                  ; MSDOS 6.0
  7181                                  ; ****************************************************************
  7182                                  ; *
  7183                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7184                                  ; *
  7185                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7186                                  ; *		 If not end of line, set up to print parse
  7187                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7188                                  ; *		 EXPECTED!
  7189                                  ; *
  7190                                  ; * INPUT:	 DS:SI	  last output from parser
  7191                                  ; *		 ES:DI	  points to parse block
  7192                                  ; *		 CX	  last output from parser
  7193                                  ; *
  7194                                  ; * OUTPUT:	 AX	  parser return code
  7195                                  ; *
  7196                                  ; *		 if end of line found
  7197                                  ; *		     zero flag set
  7198                                  ; *		 else
  7199                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7200                                  ; *
  7201                                  ; ****************************************************************
  7202                                  
  7203                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7204                                  ;
  7205                                  ;parse_check_eol Proc near			;AN000;
  7206                                  ;
  7207                                  ;	xor	dx,dx				;AN000;
  7208                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7209                                  ;	invoke	cmd_parse			;AN000; call parser
  7210                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7211                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7212                                  ;
  7213                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7214                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7215                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7216                                  ;
  7217                                  ;ok_to_setup_pmsg:
  7218                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7219                                  ;
  7220                                  ;parse_good_eol:
  7221                                  ;	ret					;AN000;
  7222                                  ;
  7223                                  ;parse_check_eol endp				;AN000;
  7224                                  
  7225                                  ; ---------------------------------------------------------------------------
  7226                                  
  7227                                  ; MSDOS 6.0
  7228                                  ; ****************************************************************
  7229                                  ; *
  7230                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7231                                  ; *
  7232                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7233                                  ; *		 message is set up.
  7234                                  ; *
  7235                                  ; * INPUT:	 DS:SI	  last output from parser
  7236                                  ; *		 ES:DI	  points to parse block
  7237                                  ; *		 CX	  last output from parser
  7238                                  ; *
  7239                                  ; * OUTPUT:	 AX	  parser return code
  7240                                  ; *
  7241                                  ; *		 if no error
  7242                                  ; *		     outputs from parser
  7243                                  ; *		 else
  7244                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7245                                  ; *		     error message set up for STD_PRINTF
  7246                                  ; *
  7247                                  ; ****************************************************************
  7248                                  
  7249                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7250                                  ;
  7251                                  ;parse_with_msg	Proc near			;AN018;
  7252                                  ;
  7253                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7254                                  ;	invoke	cmd_parse			;AN018; call parser
  7255                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7256                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7257                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7258                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7259                                  ;
  7260                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7261                                  ;
  7262                                  ;parse_msg_good:
  7263                                  ;	ret					;AN018;
  7264                                  ;
  7265                                  ;parse_with_msg endp				;AN018;
  7266                                  
  7267                                  ; ---------------------------------------------------------------------------
  7268                                  
  7269                                  ; MSDOS 6.0
  7270                                  ; ****************************************************************
  7271                                  ; *
  7272                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7273                                  ; *
  7274                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7275                                  ; *		 message is set up.
  7276                                  ; *
  7277                                  ; * INPUT:	 AX	     Parse error number
  7278                                  ; *		 SI	     Set to past last parameter
  7279                                  ; *		 Parse_last  Set to start of last parameter
  7280                                  ; *
  7281                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7282                                  ; *		 error message set up for STD_PRINTF
  7283                                  ; *
  7284                                  ; ****************************************************************
  7285                                  
  7286                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7287                                  ;
  7288                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7289                                  ;
  7290                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7291                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7292                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7293                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7294                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7295                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7296                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7297                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7298                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7299                                  ;
  7300                                  ;setup_parse_msg_ret:
  7301                                  ;	inc	si				;AN018; make sure zero flag not set
  7302                                  ;
  7303                                  ;	ret					;AC018;
  7304                                  ;
  7305                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7306                                  
  7307                                  ;============================================================================
  7308                                  ; TENV.ASM, MSDOS 6.0, 1991
  7309                                  ;============================================================================
  7310                                  ; 08/10/2018 - Retro DOS v3.0
  7311                                  
  7312                                  ; TITLE	Part6 COMMAND Transient routines.
  7313                                  
  7314                                  ;	Environment utilities and misc. routines
  7315                                  
  7316                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7317                                  
  7318                                  ; ---------------------------------------------------------------------------
  7319                                  
  7320                                  ADD_PROMPT:
  7321 00001650 E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7322 00001653 E87801                  		call	SCAN_DOUBLE_NULL
  7323                                  ADD_PROMPT2:
  7324 00001656 56                      		push	si
  7325 00001657 E86601                  		call	GETARG
  7326 0000165A 5E                      		pop	si
  7327 0000165B 7501                    		jnz	short ADD_PROMPT3
  7328                                  ADD_PROMPT_RETN:
  7329 0000165D C3                      		retn
  7330                                  ADD_PROMPT3:				; Pre scan for arguments
  7331 0000165E E84E01                  		call	MOVE_NAME	 ;Move in name
  7332 00001661 E85C01                  		call	GETARG
  7333 00001664 56                      		push	si
  7334 00001665 EB4F                    		jmp	short ADD_NAME
  7335                                  
  7336                                  ;break	The SET command
  7337                                  
  7338                                  ; Input: DS:SI points to a CR terminated string
  7339                                  ; Output: carry flag is set if no room
  7340                                  ;	  otherwise name is added to environment
  7341                                  
  7342                                  DISP_ENVJ:
  7343 00001667 E9B100                  		jmp	DISP_ENV
  7344                                  
  7345                                  ADD_NAME_TO_ENVIRONMENT:
  7346 0000166A E85301                  		call	GETARG
  7347 0000166D 74F8                    		jz	short DISP_ENVJ
  7348                                  
  7349                                  ; check if line contains exactly one equals sign
  7350                                  
  7351 0000166F 31DB                    		xor	bx,bx		; = count is 0
  7352 00001671 56                      		push	si		; Save pointer to beginning of line
  7353                                  EQLP:
  7354 00001672 AC                      		lodsb			; Get a char
  7355 00001673 3C0D                    		cmp	al,13		; IF CR we're all done
  7356 00001675 740F                    		jz	short QUEQ	
  7357 00001677 3C3D                    		cmp	al,'='		; Look for = sign	
  7358 00001679 75F7                    		jnz	short EQLP	; not there, get next char
  7359 0000167B FEC3                    		inc	bl		; Otherwise increment EQ count
  7360 0000167D 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7361 00001680 75F0                    		jnz	short EQLP
  7362 00001682 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7363 00001684 EBEC                    		jmp	short EQLP	; And look for more
  7364                                  QUEQ:
  7365 00001686 5E                      		pop	si		; Restore beginning of line
  7366 00001687 FECB                    		dec	bl		; Zero flag means only one EQ
  7367 00001689 7406                    		jz	short ONEQ	; Good line
  7368 0000168B BA[883B]                		mov	dx,SYNTMESPTR
  7369 0000168E E95505                  		jmp	CERROR
  7370                                  ONEQ:
  7371 00001691 53                      		push	bx
  7372 00001692 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7373 00001695 5B                      		pop	bx
  7374 00001696 FECF                    		dec	bh
  7375 00001698 74C3                    		jz	short ADD_PROMPT_RETN
  7376 0000169A E83101                  		call	SCAN_DOUBLE_NULL
  7377 0000169D 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7378 0000169F E80D01                  		call	MOVE_NAME
  7379 000016A2 56                      		push	si
  7380 000016A3 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7381                                  					;  env var name
  7382                                  		
  7383                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7384                                  ; necessary in the resident for re-reading the transient. Let's look for
  7385                                  ; COMSPEC=
  7386                                  
  7387                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7388 000016A5 BE[293B]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7389 000016A8 B90400                  		mov	cx,4
  7390 000016AB F3A7                    		repe cmpsw
  7391 000016AD 7505                    		jnz	short NOT_COMSPEC
  7392                                  					; Zero set => exact match
  7393                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7394 000016AF C606[8D44]01            		mov	byte [COMSPEC_FLAG],1
  7395                                  NOT_COMSPEC:
  7396 000016B4 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7397                                  ADD_NAME:
  7398 000016B6 5E                      		pop	si		; Add the value of the new env var
  7399 000016B7 56                      		push	si		;  to the environment.
  7400                                  ADD_NAME1:
  7401 000016B8 AC                      		lodsb
  7402 000016B9 3C0D                    		cmp	al,13
  7403 000016BB 7405                    		jz	short ADD_NAME_RET
  7404 000016BD E84001                  		call	STORE_CHAR
  7405 000016C0 EBF6                    		jmp	short ADD_NAME1
  7406                                  ADD_NAME_RET:
  7407 000016C2 5E                      		pop	si
  7408 000016C3 803E[8D44]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7409                                  ADD_NAME_JZ_RET:
  7410 000016C8 7493                    		jz	short ADD_PROMPT_RETN 
  7411                                  					;  copy the value into the
  7412                                  					;  comspec var in the resident
  7413                                  
  7414                                  ; We have changed the COMSPEC variable. We need to update the resident
  7415                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7416                                  
  7417 000016CA E87502                  		call	SCANOFF
  7418 000016CD 8E06[5641]              		mov	es,[RESSEG]	;  comspec var in the resident
  7419                                  
  7420                                  ; Make sure that the printer knows where the beginning of the string is
  7421                                  
  7422 000016D1 BF830B                  		mov	di,COMSPEC
  7423 000016D4 89FB                    		mov	bx,di
  7424                                  
  7425                                  ; Generate drive letter for display
  7426                                  
  7427 000016D6 31C0                    		xor	ax,ax		;g assume no drive first
  7428 000016D8 26A2CE0B                		mov	[es:COMDRV],al ;g
  7429 000016DC 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7430 000016E0 7512                    		jnz	short _GOTDRIVE
  7431 000016E2 8A04                    		mov	al,[si]		; get his specified drive
  7432                                  		;call	UPCONV
  7433 000016E4 E80901                  		call	UPCONV_MAPCALL	; convert to uppercase
  7434 000016E7 2C41                    		sub	al,'A'		; convert to 0-based
  7435 000016E9 83C702                  		add	di,2
  7436 000016EC FEC0                    		inc	al		; convert to 1-based number
  7437 000016EE 26A2CE0B                		mov	[es:COMDRV],al
  7438                                  
  7439                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7440                                  ; done here..
  7441                                  		;add	al,40h
  7442 000016F2 0440                    		add	al,'A'-1
  7443                                  _GOTDRIVE:
  7444                                  		;mov	[es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7445 000016F4 26893EC30B              		mov	[es:PUTBACKSUBSTPTR],di
  7446                                  					;g point to beginning of name after drive
  7447                                  		;mov	[es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7448 000016F9 26A2110A                		mov	[es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7449                                  
  7450                                  ; Copy chars until delim      	
  7451                                  
  7452 000016FD 89DF                    		mov	di,bx
  7453                                  COPY_COMSPEC:
  7454 000016FF AC                      		lodsb
  7455 00001700 E84702                  		call	DELIM
  7456 00001703 7407                    		jz	short COPYDONE
  7457 00001705 3C0D                    		cmp	al,13
  7458 00001707 7403                    		jz	short COPYDONE
  7459 00001709 AA                      		stosb
  7460 0000170A EBF3                    		jmp	short COPY_COMSPEC
  7461                                  COPYDONE:
  7462 0000170C 30C0                    		xor	al,al		; Null terminate the string and quit
  7463 0000170E AA                      		stosb
  7464 0000170F C606[8D44]00            		mov	byte [COMSPEC_FLAG],0
  7465 00001714 4F                      		dec	di
  7466 00001715 26893EC50B              		mov	[es:COMSPEC_END],di
  7467 0000171A C3                      		retn
  7468                                  DISP_ENV:
  7469 0000171B 8E1E[5641]              		mov	ds,[RESSEG]
  7470 0000171F 8E1EED0C                		mov	ds,[ENVIRSEG]
  7471                                  		; assume ds:nothing
  7472 00001723 31F6                    		xor	si,si
  7473                                  PENVLP:
  7474 00001725 803C00                  		cmp	byte [si],0
  7475 00001728 749E                    		jz	short ADD_NAME_JZ_RET
  7476 0000172A BF[AD42]                		mov	di,ARG_BUF
  7477                                  PENVLP2:
  7478 0000172D AC                      		lodsb
  7479 0000172E AA                      		stosb
  7480 0000172F 08C0                    		or	al,al
  7481 00001731 75FA                    		jnz	short PENVLP2
  7482 00001733 BA[3336]                		mov	dx,ARG_BUF_PTR
  7483 00001736 1E                      		push	ds
  7484 00001737 06                      		push	es
  7485 00001738 1F                      		pop	ds
  7486                                  		; assume ds:nothing
  7487 00001739 E8C91C                  		call	PRINTF_CRLF
  7488 0000173C 1F                      		pop	ds
  7489 0000173D EBE6                    		jmp	short PENVLP
  7490                                  
  7491                                  ; =============== S U B	R O U T	I N E =======================================
  7492                                  
  7493                                  DELETE_PATH:
  7494 0000173F BE[1D3B]                		mov	si,PATH_TEXT ; "PATH="
  7495 00001742 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7496                                  
  7497                                  ; =============== S U B	R O U T	I N E =======================================
  7498                                  
  7499                                  DELETE_PROMPT:
  7500 00001744 BE[223B]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7501                                  
  7502                                  ; ---------------------------------------------------------------------------
  7503                                  
  7504                                  DELETE_NAME_IN_ENVIRONMENT:
  7505                                  
  7506                                  ; Input: DS:SI points to a "=" terminated string
  7507                                  ; Output: carry flag is set if name not found
  7508                                  ;	  otherwise name is deleted
  7509                                  
  7510 00001747 56                      		push	si
  7511 00001748 1E                      		push	ds
  7512 00001749 E82400                  		call	FIND		; ES:DI points to name
  7513 0000174C 7210                    		jc	short DEL1
  7514 0000174E 89FE                    		mov	si,di		; Save it
  7515 00001750 E89500                  		call	SCASB2		; Scan for the nul
  7516 00001753 87F7                    		xchg	si,di
  7517                                  ;SR;
  7518                                  ; If we have only one env string, then the double null is lost when the last
  7519                                  ;string is deleted and we have an invalid empty environment with only a 
  7520                                  ;single null. To avoid this, we will look for the double null case and then
  7521                                  ;move an extra null char.
  7522                                  ; Bugbug: The only possible problem is that the last pathstring 
  7523                                  ;will be followed by a triple null. Is this really a problem?
  7524                                  
  7525                                  		; MSDOS 6.0
  7526                                  		;cmp	byte ptr es:[si],0 ;null char?
  7527                                  		;jnz	not_dnull	   ;no, we are at a double null
  7528                                  		;dec	si		   ;point at the double null
  7529                                  ;not_dnull:
  7530                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7531 00001755 E8F000                  		call	GETENVSIZ
  7532 00001758 29F1                    		sub	cx,si
  7533 0000175A 06                      		push	es
  7534 0000175B 1F                      		pop	ds		; ES:DI points to name
  7535                                  					; DS:SI points to next name
  7536 0000175C F3A4                    		rep movsb
  7537                                  DEL1:
  7538 0000175E 1F                      		pop	ds
  7539 0000175F 5E                      		pop	si
  7540                                  FIND_RETN:
  7541 00001760 C3                      		retn
  7542                                  
  7543                                  ; =============== S U B	R O U T	I N E =======================================
  7544                                  
  7545                                  FIND_PATH:
  7546 00001761 BE[1D3B]                		mov	si,PATH_TEXT ; "PATH="
  7547 00001764 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7548                                  
  7549                                  
  7550                                  ; =============== S U B	R O U T	I N E =======================================
  7551                                  
  7552                                  FIND_PROMPT:
  7553 00001766 BE[223B]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7554                                  
  7555                                  ; ---------------------------------------------------------------------------
  7556                                  
  7557                                  FIND_NAME_IN_ENVIRONMENT:
  7558                                  
  7559                                  ; Input: DS:SI points to a "=" terminated string
  7560                                  ; Output: ES:DI points to the arguments in the environment
  7561                                  ;	  zero is set if name not found
  7562                                  ;	  carry flag is set if name not valid format
  7563                                  
  7564 00001769 E80400                  		call	FIND		; Find the name
  7565 0000176C 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7566 0000176E EB74                    		jmp	short SCASB1	; Scan for = sign
  7567                                  
  7568                                  ; ---------------------------------------------------------------------------
  7569                                  		;nop
  7570                                  
  7571                                  ; =============== S U B	R O U T	I N E =======================================
  7572                                  
  7573                                  ; On return of FIND1, ES:DI points to beginning of name
  7574                                  
  7575                                  FIND:
  7576 00001770 FC                      		cld
  7577 00001771 E82D00                  		call	COUNT0		; CX = Length of name
  7578 00001774 8E06[5641]              		mov	es,[RESSEG]
  7579                                  		; assume es:RESGROUP
  7580 00001778 268E06ED0C              		mov	es,[es:ENVIRSEG]
  7581                                  		; assume es:NOTHING
  7582 0000177D 31FF                    		xor	di,di
  7583                                  FIND1:	
  7584 0000177F 51                      		push	cx
  7585 00001780 56                      		push	si
  7586 00001781 57                      		push	di
  7587                                  FIND11:
  7588 00001782 AC                      		lodsb
  7589                                  		;call	UPCONV
  7590 00001783 E86A00                  		call	UPCONV_MAPCALL
  7591 00001786 47                      		inc	di
  7592 00001787 263A45FF                		cmp	al,[es:di-1]
  7593 0000178B 7502                    		jnz	short FIND12
  7594 0000178D E2F3                    		loop	FIND11
  7595                                  FIND12:
  7596 0000178F 5F                      		pop	di
  7597 00001790 5E                      		pop	si
  7598 00001791 59                      		pop	cx
  7599 00001792 74CC                    		jz	short FIND_RETN
  7600 00001794 51                      		push	cx
  7601 00001795 E85000                  		call	SCASB2		; Scan for a nul
  7602 00001798 59                      		pop	cx
  7603 00001799 26803D00                		cmp	byte [es:di],0
  7604 0000179D 75E0                    		jnz	short FIND1
  7605 0000179F F9                      		stc			; Indicate not found
  7606 000017A0 C3                      		retn
  7607                                  
  7608                                  ; =============== S U B	R O U T	I N E =======================================
  7609                                  
  7610                                  COUNT0:
  7611 000017A1 1E                      		push	ds
  7612 000017A2 07                      		pop	es
  7613                                  		; assume es:nothing
  7614 000017A3 89F7                    		mov	di,si
  7615                                  ;COUNT1:
  7616 000017A5 57                      		push	di		; Count number of chars until "="
  7617 000017A6 E83B00                  		call	SCASB1
  7618                                  		; 24/02/2023
  7619                                  		;jmp	short COUNTX
  7620                                  ;COUNT2:
  7621                                  ;		push	di		; Count number of chars until nul
  7622                                  ;		call	SCASB2
  7623                                  ;COUNTX:
  7624 000017A9 59                      		pop	cx
  7625 000017AA 29CF                    		sub	di,cx
  7626 000017AC 87F9                    		xchg	di,cx
  7627                                  MOVE_NAME_RETN:
  7628 000017AE C3                      		retn
  7629                                  
  7630                                  ; =============== S U B	R O U T	I N E =======================================
  7631                                  
  7632                                  MOVE_NAME:
  7633 000017AF 803C0D                  		cmp	byte [si],13
  7634 000017B2 74FA                    		jz	short MOVE_NAME_RETN
  7635 000017B4 AC                      		lodsb
  7636                                  		;call	UPCONV
  7637 000017B5 E83800                  		call	UPCONV_MAPCALL
  7638 000017B8 E84500                  		call	STORE_CHAR
  7639 000017BB 3C3D                    		cmp	al,'='
  7640 000017BD 75F0                    		jnz	short MOVE_NAME
  7641                                  GETARG_RETN:
  7642 000017BF C3                      		retn
  7643                                  
  7644                                  ; =============== S U B	R O U T	I N E =======================================
  7645                                  
  7646                                  GETARG:
  7647 000017C0 BE8000                  		mov	si,80h
  7648 000017C3 AC                      		lodsb
  7649 000017C4 08C0                    		or	al,al
  7650 000017C6 74F7                    		jz	short GETARG_RETN
  7651 000017C8 E87701                  		call	SCANOFF
  7652 000017CB 3C0D                    		cmp	al,13
  7653                                  SDN_RETN:
  7654 000017CD C3                      		retn
  7655                                  
  7656                                  ; =============== S U B	R O U T	I N E =======================================
  7657                                  
  7658                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7659                                  ; there is NO double NULL, merely a string that is empty.
  7660                                  
  7661                                  SCAN_DOUBLE_NULL:
  7662 000017CE 8E06[5641]              		mov	es,[RESSEG]
  7663                                  		; ASSUME ES:RESGROUP
  7664 000017D2 268E06ED0C              		mov	es,[es:ENVIRSEG]
  7665                                  		; ASSUME ES:NOTHING
  7666 000017D7 31FF                    		xor	di,di
  7667                                  
  7668                                  ; Top cycle-point. If the string here is empty, then we are done
  7669                                  
  7670                                  SDN1:
  7671 000017D9 26803D00                		cmp	byte [es:di],0	; nul string?
  7672 000017DD 74EE                    		jz	short SDN_RETN	; yep, all done
  7673 000017DF E80600                  		call	SCASB2
  7674 000017E2 EBF5                    		jmp	short SDN1
  7675                                  
  7676                                  ; =============== S U B	R O U T	I N E =======================================
  7677                                  
  7678                                  SCASB1:
  7679 000017E4 B03D                    		mov	al,'='		; Scan for an =
  7680 000017E6 EB02                    		jmp	short SCASBX
  7681                                  
  7682                                  ; =============== S U B	R O U T	I N E =======================================
  7683                                  
  7684                                  SCASB2:
  7685 000017E8 30C0                    		xor	al,al		; Scan for a nul
  7686                                  
  7687                                  ; ---------------------------------------------------------------------------
  7688                                  
  7689                                  SCASBX:
  7690 000017EA B90001                  		mov	cx,256
  7691 000017ED F2AE                    		repne scasb
  7692 000017EF C3                      		retn
  7693                                  
  7694                                  ; =============== S U B	R O U T	I N E =======================================
  7695                                  
  7696                                  ; MSDOS 6.0
  7697                                  
  7698                                  ; ****************************************************************
  7699                                  ; *
  7700                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7701                                  ; *
  7702                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7703                                  ; *		 the character in AL from the file upper case table
  7704                                  ; *		 in DOS if character if above  ascii 128, else
  7705                                  ; *		 subtracts 20H if between "a" and "z".
  7706                                  ; *
  7707                                  ; * INPUT:	 AL	      char to be upper cased
  7708                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7709                                  ; *
  7710                                  ; * OUTPUT:	 AL	      upper cased character
  7711                                  ; *
  7712                                  ; ****************************************************************
  7713                                  
  7714                                  ;assume	ds:trangroup			;AN000;
  7715                                  ;
  7716                                  ;upconv	proc	near			;AN000;
  7717                                  ;
  7718                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7719                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7720                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7721                                  ;	push	ds			;AN000;
  7722                                  ;	push	bx			;AN000;
  7723                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7724                                  ;assume	ds:resgroup			;AN000;
  7725                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7726                                  ;	add	bx,2			;AN000;  skip over first word
  7727                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7728                                  ;	pop	bx			;AN000;
  7729                                  ;	pop	ds			;AN000;
  7730                                  ;assume	ds:trangroup			;AN000;
  7731                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7732                                  ;
  7733                                  ;oth_fucase:				;AN000;
  7734                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7735                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7736                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7737                                  ;	ja	upconv_end		;AC000;
  7738                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7739                                  ;
  7740                                  ;upconv_end:				;AN000;
  7741                                  ;	ret
  7742                                  ;
  7743                                  ;upconv	endp				;AN000;
  7744                                  
  7745                                  ; ---------------------------------------------------------------------------
  7746                                  
  7747                                  ; MSDOS 3.3
  7748                                  
  7749                                  UPCONV_MAPCALL:
  7750                                  					; If between "a" and "z"
  7751                                  		;cmp	al,[small_a]
  7752                                  		; 01/03/2023
  7753 000017F0 3C61                    		cmp	al,'a' ; small_a
  7754 000017F2 7206                    		jb	short UPCONV_END
  7755                                  		;cmp	al,[small_z]
  7756 000017F4 3C7A                    		cmp	al,'z' ; small_z
  7757 000017F6 7702                    		ja	short UPCONV_END
  7758 000017F8 2C20                    		sub	al,20h		; Change lower-case to upper
  7759                                  UPCONV_END:
  7760 000017FA 2EFF1E[F04B]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7761                                  					  ; 	  for (current) country
  7762 000017FF C3                      		retn
  7763                                  
  7764                                  ; =============== S U B	R O U T	I N E =======================================
  7765                                  
  7766                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7767                                  
  7768                                  STORE_CHAR:
  7769 00001800 51                      		push	cx
  7770 00001801 53                      		push	bx
  7771                                  
  7772                                  		; 16/10/2018
  7773                                  		; MSDOS 6.0
  7774                                  		;PUSH	ES		;AN056;*
  7775                                  		;PUSH	DS		;AN056; Save local DS
  7776                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7777                                  		;;ASSUME DS:RESGROUP	;AN056;
  7778                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7779                                  		;; ASSUME ES:NOTHING	;AN056;
  7780                                  		;POP	DS		;AN056; Get local segment back
  7781                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7782                                  
  7783                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7784 00001802 E84300                  		call	GETENVSIZ
  7785 00001805 89CB                    		mov	bx,cx		; Save room for double nul	
  7786 00001807 83EB02                  		sub	bx,2
  7787 0000180A 39DF                    		cmp	di,bx
  7788 0000180C 7231                    		jb	short STORE1
  7789                                  
  7790 0000180E 50                      		push	ax
  7791 0000180F 51                      		push	cx
  7792 00001810 53                      		push	bx		; Save Size of environment
  7793 00001811 E847EE                  		call	FREE_TPA
  7794 00001814 5B                      		pop	bx
  7795 00001815 83C302                  		add	bx,2		; Recover true environment size
  7796                                  
  7797 00001818 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7798 0000181C 7203                    		jb	short ENVSIZ_OK
  7799                                  BAD_ENV_SIZE:				;AN056;
  7800 0000181E F9                      		stc
  7801 0000181F EB09                    		jmp	short ENVNOSET
  7802                                  
  7803                                  		;nop
  7804                                  ENVSIZ_OK:
  7805 00001821 B104                    		mov	cl,4
  7806 00001823 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7807 00001825 43                      		inc	bx
  7808                                  
  7809                                  		; MSDOS 6.0
  7810                                  		;MOV	CX,ES		;AN056; Get environment segment
  7811                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7812                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7813                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7814                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7815                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7816                                  
  7817                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7818 00001826 B44A                    		mov	ah,SETBLOCK ; 4Ah
  7819 00001828 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7820                                  				; ES = segment address of block	to change
  7821                                  				; BX = new size	in paragraphs
  7822                                  ENVNOSET:
  7823 0000182A 9C                      		pushf
  7824 0000182B 06                      		push	es
  7825 0000182C 8E06[5641]              		mov	es,[RESSEG]
  7826                                  		;ASSUME ES:RESGROUP
  7827 00001830 E838EE                  		call	ALLOC_TPA
  7828 00001833 07                      		pop	es
  7829 00001834 9D                      		popf
  7830 00001835 59                      		pop	cx
  7831 00001836 58                      		pop	ax
  7832                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7833 00001837 7306                    		jnc	short STORE1
  7834 00001839 BA[6637]                		mov	dx,ENVERRPTR
  7835 0000183C E9A703                  		jmp	CERROR
  7836                                  
  7837                                  STORE1:	
  7838 0000183F AA                      		stosb
  7839 00001840 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7840                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7841 00001845 5B                      		pop	bx
  7842 00001846 59                      		pop	cx
  7843 00001847 C3                      		retn
  7844                                  
  7845                                  ; =============== S U B	R O U T	I N E =======================================
  7846                                  
  7847                                  GETENVSIZ:
  7848                                  
  7849                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7850                                  ;ES has environment segment
  7851                                  ;Size returned in CX, all other registers preserved
  7852                                  
  7853 00001848 06                      		push	es
  7854 00001849 50                      		push	ax
  7855 0000184A 8CC0                    		mov	ax,es
  7856 0000184C 48                      		dec	ax	;Point at arena	
  7857 0000184D 8EC0                    		mov	es,ax
  7858 0000184F 26A10300                		mov	ax,[es:ARENA.size]
  7859 00001853 B104                    		mov	cl,4
  7860 00001855 D3E0                    		shl	ax,cl	;Convert to bytes
  7861 00001857 89C1                    		mov	cx,ax
  7862 00001859 58                      		pop	ax
  7863 0000185A 07                      		pop	es
  7864                                  GETENVSIZ_RETN:
  7865 0000185B C3                      		retn
  7866                                  
  7867                                  ; =============== S U B	R O U T	I N E =======================================
  7868                                  
  7869                                  RESTUDIR1:
  7870 0000185C 1E                      		push	ds
  7871 0000185D 8E1E[5641]              		mov	ds,[RESSEG]
  7872                                  		;ASSUME	DS:RESGROUP
  7873 00001861 803EDB0B00              		cmp	byte [RESTDIR],0
  7874 00001866 1F                      		pop	ds
  7875                                  		;ASSUME	DS:TRANGROUP
  7876 00001867 74F2                    		jz	short GETENVSIZ_RETN
  7877                                  
  7878                                  ; =============== S U B	R O U T	I N E =======================================
  7879                                  
  7880                                  RESTUDIR:
  7881 00001869 BA[3840]                		mov	dx,USERDIR1
  7882 0000186C B43B                    		mov	ah,CHDIR ; 3Bh
  7883 0000186E CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7884                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7885 00001870 30C0                    		xor	al,al
  7886                                  		;call	SETREST
  7887                                  		;retn
  7888                                  		; 02/03/2023
  7889 00001872 E94206                  		jmp	SETREST
  7890                                  
  7891                                  ;============================================================================
  7892                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7893                                  ;============================================================================
  7894                                  ; 07/10/2018 - Retro DOS v3.0
  7895                                  
  7896                                  ; TITLE	Part6 COMMAND Transient routines.
  7897                                  
  7898                                  ;	Environment utilities and misc. routines
  7899                                  
  7900                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7901                                  
  7902                                  ; ---------------------------------------------------------------------------
  7903                                  
  7904                                  ; ****************************************************************
  7905                                  ; *
  7906                                  ; * ROUTINE:	 $CHDIR
  7907                                  ; *
  7908                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7909                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7910                                  ; *		 letter is found, get and display the current dir
  7911                                  ; *		 of the specified drive. If nothing is found, get
  7912                                  ; *		 and display the current dir of the default drive.
  7913                                  ; *
  7914                                  ; * INPUT:	 command line at offset 81H
  7915                                  ; *
  7916                                  ; * OUTPUT:	 none
  7917                                  ; *
  7918                                  ; ****************************************************************
  7919                                  
  7920                                  _$CHDIR:
  7921                                  		; MSDOS 6.0
  7922                                  		;mov	si,81H
  7923                                  		;mov	di,offset trangroup:parse_chdir 
  7924                                  		;			;AN000; Get address of PARSE_CHDIR
  7925                                  		;xor	cx,cx		;AN000; clear cx,dx
  7926                                  		;xor	dx,dx		;AN000;
  7927                                  		;invoke	parse_with_msg	;AC018; call parser
  7928                                  
  7929                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7930                                  		;jz	bwdJ		; No args
  7931                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7932                                  		;jnz	ChDirErr	;AC018; yes - exit
  7933                                  
  7934                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7935                                  		;jnz	REALCD		; no
  7936                                  ;;
  7937                                  ;; D: was found. See if there is anything more.
  7938                                  ;;
  7939                                  		;mov	di,offset trangroup:parse_chdir 
  7940                                  					;AC000; get address of parse_chdir
  7941                                  		;xor	dx,dx		;AC000;
  7942                                  		;invoke	parse_check_eol ;AC000; call parser
  7943                                  		;jnz	ChDirErr	;AC000;
  7944                                  	;bwdJ:
  7945                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7946                                  		;call	crlf2
  7947                                  		;return
  7948                                  
  7949                                  		; MSDOS 3.3
  7950 00001875 A1[6D41]                		mov	ax,[COMSW]
  7951 00001878 0B06[7341]              		or	ax,[ALLSWITCH]
  7952 0000187C BA[3239]                		mov	dx,BADPARMPTR
  7953 0000187F 7532                    		jnz	short CHDIRERR
  7954 00001881 BE8100                  		mov	si,81h
  7955 00001884 E8BB00                  		call	SCANOFF
  7956 00001887 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7957 00001889 740F                    		je	short BWDJ	; No args
  7958 0000188B 46                      		inc	si
  7959 0000188C AC                      		lodsb
  7960 0000188D 3C3A                    		cmp	al,':'
  7961 0000188F 750F                    		jne	short REALCD
  7962 00001891 56                      		push	si
  7963 00001892 E8AD00                  		call	SCANOFF
  7964 00001895 5E                      		pop	si
  7965 00001896 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7966 00001898 7506                    		jne	short REALCD	; no
  7967                                  BWDJ:
  7968 0000189A E87CFB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7969                                  		;call	CRLF2
  7970                                  ;CHDIR_RETN:
  7971                                  		;retn
  7972                                  		; 02/03/2023
  7973 0000189D E99500                  		jmp	CRLF2
  7974                                  
  7975                                  
  7976                                  		; MSDOS 6.0
  7977                                  ;REALCD:
  7978                                  		;push	si		;AN000; save position in line
  7979                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7980                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7981                                  		;pop	si		;AN000; restore position in line
  7982                                  		;mov	di,offset trangroup:parse_chdir 
  7983                                  		;			;AC000; get address of parse_chdir
  7984                                  		;xor	dx,dx		;AC000;
  7985                                  		;invoke	parse_check_eol ;AC000; call parser
  7986                                  		;jnz	ChDirErr	;AC000;
  7987                                  		;
  7988                                  		;invoke	SETPATH
  7989                                  		;TEST	[DESTINFO],2
  7990                                  		;JNZ	BadChdir
  7991                                  		;MOV	AH,CHDIR
  7992                                  		;INT	21h
  7993                                  		;retnc
  7994                                  		;
  7995                                  		;invoke	get_ext_error_number
  7996                                  		;			;AN022; get the extended error
  7997                                  		;cmp	ax,error_path_not_found
  7998                                  		;			;AN022; see if path not found
  7999                                  		;jz	BadChDir	;AN022; yes - issue old message
  8000                                  ;;SR;
  8001                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  8002                                  ;;but is not a directory. The extended error returns "Access denied" which
  8003                                  ;;is kind of confusing. Issue the old message if access denied error is 
  8004                                  ;;returned
  8005                                  ;;
  8006                                  		;cmp	ax,error_access_denied
  8007                                  		;jz	BadChDir
  8008                                  		;
  8009                                  		;call	Set_Ext_Error_Subst ;AN022;
  8010                                  		;jmp	short  chdirerr ;AN022;
  8011                                  ;BadChDir:
  8012                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  8013                                  ;ChDirErr:
  8014                                  		;invoke	Std_Eprintf
  8015                                  		;return
  8016                                  
  8017                                  		; MSDOS 3.3
  8018                                  REALCD:
  8019 000018A0 E88104                  		call	SETPATH
  8020 000018A3 F606[5543]02            		test	byte [DESTINFO],2
  8021 000018A8 7506                    		jnz	short BADCHDIR
  8022 000018AA B43B                    		mov	ah,CHDIR ; 3Bh
  8023 000018AC CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8024                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8025 000018AE 7306                    		jnc	short CHDIR_RETN
  8026                                  BADCHDIR:
  8027 000018B0 BA[863A]                		mov	dx,BADCDPTR
  8028                                  CHDIRERR:
  8029                                  MKDIRERR:	; 02/03/2023
  8030 000018B3 E8551B                  		call	STD_EPRINTF
  8031                                  MKDIR_RETN:
  8032                                  CHDIR_RETN:	; 02/03/2023
  8033 000018B6 C3                      		retn
  8034                                  
  8035                                  ; ---------------------------------------------------------------------------
  8036                                  
  8037                                  _$MKDIR:
  8038                                  		; MSDOS 6.0
  8039                                  		;CALL	SETRMMK
  8040                                  		;JC	MkDirErr
  8041                                  		;MOV	AH,MKDIR
  8042                                  		;INT	21h
  8043                                  		;retnc
  8044                                  
  8045                                  		;invoke	get_ext_error_number	
  8046                                  		;			;AN022; get the extended error
  8047                                  		;cmp	ax,error_path_not_found 
  8048                                  		;			;AN022; see if path not found
  8049                                  		;jz	MD_other_err	;AN022; yes - issue old message
  8050                                  		;cmp	ax,error_access_denied
  8051                                  		;			;AN022; access denied?
  8052                                  		;jz	badmderr	;AN022; yes - see if file exists
  8053                                  		
  8054                                  		;call	Set_Ext_Error_Subst ;AN022;
  8055                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  8056                                  ;BADMDERR:
  8057                                  		;mov	dx,offset trangroup:srcxname	
  8058                                  		;			;AN006; Set Disk transfer address
  8059                                  		;mov	ah,Set_DMA	;AN006;
  8060                                  		;int	21h		;AN006;
  8061                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  8062                                  		;mov	cx,attr_directory ;AN006;   search for directory
  8063                                  		;INT	21h		;AN006;
  8064                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  8065                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  8066                                  		;test	dl,attr_directory ;AN006; was it a directory?
  8067                                  		;jz	MD_other_err	;AN006; no - must have been a file
  8068                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  8069                                  		;			;AN006; set up already exists error
  8070                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  8071                                  ;MD_other_err:				;AN006;
  8072                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  8073                                  ;MkDirErr:
  8074                                  		;invoke	Std_Eprintf
  8075                                  		;return
  8076                                  
  8077                                  		; MSDOS 3.3
  8078 000018B7 E81000                  		call	SETRMMK
  8079 000018BA 72F7                    		jb	short MKDIRERR
  8080 000018BC B439                    		mov	ah,MKDIR ; 39h
  8081 000018BE CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  8082                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8083 000018C0 73F4                    		jnc	short MKDIR_RETN
  8084 000018C2 BA[A53A]                		mov	dx,BADMKDPTR
  8085 000018C5 E8AD05                  		call	GET_EXT_ERR_NUMBER
  8086                                  		; 02/03/2023
  8087 000018C8 EBE9                    		jmp	short MKDIRERR
  8088                                  ;MKDIRERR:
  8089                                  		;call	STD_EPRINTF
  8090                                  		;retn
  8091                                  		
  8092                                  
  8093                                  ; =============== S U B	R O U T	I N E =======================================
  8094                                  
  8095                                  ; 	<Common MkDir/RmDir set up code>
  8096                                  ;****************************************************************
  8097                                  ;*
  8098                                  ;* ROUTINE:	SETRMMK
  8099                                  ;*
  8100                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  8101                                  ;*		commands. Parses the command line for a required
  8102                                  ;*		filespec.
  8103                                  ;*
  8104                                  ;* INPUT:	command line at offset 81H
  8105                                  ;*
  8106                                  ;* OUTPUT:	carry clear
  8107                                  ;*		    DS:DX points to ASCIIZ argument
  8108                                  ;*		carry set
  8109                                  ;*		    DS:DX has error message pointer
  8110                                  ;*
  8111                                  ;****************************************************************
  8112                                  
  8113                                  		; MSDOS 6.0
  8114                                  		;mov	si,81H
  8115                                  		;mov	di,offset trangroup:parse_mrdir 
  8116                                  					;AN000; Get address of PARSE_MRDIR
  8117                                  		;xor	cx,cx		;AN000; clear cx,dx
  8118                                  		;xor	dx,dx		;AN000;
  8119                                  		;invoke	parse_with_msg	;AC000; call parser
  8120                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8121                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8122                                  
  8123                                  		;mov	di,offset trangroup:srcxname
  8124                                  		;			;AN000; get address of srcxname
  8125                                  		;push	di		;AN000; save address
  8126                                  		;push	si		;AN000; save position in line
  8127                                  		;lds	si,parse1_addr	;AN000; get address of path
  8128                                  
  8129                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8130                                  		;lodsb			;get a char from buffer
  8131                                  		;stosb			;AN000; store in srcxname
  8132                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8133                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8134                                  		;pop	si		;AN000; get line position back
  8135                                  ;;
  8136                                  ;; we have scanned an argument.	See if any args beyond.
  8137                                  ;;
  8138                                  		;mov	di,offset trangroup:parse_mrdir 
  8139                                  		;			;AC000; get address of parse_mrdir
  8140                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8141                                  		;pop	dx		;AC000; get address of SRCXNAME
  8142                                  		;retz			;yes - return no error
  8143                                  ;NOARGERR:
  8144                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8145                                  		;			;AC000; get extended message pointer
  8146                                  		;XOR	AX,AX
  8147                                  		;STC
  8148                                  		;return
  8149                                  
  8150                                  		; MSDOS 3.3
  8151                                  SETRMMK:
  8152 000018CA BE8100                  		mov	si,81h
  8153 000018CD E87200                  		call	SCANOFF
  8154 000018D0 3C0D                    		cmp	al,0Dh
  8155 000018D2 741E                    		je	short NOARGERR
  8156 000018D4 89F2                    		mov	dx,si
  8157                                  SETRMMK1:
  8158 000018D6 AC                      		lodsb
  8159 000018D7 E87000                  		call	DELIM
  8160 000018DA 7409                    		jz	short SETRMMK3
  8161 000018DC 3C0D                    		cmp	al,0Dh
  8162 000018DE 75F6                    		jne	short SETRMMK1
  8163 000018E0 C644FF00                		mov	byte [si-1],0
  8164                                  SETRMMK2:
  8165 000018E4 C3                      		retn
  8166                                  SETRMMK3:
  8167 000018E5 C644FF00                		mov	byte [si-1],0
  8168 000018E9 56                      		push	si
  8169 000018EA E85500                  		call	SCANOFF
  8170 000018ED 5E                      		pop	si
  8171 000018EE 3C0D                    		cmp	al,0Dh
  8172 000018F0 74F2                    		je	short SETRMMK2
  8173                                  NOARGERR:
  8174 000018F2 BA[7D3C]                		mov	dx,BADARGSPTR
  8175 000018F5 31C0                    		xor	ax,ax
  8176 000018F7 F9                      		stc
  8177                                  SETRMMK_RETN:
  8178                                  RMDIR_RETN:	; 02/03/2023
  8179 000018F8 C3                      		retn
  8180                                  
  8181                                  ; ---------------------------------------------------------------------------
  8182                                  
  8183                                  _$RMDIR:
  8184 000018F9 E8CEFF                  		call	SETRMMK
  8185 000018FC 720E                    		jb	short RMDIRERR
  8186 000018FE 7506                    		jnz	short BADRDERR
  8187 00001900 B43A                    		mov	ah,RMDIR ; 3Ah
  8188 00001902 CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8189                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8190 00001904 73F2                    		jnc	short SETRMMK_RETN
  8191                                  
  8192                                  		; MSDOS 6.0
  8193                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8194                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8195                                  		;jz	badrderr	;AN022; yes - issue old message
  8196                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8197                                  		;jz	badrderr	;AN022; yes - issue old message
  8198                                  
  8199                                  		;call	Set_Ext_Error_Subst ;AN022;
  8200                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8201                                  
  8202                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8203                                  BADRDERR:
  8204 00001906 BA[DE3A]                		mov	dx,BADRMDPTR
  8205 00001909 E86905                  		call	GET_EXT_ERR_NUMBER
  8206                                  RMDIRERR:
  8207                                  		;call	STD_EPRINTF
  8208                                  		; 02/03/2023
  8209 0000190C E9FC1A                  		jmp	STD_EPRINTF
  8210                                  ;RMDIR_RETN:
  8211                                  		;retn
  8212                                  
  8213                                  ; =============== S U B	R O U T	I N E =======================================
  8214                                  
  8215                                  ; MSDOS 6.0
  8216                                  
  8217                                  ;****************************************************************
  8218                                  ;*
  8219                                  ;* ROUTINE:	Set_ext_error_subst
  8220                                  ;*
  8221                                  ;* FUNCTION:	Sets up substitution for extended error
  8222                                  ;*
  8223                                  ;* INPUT:	AX - extended error number
  8224                                  ;*		DX - offset of string
  8225                                  ;*
  8226                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8227                                  ;*
  8228                                  ;****************************************************************
  8229                                  
  8230                                  ;Set_ext_error_subst  proc near		;AN022;
  8231                                  ;
  8232                                  ;	mov	msg_disp_class,ext_msg_class
  8233                                  ;					;AN022; set up extended error msg class
  8234                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8235                                  ;	mov	Extend_buf_sub,one_subst 
  8236                                  ;					;AN022; put number of subst in control block
  8237                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8238                                  ;					;AN022; get extended message pointer
  8239                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8240                                  ;
  8241                                  ;	ret				;AN022; return
  8242                                  ;
  8243                                  ;Set_ext_error_subst  endp		;AN022;
  8244                                  
  8245                                  ; =============== S U B	R O U T	I N E =======================================
  8246                                  
  8247                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8248                                  
  8249                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8250                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8251                                  ;   buffer
  8252                                  ;
  8253                                  ;   Inputs:	DL has 1-based drive number
  8254                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8255                                  ;   Outputs:	Carry Clear
  8256                                  ;		    DS = TranGroup
  8257                                  ;		Carry Set
  8258                                  ;		    AX has error code
  8259                                  ;   Registers Modified: AX, SI
  8260                                  
  8261                                  SAVUDIR:
  8262 0000190F BF[3840]                		mov	di,USERDIR1
  8263                                  
  8264                                  ; ---------------------------------------------------------------------------
  8265                                  
  8266                                  SAVUDIR1:
  8267 00001912 88D0                    		mov	al,dl
  8268 00001914 0440                    		add	al,'@'
  8269 00001916 3C40                    		cmp	al,'@'
  8270 00001918 7506                    		jnz	short GOTUDRV
  8271 0000191A 0206[6A41]              		add	al,[CURDRV]
  8272 0000191E FEC0                    		inc	al		; A = 1
  8273                                  GOTUDRV:
  8274 00001920 AA                      		stosb
  8275 00001921 8A26[5B41]              		mov	ah,[DIRCHAR]
  8276 00001925 B03A                    		mov	al,':'
  8277 00001927 AB                      		stosw
  8278 00001928 06                      		push	es
  8279 00001929 1F                      		pop	ds
  8280 0000192A 89FE                    		mov	si,di
  8281 0000192C B447                    		mov	ah,CURRENT_DIR	; 47h
  8282 0000192E CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8283                                  				; DL = drive (0=default,1=A,etc.)
  8284                                  				; DS:SI	points to 64-byte buffer area
  8285 00001930 72C6                    		jc	short RMDIR_RETN
  8286 00001932 0E                      		push	cs
  8287 00001933 1F                      		pop	ds
  8288 00001934 C3                      		retn
  8289                                  
  8290                                  ; =============== S U B	R O U T	I N E =======================================
  8291                                  
  8292                                  CRLF2:
  8293 00001935 52                      		push	dx
  8294 00001936 BA[9E3C]                		mov	dx,ACRLFPTR
  8295 00001939 1E                      		push	ds
  8296 0000193A 0E                      		push	cs
  8297 0000193B 1F                      		pop	ds
  8298 0000193C E8D51A                  		call	STD_PRINTF
  8299 0000193F 1F                      		pop	ds
  8300 00001940 5A                      		pop	dx
  8301 00001941 C3                      		retn
  8302                                  
  8303                                  ; =============== S U B	R O U T	I N E =======================================
  8304                                  
  8305                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8306                                  ; may NOT be TRANGROUP
  8307                                  
  8308                                  SCANOFF:
  8309 00001942 AC                      		lodsb
  8310 00001943 E80400                  		call	DELIM
  8311 00001946 74FA                    		jz	short SCANOFF
  8312 00001948 4E                      		dec	si		; Point to first non-delimiter
  8313                                  SCANOFF_RETN:
  8314 00001949 C3                      		retn
  8315                                  
  8316                                  ; ---------------------------------------------------------------------------
  8317                                  
  8318                                  ; Input:    AL is character to classify
  8319                                  ; Output:   Z set if delimiter
  8320                                  ;	    NZ set otherwise
  8321                                  ; Registers modified: none
  8322                                  
  8323                                  DELIM:
  8324 0000194A 3C20                    		cmp	al,' '
  8325 0000194C 74FB                    		jz	short SCANOFF_RETN
  8326 0000194E 3C3D                    		cmp	al,'='
  8327 00001950 74F7                    		jz	short SCANOFF_RETN
  8328 00001952 3C2C                    		cmp	al,','
  8329 00001954 74F3                    		jz	short SCANOFF_RETN
  8330 00001956 3C3B                    		cmp	al,';'
  8331 00001958 74EF                    		jz	short SCANOFF_RETN
  8332 0000195A 3C09                    		cmp	al,9		; Check for TAB character
  8333 0000195C 74EB                    		jz	short SCANOFF_RETN
  8334 0000195E 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8335 00001960 C3                      		retn
  8336                                  
  8337                                  
  8338                                  ; =============== S U B	R O U T	I N E =======================================
  8339                                  
  8340                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8341 00001961 B90800                  		mov	cx,8
  8342                                  MAINNAME:
  8343 00001964 AC                      		lodsb
  8344 00001965 3C20                    		cmp	al,' '
  8345 00001967 7401                    		jz	short SKIPSPC
  8346 00001969 AA                      		stosb
  8347                                  SKIPSPC:
  8348 0000196A E2F8                    		loop	MAINNAME
  8349 0000196C AC                      		lodsb
  8350 0000196D 3C20                    		cmp	al,' '
  8351 0000196F 7412                    		jz	short GOTNAME
  8352 00001971 88C4                    		mov	ah,al
  8353                                  		;mov	al,'.'
  8354                                  		;mov	al,[DOT_CHR]
  8355                                  		; 01/03/2023
  8356 00001973 B02E                    		mov	al,dot_chr ; mov al,'.'
  8357 00001975 AA                      		stosb
  8358 00001976 86C4                    		xchg	al,ah
  8359 00001978 AA                      		stosb
  8360 00001979 B102                    		mov	cl,2
  8361                                  EXTNAME:
  8362 0000197B AC                      		lodsb
  8363 0000197C 3C20                    		cmp	al,' '
  8364 0000197E 7403                    		jz	short GOTNAME
  8365 00001980 AA                      		stosb
  8366 00001981 E2F8                    		loop	EXTNAME
  8367                                  GOTNAME:
  8368 00001983 30C0                    		xor	al,al
  8369 00001985 AA                      		stosb
  8370                                  STRCOMP_RETN:
  8371 00001986 C3                      		retn
  8372                                  
  8373                                  ; =============== S U B	R O U T	I N E =======================================
  8374                                  
  8375                                  ; Compare ASCIZ DS:SI with ES:DI.
  8376                                  ; SI,DI destroyed.
  8377                                  
  8378                                  STRCOMP:	
  8379 00001987 A6                      		cmpsb
  8380 00001988 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8381 0000198A 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8382 0000198E 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8383 00001990 EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8384                                  
  8385                                  ; =============== S U B	R O U T	I N E =======================================
  8386                                  
  8387                                  CRPRINT:
  8388 00001992 50                      		push	ax
  8389                                  		;mov	al,13
  8390 00001993 B00D                    		mov	al,0Dh
  8391 00001995 51                      		push	cx
  8392 00001996 57                      		push	di
  8393 00001997 89D7                    		mov	di,dx
  8394 00001999 B9FFFF                  		mov	cx,65535
  8395 0000199C 06                      		push	es
  8396 0000199D 1E                      		push	ds
  8397 0000199E 07                      		pop	es
  8398 0000199F F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8399 000019A1 C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8400 000019A5 07                      		pop	es
  8401 000019A6 8916[3343]              		mov	[STRING_PTR_2],dx
  8402 000019AA BA[4F36]                		mov	dx,STRINGBUF2PTR
  8403 000019AD E8641A                  		call	STD_PRINTF
  8404                                  		;mov	byte [di-1],13
  8405 000019B0 C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8406 000019B4 7204                    		jb	short ERROR_OUTPUT
  8407 000019B6 5F                      		pop	di
  8408 000019B7 59                      		pop	cx
  8409 000019B8 58                      		pop	ax
  8410 000019B9 C3                      		retn
  8411                                  
  8412                                  ; ---------------------------------------------------------------------------
  8413                                  
  8414                                  ERROR_OUTPUT:
  8415 000019BA 0E                      		push	cs
  8416 000019BB 1F                      		pop	ds
  8417 000019BC 8E06[5641]              		mov	es,[RESSEG]
  8418 000019C0 BA[4937]                		mov	dx,NOSPACEPTR
  8419 000019C3 26803E440C00            		cmp	byte [es:PIPEFLAG],0
  8420 000019C9 7406                    		jz	short GO_TO_ERROR
  8421 000019CB E83E09                  		call	PIPEOFF
  8422 000019CE BA[E23B]                		mov	dx,PIPEEMESPTR
  8423                                  GO_TO_ERROR:
  8424 000019D1 E91202                  		jmp	CERROR
  8425                                  
  8426                                  ; =============== S U B	R O U T	I N E =======================================
  8427                                  
  8428                                  ;---- Mod for path invocation ----
  8429                                  
  8430                                  PATHCHRCMP:
  8431 000019D4 50                      		push	ax
  8432 000019D5 B42F                    		mov	ah,'/'
  8433 000019D7 3826[5A41]              		cmp	[SWITCHAR],ah
  8434 000019DB 7404                    		jz	short NOSLASHT
  8435 000019DD 3C2F                    		cmp	al,'/'
  8436 000019DF 7402                    		jz	short PCCONT
  8437                                  NOSLASHT:
  8438 000019E1 3C5C                    		cmp	al,'\'
  8439                                  PCCONT:	
  8440 000019E3 58                      		pop	ax
  8441 000019E4 C3                      		retn
  8442                                  
  8443                                  ; =============== S U B	R O U T	I N E =======================================
  8444                                  
  8445                                  ; PATHCRUNCH -
  8446                                  ;
  8447                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8448                                  ;       PathPos = ptr to string with pathname in it
  8449                                  ;       PathCnt = length of string
  8450                                  ;
  8451                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8452                                  ;       PathCnt = length left in string
  8453                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8454                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8455                                  ;       If path crunched successfully,
  8456                                  ;         CY = clear
  8457                                  ;         Current directory is changed to directory in pathname
  8458                                  ;         UserDir1 contains previous directory for use by RestUDir
  8459                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8460                                  ;         DestTail = ptr to beginning of filename
  8461                                  ;         If filename found in pathname,
  8462                                  ;           ZR = clear
  8463                                  ;           FCB filename fields contain filename
  8464                                  ;         If filename not found (pure directory path),
  8465                                  ;           ZR = set
  8466                                  ;           FCB filename fields are wildcarded with ?'s
  8467                                  ;       If pathcrunch failed (no ChDir's worked),
  8468                                  ;         CY = set
  8469                                  ;         Msg_Numb = extended error code
  8470                                  ;
  8471                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8472                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8473                                  ;       with the filename wildcarded.
  8474                                  
  8475                                  PATHCRUNCH:
  8476                                  		; MSDOS 6.0
  8477                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8478                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8479                                  		;mov	dl,[5CH]
  8480 000019E5 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8481 000019E9 E823FF                  		call	SAVUDIR		; save current directory in UserDir1
  8482 000019EC E83503                  		call	SETPATH
  8483                                  		; MSDOS 6.0
  8484                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8485                                  
  8486                                  ;       DX = ptr to pathname, NULL-terminated
  8487                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8488                                  
  8489                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8490 000019EF F606[5543]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8491 000019F4 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8492                                  
  8493 000019F6 B43B                    		mov	ah,CHDIR ; 3Bh
  8494 000019F8 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8495                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8496                                  		; MSDOS 6.0
  8497                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8498                                  		;
  8499                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8500                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8501                                  		;jz	trypeel                 ;AC022;     keep trying
  8502                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8503                                  		;jz	trypeel                 ;AC022;     keep trying
  8504                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8505                                  		;jmp	peelfail                ;AN022; exit with other error
  8506                                  
  8507                                  		; MSDOS 3.3
  8508 000019FA 7210                    		jc	short TRYPEEL
  8509                                  ;chdir_worked:
  8510                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8511 000019FC E8B604                  		call	SETREST1	; set 'Restore Directory' flag true
  8512 000019FF B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8513 00001A01 BF5D00                  		mov	di,5Dh
  8514 00001A04 B90B00                  		mov	cx,11
  8515 00001A07 F3AA                    		rep stosb
  8516 00001A09 30C0                    		xor	al,al		; return carry clear, zero set
  8517 00001A0B C3                      		retn
  8518                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8519                                  		;jmp	pcrunch_cderr	;AN022;
  8520                                  TRYPEEL:
  8521 00001A0C 8B36[A542]              		mov	si,[PATHPOS]
  8522 00001A10 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8523 00001A11 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8524 00001A14 E8BDFF                  		call	PATHCHRCMP
  8525 00001A17 7423                    		jz	short PEELFAIL
  8526                                  DELLOOP:
  8527 00001A19 39D6                    		cmp	si,dx
  8528 00001A1B 742B                    		jz	short BADRET
  8529 00001A1D 8A04                    		mov	al,[si]
  8530 00001A1F E8B2FF                  		call	PATHCHRCMP
  8531 00001A22 7403                    		jz	short TRYCD
  8532 00001A24 4E                      		dec	si
  8533 00001A25 EBF2                    		jmp	short DELLOOP
  8534                                  TRYCD:
  8535 00001A27 50                      		push	ax
  8536                                  		;mov	al,'.'
  8537                                  		;mov	al,[DOT_CHR]	; AL = '.'
  8538                                  		; 01/03/2023
  8539 00001A28 B02E                    		mov	al,dot_chr ; mov al,'.'
  8540                                  		
  8541                                  		; MSDOS 6.0
  8542                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8543                                  					;M019; allow continuation if '. ' or 
  8544                                  					;M019; '..' is not found.
  8545                                  		;jnz	@f		;M019; '.' not found
  8546                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8547                                  		;jz	@f		;M019; found '..'
  8548                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8549                                  ;@@:		;pop     ax
  8550                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8551                                  
  8552                                  		; MSDOS 3.3
  8553 00001A2A 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8554 00001A2D 58                      		pop	ax
  8555 00001A2E 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8556                                  
  8557                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8558 00001A30 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8559 00001A33 3C3A                    		cmp	al,':'
  8560 00001A35 7411                    		jz	short BADRET
  8561 00001A37 E89AFF                  		call	PATHCHRCMP
  8562 00001A3A 7502                    		jnz	short NODOUBLESL
  8563                                  PEELFAIL:
  8564 00001A3C F9                      		stc
  8565 00001A3D C3                      		retn
  8566                                  NODOUBLESL:
  8567 00001A3E C60400                  		mov	byte [si],0
  8568 00001A41 B43B                    		mov	ah,CHDIR ; 3Bh
  8569 00001A43 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8570                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8571 00001A45 7317                    		jnc	short CDSUCC
  8572                                  
  8573                                  		; MSDOS 6.0
  8574                                  ;pcrunch_cderr:
  8575                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8576                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8577                                  		;or	si,si		;AN022; set up zero flag to not zero
  8578                                  		;stc			;AN022; set up carry flag
  8579                                  		;return
  8580                                  		
  8581                                  		; MSDOS 3.3
  8582                                  PATHCRUNCH_RETN:
  8583 00001A47 C3                      		retn
  8584                                  
  8585                                  BADRET:
  8586 00001A48 8A04                    		mov	al,[si]
  8587 00001A4A E887FF                  		call	PATHCHRCMP
  8588 00001A4D F9                      		stc
  8589 00001A4E 75F7                    		jnz	short PATHCRUNCH_RETN
  8590 00001A50 30DB                    		xor	bl,bl
  8591 00001A52 865C01                  		xchg	bl,[si+1]
  8592 00001A55 B43B                    		mov	ah,CHDIR ; 3Bh
  8593 00001A57 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8594                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8595 00001A59 72EC                    		jb	short PATHCRUNCH_RETN
  8596 00001A5B 885C01                  		mov	[si+1],	bl
  8597                                  CDSUCC:
  8598 00001A5E E85404                  		call	SETREST1
  8599 00001A61 46                      		inc	si
  8600 00001A62 8936[5343]              		mov	[DESTTAIL],si
  8601                                  		; MSDOS 6.0
  8602                                  		;pushf			;AN015; save flags
  8603                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8604                                  		;jz	pcrunch_end	;AN015;
  8605                                  		;MOV	DI,FCB
  8606                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8607                                  					; Parse with default drive
  8608                                  		;INT	21h
  8609                                  ;pcrunch_end:
  8610                                  		;popf			;AN015; get flags back
  8611                                  		;return
  8612                                  
  8613                                  		; MSDOS 3.3
  8614 00001A66 BF5C00                  		mov	di,FCB ; 5Ch
  8615 00001A69 B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8616 00001A6C CD21                    		int	21h	; DOS -	PARSE FILENAME
  8617                                  				; DS:SI	-> string to parse
  8618                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8619                                  				; AL = bit mask	to control parsing
  8620 00001A6E C3                      		retn
  8621                                  
  8622                                  ;============================================================================
  8623                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8624                                  ;============================================================================
  8625                                  ; 05/10/2018 - Retro DOS v3.0
  8626                                  
  8627                                  ;TITLE	Part7 COMMAND Transient Routines
  8628                                  
  8629                                  ;	More misc routines
  8630                                  
  8631                                  ;---------------------------
  8632                                  ; We can get rid of this switch processing code if we can take
  8633                                  ; care of the remaining two calls to switch, later in the file.
  8634                                  ; However, I have not checked whether or not any other files use
  8635                                  ; switch -- after all, it IS public!
  8636                                  ;---------------------------
  8637                                  
  8638                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8639                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8640                                  
  8641                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8642                                  
  8643                                  ; ---------------------------------------------------------------------------
  8644                                  
  8645 00001A6F 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8646 00001A70 C3                      		retn
  8647                                  
  8648                                  ; =============== S U B	R O U T	I N E =======================================
  8649                                  
  8650                                  SWITCH:
  8651 00001A71 31DB                    		xor	bx,bx		; Initialize - no switches set
  8652                                  SWLOOP:
  8653 00001A73 E8CCFE                  		call	SCANOFF		; Skip any delimiters
  8654 00001A76 3A06[5A41]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8655 00001A7A 75F3                    		jnz	short RETSW	; No -- we're finished
  8656                                  		;or	bx,8000h
  8657 00001A7C 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8658 00001A80 46                      		inc	si		; Skip over the switch character
  8659 00001A81 E8BEFE                  		call	SCANOFF
  8660 00001A84 3C0D                    		cmp	al,0Dh
  8661 00001A86 74E7                    		je	short RETSW	; Oops
  8662 00001A88 46                      		inc	si
  8663                                  
  8664                                  		; Convert lower case input to upper case
  8665                                  
  8666                                  		;call	UPCONV
  8667 00001A89 E864FD                  		call	UPCONV_MAPCALL
  8668                                  
  8669 00001A8C BF[0E3E]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8670                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8671                                  		;mov	cx,5  ; MSDOS 3.3
  8672 00001A8F B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8673                                  		
  8674                                  		;nop
  8675                                  		
  8676 00001A92 F2AE                    		repne scasb		; Look for matching switch
  8677 00001A94 7507                    		jnz	short BADSW
  8678 00001A96 B80100                  		mov	ax,1
  8679 00001A99 D3E0                    		shl	ax,cl		; Set a bit for the switch
  8680 00001A9B 09C3                    		or	bx,ax
  8681                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8682 00001A9D EBD4                    		jmp	short SWLOOP
  8683                                  ;BADSW:
  8684                                  		;jmp	short SWLOOP
  8685                                  DRVBAD:
  8686 00001A9F BA[5938]                		mov	dx,BADDRVPTR
  8687 00001AA2 E94101                  		jmp	CERROR
  8688                                  EXTERNALJ:
  8689 00001AA5 E9AD00                  		jmp	EXTERNAL
  8690                                  
  8691                                  FNDCOM:					; search the internal command table
  8692 00001AA8 08C0                    		or	al,al		; Get real length of first arg
  8693 00001AAA 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8694                                  					;  to be external.
  8695                                  ; barryf code starts here
  8696                                  
  8697 00001AAC E86402                  		call	TEST_APPEND	; see if APPEND installed
  8698 00001AAF 741F                    		jz	short CONTCOM	; not loaded
  8699                                  
  8700                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8701 00001AB1 8A0E[D041]              		mov	cl,[IDLEN]
  8702 00001AB5 B500                    		mov	ch,0
  8703 00001AB7 890E[A542]              		mov	[PATHPOS],cx
  8704                                  		
  8705                                  		; MSDOS 6.0
  8706                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8707                                  
  8708 00001ABB E8F202                  		call	IOSET		; re-direct the o'l io
  8709                                  
  8710 00001ABE BE[D041]                		mov	si,IDLEN	; address command name, DS already set	
  8711 00001AC1 BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8712                                  		
  8713                                  		; MSDOS 6.0
  8714                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8715                                  					;AN010; Get the entry point for PARSE for APPEND
  8716                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8717 00001AC4 B801AE                  		mov	ax,0AE01h
  8718 00001AC7 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8719                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8720                                  				; DX = FFFFh,[SI -> buffer
  8721                                  				; Return: buffer at DS:SI filled with a	length byte
  8722                                  				;		 followed by the uppercase
  8723                                  				; internal command to execute (if length not 0)
  8724 00001AC9 803E[D041]00            		cmp	byte [IDLEN],0 ; execute requested
  8725                                  		;jne	short CONTCOM
  8726                                  		;jmp	short CMD_DONE
  8727                                  		; 02/03/2023
  8728 00001ACE 7455                    		je	short CMD_DONE
  8729                                  		
  8730                                  		;nop
  8731                                  CONTCOM:				; continue with internal scan
  8732 00001AD0 BF[F33C]                		mov	di,COMTAB
  8733 00001AD3 31C9                    		xor	cx,cx
  8734                                  FINDCOM:
  8735 00001AD5 BE[D141]                		mov	si,ID		; pointer to command argument
  8736 00001AD8 8A0D                    		mov	cl,[di]		; load length of internal command
  8737 00001ADA 47                      		inc	di		; advance past length
  8738 00001ADB E3C8                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8739 00001ADD 3A0E[D041]              		cmp	cl,[IDLEN]	; that of the command argument
  8740 00001AE1 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8741 00001AE3 890E[A542]              		mov	[PATHPOS],cx	; store length of command
  8742 00001AE7 F3A6                    		repe cmpsb
  8743                                  ABCD:					
  8744 00001AE9 9F                      		lahf			; save the good ol' flags
  8745 00001AEA 01CF                    		add	di,cx		; skip over remaining internal, if any
  8746 00001AEC 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8747 00001AEE A2[6841]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8748 00001AF1 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8749 00001AF2 8B1D                    		mov	bx,[di]		; load internal command address
  8750 00001AF4 47                      		inc	di		; skip over the puppy
  8751 00001AF5 47                      		inc	di
  8752                                  		
  8753                                  		; MSDOS 6.0
  8754                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8755                                  		;inc     DI
  8756                                  		;inc     DI
  8757                                  		;sahf			; remember those flags?
  8758                                  		;jnz     findcom	; well, if all the cmps worked...
  8759                                  ;;
  8760                                  ;; All messages get redirected.
  8761                                  ;;
  8762                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8763                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8764                                  		;invoke  ioset		; re-direct the ol' i/o
  8765                                  
  8766                                  ;dont_set_io:					;AN041;
  8767                                  ;;
  8768                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8769                                  ;; respond to /? only if it is the only command-line argument.
  8770                                  ;;
  8771                                  		;mov     ax,[COMSW]	; AX = switches after command
  8772                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8773                                  		;and     ax,SwitchQues	
  8774                                  		;jz      drive_check	; /? not in command line
  8775                                  		;	
  8776                                  		;test    [CHKDRV],fLimitHelp
  8777                                  		;jz      do_help	; /? allowed in combination
  8778                                  ;;
  8779                                  ;; Make sure /? is the only argument on the command line.
  8780                                  ;;
  8781                                  		;cmp     [arg.argvcnt],2
  8782                                  		;jne     drive_check	; /? not only arg - ignore
  8783                                  ;;
  8784                                  ;; Note:  this is all the check we need, even against things like /??.
  8785                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8786                                  ;;
  8787                                  
  8788                                  ;do_help:
  8789                                  ;
  8790                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8791                                  
  8792                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8793                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8794                                  		;push    ax		; build subst block on stack
  8795                                  
  8796                                  ;next_help_msg:
  8797                                  		;lodsw			; AX = help msg # or zero
  8798                                  		;or      ax,ax
  8799                                  		;jz      help_done
  8800                                  		;push    ax		; SS:SP = ptr to subst block
  8801                                  					;  (msg # and no_subst byte)
  8802                                  ;; We assume DS = SS.
  8803                                  
  8804                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8805                                      		;invoke  Std_PrintF	; display help message
  8806                                      		;pop     ax		; remove msg # from stack
  8807                                     		;jmp     next_help_msg
  8808                                  
  8809                                  ;help_done:
  8810                                  		;pop     ax		; clean up stack
  8811                                  		;jmp     TCommand	
  8812                                  
  8813                                  		; MSDOS 3.3
  8814 00001AF6 9E                      		sahf			; remember those flags?
  8815 00001AF7 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8816 00001AF9 E8B402                  		call	IOSET		; re-direct the ol' i/o
  8817                                  DRIVE_CHECK:
  8818                                  		;test	byte [CHKDRV],1
  8819 00001AFC F606[6841]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8820                                  					; did we wanna check those drives?
  8821 00001B01 740B                    		jz	short NOCHECK
  8822 00001B03 A0[6B41]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8823 00001B06 0A06[6C41]              		or	al,[PARM2]	; us whether those drives were OK
  8824 00001B0A 3CFF                    		cmp	al,-1
  8825                                  		;jnz	short NOCHECK
  8826                                  		;jmp	short DRVBAD
  8827                                  		; 02/03/2023
  8828 00001B0C 7491                    		jz	short DRVBAD
  8829                                  
  8830                                  ; The user may have omitted the space between the command and its arguments.
  8831                                  ; We need to copy the remainder of the user's command line into the buffer.
  8832                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8833                                  ; into the command line at 80.
  8834                                  
  8835                                  NOCHECK:
  8836 00001B0E E8E501                  		call	CMD_COPY
  8837                                  SWITCHECK:
  8838                                  		;test	byte [CHKDRV],2
  8839 00001B11 F606[6841]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8840                                  					; Does the command take switches
  8841 00001B16 750B                    		jnz	short REALWORK	; Yes, process the command
  8842 00001B18 E82400                  		call	NOSWIT		; No, check to see if any switches
  8843 00001B1B 7506                    		jnz	short REALWORK	; None, process the command
  8844                                  
  8845                                  		; MSDOS 6.0
  8846                                  		;mov	msg_disp_class,parse_msg_class	
  8847                                  		;			;AN000; set up parse error msg class
  8848                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8849                                  		;			;AC000; get extended message pointer
  8850                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8851                                  		;			;AN000; get "Invalid switch" message number
  8852                                  		;jmp	CERROR		; Print error and chill out...
  8853                                  
  8854                                  		; MSDOS 3.0
  8855 00001B1D BA[3239]                		mov	dx,BADPARMPTR
  8856 00001B20 E9C300                  		jmp	CERROR
  8857                                  
  8858                                  REALWORK:
  8859 00001B23 FFD3                    		call	bx		; do some real work, at last
  8860                                  
  8861                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8862                                  ; otherwise, go get another command.
  8863                                  
  8864                                  CMD_DONE:
  8865 00001B25 0E                      		push	cs		; g  restore data segment
  8866 00001B26 1F                      		pop	ds		; g
  8867 00001B27 1E                      		push	ds
  8868 00001B28 8E1E[5641]              		mov	ds,[RESSEG]	; g  save data segment
  8869                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8870 00001B2C 803EE80B01              		cmp	byte [CALL_FLAG],call_in_progress
  8871 00001B31 C606E80B00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8872 00001B36 1F                      		pop	ds		; g  get data segment back
  8873 00001B37 7403                    		jz	short INCALL	; G
  8874 00001B39 E9C8E5                  		jmp	TCOMMAND	; chill out...
  8875                                  INCALL:
  8876 00001B3C E96EE7                  		jmp	DOCOM1
  8877                                  
  8878                                  ; =============== S U B	R O U T	I N E =======================================
  8879                                  
  8880                                  NOSWIT:
  8881 00001B3F 57                      		push	di		; Save di
  8882 00001B40 BF8100                  		mov	di,81h		; di = ptr to command args
  8883 00001B43 BE8000                  		mov	si,80h		; Get address of length of command args
  8884 00001B46 AC                      		lodsb			; Load length
  8885 00001B47 88C1                    		mov	cl,al		; Move length to cl
  8886 00001B49 30ED                    		xor	ch,ch		; Zero ch
  8887 00001B4B 2EA0[5A41]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8888 00001B4F 3C00                    		cmp	al,0		; Turn off ZF
  8889 00001B51 F2AE                    		repne scasb		; Scan for a switch character and return
  8890 00001B53 5F                      		pop	di		;  with ZF set if one was found
  8891 00001B54 C3                      		retn
  8892                                  
  8893                                  ; ---------------------------------------------------------------------------
  8894                                  
  8895                                  EXTERNAL:
  8896 00001B55 E8BB01                  		call	TEST_APPEND	; check to see if append installed
  8897 00001B58 7406                    		jz	short NOT_BARRYF ; no - truly external command
  8898 00001B5A E954FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8899                                  
  8900                                  		; 25/02/2023
  8901                                  BATCOMJ:
  8902 00001B5D E981EB                  		jmp	BATCOM
  8903                                  
  8904                                  NOT_BARRYF:
  8905 00001B60 2EC606[6941]00          		mov	byte [cs:FILTYP],0
  8906 00001B66 2E8A16[7641]            		mov	dl,[cs:SPECDRV]
  8907 00001B6B 2E8816[D041]            		mov	[cs:IDLEN],dl
  8908 00001B70 2EC606[4C43]00          		mov	byte [cs:ROM_CALL],0
  8909 00001B76 52                      		push	dx
  8910 00001B77 BA[D041]                		mov	dx,IDLEN
  8911 00001B7A E852E8                  		call	ROM_SCAN
  8912 00001B7D 5A                      		pop	dx
  8913                                  		;jnc	short POSTSAVE
  8914 00001B7E 7305                    		jnc	short DO_SCAN
  8915 00001B80 2EFE06[4C43]            		inc	byte [cs:ROM_CALL]
  8916                                  		;jmp	short POSTSAVE
  8917                                  
  8918                                  		;nop
  8919                                  DO_SCAN:
  8920                                  POSTSAVE:
  8921 00001B85 BF[7E40]                		mov	di,EXECPATH
  8922 00001B88 C60500                  		mov	byte [di],0	; Initialize to current directory
  8923                                  	
  8924 00001B8B 2E803E[4C43]00          		cmp	byte [cs:ROM_CALL],0
  8925                                  		;jz	short RESEARCH
  8926                                  		;jmp	short NEOEXECUTE
  8927                                  		; 25/02/2023
  8928 00001B91 750C                    		jnz	short NEOEXECUTE		
  8929                                  
  8930                                  		;nop
  8931                                  RESEARCH:
  8932 00001B93 E8CA08                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8933 00001B96 09C0                    		or	ax,ax		; did we find anything?
  8934                                  		;jz	short BADCOMJ45	; null means no (sob)
  8935                                  		; 25/02/2023
  8936 00001B98 7447                    		jz	short BADCOM
  8937 00001B9A 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8938                                  					; fuckin' sixteen-bit machine ought
  8939 00001B9D 7CBE                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8940                                  					; DISPLACEMENT!!
  8941                                  		; 25/02/2023
  8942                                  		;;jmp	short NEOEXECUTE
  8943                                  		;jmp	short EXECUTE	
  8944                                  
  8945                                  		; 02H is .bat
  8946                                  
  8947                                  		;nop
  8948                                  
  8949                                  		; 25/02/2023
  8950                                  ;BATCOMJ:
  8951                                  ;		jmp	BATCOM
  8952                                  ;
  8953                                  ;BADCOMJ45:
  8954                                  ;		jmp	short BADCOM
  8955                                  
  8956                                  		;nop
  8957                                  EXECUTE:
  8958                                  NEOEXECUTE:
  8959 00001B9F E80E02                  		call	IOSET
  8960                                  
  8961                                  ; MSDOS 6.0
  8962                                  ;M051
  8963                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8964                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8965                                  ;After a close, this would still leave one open active resulting in sharing
  8966                                  ;errors on subsequent opens of the redirected file.
  8967                                  ;
  8968                                  ;LH_EXECUTE:				;M051	
  8969 00001BA2 8E06[6641]              		mov	es,[TRAN_TPA]
  8970 00001BA6 B449                    		mov	ah,DEALLOC ; 49h
  8971 00001BA8 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8972                                  				; ES = segment address of area to be freed
  8973                                  					; Now running in "free" space
  8974 00001BAA 8E06[5641]              		mov	es,[RESSEG]
  8975 00001BAE 26FE06D30B              		inc	byte [es:EXTCOM] ; Indicate external command
  8976 00001BB3 26C606DB0B00            		mov	byte [es:RESTDIR],0 
  8977                                  					; Since USERDIR1 is in transient, insure
  8978                                  					; this flag value for re-entry to COMMAND
  8979                                  		; MSDOS 6.0
  8980                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8981                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8982                                  		;MOV	CX,LenMsgOrPathBuf
  8983                                  		;CLD
  8984                                  		;REP	MOVSB		; copy program pathname to resident
  8985                                  
  8986                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8987 00001BB9 BF5C00                  		mov	di,FCB ; 5Ch
  8988 00001BBC 89FE                    		mov	si,di
  8989 00001BBE B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8990 00001BC1 F3A5                    		rep movsw		; Transfer parameters to resident header
  8991 00001BC3 BA[7E40]                		mov	dx,EXECPATH
  8992                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8993 00001BC6 BBED0C                  		mov	bx,EXEC_BLOCK
  8994 00001BC9 B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8995 00001BCC F606[4C43]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8996 00001BD1 7403                    		jz	short OK_EXEC
  8997 00001BD3 E972E8                  		jmp	ROM_EXEC
  8998                                  OK_EXEC:
  8999                                  ;
  9000                                  ; we are now running in free space. Anything we do from here on may get
  9001                                  ; trashed. Move the stack (also in free space) to allocated space because
  9002                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  9003                                  ;
  9004 00001BD6 8CC1                    		mov	cx,es
  9005 00001BD8 8ED1                    		mov	ss,cx
  9006 00001BDA BC2C08                  		mov	sp,RSTACK
  9007 00001BDD FF2E[5C41]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  9008                                  
  9009                                  ; ---------------------------------------------------------------------------
  9010                                  
  9011                                  BADCOM:
  9012 00001BE1 0E                      		push	cs
  9013 00001BE2 1F                      		pop	ds
  9014 00001BE3 BA[CB36]                		mov	dx,BADNAMPTR
  9015                                  CERROR:		
  9016 00001BE6 E82218                  		call	STD_EPRINTF
  9017 00001BE9 E918E5                  		jmp	TCOMMAND
  9018                                  
  9019                                  
  9020                                  ; =============== S U B	R O U T	I N E =======================================
  9021                                  
  9022                                  ; Prescan converts the input buffer into a canonicalized form.
  9023                                  ; All redirections and pipes are removed.
  9024                                  
  9025                                  PRESCAN:
  9026 00001BEC 31C9                    		xor	cx,cx
  9027 00001BEE 8E06[5641]              		mov	es,[RESSEG]
  9028 00001BF2 BE[B73F]                		mov	si,COMBUF+2
  9029 00001BF5 89F7                    		mov	di,si
  9030                                  COUNTQUOTES:
  9031 00001BF7 AC                      		lodsb			; get a byte
  9032 00001BF8 3C22                    		cmp	al,22h		; is it a quote?
  9033 00001BFA 7504                    		jne	short COUNTEND	; no, try for end of road
  9034 00001BFC FEC5                    		inc	ch		; bump count
  9035 00001BFE EBF7                    		jmp	short COUNTQUOTES ; go get next char
  9036                                  COUNTEND:
  9037 00001C00 3C0D                    		cmp	al,0Dh		; end of road?
  9038 00001C02 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  9039 00001C04 89FE                    		mov	si,di		; restore pointer to begining
  9040                                  PRESCANLP:
  9041 00001C06 AC                      		lodsb
  9042 00001C07 3C22                    		cmp	al,'"'		; " character
  9043 00001C09 7510                    		jne	short TRYGREATER
  9044 00001C0B FECD                    		dec	ch
  9045 00001C0D 740C                    		jz	short TRYGREATER
  9046                                  QLOOP:
  9047 00001C0F 8805                    		mov	[di],al
  9048 00001C11 47                      		inc	di
  9049 00001C12 FEC1                    		inc	cl
  9050 00001C14 AC                      		lodsb
  9051 00001C15 3C22                    		cmp	al,'"'		; " character
  9052 00001C17 75F6                    		jne	short QLOOP
  9053 00001C19 FECD                    		dec	ch
  9054                                  TRYGREATER:
  9055                                  		;cmp	al,[RABRACKET]
  9056                                  		; 01/03/2023
  9057 00001C1B 3C3E                    		cmp	al,rabracket  ; '>'
  9058 00001C1D 753E                    		jne	short NOOUT
  9059                                  
  9060                                  ; We have found a ">" char. We need to see if there is another ">"
  9061                                  ; following it.
  9062                                  
  9063 00001C1F 3804                    		cmp	[si],al
  9064 00001C21 7506                    		jnz	short NOAPPND
  9065 00001C23 AC                      		lodsb
  9066 00001C24 26FE06F20B              		inc	byte [es:RE_OUT_APP] ; Flag >>
  9067                                  NOAPPND:
  9068                                  ; Now we attempt to find the file name. First, scan off all whitespace
  9069                                  
  9070 00001C29 E816FD                  		call	SCANOFF
  9071                                  
  9072                                  		; MSDOS 6.0
  9073                                  		;;cmp	al,[LABRACKET]	   ;AN040; was there no filename?
  9074                                  		;cmp	al,labracket ; '<'
  9075                                  		;je	short REOUT_ERRSET ;AN040; yes - set up error
  9076                                  
  9077                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9078 00001C2C 3C0D                    		cmp	al,0Dh
  9079 00001C2E 750D                    		jnz	short GOTREOFIL
  9080                                  
  9081                                  ; There was no file present. Set us up at end-of-line.
  9082                                  
  9083                                  REOUT_ERRSET:				;AN040; set up for an error
  9084 00001C30 C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  9085 00001C33 26C706F30B0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  9086 00001C3A E99000                  		jmp	PRESCANEND
  9087                                  
  9088                                  GOTREOFIL:
  9089 00001C3D 57                      		push	di
  9090                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  9091 00001C3E BFF30B                  		mov	di,RE_OUTSTR
  9092 00001C41 89FB                    		mov	bx,di
  9093 00001C43 06                      		push	es
  9094                                  
  9095                                  		; MSDOS 6.0
  9096                                  SETREOUTSTR:				; Get the output redirection name
  9097                                  					; MSKK06 07/14/89
  9098                                  		;push	cx		; save cx
  9099                                  		;mov	cx,64+13	; CX = max string length
  9100                                  ;SETREOUTSTR_LOOP:
  9101                                  		;LODSB
  9102                                  		;CMP	AL,0DH
  9103                                  		;JZ	GOTRESTR_J
  9104                                  		;INVOKE	DELIM
  9105                                  		;JZ	GOTRESTR_J
  9106                                  		;CMP	AL,[SWITCHAR]
  9107                                  		;JZ	GOTRESTR_J
  9108                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  9109                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  9110                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  9111                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  9112                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  9113                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  9114                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  9115                                  		;DEC	SI		;AN002; back up over symbol
  9116                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  9117                                  ;GOTRESTR_J:
  9118                                  		;pop	cx		; MSKK06 07/14/89
  9119                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  9120                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  9121                                  		;STOSB			; store it into resgroup
  9122                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  9123                                  		;jmp	GOTRESTR_j
  9124                                  ;PIPEERRSYNJ5_J:
  9125                                  		;pop	cx		; recover CX
  9126                                  		;jmp	short PIPEERRSYNJ5
  9127                                  
  9128                                  		; MSDOS 3.3
  9129                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  9130 00001C44 AC                      		lodsb
  9131 00001C45 3C0D                    		cmp	al,0Dh
  9132 00001C47 7460                    		jz	short GOTRESTR
  9133 00001C49 E8FEFC                  		call	DELIM
  9134 00001C4C 745B                    		jz	short GOTRESTR
  9135 00001C4E 3A06[5A41]              		cmp	al,[SWITCHAR]
  9136 00001C52 7455                    		je	short GOTRESTR
  9137 00001C54 3C22                    		cmp	al,'"'
  9138 00001C56 7502                    		jne	short NO_ABRACKET
  9139 00001C58 FECD                    		dec	ch
  9140                                  NO_ABRACKET:
  9141 00001C5A AA                      		stosb
  9142 00001C5B EBE7                    		jmp	short SETREOUTSTR_LOOP
  9143                                  NOOUT:
  9144                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9145                                  		;cmp	al,[LABRACKET]
  9146                                  		; 01/03/2023
  9147 00001C5D 3C3C                    		cmp	al,labracket ; '<'
  9148 00001C5F 751F                    		jnz	short CHKPIPE
  9149 00001C61 89F3                    		mov	bx,si		; Save loc of "<"
  9150 00001C63 E8DCFC                  		call	SCANOFF
  9151                                  		; MSDOS 6.0
  9152                                  		;;cmp	al,[RABRACKET]	;AN040; was there no filename?
  9153                                  		;cmp	al,rabracket ; '>'
  9154                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9155                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9156 00001C66 3C0D                    		cmp	al,0Dh
  9157 00001C68 750B                    		jnz	short GOTREIFIL
  9158                                  REIN_ERRSET:				;AN040; set up for error
  9159 00001C6A C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9160 00001C6D C706[0141]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9161 00001C73 EB58                    		jmp	short PRESCANEND
  9162                                  GOTREIFIL:
  9163 00001C75 57                      		push	di
  9164 00001C76 BF[0141]                		mov	di,RE_INSTR
  9165 00001C79 89FB                    		mov	bx,di
  9166 00001C7B 06                      		push	es
  9167 00001C7C 0E                      		push	cs
  9168 00001C7D 07                      		pop	es		; store in TRANGROUP
  9169 00001C7E EBC4                    		jmp	short SETREOUTSTR_LOOP 
  9170                                  					; Get the input redirection name
  9171                                  CHKPIPE:
  9172 00001C80 88C4                    		mov	ah,al
  9173                                  		;cmp	ah,'|'
  9174 00001C82 80FC7C                  		cmp	ah,ALTPIPECHR
  9175                                  		; 01/03/2023
  9176                                  		;je	short ISPIPE3
  9177                                  		;;cmp	ah,[VBAR]
  9178                                  		;cmp	ah,vbar	; '|'
  9179 00001C85 7539                    		jne	short CONTPRESCAN
  9180                                  ISPIPE3:
  9181                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9182                                  
  9183 00001C87 26803E440C00            		cmp	byte [es:PIPEFLAG],0
  9184 00001C8D 7505                    		jne	short NOECHOPUSH
  9185 00001C8F 26D026D70B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9186                                  NOECHOPUSH:
  9187 00001C94 26FE06440C              		inc	byte [es:PIPEFLAG]
  9188 00001C99 E8A6FC                  		call	SCANOFF
  9189 00001C9C 3C0D                    		cmp	al,0Dh
  9190 00001C9E 7404                    		jz	short PIPEERRSYNJ5
  9191                                  		;cmp	al,'|'
  9192 00001CA0 3C7C                    		cmp	al,ALTPIPECHR
  9193                                  		; 01/03/2023
  9194                                  		;jz	short PIPEERRSYNJ5
  9195                                  		;;cmp	al,[VBAR]	; '|'
  9196                                  		;cmp	al,vbar
  9197 00001CA2 751C                    		jnz	short CONTPRESCAN
  9198                                  PIPEERRSYNJ5:
  9199 00001CA4 06                      		push	es
  9200 00001CA5 1F                      		pop	ds
  9201 00001CA6 E93802                  		jmp	PIPEERRSYN
  9202                                  
  9203                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9204                                  ; than just a : in the redir string.
  9205                                  
  9206                                  GOTRESTR:
  9207 00001CA9 86E0                    		xchg	ah,al
  9208 00001CAB B03A                    		mov	al,':'
  9209 00001CAD 29FB                    		sub	bx,di		; compute negative of number of chars
  9210 00001CAF 83FBFF                  		cmp	bx,-1		; is there just a :?
  9211 00001CB2 7407                    		je	short NOTRAILCOL ; yep, don't change
  9212 00001CB4 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9213 00001CB8 7501                    		jne	short NOTRAILCOL
  9214 00001CBA 4F                      		dec	di		; Back up over trailing ':'
  9215                                  NOTRAILCOL:
  9216 00001CBB 30C0                    		xor	al,al
  9217 00001CBD AA                      		stosb			; NUL terminate the string
  9218 00001CBE 07                      		pop	es
  9219 00001CBF 5F                      		pop	di		; Remember the start
  9220                                  CONTPRESCAN:
  9221 00001CC0 8825                    		mov	[di],ah		; "delete" the redirection string
  9222 00001CC2 47                      		inc	di
  9223 00001CC3 80FC0D                  		cmp	ah,0Dh
  9224 00001CC6 7405                    		je	short PRESCANEND
  9225 00001CC8 FEC1                    		inc	cl
  9226 00001CCA E939FF                  		jmp	PRESCANLP
  9227                                  PRESCANEND:
  9228 00001CCD 26803E440C00            		cmp	byte [es:PIPEFLAG],0
  9229 00001CD3 7414                    		je	short ISNOPIPE
  9230                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9231 00001CD5 BF680C                  		mov	di,PIPESTR
  9232 00001CD8 26893E660C              		mov	[es:PIPEPTR],di
  9233 00001CDD BE[B73F]                		mov	si,COMBUF+2
  9234 00001CE0 E85FFC                  		call	SCANOFF
  9235                                  PIPESETLP:				; Transfer the pipe into the resident
  9236 00001CE3 AC                      		lodsb			; pipe buffer
  9237 00001CE4 AA                      		stosb
  9238 00001CE5 3C0D                    		cmp	al,0Dh
  9239 00001CE7 75FA                    		jnz	short PIPESETLP
  9240                                  ISNOPIPE:
  9241 00001CE9 880E[B63F]              		mov	[COMBUF+1],cl
  9242 00001CED 26803E440C00            		cmp	byte [es:PIPEFLAG],0
  9243 00001CF3 0E                      		push	cs
  9244 00001CF4 07                      		pop	es
  9245 00001CF5 C3                      		retn
  9246                                  
  9247                                  ; =============== S U B	R O U T	I N E =======================================
  9248                                  
  9249                                  CMD_COPY:
  9250 00001CF6 BE[B73F]                		mov	si,COMBUF+2
  9251 00001CF9 E846FC                  		call	SCANOFF		; advance past separators...
  9252 00001CFC 0336[A542]              		add	si,[PATHPOS]
  9253 00001D00 BF8100                  		mov	di,81h
  9254 00001D03 31C9                    		xor	cx,cx
  9255                                  CMDCOPY:
  9256 00001D05 AC                      		lodsb
  9257 00001D06 AA                      		stosb
  9258 00001D07 3C0D                    		cmp	al,0Dh
  9259 00001D09 7403                    		je	short COPY_DONE
  9260 00001D0B 41                      		inc	cx
  9261 00001D0C EBF7                    		jmp	short CMDCOPY
  9262                                  COPY_DONE:
  9263 00001D0E 880E8000                		mov	[80h],cl
  9264 00001D12 C3                      		retn
  9265                                  
  9266                                  ; =============== S U B	R O U T	I N E =======================================
  9267                                  
  9268                                  TEST_APPEND:
  9269 00001D13 BB[B53F]                		mov	bx,COMBUF	; barry can address
  9270 00001D16 BE[D041]                		mov	si,IDLEN	; address command name, DS already set 	
  9271 00001D19 BAFFFF                  		mov	dx,-1
  9272 00001D1C B800AE                  		mov	ax,0AE00h
  9273 00001D1F CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9274                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9275                                  				; DX = FFFFh,[BX -> command line
  9276                                  				; Return: AL = FFh if this command is a TSR extension 
  9277                                  				;		   to COMMAND.COM
  9278                                  				; AL = 00h if the command should be executed as	usual
  9279 00001D21 3C00                    		cmp	al,0
  9280 00001D23 C3                      		retn
  9281                                  
  9282                                  ;============================================================================
  9283                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9284                                  ;============================================================================
  9285                                  ; 05/10/2018 - Retro DOS v3.0
  9286                                  
  9287                                  ;	More misc routines
  9288                                  
  9289                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9290                                  
  9291                                  ; =============== S U B	R O U T	I N E =======================================
  9292                                  
  9293                                  SETPATH:
  9294                                  
  9295                                  ; ENTRY PathPos = ptr to string
  9296                                  ;       PathCnt = length of string
  9297                                  ;
  9298                                  ; EXIT  PathPos = ptr to string after pathname
  9299                                  ;       PathCnt = length of rest of string
  9300                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9301                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9302                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9303                                  ;
  9304                                  ;       A null character is dropped at the end of the pathname. If the
  9305                                  ;       character in that spot previously was CR, it is copied into the
  9306                                  ;       following byte. So there must be at least two two character 
  9307                                  ;       positions in the buffer following the pathname.
  9308                                  
  9309                                  		; MSDOS 6.0
  9310                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9311                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9312                                  
  9313                                  		; MSDOS 3.3
  9314 00001D24 BE8000                  		mov	si,80h
  9315 00001D27 AC                      		lodsb
  9316 00001D28 30E4                    		xor	ah,ah
  9317 00001D2A A3[A342]                		mov	[PATHCNT],ax
  9318 00001D2D 8936[A542]              		mov	[PATHPOS],si
  9319                                  GETPATH:
  9320                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9321 00001D31 C606[5543]00            		mov	byte [DESTINFO],0
  9322 00001D36 C606[5143]00            		mov	byte [DESTVARS],0
  9323 00001D3B 8B36[A542]              		mov	si,[PATHPOS]	; SI = ptr to string
  9324 00001D3F 8B0E[A342]              		mov	cx,[PATHCNT]	; CX = string length
  9325 00001D43 89F2                    		mov	dx,si		; DX = ptr to string
  9326 00001D45 E33B                    		jcxz	PATHDONE	; string length is zero, we're done
  9327 00001D47 51                      		push	cx		; save string length
  9328 00001D48 56                      		push	si		; save ptr to string
  9329 00001D49 E825FD                  		call	SWITCH
  9330                                  
  9331                                  ;       After Switch, SI has been scanned past any switches, and
  9332                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9333                                  
  9334 00001D4C A3[A742]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9335 00001D4F 5B                      		pop	bx		; BX = ptr to original string
  9336 00001D50 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9337 00001D52 59                      		pop	cx		; CX = string length
  9338 00001D53 01D9                    		add	cx,bx		; CX = string length from current SI
  9339 00001D55 89F2                    		mov	dx,si		; DX = ptr to current string
  9340                                  SKIPPATH:
  9341 00001D57 E329                    		jcxz	PATHDONE	; string length is zero, we're done
  9342 00001D59 49                      		dec	cx		; CX = length left after next char
  9343 00001D5A AC                      		lodsb			; AL = next char of string
  9344                                  					; SI = ptr to char after this one
  9345 00001D5B E876FC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9346 00001D5E 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9347 00001D60 FE06[5143]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9348                                  TESTPMETA:
  9349 00001D64 3C3F                    		cmp	al,'?'
  9350 00001D66 7505                    		jne	short TESTPSTAR	; char is not '?'
  9351 00001D68 800E[5543]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9352                                  TESTPSTAR:
  9353                                  		;cmp	al,'*'
  9354                                  		;cmp	al,[STAR]
  9355                                  		; 01/03/2023
  9356 00001D6D 3C2A                    		cmp	al,star ; cmp al,'*'
  9357 00001D6F 7505                    		jne	short TESTPDELIM ; char is not '*'
  9358 00001D71 800E[5543]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9359                                  TESTPDELIM:
  9360 00001D76 E8D1FB                  		call	DELIM		; compare AL to all delimiters
  9361 00001D79 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9362 00001D7B 3A06[5A41]              		cmp	al,[SWITCHAR]
  9363 00001D7F 75D6                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9364                                  PATHDONEDEC:
  9365 00001D81 4E                      		dec	si		; SI = ptr to char after pathname
  9366                                  PATHDONE:
  9367 00001D82 30C0                    		xor	al,al		; AL = NULL
  9368 00001D84 8604                    		xchg	al,[si]		; place NULL after pathname
  9369 00001D86 46                      		inc	si		; SI = ptr to byte after NULL
  9370 00001D87 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9371 00001D89 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9372 00001D8B 8804                    		mov	[si],al		; save EOL after NULL
  9373                                  NOPSTORE:
  9374 00001D8D 8936[A542]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9375 00001D91 890E[A342]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9376                                  SETPATH_RETN:
  9377 00001D95 C3                      		retn
  9378                                  
  9379                                  ; ---------------------------------------------------------------------------
  9380                                  
  9381                                  PGETARG:
  9382 00001D96 BE8000                  		mov	si,80h
  9383 00001D99 AC                      		lodsb
  9384 00001D9A 08C0                    		or	al,al
  9385 00001D9C 74F7                    		jz	short SETPATH_RETN
  9386 00001D9E E80300                  		call	PSCANOFF
  9387 00001DA1 3C0D                    		cmp	al,0Dh
  9388 00001DA3 C3                      		retn
  9389                                  
  9390                                  ; ---------------------------------------------------------------------------
  9391                                  
  9392                                  PSCANOFF:
  9393 00001DA4 AC                      		lodsb
  9394 00001DA5 E8A2FB                  		call	DELIM
  9395 00001DA8 7504                    		jnz	short PSCANOFFD
  9396 00001DAA 3C3B                    		cmp	al,';'
  9397 00001DAC 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9398                                  PSCANOFFD:
  9399 00001DAE 4E                      		dec	si		; Point to first non-delimiter
  9400 00001DAF C3                      		retn
  9401                                  
  9402                                  ; =============== S U B	R O U T	I N E =======================================
  9403                                  
  9404                                  IOSET:
  9405                                  		; ALL REGISTERS PRESERVED
  9406 00001DB0 1E                      		push	ds
  9407 00001DB1 52                      		push	dx
  9408 00001DB2 50                      		push	ax
  9409 00001DB3 53                      		push	bx
  9410 00001DB4 51                      		push	cx
  9411 00001DB5 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  9412 00001DBA 803E440C00              		cmp	byte [PIPEFLAG],0
  9413 00001DBF 750D                    		jne	short NOREDIR
  9414 00001DC1 F606E20BFF              		test	byte [IFFLAG],0FFh
  9415 00001DC6 7506                    		jnz	short NOREDIR
  9416 00001DC8 E80900                  		call	TESTDOREIN
  9417 00001DCB E85400                  		call	TESTDOREOUT
  9418                                  NOREDIR:
  9419 00001DCE 59                      		pop	cx
  9420 00001DCF 5B                      		pop	bx
  9421 00001DD0 58                      		pop	ax
  9422 00001DD1 5A                      		pop	dx
  9423 00001DD2 1F                      		pop	ds
  9424                                  IOSET_RETN:
  9425 00001DD3 C3                      		retn
  9426                                  
  9427                                  ; =============== S U B	R O U T	I N E =======================================
  9428                                  
  9429                                  TESTDOREIN:
  9430 00001DD4 2E803E[0141]00          		cmp	byte [cs:RE_INSTR],0
  9431 00001DDA 74F7                    		jz	short IOSET_RETN
  9432 00001DDC 1E                      		push	ds
  9433 00001DDD 0E                      		push	cs
  9434 00001DDE 1F                      		pop	ds
  9435 00001DDF BA[0141]                		mov	dx,RE_INSTR
  9436 00001DE2 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9437 00001DE5 89C3                    		mov	bx,ax
  9438 00001DE7 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9439                                  				; DS:DX	-> ASCIZ filename
  9440                                  				; AL = access mode
  9441                                  				; 0 - read
  9442 00001DE9 1F                      		pop	ds
  9443 00001DEA 720B                    		jb	short REDIRERR
  9444 00001DEC 89C3                    		mov	bx,ax
  9445 00001DEE B0FF                    		mov	al,0FFh
  9446                                  
  9447                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9448                                  ; spot. We invalidate the new JFN we got.
  9449                                  
  9450                                  		;xchg	al,[bx+18h]
  9451 00001DF0 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9452 00001DF3 A21800                  		mov	[PDB.JFN_TABLE],al
  9453 00001DF6 C3                      		retn
  9454                                  
  9455                                  ; ---------------------------------------------------------------------------
  9456                                  
  9457                                  ; We had some kind of error on the redirection. Figure out what the
  9458                                  ; appropriate message should be; BX has the system call that failed
  9459                                  
  9460                                  REDIRERR:
  9461 00001DF7 0E                      		push	cs
  9462 00001DF8 1F                      		pop	ds
  9463                                  		;call	TriageError
  9464 00001DF9 E87900                  		call	GET_EXT_ERR_NUMBER
  9465                                  
  9466                                  ; At this point, we have recognized the network-generated access denied error.
  9467                                  ; The correct message is in DX
  9468                                  
  9469 00001DFC 83F841                  		cmp	ax,65
  9470 00001DFF 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9471 00001E01 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9472 00001E04 7406                    		jz	short OPENERR
  9473 00001E06 BA[7E37]                		mov	dx,FULDIRPTR
  9474                                  _CERRORJ:
  9475 00001E09 E9DAFD                  		jmp	CERROR
  9476                                  
  9477                                  OPENERR:
  9478                                  ; The system call was an OPEN. Report either file not found or path not found.
  9479                                  
  9480                                  		; MSDOS 6.0
  9481                                  		;mov	msg_disp_class,ext_msg_class 
  9482                                  		;			;AN000; set up extended error msg class
  9483                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9484                                  		;			;AC000; get extended message pointer
  9485                                  		;mov	Extend_Buf_ptr,ax	
  9486                                  		;			;AN000; get message number in control block
  9487                                  		;JMP	CERROR
  9488                                  
  9489                                  		; MSDOS 3.3
  9490 00001E0C BA[0837]                		mov	dx,FNOTFOUNDPTR
  9491                                  		;cmp	ax,2
  9492 00001E0F 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9493 00001E12 74F5                    		je	short _CERRORJ
  9494 00001E14 BA[2D37]                		mov	dx,ACCDENPTR
  9495                                  		;cmp	ax,5 ; Access denied error
  9496 00001E17 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9497 00001E1A 74ED                    		je	short _CERRORJ
  9498                                  			; ERROR_PATH_NOT_FOUND
  9499 00001E1C BA[1B37]                		mov	dx,PNOTFOUNDPTR
  9500 00001E1F E9C4FD                  		jmp	CERROR
  9501                                  
  9502                                  ; =============== S U B	R O U T	I N E =======================================
  9503                                  
  9504                                  TESTDOREOUT:
  9505 00001E22 803EF30B00              		cmp	byte [RE_OUTSTR],0
  9506 00001E27 743D                    		je	short NOREOUT
  9507                                  
  9508                                  REOUTEXISTS:
  9509 00001E29 803EF20B00              		cmp	byte [RE_OUT_APP],0
  9510 00001E2E 741F                    		je	short REOUTCRT
  9511                                  
  9512 00001E30 BAF30B                  		mov	dx,RE_OUTSTR
  9513                                  
  9514                                  		; MSDOS 6.0
  9515                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9516                                  		;mov	ax,3D02h
  9517                                  
  9518                                  		; MSDOS 3.3
  9519 00001E33 B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9520                                  	
  9521                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9522 00001E36 50                      		push	ax
  9523 00001E37 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9524                                  				; DS:DX	-> ASCIZ filename
  9525                                  				; AL = access mode
  9526                                  				; 1 - write
  9527 00001E39 5B                      		pop	bx
  9528 00001E3A 720D                    		jc	short OPENWRITEERROR
  9529                                  
  9530                                  		; MSDOS 6.0
  9531                                  		;MOV	BX,AX
  9532                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9533                                  		;INT	21h			;AN035;
  9534                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9535                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9536                                  		;
  9537                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9538                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9539                                  		;MOV	DX,CX			;AC011;
  9540                                  		;INT	21h
  9541                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9542                                  		;POP	DS			;AN011;
  9543                                  		;assume	DS:Trangroup		;AN011;
  9544                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9545                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9546                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9547                                  		;INT	21h			;AN011;
  9548                                  		;JC	OpenWriteError		;AN011; If error, exit
  9549                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9550                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9551                                  		;
  9552                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9553                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9554                                  		;assume	DS:Resgroup		;AN011;
  9555                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9556                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9557                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9558                                  		;MOV	DX,CX			;AN011;
  9559                                  		;INT	21h			;AN011;
  9560                                  		;JMP	SHORT SET_REOUT
  9561                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9562                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9563                                  		;assume	DS:Resgroup		;AN017;
  9564                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9565                                  		;XOR	CX,CX			;AN017; Offset is 0
  9566                                  		;MOV	DX,CX			;AN017;
  9567                                  		;INT	21h			;AN017;
  9568                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9569                                  
  9570                                  		; MSDOS 3.3
  9571 00001E3C 31D2                    		xor	dx,dx
  9572 00001E3E 31C9                    		xor	cx,cx
  9573 00001E40 89C3                    		mov	bx,ax
  9574 00001E42 B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9575 00001E45 CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9576                                  				; AL = method: offset from end of file
  9577 00001E47 EB15                    		jmp	short SET_REOUT
  9578                                  		
  9579                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9580                                  OPENWRITEERROR:	
  9581                                  		;cmp	ax,5
  9582 00001E49 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9583 00001E4C F9                      		stc
  9584 00001E4D 74A8                    		je	short REDIRERR
  9585                                  REOUTCRT:	
  9586 00001E4F BAF30B                  		mov	dx,RE_OUTSTR
  9587 00001E52 31C9                    		xor	cx,cx
  9588 00001E54 B43C                    		mov	ah,CREAT ; 3Ch
  9589 00001E56 50                      		push	ax
  9590 00001E57 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9591                                  				; CX = attributes for file
  9592                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9593 00001E59 5B                      		pop	bx
  9594 00001E5A 729B                    		jc	short REDIRERR
  9595                                  NOREDIRERR:
  9596 00001E5C 89C3                    		mov	bx,ax
  9597                                  SET_REOUT:
  9598                                  
  9599                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9600                                  ; spot. We invalidate the new JFN we got.
  9601                                  
  9602 00001E5E B0FF                    		mov	al,0FFh
  9603                                  		;xchg	al,[bx+18h]
  9604 00001E60 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9605 00001E63 A21900                  		mov	[PDB.JFN_TABLE+1],al
  9606                                  NOREOUT:
  9607 00001E66 C3                      		retn
  9608                                  
  9609                                  ; =============== S U B	R O U T	I N E =======================================
  9610                                  
  9611                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9612                                  ; registers
  9613                                  
  9614                                  DSTRLEN:
  9615 00001E67 50                      		push	ax
  9616 00001E68 31C9                    		xor	cx,cx
  9617 00001E6A FC                      		cld
  9618                                  DLOOP:
  9619 00001E6B AC                      		lodsb
  9620 00001E6C 41                      		inc	cx
  9621 00001E6D 08C0                    		or	al,al
  9622 00001E6F 75FA                    		jnz	short DLOOP
  9623 00001E71 29CE                    		sub	si,cx
  9624 00001E73 58                      		pop	ax
  9625                                  TRIAGEERR_RETN:
  9626 00001E74 C3                      		retn
  9627                                  
  9628                                  ; =============== S U B	R O U T	I N E =======================================
  9629                                  
  9630                                  ;Break	<Extended error support>
  9631                                  
  9632                                  TriageError:  ; MSDOS 6.0
  9633                                  
  9634                                  ;
  9635                                  ; TriageError will examine the return from a carry-set system call and
  9636                                  ; return the correct error if applicable.
  9637                                  ;
  9638                                  ;   Inputs:	outputs from a carry-settable system call
  9639                                  ;		No system calls may be done in the interrim
  9640                                  ;   Outputs:	If carry was set on input
  9641                                  ;		    carry set on output
  9642                                  ;		    DX contains trangroup offset to printf message
  9643                                  ;		else
  9644                                  ;		    No registers changed
  9645                                  ;
  9646                                  
  9647                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9648                                  
  9649                                  GET_EXT_ERR_NUMBER:
  9650 00001E75 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9651 00001E77 9C                      		pushf
  9652 00001E78 53                      		push	bx
  9653 00001E79 51                      		push	cx
  9654 00001E7A 56                      		push	si
  9655 00001E7B 57                      		push	di
  9656 00001E7C 55                      		push	bp
  9657 00001E7D 06                      		push	es
  9658 00001E7E 1E                      		push	ds
  9659 00001E7F 50                      		push	ax
  9660 00001E80 52                      		push	dx
  9661                                  		;mov	ah,59h
  9662 00001E81 B459                    		mov	ah,GETEXTENDEDERROR
  9663 00001E83 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9664                                  				; BX = version code (0000h for DOS 3.x)
  9665 00001E85 59                      		pop	cx
  9666 00001E86 5B                      		pop	bx		; restore original AX
  9667 00001E87 BA[2D37]                		mov	dx,ACCDENPTR
  9668 00001E8A 83F841                  		cmp	ax,65		; network access denied?
  9669 00001E8D 7404                    		je	short NOMOVE	; Yes, return it.
  9670 00001E8F 89D8                    		mov	ax,bx
  9671 00001E91 89CA                    		mov	dx,cx
  9672                                  NOMOVE:
  9673 00001E93 1F                      		pop	ds
  9674 00001E94 07                      		pop	es
  9675 00001E95 5D                      		pop	bp
  9676 00001E96 5F                      		pop	di
  9677 00001E97 5E                      		pop	si
  9678 00001E98 59                      		pop	cx
  9679 00001E99 5B                      		pop	bx
  9680 00001E9A 9D                      		popf
  9681 00001E9B C3                      		retn
  9682                                  
  9683                                  ; =============== S U B	R O U T	I N E =======================================
  9684                                  
  9685                                  		; Far call from resident portion/segment of COMMAND.COM
  9686                                  
  9687                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9688                                  
  9689                                  TRIAGE_INIT:
  9690                                  		;call	TriageError
  9691 00001E9C E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9692 00001E9F CB                      		retf
  9693                                  
  9694                                  ;============================================================================
  9695                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9696                                  ;============================================================================
  9697                                  ; 03/10/2018 - Retro DOS v3.0
  9698                                  
  9699                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9700                                  
  9701                                  ; =============== S U B	R O U T	I N E =======================================
  9702                                  
  9703                                  SINGLETEST:
  9704 00001EA0 1E                      		push	ds
  9705 00001EA1 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  9706 00001EA6 833EDD0B00              		cmp	word [SINGLECOM],0
  9707 00001EAB 7406                    		jz	short TESTDONE
  9708 00001EAD 813EDD0BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9709                                  TESTDONE:
  9710 00001EB3 1F                      		pop	ds
  9711 00001EB4 C3                      		retn
  9712                                  
  9713                                  ; =============== S U B	R O U T	I N E =======================================
  9714                                  
  9715                                  SETREST1:
  9716 00001EB5 B001                    		mov	al,1
  9717                                  
  9718                                  ; ---------------------------------------------------------------------------
  9719                                  
  9720                                  SETREST:
  9721 00001EB7 1E                      		push	ds
  9722 00001EB8 8E1E[5641]              		mov	ds,[RESSEG]
  9723 00001EBC A2DB0B                  		mov	[RESTDIR],al
  9724 00001EBF 1F                      		pop	ds
  9725 00001EC0 C3                      		retn
  9726                                  
  9727                                  ; =============== S U B	R O U T	I N E =======================================
  9728                                  
  9729                                  ; Note that we need to handle the same thing that RestDir handles: the
  9730                                  ; requirement that we try only once to restore the user's environment after
  9731                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9732                                  ; disappear, we just give up.
  9733                                  
  9734                                  PIPEDEL:
  9735 00001EC1 1E                      		push	ds
  9736 00001EC2 52                      		push	dx
  9737 00001EC3 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
  9738 00001EC8 BA460C                  		mov	dx,PIPE1	; Clean up in case ^C
  9739 00001ECB B441                    		mov	ah,UNLINK ; 41h 
  9740 00001ECD CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9741                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9742                                  				;		(no wildcards allowed)
  9743 00001ECF BA560C                  		mov	dx,PIPE2
  9744 00001ED2 B441                    		mov	ah,UNLINK ; 41h
  9745 00001ED4 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9746                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9747                                  				;		(no wildcards allowed)
  9748 00001ED6 5A                      		pop	dx
  9749 00001ED7 E83204                  		call	PIPEOFF
  9750 00001EDA C606450C00              		mov	byte [PIPEFILES],0
  9751 00001EDF 1F                      		pop	ds
  9752 00001EE0 C3                      		retn
  9753                                  
  9754                                  ; ---------------------------------------------------------------------------
  9755                                  
  9756                                  PIPEERRSYN:
  9757 00001EE1 BA[883B]                		mov	dx,SYNTMESPTR
  9758 00001EE4 E8DAFF                  		call	PIPEDEL
  9759 00001EE7 0E                      		push	cs
  9760 00001EE8 1F                      		pop	ds
  9761 00001EE9 E9FAFC                  		jmp	CERROR
  9762                                  
  9763                                  ; ---------------------------------------------------------------------------
  9764                                  
  9765                                  PIPERR:
  9766 00001EEC 9C                      		pushf
  9767                                  		;invoke	TRIAGEERROR
  9768 00001EED E885FF                  		call	GET_EXT_ERR_NUMBER
  9769 00001EF0 50                      		push	ax		; Save results from TriageError
  9770 00001EF1 52                      		push	dx
  9771 00001EF2 BA[E23B]                		mov	dx,PIPEEMESPTR
  9772 00001EF5 E8C9FF                  		call	PIPEDEL
  9773 00001EF8 0E                      		push	cs
  9774 00001EF9 1F                      		pop	ds
  9775 00001EFA E80E15                  		call	STD_EPRINTF
  9776 00001EFD 5A                      		pop	dx		; Restore results from TriageError
  9777 00001EFE 58                      		pop	ax
  9778 00001EFF 9D                      		popf
  9779 00001F00 83F841                  		cmp	ax,65
  9780 00001F03 7503                    		jnz	short TCOMMANDJ
  9781 00001F05 E9DEFC                  		jmp	CERROR
  9782                                  
  9783                                  TCOMMANDJ:
  9784 00001F08 E9F9E1                  		jmp	TCOMMAND
  9785                                  
  9786                                  PIPEPROCSTRT:
  9787 00001F0B 8E1E[5641]              		mov	ds,[RESSEG]
  9788 00001F0F FE06450C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9789                                  
  9790                                  		; MSDOS 6.0
  9791                                  		;push	es
  9792                                  		;push	di
  9793                                  		;push	ds
  9794                                  		;push	si
  9795                                  		;
  9796                                  		;push	ds
  9797                                  		;push	es
  9798                                  		;pop	ds				;ds = TRANGROUP
  9799                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9800                                  ;
  9801                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9802                                  ;so the routine is not really general
  9803                                  ;
  9804                                  		;call	Find_Name_In_Environment	;es:di points at path
  9805                                  		;pop	ds				;ds = DATARES again
  9806                                  		;jc	no_temp_path
  9807                                  		;
  9808                                  		;push	ds
  9809                                  		;push	es
  9810                                  		;pop	ds
  9811                                  		;pop	es				;swap ds and es
  9812                                  		;mov	si,di				;ds:si points at path
  9813                                  		;
  9814                                  		;call	skip_white			;skip white space chars
  9815                                  ;
  9816                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9817                                  ;
  9818                                  		;call	copy_pipe_path			;copy the pipe path
  9819                                  		;
  9820                                  ;
  9821                                  ;Check if the TEMP path is valid
  9822                                  ;
  9823                                  		;push	es
  9824                                  		;pop	ds				;ds = DATARES
  9825                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9826                                  		;mov	ax, (CHMOD shl 8) or 0
  9827                                  		;int	21h
  9828                                  		;jc	no_temp_path
  9829                                  		;
  9830                                  		;test	cx,10h				;is it a directory?
  9831                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9832                                  		;
  9833                                  		;stc					;no, indicate fail
  9834                                  no_temp_path:
  9835                                  		;pop	si
  9836                                  		;pop	ds
  9837                                  		;pop	di
  9838                                  		;pop	es
  9839                                  		;jnc	crt_temp			;path found, create tempfiles
  9840                                  
  9841                                  		; MSDOS 3.3
  9842 00001F13 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9843 00001F15 CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9844                                  		;add	al,[cs:CAPITAL_A]
  9845                                  		; 01/03/2023
  9846 00001F17 0441                    		add	al,capital_A  ; add al,'A'
  9847 00001F19 A2560C                  		mov	[PIPE2],al		; Make pipe files in root of def drv
  9848 00001F1C BB460C                  		mov	bx,PIPE1
  9849 00001F1F 8807                    		mov	[bx],al
  9850 00001F21 30E4                    		xor	ah,ah			; nul terminate path names
  9851 00001F23 8826490C                		mov	[PIPE1+3],ah
  9852 00001F27 8826590C                		mov	[PIPE2+3],ah
  9853                                  
  9854                                  		; MSDOS 6.0
  9855                                  ;SR;
  9856                                  ; We want to create temp files in the current directory rather than in the 
  9857                                  ;root of the drive. This is because the number of files that can be present
  9858                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9859                                  ;
  9860                                  		;mov	ah,'.'
  9861                                  		;mov	Pipe1,ah
  9862                                  		;mov	Pipe2,ah
  9863                                  		;xor	ah,ah
  9864                                  		;mov	Pipe1+1,ah
  9865                                  		;mov	Pipe2+1,ah		;create files in current dir
  9866                                  
  9867                                  ;crt_temp:
  9868                                  		; MSDOS 6.0
  9869                                  		;mov	dx,offset DATARES:Pipe1
  9870                                  		;mov	dx,PIPE1
  9871                                  	
  9872                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9873 00001F2B 89DA                    		mov	dx,bx
  9874 00001F2D 31C9                    		xor	cx,cx
  9875 00001F2F B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9876 00001F31 CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9877                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9878                                  			; receive generated filename
  9879                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9880 00001F33 72B7                    		jc	short PIPERR	; Couldn't create
  9881 00001F35 89C3                    		mov	bx,ax
  9882 00001F37 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9883 00001F39 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9884                                  				; BX = file handle
  9885 00001F3B BA560C                  		mov	dx,PIPE2
  9886 00001F3E B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9887 00001F40 CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9888                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9889                                  			; receive generated filename
  9890                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9891 00001F42 72A8                    		jc	short PIPERR
  9892 00001F44 89C3                    		mov	bx,ax
  9893 00001F46 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9894 00001F48 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9895                                  					; BX = file handle
  9896                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9897 00001F4A E887FE                  		call	TESTDOREIN
  9898 00001F4D 8B36660C                		mov	si,[PIPEPTR]
  9899 00001F51 833EDD0BFF              		cmp	word [SINGLECOM],-1
  9900 00001F56 7506                    		jne	short NOSINGP
  9901 00001F58 C706DD0B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9902                                  NOSINGP:
  9903 00001F5E EB26                    		jmp	short FIRSTPIPE
  9904                                  
  9905                                  ; ---------------------------------------------------------------------------
  9906                                  
  9907                                  PIPEPROC:
  9908 00001F60 8026D70BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9909 00001F65 8B36660C                		mov	si,[PIPEPTR]
  9910 00001F69 AC                      		lodsb
  9911                                  		;cmp	al,'|'		
  9912 00001F6A 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9913                                  		; 01/03/2023
  9914                                  		;je	short ISPIPE1	; Yes
  9915                                  		;;cmp	al,[cs:VBAR]
  9916                                  		;cmp	al,vbar  ; '|'
  9917                                  		; 01/03/2023
  9918                                  		;je	short ISPIPE1
  9919                                  		;jmp	PIPEEND		; Pipe done
  9920 00001F6C 757A                    		jne	short PIPEEND
  9921                                  ISPIPE1:
  9922 00001F6E 8B16E90C                		mov	dx,[INPIPEPTR] ; Get the input file name
  9923 00001F72 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9924 00001F75 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9925                                  				; DS:DX	-> ASCIZ filename
  9926                                  				; AL = access mode
  9927                                  				; 0 - read
  9928                                  PIPEERRJ:
  9929 00001F77 7303                    		jnc	short NO_PIPEERR
  9930 00001F79 E970FF                  		jmp	PIPERR		; Lost the pipe file
  9931                                  NO_PIPEERR:
  9932 00001F7C 89C3                    		mov	bx,ax
  9933 00001F7E B0FF                    		mov	al,0FFh
  9934                                  		;xchg	al,[bx+18h]
  9935 00001F80 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9936 00001F83 A21800                  		mov	[PDB.JFN_TABLE],al ; Redirect
  9937                                  FIRSTPIPE:
  9938 00001F86 BF[B73F]                		mov	di,COMBUF+2
  9939 00001F89 31C9                    		xor	cx,cx
  9940 00001F8B 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9941 00001F8E 7503                    		jne	short PIPEOK1
  9942                                  PIPEERRSYNJ:
  9943 00001F90 E94EFF                  		jmp	PIPEERRSYN
  9944                                  PIPEOK1:
  9945                                  		; 01/03/2023
  9946                                  		;;mov	al,[cs:VBAR]
  9947                                  		;mov	al,vbar ; '|'
  9948                                  		;cmp	[si],al		; '||'
  9949                                  		;je	short PIPEERRSYNJ
  9950                                  		;cmp	byte [si],'|'
  9951 00001F93 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9952 00001F96 74F8                    		je	short PIPEERRSYNJ
  9953                                  PIPECOMLP:
  9954 00001F98 AC                      		lodsb
  9955 00001F99 AA                      		stosb
  9956 00001F9A 3C0D                    		cmp	al,0Dh
  9957 00001F9C 7438                    		je	short LASTPIPE
  9958 00001F9E 41                      		inc	cx
  9959                                  		;cmp	al,'|'
  9960 00001F9F 3C7C                    		cmp	al,ALTPIPECHR
  9961                                  		; 01/03/2023
  9962                                  		;je	short ISPIPE2
  9963                                  		;;cmp	al,[cs:VBAR]
  9964                                  		;cmp	al,vbar ; '|'
  9965 00001FA1 75F5                    		jne	short PIPECOMLP
  9966                                  ISPIPE2:
  9967 00001FA3 26C645FF0D              		mov	byte [es:di-1],0Dh
  9968 00001FA8 49                      		dec	cx
  9969 00001FA9 2E880E[B63F]            		mov	[cs:COMBUF+1],cl
  9970 00001FAE 4E                      		dec	si
  9971 00001FAF 8936660C                		mov	[PIPEPTR],si	; On to next pipe element
  9972 00001FB3 8B16EB0C                		mov	dx,[OUTPIPEPTR]
  9973 00001FB7 51                      		push	cx
  9974 00001FB8 31C9                    		xor	cx,cx
  9975 00001FBA B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9976 00001FBD CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9977                                  				; CX = attributes for file
  9978                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9979 00001FBF 59                      		pop	cx
  9980 00001FC0 72B5                    		jc	short PIPEERRJ		; Lost the file
  9981 00001FC2 89C3                    		mov	bx,ax
  9982 00001FC4 B0FF                    		mov	al,0FFh
  9983                                  		;xchg	al,[bx+18h]
  9984 00001FC6 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9985 00001FC9 A21900                  		mov	[PDB.JFN_TABLE+1],al
  9986 00001FCC 8716E90C                		xchg	dx,[INPIPEPTR]	; Swap for next element of pipe
  9987 00001FD0 8916EB0C                		mov	[OUTPIPEPTR],dx
  9988 00001FD4 EB0D                    		jmp	short PIPECOM
  9989                                  LASTPIPE:
  9990 00001FD6 2E880E[B63F]            		mov	[cs:COMBUF+1],cl 
  9991 00001FDB 4E                      		dec	si
  9992 00001FDC 8936660C                		mov	[PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9993 00001FE0 E83FFE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9994                                  PIPECOM:
  9995 00001FE3 0E                      		push	cs
  9996 00001FE4 1F                      		pop	ds
  9997 00001FE5 E9D0E2                  		jmp	NOPIPEPROC	; Process the pipe element
  9998                                  PIPEEND:
  9999 00001FE8 E8D6FE                  		call	PIPEDEL
 10000 00001FEB 813EDD0B00F0            		cmp	word [SINGLECOM],0F000h
 10001 00001FF1 7506                    		jnz	short NOSINGP2
 10002 00001FF3 C706DD0BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
 10003                                  NOSINGP2:
 10004 00001FF9 E908E1                  		jmp	TCOMMAND
 10005                                  
 10006                                  ; =============== S U B	R O U T	I N E =======================================
 10007                                  
 10008                                  ; Date and time are set during initialization and use
 10009                                  ; this routines since they need to do a long return
 10010                                  
 10011                                  DATINIT:
 10012 00001FFC 2E8C1E[5641]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 10013 00002001 06                      		push	es
 10014 00002002 1E                      		push	ds		; Going to use the previous stack
 10015 00002003 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
 10016 00002005 8EC0                    		mov	es,ax
 10017 00002007 8ED8                    		mov	ds,ax
 10018                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 10019 00002009 BA[DE4B]                		mov	dx,INTERNATVARS
 10020 0000200C B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
 10021 0000200F CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10022                                  				; get current-country info
 10023                                  				; DS:DX	-> buffer for returned info
 10024                                  		; 20/10/2018
 10025 00002011 C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
 10026 00002017 C606[B53F]80            		mov	byte [COMBUF],128 ; Init COMBUF
 10027 0000201C C706[B63F]010D          		mov	word [COMBUF+1],0D01h
 10028 00002022 E86500                  		call	DATE
 10029 00002025 E87301                  		call	CTIME
 10030 00002028 1F                      		pop	ds
 10031 00002029 07                      		pop	es
 10032 0000202A CB                      		retf
 10033                                  
 10034                                  ; =============== S U B	R O U T	I N E =======================================
 10035                                  
 10036                                  ; MSDOS 6.0
 10037                                  
 10038                                  ; ****************************************************************
 10039                                  ; *
 10040                                  ; * ROUTINE:	 DATE - Set system date
 10041                                  ; *
 10042                                  ; * FUNCTION:	 If a date is specified, set the system date,
 10043                                  ; *		 otherwise display the current system date and
 10044                                  ; *		 prompt the user for a new date.  If an invalid
 10045                                  ; *		 date is specified, issue an error message and
 10046                                  ; *		 prompt for a new date.  If the user enters
 10047                                  ; *		 nothing when prompted for a date, terminate.
 10048                                  ; *
 10049                                  ; * INPUT:	 command line at offset 81H
 10050                                  ; *
 10051                                  ; * OUTPUT:	 none
 10052                                  ; *
 10053                                  ; ****************************************************************
 10054                                  
 10055                                  ;assume	ds:trangroup,es:trangroup
 10056                                  ;
 10057                                  ;DATE:
 10058                                  ;	MOV	SI,81H				; Accepting argument for date inline
 10059                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get address of PARSE_DATE
 10060                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10061                                  ;	xor	dx,dx				;AN000;
 10062                                  ;	invoke	cmd_parse			;AC000; call parser
 10063                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10064                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
 10065                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10066                                  ;	jne	daterr				;AN000; yes - go issue message
 10067                                  ;	JMP	short COMDAT			;AC000; we have a date
 10068                                  ;
 10069                                  ;PRMTDAT:
 10070                                  ;	; Print "Current date is
 10071                                  ;
 10072                                  ;	invoke	GetDate 			;AN000; get date  for output
 10073                                  ;	xchg	dh,dl				;AN000; switch month & day
 10074                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
 10075                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
 10076                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
 10077                                  ;	invoke	std_printf
 10078                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
 10079                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
 10080                                  ;
 10081                                  ;GET_NEW_DATE:					;AN000;
 10082                                  ;	call	getdat				;AC000; prompt user for date
 10083                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10084                                  ;	jz	date_end			;AC000; yes - exit
 10085                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10086                                  ;	jne	daterr				;AN000; yes - go issue message
 10087                                  ;COMDAT:
 10088                                  ;	mov	cx,date_year			;AC000; get parts of date in
 10089                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
 10090                                  ;	mov	dl,date_day			;AC000;    date function call.
 10091                                  ;	push	cx				;AC000; save date
 10092                                  ;	push	dx				;AC000;
 10093                                  ;	mov	cx,1				;AC000; set 1 positional entered
 10094                                  ;	xor	dx,dx				;AN029;
 10095                                  ;	invoke	cmd_parse			;AN029; call parser
 10096                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10097                                  ;	pop	dx				;AC000; retrieve date
 10098                                  ;	pop	cx				;AC000;
 10099                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
 10100                                  ;	MOV	AH,SET_DATE			;yes - set date
 10101                                  ;	INT	21h
 10102                                  ;	OR	AL,AL
 10103                                  ;	JNZ	DATERR
 10104                                  ;date_end:
 10105                                  ;	ret
 10106                                  ;
 10107                                  ;DATERR:
 10108                                  ;	invoke	crlf2				;AN028; print out a blank line
 10109                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
 10110                                  ;	invoke	std_printf
 10111                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
 10112                                  
 10113                                  ; =============== S U B	R O U T	I N E =======================================
 10114                                  
 10115                                  ; MSDOS 6.0
 10116                                  
 10117                                  ; TIME gets and sets the time
 10118                                  
 10119                                  ; ****************************************************************
 10120                                  ; *
 10121                                  ; * ROUTINE:	 TIME - Set system time
 10122                                  ; *
 10123                                  ; * FUNCTION:	 If a time is specified, set the system time,
 10124                                  ; *		 otherwise display the current system time and
 10125                                  ; *		 prompt the user for a new time.  If an invalid
 10126                                  ; *		 time is specified, issue an error message and
 10127                                  ; *		 prompt for a new time.  If the user enters
 10128                                  ; *		 nothing when prompted for a time, terminate.
 10129                                  ; *
 10130                                  ; * INPUT:	 command line at offset 81H
 10131                                  ; *
 10132                                  ; * OUTPUT:	 none
 10133                                  ; *
 10134                                  ; ****************************************************************
 10135                                  
 10136                                  ;assume	ds:trangroup,es:trangroup
 10137                                  ;
 10138                                  ;CTIME:
 10139                                  ;	MOV	SI,81H				; Accepting argument for time inline
 10140                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get address of PARSE_time
 10141                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10142                                  ;	xor	dx,dx				;AN000;
 10143                                  ;	invoke	cmd_parse			;AC000; call parser
 10144                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10145                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
 10146                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10147                                  ;	jne	timerr				;AN000; yes - go issue message
 10148                                  ;	JMP	short COMTIM			;AC000; we have a time
 10149                                  ;
 10150                                  ;PRMTTIM:
 10151                                  ;	;Printf "Current time is ... "
 10152                                  ;
 10153                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10154                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10155                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10156                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10157                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10158                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10159                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10160                                  ;	invoke	std_printf
 10161                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10162                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10163                                  ;
 10164                                  ;GET_NEW_TIME:
 10165                                  ;	call	gettim				;AC000;
 10166                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10167                                  ;	jz	time_end			;AC000;
 10168                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10169                                  ;	jne	timerr				;AN000; yes - go issue message
 10170                                  ;
 10171                                  ;COMTIM:
 10172                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10173                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10174                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10175                                  ;	mov	dl,time_fraction		;AC000;
 10176                                  ;	push	cx				;AC000; save time
 10177                                  ;	push	dx				;AC000;
 10178                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10179                                  ;	xor	dx,dx				;AN029;
 10180                                  ;	invoke	cmd_parse			;AN029; call parser
 10181                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10182                                  ;	pop	dx				;AC000; retieve time
 10183                                  ;	pop	cx				;AC000;
 10184                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10185                                  ;
 10186                                  ;SAVTIM:
 10187                                  ;	MOV	AH,SET_TIME
 10188                                  ;	INT	21h
 10189                                  ;	OR	AL,AL
 10190                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10191                                  ;
 10192                                  ;TIME_END:
 10193                                  ;
 10194                                  ;	ret
 10195                                  ;
 10196                                  ;TIMERR:
 10197                                  ;	invoke	crlf2				;AN028; print out a blank line
 10198                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10199                                  ;	invoke	std_printf			; Print error message
 10200                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10201                                  
 10202                                  ; =============== S U B	R O U T	I N E =======================================
 10203                                  
 10204                                  ; MSDOS 6.0
 10205                                  
 10206                                  ;
 10207                                  ; Set the special flag in the INIT flag to the value in CX.
 10208                                  ;
 10209                                  
 10210                                  ;SetInitFlag:
 10211                                  ;	mov	ds,[RESSEG]
 10212                                  ;assume ds:resgroup
 10213                                  ;	and	InitFlag,NOT initSpecial
 10214                                  ;	or	InitFlag,cL
 10215                                  ;	push	cs
 10216                                  ;	pop	ds
 10217                                  ;	return
 10218                                  ;
 10219                                  ;Public	PipeOff
 10220                                  ;PipeOff:
 10221                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10222                                  ;	SaveReg <DS,AX>
 10223                                  ;	MOV	DS,ResSeg
 10224                                  ;	ASSUME	DS:RESGroup
 10225                                  ;	XOR	AL,AL
 10226                                  ;	XCHG	PipeFlag,AL
 10227                                  ;	OR	AL,AL
 10228                                  ;	JZ	PipeOffDone
 10229                                  ;	SHR	EchoFlag,1
 10230                                  ;PipeOffDone:
 10231                                  ;	RestoreReg  <AX,DS>
 10232                                  ;	return
 10233                                  
 10234                                  ; =============== S U B	R O U T	I N E =======================================
 10235                                  
 10236                                  ; MSDOS 6.0
 10237                                  
 10238                                  ;PRINT_TIME:
 10239                                  ;
 10240                                  ;	MOV	AH,GET_TIME
 10241                                  ;	INT	21h			; Get time in CX:DX
 10242                                  ;
 10243                                  ;	PUSH	ES
 10244                                  ;	PUSH	CS
 10245                                  ;	POP	ES
 10246                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10247                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10248                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10249                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10250                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10251                                  ;	invoke	std_printf
 10252                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10253                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10254                                  ;
 10255                                  ;	POP	ES
 10256                                  ;	return
 10257                                  
 10258                                  ; =============== S U B	R O U T	I N E =======================================
 10259                                  
 10260                                  ; MSDOS 6.0
 10261                                  
 10262                                  ; ****************************************************************
 10263                                  ; *
 10264                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10265                                  ; *
 10266                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10267                                  ; *		 INFORMATION and issues the "Enter new date"
 10268                                  ; *		 message with the proper date format.  COMBUF
 10269                                  ; *		 is reset to get a date from the command line.
 10270                                  ; *		 The PARSE_DATE blocks are then reset and the
 10271                                  ; *		 PARSE function call is issued.
 10272                                  ; *
 10273                                  ; * INPUT:	 NONE
 10274                                  ; *
 10275                                  ; * OUTPUT:	 COMBUF
 10276                                  ; *		 PARSER RETURN CODES
 10277                                  ; *
 10278                                  ; ****************************************************************
 10279                                  
 10280                                  ;GETDAT	proc	near				;AC000;
 10281                                  ;
 10282                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10283                                  ;	mov	dx,5ch				;  should be entered in and
 10284                                  ;	int	21h			;  print a message describing it
 10285                                  ;	mov	si,dx
 10286                                  ;	lodsw
 10287                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10288                                  ;	dec	ax
 10289                                  ;	js	printformat
 10290                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10291                                  ;	jz	printformat
 10292                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10293                                  ;printformat:
 10294                                  ;	mov	ax,dx				;AN000; get message number of format
 10295                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10296                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10297                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10298                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10299                                  ;	invoke	std_printf
 10300                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10301                                  ;
 10302                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10303                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10304                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10305                                  ;	call	SetInitFlag			;  prompting for date.
 10306                                  ;	INT	21h			; Get input line
 10307                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10308                                  ;	call	SetInitFlag			;  prompting for date.
 10309                                  ;	invoke	CRLF2
 10310                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10311                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get address of PARSE_DATE
 10312                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10313                                  ;	xor	dx,dx				;AN000;
 10314                                  ;	invoke	cmd_parse			;AC000; call parser
 10315                                  ;
 10316                                  ;	ret
 10317                                  ;
 10318                                  ;GETDAT	endp					;AC000;
 10319                                  
 10320                                  ; =============== S U B	R O U T	I N E =======================================
 10321                                  
 10322                                  ; MSDOS 6.0
 10323                                  
 10324                                  ; ****************************************************************
 10325                                  ; *
 10326                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10327                                  ; *
 10328                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10329                                  ; *		 INFORMATION and issues the "Enter new time"
 10330                                  ; *		 message. COMBUF is reset to get a time from the
 10331                                  ; *		 command line.	The PARSE_TIME blocks are then
 10332                                  ; *		 reset and the PARSE function call is issued.
 10333                                  ; *
 10334                                  ; * INPUT:	 NONE
 10335                                  ; *
 10336                                  ; * OUTPUT:	 COMBUF
 10337                                  ; *		 PARSER RETURN CODES
 10338                                  ; *
 10339                                  ; ****************************************************************
 10340                                  
 10341                                  ;GETTIM	proc	near				;AC000;
 10342                                  ;
 10343                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10344                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10345                                  ;	invoke	std_printf
 10346                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10347                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10348                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10349                                  ;	call	SetInitFlag			;  prompting for time.
 10350                                  ;	INT	21h			; Get input line
 10351                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10352                                  ;	call	SetInitFlag			;  prompting for time.
 10353                                  ;	invoke	CRLF2
 10354                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10355                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get address of PARSE_TIME
 10356                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10357                                  ;	xor	dx,dx				;AN000;
 10358                                  ;	invoke	cmd_parse			;AC000; call parser
 10359                                  ;
 10360                                  ;	ret
 10361                                  ;
 10362                                  ;GETTIM	endp					;AC000;
 10363                                  
 10364                                  ; =============== S U B	R O U T	I N E =======================================
 10365                                  
 10366                                  ; MSDOS 6.0
 10367                                  
 10368                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10369                                  ;the '=' sign in the environment variable before the actual path.
 10370                                  ;
 10371                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10372                                  ;
 10373                                  ;	EXIT:	ds:si = start of the path
 10374                                  ;
 10375                                  ;	REGISTERS AFFECTED: ax
 10376                                  ;
 10377                                  
 10378                                  ;Skip_white	proc	near
 10379                                  ;
 10380                                  ;	cld
 10381                                  ;skw_lp:
 10382                                  ;	lodsb
 10383                                  ;	cmp	al,' '				;blank char?
 10384                                  ;	jz	skw_lp				;yes, skip it
 10385                                  ;	cmp	al,09				;tab char?
 10386                                  ;	jz	skw_lp				;yes, skip it
 10387                                  ;
 10388                                  ;	dec	si				;point at first non-white
 10389                                  ;
 10390                                  ;	ret
 10391                                  ;
 10392                                  ;Skip_white	endp
 10393                                  
 10394                                  ; =============== S U B	R O U T	I N E =======================================
 10395                                  
 10396                                  ; MSDOS 6.0
 10397                                  
 10398                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10399                                  ;variable into the path buffers Pipe1 & Pipe2.
 10400                                  ;
 10401                                  ;	ENTRY:	ds:si = path to be copied
 10402                                  ;		es = RESGROUP
 10403                                  ;
 10404                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10405                                  ;
 10406                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10407                                  ;
 10408                                  
 10409                                  ;Copy_pipe_path	proc	near
 10410                                  ;
 10411                                  ;	mov	cx,0ffffh
 10412                                  ;	xor	al,al
 10413                                  ;
 10414                                  ;	mov	di,si
 10415                                  ;	push	es			;save es
 10416                                  ;	push	ds
 10417                                  ;	pop	es			;es:di = path to be copied
 10418                                  ;	
 10419                                  ;	cld
 10420                                  ;	push	di
 10421                                  ;	repnz	scasb			;look for the null char
 10422                                  ;	pop	di
 10423                                  ;
 10424                                  ;	pop	es			;es = RESGROUP again
 10425                                  ;
 10426                                  ;	not	cx			;length including the null
 10427                                  ;
 10428                                  ;	mov	di,offset DATARES:Pipe1	
 10429                                  ;	push	di
 10430                                  ;	push	cx			
 10431                                  ;	rep	movsb			;copy path into Pipe1
 10432                                  ;	pop	cx
 10433                                  ;	pop	di
 10434                                  ;
 10435                                  ;	push	ds
 10436                                  ;	push	es
 10437                                  ;	pop	ds			;ds:si = Pipe1
 10438                                  ;	mov	si,di
 10439                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10440                                  ;	rep	movsb			;copy path into Pipe2
 10441                                  ;	pop	ds
 10442                                  ;
 10443                                  ;	ret				;
 10444                                  ;
 10445                                  ;Copy_pipe_path	endp
 10446                                  
 10447                                  ;============================================================================
 10448                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10449                                  ;============================================================================
 10450                                  ; 05/10/2018 - Retro DOS v3.0
 10451                                  
 10452                                  ; DATE - Gets and sets the time
 10453                                  
 10454                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10455                                  
 10456                                  ; =============== S U B	R O U T	I N E =======================================
 10457                                  
 10458                                  DATE_CXDX:
 10459 0000202B 89CB                    		mov	bx,cx
 10460                                  
 10461                                  ; =============== S U B	R O U T	I N E =======================================
 10462                                  
 10463                                  P_DATE:
 10464 0000202D 89D8                    		mov	ax,bx
 10465 0000202F 89D1                    		mov	cx,dx
 10466 00002031 B264                    		mov	dl,100
 10467 00002033 F6F2                    		div	dl
 10468 00002035 86C4                    		xchg	al,ah
 10469 00002037 92                      		xchg	ax,dx
 10470 00002038 B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10471                                  		;mov	ax,[INTERNATVARS]
 10472 0000203A A1[DE4B]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10473 0000203D 09C0                    		or	ax,ax
 10474 0000203F 7413                    		jz	short USPDAT
 10475 00002041 48                      		dec	ax
 10476 00002042 741E                    		jz	short EUPDAT
 10477 00002044 B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10478 00002046 E83300                  		call	P_YR
 10479 00002049 E82600                  		call	P_DSEP
 10480 0000204C E81E00                  		call	P_MON
 10481 0000204F E82000                  		call	P_DSEP
 10482                                  		;call	P_DAY
 10483                                  		;retn
 10484                                  		; 02/03/2023
 10485 00002052 EB23                    		jmp	short P_DAY
 10486                                  USPDAT:
 10487 00002054 E81600                  		call	P_MON
 10488 00002057 E81800                  		call	P_DSEP
 10489 0000205A E81A00                  		call	P_DAY
 10490                                  PLST:
 10491 0000205D E81200                  		call	P_DSEP
 10492                                  		;call	P_YR
 10493                                  		;retn
 10494                                  		; 02/03/2023
 10495 00002060 EB1A                    		jmp	short P_YR
 10496                                  EUPDAT:
 10497 00002062 E81200                  		call	P_DAY
 10498 00002065 E80A00                  		call	P_DSEP
 10499 00002068 E80200                  		call	P_MON
 10500 0000206B EBF0                    		jmp	short PLST
 10501                                  
 10502                                  ; ---------------------------------------------------------------------------
 10503                                  
 10504                                  P_MON:
 10505 0000206D 88E8                    		mov	al,ch
 10506                                  		;call	OUT2
 10507                                  		;retn
 10508                                  		; 02/03/2023
 10509 0000206F E97902                  		jmp	OUT2
 10510                                  
 10511                                  ; ---------------------------------------------------------------------------
 10512                                  
 10513                                  P_DSEP:
 10514                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10515 00002072 A0[E94B]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10516 00002075 AA                      		stosb
 10517                                  DATE_RETN:	; 02/03/2023
 10518 00002076 C3                      		retn
 10519                                  
 10520                                  ; ---------------------------------------------------------------------------
 10521                                  
 10522                                  P_DAY:
 10523 00002077 88C8                    		mov	al,cl
 10524                                  		;call	OUT2
 10525                                  		;retn
 10526                                  		; 02/03/2023
 10527 00002079 E96F02                  		jmp	OUT2
 10528                                  
 10529                                  ; ---------------------------------------------------------------------------
 10530                                  
 10531                                  P_YR:
 10532 0000207C 88F0                    		mov	al,dh
 10533 0000207E 08C0                    		or	al,al
 10534 00002080 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10535 00002082 E86602                  		call	OUT2
 10536                                  TWODIGYR:
 10537 00002085 88D0                    		mov	al,dl
 10538                                  		;call	OUT2
 10539                                  		; 02/03/2023
 10540 00002087 E96102                  		jmp	OUT2
 10541                                  ;DATE_RETN:
 10542                                  		;retn
 10543                                  
 10544                                  ; =============== S U B	R O U T	I N E =======================================
 10545                                  
 10546                                  DATE:				 	; Accepting argument for date inline
 10547 0000208A BE8100                  		mov	si,81h
 10548 0000208D E8B2F8                  		call	SCANOFF
 10549 00002090 3C0D                    		cmp	al,0Dh
 10550                                  		;jz	short PRMTDAT
 10551                                  		;jmp	short COMDAT
 10552                                  		; 02/03/2023
 10553 00002092 7548                    		jnz	short COMDAT
 10554                                  
 10555                                  		;nop
 10556                                  PRMTDAT:
 10557                                  		; MSDOS 3.3
 10558 00002094 BA[6B39]                		mov	dx,CURDATPTR
 10559 00002097 E87A13                  		call	STD_PRINTF	; Print "Current date is "	
 10560 0000209A E86908                  		call	PRINT_DATE
 10561                                  GETDAT:	
 10562 0000209D BA[7F39]                		mov	dx,NEWDATPTR
 10563 000020A0 E87113                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10564                                  
 10565 000020A3 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10566                                  					; Determine what format the date
 10567 000020A6 BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10568 000020A9 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10569                                  				; get current-country info
 10570                                  				; DS:DX	-> buffer for returned info
 10571 000020AB 89D6                    		mov	si,dx		;  print a message describing it
 10572 000020AD AD                      		lodsw
 10573 000020AE BA[8E39]                		mov	dx,USADATPTR	; get mm-dd-yy
 10574 000020B1 48                      		dec	ax
 10575 000020B2 7808                    		js	short PRINTFORMAT
 10576 000020B4 BA[9D39]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10577 000020B7 7403                    		jz	short PRINTFORMAT
 10578 000020B9 BA[AC39]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10579                                  PRINTFORMAT:
 10580 000020BC E85513                  		call	STD_PRINTF
 10581 000020BF B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10582 000020C1 BA[B53F]                		mov	dx,COMBUF
 10583 000020C4 B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10584 000020C7 E83202                  		call	SETINITFLAG	;  prompting for date.
 10585 000020CA CD21                    		int	21h		; Get input line
 10586 000020CC 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10587 000020CE E82B02                  		call	SETINITFLAG	;  prompting for date.
 10588 000020D1 E861F8                  		call	CRLF2
 10589 000020D4 BE[B73F]                		mov	si,COMBUF+2
 10590 000020D7 803C0D                  		cmp	byte [si],0Dh
 10591 000020DA 749A                    		jz	short DATE_RETN
 10592                                  COMDAT:
 10593                                  		;mov	ax,[INTERNATVARS]
 10594 000020DC A1[DE4B]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10595 000020DF 09C0                    		or	ax,ax
 10596 000020E1 7435                    		jz	short USSDAT
 10597 000020E3 48                      		dec	ax
 10598 000020E4 744B                    		jz	short EUSDAT
 10599 000020E6 E86500                  		call	GET_YR
 10600 000020E9 7235                    		jc	short DATERRJ
 10601 000020EB E89E00                  		call	GET_DSEP
 10602 000020EE 7230                    		jc	short DATERRJ
 10603 000020F0 E84D00                  		call	GET_MON
 10604 000020F3 722B                    		jc	short DATERRJ
 10605 000020F5 E89400                  		call	GET_DSEP
 10606 000020F8 7226                    		jc	short DATERRJ
 10607 000020FA E84B00                  		call	GET_DAY
 10608                                  DAT_SET:
 10609 000020FD 7303                    		jnc	short DATSET
 10610 000020FF E98100                  		jmp	DATERR
 10611                                  
 10612                                  ; ---------------------------------------------------------------------------
 10613                                  
 10614                                  DATSET:
 10615 00002102 AC                      		lodsb
 10616 00002103 3C20                    		cmp	al,' '
 10617 00002105 74FB                    		jz	short DATSET
 10618 00002107 3C09                    		cmp	al,9
 10619 00002109 74F7                    		jz	short DATSET
 10620 0000210B 3C0D                    		cmp	al,0Dh
 10621 0000210D 7574                    		jnz	short DATERR
 10622 0000210F B42B                    		mov	ah,SET_DATE ; 2Bh
 10623 00002111 CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10624                                  				; DL = day,DH = month,	CX = year
 10625                                  				; Return: AL = 00h if no error 
 10626                                  				; 	     = FFh if bad value sent to routine
 10627 00002113 08C0                    		or	al,al
 10628 00002115 756C                    		jnz	short DATERR
 10629                                  DAT_SET_RETN:
 10630 00002117 C3                      		retn
 10631                                  
 10632                                  ; ---------------------------------------------------------------------------
 10633                                  
 10634                                  USSDAT:
 10635 00002118 E82500                  		call	GET_MON
 10636 0000211B 7266                    		jb	short DATERR
 10637 0000211D E86C00                  		call	GET_DSEP
 10638                                  DATERRJ:
 10639 00002120 7261                    		jc	short DATERR
 10640 00002122 E82300                  		call	GET_DAY
 10641                                  TGET:
 10642 00002125 725C                    		jc	short DATERR
 10643 00002127 E86200                  		call	GET_DSEP
 10644 0000212A 7257                    		jc	short DATERR
 10645 0000212C E81F00                  		call	GET_YR
 10646 0000212F EBCC                    		jmp	short DAT_SET
 10647                                  
 10648                                  ; ---------------------------------------------------------------------------
 10649                                  
 10650                                  EUSDAT:
 10651 00002131 E81400                  		call	GET_DAY
 10652 00002134 724D                    		jc	short DATERR
 10653 00002136 E85300                  		call	GET_DSEP
 10654 00002139 7248                    		jc	short DATERR
 10655 0000213B E80200                  		call	GET_MON
 10656 0000213E EBE5                    		jmp	short TGET
 10657                                  
 10658                                  ; =============== S U B	R O U T	I N E =======================================
 10659                                  
 10660                                  GET_MON:
 10661 00002140 E88801                  		call	GETNUM		; Get one or two digit number
 10662 00002143 72D2                    		jc	short DAT_SET_RETN
 10663 00002145 88E6                    		mov	dh,ah		; Put in position
 10664 00002147 C3                      		retn
 10665                                  
 10666                                  
 10667                                  ; =============== S U B	R O U T	I N E =======================================
 10668                                  
 10669                                  GET_DAY:
 10670 00002148 E88001                  		call	GETNUM
 10671 0000214B 88E2                    		mov	dl,ah		; Put in position
 10672                                  GET_DAY_RETN:
 10673 0000214D C3                      		retn
 10674                                  
 10675                                  ; =============== S U B	R O U T	I N E =======================================
 10676                                  
 10677                                  GET_YR:
 10678 0000214E E87A01                  		call	GETNUM
 10679 00002151 72FA                    		jc	short GET_DAY_RETN
 10680 00002153 B96C07                  		mov	cx,1900
 10681 00002156 E83300                  		call	GET_DSEP
 10682 00002159 9C                      		pushf
 10683 0000215A 4E                      		dec	si
 10684 0000215B 9D                      		popf
 10685 0000215C 741E                    		jz	short BIAS
 10686 0000215E 803C0D                  		cmp	byte [si],0Dh
 10687 00002161 7419                    		je	short BIAS
 10688 00002163 803C20                  		cmp	byte [si],' '
 10689 00002166 7414                    		je	short BIAS
 10690 00002168 803C09                  		cmp	byte [si],9
 10691 0000216B 740F                    		je	short BIAS
 10692 0000216D 53                      		push	bx
 10693 0000216E B364                    		mov	bl,100
 10694 00002170 88E0                    		mov	al,ah
 10695 00002172 F6E3                    		mul	bl
 10696 00002174 5B                      		pop	bx
 10697 00002175 89C1                    		mov	cx,ax
 10698 00002177 E85101                  		call	GETNUM
 10699 0000217A 72D1                    		jc	short GET_DAY_RETN
 10700                                  BIAS:
 10701 0000217C 88E0                    		mov	al,ah
 10702 0000217E B400                    		mov	ah,0
 10703 00002180 01C1                    		add	cx,ax
 10704                                  BIAS_RETN:
 10705 00002182 C3                      		retn
 10706                                  
 10707                                  ; ---------------------------------------------------------------------------
 10708                                  
 10709                                  DATERR:
 10710 00002183 BA[5839]                		mov	dx,BADDATPTR
 10711 00002186 E88B12                  		call	STD_PRINTF
 10712 00002189 E911FF                  		jmp	GETDAT
 10713                                  
 10714                                  ; =============== S U B	R O U T	I N E =======================================
 10715                                  
 10716                                  GET_DSEP:
 10717 0000218C AC                      		lodsb
 10718 0000218D 3C2F                    		cmp	al,'/'
 10719 0000218F 74F1                    		je	short BIAS_RETN
 10720                                  		;cmp	al,'.'
 10721                                  		;cmp	al,[DOT_CHR]
 10722                                  		; 01/03/2023
 10723 00002191 3C2E                    		cmp	al,dot_chr ; cmp al,'.'
 10724 00002193 74ED                    		je	short BIAS_RETN
 10725                                  		; 01/03/2023
 10726 00002195 3C2D                    		cmp	al,'-'
 10727                                  		;cmp	al,[CHAR_SUB]
 10728 00002197 74E9                    		je	short BIAS_RETN
 10729 00002199 F9                      		stc
 10730 0000219A C3                      		retn
 10731                                  
 10732                                  ; =============== S U B	R O U T	I N E =======================================
 10733                                  
 10734                                  ; TIME gets and sets the time
 10735                                  
 10736                                  CTIME:
 10737 0000219B BE8100                  		mov	si,81h		; Accepting argument for time inline
 10738 0000219E E8A1F7                  		call	SCANOFF
 10739 000021A1 3C0D                    		cmp	al,0Dh
 10740 000021A3 747C                    		je	short PRMTTIM
 10741 000021A5 BB3A2E                  		mov	bx,2E3Ah ; ":."
 10742 000021A8 E80501                  		call	INLINE
 10743 000021AB E98A00                  		jmp	COMTIM
 10744                                  
 10745                                  ; =============== S U B	R O U T	I N E =======================================
 10746                                  
 10747                                  PRINT_TIME:
 10748 000021AE B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10749 000021B0 CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10750                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10751                                  				; DL = hundredths of seconds
 10752 000021B2 57                      		push	di
 10753 000021B3 06                      		push	es
 10754 000021B4 0E                      		push	cs
 10755 000021B5 07                      		pop	es
 10756 000021B6 BF[8041]                		mov	di,CHARBUF
 10757 000021B9 B301                    		mov	bl,1	; Always 24 hour time
 10758 000021BB E81300                  		call	P_TIME
 10759 000021BE 31C0                    		xor	ax,ax
 10760 000021C0 AA                      		stosb
 10761 000021C1 BA[8041]                		mov	dx,CHARBUF
 10762 000021C4 8916[3343]              		mov	[STRING_PTR_2],dx
 10763 000021C8 BA[4F36]                		mov	dx,STRINGBUF2PTR
 10764 000021CB E84612                  		call	STD_PRINTF
 10765 000021CE 07                      		pop	es
 10766 000021CF 5F                      		pop	di
 10767                                  P_TIME_RETN:
 10768 000021D0 C3                      		retn
 10769                                  
 10770                                  ; =============== S U B	R O U T	I N E =======================================
 10771                                  
 10772                                  P_TIME:
 10773 000021D1 88E8                    		mov	al,ch	
 10774 000021D3 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10775 000021D6 7512                    		jnz	short T24	; 24 hr time?
 10776 000021D8 B761                    		mov	bh,'a'		; Assume A.M.
 10777 000021DA 3C0C                    		cmp	al,12		; In the afternoon?
 10778 000021DC 7206                    		jb	short MORN
 10779 000021DE B770                    		mov	bh,'p'
 10780 000021E0 7402                    		jz	short MORN
 10781 000021E2 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10782                                  MORN:
 10783 000021E4 08C0                    		or	al,al		; Before 1 am?
 10784 000021E6 7502                    		jnz	short T24
 10785 000021E8 B00C                    		mov	al,12
 10786                                  T24:
 10787 000021EA 53                      		push	bx
 10788 000021EB B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10789 000021ED E8FB00                  		call	OUT2
 10790 000021F0 E82900                  		call	P_TSEP
 10791 000021F3 88C8                    		mov	al,cl
 10792 000021F5 E8F300                  		call	OUT2
 10793 000021F8 5B                      		pop	bx
 10794 000021F9 53                      		push	bx
 10795 000021FA F6C380                  		test	bl,80h
 10796 000021FD 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10797 000021FF B700                    		mov	bh,0		; Disable leading zero suppression
 10798 00002201 E81800                  		call	P_TSEP
 10799 00002204 88F0                    		mov	al,dh
 10800 00002206 E8E200                  		call	OUT2
 10801                                  		;mov	al,'.'
 10802 00002209 A0[E74B]                		mov	al,[DECIMAL_SEP]
 10803 0000220C AA                      		stosb
 10804 0000220D 88D0                    		mov	al,dl
 10805 0000220F E8D900                  		call	OUT2
 10806                                  PAP:
 10807 00002212 5B                      		pop	bx
 10808 00002213 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10809 00002216 75B8                    		jnz	short P_TIME_RETN
 10810 00002218 88F8                    		mov	al,bh
 10811 0000221A AA                      		stosb
 10812 0000221B C3                      		retn
 10813                                  
 10814                                  ; =============== S U B	R O U T	I N E =======================================
 10815                                  
 10816                                  P_TSEP:
 10817                                  		;mov	al,[TIME_SEP]
 10818 0000221C A0[EB4B]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10819 0000221F AA                      		stosb
 10820                                  P_TSEP_RETN:
 10821 00002220 C3                      		retn
 10822                                  
 10823                                  ; ---------------------------------------------------------------------------
 10824                                  
 10825                                  PRMTTIM:
 10826 00002221 BA[D139]                		mov	dx,CURTIMPTR
 10827 00002224 E8ED11                  		call	STD_PRINTF	; Print "Current time is "
 10828 00002227 E884FF                  		call	PRINT_TIME
 10829                                  GETTIM:
 10830 0000222A 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10831 0000222C BA[E639]                		mov	dx,NEWTIMPTR
 10832 0000222F E8E211                  		call	STD_PRINTF
 10833                                  		;mov	bx,':.'
 10834                                  		;mov	bx,[TIMECHARS] 
 10835                                  		; 01/03/2023
 10836 00002232 BB3A2E                  		mov	bx,dot_colon ; mov bx,2E3Ah ; mov bx,':.'
 10837 00002235 E85B00                  		call	GETBUF
 10838                                  COMTIM:
 10839 00002238 74E6                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10840 0000223A 724F                    		jc	short TIMEERR
 10841 0000223C 89D1                    		mov	cx,dx
 10842 0000223E 31D2                    		xor	dx,dx
 10843 00002240 AC                      		lodsb
 10844 00002241 3C0D                    		cmp	al,0Dh
 10845 00002243 743E                    		je	short SAVTIM
 10846 00002245 3C20                    		cmp	al,' '
 10847 00002247 742D                    		je	short GOTSEC2
 10848 00002249 3C09                    		cmp	al,9
 10849 0000224B 7429                    		je	short GOTSEC2
 10850 0000224D 38D8                    		cmp	al,bl
 10851 0000224F 7404                    		je	short GOTSEC
 10852 00002251 38F8                    		cmp	al,bh
 10853 00002253 7536                    		jne	short TIMEERR
 10854                                  GOTSEC:
 10855 00002255 E87300                  		call	GETNUM
 10856 00002258 7231                    		jc	short TIMEERR
 10857 0000225A 88E6                    		mov	dh,ah		; Position seconds
 10858 0000225C AC                      		lodsb
 10859 0000225D 3C0D                    		cmp	al,0Dh
 10860 0000225F 7422                    		je	short SAVTIM
 10861 00002261 3C20                    		cmp	al,' '
 10862 00002263 7411                    		je	short GOTSEC2
 10863 00002265 3C09                    		cmp	al,9
 10864 00002267 740D                    		je	short GOTSEC2
 10865                                  		;cmp	al,'.'
 10866 00002269 3A06[E74B]              		cmp	al,[DECIMAL_SEP]
 10867 0000226D 751C                    		jne	short TIMEERR
 10868 0000226F E85900                  		call	GETNUM
 10869 00002272 7217                    		jc	short TIMEERR
 10870 00002274 88E2                    		mov	dl,ah
 10871                                  GOTSEC2:
 10872 00002276 AC                      		lodsb
 10873 00002277 3C20                    		cmp	al,' '
 10874 00002279 74FB                    		je	short GOTSEC2
 10875 0000227B 3C09                    		cmp	al,9
 10876 0000227D 74F7                    		je	short GOTSEC2
 10877 0000227F 3C0D                    		cmp	al,0Dh
 10878 00002281 7508                    		jne	short TIMEERR
 10879                                  SAVTIM:
 10880 00002283 B42D                    		mov	ah,SET_TIME ; 2Dh
 10881 00002285 CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10882                                  				; CH = hours,CL = minutes,DH = seconds,
 10883                                  				;		DL = hundredths of seconds
 10884                                  				; Return: AL = 00h if no error 
 10885                                  				;	     = FFh if bad value sent to routine
 10886 00002287 08C0                    		or	al,al
 10887                                  P_TSEP_JRETN:
 10888 00002289 7495                    		jz	short P_TSEP_RETN ; Error in time?
 10889                                  TIMEERR:
 10890 0000228B BA[BE39]                		mov	dx,BADTIMPTR
 10891 0000228E E88311                  		call	STD_PRINTF	; Print "Enter new time: "
 10892 00002291 EB97                    		jmp	short GETTIM
 10893                                  
 10894                                  ; =============== S U B	R O U T	I N E =======================================
 10895                                  
 10896                                  GETBUF:
 10897 00002293 B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10898 00002295 BA[B53F]                		mov	dx,COMBUF
 10899 00002298 B90200                  		mov	cx,2
 10900 0000229B E85E00                  		call	SETINITFLAG
 10901 0000229E CD21                    		int	21h		; Get input line
 10902 000022A0 31C9                    		xor	cx,cx
 10903 000022A2 E85700                  		call	SETINITFLAG
 10904 000022A5 E88DF6                  		call	CRLF2
 10905 000022A8 BE[B73F]                		mov	si,COMBUF+2
 10906 000022AB 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10907 000022AE 74D9                    		jz	short P_TSEP_JRETN
 10908                                  
 10909                                  ; =============== S U B	R O U T	I N E =======================================
 10910                                  
 10911                                  INLINE:
 10912 000022B0 E81800                  		call	GETNUM		; Get one or two digit number
 10913                                  		;jnb	short INLINE1
 10914                                  		;retn
 10915                                  		; 02/03/2023
 10916 000022B3 7215                    		jb	short INLINE_RETN 
 10917                                  INLINE1:
 10918 000022B5 88E6                    		mov	dh,ah		; Put in position
 10919 000022B7 AC                      		lodsb
 10920 000022B8 38D8                    		cmp	al,bl
 10921 000022BA 7409                    		jz	short NEXT
 10922 000022BC 38F8                    		cmp	al,bh
 10923 000022BE 7405                    		jz	short NEXT
 10924 000022C0 4E                      		dec	si		; Clears zero flag
 10925 000022C1 F8                      		clc
 10926 000022C2 B200                    		mov	dl,0
 10927 000022C4 C3                      		retn			; Time may have only an hour specified
 10928                                  NEXT:
 10929 000022C5 E80300                  		call	GETNUM
 10930 000022C8 88E2                    		mov	dl,ah		; Put in position
 10931                                  INLINE_RETN:
 10932 000022CA C3                      		retn
 10933                                  
 10934                                  ;============================================================================
 10935                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10936                                  ;============================================================================
 10937                                  ; 05/10/2018 - Retro DOS v3.0
 10938                                  
 10939                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10940                                  
 10941                                  ; =============== S U B	R O U T	I N E =======================================
 10942                                  
 10943                                  GETNUM:
 10944 000022CB E81000                  		call	INDIG
 10945 000022CE 72FA                    		jb	short INLINE_RETN
 10946 000022D0 88C4                    		mov	ah,al		; Save first digit
 10947 000022D2 E80900                  		call	INDIG		; Another digit?
 10948 000022D5 7204                    		jb	short OKRET
 10949 000022D7 D50A                    		aad			; Convert unpacked BCD to decimal
 10950 000022D9 88C4                    		mov	ah,al
 10951                                  OKRET:
 10952 000022DB 0C01                    		or	al,1
 10953                                  GETNUM_RETN:
 10954 000022DD C3                      		retn
 10955                                  
 10956                                  ; =============== S U B	R O U T	I N E =======================================
 10957                                  
 10958                                  INDIG:
 10959 000022DE 8A04                    		mov	al,[si]
 10960 000022E0 2C30                    		sub	al,'0'
 10961 000022E2 72F9                    		jc	short GETNUM_RETN
 10962 000022E4 3C0A                    		cmp	al,10
 10963 000022E6 F5                      		cmc
 10964 000022E7 72F4                    		jc	short GETNUM_RETN
 10965 000022E9 46                      		inc	si
 10966 000022EA C3                      		retn
 10967                                  
 10968                                  ; =============== S U B	R O U T	I N E =======================================
 10969                                  
 10970                                  OUT2:					; Output binary number as two ASCII digits
 10971 000022EB D40A                    		aam			; Convert binary to unpacked BCD
 10972 000022ED 86C4                    		xchg	al,ah
 10973 000022EF 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10974 000022F2 3C30                    		cmp	al,'0'		; Is MSD zero?
 10975 000022F4 7502                    		jnz	short NOSUP
 10976 000022F6 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10977                                  NOSUP:
 10978 000022F8 B700                    		mov	bh,0		; Disable zero suppression
 10979 000022FA AB                      		stosw
 10980 000022FB C3                      		retn
 10981                                  
 10982                                  ; ---------------------------------------------------------------------------
 10983                                  		;stosb
 10984                                  		;retn
 10985                                  
 10986                                  ;============================================================================
 10987                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10988                                  ;============================================================================
 10989                                  ; 03/10/2018 - Retro DOS v3.0
 10990                                  
 10991                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10992                                  
 10993                                  ; =============== S U B	R O U T	I N E =======================================
 10994                                  
 10995                                  ; Set the special flag in the INIT flag to the value in CX.
 10996                                  
 10997                                  SETINITFLAG:
 10998 000022FC 8E1E[5641]              		mov	ds,[RESSEG]
 10999                                  		;and	byte [INITFLAG],0FDh
 11000 00002300 8026430CFD              		and	byte [INITFLAG],~INITSPECIAL
 11001 00002305 080E430C                		or	byte [INITFLAG],cl
 11002 00002309 0E                      		push	cs
 11003 0000230A 1F                      		pop	ds
 11004 0000230B C3                      		retn
 11005                                  
 11006                                  ; =============== S U B	R O U T	I N E =======================================
 11007                                  
 11008                                  PIPEOFF:
 11009 0000230C 1E                      		push	ds
 11010 0000230D 50                      		push	ax
 11011 0000230E 2E8E1E[5641]            		mov	ds,[cs:RESSEG]
 11012 00002313 30C0                    		xor	al,al
 11013 00002315 8606440C                		xchg	al,[PIPEFLAG]
 11014 00002319 08C0                    		or	al,al
 11015 0000231B 7404                    		jz	short PIPEOFFDONE
 11016 0000231D D02ED70B                		shr	byte [ECHOFLAG],1
 11017                                  PIPEOFFDONE:
 11018 00002321 58                      		pop	ax
 11019 00002322 1F                      		pop	ds
 11020 00002323 C3                      		retn
 11021                                  
 11022                                  ; ---------------------------------------------------------------------------
 11023                                  		;db    0,0,0,0,0
 11024                                  		;times 5 db 0
 11025                                  
 11026                                  ; 03/03/2023
 11027                                  ;align 16
 11028                                  
 11029                                  ;============================================================================
 11030                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 11031                                  ;============================================================================
 11032                                  ; 03/10/2018 - Retro DOS v3.0
 11033                                  
 11034                                  ;----------------------------------------------------------------------------
 11035                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 11036                                  ; argv[argvcnt] array. The most important difference between this array and
 11037                                  ; the tradition UNIX format is the extra cparse information included with
 11038                                  ; each argument element.
 11039                                  ;---------------
 11040                                  ; ENTRY:
 11041                                  ;	BL	     special delimiter for cparse -- not implemented)
 11042                                  ;---------------
 11043                                  ; EXIT:
 11044                                  ;	CF	    set if error
 11045                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 11046                                  ;	argv[]	    array of cparse flags and pointers to arguments
 11047                                  ;	argvcnt     argument count
 11048                                  ;---------------
 11049                                  ; NOTE(S):
 11050                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 11051                                  ;	*   Parseflags record contains cparse flags, as follows:
 11052                                  ;		sw_flag 	--	was this arg a switch?
 11053                                  ;		wildcard	--	whether or not it contained a * or ?
 11054                                  ;		path_sep	--	maybe it was a pathname
 11055                                  ;		unused		--	for future expansion
 11056                                  ;		special_delim	--	was there an initial special delimiter?
 11057                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 11058                                  ;	*   Relationship between input, cparse output, and comtail can be
 11059                                  ;	    found in the following chart.  Despite the claim of the cparse
 11060                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 11061                                  ;	    tokens", such is not the case (see column two, row two).
 11062                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 11063                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 11064                                  ;	    STARTEL addresses) will be null. This is clearly just a
 11065                                  ;	    documentation error.
 11066                                  ;	*   cparse also returns a switch code in BP for each switch it
 11067                                  ;	    recognizes on the command line.
 11068                                  ;	*   arglen for each token does NOT include the terminating null.
 11069                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 11070                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 11071                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 11072                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 11073                                  ;	    line parsing may result in slightly different behavior than
 11074                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 11075                                  ;
 11076                                  ;	    Input		    Cparse		Command Line (80H)
 11077                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 11078                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 11079                                  ;	foo.bat 		foo.bat 		foo.bat
 11080                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 11081                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 11082                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 11083                                  
 11084                                  ; =============== S U B	R O U T	I N E =======================================
 11085                                  
 11086                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 11087                                  
 11088                                  PARSELINE:
 11089 00002324 50                      		push	ax			; most of these are clobbered
 11090 00002325 53                      		push	bx			; by cparse...
 11091 00002326 51                      		push	cx
 11092 00002327 52                      		push	dx
 11093 00002328 57                      		push	di
 11094 00002329 56                      		push	si
 11095 0000232A 9C                      		pushf
 11096 0000232B C606[3B43]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 11097 00002330 C706[544A]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 11098 00002336 31C0                    		xor	ax,ax
 11099                                  		;mov	cx,1348
 11100 00002338 B94405                  		mov	cx,ARG_UNIT.SIZE
 11101 0000233B BF[8E44]                		mov	di,ARG
 11102 0000233E F3AA                    		rep stosb
 11103                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 11104 00002340 C706[D249][5247]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 11105                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 11106 00002346 C706[5047]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 11107                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 11108 0000234C C706[4E47]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 11109 00002352 BE[B73F]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 11110                                  
 11111                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 11112                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 11113                                  ; otherwise. This is done so that commands can get arg pointers into their
 11114                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 11115                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 11116                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 11117                                  ; the command to be repeated or the transient part of command has been
 11118                                  ; reloaded.
 11119                                  
 11120 00002355 1E                      		push	ds
 11121 00002356 8E1E[5641]              		mov	ds,[RESSEG]
 11122 0000235A 803EE30B00              		cmp	byte [FORFLAG],0
 11123 0000235F 1F                      		pop	ds
 11124 00002360 7510                    		jnz	short PCONT
 11125                                  		;mov	di,ARG_ARGFORCOMBUF
 11126 00002362 BF[5249]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 11127 00002365 30ED                    		xor	ch,ch
 11128 00002367 8A0E[B63F]              		mov	cl,[COMBUF+1]
 11129 0000236B FEC1                    		inc	cl
 11130 0000236D F3A4                    		rep movsb
 11131                                  		;mov	si,ARG_ARGFORCOMBUF
 11132 0000236F BE[5249]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 11133                                  PCONT:
 11134 00002372 BF[D449]                		mov	di,TPBUF	; destination is temporary token buffer	
 11135 00002375 B320                    		mov	bl,' '		; no special delimiter, for now
 11136                                  PARSELOOP:
 11137 00002377 8936[564A]              		mov	[COMPTR],si	; save ptr into original command buffer
 11138 0000237B 31ED                    		xor	bp,bp		; switch information put here by cparse
 11139 0000237D C606[8C44]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 11140 00002382 E8BDF5                  		call	SCANOFF		; skip leading blanks...
 11141 00002385 E8D80E                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 11142 00002388 730B                    		jnb	short MORE_PRSE
 11143 0000238A 09ED                    		or	bp,bp		; Check for trailing switch character
 11144 0000238C 7403                    		jz	short PARSEDONE
 11145 0000238E E81700                  		call	NEWARG		; We hit CR but BP is non-zero. The
 11146                                  					;   typical cause of this is that a
 11147                                  					;   switch char IMMEDIATELY preceeds
 11148                                  					;   the CR. We have an argument, but it
 11149                                  					;   is sort of an error.
 11150                                  		;jmp	short PARSEDONE	; We're done (found the CR).
 11151                                  		; 01/03/2023
 11152                                  PARSEDONE:
 11153 00002391 9D                      		popf
 11154 00002392 F8                      		clc
 11155 00002393 EB0C                    		jmp	short PARSE_EXIT
 11156                                  
 11157                                  MORE_PRSE:
 11158 00002395 C606[3B43]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 11159 0000239A E80B00                  		call	NEWARG		; add to argv array (CX has char count)
 11160 0000239D 73D8                    		jnb	short PARSELOOP	; was everything OK?
 11161                                  		;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 11162                                  		; 01/03/2023
 11163                                  ;PARSEDONE:
 11164                                  		;popf
 11165                                  		;clc
 11166                                  		;jmp	short PARSE_EXIT
 11167                                  
 11168                                  PARSE_ERROR:				; error entry (er, exit) point
 11169 0000239F 9D                      		popf
 11170 000023A0 F9                      		stc
 11171                                  PARSE_EXIT:				; depend on not changing CF
 11172 000023A1 5E                      		pop	si
 11173 000023A2 5F                      		pop	di
 11174 000023A3 5A                      		pop	dx
 11175 000023A4 59                      		pop	cx
 11176 000023A5 5B                      		pop	bx
 11177 000023A6 58                      		pop	ax
 11178 000023A7 C3                      		retn
 11179                                  
 11180                                  ; =============== S U B	R O U T	I N E =======================================
 11181                                  
 11182                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11183                                  ;
 11184                                  ; ENTRY:
 11185                                  ;   BH			argflags
 11186                                  ;   CX			character count in argstring
 11187                                  ;   DI			pointer to argstring
 11188                                  ;   comptr		ptr to starting loc of current token in original command
 11189                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11190                                  ; EXIT:
 11191                                  ;   argbufptr		points to next free section of argbuffer
 11192                                  ;   arg.argbuf		contains null-terminated argument strings
 11193                                  ;   arg.argvcnt 	argument count
 11194                                  ;   arg.argv[]		array of flags and pointers
 11195                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11196                                  ;   CF			set if error
 11197                                  ;   AL			carry set:  error code; otherwise, zero
 11198                                  
 11199                                  NEWARG:
 11200 000023A8 53                      		push	bx
 11201 000023A9 51                      		push	cx
 11202 000023AA 52                      		push	dx
 11203 000023AB 57                      		push	di
 11204 000023AC 56                      		push	si
 11205 000023AD 9C                      		pushf
 11206 000023AE E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11207                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11208                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11209                                  
 11210                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11211 000023B1 833E[4E47]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11212 000023B6 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11213 000023B8 88FE                    		mov	dh,bh			
 11214                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11215 000023BA 8B1E[4E47]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11216                                  		;inc	word [ARG_ARGVCNT]
 11217 000023BE FF06[4E47]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11218                                  		;mov	ax,ARG_ARGV
 11219 000023C2 B8[8E44]                		mov	ax,ARG+ARG_UNIT.argv
 11220 000023C5 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11221                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11222                                  		;mov	word [bx+7],0
 11223 000023C8 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11224                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11225                                  		;mov	[bx+5],cx
 11226 000023CD 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11227                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11228                                  		;mov	[bx+2],dh
 11229 000023D0 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11230 000023D3 8B36[D249]              		mov	si,[ARGBUFPTR]
 11231                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11232                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11233 000023D7 8937                    		mov	[bx],si			
 11234 000023D9 0336[7C44]              		add	si,[STARTEL]		; save startel from new location
 11235 000023DD 29FE                    		sub	si,di			; form pointer into argbuf
 11236                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11237                                  		;mov	[bx+3],si
 11238 000023DF 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11239 000023E2 8B36[564A]              		mov	si,[COMPTR]
 11240                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11241                                  		;mov	[bx+9],si
 11242 000023E6 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11243                                  
 11244 000023E9 89FE                    		mov	si,di			; now save argstring in argbuffer
 11245 000023EB 8B3E[D249]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11246 000023EF 01CF                    		add	di,cx			; sure we're not about to run off
 11247                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11248                                  		;cmp	di,ARG_ARGBUF+255
 11249 000023F1 81FF[5148]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11250 000023F5 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11251 000023F7 29CF                    		sub	di,cx
 11252 000023F9 FC                      		cld
 11253 000023FA F3A4                    		rep movsb
 11254 000023FC B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11255 000023FE AA                      		stosb
 11256 000023FF 893E[D249]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11257                                  
 11258                                  NEWARG_DONE:
 11259 00002403 9D                      		popf
 11260 00002404 F8                      		clc
 11261 00002405 EB0A                    		jmp	short NEWARG_EXIT
 11262                                  
 11263                                  TO_MANY_ARGS:
 11264 00002407 B80100                  		mov	ax,1
 11265 0000240A EB03                    		jmp	short NEWARG_ERROR
 11266                                  
 11267                                  BUF_OVFLOW:
 11268 0000240C B80200                  		mov	ax,2
 11269                                  NEWARG_ERROR:
 11270 0000240F 9D                      		popf
 11271 00002410 F9                      		stc
 11272                                  NEWARG_EXIT:
 11273 00002411 5E                      		pop	si
 11274 00002412 5F                      		pop	di
 11275 00002413 5A                      		pop	dx
 11276 00002414 59                      		pop	cx
 11277 00002415 5B                      		pop	bx
 11278 00002416 C3                      		retn
 11279                                  
 11280                                  ; =============== S U B	R O U T	I N E =======================================
 11281                                  
 11282                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11283                                  ; event that it is, and we can recognize
 11284                                  ;
 11285                                  ; ENTRY:
 11286                                  ;   As in <newarg>.
 11287                                  ; EXIT:
 11288                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11289                                  ; NOTE(S):
 11290                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11291                                  ;	on the order of definition in the <switch_list> variable and the
 11292                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11293                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11294                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11295                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11296                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11297                                  ;   *	An ugly routine.
 11298                                  
 11299                                  ARG_SWITCH:
 11300 00002417 50                      		push	ax
 11301 00002418 53                      		push	bx
 11302 00002419 51                      		push	cx
 11303 0000241A 57                      		push	di
 11304 0000241B 9C                      		pushf
 11305 0000241C F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11306 0000241F 741C                    		jz	short ARG_NO_SWITCH0
 11307 00002421 833E[544A]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11308 00002426 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11309 00002428 8B1E[544A]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11310                                  		;mov	ax,offset TRANGROUP:arg.argv
 11311                                  		;mov	ax,ARG_ARGV
 11312 0000242C B8[8E44]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11313 0000242F E81800                  		call	ARGV_CALC
 11314                                  		;or	[BX].argsw_word,BP
 11315                                  		;or	[bx+7],bp
 11316 00002432 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11317                                  		;or	arg.argswinfo,BP
 11318                                  		;or	[ARG_ARGSWINFO],bp
 11319 00002435 092E[5047]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11320                                  ARG_YES_SWITCH:
 11321 00002439 9D                      		popf
 11322 0000243A F9                      		stc
 11323 0000243B EB08                    		jmp	short ARG_SWITCH_EXIT
 11324                                  
 11325                                  ARG_NO_SWITCH0:
 11326                                  		;mov	ax,[ARG_ARGVCNT]
 11327 0000243D A1[4E47]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11328 00002440 A3[544A]                		mov	[LASTARG],ax
 11329                                  ARG_NO_SWITCH1:
 11330 00002443 9D                      		popf
 11331 00002444 F8                      		clc
 11332                                  ARG_SWITCH_EXIT:
 11333 00002445 5F                      		pop	di
 11334 00002446 59                      		pop	cx
 11335 00002447 5B                      		pop	bx
 11336 00002448 58                      		pop	ax
 11337 00002449 C3                      		retn
 11338                                  
 11339                                  ; =============== S U B	R O U T	I N E =======================================
 11340                                  
 11341                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11342                                  ; the supplied array.  Method used for computing the address is:
 11343                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11344                                  ; ENTRY:
 11345                                  ;   AX	    --	    base of array
 11346                                  ;   BX	    --	    array index
 11347                                  ; EXIT:
 11348                                  ;   BX	    --	    byte offset
 11349                                  
 11350                                  ARGV_CALC:
 11351 0000244A 50                      		push	ax		; Save base
 11352 0000244B 88D8                    		mov	al,bl		; al = array index
 11353                                  		;mov	bl,11
 11354 0000244D B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11355 0000244F F6E3                    		mul	bl		; ax = base offset
 11356 00002451 5B                      		pop	bx		; Get base
 11357 00002452 01D8                    		add	ax,bx		; Add in base offset
 11358 00002454 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11359 00002455 C3                      		retn
 11360                                  
 11361                                  ; ---------------------------------------------------------------------------
 11362                                  	
 11363                                  		;db 0Ah dup(0)
 11364                                  		;times 10 db 0
 11365 00002456 90<rep Ah>              align 16
 11366                                  
 11367                                  ;============================================================================
 11368                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11369                                  ;============================================================================
 11370                                  ; 03/10/2018 - Retro DOS v3.0
 11371                                  
 11372                                  ;----------------------------------------------------------------------------
 11373                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11374                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11375                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11376                                  ;    file on disk. Directories specified in the user's search path will be
 11377                                  ;    searched for a matching file, if a match is not found in the current
 11378                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11379                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11380                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11381                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11382                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11383                                  ;    (easily) modified to make no assumptions about where its input is found.
 11384                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11385                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11386                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11387                                  ;    else that wants to save the whole shebang and then process other command
 11388                                  ;    lines.
 11389                                  ;
 11390                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11391                                  ;
 11392                                  ; ENTRY:
 11393                                  ;   <Path_Search>:	    argv[0].
 11394                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11395                                  ; EXIT:
 11396                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11397                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11398                                  ; NOTE(S):
 11399                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11400                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11401                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11402                                  ;	does not function as specified; see <Parseline> for more details.
 11403                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11404                                  ;	need to know about. This extra information is stored in a switch_flag
 11405                                  ;	word with each command-line argument; the switches themselves will not
 11406                                  ;	appear in the resulting arg structure.
 11407                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11408                                  ;----------------------------------------------------------------------------
 11409                                  
 11410                                  ; =============== S U B	R O U T	I N E =======================================
 11411                                  
 11412                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11413                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11414                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11415                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11416                                  ; have a match, either in the current working directory if we were handed
 11417                                  ; a filename, or in the specified directory, given a pathname. If this call
 11418                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11419                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11420                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11421                                  ; either the first invocation of search or on one of the succeeding calls
 11422                                  ; sets up the appropriate information for copying the successful pathname
 11423                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11424                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11425                                  ;
 11426                                  ; ENTRY:
 11427                                  ;   argv[0]		--	command name and associated information
 11428                                  ; EXIT:
 11429                                  ;   AX			--	non-zero indicates type of file found
 11430                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11431                                  ; NOTE(S):
 11432                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11433                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11434                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11435                                  ;	if search returns an .exe or .bat.
 11436                                  ;   5)	Clobbers dma address.
 11437                                  
 11438                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11439                                  PATH_SEP_CHAR	EQU	';'
 11440                                  
 11441                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11442                                  
 11443                                  		;special_delim equ 128
 11444                                  		;path_sep equ 4
 11445                                  		;wildcard equ 2
 11446                                  		;sw_flag  equ 1
 11447                                  
 11448                                  ;----------------------------------------------------------------------------
 11449                                  
 11450                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11451                                  
 11452                                  PATH_SEARCH:
 11453 00002460 53                      		push	bx
 11454 00002461 51                      		push	cx
 11455 00002462 52                      		push	dx		; could use a "stack 'em" instruction
 11456 00002463 56                      		push	si
 11457 00002464 57                      		push	di
 11458 00002465 55                      		push	bp
 11459 00002466 9C                      		pushf
 11460                                  
 11461                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11462                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11463 00002467 F606[9044]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11464 0000246C 7403                    		jz	short PATH_SEARCH_OK
 11465                                  
 11466                                  PATH_FAILURE_JMP:
 11467 0000246E E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11468                                  
 11469                                  PATH_SEARCH_OK:
 11470 00002471 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11471 00002474 BA[584A]                		mov	dx,FBUF		; clobber old dma value with
 11472 00002477 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11473 0000247A CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11474                                  				; DS:DX	-> disk	transfer buffer
 11475 0000247C 06                      		push	es
 11476 0000247D E8E1F2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11477 00002480 8C06[834A]              		mov	[PATHINFO+0],es	; and squirrel it away
 11478 00002484 893E[854A]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11479 00002488 893E[874A]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11480 0000248C 07                      		pop	es
 11481                                  		
 11482 0000248D BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11483 00002490 BE[7E40]                		mov	si,EXECPATH
 11484 00002493 E84602                  		call	STRIP
 11485 00002496 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11486                                  		
 11487 00002498 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11488 0000249A C706[D84A][5938]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11489 000024A0 E87E01                  		call	PSEARCH		; must do at least one search
 11490 000024A3 09C0                    		or	ax,ax		; find anything?
 11491 000024A5 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11492                                  		
 11493 000024A7 89C5                    		mov	bp,ax		; success... save filetype code	
 11494 000024A9 BF[7E40]                		mov	di,EXECPATH
 11495                                  		;mov	si,ds:arg.argv[0].argpointer
 11496                                  		;mov	si,[ARG_ARGV]
 11497 000024AC 8B36[8E44]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11498                                  		;mov	cx,ds:arg.argv[0].argstartel
 11499                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11500 000024B0 8B0E[9144]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11501 000024B4 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11502                                  
 11503                                  ; We have the number of bytes in the prefix (up to the final component).
 11504                                  ; We need to form the complete pathname including leading drive and current
 11505                                  ; directory.
 11506                                  ;
 11507                                  ; Is there a drive letter present?
 11508                                  
 11509 000024B6 B43A                    		mov	ah,':'
 11510 000024B8 83F902                  		cmp	cx,2		; room for drive letter?
 11511 000024BB 7205                    		jb	short ADDDRIVE	; no, stick it in
 11512 000024BD 386401                  		cmp	[si+1],	ah	; colon present?
 11513 000024C0 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11514                                  ADDDRIVE:
 11515 000024C2 A0[6A41]                		mov	al,[CURDRV]	; get current drive
 11516 000024C5 0441                    		add	al,'A'		; convert to uppercase letter
 11517 000024C7 AB                      		stosw			; store d:
 11518 000024C8 EB05                    		jmp	short CHECKPATH
 11519                                  MOVEDRIVE:
 11520 000024CA AD                      		lodsw			; move d:
 11521 000024CB AB                      		stosw
 11522 000024CC 83E902                  		sub	cx,2		; 2 bytes less to move
 11523                                  CHECKPATH:
 11524 000024CF 0C20                    		or	al,20h
 11525 000024D1 88C2                    		mov	dl,al		
 11526                                  		;sub	dl,60h
 11527 000024D3 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11528                                  
 11529                                  ; Stick in beginning path char
 11530                                  
 11531 000024D6 A0[894A]                		mov	al,[PSEP_CHAR]
 11532 000024D9 AA                      		stosb
 11533                                  
 11534                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11535                                  ; Otherwise, get current dir for DL.
 11536                                  
 11537 000024DA 83F901                  		cmp	cx,1		; is there room for path char?
 11538 000024DD 720A                    		jb	short ADDPATH	; no, go add path
 11539 000024DF AC                      		lodsb
 11540 000024E0 49                      		dec	cx
 11541 000024E1 3A06[894A]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11542 000024E5 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11543 000024E7 41                      		inc	cx
 11544 000024E8 4E                      		dec	si		; undo the lodsb
 11545                                  ADDPATH:
 11546 000024E9 56                      		push	si
 11547 000024EA 89FE                    		mov	si,di		; remainder of buffer
 11548 000024EC B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11549 000024EF CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11550                                  				; DL = drive (0=default,1=A,etc.)
 11551                                  				; DS:SI	points to 64-byte buffer area
 11552                                  
 11553                                  ; The previous current dir will succeed a previous find_first already worked.
 11554                                  ;
 11555                                  ; Find end of string.
 11556                                  
 11557 000024F1 89F7                    		mov	di,si
 11558 000024F3 5E                      		pop	si
 11559 000024F4 A0[894A]                		mov	al,[PSEP_CHAR]
 11560 000024F7 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11561 000024FA 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11562                                  SCANEND:
 11563 000024FC 803D00                  		cmp	byte [di],0	; end of string?
 11564 000024FF 7403                    		jz	short FOUNDEND
 11565 00002501 47                      		inc	di
 11566 00002502 EBF8                    		jmp	short SCANEND
 11567                                  
 11568                                  ; Stick in a trailing path char.
 11569                                  
 11570                                  FOUNDEND:
 11571 00002504 AA                      		stosb
 11572                                  
 11573                                  ; Move remaining part of path.	Skip leading path char if present.
 11574                                  
 11575                                  MOVEPATH:
 11576 00002505 3804                    		cmp	[si],al		; first char a path char?
 11577 00002507 7502                    		jnz	short COPYPATH
 11578 00002509 46                      		inc	si		; move past leading char
 11579 0000250A 49                      		dec	cx		; drop from count
 11580                                  COPYPATH:
 11581 0000250B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11582 0000250D F3A4                    		rep movsb
 11583                                  _COPYDONE:
 11584 0000250F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11585                                  
 11586                                  PATH_NOINIT:
 11587                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11588                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11589 00002512 F606[9044]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11590 00002517 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11591                                  		;mov	bh,';'
 11592 00002519 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11593                                  		;mov	dx,ds:arg.argv[0].argstartel
 11594                                  					; this is where the last element starts
 11595                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11596 0000251B 8B16[9144]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11597                                  		;sub	dx,ds:arg.argv[0].argpointer
 11598                                  					; form pointer into EXECPATH,
 11599                                  		;sub	dx,[ARG_ARGV]
 11600 0000251F 2B16[8E44]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11601 00002523 81C2[7E40]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11602                                  PATH_LOOP:
 11603 00002527 E89500                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11604 0000252A 89C5                    		mov	bp,ax		; save filetype code
 11605 0000252C 9F                      		lahf			; save flags, just in case
 11606 0000252D 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11607 0000252F 7507                    		jnz	short PATH_FOUND 
 11608 00002531 9E                      		sahf			; see?	needed those flags, after all!
 11609 00002532 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11610                                  PATH_FAILURE:
 11611 00002534 31C0                    		xor	ax,ax
 11612 00002536 EB70                    		jmp	short PATH_EXIT
 11613                                  
 11614                                  PATH_FOUND:				; pathinfo[] points to winner
 11615 00002538 BF[7E40]                		mov	di,EXECPATH
 11616                                  		;mov	cx,pathinfo[4] 
 11617 0000253B 8B0E[874A]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11618                                  		;mov	SI,pathinfo[2]
 11619 0000253F 8B36[854A]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11620                                  
 11621                                  ;	BAS Nov 20/84
 11622                                  ;   Look at the pathname and expand . and .. if they are the first element
 11623                                  ;   in the pathname (after the drive letter)
 11624                                  
 11625 00002543 06                      		push	es
 11626                                  		;push	pathinfo[0]
 11627 00002544 FF36[834A]              		push	word [PATHINFO+0]
 11628 00002548 07                      		pop	es
 11629                                  ;SR;
 11630                                  ; Oops! Gets fooled if path= \;..
 11631                                  ; We should also check if a drive letter is really present
 11632                                  ;
 11633 00002549 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11634 0000254E 7534                    		jnz	short PATH_CPY
 11635                                  
 11636                                  		; MSDOS 6.0
 11637                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11638                                  		;jnz	path_cpy	       ;no, copy the path string
 11639                                  
 11640 00002550 51                      		push	cx		; Save pointer to end of string
 11641 00002551 268A04                  		mov	al,[es:si]
 11642 00002554 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11643 00002556 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11644 0000255A 884501                  		mov	[di+1],al
 11645 0000255D A0[894A]                		mov	al,[PSEP_CHAR]
 11646 00002560 884502                  		mov	[di+2],	al
 11647 00002563 56                      		push	si		; Save pointer to begining of string
 11648 00002564 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11649 00002567 80CA20                  		or	dl,20h
 11650                                  		;sub	dl,60h
 11651 0000256A 80EA60                  		sub	dl,'a'-1
 11652 0000256D 89FE                    		mov	si,di		; pointer to EXECPATH
 11653 0000256F 83C603                  		add	si,3		; Don't wipe out drive and root info
 11654 00002572 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11655 00002575 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11656                                  				; DL = drive (0=default,1=A,etc.)
 11657                                  				; DS:SI	points to 64-byte buffer area
 11658 00002577 E8EDF8                  		call	DSTRLEN		; Determine length of present info
 11659 0000257A 01CE                    		add	si,cx		; Don't copy over drive and root info
 11660 0000257C 4E                      		dec	si
 11661 0000257D 89F7                    		mov	di,si		; Point to end of target string
 11662 0000257F 5E                      		pop	si		; Restore pointer to begining of string
 11663 00002580 83C603                  		add	si,3		; Point past drive letter, :, .
 11664 00002583 59                      		pop	cx		; Restore pointer to end of string
 11665                                  PATH_CPY:
 11666 00002584 07                      		pop	es
 11667 00002585 29F1                    		sub	cx,si		; yields character count
 11668 00002587 1E                      		push	ds		; time to switch segments
 11669 00002588 FF36[834A]              		push	word [PATHINFO+0] ; string lives in this segment
 11670 0000258C 1F                      		pop	ds
 11671 0000258D FC                      		cld
 11672 0000258E F3A4                    		rep movsb
 11673 00002590 1F                      		pop	ds		; return to our segment
 11674 00002591 4F                      		dec	di		; overwrite terminator
 11675 00002592 A0[894A]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11676 00002595 3A45FF                  		cmp	al,[di-1]
 11677 00002598 7401                    		jz	short PATH_SUCCESS
 11678 0000259A AA                      		stosb
 11679                                  PATH_SUCCESS:
 11680 0000259B BE[8B4A]                		mov	si,SEARCH_BEST_BUF
 11681 0000259E 31C9                    		xor	cx,cx
 11682                                  PATH_SUCC_LOOP:
 11683 000025A0 AC                      		lodsb			; append winning filename to path
 11684 000025A1 AA                      		stosb			; (including terminating null)	
 11685 000025A2 08C0                    		or	al,al
 11686 000025A4 75FA                    		jnz	short PATH_SUCC_LOOP
 11687 000025A6 89E8                    		mov	ax,bp		; retrieve filetype code
 11688                                  PATH_EXIT:
 11689 000025A8 9D                      		popf
 11690 000025A9 5D                      		pop	bp
 11691 000025AA 5F                      		pop	di
 11692 000025AB 5E                      		pop	si		; chill out...
 11693 000025AC 5A                      		pop	dx
 11694 000025AD 59                      		pop	cx
 11695 000025AE 5B                      		pop	bx
 11696 000025AF C3                      		retn
 11697                                  
 11698                                  
 11699                                  ; =============== S U B	R O U T	I N E =======================================
 11700                                  
 11701                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11702                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11703                                  ;
 11704                                  ; ENTRY:
 11705                                  ; EXIT:
 11706                                  ; NOTE(S):
 11707                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11708                                  
 11709                                  STORE_PCHAR:
 11710 000025B0 50                      		push	ax
 11711 000025B1 B02F                    		mov	al,'/'		; is the pathname-element separator
 11712 000025B3 E81EF4                  		call	PATHCHRCMP	; a regular slash?
 11713 000025B6 7402                    		jz	short STORE_SLASH ; if yes, remember slash
 11714 000025B8 B05C                    		mov	al,'\'
 11715                                  		; 02/03/2023
 11716                                  		;mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11717                                  		;pop	ax
 11718                                  		;retn
 11719                                  STORE_SLASH:
 11720 000025BA A2[894A]                		mov	[PSEP_CHAR],al
 11721 000025BD 58                      		pop	ax
 11722 000025BE C3                      		retn
 11723                                  
 11724                                  ; =============== S U B	R O U T	I N E =======================================
 11725                                  
 11726                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11727                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11728                                  ; additional separator to use for breaking up the path-string. Null is the
 11729                                  ; default. Once the user-string has been formed, search is invoked to see
 11730                                  ; what's out there.
 11731                                  ;
 11732                                  ; ENTRY:
 11733                                  ;   BH			--	additional terminator character
 11734                                  ;   SI			--	pointer into pathstring to be dissected
 11735                                  ;   DX			--	pointer to stripped filename
 11736                                  ; EXIT:
 11737                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11738                                  ;   SI			--	moves along pathstring from call to call
 11739                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11740                                  ;   [tpbuf]		--	clobbered
 11741                                  ; NOTE(S):
 11742                                  ;   *	Implicit in this code is the ability to specify when to search
 11743                                  ;	the current directory (if at all) through the PATH defined by
 11744                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11745                                  ;	current directory before the bin and etc directories of drive c).
 11746                                  
 11747                                  PATH_CRUNCH:
 11748 000025BF 53                      		push	bx
 11749 000025C0 51                      		push	cx
 11750 000025C1 52                      		push	dx
 11751 000025C2 57                      		push	di
 11752 000025C3 56                      		push	si
 11753 000025C4 9C                      		pushf
 11754 000025C5 E8E8FF                  		call	STORE_PCHAR	; figure out pathname separator
 11755 000025C8 BF[D449]                		mov	di,TPBUF	; destination of concatenated string
 11756 000025CB 8B36[874A]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11757 000025CF 8936[854A]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11758 000025D3 1E                      		push	ds		; save old segment pointer
 11759 000025D4 FF36[834A]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11760 000025D8 1F                      		pop	ds		; segment		
 11761                                  PATH_CR_COPY:
 11762 000025D9 AC                      		lodsb			; get a pathname byte
 11763 000025DA 08C0                    		or	al,al		; check for terminator(s)
 11764 000025DC 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11765 000025DE 38F8                    		cmp	al,bh
 11766 000025E0 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11767 000025E2 AA                      		stosb
 11768 000025E3 EBF4                    		jmp	short PATH_CR_COPY
 11769                                  PATH_SEG:
 11770 000025E5 1F                      		pop	ds		; restore old data segment
 11771 000025E6 8936[874A]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11772 000025EA 88C3                    		mov	bl,al		; remember if we saw null or not...
 11773                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11774 000025EC 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11775 000025EE 81FF[D449]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11776 000025F2 741D                    		jz	short PATH_CR_LEAVE 
 11777                                  					; if nothing was copied, pathstr empty
 11778                                  PATH_CR_LOOK:
 11779 000025F4 A0[894A]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11780 000025F7 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11781 000025FA 7401                    		jz	short PATH_CR_L1
 11782 000025FC AA                      		stosb
 11783                                  PATH_CR_L1:
 11784 000025FD 89D6                    		mov	si,dx
 11785                                  PATH_CR_L2:
 11786 000025FF AC                      		lodsb			; tack the stripped filename onto
 11787 00002600 AA                      		stosb			; the end of the path, up to and
 11788 00002601 08C0                    		or	al,al		; including the terminating null
 11789 00002603 75FA                    		jnz	short PATH_CR_L2
 11790 00002605 BA[D449]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11791 00002608 C706[D84A][503B]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11792                                  		;invoke search
 11793 0000260E E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11794                                  PATH_CR_LEAVE:
 11795 00002611 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11796 00002613 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11797 00002615 9D                      		popf			; otherwise, plenty left
 11798 00002616 F8                      		clc
 11799 00002617 EB02                    		jmp	short PATH_CR_EXIT
 11800                                  PATH_CR_EMPTY:
 11801 00002619 9D                      		popf
 11802 0000261A F9                      		stc
 11803                                  PATH_CR_EXIT:
 11804 0000261B 5E                      		pop	si
 11805 0000261C 5F                      		pop	di
 11806 0000261D 5A                      		pop	dx
 11807 0000261E 59                      		pop	cx
 11808 0000261F 5B                      		pop	bx
 11809 00002620 C3                      		retn
 11810                                  
 11811                                  ;============================================================================
 11812                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11813                                  ;============================================================================
 11814                                  ; 02/10/2018 - Retro DOS v3.0
 11815                                  
 11816                                  ;----------------------------------------------------------------------------
 11817                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11818                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11819                                  ; lowest priority). Where conflicts arise, the extension with
 11820                                  ; the highest priority is favored.
 11821                                  ; ENTRY:
 11822                                  ;   DX		--	pointer to null-terminated pathname
 11823                                  ;   fbuf	--	dma buffer for findfirst/next
 11824                                  ; EXIT:
 11825                                  ;   AX		--	8)  file found with .com extension
 11826                                  ;			4)  file found with .exe extension
 11827                                  ;			2)  file found with .bat extension
 11828                                  ;			0)  no such file to be found
 11829                                  ;   (if AX is non-zero:)
 11830                                  ;   [search_best]	identical to AX
 11831                                  ;   [search_best_buf]	null-terminated filename
 11832                                  ; NOTES:
 11833                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11834                                  ;---------------
 11835                                  ; CONSTANTS:
 11836                                  ;---------------
 11837                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11838                                  SEARCH_COM		EQU	8
 11839                                  SEARCH_EXE		EQU	4
 11840                                  SEARCH_BAT		EQU	2
 11841                                  FNAME_LEN		EQU	8
 11842                                  FNAME_MAX_LEN		EQU	13
 11843                                  DOT			EQU	'.'
 11844                                  WILDCHAR		EQU	'?'
 11845                                  
 11846                                  
 11847                                  ; =============== S U B	R O U T	I N E =======================================
 11848                                  
 11849                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11850                                  
 11851                                  PSEARCH:
 11852 00002621 51                      		push	cx
 11853 00002622 52                      		push	dx
 11854 00002623 57                      		push	di
 11855 00002624 56                      		push	si
 11856 00002625 9C                      		pushf
 11857 00002626 52                      		push	dx		; check drivespec (save pname ptr)
 11858 00002627 89D7                    		mov	di,dx		; working copy of pathname
 11859 00002629 BE[984A]                		mov	si,SEARCH_CURDIR_BUF
 11860 0000262C 31D2                    		xor	dx,dx		; zero means current drive
 11861 0000262E 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11862 00002632 7508                    		jne	short SEARCH_DIR_CHECK
 11863 00002634 8A15                    		mov	dl,[di]		; get the drive byte
 11864 00002636 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11865 00002639 80EA40                  		sub	dl,'@'		; and convert to drive number
 11866                                  SEARCH_DIR_CHECK:
 11867 0000263C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11868 0000263F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11869                                  				; DL = drive (0=default,1=A,etc.)
 11870                                  				; DS:SI	points to 64-byte buffer area
 11871 00002641 5A                      		pop	dx		; directory? If we can't we'll		
 11872 00002642 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11873 00002644 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11874 00002647 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11875 0000264A CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11876                                  				; CX = search attributes
 11877                                  				; DS:DX	-> ASCIZ filespec
 11878                                  				; (drive,path,	and wildcards allowed)
 11879 0000264C 723C                    		jc	short SEARCH_NO_FILE
 11880 0000264E C606[8A4A]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11881 00002653 C606[8B4A]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11882                                  SEARCH_LOOP:
 11883 00002658 E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11884 0000265B 3A06[8A4A]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11885 0000265F 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11886 00002661 A2[8A4A]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11887                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11888                                  		;mov	si,FBUF_PNAME
 11889 00002664 BE[764A]                		mov	si,FBUF+FIND_BUF.PNAME
 11890 00002667 BF[8B4A]                		mov	di,SEARCH_BEST_BUF
 11891 0000266A B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11892 0000266D FC                      		cld
 11893 0000266E F3A4                    		rep movsb		; save complete pathname representation
 11894 00002670 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11895 00002672 740A                    		je	short SEARCH_DONE
 11896                                  SEARCH_NEXT:				; keep on looking
 11897 00002674 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11898 00002677 B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11899 0000267A CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11900                                  				; [DTA]	= data block from
 11901                                  				; last AH = 4Eh/4Fh call
 11902 0000267C 73DA                    		jnc	short SEARCH_LOOP
 11903                                  SEARCH_DONE:				; it's all over with...
 11904 0000267E A0[8A4A]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11905                                  		; MSDOS 6.0
 11906                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11907                                  		;jz	search_exit	;AN005; no - exit
 11908                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11909                                  		;mov	search_best,al	;AN005; save the real file type
 11910                                  		;
 11911 00002681 EB0A                    		jmp	short SEARCH_EXIT
 11912                                  
 11913                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11914 00002683 8B16[D84A]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11915 00002687 E88A0D                  		call	STD_PRINTF	 ; and pretend no file found
 11916                                  
 11917                                  SEARCH_NO_FILE:				; couldn't find a match
 11918 0000268A B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11919                                  SEARCH_EXIT:
 11920 0000268D 9D                      		popf
 11921 0000268E 5E                      		pop	si
 11922 0000268F 5F                      		pop	di
 11923 00002690 5A                      		pop	dx
 11924 00002691 59                      		pop	cx
 11925 00002692 C3                      		retn
 11926                                  
 11927                                  ; =============== S U B	R O U T	I N E =======================================
 11928                                  
 11929                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11930                                  ;
 11931                                  ; ENTRY:
 11932                                  ;   fbuf    --	    dma buffer containing filename
 11933                                  ; EXIT:
 11934                                  ;   AX	    --	    file code, as given in search header
 11935                                  ; NOTE(S):
 11936                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11937                                  
 11938                                  SEARCH_FTYPE:
 11939 00002693 57                      		push	di
 11940 00002694 56                      		push	si
 11941 00002695 B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11942                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11943                                  		;mov	di,FBUF_PNAME
 11944 00002698 BF[764A]                		mov	di,FBUF+FIND_BUF.PNAME
 11945 0000269B B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11946 0000269E FC                      		cld
 11947 0000269F F2AE                    		repnz scasb		; search for the terminating null
 11948 000026A1 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11949 000026A3 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11950                                  
 11951                                  		; Compare .COM
 11952                                  
 11953 000026A6 BE[023E]                		mov	si,COMEXT ; ".COM"
 11954 000026A9 89F8                    		mov	ax,di
 11955 000026AB A7                      		cmpsw
 11956 000026AC 7508                    		jnz	short FTYPE_EXE
 11957 000026AE A7                      		cmpsw
 11958 000026AF 7505                    		jnz	short FTYPE_EXE
 11959                                  		;mov	ax,8
 11960 000026B1 B80800                  		mov	ax,SEARCH_COM	; success!
 11961 000026B4 EB23                    		jmp	short FTYPE_EXIT
 11962                                  
 11963                                  		; Compare .EXE
 11964                                  FTYPE_EXE:				; still looking... now for '.exe'
 11965 000026B6 89C7                    		mov	di,ax
 11966 000026B8 BE[063E]                		mov	si,EXEEXT ; ".EXE"
 11967 000026BB A7                      		cmpsw
 11968 000026BC 7508                    		jnz	short FTYPE_BAT
 11969 000026BE A7                      		cmpsw
 11970 000026BF 7505                    		jnz	short FTYPE_BAT
 11971                                  		;mov	ax,4
 11972 000026C1 B80400                  		mov	ax,SEARCH_EXE	; success!
 11973 000026C4 EB13                    		jmp	short FTYPE_EXIT
 11974                                  
 11975                                  		; Compare .BAT
 11976                                  FTYPE_BAT:				; still looking... now for '.bat'
 11977 000026C6 89C7                    		mov	di,ax
 11978 000026C8 BE[0A3E]                		mov	si,BATEXT ; ".BAT"
 11979 000026CB A7                      		cmpsw
 11980 000026CC 7508                    		jnz	short FTYPE_FAIL
 11981 000026CE A7                      		cmpsw
 11982 000026CF 7505                    		jnz	short FTYPE_FAIL
 11983                                  		;mov	ax,2
 11984 000026D1 B80200                  		mov	ax,SEARCH_BAT	; success!
 11985 000026D4 EB03                    		jmp	short FTYPE_EXIT
 11986                                  
 11987                                  FTYPE_FAIL:				; file doesn't match what we need
 11988 000026D6 B80000                  		mov	ax,ANULL ; 0
 11989                                  FTYPE_EXIT:
 11990                                  		; MSDOS 6.0
 11991                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11992                                  		;jz	ftype_done	;AN005; no - exit
 11993                                  		;cmp	ax,ANULL	;AN005; was any match found
 11994                                  		;jz	ftype_done	;AN005; no - exit
 11995                                  		;mov	ext_entered,al	;AN005; save the match type found
 11996                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11997                                  ;ftype_done:
 11998 000026D9 5E                      		pop	si
 11999 000026DA 5F                      		pop	di
 12000 000026DB C3                      		retn
 12001                                  
 12002                                  ; =============== S U B	R O U T	I N E =======================================
 12003                                  
 12004                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 12005                                  ; replacing any extension with wildcards.
 12006                                  ;
 12007                                  ; ENTRY:
 12008                                  ;	BX		--		maximum length of destination buffer
 12009                                  ;	DS:SI		--		address of destination buffer
 12010                                  ;	argv[0] 	--		command name to be stripped
 12011                                  ; EXIT:
 12012                                  ;	CF		--		set if failure, clear if successful
 12013                                  ; NOTE(S):
 12014                                  
 12015                                  
 12016                                  STRIP:
 12017 000026DC 50                      		push	ax
 12018 000026DD 53                      		push	bx
 12019 000026DE 51                      		push	cx
 12020 000026DF 52                      		push	dx
 12021 000026E0 57                      		push	di
 12022 000026E1 56                      		push	si
 12023 000026E2 9C                      		pushf
 12024                                  		
 12025                                  		; MSDOS 6.0
 12026                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 12027                                  
 12028                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12029                                  		;mov	dx,[ARG_ARGV]
 12030                                  		;mov	dx,ds:arg.argv[0].argpointer
 12031                                  					; save pointer to beginning of argstring
 12032                                  		;mov	dx,[ARGV0_ARGPOINTER]
 12033 000026E3 8B16[8E44]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 12034                                  		;mov	di,ds:arg.argv[0].argstartel
 12035                                  					; beginning of last pathname element
 12036                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 12037 000026E7 8B3E[9144]              		mov	di,[ARG+ARGV_ELE.argstartel]
 12038 000026EB 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 12039 000026EE 742E                    		je	short STRIP_ERROR
 12040 000026F0 89D1                    		mov	cx,dx		; compute where end of argstring lies
 12041                                  		;add	cx,ds:arg.argv[0].arglen
 12042                                  		;add	cx,[ARGV0_ARGLEN]
 12043 000026F2 030E[9344]              		add	cx,[ARG+ARGV_ELE.arglen]
 12044 000026F6 29F9                    		sub	cx,di		; and then find length of last element
 12045 000026F8 41                      		inc	cx		; include null as well
 12046                                  		;mov	al,'.'
 12047 000026F9 B02E                    		mov	al,DOT		; let's find the filetype extension
 12048 000026FB FC                      		cld
 12049 000026FC F2AE                    		repnz scasb		; wind up pointing to either null or dot
 12050                                  
 12051                                  		; MSDOS 6.0
 12052                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 12053                                  		;mov	ext_entered,0	;AN005; we found an extension
 12054                                  		;mov	al,ANULL	;AN005; continue scanning until the
 12055                                  		;repnz	scasb		;AN005;    end of line is reached.
 12056                                  PROCESS_EXT:
 12057                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12058 000026FE 89F9                    		mov	cx,di		; pointer to end of argstring yields
 12059 00002700 29D1                    		sub	cx,dx		; number of bytes to be copied
 12060 00002702 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 12061 00002705 39D9                    		cmp	cx,bx
 12062 00002707 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 12063 00002709 89F7                    		mov	di,si		; destination buffer
 12064 0000270B 89D6                    		mov	si,dx		; source is beginning of pathname
 12065 0000270D FC                      		cld
 12066 0000270E F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 12067                                  
 12068                                  		; MSDOS 6.0
 12069                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 12070                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 12071                                  
 12072                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12073 00002710 4F                      		dec	di		; overwrite null or dot
 12074 00002711 AA                      		stosb			; with a dot
 12075                                  		;mov	al,'?'
 12076 00002712 B03F                    		mov	al,WILDCHAR	; now add wildcards
 12077 00002714 AA                      		stosb
 12078 00002715 AA                      		stosb
 12079 00002716 AA                      		stosb
 12080                                  		;mov	al,0
 12081 00002717 B000                    		mov	al,ANULL	; and a terminating null	
 12082 00002719 AA                      		stosb
 12083                                  SKIP_WILDS:
 12084 0000271A 9D                      		popf
 12085 0000271B F8                      		clc
 12086 0000271C EB02                    		jmp	short STRIP_EXIT ; chill out...
 12087                                  STRIP_ERROR:
 12088 0000271E 9D                      		popf
 12089 0000271F F9                      		stc
 12090                                  STRIP_EXIT:
 12091 00002720 5E                      		pop	si
 12092 00002721 5F                      		pop	di
 12093 00002722 5A                      		pop	dx
 12094 00002723 59                      		pop	cx
 12095 00002724 5B                      		pop	bx
 12096 00002725 58                      		pop	ax
 12097 00002726 C3                      		retn
 12098                                  
 12099                                  ; =============== S U B	R O U T	I N E =======================================
 12100                                  
 12101                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 12102                                  ;
 12103                                  ; structure in newly allocated memory. The argv[] structure is found at the
 12104                                  ; beginning of this area. The caller indicates how much extra space is
 12105                                  ; needed in the resulting structure; Save_Args returns a segment number and
 12106                                  ; an offset into that area, indicating where the caller may preserve its own
 12107                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 12108                                  ; ENTRY:
 12109                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 12110                                  ; EXIT:
 12111                                  ;   AX	    --	    segment of new area.
 12112                                  ;   CF	    --	    set if unable to save a copy.
 12113                                  ; NOTE(S):
 12114                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 12115                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 12116                                  ;	paragraphs.
 12117                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 12118                                  ;	as the caller of Save_Args requests.
 12119                                  ;   3)	AX is undefined if CF indicates an error.
 12120                                  
 12121                                  SAVE_ARGS:
 12122 00002727 53                      		push	bx
 12123 00002728 51                      		push	cx
 12124 00002729 52                      		push	dx
 12125 0000272A 57                      		push	di
 12126 0000272B 56                      		push	si
 12127 0000272C 55                      		push	bp
 12128 0000272D 9C                      		pushf
 12129                                  		;add	bx,1363		; space for arg structure, round up
 12130 0000272E 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 12131 00002732 B104                    		mov	cl,4		; to paragraph size and convert
 12132 00002734 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 12133 00002736 B80048                  		mov	ax,ALLOC*256 ; 4800h
 12134 00002739 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 12135                                  				; BX = number of 16-byte paragraphs desired
 12136 0000273B 7244                    		jc	short SAVE_ERROR
 12137 0000273D 89C5                    		mov	bp,ax		; save segment id
 12138 0000273F 06                      		push	es		; save TRANGROUP address
 12139 00002740 8EC0                    		mov	es,ax		; switch to new memory segment
 12140                                  		; assume es:nothing
 12141                                  		;mov	cx,1348		; get back structure size
 12142 00002742 B94405                  		mov	cx,ARG_UNIT.SIZE
 12143 00002745 31FF                    		xor	di,di		; destination is new memory area
 12144                                  		;mov	si,ARG_ARGV
 12145 00002747 BE[8E44]                		mov	si,ARG		; source is arg structure
 12146 0000274A F3A4                    		rep movsb		; move that sucker!
 12147                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 12148                                  		;mov	cx,[ARG_ARGVCNT]
 12149 0000274C 8B0E[4E47]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 12150 00002750 31C0                    		xor	ax,ax		; base address for argv_calc
 12151                                  
 12152                                  	;	Bugbug:	What did they mean by this?
 12153                                  	;	Note that the replacement line produces exactly the same code.
 12154                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 12155                                  	;	mov	SI, OFFSET TRANGROUP:arg
 12156                                  
 12157                                  		;mov	si,ARG_ARGV
 12158 00002752 BE[8E44]                		mov	si,ARG	
 12159                                  SAVE_PTR_LOOP:
 12160 00002755 49                      		dec	cx		; exhausted all args?
 12161 00002756 7C24                    		jl	short SAVE_DONE
 12162 00002758 89CB                    		mov	bx,cx		; get arg index and
 12163 0000275A E8EDFC                  		call	ARGV_CALC	; convert to a pointer
 12164                                  		;mov	dx,ds:arg.argv[bx].argpointer
 12165                                  		;mov	dx,[ARG_ARGV+bx]
 12166 0000275D 8B97[8E44]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 12167 00002761 29F2                    		sub	dx,si		; adjust argpointer
 12168                                  		;mov	es:argv[BX].argpointer,dx
 12169                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12170 00002763 268917                  		mov	[es:bx],dx
 12171                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12172                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12173 00002766 8B97[9144]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12174 0000276A 29F2                    		sub	dx,si		; and adjust argstartel
 12175                                  		;mov	es:argv[bx].argstartel,dx
 12176                                  		;mov	[es:bx+3],dx
 12177 0000276C 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12178                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12179                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12180 00002770 8B97[9744]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12181 00002774 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12182                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12183                                  		;mov	[es:bx+9],dx
 12184 00002776 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12185 0000277A EBD9                    		jmp	short SAVE_PTR_LOOP
 12186                                  SAVE_DONE:
 12187 0000277C 07                      		pop	es		; back we go to TRANGROUP
 12188                                  		; assume es:nothing
 12189 0000277D 89E8                    		mov	ax,bp		; restore segment id
 12190 0000277F EB04                    		jmp	short SAVE_OK
 12191                                  SAVE_ERROR:
 12192 00002781 9D                      		popf
 12193 00002782 F9                      		stc
 12194 00002783 EB02                    		jmp	short SAVE_EXIT
 12195                                  SAVE_OK:
 12196 00002785 9D                      		popf
 12197 00002786 F8                      		clc
 12198                                  SAVE_EXIT:
 12199 00002787 5D                      		pop	bp
 12200 00002788 5E                      		pop	si
 12201 00002789 5F                      		pop	di
 12202 0000278A 5A                      		pop	dx
 12203 0000278B 59                      		pop	cx
 12204 0000278C 5B                      		pop	bx
 12205                                  NOTEST2_RETN:	; 02/03/2023
 12206 0000278D C3                      		retn
 12207                                  
 12208                                  ;============================================================================
 12209                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12210                                  ;============================================================================
 12211                                  ; 02/10/2018 - Retro DOS v3.0
 12212                                  
 12213                                  ; Title	COMMAND Language midifiable Code Transient
 12214                                  
 12215                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12216                                  
 12217                                  ; =============== S U B	R O U T	I N E =======================================
 12218                                  
 12219                                  ; ****************************************************************
 12220                                  ; *
 12221                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12222                                  ; *
 12223                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12224                                  ; *		 user for Y/N if necessary. If an error occurs,
 12225                                  ; *		 set up an error message and go to CERROR.
 12226                                  ; *
 12227                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12228                                  ; *		 Current directory set to entered directory
 12229                                  ; *
 12230                                  ; * OUTPUT:	 none
 12231                                  ; *
 12232                                  ; ****************************************************************
 12233                                  ;
 12234                                  ; ARE YOU SURE prompt when deleting *.*
 12235                                  
 12236                                  NOTEST2:
 12237 0000278E B90B00                  		mov	cx,11
 12238 00002791 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12239                                  AMBSPEC:
 12240 00002794 AC                      		lodsb
 12241 00002795 3C3F                    		cmp	al,'?'
 12242 00002797 7502                    		jnz	short ALLFIL
 12243 00002799 E2F9                    		loop	AMBSPEC
 12244                                  ALLFIL:
 12245 0000279B 83F900                  		cmp	cx,0
 12246 0000279E 7530                    		jnz	short NOPRMPT
 12247                                  ASKAGN:	
 12248 000027A0 BA[FC39]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12249 000027A3 E86E0C                  		call	STD_PRINTF
 12250 000027A6 BE8000                  		mov	si,80h
 12251 000027A9 89F2                    		mov	dx,si
 12252 000027AB C7047800                		mov	word [si],120	; zero length
 12253                                  		;mov	ax,0C0Ah
 12254 000027AF B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12255 000027B2 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12256                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12257 000027B4 AD                      		lodsw
 12258 000027B5 08E4                    		or	ah,ah
 12259 000027B7 74E7                    		jz	short ASKAGN
 12260 000027B9 E886F1                  		call	SCANOFF
 12261                                  		; MSDOS 6.0
 12262                                  		;call	char_in_xlat	; Convert to upper case
 12263                                  		;retc			; return if function not supported
 12264                                  		; MSDOS 3.3
 12265 000027BC E87601                  		call	UPCONV
 12266                                  		
 12267                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12268 000027BF 3A06[A93C]              		cmp	al,[CAPITAL_N]
 12269                                  		;jne	short CHECK_Y
 12270                                  		;retn
 12271                                  		; 02/03/2023
 12272 000027C3 74C8                    		je	short NOTEST2_RETN
 12273                                  CHECK_Y:
 12274 000027C5 3A06[A83C]              		cmp	al,[CAPITAL_Y]
 12275 000027C9 9C                      		pushf
 12276 000027CA E868F1                  		call	CRLF2
 12277 000027CD 9D                      		popf
 12278 000027CE 75D0                    		jne	short ASKAGN
 12279                                  NOPRMPT:
 12280 000027D0 B413                    		mov	ah,FCB_DELETE ; 13h
 12281 000027D2 BA5C00                  		mov	dx,FCB ; 5Ch
 12282 000027D5 CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12283                                  				; DS:DX	-> FCB with filename field filled with
 12284                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12285                                  				; Return: AL = 00h file	found,FFh file	not found
 12286 000027D7 FEC0                    		inc	al
 12287 000027D9 7403                    		jz	short ERAERR
 12288                                  		;call	RESTUDIR
 12289                                  		;retn
 12290                                  		; 02/03/2023
 12291 000027DB E98BF0                  		jmp	RESTUDIR
 12292                                  
 12293                                  		; MSDOS 6.0
 12294                                  ;eraerr:
 12295                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12296                                  		;push	dx			;AN022; save message
 12297                                  		;invoke	RESTUDIR
 12298                                  		;pop	dx			;AN022; restore message
 12299                                  		;
 12300                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12301                                  		;				;AN022; convert no more files to
 12302                                  		;jnz	cerrorj2		;AN022; 	file not found
 12303                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12304                                  		;			;AN000; get message number in control block
 12305                                  ;cerrorj2:
 12306                                  		;jmp	cerror
 12307                                  	
 12308                                  		; MSDOS 3.3
 12309                                  ERAERR:	
 12310 000027DE B41A                    		mov	ah,SET_DMA ; 1Ah
 12311 000027E0 BA5C00                  		mov	dx,FCB ; 5Ch
 12312 000027E3 CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12313                                  					; DS:DX	-> disk	transfer buffer
 12314 000027E5 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12315 000027E7 CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12316                                  					; DS:DX	-> FCB
 12317 000027E9 50                      		push	ax
 12318 000027EA E87CF0                  		call	RESTUDIR
 12319 000027ED 58                      		pop	ax
 12320 000027EE BA[0837]                		mov	dx,FNOTFOUNDPTR
 12321 000027F1 FEC0                    		inc	al
 12322 000027F3 743D                    		jz	short CERRORJ
 12323 000027F5 BA[2D37]                		mov	dx,ACCDENPTR
 12324 000027F8 E9EBF3                  		jmp	CERROR
 12325                                  
 12326                                  ; =============== S U B	R O U T	I N E =======================================
 12327                                  
 12328                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12329                                  
 12330                                  ECHO:
 12331 000027FB E89400                  		call	ON_OFF
 12332 000027FE 7212                    		jb	short DOEMES
 12333 00002800 8E1E[5641]              		mov	ds,[RESSEG]
 12334 00002804 7506                    		jnz	short ECH_OFF
 12335 00002806 800ED70B01              		or	byte [ECHOFLAG],1
 12336                                  ;NOTEST2_RETN:	; 02/03/2023
 12337 0000280B C3                      		retn
 12338                                  ECH_OFF:
 12339 0000280C 8026D70BFE              		and	byte [ECHOFLAG],0FEh
 12340 00002811 C3                      		retn
 12341                                  
 12342                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12343                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12344                                  
 12345                                  DOEMES:
 12346                                  		; MSDOS 6.0
 12347                                  		;cmp	cl,0		;AC000; was anything on the line?
 12348                                  		;jz	PECHO		; just display current state.
 12349                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12350                                  		;invoke	CRPRINT
 12351                                  		;JMP	CRLF2
 12352                                  
 12353                                  		; MSDOS 3.3
 12354 00002812 E82000                  		call	MOVE_TO_FIRST_ARG
 12355 00002815 7409                    		jz	short PECHO
 12356 00002817 BA8200                  		mov	dx,82h
 12357 0000281A E875F1                  		call	CRPRINT
 12358 0000281D E915F1                  		jmp	CRLF2
 12359                                  
 12360                                  PECHO:
 12361                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12362 00002820 8E1E[5641]              		mov	ds,[RESSEG]
 12363 00002824 8A1ED70B                		mov	bl,[ECHOFLAG]
 12364 00002828 0E                      		push	cs
 12365 00002829 1F                      		pop	ds
 12366 0000282A 80E301                  		and	bl,1
 12367 0000282D BA[2F3C]                		mov	dx,ECHOMESPTR
 12368 00002830 EB2E                    		jmp	short PYN
 12369                                  
 12370                                  ; ---------------------------------------------------------------------------
 12371                                  
 12372                                  		; MSDOS 3.3
 12373                                  CERRORJ:
 12374 00002832 E9B1F3                  		jmp	CERROR
 12375                                  
 12376                                  
 12377                                  ; =============== S U B	R O U T	I N E =======================================
 12378                                  
 12379                                  MOVE_TO_FIRST_ARG:
 12380 00002835 BE8100                  		mov	si,81h
 12381 00002838 E807F1                  		call	SCANOFF
 12382 0000283B 3C0D                    		cmp	al,0Dh
 12383 0000283D C3                      		retn
 12384                                  
 12385                                  ; =============== S U B	R O U T	I N E =======================================
 12386                                  
 12387                                  CNTRLC:
 12388 0000283E E85100                  		call	ON_OFF
 12389 00002841 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12390 00002844 720C                    		jc	short PCNTRLC
 12391 00002846 7505                    		jnz	short CNTRLC_OFF
 12392 00002848 B201                    		mov	dl,1
 12393 0000284A CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12394                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12395                                  				; DL = 00h for OFF or 01h for ON
 12396 0000284C C3                      		retn
 12397                                  
 12398                                  ; ---------------------------------------------------------------------------
 12399                                  
 12400                                  CNTRLC_OFF:
 12401 0000284D 30D2                    		xor	dl,dl
 12402 0000284F CD21                    		int	21h		; Turn off ^C check
 12403 00002851 C3                      		retn
 12404                                  
 12405                                  ; ---------------------------------------------------------------------------
 12406                                  
 12407                                  PCNTRLC:
 12408                                  		; MSDOS 6.0
 12409                                  		;CMP	CL,0		;AC000; rest of line blank?
 12410                                  		;JNZ	CERRORJ 	; no, oops!
 12411                                  
 12412                                  		; MSDOS 3.3
 12413 00002852 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12414 00002855 75DB                    		jnz	short CERRORJ
 12415                                  ;pccont:
 12416                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12417 00002857 30C0                    		xor	al,al
 12418 00002859 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12419 0000285B 88D3                    		mov	bl,dl
 12420 0000285D BA[173C]                		mov	dx,CTRLMESPTR
 12421                                  
 12422                                  ; ---------------------------------------------------------------------------
 12423                                  
 12424                                  PYN:		; write "ON" or "OFF" state 
 12425                                  
 12426 00002860 E8B10B                  		call	STD_PRINTF
 12427 00002863 BA[3E3C]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12428 00002866 08DB                    		or	bl,bl
 12429 00002868 7503                    		jnz	short PRINTVAL
 12430 0000286A BA[373C]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12431                                  
 12432                                  PRINTVAL:
 12433                                  		; MSDOS 3.3
 12434 0000286D E9A40B                  		jmp	STD_PRINTF
 12435                                  
 12436                                  		; MSDOS 6.0
 12437                                  		;push	dx		;AN000; save offset of message block
 12438                                  		;mov	bx,dx		;AN000; save offset value
 12439                                  		;lodsw			;AN000; get message number of on or off
 12440                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12441                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12442                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12443                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12444                                  		;pop	dx		;AN000; get message back
 12445                                  		;invoke	std_printf	;AC000; go print message
 12446                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12447                                  		;
 12448                                  		;ret			;AN000; exit
 12449                                  
 12450                                  ; =============== S U B	R O U T	I N E =======================================
 12451                                  
 12452                                  VERIFY:
 12453 00002870 E81F00                  		call	ON_OFF
 12454 00002873 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12455 00002876 720A                    		jc	short PVERIFY
 12456 00002878 7503                    		jnz	short VER_OFF
 12457 0000287A CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12458                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12459 0000287C C3                      		retn
 12460                                  
 12461                                  ; ---------------------------------------------------------------------------
 12462                                  
 12463                                  VER_OFF:
 12464 0000287D FEC8                    		dec	al
 12465 0000287F CD21                    		int	21h		; Turn off verify after write
 12466 00002881 C3                      		retn
 12467                                  
 12468                                  ; ---------------------------------------------------------------------------
 12469                                  
 12470                                  PVERIFY:
 12471                                  		; MSDOS 6.0
 12472                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12473                                  		;JNZ	CERRORJ 	; nope...
 12474                                  
 12475                                  		; MSDOS 3.3
 12476 00002882 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12477 00002885 75AB                    		jnz	short CERRORJ
 12478                                  
 12479 00002887 B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12480 00002889 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12481                                  					; Return: AL = 00h if flag OFF
 12482                                  					; AL = 01h if flag ON
 12483 0000288B 88C3                    		mov	bl,al
 12484 0000288D BA[243C]                		mov	dx,VERIMESPTR
 12485 00002890 EBCE                    		jmp	short PYN
 12486                                  
 12487                                  ; =============== S U B	R O U T	I N E =======================================
 12488                                  
 12489                                  ; ****************************************************************
 12490                                  ; *
 12491                                  ; * ROUTINE:	 ON_OFF
 12492                                  ; *
 12493                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12494                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12495                                  ; *		 routines.
 12496                                  ; *
 12497                                  ; * INPUT:	 command line at offset 81H
 12498                                  ; *		 PARSE_BREAK control block
 12499                                  ; *
 12500                                  ; * OUTPUT:	 If carry is clear
 12501                                  ; *		    If ON is found
 12502                                  ; *		       Zero flag set
 12503                                  ; *		    If OFF is found
 12504                                  ; *		       Zero flag clear
 12505                                  ; *		 If carry set
 12506                                  ; *		    If nothing on command line
 12507                                  ; *		       CL set to zero
 12508                                  ; *		    If error
 12509                                  ; *		       CL contains error value from parse
 12510                                  ; *
 12511                                  ; ****************************************************************
 12512                                  
 12513                                  ON_OFF:
 12514 00002892 BE8100                  		mov	si,81h
 12515                                  
 12516                                  		; MSDOS 3.3
 12517 00002895 E8AAF0                  		call	SCANOFF		; scan off leading blanks & equal
 12518 00002898 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12519 0000289A 742A                    		je	short BAD_ONF	; yes, return error
 12520 0000289C AD                      		lodsw
 12521 0000289D 0D2020                  		or	ax,2020h	; convert to lowercase
 12522 000028A0 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12523 000028A3 7410                    		je	short ON_CHECK
 12524 000028A5 3D6F66                  		cmp	ax,666Fh ;'of'
 12525 000028A8 751C                    		jne	short BAD_ONF
 12526 000028AA AC                      		lodsb
 12527 000028AB 0C20                    		or	al,20h		; convert to lowercase		
 12528 000028AD 3C66                    		cmp	al,66h	 ; 'f'
 12529 000028AF 7515                    		jne	short BAD_ONF	
 12530 000028B1 0C66                    		or	al,66h ; or al,'f'
 12531 000028B3 EB02                    		jmp	short OFF_CHECK
 12532                                  ON_CHECK:
 12533 000028B5 30C0                    		xor	al,al
 12534                                  OFF_CHECK:
 12535 000028B7 9F                      		lahf
 12536 000028B8 89C3                    		mov	bx,ax
 12537 000028BA E885F0                  		call	SCANOFF		; scan off leading blanks & equal
 12538 000028BD 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12539 000028BF 7505                    		jne	short BAD_ONF	; no, return error
 12540 000028C1 89D8                    		mov	ax,bx
 12541 000028C3 9E                      		sahf
 12542 000028C4 F8                      		clc
 12543 000028C5 C3                      		retn
 12544                                  
 12545                                  		; MSDOS 6.0
 12546                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12547                                  ;		lodsb			;AN032; get a char
 12548                                  ;		cmp	al,blank	;AN032; if whitespace
 12549                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12550                                  ;		cmp	al,tab_chr	;AN032; if tab
 12551                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12552                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12553                                  ;		jz	parse_on_off	;AN032;    start parsing
 12554                                  ;		dec	si		;AN032; if none of above - back up
 12555                                  ;
 12556                                  ;parse_on_off:				;AN032;    and start parsing
 12557                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get address of PARSE_BREAK
 12558                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12559                                  ;		xor	dx,dx		;AN000;
 12560                                  ;		invoke	cmd_parse	;AC000; call parser
 12561                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12562                                  ;		jz	BADONF		;AC000; yes, return error
 12563                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12564                                  ;		jz	on_off_there	;AN000; no - continue
 12565                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12566                                  ;		jmp	short BADONF	;AN000; return error
 12567                                  ;
 12568                                  ;on_off_there:
 12569                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12570                                  ;		jnz	good_on_off	;AN014; yes - continue
 12571                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12572                                  ;		jmp	short BADONF	;AN014; return error
 12573                                  ;
 12574                                  ;good_on_off:				;AN014;
 12575                                  ;		xor	ax,ax		;AC000; set up return code for
 12576                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12577                                  ;		pushf			;AN000; save flags
 12578                                  ;		mov	di,offset trangroup:parse_break
 12579                                  ;					;AN000; Get address of PARSE_BREAK
 12580                                  ;		xor	dx,dx		;AN000;
 12581                                  ;		invoke	cmd_parse	;AN000; call parser
 12582                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12583                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12584                                  ;		popf			;AN000; restore flags
 12585                                  ;		clc			;AC000; no error
 12586                                  ;		jmp	short on_off_end ;AN000; return to caller
 12587                                  ;
 12588                                  ;BADONF_flags:
 12589                                  ;		mov	cx,ax
 12590                                  ;		popf
 12591                                  
 12592                                  ; ---------------------------------------------------------------------------
 12593                                  
 12594                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12595                                  ; and return the error
 12596                                  
 12597                                  BAD_ONF:
 12598 000028C6 BA[F93A]                		mov	dx,BADONOFFPTR
 12599 000028C9 F9                      		stc
 12600                                  ;on_off_end:
 12601 000028CA C3                      		retn
 12602                                  
 12603                                  ;============================================================================
 12604                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12605                                  ;============================================================================
 12606                                  ; 02/10/2018 - Retro DOS v3.0
 12607                                  
 12608                                  ; Print volume ID info
 12609                                  
 12610                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12611                                  
 12612                                  ; ---------------------------------------------------------------------------
 12613                                  
 12614                                  PRINTVOL:
 12615 000028CB 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12616 000028CC A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12617 000028CF 0440                    		add	al,'@'
 12618 000028D1 3C40                    		cmp	al,'@'
 12619 000028D3 7505                    		jnz	short DRVOK
 12620 000028D5 A0[6A41]                		mov	al,[CURDRV]
 12621                                  		;add	al,[CAPITAL_A]
 12622                                  		; 01/03/2023
 12623 000028D8 0441                    		add	al,capital_A  ; add al,'A'
 12624                                  DRVOK:
 12625 000028DA A2[4943]                		mov	[VOL_DRV],al	; get drive letter into argument
 12626 000028DD 58                      		pop	ax		; get return code back
 12627 000028DE BA[653A]                		mov	dx,NOVOL ; "has	no label" 
 12628 000028E1 08C0                    		or	al,al		; volume label found?
 12629 000028E3 7517                    		jnz	short PRINTVOL2	; print no volume message
 12630                                  GOODVOL:
 12631                                  		; MSDOS 3.3
 12632 000028E5 BF[8041]                		mov	di,CHARBUF
 12633 000028E8 89FA                    		mov	dx,di
 12634 000028EA BE[613A]                		mov	si,IS	; "is "
 12635 000028ED E88BDF                  		call	STRCPY
 12636 000028F0 4F                      		dec	di
 12637 000028F1 BE[5742]                		mov	si,DIRBUF+8
 12638 000028F4 B90B00                  		mov	cx,11
 12639 000028F7 F3A4                    		rep movsb
 12640 000028F9 31C0                    		xor	ax,ax
 12641                                  		;xor	al,al  ; MSDOS 6.0
 12642 000028FB AA                      		stosb			; store a zero to terminate the string
 12643                                  PRINTVOL2:
 12644 000028FC 8916[4743]              		mov	[VOLNAME_ADDR],dx
 12645 00002900 BA[5B3A]                		mov	dx,VOLMESPTR
 12646 00002903 E9FF0A                  		jmp	PRINTF_CRLF
 12647                                  
 12648                                  		; MSDOS 6.0
 12649                                  ;drvok:
 12650                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12651                                  ;		pop	ax		;AC000; get return code back
 12652                                  ;		or	al,al		;AC000; volume label found?
 12653                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12654                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12655                                  ;					;AC000; set up no volume message
 12656                                  ;		jmp	short print_serial	;AC000; go print it
 12657                                  ;
 12658                                  ;Get_vol_name:
 12659                                  ;		mov	di,offset trangroup:charbuf
 12660                                  ;		mov	dx,di
 12661                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12662                                  ;		mov	cx,11				;AN000;  3/3/KK
 12663                                  ;		rep	movsb				;AN000;  3/3/KK
 12664                                  ;
 12665                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12666                                  ;		stosb
 12667                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12668                                  ;
 12669                                  ;PRINT_SERIAL:
 12670                                  ;
 12671                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12672                                  ;; occurs, do not print volume serial number.
 12673                                  ;
 12674                                  ;		push	dx		;AN000; save message offset
 12675                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12676                                  ;					;AC036; Get the volume serial info
 12677                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12678                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12679                                  ;		int	21h		;AN000; do the call
 12680                                  ;		pop	dx		;AN000; get message offset back
 12681                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12682                                  ;		call	std_printf	;AC000; go print volume message
 12683                                  ;		mov	al,blank	;AN051; Print out a blank
 12684                                  ;		invoke	print_char	;AN051;   before volume message
 12685                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12686                                  ;					;AN000; get serial number message
 12687                                  ;printvol_end:
 12688                                  ;		jmp	std_printf	;AC000; go print and exit
 12689                                  
 12690                                  ;============================================================================
 12691                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12692                                  ;============================================================================
 12693                                  ; 02/10/2018 - Retro DOS v3.0
 12694                                  
 12695                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12696                                  
 12697                                  ; =============== S U B	R O U T	I N E =======================================
 12698                                  
 12699                                  PRINT_DATE:
 12700                                  		; 20/03/2023
 12701                                  		; MSDOS 3.3
 12702                                  		;push	es ; 20/03/2023	
 12703                                  		;push	di
 12704 00002906 0E                      		push	cs
 12705 00002907 07                      		pop	es
 12706 00002908 BF[AD42]                		mov	di,ARG_BUF
 12707 0000290B B42A                    		mov	ah,GET_DATE ; 2Ah
 12708 0000290D CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12709                                  				; Return: DL = day,DH = month,	CX = year
 12710                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12711 0000290F 98                      		cbw
 12712 00002910 E80D00                  		call	GETDATE
 12713 00002913 E817F7                  		call	P_DATE
 12714 00002916 30C0                    		xor	al,al
 12715 00002918 AA                      		stosb
 12716 00002919 BA[3336]                		mov	dx,ARG_BUF_PTR
 12717 0000291C E8F50A                  		call	STD_PRINTF
 12718                                  			; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 12719                                  		;pop	es ; !!??!! 
 12720                                  		;pop	di
 12721 0000291F C3                      		retn
 12722                                  
 12723                                  		; MSDOS 6.0
 12724                                  		;PUSH	ES
 12725                                  		;PUSH	DI
 12726                                  		;PUSH	CS
 12727                                  		;POP	ES
 12728                                  		;CALL	GetDate 		; get date
 12729                                  		;xchg	dh,dl			;AN000; switch month & day
 12730                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12731                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12732                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12733                                  		;invoke	std_printf
 12734                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12735                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12736                                  		;POP	DI			;AC000; restore di,es
 12737                                  		;POP	ES			;AC000;
 12738                                  		;return
 12739                                  
 12740                                  ; ---------------------------------------------------------------------------
 12741                                  
 12742                                  GETDATE:
 12743                                  		; MSDOS 3.3
 12744 00002920 89C6                    		mov	si,ax
 12745 00002922 D1E6                    		shl	si,1
 12746 00002924 01C6                    		add	si,ax
 12747 00002926 81C6[3439]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12748 0000292A 89CB                    		mov	bx,cx
 12749 0000292C B90300                  		mov	cx,3
 12750 0000292F F3A4                    		rep movsb
 12751 00002931 B020                    		mov	al,' '
 12752 00002933 AA                      		stosb
 12753 00002934 C3                      		retn
 12754                                  
 12755                                  		; MSDOS 6.0
 12756                                  
 12757                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12758                                  ; for output.  Date will be returned in CX,DX.
 12759                                  
 12760                                  ;GetDate:
 12761                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12762                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12763                                  		;INT	21h			;AC000; Get date in CX:DX
 12764                                  		;CBW				;AC000;
 12765                                  		;
 12766                                  		;push	cx			;AN000; save date returned in
 12767                                  		;push	dx			;AN000;      CX:DX
 12768                                  		;MOV	SI,AX
 12769                                  		;
 12770                                  		;SHL	SI,1
 12771                                  		;ADD	SI,AX			; SI=AX*3
 12772                                  		;
 12773                                  		;mov	cx,si			;AN000; save si
 12774                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12775                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12776                                  		;push	di			;AN000; save argument buffer
 12777                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12778                                  		;pop	di			;AN000; retrieve argument buffer
 12779                                  		;add	si,cx			;AC000; get day of week
 12780                                  		;
 12781                                  		;MOV	CX,3
 12782                                    		;REP	MOVSB
 12783                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12784                                  		;stosb
 12785                                  		;pop	dx			;AN000; get back date
 12786                                  		;pop	cx			;AN000;
 12787                                  		;
 12788                                  		;return
 12789                                  
 12790                                  ; =============== S U B	R O U T	I N E =======================================
 12791                                  
 12792                                  		; MSDOS 6.0
 12793                                  
 12794                                  ; This routine determines whether the character in AL is a
 12795                                  ; Yes or No character. On return, if AL=0, the character is
 12796                                  ; No, if AL=1, the character is Yes.
 12797                                  
 12798                                  ;		assume	ds:trangroup
 12799                                  
 12800                                  ;char_in_xlat	proc	near
 12801                                  ;
 12802                                  ;		mov	dl,al			;AC000; get character into DX
 12803                                  ;		xor	dh,dh			;AC000;
 12804                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12805                                  ;		int	21h			;AC000;
 12806                                  ;
 12807                                  ;		ret
 12808                                  ;
 12809                                  ;char_in_xlat	endp
 12810                                  
 12811                                  ;============================================================================
 12812                                  ; TENV.ASM, MSDOS 6.0, 1991
 12813                                  ;============================================================================
 12814                                  ; 02/10/2018 - Retro DOS v3.0
 12815                                  
 12816                                  ;	Environment utilities and misc. routines
 12817                                  
 12818                                  ; MSDOS 6.0
 12819                                  ; ****************************************************************
 12820                                  ; *
 12821                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12822                                  ; *
 12823                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12824                                  ; *		 the character in AL from the file upper case table
 12825                                  ; *		 in DOS if character if above  ascii 128, else
 12826                                  ; *		 subtracts 20H if between "a" and "z".
 12827                                  ; *
 12828                                  ; * INPUT:	 AL	      char to be upper cased
 12829                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12830                                  ; *
 12831                                  ; * OUTPUT:	 AL	      upper cased character
 12832                                  ; *
 12833                                  ; ****************************************************************
 12834                                  ;
 12835                                  ;assume	ds:trangroup				;AN000;
 12836                                  ;
 12837                                  ;upconv	proc	near				;AN000;
 12838                                  ;
 12839                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12840                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12841                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12842                                  ;	push	ds				;AN000;
 12843                                  ;	push	bx				;AN000;
 12844                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12845                                  ;assume	ds:resgroup				;AN000;
 12846                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12847                                  ;	add	bx,2				;AN000;  skip over first word
 12848                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12849                                  ;	pop	bx				;AN000;
 12850                                  ;	pop	ds				;AN000;
 12851                                  ;assume	ds:trangroup				;AN000;
 12852                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12853                                  ;
 12854                                  ;oth_fucase:					;AN000;
 12855                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12856                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12857                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12858                                  ;	ja	upconv_end			;AC000;
 12859                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12860                                  ;
 12861                                  ;upconv_end:					;AN000;
 12862                                  ;	ret
 12863                                  ;
 12864                                  ;upconv	endp					;AN000;
 12865                                  
 12866                                  
 12867                                  ; =============== S U B	R O U T	I N E =======================================
 12868                                  
 12869                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12870                                  
 12871                                  UPCONV:
 12872 00002935 3C80                    		cmp	al,80h
 12873 00002937 7214                    		jb	short OTH_UCASE
 12874 00002939 2C80                    		sub	al,80h
 12875 0000293B 1E                      		push	ds
 12876 0000293C 53                      		push	bx
 12877 0000293D 8E1E[5641]              		mov	ds,[RESSEG]
 12878 00002941 C51EEE0B                		lds	bx,[UPPERCASETBL]
 12879 00002945 83C302                  		add	bx,2
 12880 00002948 D7                      		xlat
 12881 00002949 5B                      		pop	bx
 12882 0000294A 1F                      		pop	ds
 12883 0000294B EB0A                    		jmp	short UPCONV_RETN
 12884                                  OTH_UCASE:
 12885 0000294D 3C61                    		cmp	al,'a'
 12886 0000294F 7206                    		jb	short UPCONV_RETN
 12887 00002951 3C7A                    		cmp	al,'z'
 12888 00002953 7702                    		ja	short UPCONV_RETN
 12889 00002955 2C20                    		sub	al,20h
 12890                                  UPCONV_RETN:
 12891 00002957 C3                      		retn
 12892                                  
 12893                                  ;============================================================================
 12894                                  ; COPY.ASM, MSDOS 6.0, 1991
 12895                                  ;============================================================================
 12896                                  ; 01/10/2018 - Retro DOS v3.0
 12897                                  
 12898                                  ;	title	COMMAND COPY routines.
 12899                                  
 12900                                  ;/*
 12901                                  ; *                      Microsoft Confidential
 12902                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12903                                  ; *                      All Rights Reserved.
 12904                                  ; */
 12905                                  
 12906                                  ;***	COPY.ASM
 12907                                  
 12908                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12909                                  
 12910                                  
 12911                                  ;***	MODIFICATION HISTORY
 12912                                  
 12913                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12914                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12915                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12916                                  ;	     to tokens which begin with path characters so that PARSELINE
 12917                                  ;	     will work correctly.
 12918                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12919                                  ;	     individual tokens.  That distinction is no longer needed for
 12920                                  ;	     FOR loop processing.
 12921                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12922                                  ;	     1 when Cparse is called from COPY.
 12923                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12924                                  ;	     mod.  It now is conditional on flag like previous mod.
 12925                                  ;11/21/83 NP  Added printf
 12926                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12927                                  ;	     be added to a token.
 12928                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12929                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12930                                  ;	     special values:  -1 meaning destination was never opened and
 12931                                  ;	     0 which means that the destination has been openned and
 12932                                  ;	     closed.
 12933                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12934                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12935                                  ;	     lost on large and multiple file (wildcard) copies.
 12936                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12937                                  ;	     destination are not equal.
 12938                                  ;
 12939                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12940                                  ;	     first source file AND we run out of disk space before
 12941                                  ;	     completing the concatenation, restore the first source
 12942                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12943                                  ;
 12944                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12945                                  ;		instead of compatibility mode. This gives lesser sharing
 12946                                  ;		violations when files are opened for read on a copy.
 12947                                  
 12948                                  ; ---------------------------------------------------------------------------
 12949                                  ;***	COPY CODE
 12950                                  ; ---------------------------------------------------------------------------
 12951                                  
 12952                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12953                                  
 12954                                  COPY:
 12955                                  	; 	Initialize internal variables.
 12956                                  
 12957 00002958 31C0                    		xor	ax,ax		; AX = 0
 12958 0000295A A3[3543]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12959 0000295D A3[6A44]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12960 00002960 A3[B643]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12961 00002963 A2[7541]                		mov	[CFLAG],al	; 'destination file created' = false
 12962 00002966 A3[7941]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12963 00002969 A3[7141]                		mov	[DESTSWITCH],ax	; destination switches = none
 12964 0000296C A3[7C44]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12965 0000296F A3[5343]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12966 00002972 A2[7641]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12967 00002975 A2[5243]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12968 00002978 A2[B543]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12969 0000297B A2[5543]                		mov	[DESTINFO],al	; destination pathname flags = none
 12970 0000297E A2[B843]                		mov	[SRCINFO],al	; source pathname flags = none
 12971 00002981 A2[6C44]                		mov	[INEXACT],al	; 'inexact copy' = false
 12972 00002984 A2[5143]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12973 00002987 A2[B443]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12974 0000298A A2[3840]                		mov	[USERDIR1],al	; saved working directory = null
 12975 0000298D A2[6E44]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12976 00002990 A2[6941]                		mov	[RDEOF],al	; 'read end of file' = false
 12977 00002993 A3[1044]                		mov	[SRCHAND],ax	; source handle = 0
 12978 00002996 A3[7644]                		mov	[CPDATE],ax	; copy date = 0
 12979 00002999 A3[7844]                		mov	[CPTIME],ax	; copy time = 0
 12980 0000299C A2[1244]                		mov	[SRCISDEV],al	; 'source is device' = false
 12981                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12982                                  		;mov	[OFilePtr_Lo],ax
 12983                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12984 0000299F A2[7244]                		mov	[TERMREAD],al	; 'terminate read' = false
 12985 000029A2 A2[AB42]                		mov	[COMMA],al	; '"+,," found' = false
 12986 000029A5 A2[AC42]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12987 000029A8 A3[7341]                		mov	[ALLSWITCH],ax	; all switches = none
 12988 000029AB A2[6C41]                		mov	[ARGC],al	; source/dest argument count = 0
 12989 000029AE A2[7444]                		mov	[PLUS],al	; '"+" in command line' = false
 12990 000029B1 A2[6F44]                		mov	[BINARY],al	; 'binary copy' = false
 12991 000029B4 A2[7344]                		mov	[ASCII],al	; 'ascii copy' = false
 12992 000029B7 A3[7E41]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12993 000029BA A3[7044]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12994 000029BD A2[6B41]                		mov	[CONCAT],al	; 'concatenating' = false
 12995 000029C0 A2[B143]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12996 000029C3 A3[B243]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12997                                  
 12998                                  	;	Initialize buffers with double-nulls.
 12999                                  
 13000 000029C6 A3[1344]                		mov	[SCANBUF],ax
 13001 000029C9 A3[5643]                		mov	[DESTBUF],ax
 13002 000029CC A3[B943]                		mov	[SRCBUF],ax
 13003 000029CF A3[9542]                		mov	[SDIRBUF],ax
 13004 000029D2 A3[4F42]                		mov	[DIRBUF],ax
 13005 000029D5 A3[0C42]                		mov	[DESTFCB],ax
 13006                                  
 13007 000029D8 A2[7544]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 13008                                  		
 13009 000029DB 48                      		dec	ax		; AX = 0FFFFh
 13010 000029DC A3[AD43]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 13011 000029DF A2[7B41]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 13012 000029E2 A2[B043]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 13013 000029E5 A2[5143]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 13014                                  		
 13015 000029E8 BE8100                  		mov	si,81h		; SI = ptr to command line
 13016                                  		;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 13017                                  		; 01/03/2023
 13018                                  		;mov	bl,'+'
 13019 000029EB B32B                    		mov	bl,plus_chr
 13020 000029ED FE06[8C44]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 13021 000029F1 C606[3B43]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 13022                                  
 13023                                  	;*	Scan the command line for destination information.
 13024                                  
 13025                                  DESTSCAN:
 13026 000029F6 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 13027 000029F8 BF[1344]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 13028                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 13029 000029FB E86208                  		call	CPARSE			; parse next object
 13030 000029FE 9C                      		pushf				; save CParse flags
 13031 000029FF FE06[7544]              		inc	byte [OBJCNT]		; count object
 13032 00002A03 F6C780                  		test	bh,80h
 13033 00002A06 7405                    		jz	short NOCOPY		; no "+" delimiter
 13034 00002A08 C606[7444]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 13035                                  NOCOPY:
 13036 00002A0D F6C701                  		test	bh,1
 13037 00002A10 740D                    		jz	short TESTP2		; not a switch
 13038                                  
 13039                                  	;	Found a switch.
 13040                                  
 13041                                  		; MSDOS 6.0
 13042                                  		;test	bp,SwitchV		;AN038; Verify requested?
 13043                                  		;jz	Not_SlashV		;AN038; No - set the switch
 13044                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 13045                                  		;jz	Not_SlashV		;AN038; No - set the switch
 13046                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 13047                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 13048                                  
 13049                                  NOT_SLASHV:
 13050 00002A12 092E[7141]              		or	[DESTSWITCH],bp		; assume destination
 13051 00002A16 092E[7341]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 13052                                  
 13053                                  		; MSDOS 6.0
 13054                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 13055                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 13056                                  		;popf				;AN018; fix up stack
 13057                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 13058                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 13059                                  		;jmp	CError			;AC018; exit
 13060                                  
 13061                                  NOT_BAD_SWITCH:
 13062 00002A1A 9D                      		popf				; restore CParse flags
 13063 00002A1B 7233                    		jc	short CHECKDONE		; found CR
 13064 00002A1D EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 13065                                  
 13066                                  TESTP2:
 13067 00002A1F 9D                      		popf				; restore CParse flags
 13068 00002A20 722E                    		jc	short CHECKDONE		; found CR
 13069 00002A22 F6C780                  		test	bh,80h
 13070 00002A25 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 13071 00002A27 FE06[6C41]              		inc	byte [ARGC]		; count independent pathname args
 13072                                  GOTPLUS:
 13073 00002A2B 56                      		push	si			; save cmd line ptr
 13074 00002A2C A1[7C44]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 13075 00002A2F BE[1344]                		mov	si,SCANBUF		; SI = ptr to path string
 13076 00002A32 29F0                    		sub	ax,si			; AX = offset of last element
 13077 00002A34 BF[5643]                		mov	di,DESTBUF		; DI = ptr to destination buf
 13078 00002A37 01F8                    		add	ax,di			; AX = ptr to last element in
 13079                                  						;  destination path buffer
 13080 00002A39 A3[5343]                		mov	[DESTTAIL],ax		; save ptr to last element
 13081 00002A3C 880E[5243]              		mov	[DESTSIZ],cl		; save path string length
 13082 00002A40 41                      		inc	cx			; CX = mov length (incl null)
 13083 00002A41 F3A4                    		rep movsb			; DestBuf = possible destination path
 13084 00002A43 883E[5543]              		mov	[DESTINFO],bh		; save CParse info flags
 13085 00002A47 C706[7141]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13086 00002A4D 5E                      		pop	si			; SI = ptr into cmd line again
 13087 00002A4E EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 13088                                  
 13089                                  CHECKDONE:
 13090                                  	;	We reached the CR. The destination scan is finished.
 13091                                  
 13092                                  	;	Disallow "copy file1+" as file overwriting itself.
 13093                                  	;
 13094                                  	;	(Note that "copy file1+file2+" will be accepted, and
 13095                                  	;	equivalent to "copy file1+file2".)
 13096                                  
 13097                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 13098                                  	;	through this check, since the switch would count
 13099                                  	;	as another object in ObjCnt.
 13100                                  
 13101 00002A50 803E[7444]01            		cmp	byte [PLUS],1		; "+" with
 13102 00002A55 7514                    		jnz	short CDCONT
 13103 00002A57 803E[6C41]01            		cmp	byte [ARGC],1		; one arg,
 13104 00002A5C 750D                    		jnz	short CDCONT
 13105 00002A5E 803E[7544]02            		cmp	byte [OBJCNT],2		; two objects..
 13106 00002A63 7506                    		jnz	short CDCONT
 13107 00002A65 BA[A437]                		mov	dx,OVERWRPTR
 13108 00002A68 E9A905                  		jmp	COPYERR			; is file overwrite
 13109                                  
 13110                                  CDCONT:
 13111 00002A6B A0[7444]                		mov	al,[PLUS]		; AL = '"+" occurred'
 13112 00002A6E A2[6B41]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 13113 00002A71 D0E0                    		shl	al,1
 13114 00002A73 D0E0                    		shl	al,1
 13115 00002A75 A2[6C44]                		mov	[INEXACT],al		; therefore making an inexact copy
 13116 00002A78 BA[7D3C]                		mov	dx,BADARGSPTR
 13117 00002A7B A0[6C41]                		mov	al,[ARGC]		; AL = # independent arguments
 13118 00002A7E 08C0                    		or	al,al
 13119 00002A80 7404                    		jz	short CERROR4J
 13120                                  
 13121                                  		; MSDOS 6.0
 13122                                  		;or	al,al
 13123                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 13124                                  		
 13125                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 13126                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 13127                                  		;jmp	short CError_ParseJ		; take parse error exit		
 13128                                  
 13129                                  	; more than 0 args; check if too many
 13130                                  
 13131                                  TRY_TOO_MANY:
 13132 00002A82 3C02                    		cmp	al,2
 13133 00002A84 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 13134                                  
 13135                                  		; MSDOS 6.0
 13136                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 13137                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 13138                                  ;CError_ParseJ:
 13139                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 13140                                  
 13141                                  CERROR4J:
 13142 00002A86 E95DF1                  		jmp	CERROR
 13143                                  
 13144                                  ACOUNTOK:
 13145 00002A89 BD[5143]                		mov	bp,DESTVARS		; BP = base of dest variables
 13146                                  
 13147 00002A8C 3C01                    		cmp	al,1
 13148 00002A8E 7520                    		jnz	short GOT2ARGS
 13149                                  
 13150                                  	;	Only one independent pathname argument on command line.
 13151                                  	;	Set destination to d:*.*, where d: is current drive.
 13152                                  
 13153                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 13154                                  	;	The two files would be appended as d:file1, rather than x:file1.
 13155                                  
 13156 00002A90 A0[6A41]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 13157                                  		;add	al,[CAPITAL_A]		; AL = current drive letter
 13158                                  		; 01/03/2023
 13159 00002A93 0441                    		add	al,capital_A  ; add al,'A'
 13160 00002A95 B43A                    		mov	ah,':'			; AX = "d:"
 13161                                  		;mov	byte [bp+1],2
 13162 00002A97 C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 13163                                  
 13164 00002A9B BF[5643]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 13165 00002A9E AB                      		stosw				; store "d:"
 13166                                  		
 13167 00002A9F C706[7141]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13168                                  		;mov	byte [bp+4],2		
 13169 00002AA5 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13170                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13171                                  		;mov	byte [bp+0],0		
 13172 00002AA9 C6460000                		mov	byte [bp],0
 13173 00002AAD E88107                  		call	SETSTARS		; add wildcards
 13174                                  GOT2ARGS:
 13175                                  	;	If destination pathname is "d:", add full wildcard filename
 13176                                  
 13177                                  		;cmp	byte [bp+1],2
 13178 00002AB0 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13179 00002AB4 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13180 00002AB6 B03A                    		mov	al,':'
 13181 00002AB8 3806[5743]              		cmp	[DESTBUF+1],al
 13182 00002ABC 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13183                                  		;or	byte [bp+4],2
 13184 00002ABE 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13185 00002AC2 BF[5843]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13186                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13187                                  		;mov	byte [bp+0],0		
 13188 00002AC5 C6460000                		mov	byte [bp],0
 13189 00002AC9 E86507                  		call	SETSTARS		; add wildcards
 13190                                  
 13191                                  NOTSHORTDEST:
 13192                                  	;	If destination pathname ends with "\", try to make
 13193                                  	;	sure it's "d:\".
 13194                                  
 13195                                  		;mov	di,[bp+2]
 13196 00002ACC 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13197 00002ACF 803D00                  		cmp	byte [di],0
 13198 00002AD2 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13199                                  
 13200 00002AD4 BA[863A]                		mov	dx,BADCDPTR
 13201 00002AD7 B03A                    		mov	al,':'
 13202 00002AD9 3845FE                  		cmp	[di-2],al
 13203 00002ADC 75A8                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13204                                  		;mov	byte [bp+0],2
 13205                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13206 00002ADE C6460002                		mov	byte [bp],2
 13207                                  		;or	byte [bp+4],6
 13208 00002AE2 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13209                                  						  ;  path character
 13210 00002AE6 E84807                  		call	SETSTARS		; add wildcards
 13211                                  CHKSWTCHES:
 13212                                  	;	We have enough information about the destination for now.
 13213                                  
 13214                                  	;	Turn on verify if requested. Save the current verify flag.
 13215                                  
 13216 00002AE9 BA[3239]                		mov	dx,BADPARMPTR
 13217 00002AEC A1[7341]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13218                                  
 13219                                  		; MSDOS 3.3
 13220                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13221 00002AEF A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13222 00002AF2 7592                    		jnz	short CERROR4J
 13223                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13224 00002AF4 A91000                  		test	ax,SWITCHV ; 10h
 13225 00002AF7 7414                    		jz	short NOVERIF		; no /v, no verify
 13226                                  
 13227 00002AF9 B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13228 00002AFB CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13229                                  					; Return: AL = 00h if flag OFF
 13230                                  					; AL = 01h if flag ON
 13231 00002AFD 1E                      		push	ds
 13232 00002AFE 8E1E[5641]              		mov	ds,[RESSEG]
 13233 00002B02 30E4                    		xor	ah,ah
 13234 00002B04 A3DF0B                  		mov	[VERVAL],ax	; save current verify flag
 13235 00002B07 1F                      		pop	ds
 13236 00002B08 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13237 00002B0B CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13238                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13239                                  NOVERIF:
 13240                                  		;*	Scan for first source.
 13241                                  
 13242 00002B0D 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13243 00002B0F BE8100                  		mov	si,81h			; SI = ptr into command line
 13244                                  		;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13245                                  		; 01/03/2023
 13246 00002B12 B32B                    		mov	bl,plus_chr  ; mov bl,'+'
 13247                                  SCANFSRC:
 13248 00002B14 BF[1344]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13249 00002B17 E84607                  		call	CPARSE			; parse first source pathname
 13250 00002B1A F6C701                  		test	bh,1			; switch?
 13251 00002B1D 75F5                    		jnz	short SCANFSRC		; yes, try again
 13252 00002B1F 092E[7141]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13253                                  
 13254                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13255                                  
 13256                                  		;test	bp,8
 13257 00002B23 F7C50800                		test	bp,SWITCHB
 13258 00002B27 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13259 00002B29 803E[6B41]00            		cmp	byte [CONCAT],0
 13260 00002B2E 7405                    		je	short NOSETCASC		; we're not concatenating
 13261                                  		;mov	byte [ASCII],4
 13262 00002B30 C606[7344]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13263                                  NOSETCASC:
 13264 00002B35 E88F03                  		call	SOURCE_SET		; set source variables
 13265 00002B38 E83B00                  		call	FRSTSRC			; set up first source copy
 13266 00002B3B E98C00                  		jmp	FIRSTENT		; jump into the copy loop
 13267                                  
 13268                                  ; ---------------------------------------------------------------------------
 13269                                  
 13270                                  ENDCOPY:
 13271                                  
 13272                                  	;*	End of the road. Close destination, display # files
 13273                                  	;	copied (meaning # destinations), and go back to main
 13274                                  	;	transient COMMAND code.
 13275                                  
 13276 00002B3E E8A002                  		call	CLOSEDEST
 13277                                  ENDCOPY2:
 13278 00002B41 BA[0E38]                		mov	dx,COPIEDPTR
 13279 00002B44 8B36[7E41]              		mov	si,[FILECNT]
 13280 00002B48 8936[3543]              		mov	[COPY_NUM],si
 13281 00002B4C E8C508                  		call	STD_PRINTF
 13282 00002B4F E9B2D5                  		jmp	TCOMMAND		; stack could be messed up
 13283                                  
 13284                                  ; ---------------------------------------------------------------------------
 13285                                  
 13286                                  SRCNONEXIST:
 13287                                  
 13288                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13289                                  	;	Otherwise, say 'file not found' and quit.
 13290                                  
 13291 00002B52 803E[6B41]00            		cmp	byte [CONCAT],0
 13292 00002B57 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13293                                  
 13294                                  		; MSDOS 3.3
 13295 00002B59 BA[B943]                		mov	dx,SRCBUF
 13296 00002B5C 8916[2D43]              		mov	[STRING_PTR_1],dx
 13297 00002B60 BA[3D36]                		mov	dx,STRINGBUF1PTR
 13298 00002B63 E8AE08                  		call	STD_PRINTF
 13299 00002B66 BA[0837]                		mov	dx,FNOTFOUNDPTR
 13300 00002B69 E9A804                  		jmp	COPYERR
 13301                                  
 13302                                  		; MSDOS 6.0
 13303                                  	;	Set up error message.
 13304                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13305                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13306                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13307                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13308                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13309                                  		;
 13310                                  		;jmp	CopErr			; print msg and clean up
 13311                                  
 13312                                  ; ---------------------------------------------------------------------------
 13313                                  
 13314                                  SOURCEPROC:
 13315                                  
 13316                                  	;*	Preparatory processing for each source file.
 13317                                  	;	Called at FrstSrc for first source file.
 13318                                  
 13319 00002B6C E85803                  		call	SOURCE_SET		; set source variables & ascii/binary
 13320 00002B6F 803E[6B41]00            		cmp	byte [CONCAT],0
 13321 00002B74 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13322                                  
 13323                                  ; ---------------------------------------------------------------------------
 13324                                  
 13325                                  FRSTSRC:
 13326 00002B76 31C0                    		xor	ax,ax
 13327 00002B78 A2[7541]                		mov	[CFLAG],al		; 'destination not created'
 13328 00002B7B A3[7941]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13329 00002B7E A2[7641]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13330                                  
 13331                                  LEAVECFLAG:
 13332 00002B81 8936[6A44]              		mov	[SRCPT],si		; save cmd-line ptr
 13333 00002B85 BF[3840]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13334                                  						;   current dir
 13335 00002B88 BD[B443]                		mov	bp,SRCVARS		; BP = base of source variables
 13336 00002B8B E8CD05                  		call	BUILDPATH		; cd to source dir, figure
 13337                                  						;   out stuff about source
 13338 00002B8E 8B36[B643]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13339 00002B92 C3                      		retn
 13340                                  
 13341                                  ; ---------------------------------------------------------------------------
 13342                                  
 13343                                  NEXTSRC:
 13344                                  
 13345                                  	;*	Next source. Come here after handling each pathname.
 13346                                  	;	We're done unless there are additional source pathnames
 13347                                  	;	to be appended.
 13348                                  	;
 13349                                  	;	Note that all files matching an ambiguous pathname
 13350                                  	;	are processed before coming here.
 13351                                  
 13352 00002B93 803E[7444]00            		cmp	byte [PLUS],0
 13353                                  		;jne	short MORECP		; copying "+" sources - keep going
 13354                                  		; 01/03/2023
 13355 00002B98 74A4                    		je	short ENDCOPY
 13356                                  ;ENDCOPYJ2:
 13357                                  		;jmp	short ENDCOPY
 13358                                  MORECP:
 13359 00002B9A 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13360 00002B9C 8B36[6A44]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13361                                  		;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13362                                  		; 01/03/2023
 13363 00002BA0 B32B                    		mov	bl,plus_chr ; mov bl,'+'
 13364                                  SCANSRC:
 13365 00002BA2 BF[1344]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13366 00002BA5 E8B806                  		call	CPARSE			; parse first source name
 13367                                  		;jb	short ENDCOPYJ2		; CR found - we're done
 13368                                  		; 01/03/2023
 13369 00002BA8 7294                    		jb	short ENDCOPY
 13370                                  
 13371 00002BAA F6C780                  		test	bh,80h
 13372                                  		;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13373                                  		; 01/03/2023
 13374 00002BAD 748F                    		jz	short ENDCOPY
 13375                                  
 13376 00002BAF F6C701                  		test	bh,1
 13377 00002BB2 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13378                                  
 13379                                  	;	ScanBuf contains the next source pathname.
 13380                                  
 13381 00002BB4 E8B5FF                  		call	SOURCEPROC		; prepare this source
 13382 00002BB7 803E[AB42]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13383 00002BBC 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13384 00002BBE C606[AC42]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13385 00002BC3 EB8D                    		jmp	short SRCNONEXIST	; we know we won't find it
 13386                                  NOSTAMP:
 13387 00002BC5 C606[AC42]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13388                                  
 13389                                  ; ---------------------------------------------------------------------------
 13390                                  
 13391                                  FIRSTENT:
 13392                                  
 13393                                  ;M047
 13394                                  ; The only case we need to worry about is when the source is wildcarded and
 13395                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13396                                  ;concatenation. We check for this case.
 13397                                  ;
 13398                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13399                                  ;right place to do this check.
 13400                                  
 13401                                  	;	This is where we enter the loop with the first source.
 13402                                  
 13403 00002BCA BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13404 00002BCD B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13405 00002BD0 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13406                                  					; DS:SI	-> string to parse
 13407                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13408                                  					; AL = bit mask	to control parsing
 13409 00002BD2 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13410 00002BD5 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13411 00002BD7 A1[B943]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13412 00002BDA 80FC3A                  		cmp	ah,':'
 13413 00002BDD 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13414 00002BDF B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13415                                  DRVSPEC1:
 13416 00002BE1 0C20                    		or	al,20h			; AL = lowercase drive letter
 13417 00002BE3 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13418                                  		;mov	[5Ch],al
 13419 00002BE5 A25C00                  		mov	[FCB],al		; put drive id in FCB
 13420                                  
 13421                                  	;	FCB contains drive and filename to search.
 13422                                  		
 13423 00002BE8 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13424 00002BEA E80301                  		call	SEARCH
 13425                                  SRCHDONE:
 13426 00002BED 9C                      		pushf				; save flags from Search
 13427 00002BEE E86BEC                  		call	RESTUDIR1		; restore users current directory
 13428 00002BF1 9D                      		popf				; restore flags from search
 13429 00002BF2 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13430 00002BF4 E95BFF                  		jmp	SRCNONEXIST		; didn't find the source
 13431                                  
 13432                                  NEXTAMBIG0:
 13433 00002BF7 30C0                    		xor	al,al
 13434 00002BF9 8606[7B41]              		xchg	al,[FRSTSRCH]
 13435 00002BFD 08C0                    		or	al,al
 13436 00002BFF 740B                    		jz	short NEXTAMBIG
 13437                                  SETNMEL:
 13438 00002C01 B90C00                  		mov	cx,12
 13439 00002C04 BF[9542]                		mov	di,SDIRBUF
 13440 00002C07 BE[4F42]                		mov	si,DIRBUF
 13441 00002C0A F3A4                    		rep movsb			; save very first source name
 13442                                  NEXTAMBIG:
 13443 00002C0C 30C0                    		xor	al,al
 13444 00002C0E A2[6E44]                		mov	[NOWRITE],al		; turn off nowrite
 13445 00002C11 8B3E[B643]              		mov	di,[SRCTAIL]
 13446 00002C15 BE[5042]                		mov	si,DIRBUF+1
 13447 00002C18 E846ED                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13448                                  MELDO:
 13449 00002C1B 803E[6B41]00            		cmp	byte [CONCAT],0
 13450 00002C20 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13451 00002C22 F606[B843]02            		test	byte [SRCINFO],2	; wildcard - show name
 13452 00002C27 7410                    		jz	short DOREAD
 13453                                  SHOWCPNAM:
 13454 00002C29 BA[B943]                		mov	dx,SRCBUF
 13455 00002C2C 8916[3343]              		mov	[STRING_PTR_2],dx
 13456 00002C30 BA[4F36]                		mov	dx,STRINGBUF2PTR
 13457 00002C33 E8DE07                  		call	STD_PRINTF
 13458 00002C36 E8FCEC                  		call	CRLF2
 13459                                  DOREAD:
 13460 00002C39 E8C500                  		call	DOCOPY
 13461 00002C3C 803E[6B41]00            		cmp	byte [CONCAT],0
 13462 00002C41 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13463                                  
 13464 00002C43 E89B01                  		call	CLOSEDEST		; close current destination
 13465 00002C46 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13466                                  
 13467 00002C48 C606[7541]00            		mov	byte [CFLAG],0		; 'destination not created'
 13468                                  NODCLOSE:
 13469 00002C4D 803E[6B41]00            		cmp	byte [CONCAT],0		
 13470 00002C52 740A                    		jz	short NOFLUSH
 13471                                  
 13472                                  ;	Concatenating - flush output between source files so LostErr
 13473                                  ;	stuff works correctly.
 13474                                  
 13475                                  		;invoke	FlshFil  ; MSDOS 6.0
 13476                                  
 13477 00002C54 E8A502                  		call	FLUSHFIL ; MSDOS 3.3
 13478 00002C57 F606[B143]FF            		test	byte [MELCOPY],0FFh
 13479                                  		;jz	short NOFLUSH
 13480                                  		;jmp	short DOMELCOPY
 13481                                  		; 01/03/2023
 13482 00002C5C 750C                    		jnz	short DOMELCOPY
 13483                                  NOFLUSH:
 13484 00002C5E E88300                  		call	SEARCHNEXT		; try next match
 13485 00002C61 755D                    		jnz	short NEXTSRCJ		; not found - finished with 
 13486                                  						;   this source spec
 13487 00002C63 C606[7641]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13488                                  
 13489 00002C68 EBA2                    		jmp	short NEXTAMBIG		; do next ambig match
 13490                                  DOMELCOPY:
 13491 00002C6A 803E[B143]FF            		cmp	byte [MELCOPY],0FFh
 13492 00002C6F 740D                    		je	short CONTMEL
 13493 00002C71 8B36[6A44]              		mov	si,[SRCPT]
 13494 00002C75 8936[B243]              		mov	[MELSTART],si
 13495 00002C79 C606[B143]FF            		mov	byte [MELCOPY],0FFh
 13496                                  CONTMEL:
 13497 00002C7E 31ED                    		xor	bp,bp
 13498 00002C80 8B36[6A44]              		mov	si,[SRCPT]
 13499                                  		;mov	bl,[PLUS_CHR]
 13500                                  		; 01/03/2023
 13501 00002C84 B32B                    		mov	bl,plus_chr ; mov bl,'+'
 13502                                  SCANSRC2:
 13503 00002C86 BF[1344]                		mov	di,SCANBUF
 13504 00002C89 E8D405                  		call	CPARSE
 13505 00002C8C F6C780                  		test	bh,80h
 13506 00002C8F 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13507 00002C91 F6C701                  		test	bh,1
 13508 00002C94 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13509 00002C96 E8D3FE                  		call	SOURCEPROC
 13510 00002C99 E8C0EB                  		call	RESTUDIR1
 13511 00002C9C BF[D041]                		mov	di,DESTFCB2
 13512 00002C9F B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13513 00002CA2 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13514                                  					; DS:SI	-> string to parse
 13515                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13516                                  					; AL = bit mask	to control parsing
 13517 00002CA4 BB[9642]                		mov	bx,SDIRBUF+1
 13518 00002CA7 BE[D141]                		mov	si,DESTFCB2+1
 13519 00002CAA 8B3E[B643]              		mov	di,[SRCTAIL]
 13520                                  
 13521 00002CAE E87A04                  		call	BUILDNAME
 13522                                  
 13523 00002CB1 803E[6B41]00            		cmp	byte [CONCAT],0
 13524 00002CB6 7405                    		je	short MELDOJ		; not concatenating - continue
 13525                                  
 13526                                  	;	Yes, turn off nowrite because this part of the code 
 13527                                  	;	is only reached after the first file has been dealt with.
 13528                                  
 13529 00002CB8 C606[6E44]00            		mov	byte [NOWRITE],0
 13530                                  MELDOJ:
 13531 00002CBD E95BFF                  		jmp	MELDO
 13532                                  
 13533                                  NEXTSRCJ:
 13534 00002CC0 E9D0FE                  		jmp	NEXTSRC
 13535                                  
 13536                                  NEXTMEL:
 13537 00002CC3 E81B01                  		call	CLOSEDEST
 13538 00002CC6 31C0                    		xor	ax,ax
 13539 00002CC8 A2[7541]                		mov	[CFLAG],al
 13540 00002CCB A3[7941]                		mov	[NXTADD],ax
 13541 00002CCE A2[7641]                		mov	[SPECDRV],al
 13542 00002CD1 8B36[B243]              		mov	si,[MELSTART]
 13543 00002CD5 8936[6A44]              		mov	[SRCPT],si
 13544 00002CD9 E80800                  		call	SEARCHNEXT
 13545 00002CDC 7403                    		jz	short SETNMELJ
 13546 00002CDE E960FE                  		jmp	ENDCOPY2
 13547                                  
 13548                                  SETNMELJ:
 13549 00002CE1 E91DFF                  		jmp	SETNMEL
 13550                                  
 13551                                  ; ---------------------------------------------------------------------------
 13552                                  
 13553                                  SEARCHNEXT:
 13554 00002CE4 B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13555 00002CE6 F606[B843]02            		test	byte [SRCINFO],2
 13556 00002CEB 7503                    		jnz	short SEARCH		; do search-next if ambig
 13557 00002CED 08E4                    		or	ah,ah			; reset zero flag
 13558 00002CEF C3                      		retn
 13559                                  
 13560                                  ; ---------------------------------------------------------------------------
 13561                                  
 13562                                  SEARCH:
 13563 00002CF0 50                      		push	ax
 13564 00002CF1 B41A                    		mov	ah,SET_DMA ; 1Ah
 13565 00002CF3 BA[4F42]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13566 00002CF6 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13567                                  				; DS:DX	-> disk	transfer buffer
 13568 00002CF8 58                      		pop	ax		; restore search first/next command
 13569 00002CF9 BA5C00                  		mov	dx,FCB ; 5Ch
 13570 00002CFC CD21                    		int	21h		; Do the search
 13571 00002CFE 08C0                    		or	al,al
 13572 00002D00 C3                      		retn
 13573                                  
 13574                                  ; ---------------------------------------------------------------------------
 13575                                  
 13576                                  DOCOPY:
 13577 00002D01 BE[B943]                		mov	si,SRCBUF	; do name translate of source
 13578 00002D04 BF[843E]                		mov	di,SRCXNAME	; save for name comparison
 13579 00002D07 B460                    		mov	ah,XNAMETRANS ; 60h
 13580 00002D09 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13581                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13582                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13583 00002D0B C606[6941]00            		mov	byte [RDEOF],0	; no EOF yet
 13584                                  
 13585                                  		; MSDOS 6.0
 13586                                  		;mov	ax,EXTOPEN shl 8	; open the file
 13587                                  ;M046
 13588                                  ; For reads, the sharing mode should be deny none so that any process can
 13589                                  ;open this file again in any other sharing mode. This is mainly to allow
 13590                                  ;multiple command.com's to access the same file without getting sharing
 13591                                  ;violations
 13592                                  ;
 13593                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE
 13594                                  						; open mode for COPY ;M046
 13595                                  		;xor	cx,cx			; no special files
 13596                                  		;mov	dx,READ_OPEN_FLAG	; set up open flags
 13597                                  		;int	21h
 13598                                  		;
 13599                                  		;jnc	OpenOk
 13600                                  
 13601                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 13602                                  	;	They asked for it...
 13603                                  
 13604                                  		;jmp	short Error_On_Source 	;AC022; clean up and exit
 13605                                  
 13606                                  		; MSDOS 3.3
 13607 00002D10 BA[B943]                		mov	dx,SRCBUF
 13608 00002D13 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13609 00002D16 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13610                                  					; DS:DX	-> ASCIZ filename
 13611                                  					; AL = access mode
 13612                                  					; 0 - read
 13613 00002D18 7311                    		jnc	short OPENOK
 13614 00002D1A E858F1                  		call	GET_EXT_ERR_NUMBER
 13615 00002D1D 9C                      		pushf
 13616 00002D1E 83F841                  		cmp	ax,65
 13617 00002D21 7506                    		jnz	short DOCOPY_ERR
 13618 00002D23 BA[2D37]                		mov	dx,ACCDENPTR
 13619 00002D26 E8EB06                  		call	STD_PRINTF
 13620                                  DOCOPY_ERR:
 13621 00002D29 9D                      		popf
 13622 00002D2A C3                      		retn
 13623                                  
 13624                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13625                                  OPENOK:
 13626 00002D2B 89C3                    		mov	bx,ax
 13627 00002D2D 891E[1044]              		mov	[SRCHAND],bx		; save handle
 13628 00002D31 B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13629 00002D34 CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13630                                  					; BX = file handle
 13631                                  
 13632                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13633                                  
 13634 00002D36 8916[7644]              		mov	[CPDATE],dx		; save date
 13635 00002D3A 890E[7844]              		mov	[CPTIME],cx		; save time
 13636                                  
 13637                                  		; MSDOS 6.0
 13638                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13639                                  
 13640                                  ;Error_On_Source:				;AN022; we have a BAD error
 13641                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13642                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13643                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13644                                  		;invoke	Std_EprintF		;AN022; print it
 13645                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13646                                  		;je	No_Close_Src		;AN022; no - don't close
 13647                                  		;call	CloseSrc		;AN022; clean up
 13648                                  ;No_Close_Src:					;AN022;
 13649                                  		;cmp	CFlag,0			;AN022; was destination created?
 13650                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13651                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13652                                  ;EndCopyJ3:					;AN022;
 13653                                  		;jmp	EndCopy2		;AN022;
 13654                                  ;No_Copy_Xa:
 13655                                  		;mov	bx,SrcHand		;AN022; get handle back
 13656                                  
 13657                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13658 00002D3E B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13659 00002D41 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13660                                  					; BX = file or device handle
 13661 00002D43 80E280                  		and	dl,devid_ISDEV ; 80h
 13662 00002D46 8816[1244]              		mov	[SRCISDEV],dl		; set source info
 13663 00002D4A 740D                    		jz	short COPYLP		; source not a device
 13664 00002D4C 803E[6F44]00            		cmp	byte [BINARY],0
 13665 00002D51 7406                    		je	short COPYLP		; ascii device ok
 13666 00002D53 BA[0B3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13667 00002D56 E9BB02                  		jmp	COPYERR
 13668                                  
 13669                                  COPYLP:
 13670 00002D59 8B1E[1044]              		mov	bx,[SRCHAND]
 13671 00002D5D 8B0E[7741]              		mov	cx,[BYTCNT]
 13672 00002D61 8B16[7941]              		mov	dx,[NXTADD]
 13673 00002D65 29D1                    		sub	cx,dx			; compute available space
 13674 00002D67 750E                    		jnz	short GOTROOM
 13675                                  		;invoke	FlshFil   ; MSDOS 6.0
 13676 00002D69 E89001                  		call	FLUSHFIL  ; MSDOS 3.3
 13677 00002D6C 803E[7244]00            		cmp	byte [TERMREAD],0
 13678 00002D71 7565                    		jne	short CLOSESRC		; give up
 13679 00002D73 8B0E[7741]              		mov	cx,[BYTCNT]
 13680                                  GOTROOM:
 13681 00002D77 1E                      		push	ds
 13682 00002D78 8E1E[5841]              		mov	ds,[TPA]
 13683 00002D7C B43F                    		mov	ah,READ ; 3Fh
 13684 00002D7E CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13685                                  					; BX = file handle,CX = number	of bytes to read
 13686                                  					; DS:DX	-> buffer
 13687 00002D80 1F                      		pop	ds
 13688 00002D81 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13689                                  		;jc	Error_On_Source ; MSDOS 6.0
 13690 00002D83 89C1                    		mov	cx,ax			; get count
 13691 00002D85 E351                    		jcxz	CLOSESRC		; no more to read
 13692 00002D87 803E[1244]00            		cmp	byte [SRCISDEV],0
 13693 00002D8C 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13694 00002D8E 803E[7344]00            		cmp	byte [ASCII],0
 13695 00002D93 741B                    		je	short BINREAD
 13696                                  NOTESTA:
 13697 00002D95 89CA                    		mov	dx,cx
 13698 00002D97 8B3E[7941]              		mov	di,[NXTADD]
 13699 00002D9B B01A                    		mov	al,1Ah
 13700 00002D9D 06                      		push	es
 13701 00002D9E 8E06[5841]              		mov	es,[TPA]		; scan for EOF
 13702 00002DA2 F2AE                    		repne scasb
 13703 00002DA4 07                      		pop	es
 13704 00002DA5 7505                    		jnz	short USEALL
 13705 00002DA7 FE06[6941]              		inc	byte [RDEOF]
 13706 00002DAB 41                      		inc	cx
 13707                                  USEALL:
 13708 00002DAC 29CA                    		sub	dx,cx
 13709 00002DAE 89D1                    		mov	cx,dx
 13710                                  BINREAD:
 13711 00002DB0 030E[7941]              		add	cx,[NXTADD]
 13712 00002DB4 890E[7941]              		mov	[NXTADD],cx
 13713 00002DB8 3B0E[7741]              		cmp	cx,[BYTCNT]		; is buffer full?
 13714 00002DBC 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13715                                  		;invoke	FlshFil
 13716 00002DBE E83B01                  		call	FLUSHFIL
 13717 00002DC1 803E[7244]00            		cmp	byte [TERMREAD],0
 13718 00002DC6 7510                    		jne	short CLOSESRC		; give up
 13719 00002DC8 EB8F                    		jmp	short COPYLP
 13720                                  TESTDEV:
 13721 00002DCA 803E[1244]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13722 00002DCF 7407                    		je	short CLOSESRC
 13723 00002DD1 803E[6941]00            		cmp	byte [RDEOF],0
 13724 00002DD6 7481                    		je	short COPYLP		; on device, go till ^Z
 13725                                  CLOSESRC:
 13726 00002DD8 8B1E[1044]              		mov	bx,[SRCHAND]
 13727 00002DDC B43E                    		mov	ah,CLOSE ; 3Eh
 13728 00002DDE CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13729                                  					; BX = file handle
 13730                                  CLOSESRCDEST_RETN:
 13731 00002DE0 C3                      		retn
 13732                                  
 13733                                  ; ---------------------------------------------------------------------------
 13734                                  
 13735                                  CLOSEDEST:
 13736                                  
 13737                                  	;	We are called to close the destination.
 13738                                  	;	We need to note whether or not there is any internal data left
 13739                                  	;	to be flushed out.
 13740                                  
 13741 00002DE1 803E[7641]00            		cmp	byte [DESTCLOSED],0
 13742 00002DE6 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13743 00002DE8 A0[7141]                		mov	al,[DESTSWITCH]
 13744 00002DEB E86502                  		call	SETASC			; check for b or a switch
 13745 00002DEE 7434                    		jz	short BINCLOS		;   on destination
 13746 00002DF0 8B1E[7941]              		mov	bx,[NXTADD]
 13747                                  ;
 13748                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13749                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13750                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13751                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13752                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13753                                  ;performance overhead on single ASCII file copies which now always involve
 13754                                  ;2 writes instead of 1 before. Is this really that important?
 13755                                  ;
 13756                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13757                                  ;M048;	jne	PutZ
 13758                                  
 13759                                  		; MSDOS 3.3
 13760 00002DF4 3B1E[7741]              		cmp	bx,[BYTCNT]	; is memory full?
 13761 00002DF8 7509                    		jne	short PUTZ
 13762                                  
 13763 00002DFA E8F200                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13764 00002DFD 7402                    		jz	short NOCONC
 13765                                  CONCHNG:
 13766 00002DFF F9                      		stc
 13767 00002E00 C3                      		retn
 13768                                  
 13769                                  NOCONC:	
 13770 00002E01 31DB                    		xor	bx,bx
 13771                                  PUTZ:
 13772 00002E03 1E                      		push	ds
 13773 00002E04 8E1E[5841]              		mov	ds,[TPA]
 13774 00002E08 C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13775 00002E0C 1F                      		pop	ds
 13776 00002E0D FF06[7941]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13777 00002E11 C606[6E44]00            		mov	byte [NOWRITE],0
 13778 00002E16 A1[7044]                		mov	ax,[WRITTEN]
 13779 00002E19 0306[7941]              		add	ax,[NXTADD]
 13780 00002E1D 7205                    		jc	short BINCLOS	; > 1
 13781 00002E1F 83F801                  		cmp	ax,1
 13782 00002E22 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13783                                  BINCLOS:
 13784 00002E24 E8C800                  		call	TRYFLUSH
 13785 00002E27 75D6                    		jnz	short CONCHNG
 13786                                  
 13787 00002E29 803E[7044]00            		cmp	byte [WRITTEN],0
 13788                                  FORGETITJ:
 13789 00002E2E 747D                    		jz	short FORGETIT	; never wrote nothing
 13790                                  NO_FORGET:				; wrote something
 13791 00002E30 8B1E[AD43]              		mov	bx,[DESTHAND]
 13792 00002E34 8B0E[7844]              		mov	cx,[CPTIME]
 13793 00002E38 8B16[7644]              		mov	dx,[CPDATE]
 13794 00002E3C 803E[6C44]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13795 00002E41 7431                    		je	short DODCLOSE	; if no, copy date & time
 13796 00002E43 B42C                    		mov	ah,GET_TIME ; 2Ch
 13797 00002E45 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13798                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13799                                  					; DL = hundredths of seconds
 13800 00002E47 D0E1                    		shl	cl,1
 13801 00002E49 D0E1                    		shl	cl,1		; left justify min in cl
 13802 00002E4B D1E1                    		shl	cx,1
 13803 00002E4D D1E1                    		shl	cx,1
 13804 00002E4F D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13805 00002E51 D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13806 00002E53 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13807 00002E55 51                      		push	cx		; save packed time
 13808 00002E56 B42A                    		mov	ah,GET_DATE ; 2Ah
 13809 00002E58 CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13810                                  					; Return: DL = day,DH = month,	CX = year
 13811                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13812 00002E5A 81E9BC07                		sub	cx,1980
 13813 00002E5E 86E9                    		xchg	ch,cl
 13814 00002E60 D1E1                    		shl	cx,1		; year to high 7 bits
 13815 00002E62 D0E6                    		shl	dh,1		; month to high 3 bits
 13816 00002E64 D0E6                    		shl	dh,1
 13817 00002E66 D0E6                    		shl	dh,1
 13818 00002E68 D0E6                    		shl	dh,1
 13819 00002E6A D0E6                    		shl	dh,1		; most sig bit of month in carry
 13820 00002E6C 80D500                  		adc	ch,0		; put that bit next to year
 13821 00002E6F 08F2                    		or	dl,dh		; or low three of month into day
 13822 00002E71 88EE                    		mov	dh,ch		; get year and high bit of month
 13823 00002E73 59                      		pop	cx
 13824                                  DODCLOSE:
 13825 00002E74 83FB00                  		cmp	bx,0
 13826 00002E77 7E2A                    		jle	short CLOSEDONE
 13827 00002E79 B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13828 00002E7C CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13829                                  					; BX = file handle,CX = time to be set
 13830                                  					; DX = date to be set
 13831                                  		; MSDOS 6.0
 13832                                  		;jc	Cleanup_Err	;AN022; handle error
 13833                                  
 13834                                  	;	See if the destination has *anything* in it.
 13835                                  	;	If not, just close and delete it.
 13836                                  
 13837 00002E7E B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13838 00002E81 31D2                    		xor	dx,dx
 13839 00002E83 89D1                    		mov	cx,dx
 13840 00002E85 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13841                                  					; AL = method: offset from end of file
 13842                                  	;	DX:AX is file size
 13843                                  
 13844 00002E87 09C2                    		or	dx,ax
 13845 00002E89 9C                      		pushf
 13846 00002E8A B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13847 00002E8D CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13848                                  					; BX = file or device handle
 13849 00002E8F 52                      		push	dx			; save them away
 13850 00002E90 B43E                    		mov	ah,CLOSE ; 3Eh
 13851 00002E92 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13852                                  					; BX = file handle
 13853 00002E94 5A                      		pop	dx
 13854                                  
 13855                                  		; MSDOS 6.0
 13856                                  		;jnc	Close_Cont	;AN022; handle error on close
 13857                                  		;popf			;AN022; get the flags back
 13858                                  ;Cleanup_Err: 				;AN022;
 13859                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13860                                  		;call	DestDelete	;AN022; attempt to delete the target
 13861                                  		;jmp	short FileClosed ;AN022; close the file
 13862                                  ;Close_Cont:				;AN022; no error - co
 13863                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13864 00002E95 9D                      		popf
 13865 00002E96 750B                    		jnz	short CLOSEDONE
 13866 00002E98 F7C28000                		test	dx,80h		; is the destination a device?
 13867 00002E9C 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13868 00002E9E E81E00                  		call	DESTDELETE
 13869 00002EA1 EB04                    		jmp	short FILECLOSED
 13870                                  CLOSEDONE:
 13871 00002EA3 FF06[7E41]              		inc	word [FILECNT]
 13872                                  FILECLOSED:
 13873 00002EA7 FE06[7641]              		inc	byte [DESTCLOSED]
 13874                                  RET50:
 13875 00002EAB F8                      		clc
 13876 00002EAC C3                      		retn
 13877                                  FORGETIT:
 13878 00002EAD 8B1E[AD43]              		mov	bx,[DESTHAND]
 13879 00002EB1 E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13880 00002EB4 E80800                  		call	DESTDELETE
 13881 00002EB7 C706[7E41]0000          		mov	word [FILECNT],0 ; no files transferred
 13882 00002EBD EBEC                    		jmp	short RET50
 13883                                  
 13884                                  ; ---------------------------------------------------------------------------
 13885                                  
 13886                                  DESTDELETE:
 13887 00002EBF BA[5643]                		mov	dx,DESTBUF
 13888 00002EC2 B441                    		mov	ah,UNLINK ; 41h
 13889 00002EC4 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13890                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13891                                  				;		(no wildcards allowed)
 13892 00002EC6 C3                      		retn
 13893                                  
 13894                                  ; ---------------------------------------------------------------------------
 13895                                  
 13896                                  SOURCE_SET:
 13897 00002EC7 56                      		push	si
 13898 00002EC8 A1[7C44]                		mov	ax,[STARTEL]
 13899 00002ECB BE[1344]                		mov	si,SCANBUF	; adjust to copy
 13900 00002ECE 29F0                    		sub	ax,si
 13901 00002ED0 BF[B943]                		mov	di,SRCBUF
 13902 00002ED3 01F8                    		add	ax,di
 13903 00002ED5 A3[B643]                		mov	[SRCTAIL],ax
 13904 00002ED8 880E[B543]              		mov	[SRCSIZ],cl	; save its size
 13905 00002EDC 41                      		inc	cx		; include the nul
 13906 00002EDD F3A4                    		rep movsb		; save this source
 13907 00002EDF 883E[B843]              		mov	[SRCINFO],bh	; save info about it
 13908 00002EE3 5E                      		pop	si
 13909 00002EE4 89E8                    		mov	ax,bp		; switches so far
 13910 00002EE6 E86A01                  		call	SETASC		; set a,b switches accordingly
 13911 00002EE9 E885EB                  		call	SWITCH		; get any more switches on this arg
 13912                                  		;call	SETASC		; set
 13913                                  		;retn
 13914                                  		; 02/03/2023
 13915 00002EEC E96401                  		jmp	SETASC
 13916                                  
 13917                                  ; =============== S U B	R O U T	I N E =======================================
 13918                                  
 13919                                  ; MSDOS 6.0
 13920                                  
 13921                                  ;****************************************************************
 13922                                  ;*
 13923                                  ;* ROUTINE:	CleanupErr
 13924                                  ;*
 13925                                  ;* FUNCTION:	Issues extended error message for destination
 13926                                  ;*		if not alreay issued
 13927                                  ;*
 13928                                  ;* INPUT:	return from INT 21
 13929                                  ;*
 13930                                  ;* OUTPUT:	none
 13931                                  ;*
 13932                                  ;****************************************************************
 13933                                  
 13934                                  ;CleanupErr	proc	near		;AN022;
 13935                                  ;
 13936                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13937                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13938                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13939                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13940                                  ;					;AN022; get address of failed string
 13941                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13942                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13943                                  ;
 13944                                  ;CleanupErr_Cont:			;AN022;
 13945                                  ;	ret				;AN022; return to caller
 13946                                  ;
 13947                                  ;CleanupErr	endp			;AN022;
 13948                                  
 13949                                  ;============================================================================
 13950                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13951                                  ;============================================================================
 13952                                  ; 01/10/2018 - Retro DOS v3.0
 13953                                  
 13954                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13955                                  
 13956                                  ; =============== S U B	R O U T	I N E =======================================
 13957                                  
 13958                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13959                                  ;
 13960                                  ;	EXIT	ZR set if concatenate flag unchanged
 13961                                  
 13962                                  TRYFLUSH:
 13963 00002EEF A0[6B41]                		mov	al,[CONCAT]
 13964 00002EF2 50                      		push	ax
 13965 00002EF3 E80600                  		call	FLUSHFIL
 13966 00002EF6 58                      		pop	ax
 13967 00002EF7 3A06[6B41]              		cmp	al,[CONCAT]
 13968 00002EFB C3                      		retn
 13969                                  
 13970                                  ; =============== S U B	R O U T	I N E =======================================
 13971                                  
 13972                                  FLUSHFIL:
 13973 00002EFC A0[6F44]                		mov	al,[BINARY]
 13974 00002EFF 8A26[7344]              		mov	ah,[ASCII]
 13975 00002F03 50                      		push	ax
 13976 00002F04 E80900                  		call	FLSHFIL
 13977 00002F07 58                      		pop	ax
 13978 00002F08 8826[7344]              		mov	[ASCII],ah
 13979 00002F0C A2[6F44]                		mov	[BINARY],al
 13980 00002F0F C3                      		retn
 13981                                  
 13982                                  ; =============== S U B	R O U T	I N E =======================================
 13983                                  
 13984                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13985                                  ;
 13986                                  ;	Inputs:
 13987                                  ;	  [NXTADD] = No. of bytes to write
 13988                                  ;	  [CFLAG] <> 0 if file has been created
 13989                                  ;	Outputs:
 13990                                  ;	  [NXTADD] = 0
 13991                                  
 13992                                  FLSHFIL:
 13993 00002F10 C606[7244]00            		mov	byte [TERMREAD],0
 13994 00002F15 803E[7541]00            		cmp	byte [CFLAG],0
 13995 00002F1A 7403                    		jz	short NOTEXISTS
 13996 00002F1C E98300                  		jmp	EXISTS
 13997                                  
 13998                                  NOTEXISTS:
 13999 00002F1F E84B01                  		call	BUILDDEST	; find out all about the destination
 14000 00002F22 E82803                  		call	COMPNAME	; source and dest. the same?
 14001 00002F25 7516                    		jnz	short PROCDEST	; if not, go ahead
 14002 00002F27 803E[1244]00            		cmp	byte [SRCISDEV],0
 14003 00002F2C 750F                    		jnz	short PROCDEST	; same name on device ok
 14004 00002F2E 803E[6B41]00            		cmp	byte [CONCAT],0	; concatenation?
 14005 00002F33 BA[A437]                		mov	dx,OVERWRPTR
 14006 00002F36 745E                    		je	short COPERR	; not concatenating - overwrite error
 14007                                  		
 14008                                  ;No_Concat_Err:	; concatenating
 14009 00002F38 C606[6E44]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 14010                                  PROCDEST:
 14011                                  		; MSDOS 6.0
 14012                                  		;mov	ax,EXTOPEN shl 8		; open the file
 14013                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 14014                                  ;M046
 14015                                  ; For writes, we want to deny writes by anyone else at the same time that we
 14016                                  ;are writing to it. For instance, on a network, 2 workstations could try
 14017                                  ;writing to the same file. Also, because we opened the source file with
 14018                                  ;DENY NONE, it is fine if the source and destination files are the same as
 14019                                  ;would happen when we append to an existing file.
 14020                                  ;
 14021                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 14022                                  		;xor	cx,cx				; no special files
 14023                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 14024                                  		;
 14025                                  		;cmp	NoWrite,0
 14026                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 14027                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 14028                                  
 14029 00002F3D B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 14030 00002F40 803E[6E44]00            		cmp	byte [NOWRITE],0
 14031 00002F45 7504                    		jne	short DODESTOPEN
 14032 00002F47 B43C                    		mov	ah,CREAT ; 3Ch
 14033 00002F49 31C9                    		xor	cx,cx
 14034                                  DODESTOPEN:
 14035 00002F4B BA[5643]                		mov	dx,DESTBUF
 14036 00002F4E CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 14037                                  				; CX = attributes for file
 14038                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 14039                                  		
 14040                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 14041                                  		;mov	dx,FULDIRPTR
 14042                                  		;call	GET_EXT_ERR_NUMBER
 14043                                  		;jc	short COPERR
 14044                                  
 14045                                  		; 01/10/2018
 14046                                  		;jnc	short DEST_OPEN_OKAY
 14047                                  		
 14048                                  		;mov	dx,FULDIRPTR
 14049                                  		;call	GET_EXT_ERR_NUMBER
 14050                                  		;jmp	short COPERR
 14051                                  
 14052 00002F50 723E                    		jc	short DEST_OPEN_ERROR
 14053                                  ;DEST_OPEN_OKAY:
 14054 00002F52 A3[AD43]                		mov	[DESTHAND],ax	; save handle
 14055 00002F55 C606[7541]01            		mov	byte [CFLAG],1	; destination now exists
 14056 00002F5A 89C3                    		mov	bx,ax
 14057 00002F5C B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 14058 00002F5F CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 14059                                  				   	; BX = file or device handle
 14060                                  
 14061 00002F61 8816[AF43]              		mov	[DESTISDEV],dl	; set dest info
 14062                                  		;test	dl,80h
 14063 00002F65 F6C280                  		test	dl,devid_ISDEV
 14064 00002F68 7438                    		jz	short EXISTS	; Dest not a device
 14065                                  
 14066                                  ;	Destination is device.
 14067                                  
 14068 00002F6A A0[7141]                		mov	al,[DESTSWITCH]
 14069                                  		;and	al,0Ch
 14070 00002F6D 240C                    		and	al,SWITCHA+SWITCHB
 14071 00002F6F 7509                    		jnz	short TESTBOTH
 14072 00002F71 A0[7344]                		mov	al,[ASCII]	; neither set, use current setting
 14073 00002F74 0A06[6F44]              		or	al,[BINARY]
 14074 00002F78 741E                    		jz	short EXSETA	; neither set, default to ascii
 14075                                  TESTBOTH:
 14076 00002F7A 7A26                    		jpe	short EXISTS	; both are set, ignore
 14077                                  		;test	al,8
 14078 00002F7C A808                    		test	al,SWITCHB
 14079 00002F7E 7422                    		jz	short EXISTS
 14080                                  		;mov	ax,(IOCTL shl 8) or 1
 14081 00002F80 B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 14082 00002F83 30F6                    		xor	dh,dh
 14083                                  		;or	dl,20h
 14084 00002F85 80CA20                  		or	dl,devid_RAW
 14085 00002F88 8816[AF43]              		mov	[DESTISDEV],dl
 14086 00002F8C CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 14087                                  				; BX = device handle,DH = 0
 14088                                  				; DL = device information to set (bits 0-7 from	function 0)
 14089 00002F8E EB12                    		jmp	short EXISTS
 14090                                  
 14091                                  		; 01/10/2018 - Retro DOS v3.0 modification
 14092                                  DEST_OPEN_ERROR:
 14093 00002F90 BA[7E37]                		mov	dx,FULDIRPTR
 14094 00002F93 E8DFEE                  		call	GET_EXT_ERR_NUMBER
 14095                                  COPERR:
 14096 00002F96 EB7C                    		jmp	short COPYERR
 14097                                  
 14098                                  EXSETA:
 14099                                  ;	What we read in may have been in binary mode, flag zapped write OK
 14100                                  
 14101                                  		;mov	byte [ASCII],4
 14102 00002F98 C606[7344]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 14103                                  		;or	byte [INEXACT],4
 14104 00002F9D 800E[6C44]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 14105                                  EXISTS:
 14106 00002FA2 803E[6E44]00            		cmp	byte [NOWRITE],0
 14107 00002FA7 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 14108 00002FA9 803E[AC42]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 14109 00002FAE 741D                    		jz	short NOCHECKING
 14110 00002FB0 E89A02                  		call	COMPNAME		; source and dest. the same?
 14111 00002FB3 7518                    		jnz	short NOCHECKING	; if not, go ahead
 14112 00002FB5 803E[1244]00            		cmp	byte [SRCISDEV],0
 14113 00002FBA 7511                    		jne	short NOCHECKING	; same name on device ok
 14114                                  
 14115                                  ;	At this point we know in append (would have gotten overwrite error
 14116                                  ;	on first destination create otherwise), and user trying to specify
 14117                                  ;	destination which has been scribbled already (if dest had been named
 14118                                  ;	first, NoWrite would be set).
 14119                                  
 14120 00002FBC BA[D037]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 14121                                  		;invoke	Std_EprintF		;ac022;
 14122 00002FBF E85204                  		call	STD_PRINTF
 14123 00002FC2 C706[7941]0000          		mov	word [NXTADD],0		; set return
 14124 00002FC8 FE06[7244]              		inc	byte [TERMREAD]		; tell read to give up
 14125                                  RET60:
 14126 00002FCC C3                      		retn
 14127                                  
 14128                                  NOCHECKING:
 14129 00002FCD 8B1E[AD43]              		mov	bx,[DESTHAND]		; get handle
 14130 00002FD1 31C9                    		xor	cx,cx
 14131 00002FD3 870E[7941]              		xchg	cx,[NXTADD]
 14132 00002FD7 E3F3                    		jcxz	RET60			; if nothing to write, forget it
 14133 00002FD9 FF06[7044]              		inc	word [WRITTEN]		; flag that we wrote something
 14134 00002FDD 803E[6E44]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 14135 00002FE2 755A                    		jnz	short SEEKEND
 14136 00002FE4 31D2                    		xor	dx,dx
 14137 00002FE6 1E                      		push	ds
 14138 00002FE7 8E1E[5841]              		mov	ds,[TPA]
 14139 00002FEB B440                    		mov	ah,WRITE ; 40h
 14140 00002FED CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14141                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14142 00002FEF 1F                      		pop	ds
 14143 00002FF0 BA[4937]                		mov	dx,NOSPACEPTR
 14144 00002FF3 7222                    		jc	short COPERRP		; failure
 14145 00002FF5 29C1                    		sub	cx,ax
 14146 00002FF7 74D3                    		jz	short RET60		; wrote all supposed to
 14147 00002FF9 F606[AF43]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 14148 00002FFE 7414                    		jz	short COPYERR		; is a file, error
 14149 00003000 F606[AF43]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 14150 00003005 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 14151 00003007 803E[6C44]00            		cmp	byte [INEXACT],0
 14152 0000300C 75BE                    		jnz	short RET60		; inexact so ok
 14153 0000300E 49                      		dec	cx
 14154                                  RETZ60:
 14155 0000300F 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 14156                                  
 14157                                  DEVWRTERR:
 14158 00003011 BA[993C]                		mov	dx,DEVWMESPTR
 14159                                  
 14160                                  COPYERR:
 14161                                  		;invoke	Std_EPrintF		;AC022;
 14162 00003014 E8FD03                  		call	STD_PRINTF
 14163                                  COPERRP:
 14164 00003017 FE06[7641]              		inc	byte [DESTCLOSED]
 14165 0000301B 803E[7541]00            		cmp	byte [CFLAG],0
 14166 00003020 7419                    		jz	short ENDCOPYJ		; never actually got it open
 14167 00003022 8B1E[AD43]              		mov	bx,[DESTHAND]
 14168 00003026 83FB00                  		cmp	bx,0
 14169 00003029 7E04                    		jle	short NOCLOSE
 14170                                  
 14171                                  ;	Check to see if we should save part of the destination file.
 14172                                  
 14173                                  		; MSDOS 6.0
 14174                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 14175                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 14176                                  			
 14177                                  		;mov	ax,cx
 14178                                  		;or	ax,dx
 14179                                  		;jz	ceClose			; null file ptr means nothing to save
 14180                                  
 14181                                  ;	Destination was also the first source.  Do the best we can to
 14182                                  ;	restore it.  Truncate it back to the size we took from it (which
 14183                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14184                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14185                                  
 14186                                  		;mov	ax,LSEEK shl 8
 14187                                  		;int	21h
 14188                                  
 14189                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14190                                  		;mov	ah,WRITE
 14191                                  		;int	21h			; truncate file
 14192                                  
 14193                                  		;cmp	OCtrlZ,0
 14194                                  		;je	@f			; no ctrl-z removed from original
 14195                                  		;inc	cx			; CX = # bytes to write = 1
 14196                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14197                                  		;mov	ah,WRITE
 14198                                  		;int	21h			; write ctrl-z
 14199                                  ;@@:
 14200                                  		;mov	ah,CLOSE
 14201                                  		;int	21h			; close it
 14202                                  ;;		;mov	CFlag,0
 14203                                  		;jmp	EndCopy			; and go home
 14204                                  
 14205                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14206                                  CECLOSE:
 14207 0000302B B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14208 0000302D CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14209                                  					; BX = file handle
 14210                                  NOCLOSE:
 14211 0000302F BA[5643]                		mov	dx,DESTBUF
 14212 00003032 B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14213 00003034 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14214                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14215 00003036 C606[7541]00            		mov	byte [CFLAG],0
 14216                                  ENDCOPYJ:
 14217 0000303B E900FB                  		jmp	ENDCOPY
 14218                                  
 14219                                  SEEKEND:
 14220 0000303E 31D2                    		xor	dx,dx
 14221 00003040 87D1                    		xchg	dx,cx
 14222                                  		;mov	ax,(LSEEK shl 8) or 1
 14223 00003042 B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14224 00003045 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14225                                  					; AL = method: offset from present location
 14226 00003047 803E[6941]00            		cmp	byte [RDEOF],0
 14227 0000304C 74C1                    		jz	short RETZ60
 14228                                  
 14229                                  ;	^Z has been read - we must set the file size to the current
 14230                                  ;	file pointer location
 14231                                  
 14232 0000304E B440                    		mov	ah,WRITE ; 40h
 14233 00003050 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14234                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14235                                  
 14236                                  		; MSDOS 6.0
 14237                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14238                                  
 14239                                  ;	Make note that ^Z was removed, in case the
 14240                                  ;	copy should fail and we need to restore the file.
 14241                                  
 14242                                  		;mov	OCtrlZ,1Ah
 14243                                  
 14244 00003052 C3                      		retn
 14245                                  
 14246                                  ;============================================================================
 14247                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14248                                  ;============================================================================
 14249                                  ; 01/10/2018 - Retro DOS v3.0
 14250                                  
 14251                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14252                                  
 14253                                  ; =============== S U B	R O U T	I N E =======================================
 14254                                  
 14255                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14256                                  ;
 14257                                  ;	Given switch vector in AX,
 14258                                  ;	  Set Ascii flag if /a is set
 14259                                  ;	  Clear Ascii flag if /b is set
 14260                                  ;	  Binary set if /b specified
 14261                                  ;	  Leave Ascii unchanged if neither or both are set
 14262                                  ; 	Also sets Inexact if Ascii is ever set. 
 14263                                  ;	AL = Ascii on exit, flags set
 14264                                  
 14265                                  SETASC:
 14266 00003053 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14267 00003055 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14268 00003057 50                      		push	ax
 14269 00003058 2408                    		and	al,SWITCHB  ; 8
 14270 0000305A A2[6F44]                		mov	[BINARY],al
 14271 0000305D 58                      		pop	ax
 14272 0000305E 2404                    		and	al,4
 14273 00003060 A2[7344]                		mov	[ASCII],al
 14274 00003063 0806[6C44]              		or	[INEXACT],al
 14275                                  LOADSW:
 14276 00003067 A0[7344]                		mov	al,[ASCII]
 14277 0000306A 08C0                    		or	al,al
 14278 0000306C C3                      		retn
 14279                                  
 14280                                  ; =============== S U B	R O U T	I N E =======================================
 14281                                  
 14282                                  BUILDDEST:
 14283 0000306D 803E[5143]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14284 00003072 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14285 00003074 BF[3840]                		mov	di,USERDIR1
 14286 00003077 BD[5143]                		mov	bp,DESTVARS
 14287 0000307A E8DE00                  		call	BUILDPATH
 14288 0000307D E8DCE7                  		call	RESTUDIR1
 14289                                  
 14290                                  ;	We now know all about the destination
 14291                                  
 14292                                  KNOWABOUTDEST:
 14293 00003080 30C0                    		xor	al,al
 14294 00003082 8606[B043]              		xchg	al,[FIRSTDEST]
 14295 00003086 08C0                    		or	al,al
 14296 00003088 7503                    		jnz	short FIRSTDST
 14297 0000308A E98A00                  		jmp	NOFIRSTDEST
 14298                                  FIRSTDST:
 14299                                  
 14300                                  ;	Create an fcb of the original dest.
 14301                                  
 14302 0000308D 8B36[5343]              		mov	si,[DESTTAIL]
 14303 00003091 BF[0C42]                		mov	di,DESTFCB
 14304 00003094 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14305 00003097 CD21                    		int	21h		; DOS -	PARSE FILENAME
 14306                                  					; DS:SI	-> string to parse
 14307                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14308                                  					; AL = bit mask	to control parsing
 14309 00003099 803C00                  		cmp	byte [si],0
 14310 0000309C 7404                    		jz	short GOODPARSE
 14311 0000309E C645017C                		mov	byte [di+1],'|'
 14312                                  		; MSDOS 6.0
 14313                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14314                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14315                                  		;jmp	CopErr				;AN052;
 14316                                  GOODPARSE:
 14317 000030A2 A1[5643]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14318 000030A5 80FC3A                  		cmp	ah,':'
 14319 000030A8 7402                    		jz	short DRVSPEC4
 14320 000030AA B040                    		mov	al,'@'
 14321                                  DRVSPEC4:
 14322                                  
 14323                                  ;	AX = "d:" for following FCB drive computation
 14324                                  
 14325 000030AC 8A0E[7344]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14326 000030B0 0C20                    		or	al,20h
 14327 000030B2 2C60                    		sub	al,60h
 14328 000030B4 A2[0C42]                		mov	[DESTFCB],al		; store drive # in FCB
 14329                                  
 14330                                  ;*	Figure out what copy mode we're in.
 14331                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14332                                  ;	+n stands for additional sources delimited by +'s.
 14333                                  ;
 14334                                  ;	copy a b	not concatenating
 14335                                  ;	copy a *	not concatenating
 14336                                  ;	copy * a	concatenating
 14337                                  ;	copy * *	not concatenating
 14338                                  ;	copy a+n b	concatenating
 14339                                  ;	copy *+n a	concatenating
 14340                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14341                                  
 14342                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14343                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14344                                  
 14345 000030B7 A0[5543]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14346 000030BA 8A26[B843]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14347 000030BE 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14348 000030C1 08C0                    		or	al,al
 14349 000030C3 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14350                                  
 14351                                  ;	Destination is wildcarded.
 14352                                  	
 14353 000030C5 38E0                    		cmp	al,ah
 14354 000030C7 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14355                                  
 14356                                  ;	Source and destination are both wildcarded.
 14357                                  
 14358 000030C9 803E[7444]00            		cmp	byte [PLUS],0
 14359 000030CE 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14360                                  
 14361                                  ;	Source and destination are wildcarded, and source includes +'s.
 14362                                  ;	It's Mel Hallorman copy time.
 14363                                  
 14364 000030D0 FE06[B143]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14365 000030D4 30C0                    		xor	al,al
 14366 000030D6 EB06                    		jmp	short SETCONC
 14367                                  
 14368                                  NOTMELCOPY:
 14369 000030D8 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14370 000030DA 20E0                    		and	al,ah
 14371 000030DC D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14372                                  				;   (implies concatenation)
 14373                                  SETCONC:
 14374 000030DE 0A06[7444]              		or	al,[PLUS]	; "+" always infers concatenation
 14375                                  
 14376                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14377                                  
 14378 000030E2 A2[6B41]                		mov	[CONCAT],al
 14379 000030E5 D0E0                    		shl	al,1
 14380 000030E7 D0E0                    		shl	al,1
 14381 000030E9 A2[6C44]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14382 000030EC 803E[6F44]00            		cmp	byte [BINARY],0
 14383 000030F1 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14384                                  
 14385 000030F3 A2[7344]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14386 000030F6 08C9                    		or	cl,cl
 14387 000030F8 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14388 000030FA 08C0                    		or	al,al
 14389 000030FC 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14390                                  
 14391                                  ;	At this point there may already be binary read data in the read
 14392                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14393                                  ;	amount of data in the buffer correctly.
 14394                                  
 14395 000030FE 8B0E[7941]              		mov	cx,[NXTADD]
 14396 00003102 E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14397 00003104 B01A                    		mov	al,1Ah
 14398 00003106 06                      		push	es
 14399 00003107 31FF                    		xor	di,di
 14400 00003109 8E06[5841]              		mov	es,[TPA]
 14401 0000310D F2AE                    		repne scasb		; scan for EOF
 14402 0000310F 07                      		pop	es
 14403 00003110 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14404 00003112 4F                      		dec	di		; point at ^z
 14405 00003113 893E[7941]              		mov	[NXTADD],di	; new buffer length
 14406                                  
 14407                                  NOFIRSTDEST:
 14408 00003117 BB[5042]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14409 0000311A 803E[6B41]00            		cmp	byte [CONCAT],0
 14410 0000311F 7403                    		jz	short GOTCHRSRC	; Not a concat
 14411 00003121 BB[9642]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14412                                  GOTCHRSRC:
 14413 00003124 BE[0D42]                		mov	si,DESTFCB+1	; Original dest name
 14414 00003127 8B3E[5343]              		mov	di,[DESTTAIL]	; Where to put result
 14415                                  
 14416                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14417                                  
 14418                                  BUILDNAME:
 14419 0000312B B90800                  		mov	cx,8
 14420                                  BUILDMAIN:
 14421 0000312E AC                      		lodsb
 14422 0000312F 3C3F                    		cmp	al,'?'
 14423 00003131 7502                    		jnz	short NOTAMBIG
 14424 00003133 8A07                    		mov	al,[bx]
 14425                                  NOTAMBIG:
 14426 00003135 3C20                    		cmp	al,' '
 14427 00003137 7401                    		jz	short NOSTORE
 14428 00003139 AA                      		stosb
 14429                                  NOSTORE:
 14430 0000313A 43                      		inc	bx
 14431 0000313B E2F1                    		loop	BUILDMAIN
 14432 0000313D B103                    		mov	cl,3
 14433 0000313F B020                    		mov	al,' '
 14434 00003141 3804                    		cmp	[si],al
 14435 00003143 7412                    		jz	short ENDDEST	; No extension
 14436                                  		;mov	al,[DOT_CHR]
 14437                                  		; 01/03/2023
 14438 00003145 B02E                    		mov	al,dot_chr ; mov al,'.'
 14439 00003147 AA                      		stosb
 14440                                  BUILDEXT:
 14441 00003148 AC                      		lodsb
 14442 00003149 3C3F                    		cmp	al,'?'
 14443 0000314B 7502                    		jnz	short NOTAMBIGE
 14444 0000314D 8A07                    		mov	al,[bx]
 14445                                  NOTAMBIGE:
 14446 0000314F 3C20                    		cmp	al,' '
 14447 00003151 7401                    		jz	short NOSTOREE
 14448 00003153 AA                      		stosb
 14449                                  NOSTOREE:
 14450 00003154 43                      		inc	bx
 14451 00003155 E2F1                    		loop	BUILDEXT
 14452                                  ENDDEST:
 14453 00003157 30C0                    		xor	al,al
 14454 00003159 AA                      		stosb			; NUL terminate
 14455 0000315A C3                      		retn
 14456                                  
 14457                                  ; =============== S U B	R O U T	I N E =======================================
 14458                                  
 14459                                  BUILDPATH:
 14460 0000315B F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14461 0000315F 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14462 00003161 89EA                    		mov	dx,bp		; Set DX to spec
 14463 00003163 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14464                                  
 14465                                  		; MSDOS 6.0
 14466                                  		;push	di				;AN000;
 14467                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14468                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14469                                  		;xor	cx,cx				;AN000; no special files
 14470                                  		;mov	si,dx				;AN030; get file name offset
 14471                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14472                                  		;INT	21h
 14473                                  		;pop	di				;AN000;
 14474                                  		;jnc	pure_file			;AN022; is pure file
 14475                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14476                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14477                                  		;jz	notpfile			;AN022;
 14478                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14479                                  		;jz	notpfile			;AN022;
 14480                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14481                                  		;jz	notpfile			;AN022;
 14482                                  		;jmp	extend_setup			;AN022; exit with error
 14483                                  ;pure_file:
 14484                                  		; MSDOS 3.3
 14485 00003166 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14486 00003169 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14487                                  					; DS:DX	-> ASCIZ filename
 14488                                  					; AL = access mode
 14489                                  					; 0 - read
 14490 0000316B 7216                    		jc	short NOTPFILE
 14491                                  ;PURE_FILE:
 14492 0000316D 89C3                    		mov	bx,ax
 14493 0000316F B80044                  		mov	ax,IOCTL*256 ; 4400h
 14494 00003172 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14495                                  					; BX = file or device handle
 14496 00003174 B43E                    		mov	ah,CLOSE ;3Eh
 14497 00003176 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14498                                  					; BX = file handle
 14499 00003178 F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14500 0000317B 7545                    		jnz	short ISADEV
 14501 0000317D F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14502 00003181 743F                    		jz	short ISADEV
 14503                                  
 14504                                  NOTPFILE:
 14505 00003183 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14506                                  		
 14507                                  		;MSDOS 6.0
 14508                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14509                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14510                                  
 14511 00003186 80FE3A                  		cmp	dh,':'
 14512 00003189 7402                    		je	short DRVSPEC5
 14513                                  SET_DRIVE_SPEC:
 14514 0000318B B240                    		mov	dl,'@'
 14515                                  
 14516                                  DRVSPEC5:
 14517 0000318D 80CA20                  		or	dl,20h
 14518 00003190 80EA60                  		sub	dl,60h		; A = 1
 14519 00003193 E87CE7                  		call	SAVUDIR1
 14520                                  	
 14521                                  		; MSDOS 6.0
 14522                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14523                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14524                                  		;jmp	extend_setup		;AN022; exit with error
 14525                                  CURDIR_OK:
 14526 00003196 89EA                    		mov	dx,bp
 14527                                  		;add	dx,5
 14528 00003198 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14529                                  		;mov	bh,[bp+4]
 14530 0000319B 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14531 0000319E 80E706                  		and	bh,6
 14532 000031A1 80FF06                  		cmp	bh,6			; Ambig and path ?
 14533 000031A4 7517                    		jne	short CHECKAMB		; jmp if no
 14534                                  		;mov	si,[bp+2]
 14535 000031A6 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14536 000031A9 B33A                    		mov	bl,':'
 14537 000031AB 385CFE                  		cmp	[si-2],bl
 14538 000031AE 7506                    		jne	short KNOWNOTSPEC
 14539                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14540                                  		;mov	byte [bp+0],2
 14541 000031B0 C6460002                		mov	byte [bp],2
 14542 000031B4 EB05                    		jmp	short DOPCDJ
 14543                                  KNOWNOTSPEC:
 14544                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14545                                  		;mov	byte [bp+0],1		
 14546 000031B6 C6460001                		mov	byte [bp],1
 14547 000031BA 4E                      		dec	si
 14548                                  DOPCDJ:
 14549 000031BB EB5C                    		jmp	short DOPCD
 14550                                  CHECKAMB:
 14551 000031BD 80FF02                  		cmp	bh,2
 14552 000031C0 7505                    		jnz	short CHECKCD
 14553                                  ISSIMPFILE:
 14554                                  ISADEV:
 14555                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14556                                  		;mov	byte [bp+0],0		
 14557 000031C2 C6460000                		mov	byte [bp],0
 14558                                  NOTPDIR_RETN:	; 02/03/2023
 14559 000031C6 C3                      		retn
 14560                                  
 14561                                  CHECKCD:
 14562 000031C7 E8EBEC                  		call	SETREST1
 14563 000031CA B43B                    		mov	ah,CHDIR ; 3Bh
 14564 000031CC CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14565                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14566 000031CE 7221                    		jb	short NOTPDIR
 14567 000031D0 89D7                    		mov	di,dx
 14568 000031D2 31C0                    		xor	ax,ax
 14569 000031D4 89C1                    		mov	cx,ax
 14570 000031D6 49                      		dec	cx
 14571 000031D7 F2AE                    		repne scasb
 14572                                  DONE:
 14573 000031D9 4F                      		dec	di
 14574 000031DA A0[5B41]                		mov	al,[DIRCHAR]
 14575                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14576                                  		;mov	byte [bp+0],2
 14577 000031DD C6460002                		mov	byte [bp],2
 14578 000031E1 3A45FF                  		cmp	al,[di-1]
 14579 000031E4 7405                    		jz	short GOTSRCSLSH
 14580                                  _STORE_PCHAR:
 14581 000031E6 AA                      		stosb
 14582                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14583                                  		;mov	byte [bp+0],1
 14584 000031E7 C6460001                		mov	byte [bp],1
 14585                                  GOTSRCSLSH:
 14586                                  		;or	byte [bp+4],6
 14587 000031EB 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14588                                  		;call	SETSTARS
 14589                                  		; 02/03/2023
 14590 000031EF EB40                    		jmp	SETSTARS
 14591                                  ;NOTPDIR_RETN:
 14592                                  		;retn
 14593                                  
 14594                                  NOTPDIR:
 14595                                  		; MSDOS 6.0
 14596                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14597                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14598                                  		;jz	notpdir_try		;AN022;
 14599                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14600                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14601                                  ;notpdir_try:
 14602                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14603                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14604                                  		;mov	byte [bp+0],0
 14605 000031F1 C6460000                		mov	byte [bp],0
 14606                                  		;mov	bh,[bp+4]
 14607 000031F5 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14608 000031F8 F6C704                  		test	bh,4
 14609 000031FB 74C9                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14610                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14611                                  		;mov	byte [bp+0],2		
 14612 000031FD C6460002                		mov	byte [bp],2
 14613                                  		;mov	si,[bp+2]
 14614 00003201 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14615 00003204 803C00                  		cmp	byte [si],0
 14616 00003207 7424                    		je	short BADCDERRJ2	; Trailing '/'	
 14617                                  		;;mov	bl,[DOT_CHR]
 14618                                  		; 01/03/2023
 14619                                  		;mov	bl,dot_chr  ; mov bl,'.'
 14620                                  		;cmp	[si],bl
 14621 00003209 803C2E                  		cmp	byte [si],dot_chr ; '.'
 14622 0000320C 741F                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14623                                  		;mov	bl,':'
 14624                                  		;cmp	[si-2],bl
 14625                                  		; 01/03/2023
 14626 0000320E 807CFE3A                		cmp	byte [si-2],':'
 14627 00003212 7405                    		je	short DOPCD		   ; Know d:/file
 14628                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14629                                  		;mov	byte [bp+0],1
 14630 00003214 C6460001                		mov	byte [bp],1
 14631 00003218 4E                      		dec	si			; Point at last '/'
 14632                                  DOPCD:
 14633 00003219 30DB                    		xor	bl,bl
 14634 0000321B 861C                    		xchg	bl,[si]			; Stick in a NUL
 14635 0000321D E895EC                  		call	SETREST1
 14636 00003220 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14637 00003223 7408                    		je	short BADCDERRJ2
 14638 00003225 B43B                    		mov	ah,CHDIR ; 3Bh
 14639 00003227 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14640                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14641 00003229 861C                    		xchg	bl,[si]
 14642 0000322B 7399                    		jnc	short NOTPDIR_RETN
 14643                                  		
 14644                                  		; MSDOS 3.3
 14645                                  BADCDERRJ2:
 14646 0000322D F9                      		stc
 14647 0000322E E98FDF                  		jmp	BADCDERR
 14648                                  
 14649                                  		; MSDOS 6.0
 14650                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14651                                  ;EXTEND_SETUPJ:					;AN022;
 14652                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14653                                  ;BADCDERRJ2:
 14654                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14655                                  
 14656                                  ; =============== S U B	R O U T	I N E =======================================
 14657                                  
 14658                                  SETSTARS:
 14659                                  		;mov	[bp+2],di
 14660 00003231 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14661                                  		;add	byte [bp+1],12
 14662 00003234 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14663                                  		;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14664                                  		; 01/03/2023
 14665 00003238 B83F2E                  		mov	ax,dot_qmark ; '?.' (mov ax,2E3Fh)
 14666 0000323B B90800                  		mov	cx,8
 14667 0000323E F3AA                    		rep stosb
 14668 00003240 86C4                    		xchg	al,ah
 14669 00003242 AA                      		stosb
 14670 00003243 86C4                    		xchg	al,ah
 14671 00003245 B103                    		mov	cl,3
 14672 00003247 F3AA                    		rep stosb
 14673 00003249 30C0                    		xor	al,al
 14674 0000324B AA                      		stosb
 14675 0000324C C3                      		retn
 14676                                  
 14677                                  ; =============== S U B	R O U T	I N E =======================================
 14678                                  
 14679                                  COMPNAME:
 14680 0000324D BE[5643]                		mov	si,DESTBUF	; do name translate of target
 14681 00003250 BF[DB3E]                		mov	di,TRGXNAME	; save for name comparison
 14682 00003253 B460                    		mov	ah,XNAMETRANS ; 60h
 14683 00003255 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14684                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14685                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14686 00003257 BE[843E]                		mov	si,SRCXNAME	; get name translate of source
 14687 0000325A BF[DB3E]                		mov	di,TRGXNAME	; get name translate of target
 14688                                  		;call	STRCOMP
 14689                                  		;retn
 14690                                  		; 02/03/2023
 14691 0000325D E927E7                  		jmp	STRCOMP
 14692                                  
 14693                                  ;============================================================================
 14694                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14695                                  ;============================================================================
 14696                                  ; 30/09/2018 - Retro DOS v3.0
 14697                                  
 14698                                  ;-----------------------------------------------------------------------;
 14699                                  ; ENTRY:								;
 14700                                  ;	DS:SI	Points input buffer					;
 14701                                  ;	ES:DI	Points to the token buffer				;
 14702                                  ;	BL	Special delimiter for this call 			;
 14703                                  ;		    Always checked last 				;
 14704                                  ;		    set it to space if there is no special delimiter	;
 14705                                  ; EXIT: 								;
 14706                                  ;	DS:SI	Points to next char in the input buffer 		;
 14707                                  ;	ES:DI	Points to the token buffer				;
 14708                                  ;	[STARTEL] Points to start of last element of path in token	;
 14709                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14710                                  ;	CX	Character count 					;
 14711                                  ;	BH	Condition Code						;
 14712                                  ;			Bit 1H of BH set if switch character		;
 14713                                  ;				Token buffer contains char after	;
 14714                                  ;				switch character			;
 14715                                  ;				BP has switch bits set (ORing only)	;
 14716                                  ;			Bit 2H of BH set if ? or * in token		;
 14717                                  ;				if * found element ? filled		;
 14718                                  ;			Bit 4H of BH set if path sep in token		;
 14719                                  ;			Bit 80H of BH set if the special delimiter	;
 14720                                  ;			   was skipped at the start of this token	;
 14721                                  ;		Token buffer always starts d: for non switch tokens	;
 14722                                  ;	CARRY SET							;
 14723                                  ;	    if CR on input						;
 14724                                  ;		token buffer not altered				;
 14725                                  ;									;
 14726                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14727                                  ; MODIFIES:								;
 14728                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14729                                  ;									;
 14730                                  ;-----------------------------------------------------------------------;
 14731                                  
 14732                                  ; Modifications to cparse: recognition of right and left parentheses
 14733                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14734                                  ;
 14735                                  ; Both modifications were installed in the course of adding a coherent
 14736                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14737                                  ; structure for command-line arguments. This parser relies on cparse to
 14738                                  ; recognize individual tokens.
 14739                                  ;
 14740                                  ; To process for-loops correctly, parentheses must therefore be
 14741                                  ; recognized as tokens. The upper-case conversion code was removed so
 14742                                  ; that commands (such as for and echo) would be able to use the "original"
 14743                                  ; text of the command line.
 14744                                  ;
 14745                                  ; Note also the modification to prevent the automatic conversion of colons
 14746                                  ; into spaces WITHIN THE SOURCE TEXT!
 14747                                  ;
 14748                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14749                                  ; on the command line.
 14750                                  ;
 14751                                  ; Alan L, OS/MSDOS				    14 August 1983
 14752                                  
 14753                                  ; ---------------------------------------------------------------------------
 14754                                  
 14755                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14756                                  
 14757                                  ;FSWITCH	EQU	8000h
 14758                                  ;FBADSWITCH	EQU	4000h
 14759                                  
 14760                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14761                                  
 14762                                  ; =============== S U B	R O U T	I N E =======================================
 14763                                  
 14764                                  CPARSE:
 14765 00003260 31C0                    		xor	ax,ax
 14766 00003262 893E[7C44]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14767 00003266 A2[7F44]                		mov	[ELPOS],al		; Start in 8 char prefix
 14768 00003269 A2[8044]                		mov	[SOURCE],al		; No skip delimiter yet
 14769 0000326C 88C7                    		mov	bh,al			; Init nothing
 14770 0000326E 9C                      		pushf				; save flags
 14771 0000326F 57                      		push	di			; save the token buffer addrss
 14772 00003270 31C9                    		xor	cx,cx			; no chars in token buffer
 14773 00003272 880E[AB42]              		mov	[COMMA],cl		; reset comma flag
 14774                                  MOREDELIM:
 14775 00003276 AC                      		lodsb
 14776 00003277 E8D0E6                  		call	DELIM
 14777 0000327A 751D                    		jnz	short SCANCDONE
 14778 0000327C 3C20                    		cmp	al,' '
 14779 0000327E 74F6                    		jz	short MOREDELIM
 14780 00003280 3C09                    		cmp	al,9
 14781 00003282 74F2                    		jz	short MOREDELIM
 14782 00003284 8606[8044]              		xchg	al,[SOURCE]
 14783 00003288 08C0                    		or	al,al
 14784 0000328A 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14785 0000328C F6C780                  		test	bh,80h			; has a special char been found?
 14786 0000328F 7405                    		jz	short NO_COMMA		; no - just exit
 14787 00003291 C606[AB42]01            		mov	byte [COMMA],1		; set comma flag
 14788                                  NO_COMMA:
 14789 00003296 E91801                  		jmp	X_DONE			; Nul argument
 14790                                  SCANCDONE:
 14791 00003299 803E[3B43]01            		cmp	byte [CPYFLAG],1
 14792 0000329E 7503                    		jnz	short CPCONT1
 14793 000032A0 E84DE5                  		call	UPCONV_MAPCALL
 14794                                  CPCONT1:
 14795 000032A3 38D8                    		cmp	al,bl			; Special delimiter?
 14796 000032A5 7505                    		jnz	short NOSPEC
 14797 000032A7 80CF80                  		or	bh,80h
 14798 000032AA EBCA                    		jmp	short MOREDELIM
 14799                                  NOSPEC:
 14800 000032AC 3C0D                    		cmp	al,0Dh			; a CR?
 14801 000032AE 7503                    		jnz	short NCPERROR
 14802 000032B0 E9F900                  		jmp	CPERROR
 14803                                  NCPERROR:
 14804 000032B3 3A06[5A41]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14805 000032B7 7503                    		jnz	short NA_SWITCH		; yes, process...
 14806 000032B9 E9F800                  		jmp	A_SWITCH
 14807                                  NA_SWITCH:
 14808 000032BC B23A                    		mov	dl,':'
 14809 000032BE 3814                    		cmp	[si],dl
 14810 000032C0 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14811 000032C2 E83501                  		call	MOVE_CHAR
 14812 000032C5 AC                      		lodsb				; Get the ':'
 14813 000032C6 E83101                  		call	MOVE_CHAR
 14814 000032C9 893E[7C44]              		mov	[STARTEL],di
 14815 000032CD C606[7E44]00            		mov	byte [ELCNT],0
 14816 000032D2 E99A00                  		jmp	ANUM_TEST
 14817                                  ANUM_CHARD:
 14818 000032D5 893E[7C44]              		mov	[STARTEL],di
 14819 000032D9 C606[7E44]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14820 000032DE 803E[3B43]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14821 000032E3 751D                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14822 000032E5 E8ECE6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14823 000032E8 7518                    		jnz	short ANUM_CHAR		; no
 14824 000032EA 50                      		push	ax
 14825 000032EB A0[6A41]                		mov	al,[CURDRV]		; Insert drive spec
 14826                                  		;add	al,[CAPITAL_A]
 14827                                  		; 01/03/2023
 14828 000032EE 0441                    		add	al,capital_A  ; add al,'A'
 14829 000032F0 E80701                  		call	MOVE_CHAR
 14830 000032F3 B03A                    		mov	al,':'
 14831 000032F5 E80201                  		call	MOVE_CHAR
 14832 000032F8 58                      		pop	ax
 14833 000032F9 893E[7C44]              		mov	[STARTEL],di
 14834 000032FD C606[7E44]00            		mov	byte [ELCNT],0
 14835                                  ANUM_CHAR:
 14836                                  		;cmp	al,[DOT_CHR]
 14837                                  		; 01/03/2023
 14838 00003302 3C2E                    		cmp	al,dot_chr  ; cmp al,'.'
 14839 00003304 7509                    		jnz	short TESTQUEST
 14840 00003306 FE06[7F44]              		inc	byte [ELPOS]		; flag in extension
 14841 0000330A C606[7E44]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14842                                  TESTQUEST:
 14843 0000330F 3C3F                    		cmp	al,'?'
 14844 00003311 7503                    		jnz	short TESTSPLAT
 14845 00003313 80CF02                  		or	bh,2
 14846                                  TESTSPLAT:
 14847                                  		;cmp	al,[STAR]
 14848                                  		; 01/03/2023
 14849 00003316 3C2A                    		cmp	al,star ; cmp al,'*'
 14850 00003318 752C                    		jnz	short TESTPATH
 14851 0000331A 80CF02                  		or	bh,2
 14852 0000331D 803E[8C44]00            		cmp	byte [EXPAND_STAR],0
 14853                                  		;jnz	short EXPAND_FILENAME
 14854                                  		;jmp	short TESTPATH
 14855                                  		; 01/03/2023
 14856 00003322 7422                    		jz	short TESTPATH
 14857                                  ;BADPERR2J:
 14858                                  		;jmp	BADPERR2
 14859                                  
 14860                                  		;db	0E9h
 14861                                  		;db	7Eh	
 14862                                  		;db	0
 14863                                  
 14864                                  EXPAND_FILENAME:
 14865 00003324 B407                    		mov	ah,7
 14866 00003326 803E[7F44]00            		cmp	byte [ELPOS],0
 14867 0000332B 7402                    		jz	short GOTELCNT
 14868 0000332D B402                    		mov	ah,2
 14869                                  GOTELCNT:
 14870 0000332F B03F                    		mov	al,'?'
 14871 00003331 2A26[7E44]              		sub	ah,[ELCNT]
 14872                                  		;jb	short BADPERR2J
 14873                                  		; 01/03/2023
 14874 00003335 726C                    		jb	short BADPERR2
 14875 00003337 86E1                    		xchg	ah,cl
 14876 00003339 E309                    		jcxz	TESTPATHX
 14877                                  QMOVE:
 14878 0000333B 86E1                    		xchg	ah,cl
 14879 0000333D E8BA00                  		call	MOVE_CHAR
 14880 00003340 86E1                    		xchg	ah,cl
 14881 00003342 E2F7                    		loop	QMOVE
 14882                                  TESTPATHX:
 14883 00003344 86E1                    		xchg	ah,cl
 14884                                  TESTPATH:
 14885 00003346 E88BE6                  		call	PATHCHRCMP
 14886 00003349 7521                    		jnz	short NOTSPECIAL
 14887 0000334B 80CF04                  		or	bh,4
 14888 0000334E 803E[8C44]00            		cmp	byte [EXPAND_STAR],0
 14889 00003353 7405                    		jz	short NO_ERR_CHECK
 14890 00003355 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14891 00003358 754F                    		jnz	short BADPERR
 14892                                  NO_ERR_CHECK:
 14893 0000335A 893E[7C44]              		mov	[STARTEL],di	  ; New element
 14894 0000335E FF06[7C44]              		inc	word [STARTEL]	  ; Point to char after /
 14895 00003362 C606[7E44]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14896 00003367 C606[7F44]00            		mov	byte [ELPOS],0
 14897                                  NOTSPECIAL:
 14898 0000336C E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14899                                  ANUM_TEST:
 14900 0000336F AC                      		lodsb
 14901 00003370 803E[3B43]01            		cmp	byte [CPYFLAG],1
 14902 00003375 7503                    		jnz	short CPCONT3
 14903 00003377 E876E4                  		call	UPCONV_MAPCALL
 14904                                  CPCONT3:
 14905 0000337A E8CDE5                  		call	DELIM
 14906 0000337D 7432                    		jz	short X_DONE
 14907 0000337F 3C0D                    		cmp	al,0Dh
 14908 00003381 742E                    		jz	short X_DONE
 14909 00003383 3A06[5A41]              		cmp	al,[SWITCHAR]
 14910 00003387 7428                    		jz	short X_DONE
 14911 00003389 38D8                    		cmp	al,bl
 14912 0000338B 7424                    		jz	short X_DONE
 14913 0000338D 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14914 0000338F 750F                    		jnz	short ANUM_CHARJ
 14915                                  
 14916                                  ; Modification made for parseline.
 14917                                  ; Why would it be necessary to change colons to spaces? In this
 14918                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14919                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14920                                  
 14921 00003391 803E[3B43]02            		cmp	byte [CPYFLAG],2
 14922 00003396 7505                    		jnz	short CPCONT4
 14923 00003398 E85F00                  		call	MOVE_CHAR
 14924 0000339B EBD2                    		jmp	short ANUM_TEST
 14925                                  CPCONT4:
 14926 0000339D 46                      		inc	si		;Skip the ':'
 14927 0000339E EB11                    		jmp	short X_DONE
 14928                                  ANUM_CHARJ:
 14929 000033A0 E95FFF                  		jmp	ANUM_CHAR
 14930                                  BADPERR2:
 14931 000033A3 BA[5C3C]                		mov	dx,BADCPMESPTR
 14932 000033A6 E93DE8                  		jmp	CERROR
 14933                                  BADPERR:
 14934 000033A9 E914DE                  		jmp	BADCDERR  ; MSDOS 3.3	
 14935                                  CPERROR:
 14936 000033AC 4E                      		dec	si		; adjust the pointer
 14937 000033AD 5F                      		pop	di		; retrive token buffer address
 14938 000033AE 9D                      		popf			; restore flags
 14939 000033AF F9                      		stc			; set the carry bit
 14940 000033B0 C3                      		retn
 14941                                  X_DONE:
 14942 000033B1 4E                      		dec	si		; adjust for next round
 14943                                  
 14944                                  ; Mod to recognize right and left parens as integral tokens.
 14945                                  ;X_DONE2:
 14946 000033B2 EB3F                    		jmp	short OUT_TOKEN
 14947                                  A_SWITCH:
 14948 000033B4 80CF01                  		or	bh,1		; Indicate switch
 14949 000033B7 81CD0080                		or	bp,FSWITCH ; 8000h
 14950 000033BB E884E5                  		call	SCANOFF
 14951 000033BE 46                      		inc	si
 14952 000033BF 3C0D                    		cmp	al,0Dh
 14953 000033C1 7509                    		jnz	short STORE_SWT
 14954 000033C3 B000                    		mov	al,0
 14955 000033C5 AA                      		stosb
 14956 000033C6 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14957 000033CA EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14958                                  					;   BP = fSwitch but no switch
 14959                                  					;   bit is set (unknown switch)
 14960                                  STORE_SWT:
 14961 000033CC E82B00                  		call	MOVE_CHAR	; store the character
 14962                                  
 14963                                  ; This upconv call must stay.  It is used to identify copy-switches
 14964                                  ; on the command line, and won't store anything into the output buffer.
 14965                                  
 14966 000033CF E81EE4                  		call	UPCONV_MAPCALL
 14967 000033D2 06                      		push	es
 14968 000033D3 57                      		push	di
 14969 000033D4 51                      		push	cx
 14970 000033D5 0E                      		push	cs
 14971 000033D6 07                      		pop	es
 14972 000033D7 BF[0E3E]                		mov	di,SWITCH_LIST ; "VBAPW"
 14973 000033DA B90500                  		mov	cx,SWCOUNT ; 5
 14974 000033DD 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14975 000033E1 F2AE                    		repne scasb
 14976 000033E3 750B                    		jnz	short OUT_TOKENP
 14977 000033E5 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14978 000033E9 B80100                  		mov	ax,1
 14979 000033EC D3E0                    		shl	ax,cl
 14980 000033EE 09C5                    		or	bp,ax
 14981                                  OUT_TOKENP:
 14982 000033F0 59                      		pop	cx
 14983 000033F1 5F                      		pop	di
 14984 000033F2 07                      		pop	es
 14985                                  OUT_TOKEN:
 14986 000033F3 B000                    		mov	al,0		; null at the end
 14987 000033F5 AA                      		stosb
 14988 000033F6 5F                      		pop	di		; restore token buffer pointer	
 14989 000033F7 9D                      		popf
 14990 000033F8 F8                      		clc			; clear carry flag
 14991 000033F9 C3                      		retn
 14992                                  
 14993                                  ; =============== S U B	R O U T	I N E =======================================
 14994                                  
 14995                                  MOVE_CHAR:
 14996 000033FA AA                      		stosb			; store char in token buffer
 14997 000033FB 41                      		inc	cx		; increment char count
 14998 000033FC FE06[7E44]              		inc	byte [ELCNT]	; increment element count for * substi
 14999 00003400 C3                      		retn
 15000                                  
 15001                                  ;============================================================================
 15002                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 15003                                  ;============================================================================
 15004                                  ; 30/09/2018 - Retro DOS v3.0
 15005                                  
 15006                                  ; BREAK	<Message Printing Routine>
 15007                                  
 15008                                  ;
 15009                                  ;	MSDOS V3.00 PRINT
 15010                                  ;
 15011                                  ;	Message Printing Routine
 15012                                  ;
 15013                                  
 15014                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 15015                                  ;
 15016                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 15017                                  ;
 15018                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 15019                                  ;
 15020                                  ; Characters are output to PFHandle according to the
 15021                                  ; specifications contained in the Control String.
 15022                                  ;
 15023                                  ; The conversion characters are as follow:
 15024                                  ;
 15025                                  ;               %c - output the next argument as a character
 15026                                  ;               %s - output the next argument as a string
 15027                                  ;               %x - output the next argument as a hexidecimal number
 15028                                  ;                    using abcedf
 15029                                  ;               %X - output the next argument as a hexidecimal number
 15030                                  ;                    using ABCDEF
 15031                                  ;               %d - output the next argument as a decimal number
 15032                                  ;
 15033                                  ;
 15034                                  ; Other format specifiers that may precede the conversion character are:
 15035                                  ;
 15036                                  ;               - (minus sign) - causes the field to be left-adjusted
 15037                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 15038                                  ;               n - digit specifing the minimum field width (default to 1)
 15039                                  ;               L - specifing a long integer
 15040                                  ;
 15041                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 15042                                  ;   to an argument list.
 15043                                  ;
 15044                                  ;   ____________________
 15045                                  ;   |   Ret Addr       |      <= SP
 15046                                  ;   --------------------
 15047                                  ;   |  Ptr to Arg List |
 15048                                  ;   --------------------
 15049                                  ;
 15050                                  ;   And the argument list contains the following:
 15051                                  ;
 15052                                  ;       String_ptr                  (a pointer to the control string)
 15053                                  ;       Arg 1
 15054                                  ;       Arg 2
 15055                                  ;         .
 15056                                  ;         .
 15057                                  ;         .
 15058                                  ;       Arg n-1
 15059                                  ;       Arg n
 15060                                  ;
 15061                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 15062                                  ;   or character.
 15063                                  ;
 15064                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 15065                                  
 15066                                  
 15067                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 15068                                  
 15069                                  ; =============== S U B	R O U T	I N E =======================================
 15070                                  
 15071                                  PRINTF_INIT:
 15072 00003401 E81000                  		call	STD_PRINTF
 15073 00003404 CB                      		retf
 15074                                  
 15075                                  ; =============== S U B	R O U T	I N E =======================================
 15076                                  
 15077                                  PRINTF_CRLF:
 15078 00003405 E80C00                  		call	STD_PRINTF
 15079                                  		;call	CRLF2
 15080                                  		;retn
 15081                                  		; 02/03/2023
 15082 00003408 E92AE5                  		jmp	CRLF2
 15083                                  
 15084                                  ; =============== S U B	R O U T	I N E =======================================
 15085                                  
 15086                                  STD_EPRINTF:
 15087 0000340B 2EC706[1E3E]0200        		mov	word [cs:PRINTF_HANDLE],2
 15088 00003412 EB07                    		jmp	short NEW_PRINTF
 15089                                  
 15090                                  ; =============== S U B	R O U T	I N E =======================================
 15091                                  
 15092                                  STD_PRINTF:
 15093                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 15094                                  
 15095 00003414 2EC706[1E3E]0100        		mov	word [cs:PRINTF_HANDLE],1
 15096                                  
 15097                                  NEW_PRINTF:				;Save the callers' registers
 15098 0000341B FC                      		cld
 15099 0000341C 52                      		push	dx
 15100 0000341D 55                      		push	bp
 15101 0000341E 89E5                    		mov	bp,sp
 15102 00003420 51                      		push	cx
 15103 00003421 53                      		push	bx
 15104 00003422 50                      		push	ax
 15105 00003423 57                      		push	di
 15106 00003424 56                      		push	si
 15107 00003425 06                      		push	es
 15108 00003426 1E                      		push	ds
 15109 00003427 0E                      		push	cs
 15110 00003428 07                      		pop	es		;ES points to Printf segment
 15111 00003429 BF[203E]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 15112 0000342C 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 15113                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 15114 0000342F 3E8B7600                		mov	si,[ds:bp] ; bp
 15115 00003433 83C502                  		add	bp,2
 15116 00003436 31DB                    		xor	bx,bx
 15117 00003438 E8D001                  		call	CLEAR_FLAGS	; initialize the world
 15118                                  GET_CHAR:
 15119 0000343B AC                      		lodsb			;Get a character
 15120 0000343C 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 15121 0000343E 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 15122 00003440 08C0                    		or	al,al		;Is it the end of the control string?
 15123 00003442 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 15124                                  PRINTF_PERCENT:				
 15125 00003444 E86101                  		call	OUTCHR		;Otherwise store the character
 15126 00003447 EBF2                    		jmp	short GET_CHAR	;And go get another
 15127                                  PRINTF_DONE:
 15128 00003449 E86401                  		call	FLUSH
 15129 0000344C 1F                      		pop	ds
 15130 0000344D 07                      		pop	es
 15131 0000344E 5E                      		pop	si
 15132 0000344F 5F                      		pop	di
 15133 00003450 58                      		pop	ax
 15134 00003451 5B                      		pop	bx
 15135 00003452 59                      		pop	cx
 15136 00003453 5D                      		pop	bp
 15137 00003454 5A                      		pop	dx
 15138 00003455 C3                      		retn
 15139                                  
 15140                                  CONV_CHAR:
 15141 00003456 2EC606[153E]00          		mov	byte [cs:PRINTF_LEFT],0
 15142                                  NXT_CONV_CHAR:	
 15143                                  		;Look for any format specifiers preceeding the conversion character
 15144 0000345C AC                      		lodsb
 15145 0000345D 3C25                    		cmp	al,'%'			;Just print the %
 15146 0000345F 74E3                    		jz	short PRINTF_PERCENT
 15147                                  		;cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 15148                                  		; 01/03/2023
 15149 00003461 3C2D                    		cmp	al,'-'
 15150 00003463 743C                    		jz	short LEFT_ADJ
 15151                                  		;cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 15152 00003465 3C2B                    		cmp	al,plus_chr ; cmp al,'+'
 15153 00003467 74ED                    		jz	short CONV_CHAR
 15154                                  		;cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 15155 00003469 3C4C                    		cmp	al,'L'
 15156 0000346B 743C                    		jz	short LONG_INT
 15157                                  		;cmp	al,[cs:char_l]	 ; "l"		
 15158 0000346D 3C6C                    		cmp	al,'l'
 15159 0000346F 7438                    		jz	short LONG_INT
 15160 00003471 3C30                    		cmp	al,'0'			;Is it a precision specification
 15161 00003473 723C                    		jb	short LOOK_CONV_CHAR
 15162 00003475 3C39                    		cmp	al,'9'
 15163 00003477 7738                    		ja	short LOOK_CONV_CHAR
 15164 00003479 3C30                    		cmp	al,'0'
 15165 0000347B 750C                    		jnz	short NOT_PAD
 15166 0000347D 2E833E[193E]00          		cmp	word [cs:PRINTF_WIDTH],0
 15167 00003483 7504                    		jnz	short NOT_PAD
 15168                                  		;mov	ah,'0'
 15169                                  		;mov	[cs:PAD_CHAR],ah
 15170                                  		; 01/03/2023
 15171 00003485 2EA2[1D3E]              		mov	[cs:PAD_CHAR],al ; '0'
 15172                                  NOT_PAD:					;Adjust decimal place on precision
 15173 00003489 50                      		push	ax
 15174 0000348A 2EA1[193E]              		mov	ax,[cs:PRINTF_WIDTH]
 15175 0000348E B90A00                  		mov	cx,10
 15176 00003491 F7E1                    		mul	cx
 15177 00003493 5A                      		pop	dx
 15178 00003494 30F6                    		xor	dh,dh
 15179 00003496 80EA30                  		sub	dl,'0'
 15180 00003499 01D0                    		add	ax,dx
 15181 0000349B 2EA3[193E]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 15182 0000349F EBBB                    		jmp	short NXT_CONV_CHAR
 15183                                  LEFT_ADJ:
 15184 000034A1 2EC606[153E]01          		mov	byte [cs:PRINTF_LEFT],1
 15185 000034A7 EBB3                    		jmp	short NXT_CONV_CHAR
 15186                                  LONG_INT:
 15187 000034A9 2E800E[163E]01          		or	byte [cs:PRINTF_LONG],1
 15188 000034AF EBAB                    		jmp	short NXT_CONV_CHAR
 15189                                  LOOK_CONV_CHAR:
 15190 000034B1 24DF                    		and	al,0DFh
 15191                                  		; 01/03/2023
 15192                                  		;cmp	al,[cs:CHAR_X]	 ; "X"
 15193 000034B3 3C58                    		cmp	al,'X'
 15194 000034B5 7431                    		jz	short HEX_UP
 15195                                  		;cmp	al,[cs:CHAR_D]	 ; "D"
 15196 000034B7 3C44                    		cmp	al,'D'
 15197 000034B9 7436                    		jz	short DECIMAL
 15198                                  		;cmp	al,[cs:CHAR_C]	 ; "C"
 15199 000034BB 3C43                    		cmp	al,'C'
 15200 000034BD 743B                    		jz	short C_PUT_CHAR
 15201                                  		;cmp	al,[cs:CHAR_S]	 ; "S"
 15202 000034BF 3C53                    		cmp	al,'S'
 15203                                  		;jz	short S_PUT_STRG
 15204                                  		;call	CLEAR_FLAGS
 15205                                  		;jmp	GET_CHAR
 15206                                  		; 01/03/2023
 15207 000034C1 753F                    		jnz	short S_PUT_5
 15208                                  		;jmp	short S_PUT_STRG ; -->
 15209                                  
 15210                                  		; 01/03/2023
 15211                                  ;HEX_UP:
 15212                                  ;		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15213                                  ;		jmp	short CONV_TO_NUM
 15214                                  ;DECIMAL:
 15215                                  ;		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15216                                  ;		jmp	short CONV_TO_NUM
 15217                                  ;
 15218                                  ;C_PUT_CHAR:
 15219                                  ;		call	NEXT_CHRS
 15220                                  ;		mov	al,dl
 15221                                  ;		call	OUTCHR
 15222                                  ;		call	CLEAR_FLAGS
 15223                                  ;		jmp	GET_CHAR
 15224                                  
 15225                                  ; -->
 15226                                  S_PUT_STRG:
 15227 000034C3 56                      		push	si			;Save pointer to control string
 15228 000034C4 E83701                  		call	NEXT_CHRS
 15229 000034C7 89D6                    		mov	si,dx
 15230                                  S_PUT_1:
 15231 000034C9 2E8B0E[193E]            		mov	cx,[cs:PRINTF_WIDTH]
 15232 000034CE 09C9                    		or	cx,cx
 15233 000034D0 740B                    		jz	short S_PUT_2
 15234 000034D2 2E803E[153E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15235 000034D8 7503                    		jnz	short S_PUT_2
 15236 000034DA E84300                  		call	PAD_STRING
 15237                                  S_PUT_2:
 15238 000034DD 56                      		push	si
 15239                                  S_PUT_3:
 15240 000034DE AC                      		lodsb
 15241 000034DF 08C0                    		or	al,al
 15242 000034E1 7425                    		jz	short S_PUT_4
 15243 000034E3 E8C200                  		call	OUTCHR			;Put it into our buffer
 15244 000034E6 EBF6                    		jmp	short S_PUT_3
 15245                                  
 15246                                  		; 01/03/2023
 15247                                  HEX_UP:
 15248 000034E8 2EC706[1B3E]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15249 000034EF EB41                    		jmp	short CONV_TO_NUM
 15250                                  DECIMAL:
 15251 000034F1 2EC706[1B3E]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15252 000034F8 EB38                    		jmp	short CONV_TO_NUM
 15253                                  C_PUT_CHAR:
 15254 000034FA E80101                  		call	NEXT_CHRS
 15255 000034FD 88D0                    		mov	al,dl
 15256 000034FF E8A600                  		call	OUTCHR
 15257                                  S_PUT_5: ; 01/03/2023
 15258 00003502 E80601                  		call	CLEAR_FLAGS
 15259 00003505 E933FF                  		jmp	GET_CHAR
 15260                                  S_PUT_4:
 15261 00003508 5E                      		pop	si
 15262 00003509 2E803E[153E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15263 0000350F 740C                    		jz	short C_S_END
 15264 00003511 2E8B0E[193E]            		mov	cx,[cs:PRINTF_WIDTH]
 15265 00003516 09C9                    		or	cx,cx
 15266 00003518 7403                    		jz	short C_S_END
 15267 0000351A E80300                  		call	PAD_STRING
 15268                                  C_S_END:
 15269 0000351D 5E                      		pop	si			;Restore control string pointer
 15270                                  		;call	CLEAR_FLAGS
 15271                                  		;jmp	GET_CHAR		;Go get another character	
 15272                                  		; 01/03/2023
 15273 0000351E EBE2                    		jmp	short S_PUT_5
 15274                                  
 15275                                  ; =============== S U B	R O U T	I N E =======================================
 15276                                  
 15277                                  PAD_STRING:
 15278 00003520 31D2                    		xor	dx,dx
 15279 00003522 56                      		push	si
 15280                                  COUNT_LOOP:
 15281 00003523 AC                      		lodsb
 15282 00003524 08C0                    		or	al,al
 15283 00003526 7403                    		jz	short COUNT_DONE
 15284 00003528 42                      		inc	dx
 15285 00003529 EBF8                    		jmp	short COUNT_LOOP
 15286                                  COUNT_DONE:
 15287 0000352B 5E                      		pop	si
 15288 0000352C 29D1                    		sub	cx,dx
 15289 0000352E 7667                    		jbe	short COUNT_RET
 15290                                  		;call	PAD
 15291                                  		; 02/03/2023
 15292 00003530 EB66                    		jmp	PAD
 15293                                  ;COUNT_RET:
 15294                                  		;retn
 15295                                  
 15296                                  ; ---------------------------------------------------------------------------
 15297                                  
 15298                                  CONV_TO_NUM:
 15299 00003532 E8C900                  		call	NEXT_CHRS
 15300 00003535 89D0                    		mov	ax,dx
 15301 00003537 31D2                    		xor	dx,dx
 15302 00003539 2E803E[163E]00          		cmp	byte [cs:PRINTF_LONG],0 
 15303                                  				;Is this is a short or long integer?
 15304 0000353F 7403                    		jz	short NOT_LONG_INT
 15305 00003541 E8BA00                  		call	NEXT_CHRS
 15306                                  NOT_LONG_INT:
 15307 00003544 53                      		push	bx
 15308 00003545 56                      		push	si
 15309 00003546 2E8B36[1B3E]            		mov	si,[cs:PRINTF_BASE]
 15310 0000354B 2E8B0E[193E]            		mov	cx,[cs:PRINTF_WIDTH]
 15311 00003550 E80B00                  		call	PNUM
 15312 00003553 5E                      		pop	si
 15313 00003554 5B                      		pop	bx
 15314 00003555 E84000                  		call	PAD
 15315 00003558 E8B000                  		call	CLEAR_FLAGS
 15316 0000355B E9DDFE                  		jmp	GET_CHAR
 15317                                  
 15318                                  ; =============== S U B	R O U T	I N E =======================================
 15319                                  
 15320                                  PNUM:
 15321 0000355E 49                      		dec	cx
 15322 0000355F 50                      		push	ax
 15323 00003560 89D0                    		mov	ax,dx
 15324 00003562 31D2                    		xor	dx,dx
 15325 00003564 F7F6                    		div	si
 15326 00003566 89C3                    		mov	bx,ax
 15327 00003568 58                      		pop	ax
 15328 00003569 F7F6                    		div	si
 15329 0000356B 87DA                    		xchg	bx,dx
 15330 0000356D 50                      		push	ax
 15331 0000356E 09D0                    		or	ax,dx
 15332 00003570 58                      		pop	ax
 15333 00003571 7407                    		jz	short DO_PAD
 15334 00003573 53                      		push	bx
 15335 00003574 E8E7FF                  		call	PNUM
 15336 00003577 5B                      		pop	bx
 15337 00003578 EB0B                    		jmp	short REM
 15338                                  DO_PAD:
 15339 0000357A 2E803E[153E]00          		cmp	byte [cs:PRINTF_LEFT],0
 15340 00003580 7503                    		jnz	short REM
 15341 00003582 E81300                  		call	PAD
 15342                                  REM:
 15343 00003585 80FB0A                  		cmp	bl,10
 15344 00003588 7203                    		jb	short NOT_HEX
 15345 0000358A 83C306                  		add	bx,6
 15346                                  NOT_HEX:
 15347 0000358D 2E8A87[2036]            		mov	al,[cs:PRINTF_TABLE+bx]	; "0123456789ABCDEF"
 15348 00003592 51                      		push	cx
 15349 00003593 E81200                  		call	OUTCHR
 15350 00003596 59                      		pop	cx
 15351                                  COUNT_RET:	; 02/03/2023
 15352 00003597 C3                      		retn
 15353                                  
 15354                                  ; =============== S U B	R O U T	I N E =======================================
 15355                                  
 15356                                  PAD:
 15357 00003598 09C9                    		or	cx,cx
 15358 0000359A 7E0B                    		jle	short PAD_DONE
 15359 0000359C 2EA0[1D3E]              		mov	al,[cs:PAD_CHAR]
 15360                                  PAD_LOOP:
 15361 000035A0 51                      		push	cx
 15362 000035A1 E80400                  		call	OUTCHR
 15363 000035A4 59                      		pop	cx
 15364 000035A5 E2F9                    		loop	PAD_LOOP
 15365                                  PAD_DONE:
 15366 000035A7 C3                      		retn
 15367                                  
 15368                                  ; =============== S U B	R O U T	I N E =======================================
 15369                                  
 15370                                  OUTCHR:
 15371 000035A8 AA                      		stosb
 15372 000035A9 81FF[843E]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15373 000035AD 7401                    		je	short FLUSH
 15374                                  OUTCHR_RETN:
 15375 000035AF C3                      		retn
 15376                                  
 15377                                  ; =============== S U B	R O U T	I N E =======================================
 15378                                  
 15379                                  FLUSH:
 15380 000035B0 B9[203E]                		mov	cx,PRINTF_BUF
 15381 000035B3 87CF                    		xchg	cx,di
 15382 000035B5 29F9                    		sub	cx,di
 15383 000035B7 74F6                    		jz	short OUTCHR_RETN
 15384                                  WRITE_CHARS:
 15385 000035B9 53                      		push	bx
 15386 000035BA 2E8B1E[1E3E]            		mov	bx,[cs:PRINTF_HANDLE]
 15387 000035BF 1E                      		push	ds
 15388 000035C0 0E                      		push	cs
 15389 000035C1 1F                      		pop	ds
 15390 000035C2 BA[203E]                		mov	dx,PRINTF_BUF
 15391 000035C5 B440                    		mov	ah,WRITE ; 40h
 15392 000035C7 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15393                                  					; BX = file handle, CX = number	of bytes to write,
 15394                                  					; DS:DX -> buffer
 15395 000035C9 730B                    		jnb	short FOOB2_1
 15396 000035CB E8A7E8                  		call	GET_EXT_ERR_NUMBER
 15397 000035CE 83F806                  		cmp	ax,6
 15398                                  		;jz	short FOOB2_4
 15399                                  		;jmp	short FOOB2_2
 15400                                  		; 02/03/2023
 15401 000035D1 7507                    		jnz	short FOOB2_2
 15402                                  FOOB2_4:
 15403 000035D3 1F                      		pop	ds
 15404 000035D4 5B                      		pop	bx
 15405 000035D5 C3                      		retn
 15406                                  FOOB2_1:
 15407 000035D6 39C1                    		cmp	cx,ax
 15408 000035D8 74F9                    		jz	short FOOB2_4
 15409                                  FOOB2_2:
 15410 000035DA 89D3                    		mov	bx,dx
 15411 000035DC 01C3                    		add	bx,ax
 15412 000035DE 803F1A                  		cmp	byte [bx],1Ah
 15413 000035E1 74F0                    		jz	short FOOB2_4
 15414 000035E3 1F                      		pop	ds
 15415 000035E4 5B                      		pop	bx
 15416 000035E5 2E8E06[5641]            		mov	es,[cs:RESSEG]
 15417 000035EA BA[4937]                		mov	dx,NOSPACEPTR
 15418 000035ED 26F606440CFF            		test	byte [es:PIPEFLAG],0FFh
 15419 000035F3 7406                    		jz	short PRINT_ERR_EXIT
 15420 000035F5 E814ED                  		call	PIPEOFF
 15421 000035F8 BA[E23B]                		mov	dx,PIPEEMESPTR
 15422                                  PRINT_ERR_EXIT:	
 15423 000035FB E9E8E5                  		jmp	CERROR
 15424                                  
 15425                                  		; 02/03/2023
 15426                                  ;FOOB2_4:
 15427                                  		;pop	ds
 15428                                  		;pop	bx
 15429                                  		;retn
 15430                                  
 15431                                  ; =============== S U B	R O U T	I N E =======================================
 15432                                  
 15433                                  NEXT_CHRS:
 15434 000035FE 56                      		push	si		;Save pointer to control string
 15435 000035FF 89DE                    		mov	si,bx		;Get index into argument list
 15436 00003601 83C302                  		add	bx,2		;Increment the index
 15437 00003604 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15438 00003607 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15439 00003609 5E                      		pop	si
 15440 0000360A C3                      		retn
 15441                                  
 15442                                  ; =============== S U B	R O U T	I N E =======================================
 15443                                  
 15444                                  CLEAR_FLAGS:
 15445 0000360B 31C0                    		xor	ax,ax
 15446 0000360D 2EA2[153E]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15447 00003611 2EA2[163E]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15448 00003615 2EA3[193E]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15449 00003619 B020                    		mov	al,' '			
 15450 0000361B 2EA2[1D3E]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15451 0000361F C3                      		retn
 15452                                  
 15453                                  ; ---------------------------------------------------------------------------
 15454                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15455                                  
 15456                                  		; times 7 db 0
 15457                                  
 15458                                  ;============================================================================
 15459                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15460                                  ;============================================================================
 15461                                  ; 30/09/2018 - Retro DOS v3.0
 15462                                  
 15463                                  ; TITLE	COMMAND Transient Initialized DATA
 15464                                  
 15465                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15466                                  ;initial values at the beginning of each command cycle. It is
 15467                                  ;included in the transient checksum area. If values in TRANDATA
 15468                                  ;change, the transient will be reloaded for the next command cycle.
 15469                                  
 15470                                  align 16
 15471                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15472                                  
 15473 00003620 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15473 00003629 39414243444546     
 15474 00003630 255300                  _3740h:		db '%S',0
 15475 00003633 [3036]                  ARG_BUF_PTR:	dw _3740h
 15476 00003635 [3736]                  		dw _3747h
 15477 00003637 [AD42]                  _3747h:		dw ARG_BUF ; _43E8h
 15478 00003639 25532000                _3749h:		db '%S ',0
 15479 0000363D [3936]                  STRINGBUF1PTR:	dw _3749h
 15480 0000363F [2D43]                  		dw STRING_PTR_1 ; _4468h
 15481 00003641 25396C6400              _3751h:		db '%9ld',0
 15482 00003646 [4136]                  FSIZEMESPTR:	dw _3751h
 15483 00003648 [2F43]                  		dw FILESIZE_L ; _446Ah
 15484 0000364A [3143]                  		dw FILESIZE_H ; _446Ch
 15485 0000364C 255300                  _375Ch:		db '%S',0
 15486 0000364F [4C36]                  STRINGBUF2PTR:	dw _375Ch
 15487 00003651 [3343]                  		dw STRING_PTR_2 ; _446Eh
 15488 00003653 0900                    _3763h:		db 9,0
 15489 00003655 [5336]                  TABPTR:		dw _3763h
 15490 00003657 0D0A                    _3767h:		db 0Dh,0Ah
 15491 00003659 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15491 00003662 65206D697373696E67-
 15491 0000366B 0D0A00             
 15492 0000366E [5736]                  BADPATHPTR:	dw _3767h
 15493 00003670 0D0A                    _3780h:		db 0Dh,0Ah
 15494 00003672 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15494 0000367B 736B20776974682062-
 15494 00003684 617463682066696C65-
 15494 0000368D 0D0A               
 15495 0000368F 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15495 00003698 20616E79206B657920-
 15495 000036A1 7768656E2072656164-
 15495 000036AA 790D0A00           
 15496 000036AE [7036]                  INSERTDSKPTR:	dw _3780h
 15497 000036B0 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15497 000036B9 6E64206F722066696C-
 15497 000036C2 65206E616D650D0A00 
 15498 000036CB [B036]                  BADNAMPTR:	dw _37C0h
 15499 000036CD 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15499 000036D6 2066696C65206E616D-
 15499 000036DF 65206F722046696C65-
 15499 000036E8 206E6F7420666F756E-
 15499 000036F1 640D0A00           
 15500 000036F5 [CD36]                  RENERRPTR:	dw _37DDh
 15501 000036F7 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15501 00003700 666F756E640D0A00   
 15502 00003708 [F736]                  FNOTFOUNDPTR:	dw _3807h
 15503 0000370A 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15503 00003713 666F756E640D0A00   
 15504 0000371B [0A37]                  PNOTFOUNDPTR:	dw _381Ah
 15505 0000371D 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15505 00003726 6E6965640D0A00     
 15506 0000372D [1D37]                  ACCDENPTR:	dw _382Dh
 15507 0000372F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15507 00003738 656E74206469736B20-
 15507 00003741 73706163650D0A00   
 15508 00003749 [2F37]                  NOSPACEPTR:	dw _383Fh
 15509 0000374B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15509 00003754 7669726F6E6D656E74-
 15509 0000375D 2073706163650D0A00 
 15510 00003766 [4B37]                  ENVERRPTR:	dw _385Bh
 15511 00003768 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15511 00003771 74696F6E206572726F-
 15511 0000377A 720D0A00           
 15512 0000377E 7838                    FULDIRPTR:	dw 3878h
 15513 00003780 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15513 00003789 6F7420626520636F70-
 15513 00003792 696564206F6E746F20-
 15513 0000379B 697473656C660D0A00 
 15514 000037A4 [8037]                  OVERWRPTR:	dw _3890h
 15515 000037A6 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15515 000037AF 662064657374696E61-
 15515 000037B8 74696F6E206C6F7374-
 15515 000037C1 206265666F72652063-
 15515 000037CA 6F70790D0A00       
 15516 000037D0 [A637]                  LOSTERRPTR:	dw _38B6h
 15517 000037D2 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15517 000037DB 696C656E616D65206F-
 15517 000037E4 722066696C65206E6F-
 15517 000037ED 7420666F756E640D0A-
 15517 000037F6 00                 
 15518 000037F7 [D237]                  INORNOTPTR:	dw _38E2h
 15519 000037F9 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15519 00003802 732920636F70696564-
 15519 0000380B 0D0A00             
 15520 0000380E [F937]                  COPIEDPTR:	dw _3909h
 15521 00003810 [3543]                  		dw COPY_NUM ; _4470h
 15522 00003812 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15522 0000381B 73292000           
 15523 0000381F [1238]                  DIRMESPTR:	dw _3922h
 15524 00003821 [3C43]                  		dw DIR_NUM  ; _4477h
 15525 00003823 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15525 0000382C 7320667265650D0A00 
 15526 00003835 [2338]                  BYTEMESPTR:	dw _3933h
 15527 00003837 [3E43]                  		dw BYTES_FREE   ; _4479h
 15528 00003839 [4043]                  		dw BYTES_FREE+2 ; _447Bh
 15529 0000383B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15529 00003844 726976652073706563-
 15529 0000384D 696669636174696F6E-
 15529 00003856 0D0A00             
 15530 00003859 [3B38]                  BADDRVPTR:	dw _394Bh
 15531 0000385B 0D0A                    _396Bh:		db 0Dh,0Ah
 15532 0000385D 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15532 00003866 20253564206E6F7420-
 15532 0000386F 707265706172656420-
 15532 00003878 666F72207379737465-
 15532 00003881 6D0D0A00           
 15533 00003885 [5B38]                  CPNOTSETPTR:	dw _396Bh
 15534 00003887 [003E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15535 00003889 0D0A                    _3999h:		db 0Dh,0Ah
 15536 0000388B 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15536 00003894 20253564206E6F7420-
 15536 0000389D 707265706172656420-
 15536 000038A6 666F7220616C6C2064-
 15536 000038AF 6576696365730D0A00 
 15537 000038B8 [8938]                  CPNOTALLPTR:	dw _3999h
 15538 000038BA [003E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15539 000038BC 0D0A                    _39CCh:		db 0Dh,0Ah
 15540 000038BE 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15540 000038C7 646520706167653A20-
 15540 000038D0 2535640D0A00       
 15541 000038D6 [BC38]                  CPACTIVEPTR:	dw _39CCh
 15542 000038D8 [003E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15543 000038DA 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15543 000038E3 72697665206973206E-
 15543 000038EC 6F206C6F6E67657220-
 15543 000038F5 76616C696400       
 15544 000038FB [DA38]                  BADCURDRVPTR:	dw _39EAh
 15545 000038FD 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15545 00003906 6B6579207768656E20-
 15545 0000390F 7265616479202E202E-
 15545 00003918 202E2000           
 15546 0000391C [FD38]                  PAUSEMESPTR:	dw _3A0Dh
 15547 0000391E 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15547 00003927 6172616D657465720D-
 15547 00003930 0A00               
 15548 00003932 [1E39]                  BADPARMPTR:	dw _3A2Eh
 15549 00003934 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15549 0000393D 576564546875467269-
 15549 00003946 536174             
 15550 00003949 0D0A                    _3A59h:		db 0Dh,0Ah
 15551 0000394B 496E76616C69642064-     		db 'Invalid date',0
 15551 00003954 61746500           
 15552 00003958 [4939]                  BADDATPTR:	dw _3A59h
 15553 0000395A 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15553 00003963 6174652069732000   
 15554 0000396B [5A39]                  CURDATPTR:	dw _3A6Ah
 15555 0000396D 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15556 0000396F 456E746572206E6577-     		db 'Enter new date ',0
 15556 00003978 20646174652000     
 15557 0000397F [6D39]                  NEWDATPTR:	dw _3A7Dh
 15558 00003981 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15558 0000398A 293A2000           
 15559 0000398E [8139]                  USADATPTR:	dw _3A91h
 15560 00003990 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15560 00003999 293A2000           
 15561 0000399D [9039]                  EURDATPTR:	dw _3AA0h
 15562 0000399F 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15562 000039A8 293A2000           
 15563 000039AC [9F39]                  JAPDATPTR:	dw _3AAFh
 15564 000039AE 0D0A                    _3ABEh:		db 0Dh,0Ah
 15565 000039B0 496E76616C69642074-     		db 'Invalid time ',0
 15565 000039B9 696D652000         
 15566 000039BE [AE39]                  BADTIMPTR:	dw _3ABEh
 15567 000039C0 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15567 000039C9 696D652069732000   
 15568 000039D1 [C039]                  CURTIMPTR:	dw _3AD0h
 15569 000039D3 0D0A                    _3AE3h:		db 0Dh,0Ah
 15570 000039D5 456E746572206E6577-     		db 'Enter new time: ',0
 15570 000039DE 2074696D653A2000   
 15571 000039E6 [D339]                  NEWTIMPTR:	dw _3AE3h
 15572 000039E8 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15572 000039F1 7572652028592F4E29-
 15572 000039FA 3F00               
 15573 000039FC [E839]                  SUREMESPTR:	dw _3AF8h
 15574 000039FE 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15574 00003A07 00                 
 15575 00003A08 [FE39]                  DMESPTR:	dw _3B0Eh
 15576 00003A0A 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15576 00003A13 7273696F6E20253164-
 15576 00003A1C 2E2530326420202020-
 15576 00003A25 202020202020202020-
 15576 00003A2E 202020202020202000 
 15577 00003A37 [0A3A]                  VERMESPTR:	dw _3B1Ah
 15578 00003A39 [4243]                  		dw MAJOR_VER_NUM ; _447Dh
 15579 00003A3B [4443]                  		dw MINOR_VER_NUM ; _447Fh
 15580 00003A3D 254300                  _3B4Dh:		db '%C',0
 15581 00003A40 [3D3A]                  ONECHRVALPTR:	dw _3B4Dh
 15582 00003A42 [4643]                  		dw ONE_CHAR_VAL	; _4481h
 15583 00003A44 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15583 00003A4D 6E2064726976652025-
 15583 00003A56 6320257300         
 15584 00003A5B [443A]                  VOLMESPTR:	dw _3B54h
 15585 00003A5D [4943]                  		dw VOL_DRV ; _4484h
 15586 00003A5F [4743]                  		dw VOLNAME_ADDR ; _4482h
 15587 00003A61 69732000                IS:		db 'is ',0
 15588 00003A65 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15588 00003A6E 62656C00           
 15589 00003A72 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15589 00003A7B 69726563746F72790D-
 15589 00003A84 0A00               
 15590 00003A86 [723A]                  BADCDPTR:	dw _3B82h
 15591 00003A88 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15591 00003A91 206372656174652064-
 15591 00003A9A 69726563746F72790D-
 15591 00003AA3 0A00               
 15592 00003AA5 [883A]                  BADMKDPTR:	dw _3B98h
 15593 00003AA7 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15593 00003AB0 6174682C206E6F7420-
 15593 00003AB9 6469726563746F7279-
 15593 00003AC2 2C0D0A             
 15594 00003AC5 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15594 00003ACE 6F7279206E6F742065-
 15594 00003AD7 6D7074790D0A00     
 15595 00003ADE [A73A]                  BADRMDPTR:	dw _3BB7h
 15596 00003AE0 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15596 00003AE9 696679204F4E206F72-
 15596 00003AF2 204F46460D0A00     
 15597 00003AF9 [E03A]                  BADONOFFPTR:	dw _3BF0h
 15598 00003AFB 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15598 00003B04 79206F66202025530D-
 15598 00003B0D 0A00               
 15599 00003B0F [FB3A]                  DIRHEADPTR:	dw _3C0Bh
 15600 00003B11 [4A43]                  		dw VOL_DIR ; _4485h
 15601 00003B13 4E6F205061746800        _3C23h:		db 'No Path',0
 15602 00003B1B [133B]                  NULLPATHPTR:	dw _3C23h
 15603 00003B1D 504154483D              PATH_TEXT:	db 'PATH='
 15604 00003B22 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15605 00003B29 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15606 00003B31 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15606 00003B3A 7269766520696E2073-
 15606 00003B43 656172636820706174-
 15606 00003B4C 680D0A00           
 15607 00003B50 [313B]                  BADPMESPTR:	dw _3C41h
 15608 00003B52 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15608 00003B5B 65766963650D0A00   
 15609 00003B63 [523B]                  BADDEVPTR:	dw _3C62h
 15610 00003B65 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15610 00003B6E 20666F756E640D0A00 
 15611 00003B77 [653B]                  BADLABPTR:	dw _3C75h
 15612 00003B79 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15612 00003B82 726F720D0A00       
 15613 00003B88 [793B]                  SYNTMESPTR:	dw _3C89h
 15614 00003B8A 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15614 00003B93 6F74206265206E6573-
 15614 00003B9C 7465640D0A00       
 15615 00003BA2 [8A3B]                  FORNESTMESTR:	dw _3C9Ah
 15616 00003BA4 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15616 00003BAD 656E74206D656D6F72-
 15616 00003BB6 790D0A00           
 15617 00003BBA [A43B]                  INSFMEMMESPTR:	dw _3CB4h
 15618 00003BBC 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15618 00003BC5 6174652066696C6520-
 15618 00003BCE 6572726F7220647572-
 15618 00003BD7 696E6720706970650D-
 15618 00003BE0 0A00               
 15619 00003BE2 [BC3B]                  PIPEEMESPTR:	dw _3CCCh
 15620 00003BE4 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15620 00003BED 2062696E6172792072-
 15620 00003BF6 656164732066726F6D-
 15620 00003BFF 206120646576696365-
 15620 00003C08 0D0A00             
 15621 00003C0B [E43B]                  INBDEVPTR:	dw _3CF4h
 15622 00003C0D 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15622 00003C16 00                 
 15623 00003C17 [0D3C]                  CTRLMESPTR:	dw _3D1Dh
 15624 00003C19 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15624 00003C22 2000               
 15625 00003C24 [193C]                  VERIMESPTR:	dw _3D29h
 15626 00003C26 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15627 00003C2F [263C]                  ECHOMESPTR:	dw _3D36h
 15628 00003C31 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15629 00003C37 [313C]                  OFFMESPTR:	dw _3D41h
 15630 00003C39 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15631 00003C3E [393C]                  ONMESPTR:	dw _3D49h
 15632 00003C40 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15632 00003C49 617468206F72206669-
 15632 00003C52 6C65206E616D650D0A-
 15632 00003C5B 00                 
 15633 00003C5C [403C]                  BADCPMESPTR:	dw _3D50h
 15634 00003C5E 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15634 00003C67 756D626572206F6620-
 15634 00003C70 706172616D65746572-
 15634 00003C79 730D0A00           
 15635 00003C7D [5E3C]                  BADARGSPTR:	dw _3D6Eh
 15636 00003C7F 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15636 00003C88 74696E6720746F2064-
 15636 00003C91 65766963650D0A00   
 15637 00003C99 [7F3C]                  DEVWMESPTR:	dw _3D8Fh
 15638 00003C9B 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15639 00003C9E [9B3C]                  ACRLFPTR:	dw _3DABh
 15640 00003CA0 08                      _3DB0h:		db 8
 15641 00003CA1 20                      		db 20h
 15642 00003CA2 08                      		db 8
 15643 00003CA3 00                      		db 0
 15644 00003CA4 [A03C]                  DBACKPTR:	dw _3DB0h
 15645 00003CA6 79                      small_y:	db 'y'
 15646 00003CA7 6E                      small_n:	db 'n'
 15647 00003CA8 59                      CAPITAL_Y:	db 'Y'
 15648 00003CA9 4E                      CAPITAL_N:	db 'N'
 15649 00003CAA 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15650                                  PROMPT_TABLE:
 15651 00003CAF 42                      		db 'B' ; 42h
 15652 00003CB0 [D413]                  		dw PRINT_B
 15653 00003CB2 44                      		db 'D' ; 44h
 15654 00003CB3 [0629]                  		dw PRINT_DATE
 15655 00003CB5 45                      		db 'E' ; 45h
 15656 00003CB6 [C813]                  		dw PRINT_ESC
 15657 00003CB8 47                      		db 'G' ; 47h
 15658 00003CB9 [CC13]                  		dw PRINT_G
 15659 00003CBB 48                      		db 'H' ; 48h
 15660 00003CBC [BE13]                  		dw PRINT_BACK
 15661 00003CBE 4C                      		db 'L' ; 4Ch
 15662 00003CBF [D013]                  		dw PRINT_L
 15663 00003CC1 4E                      		db 'N' ; 4Eh
 15664 00003CC2 [E913]                  		dw PRINT_DRIVE
 15665 00003CC4 50                      		db 'P' ; 50h
 15666 00003CC5 [F113]                  		dw BUILD_DIR_FOR_PROMPT
 15667 00003CC7 51                      		db 'Q' ; 51h
 15668 00003CC8 [C413]                  		dw PRINT_EQ
 15669 00003CCA 54                      		db 'T' ; 54h
 15670 00003CCB [AE21]                  		dw PRINT_TIME
 15671 00003CCD 56                      		db 'V' ; 56h
 15672 00003CCE [5213]                  		dw PRINT_VERSION
 15673 00003CD0 5F                      		db '_' ; 5Fh
 15674 00003CD1 [3519]                  		dw CRLF2
 15675 00003CD3 24                      		db '$' ; 24h
 15676 00003CD4 [D613]                  		dw PRINT_CHAR
 15677 00003CD6 00                      		db 0
 15678                                  
 15679                                  		; Table of IF conditionals
 15680                                  IFTAB:
 15681 00003CD7 03                      		db 3	; First byte is count
 15682 00003CD8 4E4F54                  		db 'NOT'
 15683 00003CDB [7609]                  		dw IFNOT
 15684 00003CDD 0A                      		db 10
 15685 00003CDE 4552524F524C455645-     		db 'ERRORLEVEL'
 15685 00003CE7 4C                 
 15686 00003CE8 [390A]                  		dw IFERLEV
 15687 00003CEA 05                      		db 5
 15688 00003CEB 4558495354              		db 'EXIST'
 15689 00003CF0 [CD09]                  		dw IFEXISTS
 15690 00003CF2 00                      		db 0
 15691                                  
 15692                                  		; Table for internal command names
 15693                                  
 15694 00003CF3 03                      COMTAB:		db 3
 15695 00003CF4 444952                  		db 'DIR'
 15696 00003CF7 03                      		db 3
 15697 00003CF8 [A80E]                  		dw CATALOG
 15698 00003CFA 04                      		db 4
 15699 00003CFB 43414C4C                		db 'CALL'
 15700 00003CFF 02                      		db 2
 15701 00003D00 [AE0A]                  		dw _$CALL
 15702 00003D02 04                      		db 4
 15703 00003D03 43484350                		db 'CHCP'
 15704 00003D07 02                      		db 2
 15705 00003D08 [9515]                  		dw CHCP
 15706 00003D0A 06                      		db 6
 15707 00003D0B 52454E414D45            		db 'RENAME'
 15708 00003D11 01                      		db 1
 15709 00003D12 [E411]                  		dw CRENAME
 15710 00003D14 03                      		db 3
 15711 00003D15 52454E                  		db 'REN'
 15712 00003D18 01                      		db 1
 15713 00003D19 [E411]                  		dw CRENAME
 15714 00003D1B 05                      		db 5
 15715 00003D1C 4552415345              		db 'ERASE'
 15716 00003D21 01                      		db 1
 15717 00003D22 [7B11]                  		dw ERASE
 15718 00003D24 03                      		db 3
 15719 00003D25 44454C                  		db 'DEL'
 15720 00003D28 01                      		db 1
 15721 00003D29 [7B11]                  		dw ERASE
 15722 00003D2B 04                      		db 4
 15723 00003D2C 54595045                		db 'TYPE'
 15724 00003D30 01                      		db 1
 15725 00003D31 [5612]                  		dw TYPEFIL
 15726 00003D33 03                      		db 3
 15727 00003D34 52454D                  		db 'REM'
 15728 00003D37 02                      		db 2
 15729 00003D38 [0401]                  		dw TCOMMAND
 15730 00003D3A 04                      		db 4
 15731 00003D3B 434F5059                		db 'COPY'
 15732 00003D3F 03                      		db 3
 15733 00003D40 [5829]                  		dw COPY
 15734 00003D42 05                      		db 5
 15735 00003D43 5041555345              		db 'PAUSE'
 15736 00003D48 02                      		db 2
 15737 00003D49 [6F11]                  		dw PAUSE
 15738 00003D4B 04                      		db 4
 15739 00003D4C 44415445                		db 'DATE'
 15740 00003D50 02                      		db 2
 15741 00003D51 [8A20]                  		dw DATE
 15742 00003D53 04                      		db 4
 15743 00003D54 54494D45                		db 'TIME'
 15744 00003D58 00                      		db 0
 15745 00003D59 [9B21]                  		dw CTIME
 15746 00003D5B 03                      		db 3
 15747 00003D5C 564552                  		db 'VER'
 15748 00003D5F 00                      		db 0
 15749 00003D60 [4913]                  		dw VERSION
 15750 00003D62 03                      		db 3
 15751 00003D63 564F4C                  		db 'VOL'
 15752 00003D66 01                      		db 1
 15753 00003D67 [F312]                  		dw VOLUME
 15754 00003D69 02                      		db 2
 15755 00003D6A 4344                    		db 'CD'
 15756 00003D6C 01                      		db 1
 15757 00003D6D [7518]                  		dw _$CHDIR
 15758 00003D6F 05                      		db 5
 15759 00003D70 4348444952              		db 'CHDIR'
 15760 00003D75 01                      		db 1
 15761 00003D76 [7518]                  		dw _$CHDIR
 15762 00003D78 02                      		db 2
 15763 00003D79 4D44                    		db 'MD'
 15764 00003D7B 01                      		db 1
 15765 00003D7C [B718]                  		dw _$MKDIR
 15766 00003D7E 05                      		db 5
 15767 00003D7F 4D4B444952              		db 'MKDIR'
 15768 00003D84 01                      		db 1
 15769 00003D85 [B718]                  		dw _$MKDIR
 15770 00003D87 02                      		db 2
 15771 00003D88 5244                    		db 'RD'
 15772 00003D8A 01                      		db 1
 15773 00003D8B [F918]                  		dw _$RMDIR
 15774 00003D8D 05                      		db 5
 15775 00003D8E 524D444952              		db 'RMDIR'
 15776 00003D93 01                      		db 1
 15777 00003D94 [F918]                  		dw _$RMDIR
 15778 00003D96 05                      		db 5
 15779 00003D97 425245414B              		db 'BREAK'
 15780 00003D9C 00                      		db 0
 15781 00003D9D [3E28]                  		dw CNTRLC
 15782 00003D9F 06                      		db 6
 15783 00003DA0 564552494659            		db 'VERIFY'
 15784 00003DA6 00                      		db 0
 15785 00003DA7 [7028]                  		dw VERIFY
 15786 00003DA9 03                      		db 3
 15787 00003DAA 534554                  		db 'SET'
 15788 00003DAD 02                      		db 2
 15789 00003DAE [6A16]                  		dw ADD_NAME_TO_ENVIRONMENT
 15790 00003DB0 06                      		db 6
 15791 00003DB1 50524F4D5054            		db 'PROMPT'
 15792 00003DB7 02                      		db 2
 15793 00003DB8 [5016]                  		dw ADD_PROMPT
 15794 00003DBA 04                      		db 4
 15795 00003DBB 50415448                		db 'PATH'
 15796 00003DBF 02                      		db 2
 15797 00003DC0 [5814]                  		dw PATH
 15798 00003DC2 04                      		db 4
 15799 00003DC3 45584954                		db 'EXIT'
 15800 00003DC7 00                      		db 0
 15801 00003DC8 [2216]                  		dw _$EXIT
 15802 00003DCA 04                      		db 4
 15803 00003DCB 43545459                		db 'CTTY'
 15804 00003DCF 03                      		db 3
 15805 00003DD0 [3115]                  		dw CTTY
 15806 00003DD2 04                      		db 4
 15807 00003DD3 4543484F                		db 'ECHO'
 15808 00003DD7 02                      		db 2
 15809 00003DD8 [FB27]                  		dw ECHO
 15810 00003DDA 04                      		db 4
 15811 00003DDB 474F544F                		db 'GOTO'
 15812 00003DDF 02                      		db 2
 15813 00003DE0 [E20A]                  		dw GOTO
 15814 00003DE2 05                      		db 5
 15815 00003DE3 5348494654              		db 'SHIFT'
 15816 00003DE8 02                      		db 2
 15817 00003DE9 [670A]                  		dw SHIFT
 15818 00003DEB 02                      		db 2
 15819 00003DEC 4946                    		db 'IF'
 15820 00003DEE 02                      		db 2
 15821 00003DEF [2609]                  		dw _$IF
 15822 00003DF1 03                      		db 3
 15823 00003DF2 464F52                  		db 'FOR'
 15824 00003DF5 02                      		db 2
 15825 00003DF6 [3B0D]                  		dw _$FOR
 15826 00003DF8 03                      		db 3
 15827 00003DF9 434C53                  		db 'CLS'
 15828 00003DFC 00                      		db 0
 15829 00003DFD [C614]                  		dw CLS
 15830 00003DFF 00                      		db 0
 15831                                  
 15832                                  ; 01/03/2023
 15833                                  ;CAPITAL_A:	db 'A'
 15834                                  ;VBAR:		db '|'
 15835                                  ;LABRACKET:	db '<' ; 3Ch
 15836                                  ;RABRACKET:	db '>' ; 3Eh
 15837                                  ;DOLLAR:	db '$'
 15838                                  ;LPAREN:	db '('
 15839                                  ;RPAREN:	db ')'
 15840                                  ;NULLRPAREN:	db ')' ; 29h
 15841                                  ;		db 0
 15842                                  ;IN_WORD:	db 'I','N'
 15843                                  ;DO_WORD:	db 'D','O'
 15844                                  ;STAR:		db '*'
 15845                                  ;CHAR_SUB:	db '-' 
 15846                                  ;PLUS_CHR:	db '+'
 15847                                  ;CHAR_L:	db 'L'
 15848                                  ;char_l:	db 'l'
 15849                                  ;small_a:	db 'a'
 15850                                  ;small_z:	db 'z'
 15851                                  ;CHAR_D:	db 'D'
 15852                                  ;CHAR_C:	db 'C'
 15853                                  ;CHAR_S:	db 'S'
 15854                                  ;CHAR_X:	db 'X'
 15855                                  ;DOT_CHR:	db '.' 
 15856                                  ;DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15857                                  ;		db ','
 15858                                  ;TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15859                                  ;MNCHR:		db 'p'
 15860                                  
 15861 00003E00 0000                    SYSTEM_CPAGE:	dw 0
 15862                                  
 15863 00003E02 2E434F4D                COMEXT:		db '.COM'
 15864 00003E06 2E455845                EXEEXT:		db '.EXE'
 15865 00003E0A 2E424154                BATEXT:		db '.BAT'
 15866 00003E0E 5642415057              SWITCH_LIST:	db 'VBAPW'
 15867 00003E13 2000                    BATBUFLEN:	dw BATLEN ; 32
 15868                                  
 15869                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15870                                  
 15871                                  TRANDATAEND:
 15872                                  
 15873                                  ;============================================================================
 15874                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15875                                  ;============================================================================
 15876                                  ; 29/09/2018 - Retro DOS v3.0
 15877                                  
 15878                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15879                                  
 15880                                  ;The TRANSPACE segment contains variable data that is considered
 15881                                  ;volatile between command cycles, and therefore is not included in the
 15882                                  ;transient checksum area. Contents of these variables MUST be
 15883                                  ;initialized before use, and must not be relied upon from command
 15884                                  ;cycle to command cycle.
 15885                                  ;
 15886                                  ;No constant data values should be stored here.
 15887                                  
 15888                                  ; ---------------------------------------------------------------------------
 15889                                  ; START OF UNITIALIZED DATA
 15890                                  ; ---------------------------------------------------------------------------	
 15891                                  
 15892                                  ;	times 12 db 0
 15893                                  
 15894                                  ; 03/03/2023
 15895                                  ;align 16
 15896                                  
 15897                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15898                                  
 15899 00003E15 00                      PRINTF_LEFT:	db 0
 15900 00003E16 00                      PRINTF_LONG:	db 0
 15901 00003E17 00                      PRINTF_HEX:	db 0
 15902 00003E18 00                      TABLE_INDEX:	db 0
 15903 00003E19 0000                    PRINTF_WIDTH:	dw 0
 15904 00003E1B 0000                    PRINTF_BASE:	dw 0
 15905 00003E1D 00                      PAD_CHAR:	db 0
 15906 00003E1E 0000                    PRINTF_HANDLE:	dw 0
 15907 00003E20 00<rep 64h>             PRINTF_BUF: times 100 db 0
 15908                                  PRINTF_BUF_END: ; 30/09/2018
 15909                                  
 15910                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15911                                  
 15912 00003E84 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15913 00003EDB 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15914 00003F32 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15915 00003FB5 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15916 00004038 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15917 0000407E 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15918 00004101 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15919                                  
 15920                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15921 00004154 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15922 00004156 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15923 00004158 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15924 0000415A 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15925 0000415B 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15926 0000415C 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15927                                  					; MYSEG1    (dw 0)	
 15928 00004160 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15929                                  					; MYSEG2    (dw 0)	
 15930 00004164 0000                    		dw 0			; RESTEST   (dw 0)	
 15931 00004166 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15932                                  
 15933 00004168 00                      CHKDRV:		db 0
 15934                                  IFNOTFLAG:
 15935                                  FILTYP:
 15936 00004169 00                      RDEOF:		db 0			; Misc flags
 15937 0000416A 00                      CURDRV:		db 0
 15938                                  PARM1:
 15939 0000416B 00                      CONCAT:		db 0
 15940                                  PARM2:
 15941 0000416C 00                      ARGC:		db 0
 15942 0000416D 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15943 0000416F 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15944                                  ARG2S:					; Switches after 2nd arg		
 15945 00004171 0000                    DESTSWITCH:	dw 0
 15946                                  ARGTS:
 15947 00004173 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15948 00004175 00                      CFLAG:		db 0
 15949                                  DESTCLOSED:
 15950 00004176 00                      SPECDRV:	db 0
 15951 00004177 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15952 00004179 0000                    NXTADD:		dw 0
 15953 0000417B 00                      FRSTSRCH:	db 0
 15954                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15955                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15956 0000417C 00                      LINCNT:		db 0
 15957 0000417D 00                      LINLEN:		db 0
 15958                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15959 0000417E 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15960                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15961                                  
 15962                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15963                                  ;
 15964                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15965                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15966                                  
 15967                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15968                                  
 15969 00004180 00<rep 50h>             CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15970                                  DESTFCB2:
 15971 000041D0 00                      IDLEN:		db 0
 15972 000041D1 00<rep 8h>              ID:	  times	8  db 0
 15973 000041D9 00<rep 3h>              COM:	  times	3  db 0 
 15974 000041DC 00<rep 25h>             DEST:	  times 37 db 0
 15975 00004201 00<rep Bh>              DESTNAME: times 11 db 0
 15976                                  DESTDIR:
 15977 0000420C 00<rep 43h>             DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15978                                  GOTOLEN:	; word
 15979                                  BWDBUF: 	; byte
 15980                                  EXEFCB: 	; word
 15981 0000424F 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15982                                  
 15983                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15984                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15985                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15986                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15987                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15988                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15989                                  
 15990 00004295 00<rep Ch>              SDIRBUF:  times 12 db 0	
 15991 000042A1 0000                    _BITS:		dw 0
 15992 000042A3 0000                    PATHCNT:	dw 0
 15993 000042A5 0000                    PATHPOS:	dw 0
 15994 000042A7 0000                    PATHSW:		dw 0
 15995                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15996                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15997 000042A9 00                      LINPERPAG:	db 0
 15998 000042AA 00                      		db 0
 15999 000042AB 00                      COMMA:		db 0			; flag set if +,, occurs
 16000 000042AC 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 16001                                  
 16002                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 16003                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 16004                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 16005                                  
 16006 000042AD 00<rep 80h>             ARG_BUF:  times 128 db 0   ; _43E8h	
 16007 0000432D 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 16008 0000432F 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 16009 00004331 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 16010 00004333 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 16011                                  
 16012 00004335 0000                    COPY_NUM:	dw 0
 16013 00004337 00<rep 4h>              	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 16014 0000433B 00                      CPYFLAG:	db 0
 16015 0000433C 0000                    DIR_NUM:	dw 0
 16016 0000433E 0000                    BYTES_FREE:	dw 0
 16017 00004340 0000                    		dw 0
 16018 00004342 0000                    MAJOR_VER_NUM:	dw 0
 16019 00004344 0000                    MINOR_VER_NUM:	dw 0
 16020 00004346 00                      ONE_CHAR_VAL:	db 0
 16021                                  		;db 0
 16022 00004347 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 16023 00004349 00                      VOL_DRV:	db 0
 16024 0000434A 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 16025                                  
 16026 0000434C 00                      ROM_CALL:	db 0			; flag for rom function
 16027 0000434D 0000                    ROM_IP:		dw 0
 16028 0000434F 0000                    ROM_CS:		dw 0
 16029                                  
 16030                                  DESTVARS:
 16031 00004351 00                      DESTISDIR:	db 0
 16032 00004352 00                      DESTSIZ:	db 0
 16033 00004353 0000                    DESTTAIL:	dw 0
 16034 00004355 00                      DESTINFO:	db 0
 16035 00004356 00<rep 57h>             DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 16036                                  ENDDESTBUF:
 16037                                  
 16038 000043AD 0000                    DESTHAND:	dw 0
 16039 000043AF 00                      DESTISDEV:	db 0
 16040 000043B0 00                      FIRSTDEST:	db 0
 16041 000043B1 00                      MELCOPY:	db 0
 16042 000043B2 0000                    MELSTART:	dw 0
 16043                                  
 16044                                  SRCVARS:
 16045 000043B4 00                      SRCISDIR:	db 0
 16046 000043B5 00                      SRCSIZ:		db 0
 16047 000043B6 0000                    SRCTAIL:	dw 0
 16048 000043B8 00                      SRCINFO:	db 0
 16049 000043B9 00<rep 57h>             SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 16050                                  
 16051 00004410 0000                    SRCHAND:	dw 0
 16052 00004412 00                      SRCISDEV:	db 0
 16053                                  
 16054 00004413 00<rep 57h>             SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 16055                                  
 16056 0000446A 0000                    SRCPT:		dw 0
 16057 0000446C 00                      INEXACT:	db 0
 16058 0000446D 00                      		db 0 ; MSDOS 3.3 
 16059 0000446E 00                      NOWRITE:	db 0
 16060 0000446F 00                      BINARY:		db 0
 16061 00004470 0000                    WRITTEN:	dw 0
 16062 00004472 00                      TERMREAD:	db 0
 16063 00004473 00                      ASCII:		db 0
 16064 00004474 00                      PLUS:		db 0
 16065 00004475 00                      OBJCNT:		db 0			; Used in copy
 16066 00004476 0000                    CPDATE:		dw 0
 16067 00004478 0000                    CPTIME:		dw 0
 16068                                  
 16069                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 16070                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 16071                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 16072                                  
 16073 0000447A 0000                    BATHAND:	dw 0			; Batch handle
 16074 0000447C 0000                    STARTEL:	dw 0
 16075 0000447E 00                      ELCNT:		db 0
 16076 0000447F 00                      ELPOS:		db 0
 16077 00004480 00<rep Bh>              SOURCE:   times	11 db 0
 16078                                  
 16079 0000448B 00                      ext_entered:	db 0			;AN005;
 16080                                  
 16081                                  ;display_ioctl	db 0			;AN000; info level
 16082                                  ;		db 0			;AN000; reserved
 16083                                  ;		dw crt_ioctl_ln		;AN000; length of data
 16084                                  ;		dw 0			;AN000; control flags
 16085                                  ;display_mode:	db 0			;AN000; display mode, colors
 16086                                  ;		db 0			;AN000; reserved
 16087                                  ;		dw 0			;AN023; colors
 16088                                  ;		dw 0			;AN000; display width (PELS)
 16089                                  ;		dw 0			;AN000; display length (PELS)
 16090                                  ;display_width:	dw 0			;AN000; display width
 16091                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 16092                                  ;
 16093                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 16094                                  ;		dw 0			;AN000; info level
 16095                                  ;vol_serial:	dd 0			;AN000; volume serial number
 16096                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 16097                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 16098                                  
 16099 0000448C 00                      EXPAND_STAR:	db 0
 16100                                  
 16101                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 16102                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 16103                                  ;append_exec:	db 0			;AN041; set if internal append executed
 16104                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 16105                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 16106                                  
 16107 0000448D 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 16108                                  
 16109                                  ; Data declarations taken out of parse.asm
 16110                                  
 16111                                  ; MSDOS 6.0
 16112                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 16113                                  ;argbufptr	dw	?		; index for argv[].argpointer
 16114                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 16115                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 16116                                  ;comptr		dw	?		; ptr into combuf
 16117                                  
 16118                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 16119                                  ARG:
 16120                                  ARG_ARGV:
 16121 0000448E 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 16122 00004490 00                      ARGV0_ARG_FLAGS:  db 0
 16123 00004491 0000                    ARGV0_ARGSTARTEL: dw 0
 16124 00004493 0000                    ARGV0_ARGLEN:	  dw 0
 16125 00004495 0000                    ARGV0_ARGSW_WORD: dw 0
 16126 00004497 0000                    ARGV0_OCOMPTR:	  dw 0
 16127                                  
 16128 00004499 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 16129 0000449B 00<rep 5h>              	  times 5 db 0
 16130 000044A0 0000                    ARGV1_ARGSW_WORD: dw 0
 16131 000044A2 0000                    		  dw 0
 16132                                  
 16133 000044A4 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 16134 000044A6 00<rep 5h>              	  times 5 db 0
 16135 000044AB 0000                    ARGV2_ARGSW_WORD: dw 0
 16136 000044AD 0000                    		  dw 0
 16137                                  
 16138 000044AF 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 16139                                  	
 16140 0000474E 0000                    ARG_ARGVCNT:	dw 0
 16141 00004750 0000                    ARG_ARGSWINFO:	dw 0
 16142                                  
 16143 00004752 0000<rep 100h>          ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 16144 00004952 00<rep 80h>             ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 16145                                  
 16146                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 16147                                  
 16148 000049D2 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 16149 000049D4 00<rep 80h>             TPBUF:    times 128 db 0		; temporary buffer
 16150 00004A54 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 16151 00004A56 0000                    COMPTR:		dw 0			; ptr into combuf
 16152                                  
 16153                                  ; Data declarations taken out of path.asm
 16154                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 16155                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 16156                                  ;psep_char	DB	?			; '/' or '\'
 16157                                  ;search_best	DB	(?)			; best code, best filename so far
 16158                                  ;fname_max_len	equ	13
 16159                                  ;search_best_buf DB	fname_max_len DUP (?)
 16160                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 16161                                  ;search_error	DW	(?)			; address of error message to be printed
 16162                                  
 16163                                  FINDBUFLEN equ FIND_BUF.size ; 43
 16164                                  
 16165                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 16166                                  
 16167 00004A58 00<rep 2Bh>             FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 16168                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 16169                                  PATHINFO:
 16170 00004A83 0000                    PATHINFO_0:	dw 0
 16171 00004A85 0000                    PATHINFO_2:	dw 0
 16172 00004A87 0000                    PATHINFO_4:	dw 0
 16173 00004A89 00                      PSEP_CHAR:	db 0
 16174 00004A8A 00                      SEARCH_BEST:	db 0
 16175                                  ;FNAME_MAX_LEN equ 13
 16176 00004A8B 00<rep Dh>              SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 16177 00004A98 00<rep 40h>             SEARCH_CURDIR_BUF: times 64 db 0
 16178 00004AD8 0000                    SEARCH_ERROR:	dw 0
 16179                                  
 16180                                  ; Data declarations taken out of tbatch.asm
 16181                                  
 16182                                  ;if_not_count	DW	?
 16183                                  ;
 16184                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 16185                                  ;
 16186                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 16187                                  ;STACK		LABEL	WORD
 16188                                  
 16189                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 16190                                  
 16191 00004ADA 0000                    IF_NOT_COUNT:	dw 0
 16192 00004ADC 00                      ZFLAG:		db 0
 16193 00004ADD 00                      		db 0 ; 03/03/2023
 16194 00004ADE 00<rep 100h>            	  times 256 db 0 	
 16195                                  STACK:
 16196                                  
 16197                                  ;INTERNATVARS	internat_block <>
 16198                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 16199                                  ;
 16200                                  ;;		Buffer for DOS function 64h (Get extended country information)
 16201                                  ;;		subfunctions 2, 4, 6, or 7:
 16202                                  ;
 16203                                  ;CountryPtrInfo	label	byte
 16204                                  ;CountryPtrId	db	?
 16205                                  ;CountryPtr	dd	?
 16206                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 16207                                  
 16208                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 16209                                  
 16210                                  INTERNATVARS:	
 16211 00004BDE 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 16212 00004BE0 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 16213 00004BE5 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 16214 00004BE7 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 16215 00004BE9 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 16216 00004BEB 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 16217 00004BED 00                      BIT_FIELD:	db 0			; Bit values
 16218                                  					;   Bit 0 = 0 if currency symbol first
 16219                                  					;	  = 1 if currency symbol last
 16220                                  					;   Bit 1 = 0 if No space after currency symbol
 16221                                  					;	  = 1 if space after currency symbol
 16222 00004BEE 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16223 00004BEF 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16224 00004BF0 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16225                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16226                                  					;  in pieces.
 16227 00004BF4 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16228                                  
 16229 00004BF6 00<rep 8h>              		times 8 db 0
 16230                                  ;
 16231                                  ; Max size of the block returned by the INTERNATIONAL call
 16232                                  ;
 16233                                  INTERNAT_BLOCK_SIZE EQU	32
 16234                                  
 16235                                  BATLEN equ 32
 16236                                  	
 16237                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16238                                  
 16239 00004BFE 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16240                                  
 16241 00004C00 00<rep 20h>             BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16242                                  
 16243 00004C20 0000                    BATBUFEND:	dw 0
 16244                                  
 16245                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16246                                  
 16247                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
