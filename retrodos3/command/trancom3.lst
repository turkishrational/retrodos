     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 24/02/2023 ((Prev: 20/10/2018))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   309 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   315 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   316 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 ??                      .ISDIR:		RESB	1
   623 00000001 ??                      .SIZ:		RESB	1
   624 00000002 ????                    .TTAIL:		RESW	1
   625 00000004 ??                      .INFO:		RESB	1
   626 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 ??                      .BatType:	RESB	1		; signature
   660 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   691 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   735 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   736 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   737 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   738 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   739 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   740 00000015 ??                      .ATTR:	    resb 1	; attribute found
   741 00000016 ????                    .TIMR:	    resw 1	; time
   742 00000018 ????                    .DATE:	    resw 1	; date
   743 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   744 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   745 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 ??                                      resb 1
   766 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   768 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   782 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 ????                    .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 ??????????              .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 ????                    .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 ????                    .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B ????                    .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D ????                    .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F ??                      .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 ??                      .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 ??                      .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 ????                    .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 ????                                      RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 ????                    .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 ????                      .owner:	resw 1		; owner of arena item
   917 00000003 ????                      .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  ;LODCOM1   equ	0318h	; 13/10/2018
   962                                  LODCOM1    equ	0319h	; 24/02/2023
   963                                  
   964                                  ; EXEC call adressses in resident portion for calling from transient portion
   965                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   966                                  
   967                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   968                                  ;PUTBACKDRV equ	0A21h	; 14/10/2018
   969                                  PUTBACKDRV equ	0A23h	; 24/02/2023
   970                                  
   971                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   972                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   973                                  
   974                                  ; Resident portion stack address  
   975                                  ;RSTACK	   equ	083Ch
   976                                  RSTACK	   equ	083Eh	; 24/02/2023 
   977                                  
   978                                  ;RETRABASE equ  0B86h	; 13/10/2018 (Base addr for following common params.)
   979                                  RETRABASE  equ  0B88h	; 24/02/2023	
   980                                  
   981                                  ; RESGROUP       [RESSEG]
   982                                  ; DATA		  offset
   983                                  ; --------     	------------
   984                                  PARENT	  equ	RETRABASE+6	; 0B8Ch
   985                                  OLDTERM	  equ	RETRABASE+8	; 0B9Eh
   986                                  BATCH	  equ	RETRABASE+17	; 0B97h
   987                                  COMSPEC	  equ	RETRABASE+19	; 0B99h
   988                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD9h
   989                                  COMSPEC_END equ	RETRABASE+85	; 0BDBh
   990                                  IN_BATCH  equ	RETRABASE+92	; 0BE2h
   991                                  BATCH_ABORT equ	RETRABASE+93	; 0BE3h
   992                                  COMDRV	  equ	RETRABASE+94	; 0BE4h
   993                                  EXTCOM	  equ	RETRABASE+99	; 0BE9h
   994                                  RETCODE	  equ	RETRABASE+100	; 0BEAh
   995                                  ECHOFLAG  equ	RETRABASE+103	; 0BEDh
   996                                  SUPPRESS  equ	RETRABASE+104	; 0BEEh
   997                                  IO_SAVE	  equ	RETRABASE+105	; 0BEFh
   998                                  RESTDIR	  equ	RETRABASE+107	; 0BF1h
   999                                  PERMCOM	  equ	RETRABASE+108	; 0BF2h
  1000                                  SINGLECOM equ	RETRABASE+109	; 0BF3h
  1001                                  VERVAL	  equ	RETRABASE+111	; 0BF5h
  1002                                  IFFLAG	  equ	RETRABASE+114	; 0BF8h	
  1003                                  FORFLAG	  equ	RETRABASE+115	; 0BF9h
  1004                                  FORPTR	  equ	RETRABASE+116	; 0BFAh 	
  1005                                  NEST	  equ	RETRABASE+118	; 0BFCh
  1006                                  CALL_FLAG equ	RETRABASE+120	; 0BFEh
  1007                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFFh
  1008                                  NEXT_BATCH equ	RETRABASE+122 	; 0C00h
  1009                                  NULLFLAG  equ	RETRABASE+124	; 0C02h
  1010                                  UPPERCASETBL equ RETRABASE+126	; 0C04h
  1011                                  RE_OUT_APP equ	RETRABASE+130	; 0C08h
  1012                                  RE_OUTSTR equ	RETRABASE+131	; 0C09h
  1013                                  INITFLAG  equ	RETRABASE+211	; 0C59h	
  1014                                  PIPEFLAG  equ	RETRABASE+212	; 0C5Ah
  1015                                  PIPEFILES equ	RETRABASE+213	; 0C5Bh
  1016                                  PIPE1	  equ	RETRABASE+214	; 0C5Ch	
  1017                                  PIPE2	  equ	RETRABASE+230	; 0C6Ch
  1018                                  PIPEPTR	  equ	RETRABASE+246	; 0C7Ch
  1019                                  PIPESTR	  equ	RETRABASE+248	; 0C7Eh
  1020                                  INPIPEPTR equ	RETRABASE+377	; 0CFFh
  1021                                  OUTPIPEPTR equ	RETRABASE+379	; 0D01h
  1022                                  ENVIRSEG  equ	RETRABASE+381	; 0D03h
  1023                                  EXEC_BLOCK equ	RETRABASE+381 	; 0D03h  ; ENVIRSEG
  1024                                  LTPA	  equ	RETRABASE+399	; 0D15h
  1025                                  RES_TPA	  equ	RETRABASE+413	; 0D23h
  1026                                  
  1027                                  ;=============================================================================
  1028                                  					
  1029                                  ; (command3.s -> offset TRANGOUP)
  1030                                  
  1031                                  TRANGROUP:
  1032                                  
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; START OF TRANSIENT PORTION
  1035                                  ; ----------------------------------------------------------------------------
  1036                                  ; SEGMENT - TRANSCODE
  1037                                  ; ----------------------------------------------------------------------------
  1038                                  ; 13/10/2018 - Retro DOS v3.0
  1039                                  
  1040                                  ;[BITS 16]
  1041                                  ;[ORG 0]
  1042 00000000 00<rep 100h>            		times 256 db 0
  1043                                  
  1044                                  ;============================================================================
  1045                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1046                                  ;============================================================================
  1047                                  ; 12/10/2018 - Retro DOS v3.0
  1048                                  
  1049                                  ;[ORG 100h]
  1050                                  
  1051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1052                                  
  1053                                  ; ---------------------------------------------------------------------------
  1054                                  
  1055                                  SETDRV:					; Allow for 100H parameter area
  1056 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1057 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1058                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1059                                  				; Return: AL = number of logical drives
  1060                                  
  1061                                  ; ---------------------------------------------------------------------------
  1062                                  
  1063                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1064                                  ; No registers (CS:IP) no flags, nothing.
  1065                                  
  1066                                  TCOMMAND:
  1067 00000104 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  1068 00000109 B8FFFF                  		mov	ax,-1
  1069 0000010C 8706F70B                		xchg	ax,word [VERVAL]
  1070 00000110 83F8FF                  		cmp	ax,-1
  1071 00000113 7404                    		jz	short NOSETVER2
  1072 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1073 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1074                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1075                                  NOSETVER2:
  1076 00000119 2EFF1E[6F42]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1077 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1078 00000120 833EF50BFF              		cmp	word [SINGLECOM],-1
  1079 00000125 7505                    		jnz	short COMMAND
  1080                                  _$EXITPREP:
  1081 00000127 0E                      		push	cs
  1082 00000128 1F                      		pop	ds
  1083 00000129 E92415                  		jmp	_$EXIT		; Have finished the single command
  1084                                  
  1085                                  ; ---------------------------------------------------------------------------
  1086                                  ;
  1087                                  ; Main entry point from resident portion.
  1088                                  ;
  1089                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1090                                  ;   just beginning the processing of another command.
  1091                                  ;
  1092                                  ; ---------------------------------------------------------------------------
  1093                                  
  1094                                  ; We are not always sure of the state of the world at this time. We presume
  1095                                  ; worst case and initialize the relevant registers: segments and stack.
  1096                                  
  1097                                  COMMAND:
  1098 0000012C FC                      		cld
  1099 0000012D 8CC8                    		mov	ax,cs
  1100 0000012F FA                      		cli
  1101 00000130 8ED0                    		mov	ss,ax
  1102                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1103 00000132 BC[F84C]                		mov	sp,STACK
  1104 00000135 FB                      		sti
  1105                                  		
  1106 00000136 8EC0                    		MOV	ES,AX
  1107                                  		
  1108                                  		; MSDOS 6.0
  1109                                  		;MOV	DS,AX		;AN000; set DS to transient
  1110                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1111                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1112                                  		;mov	append_exec,0	;AN041; set internal append state off
  1113                                  
  1114                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1115 00000138 368E1E[7142]            		mov	ds,[ss:RESSEG]
  1116 0000013D 36C606[4D40]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1117 00000143 36C606[D040]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1118                                  
  1119                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1120                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1121                                  ; I guess not:  the only circumstances in which we reload the command processor
  1122                                  ; is after a transient program execution. In this case, we let the current
  1123                                  ; directory lie where it may.
  1124                                  
  1125 00000149 09ED                    		or	bp,bp		; See if just read
  1126 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1127 0000014D 36C706[4E40]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1128 00000154 EB17                    		jmp	short NOSETBUF
  1129                                  TESTRDIR:
  1130 00000156 803EF30B00              		cmp	byte [RESTDIR],0
  1131 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1132 0000015D 1E                      		push	ds
  1133                                  
  1134                                  ; We have an unusual situation to handle. The user *may* have changed his
  1135                                  ; directory as a result of an internal command that got aborted. Restoring it
  1136                                  ; twice may not help us: the problem may never go away. We just attempt it
  1137                                  ; once and give up.
  1138                                  
  1139 0000015E C606F30B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1140                                  
  1141                                  		; Restore users directory
  1142 00000163 0E                      		push	cs
  1143 00000164 1F                      		pop	ds
  1144 00000165 BA[5341]                		mov	dx,USERDIR1
  1145 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1146 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1147                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1148 0000016C 1F                      		pop	ds
  1149                                  NOSETBUF:
  1150 0000016D 803E5D0C00              		cmp	byte [PIPEFILES],0
  1151 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1152 00000174 803E5C0C00              		cmp	byte [PIPEFLAG],0
  1153 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1154 0000017B E8981D                  		call	PIPEDEL
  1155                                  NOPCLOSE:
  1156                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1157 0000017E C606EB0B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1158 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1159 00000185 8ED8                    		mov	ds,ax
  1160 00000187 50                      		push	ax
  1161 00000188 BA[F84C]                		mov	dx,INTERNATVARS
  1162 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1163 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1164                                  				; get current-country info
  1165                                  				; DS:DX	-> buffer for returned info
  1166 00000190 58                      		pop	ax
  1167 00000191 2B06[7342]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1168 00000195 53                      		push	bx
  1169 00000196 BB1000                  		mov	bx,16
  1170 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1171 0000019B 5B                      		pop	bx
  1172 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1173 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1174 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1175                                  SAVSIZ:
  1176                                  
  1177                                  ; AX is the number of bytes free in the buffer between the resident and the
  1178                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1179                                  
  1180 000001A3 3D0002                  		cmp	ax,512
  1181 000001A6 7603                    		jbe	short GOTSIZE
  1182                                  		;and	ax,~1FFh
  1183 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1184                                  GOTSIZE:
  1185 000001AB A3[9242]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1186 000001AE 8E1E[7142]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1187                                  
  1188 000001B2 F606EF0B01              		test	byte [ECHOFLAG],1 
  1189 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1190 000001B9 E8391D                  		call	SINGLETEST
  1191 000001BC 7219                    		jb	short GETCOM
  1192 000001BE F6065C0CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1193 000001C3 7512                    		jnz	short GETCOM
  1194                                  					; G  Don't print prompt in FOR
  1195 000001C5 F606FB0BFF              		test	byte [FORFLAG],0FFh ; -1
  1196 000001CA 750B                    		jnz	short GETCOM
  1197                                  					; G  Don't print prompt if in batch
  1198 000001CC F706990BFFFF            		test	word [BATCH],0FFFFh ; -1
  1199 000001D2 7503                    		jnz	short GETCOM
  1200 000001D4 E89517                  		call	CRLF2
  1201                                  GETCOM:
  1202 000001D7 C606000C00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1203 000001DC C606010C00              		mov	byte [CALL_BATCH_FLAG],0
  1204 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1205 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1206 000001E5 36A2[8542]              		mov	[ss:CURDRV],al
  1207 000001E9 F6065C0CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1208 000001EE 7403                    		jz	short NOPIPE
  1209 000001F0 E9C51D                  		jmp	PIPEPROC	; Continue the pipeline
  1210                                  NOPIPE:
  1211 000001F3 F606EF0B01              		test	byte [ECHOFLAG],1
  1212 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1213 000001FA E8F81C                  		call	SINGLETEST
  1214 000001FD 7212                    		jb	short NOPDRV
  1215 000001FF F606FB0BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1216 00000204 750B                    		jnz	short NOPDRV
  1217 00000206 F706990BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1218 0000020C 750D                    		jnz	short TESTFORBAT
  1219 0000020E E87911                  		call	PRINT_PROMPT	; Prompt the user
  1220                                  NOPDRV:
  1221 00000211 F606FB0BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1222 00000216 7403                    		jz	short TESTFORBAT
  1223 00000218 E9FE09                  		jmp	FORPROC		; Continue the FOR
  1224                                  
  1225                                  TESTFORBAT:
  1226 0000021B 36C606[1C42]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1227 00000221 C6060B0C00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1228 00000226 C6060A0C00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1229 0000022B C606FA0B00              		mov	byte [IFFLAG],0	; no more ifs...
  1230 00000230 F706990BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1231 00000236 7429                    		jz	short ISNOBAT
  1232                                  
  1233                                  		; MSDOS 6.0
  1234                                  
  1235                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1236                                  
  1237                                  		;push	es			;AN000; save ES
  1238                                  		;push	ds			;AN000; save DS
  1239                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1240                                  		;mov	es,[batch]		;AN000; get batch segment
  1241                                  		;mov	di,batfile		;AN000; get batch file name
  1242                                  		;push	cs			;AN000; get local segment to DS
  1243                                  		;pop	ds			;AN000;
  1244                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1245                                  		;int	2fh			;AN000; call the shell
  1246                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1247                                  		;pop	ds			;AN000; restore DS
  1248                                  		;pop	es			;AN000; restore ES
  1249                                  		;jz	jdocom1 		;AN000; yes - go process command
  1250                                  
  1251                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1252 00000238 1E                      		push	ds
  1253 00000239 E8BC02                  		call	READBAT			; Continue BATCH
  1254 0000023C 1F                      		pop	ds
  1255 0000023D C606040C00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1256 00000242 F706990BFFFF            		test	word [BATCH],0FFFFh
  1257 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1258 0000024A 8B1E020C                		mov	bx,word [NEXT_BATCH]
  1259 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1260 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1261 00000253 891E990B                		mov	word [BATCH],bx		;G get segment of next batch file
  1262 00000257 C706020C0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1263                                  JDOCOM1:
  1264 0000025D 0E                      		push	cs
  1265 0000025E 1F                      		pop	ds
  1266 0000025F EB4C                    		jmp	short DOCOM1
  1267                                  
  1268 00000261 833EF50B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1269 00000266 741C                    		jz	short REGCOM
  1270                                  		;MOV	SI,[SEMIPERMCOM] ;  MSDOS 6.0
  1271 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1272 0000026B 8736F50B                		xchg	si,word [SINGLECOM]
  1273 0000026F BF[D240]                		mov	di,COMBUF+2
  1274 00000272 31C9                    		xor	cx,cx
  1275                                  SINGLELOOP:
  1276 00000274 AC                      		lodsb
  1277 00000275 AA                      		stosb
  1278 00000276 41                      		inc	cx
  1279 00000277 3C0D                    		cmp	al,0Dh
  1280 00000279 75F9                    		jnz	short SINGLELOOP
  1281 0000027B 49                      		dec	cx
  1282 0000027C 0E                      		push	cs
  1283 0000027D 1F                      		pop	ds
  1284 0000027E 880E[D140]              		mov	[COMBUF+1],cl
  1285                                  
  1286                                  ; do NOT issue a trailing CRLF...
  1287                                  
  1288 00000282 EB29                    		jmp	short DOCOM1
  1289                                  
  1290                                  		;nop
  1291                                  
  1292                                  ; We have a normal command.  
  1293                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1294                                  ; sometimes they aren't. At this point, we automatically close all spool
  1295                                  ; files and turn on truncation mode.
  1296                                  
  1297                                  REGCOM:
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1299                                  		;mov	ax,5D09h
  1300 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1301 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1302                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1303                                  		;mov	ax,5D08h
  1304 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1305 0000028C B201                    		mov	dl,1
  1306 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1307                                  				; DL = 00h redirected output is	combined
  1308                                  				;      01h redirected output placed in separate	jobs
  1309                                  				; start	new print job now
  1310 00000290 0E                      		push	cs
  1311 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1312 00000292 BA[4D40]                		mov	dx,UCOMBUF
  1313                                  
  1314                                  		; MSDOS 6.0
  1315                                  ;	Try to read interactive command line via DOSKey.
  1316                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1317                                  
  1318                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1319                                  		;int	2fh
  1320                                  		;or	ax,ax
  1321                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1322                                  
  1323                                  		;mov	ah,0Ah
  1324 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1325 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1326                                  				; DS:DX	-> buffer
  1327                                  ;GOTCOM:
  1328 00000299 8A0E[4D40]              		mov	cl,[UCOMBUF]
  1329 0000029D 30ED                    		xor	ch,ch
  1330 0000029F 83C103                  		add	cx,3
  1331 000002A2 BE[4D40]                		mov	si,UCOMBUF
  1332 000002A5 BF[D040]                		mov	di,COMBUF
  1333 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1334                                  DOCOM:
  1335 000002AA E8BF16                  		call	CRLF2
  1336                                  DOCOM1:
  1337 000002AD E87F19                  		call	PRESCAN		; Cook the input buffer
  1338 000002B0 7406                    		jz	short NOPIPEPROC
  1339 000002B2 E9AB1C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1340                                  
  1341                                  NULLCOMJ:
  1342 000002B5 E9FA00                  		jmp	NULLCOM
  1343                                  
  1344                                  NOPIPEPROC:
  1345 000002B8 E8F520                  		call	PARSELINE
  1346 000002BB 730B                    		jnb	short OKPARSE	; user error?  or maybe we goofed?
  1347                                  BADPARSE:
  1348 000002BD 0E                      		push	cs
  1349 000002BE 1F                      		pop	ds
  1350 000002BF BA[BB37]                		mov	dx,BADNAMPTR
  1351 000002C2 E80532                  		call	STD_EPRINTF
  1352 000002C5 E93CFE                  		jmp	TCOMMAND
  1353                                  
  1354                                  OKPARSE:
  1355                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1356 000002C8 F606[AB45]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1357 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1358                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1359 000002CF 833E[6948]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1360 000002D4 74DF                    		jz	short NULLCOMJ
  1361                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1362 000002D6 833E[AE45]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1363 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1364                                  
  1365 000002DD BE[D240]                		mov	si,COMBUF+2
  1366 000002E0 BF[EB42]                		mov	di,IDLEN
  1367                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1368                                  					; Make FCB with blank scan-off
  1369 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1370                                  		;mov	ax,2901h
  1371 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1372                                  				; DS:SI	-> string to parse
  1373                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1374                                  				; AL = bit mask	to control parsing
  1375                                  		;mov	bx,[ARG_ARGV]
  1376 000002E8 8B1E[A945]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1377 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1378 000002F0 751C                    		jne	short DRVGD	; no, use default of zero...
  1379 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1380                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1381                                  		;and	dl,~20h
  1382 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1383 000002F7 2A16[F03E]              		sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1384 000002FB 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1385 000002FD 740C                    		jz	short DRVBADJ	; It was invalid.
  1386                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1387 000002FF 8B3E[AC45]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1388 00000303 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1389 00000306 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1390 00000308 E9F5FD                  		jmp	SETDRV		; and set drive to new drive spec
  1391                                  DRVBADJ:
  1392 0000030B E9CA17                  		jmp	DRVBAD
  1393                                  DRVGD:
  1394 0000030E 8A05                    		mov	al,[di]
  1395 00000310 A2[9142]                		mov	[SPECDRV],al
  1396 00000313 B020                    		mov	al,' '
  1397 00000315 B90900                  		mov	cx,9
  1398 00000318 47                      		inc	di
  1399 00000319 F2AE                    		repne scasb		; Count number of letters in command name
  1400 0000031B B008                    		mov	al,8
  1401 0000031D 28C8                    		sub	al,cl
  1402 0000031F A2[EB42]                		mov	[IDLEN],al	; IDLEN is truly the length
  1403 00000322 BF8100                  		mov	di,81h
  1404 00000325 56                      		push	si
  1405 00000326 BE[D240]                		mov	si,COMBUF+2	; Skip over all leading delims
  1406 00000329 E84D16                  		call	SCANOFF
  1407                                  
  1408                                  		; MSDOS 6.0
  1409                                  ;SR;
  1410                                  ; We are going to skip over the first char always. The logic is that the
  1411                                  ;command tail can never start from the first character. The code below is 
  1412                                  ;trying to figure out the command tail and copy it to the command line 
  1413                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1414                                  ;character and the user given command line is a full 128 bytes, we try to
  1415                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1416                                  ;char overwrites the code and leads to a crash on future commands.
  1417                                  ;
  1418                                  		;inc	si ;  MSDOS 6.0
  1419                                  DO_SKIPCOM:
  1420 0000032C AC                      		lodsb			; move command line pointer over
  1421 0000032D E85116                  		call	DELIM		; pathname -- have to do it ourselves
  1422 00000330 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1423 00000332 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1424 00000334 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1425 00000336 3A06[7542]              		cmp	al,[SWITCHAR]	; specified command string
  1426 0000033A 75F0                    		jnz	short DO_SKIPCOM 
  1427                                  DO_SKIPPED:
  1428 0000033C 4E                      		dec	si
  1429 0000033D 31C9                    		xor	cx,cx
  1430                                  COMTAIL:
  1431 0000033F AC                      		lodsb
  1432 00000340 AA                      		stosb			; Move command tail to 80h
  1433 00000341 3C0D                    		cmp	al,0Dh
  1434 00000343 E0FA                    		loopne	COMTAIL
  1435 00000345 4F                      		dec	di
  1436 00000346 89FD                    		mov	bp,di
  1437 00000348 F6D1                    		not	cl
  1438 0000034A 880E8000                		mov	[80h],cl
  1439 0000034E 5E                      		pop	si
  1440                                  ;-----
  1441                                  ; Some of these comments are sadly at odds with this brave new code.
  1442                                  ;-----
  1443                                  ; If the command has 0 parameters must check here for
  1444                                  ; any switches that might be present.
  1445                                  ; SI -> first character after the command.
  1446                                  
  1447                                  		;mov	di, arg.argv[0].argsw_word
  1448                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1449 0000034F 8B3E[B045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1450 00000353 893E[8842]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1451                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1452                                  					; s = argv[1];
  1453                                  		;mov	si,[ARGV1_ARGPOINTER]
  1454 00000357 8B36[B445]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1455 0000035B 09F6                    		or	si,si		;   if (s == NULL)
  1456 0000035D 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1457 0000035F 89EE                    		mov	si,bp
  1458                                  DOPARSE:
  1459 00000361 BF5C00                  		mov	di,FCB ; 5Ch
  1460                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1461                                  		;mov	ax,2901h
  1462 00000364 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1463 00000367 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1464                                  				; DS:SI	-> string to parse
  1465                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1466                                  				; AL = bit mask	to control parsing
  1467 00000369 A2[8642]                		mov	[PARM1],al	; Save result of parse
  1468                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1469                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1470 0000036C 8B3E[BB45]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1471 00000370 893E[8A42]              		mov	[ARG1S],di
  1472                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1473                                  					; s = argv[2];
  1474                                  		;mov	si,[ARGV2_ARGPOINTER]
  1475 00000374 8B36[BF45]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1476 00000378 09F6                    		or	si,si		;   if (s == NULL)
  1477 0000037A 7502                    		jnz	short DOPARSE2
  1478 0000037C 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1479                                  DOPARSE2:			
  1480 0000037E BF6C00                  		mov	di,FCB+10H ; 6Ch
  1481                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1482                                  		;mov	ax,2901h
  1483 00000381 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1484 00000384 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1485                                  				; DS:SI	-> string to parse
  1486                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1487                                  				; AL = bit mask	to control parsing
  1488 00000386 A2[8742]                		mov	[PARM2],al	; Save result
  1489                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1490                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1491 00000389 8B3E[C645]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1492 0000038D 893E[8C42]              		mov	[ARG2S],di
  1493                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1494                                  		;mov	di,arg.argv[0].argsw_word
  1495 00000391 8B3E[B045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1496 00000395 F7D7                    		not	di		; ARGTS doesn't include the flags
  1497                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1498                                  		;and	di,arg.argswinfo	
  1499 00000397 233E[6B48]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1500 0000039B 893E[8E42]              		mov	[ARGTS],di
  1501                                  
  1502 0000039F A0[EB42]                		mov	al,[IDLEN]
  1503 000003A2 8A16[9142]              		mov	dl,[SPECDRV]
  1504 000003A6 08D2                    		or	dl,dl		; if a drive was specified...
  1505 000003A8 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1506 000003AA FEC8                    		dec	al		; (I don't know why -- old code did it)
  1507 000003AC E93217                  		jmp	FNDCOM		; otherwise, check internal com table
  1508                                  EXTERNALJ1:
  1509 000003AF E9E017                  		jmp	EXTERNAL
  1510                                  NULLCOM:
  1511 000003B2 8E1E[7142]              		mov	ds,[RESSEG]
  1512 000003B6 F706990BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1513 000003BC 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1514                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1515 000003BE C606040C01              		mov	byte [NULLFLAG],nullcommand ; 1
  1516                                  NOSETFLAG:
  1517 000003C3 833EF50BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1518 000003C8 7403                    		jz	short EXITJ
  1519 000003CA E90AFE                  		jmp	GETCOM
  1520                                  EXITJ:
  1521 000003CD E957FD                  		jmp	_$EXITPREP
  1522                                  
  1523                                  ;============================================================================
  1524                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1525                                  ;============================================================================
  1526                                  ; 12/10/2018 - Retro DOS v3.0
  1527                                  
  1528                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1529                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1530                                  ;   there is a header that describes a block of rom program.  This header
  1531                                  ;   contains information needed to initialize a module and to provide PCDOS
  1532                                  ;   with a set of reserved names for execution.
  1533                                  ;
  1534                                  ;   This header has the following format:
  1535                                  ;
  1536                                  ;   rom_header	STRUC
  1537                                  ;	Signature1  DB	55h
  1538                                  ;	Signature2  DB	AAh
  1539                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1540                                  ;	init_jmp    DB	3 dup (?)
  1541                                  ;	name_list   name_struc <>
  1542                                  ;   rom_header	ENDS
  1543                                  ;
  1544                                  ;   name_struc	STRUC
  1545                                  ;	name_len    DB	?
  1546                                  ;	name_text   DB	? DUP (?)
  1547                                  ;	name_jmp    DB	3 DUP (?)
  1548                                  ;   name_struc	ENDS
  1549                                  ;
  1550                                  ;   The name list is a list of names that are reserved by a particular section
  1551                                  ;   of a module.  This list of names is terminated by a null name (length
  1552                                  ;   is zero).
  1553                                  ;
  1554                                  ;   Consider now, the PCDOS action when a user enters a command:
  1555                                  ;
  1556                                  ;	COMMAND.COM has control.
  1557                                  ;	o   If location FFFFEh has FDh then
  1558                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1559                                  ;		    by AAh, stop scan if we get above or = F0000H
  1560                                  ;	o	When we've found one, compare the name entered by the user
  1561                                  ;		    with the one found in the rom.  If we have a match, then
  1562                                  ;		    set up the environment for execution and do a long jump
  1563                                  ;		    to the near jump after the found name.
  1564                                  ;	o	If no more names in the list, then continue scanning the module
  1565                                  ;		    for more 55h followed by AAh.
  1566                                  ;	o   We get to this point only if there is no matching name in the
  1567                                  ;		rom.  We now look on disk for the command.
  1568                                  ;
  1569                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1570                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1571                                  ;   want to be invisible to the DOS should not have any names in their lists
  1572                                  ;   (i.e. they have a single null name).
  1573                                  ;
  1574                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1575                                  ;   Clearly this version will be available on disk.  How does a user actually
  1576                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1577                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1578                                  ;   solution:
  1579                                  ;
  1580                                  ;   o	Keep things consistent and force the user to have his software named
  1581                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1582                                  
  1583                                  struc ROM_HEADER
  1584 00000000 ??                          .signature1: resb 1
  1585 00000001 ??                          .signature2: resb 1
  1586 00000002 ??                          .rom_length: resb 1
  1587 00000003 ??????                      .init_jmp:	 resb 3
  1588 00000006 ??                          .name_list:	 resb 1
  1589                                      .size:
  1590                                  endstruc
  1591                                  
  1592                                  struc NAME_STRUC
  1593 00000000 ??                          .name_len:	resb 1
  1594 00000001 ??                          .name_text:	resb 1
  1595 00000002 ??????                      .name_jmp:	resb 3
  1596                                      .size:	
  1597                                  endstruc
  1598                                  
  1599                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1600                                  
  1601                                  ; =============== S U B	R O U T	I N E =======================================
  1602                                  
  1603                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1604                                  
  1605                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1606                                  
  1607                                  ROM_SCAN:
  1608 000003D0 06                      		push	es
  1609 000003D1 56                      		push	si
  1610 000003D2 57                      		push	di
  1611 000003D3 51                      		push	cx
  1612 000003D4 50                      		push	ax
  1613 000003D5 53                      		push	bx
  1614                                  
  1615                                  		; check for PC Jr signature in rom
  1616                                  
  1617 000003D6 B800F0                  		mov	ax,0F000h
  1618 000003D9 8EC0                    		mov	es,ax
  1619 000003DB 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1620 000003E1 7408                    		je	short SCAN_IT
  1621                                  NO_ROM:
  1622 000003E3 F8                      		clc
  1623                                  ROM_RET:
  1624 000003E4 5B                      		pop	bx
  1625 000003E5 58                      		pop	ax
  1626 000003E6 59                      		pop	cx
  1627 000003E7 5F                      		pop	di
  1628 000003E8 5E                      		pop	si
  1629 000003E9 07                      		pop	es
  1630 000003EA C3                      		retn
  1631                                  
  1632                                  SCAN_IT:	; start scanning at C000h
  1633                                  
  1634 000003EB B800C0                  		mov	ax,0C000h
  1635                                  SCAN_ONE:
  1636 000003EE 8EC0                    		mov	es,ax
  1637 000003F0 31FF                    		xor	di,di
  1638                                  
  1639                                  SCAN_MODULE:	; check for a valid header
  1640                                  
  1641 000003F2 26813D55AA              		cmp	word [es:di],0AA55h
  1642 000003F7 740A                    		jz	short SCAN_LIST
  1643 000003F9 058000                  		add	ax,80h
  1644                                  SCAN_END:
  1645 000003FC 3D00F0                  		cmp	ax,0F000h
  1646 000003FF 72ED                    		jb	short SCAN_ONE
  1647 00000401 EBE0                    		jmp	short NO_ROM
  1648                                  
  1649                                  		; trundle down list of names
  1650                                  SCAN_LIST:
  1651                                  		;mov	bl,[es:di+2]
  1652                                  					; number of 512-byte jobbers
  1653 00000403 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1654 00000407 30FF                    		xor	bh,bh		; nothing in the high byte
  1655 00000409 D1E3                    		shl	bx,1
  1656 0000040B D1E3                    		shl	bx,1		; number of paragraphs
  1657 0000040D 83C37F                  		add	bx,7Fh
  1658 00000410 83E380                  		and	bx,0FF80h	; round to 2k	
  1659                                  		;mov	di,6
  1660 00000413 BF0200                  		mov	di,ROM_HEADER.rom_length
  1661                                  
  1662                                  		;nop
  1663                                  SCAN_NAME:
  1664 00000416 268A0D                  		mov	cl,[es:di]	; length of name
  1665 00000419 47                      		inc	di		; point to name
  1666 0000041A 30ED                    		xor	ch,ch
  1667 0000041C 09C9                    		or	cx,cx		; zero length name
  1668 0000041E 7504                    		jnz	short SCAN_TEST	; nope... compare
  1669 00000420 01D8                    		add	ax,bx		; yep, skip to next block
  1670 00000422 EBD8                    		jmp	short SCAN_END
  1671                                  
  1672                                  SCAN_TEST:	; compare a single name
  1673                                  
  1674 00000424 89D6                    		mov	si,dx
  1675 00000426 46                      		inc	si
  1676 00000427 F3A6                    		repe cmpsb		 ; compare name
  1677 00000429 7407                    		jz	short SCAN_FOUND ; success!
  1678                                  SCAN_NEXT:
  1679 0000042B 01CF                    		add	di,cx		; failure, next name piece
  1680 0000042D 83C703                  		add	di,3
  1681 00000430 EBE4                    		jmp	short SCAN_NAME
  1682                                  
  1683                                  SCAN_FOUND:	; found a name. save entry location
  1684                                  
  1685 00000432 803C3F                  		cmp	byte [si],'?'
  1686 00000435 7405                    		jz	short SCAN_SAVE
  1687 00000437 803C20                  		cmp	byte [si],' '
  1688 0000043A 75EF                    		jnz	short SCAN_NEXT
  1689                                  SCAN_SAVE:
  1690 0000043C 2E8C06[6A44]            		mov	[cs:ROM_CS],es
  1691 00000441 2E893E[6844]            		mov	[cs:ROM_IP],di
  1692 00000446 F9                      		stc
  1693 00000447 EB9B                    		jmp	short ROM_RET
  1694                                  
  1695                                  ; ---------------------------------------------------------------------------
  1696                                  
  1697                                  ; execute a rom-placed body of code. allocate largest block
  1698                                  
  1699                                  ROM_EXEC:
  1700 00000449 BBFFFF                  		mov	bx,0FFFFh
  1701 0000044C B448                    		mov	ah,ALLOC ; 48h
  1702 0000044E CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1703                                  				; BX = number of 16-byte paragraphs desired
  1704 00000450 B448                    		mov	ah,ALLOC ; 48h
  1705 00000452 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1706                                  				; BX = number of 16-byte paragraphs desired
  1707 00000454 53                      		push	bx
  1708 00000455 50                      		push	ax
  1709                                  
  1710                                  		; set terminate addresses
  1711                                  
  1712                                  		;mov	ax,2522h
  1713                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1714 00000456 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1715 00000459 1E                      		push	ds
  1716 0000045A 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  1717                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1718                                  		;mov	dx,131h ; MSDOS 3.3
  1719 0000045F BA3101                  		mov	dx,EXEC_WAIT
  1720 00000462 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1721                                  				; AL = interrupt number
  1722                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1723 00000464 8CDA                    		mov	dx,ds
  1724 00000466 8EC2                    		mov	es,dx
  1725 00000468 1F                      		pop	ds
  1726                                  		
  1727                                  		; and create program header and dup all jfn's
  1728                                  
  1729 00000469 5A                      		pop	dx
  1730 0000046A B455                    		mov	ah,DUP_PDB ; 55h
  1731 0000046C CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1732                                  				; DX = segment number at which to set up PSP
  1733                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1734                                  		
  1735                                  		; set up dma address
  1736                                  
  1737 0000046E 8EDA                    		mov	ds,dx
  1738 00000470 BA8000                  		mov	dx,80h
  1739 00000473 B41A                    		mov	ah,SET_DMA ; 1Ah
  1740 00000475 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1741                                  				; DS:DX	-> disk	transfer buffer
  1742                                  
  1743                                  		; copy in environment info
  1744                                  
  1745 00000477 26A1050D                		mov	ax,word [es:ENVIRSEG]
  1746 0000047B A32C00                  		mov	[PDB.ENVIRON],	ax
  1747                                  
  1748                                  		; set up correct size of block
  1749                                  
  1750 0000047E 5B                      		pop	bx		; BX has size, DS has segment
  1751 0000047F 8CDA                    		mov	dx,ds
  1752 00000481 01DA                    		add	dx,bx
  1753                                  		;mov	[2],dx
  1754 00000483 89160200                		mov	word [PDB.BLOCK_LEN],dx
  1755                                  
  1756                                  		; change ownership of block
  1757                                  
  1758 00000487 8CDA                    		mov	dx,ds
  1759 00000489 4A                      		dec	dx
  1760 0000048A 8EDA                    		mov	ds,dx
  1761 0000048C 42                      		inc	dx	
  1762                                  		;mov	[1],dx
  1763 0000048D 89160100                		mov	word [ARENA.owner],dx
  1764 00000491 8EDA                    		mov	ds,dx
  1765                                  
  1766                                  		; set up correct stack
  1767                                  
  1768 00000493 81FB0010                		cmp	bx,1000h
  1769 00000497 7202                    		jb	short GOT_STACK
  1770 00000499 31DB                    		xor	bx,bx
  1771                                  GOT_STACK:
  1772 0000049B B104                    		mov	cl,4
  1773 0000049D D3E3                    		shl	bx,cl
  1774 0000049F 8CDA                    		mov	dx,ds
  1775 000004A1 8ED2                    		mov	ss,dx
  1776 000004A3 89DC                    		mov	sp,bx
  1777 000004A5 31C0                    		xor	ax,ax
  1778 000004A7 50                      		push	ax
  1779                                  
  1780                                  		; set up initial registers and go to the guy
  1781                                  
  1782 000004A8 F7D0                    		not	ax
  1783 000004AA 2EFF36[6A44]            		push	word [cs:ROM_CS]
  1784 000004AF 2EFF36[6844]            		push	word [cs:ROM_IP]
  1785 000004B4 8EC2                    		mov	es,dx
  1786 000004B6 CB                      		retf	; far return
  1787                                  
  1788                                  ;============================================================================
  1789                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1790                                  ;============================================================================
  1791                                  ; 12/10/2018 - Retro DOS v3.0
  1792                                  
  1793                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1794                                  
  1795                                  ; =============== S U B	R O U T	I N E =======================================
  1796                                  
  1797                                  ;Break	<PromptBat - Open or wait for batch file>
  1798                                  
  1799                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1800                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1801                                  ; file. Leave segment registers alone.
  1802                                  
  1803                                  PROMPTBAT:
  1804 000004B7 E8EF06                  		call	BATOPEN
  1805 000004BA 7201                    		jc	short PROMPTBAT1
  1806 000004BC C3                      		retn
  1807                                  PROMPTBAT1:
  1808                                  		; MSDOS 6.0 COMMAND.COM
  1809                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1810                                  		;jz	Bat_Remcheck		;AN022;
  1811                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1812                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1813                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1814                                  		;jmp	short BatDie		;AN022;
  1815                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1816                                  		;call	[RCH_ADDR]		; DX has error number
  1817                                  		;jz	AskForBat		; Media is removable
  1818                                  
  1819                                  		; MSDOS 3.3 COMMAND.COM
  1820 000004BD 81FA[1D38]              		cmp	dx,ACCDENPTR
  1821 000004C1 7413                    		jz	short BATDIE
  1822                                  
  1823                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1824                                  BAT_REMCHECK:				; Go see if media is removable
  1825 000004C3 2EFF1E[7B42]            		call	far [cs:RCH_ADDR] ; DX has error number
  1826 000004C8 7417                    		jz	short ASKFORBAT	; Media is removable
  1827                                  
  1828                                  ; The media is not changeable. Turn everything off.
  1829                                  
  1830 000004CA E8CE09                  		call	FOROFF
  1831 000004CD E8BC1E                  		call	PIPEOFF
  1832 000004D0 A2FA0B                  		mov	byte [IFFLAG],al ; No If in progress.	
  1833 000004D3 BA[5E37]                		mov	dx,BADPATHPTR
  1834                                  BATDIE:
  1835 000004D6 E84F03                  		call	BATCHOFF
  1836 000004D9 0E                      		push	cs
  1837 000004DA 1F                      		pop	ds
  1838                                  		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
  1839 000004DB E8F52F                  		call	STD_PRINTF	; MSDOS 3.3
  1840                                  
  1841                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1842                                  
  1843 000004DE E923FC                  		jmp	TCOMMAND
  1844                                  
  1845                                  ; Ask the user to reinsert the batch file
  1846                                  
  1847                                  ASKFORBAT:
  1848 000004E1 1E                      		push	ds
  1849 000004E2 0E                      		push	cs
  1850 000004E3 1F                      		pop	ds
  1851                                  
  1852                                  		; MSDOS 6.0
  1853                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1854                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1855                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1856                                  		;;invoke std_eprintf		;AN000; get second part of message
  1857                                  						;AN000; print it to stderr
  1858                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1859 000004E4 E8E32F                  		call	STD_EPRINTF
  1860 000004E7 E80300                  		call	GETKEYSTROKE
  1861 000004EA 1F                      		pop	ds
  1862 000004EB EBCA                    		jmp	short PROMPTBAT
  1863                                  
  1864                                  
  1865                                  ; MSDOS 6.0
  1866                                  ;****************************************************************
  1867                                  ;*
  1868                                  ;* ROUTINE:	Output_batch_name
  1869                                  ;*
  1870                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1871                                  ;*
  1872                                  ;* INPUT:	DX - extended error number
  1873                                  ;*
  1874                                  ;* OUTPUT:	Ready to call print routine
  1875                                  ;*
  1876                                  ;****************************************************************
  1877                                  ;
  1878                                  ;public	output_batch_name			;AN022;
  1879                                  ;
  1880                                  ;Output_batch_name    proc near			;AN022;
  1881                                  ;
  1882                                  ;		push	ds			;AN022; save resident segment
  1883                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1884                                  ;	assume	DS:nothing			;AN022;
  1885                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1886                                  ;		invoke	dstrlen 		;AN022; get length of string
  1887                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1888                                  ;		rep	movsb			;AN022; move the name
  1889                                  ;
  1890                                  ;		push	cs			;AN022; get local segment
  1891                                  ;		pop	ds			;AN022;
  1892                                  ;	assume	DS:trangroup			;AN022;
  1893                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1894                                  ;		mov	msg_disp_class,ext_msg_class
  1895                                  ;						;AN022; set up extended error msg class
  1896                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1897                                  ;						;AN022; get extended message pointer
  1898                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1899                                  ;						;AN022; point to substitution
  1900                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1901                                  ;		pop	ds			;AN022; restore data segment
  1902                                  ;
  1903                                  ;		ret				;AN022; return
  1904                                  ;
  1905                                  ;Output_batch_name    endp			;AN022;
  1906                                  
  1907                                  
  1908                                  ; =============== S U B	R O U T	I N E =======================================
  1909                                  
  1910                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1911                                  
  1912                                  ; Read the next keystroke. Since there may be several characters in the queue
  1913                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1914                                  ; AFTER waiting.
  1915                                  
  1916                                  GETKEYSTROKE:
  1917                                  		; MSDOS 3.3
  1918                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1919                                  		;mov	ax,0C08h
  1920 000004ED B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1921 000004F0 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1922                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1923                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1924                                  		;mov	ax,0C00h
  1925 000004F2 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1926 000004F5 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1927                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1928 000004F7 C3                      		retn
  1929                                  
  1930                                  		; MSDOS 6.0
  1931                                  		;PUSH	DX				;AN000;  3/3/KK
  1932                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1933                                  		;INT	21h				;AN000;  3/3/KK
  1934                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1935                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1936                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1937                                  		;INT	21h				;AN000;  3/3/KK
  1938                                  		;
  1939                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1940                                  		;INT	21h		; Get character with KB buffer flush
  1941                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1942                                  		;INT	21h
  1943                                  		;
  1944                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1945                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1946                                  		;INT	21h				;AN000;  3/3/KK
  1947                                  		;POP	DX				;AN000;  3/3/KK
  1948                                  		;
  1949                                  		;return
  1950                                  
  1951                                  ; =============== S U B	R O U T	I N E =======================================
  1952                                  
  1953                                  ; Break	<ReadBat - read 1 line from batch file>
  1954                                  
  1955                                  ; ReadBat - read a single line from the batch file. 
  1956                                  ; Perform all substitutions as appropriate.
  1957                                  
  1958                                  READBAT:
  1959                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1960                                  		
  1961                                  		;mov	byte [SUPPRESS],1
  1962                                  					; initialize line suppress status
  1963 000004F8 C606F00B01              		mov	byte [SUPPRESS],YES_ECHO 
  1964 000004FD F606E50BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1965 00000502 7508                    		jnz	short TRYING_TO_ABORT
  1966 00000504 C606E40B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1967                                  
  1968                                  		; MSDOS 6.0
  1969                                  ;
  1970                                  ;M037; Start of changes
  1971                                  ; We check here if we have set the flag indicating that the batchfile is at
  1972                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1973                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1974                                  ;batch file gets closed etc. and then return as if everything is done.
  1975                                  ;
  1976                                  		;push	ds
  1977                                  		;mov	ds,Batch
  1978                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1979                                  		;pop	ds
  1980                                  		;jz	contbat		; no, continue normal processing
  1981                                  		;invoke	GetBatByt	; frees up batchseg
  1982                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1983                                  		;			; as a dummy command
  1984                                  		;invoke CrLf2		; print a CR-LF
  1985                                  		;return			; done batch processing
  1986                                  
  1987                                  ;M037; End of changes
  1988                                  		
  1989                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1990                                  CONTBAT:
  1991 00000509 E8ABFF                  		call	PROMPTBAT
  1992                                  
  1993                                  TRYING_TO_ABORT:
  1994 0000050C BF[D240]                		mov	di,COMBUF+2
  1995                                  
  1996                                  ; Save position and try to scan for first non delimiter.
  1997                                  
  1998                                  TESTNOP:
  1999 0000050F 8CD8                    		mov	ax,ds
  2000 00000511 8E1E990B                		mov	ds,word [BATCH]
  2001 00000515 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  2002 00000519 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  2003 0000051D 8ED8                    		mov	ds,ax
  2004 0000051F E88105                  		call	SKIPDELIM	; skip to first non-delim
  2005                                  
  2006                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2007                                  ; beginning and read the line.
  2008                                  
  2009 00000522 3C3A                    		cmp	al,':'		; is it a label?
  2010 00000524 59                      		pop	cx
  2011 00000525 5A                      		pop	dx		; restore position in bat file
  2012 00000526 7431                    		jz	short NOPLINE	; yes, resync everything.
  2013 00000528 F706990BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2014 0000052E 7438                    		jz	short RDBAT	; no, go read batch file
  2015                                  
  2016                                  		;cmp	al,'@'
  2017 00000530 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2018 00000532 7507                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2019                                  		;mov	byte [SUPPRESS],0
  2020 00000534 C606F00B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2021 00000539 EB2D                    		jmp	short RDBAT	; go read batch file
  2022                                  
  2023                                  		;nop
  2024                                  SET_BAT_POS:
  2025 0000053B 1E                      		push	ds
  2026 0000053C 8E1E990B                		mov	ds,word [BATCH]
  2027 00000540 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2028 00000544 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2029 00000548 1F                      		pop	ds
  2030                                  		;MOV	AX,(LSEEK SHL 8) + 0
  2031 00000549 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2032 0000054C CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2033                                  				; AL = method: offset from beginning of	file
  2034                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2035 0000054E 2EC706[184D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2036 00000555 31C9                    		xor	cx,cx		; Initialize line length to zero
  2037 00000557 EB0F                    		jmp	short RDBAT
  2038                                  
  2039                                  		;nop
  2040                                  
  2041                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2042                                  ; We eat characters until a CR is seen.
  2043                                  
  2044                                  NOPLINE:
  2045 00000559 E8F400                  		call	SKIPTOEOL
  2046 0000055C E82E03                  		call	GETBATBYT	; eat trailing LF
  2047                                  		;test	word [BATCH],0FFFFh
  2048 0000055F F706990BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2049 00000565 75A8                    		jnz	short TESTNOP	; no, go get another line
  2050                                  READBAT_RETN:				; Hit EOF			
  2051 00000567 C3                      		retn
  2052                                  
  2053                                  ; ---------------------------------------------------------------------------
  2054                                  
  2055                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2056                                  ; input, we are to consider two special cases:
  2057                                  ;
  2058                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2059                                  ;   %sym%	This is a symbol from the environment
  2060                                  
  2061                                  RDBAT:
  2062 00000568 E82203                  		call	GETBATBYT
  2063 0000056B 41                      		inc	cx		; Inc the line length
  2064                                  RDBAT1:
  2065 0000056C 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2066 00000570 7344                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2067                                  
  2068                                  ; See if we have a parameter character.
  2069                                  
  2070 00000572 3C25                    		cmp	al,'%'		; Check for parameter
  2071 00000574 744A                    		jz	short NEEDPARM
  2072                                  
  2073                                  ; no parameter character. Store it as usual and see if we are done.
  2074                                  
  2075                                  SAVBATBYT:
  2076 00000576 AA                      		stosb			; End of line found?
  2077 00000577 3C0D                    		cmp	al,0Dh
  2078 00000579 75ED                    		jnz	short RDBAT	; no, go for more
  2079                                  
  2080                                  ; We have read in an entire line. 
  2081                                  ; Decide whether we should echo the command line or not.
  2082                                  
  2083                                  FOUND_EOL:
  2084 0000057B 81EF[D340]              		sub	di,COMBUF+3
  2085 0000057F 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2086 00000581 26A2[D140]              		mov	[es:COMBUF+1],al ; Set length of line
  2087 00000585 E80503                  		call	GETBATBYT	; Eat linefeed
  2088 00000588 E80A06                  		call	BATCLOSE
  2089 0000058B 803EF00B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2090 00000590 7407                    		jz	short RESET
  2091 00000592 F606EF0B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2092 00000597 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2093                                  RESET:
  2094 00000599 0E                      		push	cs
  2095 0000059A 1F                      		pop	ds		; Go back to local segment
  2096 0000059B 74CA                    		jz	short READBAT_RETN ; no echoing here...
  2097                                  TRY_NEXTFLAG:
  2098 0000059D 803E040C01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2099                                  					;G was there a command last time?
  2100 000005A2 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2101 000005A4 E8C513                  		call	CRLF2		;G  Print out prompt
  2102                                  NO_CRLF_PRINT:
  2103 000005A7 E8E00D                  		call	PRINT_PROMPT
  2104 000005AA 0E                      		push	cs		;G change data segment
  2105 000005AB 1F                      		pop	ds
  2106 000005AC BA[D240]                		mov	dx,COMBUF+2	; get command line for echoing
  2107 000005AF E81814                  		call	CRPRINT
  2108 000005B2 E8B713                  		call	CRLF2
  2109 000005B5 C3                      		retn
  2110                                  
  2111                                  ; The line was too long. Eat remainder of input text up until the CR
  2112                                  
  2113                                  TOOLONG:
  2114 000005B6 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2115 000005B8 7403                    		jz	short LTLCONT	; Yes, continue
  2116 000005BA E89300                  		call	SKIPTOEOL	; Eat remainder of line	
  2117                                  LTLCONT:
  2118 000005BD AA                      		stosb			; Terminate the command
  2119 000005BE EBBB                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2120                                  
  2121                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2122                                  
  2123                                  NEEDPARM:
  2124 000005C0 E8CA02                  		call	GETBATBYT	; get next character
  2125 000005C3 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2126 000005C5 74AF                    		jz	short SAVBATBYT	; if so, replace with a single %
  2127 000005C7 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2128 000005C9 74AB                    		jz	short SAVBATBYT	; yes, treat it normally
  2129                                  
  2130                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2131                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2132                                  ; see if the <something> has a terminating % and then look up the contents
  2133                                  ; in the environment.
  2134                                  
  2135                                  PAROK:
  2136 000005CB 2C30                    		sub	al,'0'
  2137 000005CD 7239                    		jb	short NEEDENV	; look for parameter in the environment
  2138 000005CF 3C09                    		cmp	al,9
  2139 000005D1 7735                    		ja	short NEEDENV
  2140                                  
  2141                                  ; We have found %<number>. This is taken from the parameters in the
  2142                                  ; allocated batch area.
  2143                                  
  2144 000005D3 98                      		cbw
  2145 000005D4 89C3                    		mov	bx,ax		; move index into AX
  2146 000005D6 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2147 000005D8 06                      		push	es
  2148 000005D9 8E06990B                		mov	es,word [BATCH]
  2149                                  ;
  2150                                  ; The structure of the batch area is:
  2151                                  ;
  2152                                  ;   BYTE    type of segment
  2153                                  ;   DWORD   offset for next line
  2154                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2155                                  ;   ASCIZ   file name (with . and ..)
  2156                                  ;   BYTES   CR-terminated parameters
  2157                                  ;   BYTE    0 flag to indicate end of parameters
  2158                                  ;
  2159                                  ; Get pointer to BX'th argument
  2160                                  ;
  2161                                  		;mov	si,[es:bx+0Bh]
  2162 000005DD 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2163 000005E1 07                      		pop	es
  2164                                  
  2165                                  ; Is there a parameter here?
  2166                                  
  2167 000005E2 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2168 000005E5 7503                    		jnz	short YES_THERE_IS ; Yes go get it
  2169 000005E7 E97EFF                  		jmp	RDBAT		; Ignore if it doesn't
  2170                                  
  2171                                  ; Copy in the found parameter from batch segment
  2172                                  
  2173                                  YES_THERE_IS:
  2174 000005EA 1E                      		push	ds
  2175 000005EB 8E1E990B                		mov	ds,word [BATCH]
  2176 000005EF 49                      		dec	cx		; Don't count '%' in line length
  2177                                  COPYPARM:
  2178 000005F0 AC                      		lodsb			; From resident segment
  2179 000005F1 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2180 000005F3 740F                    		jz	short ENDPARAM
  2181 000005F5 41                      		inc	cx		; Inc the line length
  2182 000005F6 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2183 000005FA 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2184 000005FC AA                      		stosb
  2185 000005FD EBF1                    		jmp	short COPYPARM
  2186                                  
  2187                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2188                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2189                                  ; believing that we are at EOL. Clobber AL too.
  2190                                  
  2191                                  LINETOOL:
  2192 000005FF 30C0                    		xor	al,al
  2193 00000601 1F                      		pop	ds
  2194 00000602 EBB2                    		jmp	short TOOLONG
  2195                                  
  2196                                  ; We have copied in an entire parameter. Go back for more
  2197                                  
  2198                                  ENDPARAM:
  2199 00000604 1F                      		pop	ds
  2200 00000605 E960FF                  		jmp	RDBAT
  2201                                  
  2202                                  ; We have found % followed by something other than 0-9. We presume that there
  2203                                  ; will be a following % character. In between is an environment variable that
  2204                                  ; we will fetch and replace in the batch line with its value.
  2205                                  
  2206                                  NEEDENV:
  2207                                  		; MSDOS 6.0 COMMAND.COM 
  2208                                  		;dec     cx 		;AN070; Don't count "%"
  2209                                  
  2210                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2211 00000608 1E                      		push	ds
  2212 00000609 57                      		push	di
  2213                                  					; temp spot for name
  2214 0000060A BF[EC42]                		mov	di,ID
  2215 0000060D 0430                    		add	al,'0'		; reconvert character
  2216 0000060F AA                      		stosb			; store it in appropriate place
  2217                                  
  2218                                  ; loop getting characters until the next % is found or until EOL
  2219                                  
  2220                                  GETENV1:
  2221 00000610 E87A02                  		call	GETBATBYT	; get the byte
  2222 00000613 AA                      		stosb			; store it
  2223 00000614 3C0D                    		cmp	al,0Dh		; EOL?
  2224 00000616 7513                    		jnz	short GETENV15	; no, see if it the term char
  2225                                  
  2226                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2227                                  
  2228 00000618 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2229 0000061D BE[EC42]                		mov	si,ID 		; point to buffer
  2230 00000620 5F                      		pop	di		; point to line buffer
  2231 00000621 0E                      		push	cs
  2232 00000622 1F                      		pop	ds
  2233 00000623 E85E02                  		call	STRCPY
  2234                                  		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
  2235 00000626 4F                      		dec	di  		;  MSDOS 3.3 COMMAND.COM	
  2236 00000627 1F                      		pop	ds
  2237 00000628 E94BFF                  		jmp	SAVBATBYT
  2238                                  GETENV15:
  2239 0000062B 3C25                    		cmp	al,'%'		; terminating %?
  2240 0000062D 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2241                                  
  2242                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2243                                  ; This was the source of bug #1.
  2244                                  ;		dec	cx		;AN070; Don't count "%"
  2245                                  
  2246 0000062F B03D                    		mov	al,'='		; terminate  with =
  2247 00000631 268845FF                		mov	[es:di-1],al
  2248                                  
  2249                                  ; ID now either has a =-terminated string which we are to find in the
  2250                                  ; environment or a non =-terminated string which will not be found in the
  2251                                  ; environment.
  2252                                  
  2253                                  GETENV2:
  2254 00000635 BE[EC42]                		mov	si,ID
  2255 00000638 0E                      		push	cs
  2256 00000639 1F                      		pop	ds		; DS:SI points to name
  2257 0000063A 51                      		push	cx
  2258 0000063B E85911                  		call	FIND_NAME_IN_ENVIRONMENT
  2259 0000063E 59                      		pop	cx
  2260 0000063F 06                      		push	es
  2261 00000640 1F                      		pop	ds
  2262 00000641 0E                      		push	cs
  2263 00000642 07                      		pop	es
  2264 00000643 89FE                    		mov	si,di
  2265 00000645 5F                      		pop	di		; get back pointer to command line
  2266                                  
  2267                                  ; If the parameter was not found, there is no need to perform any replacement.
  2268                                  ; We merely pretend that we've copied the parameter.
  2269                                  
  2270 00000646 7204                    		jc	short GETENV6
  2271                                  
  2272                                  ; ES:DI points to command line being built
  2273                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2274                                  
  2275 00000648 E83902                  		call	STRCPY		; (let RdBat handle overflow)
  2276 0000064B 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2277                                  GETENV6:
  2278 0000064C 1F                      		pop	ds
  2279 0000064D E918FF                  		jmp	RDBAT		; go back to batch file
  2280                                  
  2281                                  ; =============== S U B	R O U T	I N E =======================================
  2282                                  
  2283                                  ;   SkipToEOL - read from batch file until end of line
  2284                                  
  2285                                  SKIPTOEOL:
  2286 00000650 F706990BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2287                                  		
  2288                                  		;jnz	short SKIPTOEOL1  	
  2289                                  		;retn			; no batch file in effect
  2290                                  		
  2291 00000656 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2292                                  SKIPTOEOL1:
  2293 00000658 E83202                  		call	GETBATBYT
  2294 0000065B 3C0D                    		cmp	al,0Dh		; eol character?
  2295 0000065D 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2296                                  SKIPTOEOL2:
  2297 0000065F C3                      		retn
  2298                                  
  2299                                  ; =============== S U B	R O U T	I N E =======================================
  2300                                  
  2301                                  ;Break	<Allocate and deallocate the transient portion>
  2302                                  
  2303                                  ; Free Transient. Modify ES,AX,flags
  2304                                  
  2305                                  FREE_TPA:
  2306 00000660 06                      		push	es
  2307 00000661 8E06[7142]              		mov	es,[RESSEG]
  2308 00000665 268E06250D              		mov	es,word [es:RES_TPA]
  2309 0000066A B449                    		mov	ah,DEALLOC ; 49h
  2310 0000066C CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2311                                  				; ES = segment address of area to be freed
  2312 0000066E 07                      		pop	es
  2313 0000066F C3                      		retn
  2314                                  
  2315                                  ; =============== S U B	R O U T	I N E =======================================
  2316                                  
  2317                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2318                                  
  2319                                  ALLOC_TPA:
  2320 00000670 06                      		push	es
  2321 00000671 8E06[7142]              		mov	es,[RESSEG]
  2322 00000675 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2323 00000678 B448                    		mov	ah,ALLOC ; 48h
  2324 0000067A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2325                                  				; BX = number of 16-byte paragraphs desired
  2326 0000067C 53                      		push	bx	  	; Save size of block
  2327 0000067D B448                    		mov	ah,ALLOC ; 48h
  2328 0000067F CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2329                                  				; BX = number of 16-byte paragraphs desired
  2330                                  
  2331                                  ; Attempt to align TPA on 64K boundary
  2332                                  
  2333 00000681 5B                      		pop	bx		; Restore size of block
  2334 00000682 26A3250D                		mov	word [es:RES_TPA],ax ; Save segment to beginning of block
  2335 00000686 A3[8142]                		mov	[TRAN_TPA],ax
  2336                                  
  2337                                  ; Is the segment already aligned on a 64K boundary
  2338                                  
  2339 00000689 89C2                    		mov	dx,ax		; Save segment
  2340 0000068B 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2341 0000068E 7507                    		jnz	short CALC_TPA
  2342 00000690 89D0                    		mov	ax,dx
  2343 00000692 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2344 00000695 7523                    		jnz	short NOROUND
  2345                                  CALC_TPA:
  2346 00000697 89D0                    		mov	ax,dx
  2347 00000699 2500F0                  		and	ax,0F000h
  2348 0000069C 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2349 0000069F 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2350                                  
  2351                                  ; Make sure that new boundary is within allocated range
  2352                                  
  2353 000006A1 268B16250D              		mov	dx,word [es:RES_TPA]
  2354 000006A6 01DA                    		add	dx,bx		; Compute maximum address
  2355 000006A8 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2356 000006AA 720E                    		jb	short NOROUND
  2357                                  
  2358                                  ; Make sure that we won't overwrite the transient
  2359                                  
  2360 000006AC 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2361 000006AE 39C3                    		cmp	bx,ax
  2362 000006B0 7208                    		jb	short NOROUND
  2363                                  
  2364                                  ; The area from the 64K boundary to the beginning of the transient must
  2365                                  ; be at least 64K.
  2366                                  
  2367 000006B2 29C3                    		sub	bx,ax
  2368                                  		;cmp	bx,4096
  2369 000006B4 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2370 000006B8 7304                    		jnb	short ROUNDDONE
  2371                                  NOROUND:
  2372 000006BA 26A1250D                		mov	ax,word [es:RES_TPA]
  2373                                  ROUNDDONE:
  2374 000006BE 26A3170D                		mov	word [es:LTPA],ax ; Re-compute everything
  2375 000006C2 A3[7342]                		mov	[TPA],ax
  2376 000006C5 89C3                    		mov	bx,ax
  2377 000006C7 8CC8                    		mov	ax,cs
  2378 000006C9 29D8                    		sub	ax,bx
  2379 000006CB 53                      		push	bx
  2380 000006CC BB1000                  		mov	bx,16
  2381 000006CF F7E3                    		mul	bx
  2382 000006D1 5B                      		pop	bx
  2383 000006D2 09D2                    		or	dx,dx
  2384 000006D4 7403                    		jz	short SAVSIZ2
  2385 000006D6 B8FFFF                  		mov	ax,-1
  2386                                  SAVSIZ2:
  2387                                  
  2388                                  ; AX is the number of bytes free in the buffer between the resident and the
  2389                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2390                                  
  2391 000006D9 3D0002                  		cmp	ax,512
  2392 000006DC 7603                    		jbe	short GOTSIZE2
  2393                                  		;and	ax,~1FFh
  2394 000006DE 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2395                                  GOTSIZE2:
  2396 000006E1 A3[9242]                		mov	[BYTCNT],ax
  2397 000006E4 07                      		pop	es
  2398 000006E5 C3                      		retn
  2399                                  
  2400                                  ; =============== S U B	R O U T	I N E =======================================
  2401                                  
  2402                                  ;Break	<BatCom - enter a batch file>
  2403                                  
  2404                                  ; The exec search has determined that the user has requested a batch file for
  2405                                  ; execution. We parse the arguments, create the batch segment, and signal
  2406                                  ; batch processing.
  2407                                  
  2408                                  BATCOM:	
  2409                                  
  2410                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2411                                  
  2412                                  ; Batch parameters are read with ES set to segment of resident part
  2413                                  
  2414                                  		; MSDOS 6.0
  2415                                  		;mov	es,[RESSEG]
  2416                                  		;ASSUME	ES:RESGROUP
  2417                                  		;cmp	es:[call_batch_flag],call_in_progress
  2418                                  		;				;AN043; If in CALL,
  2419                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2420                                  		;invoke	IOSET			; Set up any redirection
  2421                                  ;skip_ioset:					;AN043;
  2422                                  		;call	FREE_TPA		; G
  2423                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2424                                  		;jz	getecho 		; G if we're in a call, don't execute
  2425                                  
  2426                                  		; MSDOS 3.3
  2427 000006E6 E81C17                  		call	IOSET
  2428 000006E9 8E06[7142]              		mov	es,[RESSEG]
  2429 000006ED E870FF                  		call	FREE_TPA
  2430                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2431 000006F0 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2432 000006F6 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2433                                  
  2434                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2435                                  
  2436                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2437                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2438                                  ; Don't execute if in call
  2439                                  
  2440 000006F8 E8A007                  		call	FOROFF
  2441                                  GETECHO:
  2442 000006FB E88E1C                  		call	PIPEOFF
  2443 000006FE 26A0EF0B                		mov	al,byte [es:ECHOFLAG] ; preserve echo state for chaining
  2444 00000702 2401                    		and	al,1		; Save current echo state
  2445                                  
  2446 00000704 50                      		push	ax
  2447 00000705 31C0                    		xor	ax,ax
  2448 00000707 26F706990BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2449 0000070E 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2450 00000710 26A1990B                		mov	ax,word [es:BATCH] ; Get current batch segment
  2451                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2452 00000714 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2453 0000071A 7408                    		jz	short LEAVEBAT
  2454                                  
  2455                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2456                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2457                                  
  2458 0000071C 06                      		push	es
  2459 0000071D 8EC0                    		mov	es,ax		; Get current batch segment
  2460                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2461                                  					; Get previous batch segment
  2462 0000071F 26A10200                		mov	ax,word [es:BATCHSEGMENT.BatLast]
  2463 00000723 07                      		pop	es
  2464                                  LEAVEBAT:
  2465 00000724 50                      		push	ax		; Keep segment until new one created
  2466 00000725 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2467 0000072B 7403                    		jz	short STARTBAT
  2468 0000072D E8F800                  		call	BATCHOFF
  2469                                  
  2470                                  ; Find length of batch file
  2471                                  
  2472                                  STARTBAT:
  2473 00000730 26C606010C00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2474 00000736 BE[9941]                		mov	si,EXECPATH
  2475                                  
  2476                                  		; MSDOS 6.0
  2477                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2478                                  		;int	2fh		;AN042;    was found with APPEND
  2479                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2480                                  		;mov	dx,si		;AN042; Get the string
  2481                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2482                                  		;int	21h		;AN042;
  2483                                  
  2484                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2485 00000739 E88017                  		call	DSTRLEN
  2486                                  ;
  2487                                  ; Allocate batch area:
  2488                                  ;   BYTE    type of segment
  2489                                  ;   WORD    segment of last batch file
  2490                                  ;   WORD    segment for FOR command
  2491                                  ;   BYTE    FOR flag state on entry to batch file
  2492                                  ;   DWORD   offset for next line
  2493                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2494                                  ;   ASCIZ   file name (with . and ..)
  2495                                  ;   BYTES   CR-terminated parameters
  2496                                  ;   BYTE    0 flag to indicate end of parameters
  2497                                  ;
  2498                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2499                                  ; later when we've squeezed out the extra
  2500                                  ;
  2501 0000073C 89CB                    		mov	bx,cx		; length of file name.
  2502                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2503 0000073E 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2504                                  					; structure + max len + round up
  2505 00000742 51                      		push	cx
  2506 00000743 B104                    		mov	cl,4
  2507 00000745 D3EB                    		shr	bx,cl		; convert to paragraphs
  2508 00000747 53                      		push	bx		; Save size of batch segment
  2509 00000748 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2510 0000074A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2511                                  				; BX = number of 16-byte paragraphs desired
  2512 0000074C 5B                      		pop	bx		; Get size of batch segment
  2513                                  
  2514                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2515                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2516                                  ; G This error will occur with nesting of batch files. We also need to
  2517                                  ; G make sure that we don't overlay the transient.
  2518                                  
  2519 0000074D 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2520                                  
  2521 0000074F 50                      		push	ax		;G save batch segment
  2522 00000750 01D8                    		add	ax,bx		;G get end of batch segment
  2523 00000752 83C020                  		add	ax,20h		;G add some tpa work area
  2524 00000755 8CCB                    		mov	bx,cs		;G get the transient segment
  2525                                  
  2526                                  		; MSDOS 6.0
  2527                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2528                                  ; M006; batchseg is always above the transient. We need to change this code
  2529                                  ; M006; to only check for an overlap
  2530                                  ;
  2531                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2532                                  		;add	dx,15		;round up para; M006
  2533                                  		;shr	dx,cl		;para size of transient; M006
  2534                                  		;add	dx,bx		;dx = top of transient; M006
  2535                                  
  2536                                  		;cmp	ax,bx		; M006
  2537                                  		;jb	enough_mem	; Batchseg below transient
  2538                                  					; enough memory ; M006
  2539                                  		;cmp	ax,dx		; M006
  2540                                  		;ja	enough_mem	; Batchseg above transient
  2541                                  					; enough memory ; M006
  2542                                  ;
  2543                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2544                                  ;
  2545                                  		;pop	ax		; restore ax; M006
  2546                                  
  2547                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2548                                  ;M006;		pop	ax		;G get batch segment back
  2549                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2550                                  
  2551                                  		; MSDOS 3.3
  2552 00000757 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2553 00000759 58                      		pop	ax		; get batch segment back
  2554 0000075A 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2555                                  
  2556                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2557 0000075C 06                      		push	es		;G no we're hitting the transient
  2558 0000075D 8EC0                    		mov	es,ax
  2559 0000075F B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2560 00000762 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2561                                  				; ES = segment address of area to be freed
  2562 00000764 07                      		pop	es
  2563                                  MEM_ERROR:
  2564 00000765 E9B400                  		jmp	NO_MEMORY	;G Set up for message and exit
  2565                                  
  2566                                  ENOUGH_MEM:
  2567                                  		; MSDOS 6.0
  2568                                  		;pop	ax		; restore ax; M006
  2569                                  
  2570                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2571 00000768 26A3990B                		mov	word [es:BATCH],ax
  2572 0000076C E801FF                  		call	ALLOC_TPA
  2573                                  
  2574                                  ; Initialize batch segment
  2575                                  
  2576 0000076F 5A                      		pop	dx		; length of name
  2577 00000770 58                      		pop	ax		;G get saved batch segment back
  2578 00000771 26FF06FE0B              		inc	word [es:NEST]	;G increment # batch files in progress
  2579 00000776 06                      		push	es
  2580 00000777 268E06990B              		mov	es,word [es:BATCH]
  2581                                  		;mov	byte [ES:0],0
  2582                                  					; signal batch file type
  2583 0000077C 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2584                                  		;mov	byte [ES:2],ax ; MSDOS 3.3
  2585                                  					;G save segment of last batch file
  2586 00000782 26A30200                		mov	word [es:BATCHSEGMENT.BatLast],ax
  2587 00000786 1E                      		push	ds
  2588 00000787 8E1E[7142]              		mov	ds,[RESSEG]	;G set to resident data
  2589                                  
  2590 0000078B 31C0                    		xor	ax,ax
  2591 0000078D 8A1EFB0B                		mov	bl,byte [FORFLAG] ;G get the current FOR state
  2592                                  		;mov	[es:6],bl ;  MSDOS 3.3
  2593                                  					;G save it in the batch segment
  2594 00000791 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2595 00000796 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2596 00000799 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2597 0000079B A1FC0B                  		mov	ax,word [FORPTR] ;G yes, get current FOR segment	
  2598 0000079E C606FB0B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2599                                  FOR_NOT_ON:
  2600                                  		;mov	[es:4],ax ; MSDOS 3.3
  2601                                  					;G save FOR segment in batch segment
  2602 000007A3 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2603 000007A7 31C0                    		xor	ax,ax
  2604 000007A9 A3FC0B                  		mov	word [FORPTR],ax ;G make sure for segment is not active
  2605 000007AC 8A1EEF0B                		mov	bl,byte [ECHOFLAG]
  2606 000007B0 1F                      		pop	ds
  2607                                  		;mov	[es:1],bl 
  2608                                  					 ;G save echo state of parent
  2609 000007B1 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2610                                  ;SR;
  2611                                  ; Initialize the new BatchEOF flag we have added to 0
  2612                                  ;
  2613                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2614                                  
  2615 000007B6 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2616 000007BA 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2617                                  
  2618                                  ; Initialize pointers
  2619                                  
  2620 000007BE 48                      		dec	ax		; put -1 into AX
  2621                                  		;mov	di,0Bh  ; MSDOS 3.3
  2622                                  					; point to parm area
  2623 000007BF BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2624 000007C2 89FB                    		mov	bx,di
  2625 000007C4 B90A00                  		mov	cx,10
  2626 000007C7 F3AB                    		rep stosw		; Init to no parms
  2627                                  
  2628                                  ; Move in batch file name
  2629                                  
  2630 000007C9 89D1                    		mov	cx,dx
  2631 000007CB F3A4                    		rep movsb
  2632                                  
  2633                                  ; Now copy the command line into batch segment, parsing the arguments along
  2634                                  ; the way. Segment will look like this:
  2635                                  ;
  2636                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2637                                  ;
  2638                                  ; or, in the case of fewer arguments:
  2639                                  ;
  2640                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2641                                  ;
  2642 000007CD BE[D240]                		mov	si,COMBUF+2
  2643 000007D0 B90A00                  		mov	cx,10		; at most 10 arguments
  2644                                  EACHPARM:
  2645 000007D3 E8A311                  		call	SCANOFF		; skip to argument
  2646                                  
  2647                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2648                                  
  2649 000007D6 3C0D                    		cmp	al,0Dh		; end of road?
  2650 000007D8 741D                    		jz	short HAVPARM	; yes, no more arguments
  2651                                  
  2652                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2653                                  
  2654 000007DA E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2655                                  
  2656                                  ; Go into allocated piece and stick in new argument pointer.
  2657                                  
  2658 000007DC 26893F                  		mov	[es:bx],di	; store batch pointer
  2659 000007DF 83C302                  		add	bx,2		; advance arg counter
  2660                                  
  2661                                  ; Move the parameter into batch segment
  2662                                  
  2663                                  MOVPARM:
  2664 000007E2 AC                      		lodsb			; get byte
  2665 000007E3 E89B11                  		call	DELIM		; if delimiter
  2666 000007E6 7407                    		jz	short ENDPARM	; then done with parm
  2667 000007E8 AA                      		stosb			; store byte
  2668 000007E9 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2669 000007EB 740A                    		jz	short HAVPARM	; but end of parm list, finish
  2670 000007ED EBF3                    		jmp	short MOVPARM
  2671                                  
  2672                                  ; We have copied a parameter up until the first separator.
  2673                                  ; Terminate it with CR.
  2674                                  
  2675                                  ENDPARM:
  2676 000007EF B00D                    		mov	al,0Dh
  2677 000007F1 AA                      		stosb
  2678 000007F2 E3DF                    		jcxz	EACHPARM	; if no parameters, don't dec
  2679 000007F4 49                      		dec	cx		; remember that we've seen one.	
  2680 000007F5 EBDC                    		jmp	short EACHPARM
  2681                                  
  2682                                  ; We have parsed the entire line. Terminate the arg list
  2683                                  
  2684                                  HAVPARM:
  2685 000007F7 30C0                    		xor	al,al		; Nul terminate the parms
  2686 000007F9 AA                      		stosb
  2687                                  
  2688                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2689                                  ; into paragraphs and setblock to the appropriate size
  2690                                  
  2691 000007FA 8D5D0F                  		lea	bx,[di+15]
  2692 000007FD B104                    		mov	cl,4
  2693 000007FF D3EB                    		shr	bx,cl
  2694 00000801 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2695 00000803 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2696                                  				; ES = segment address of block	to change
  2697                                  				; BX = new size	in paragraphs
  2698 00000805 07                      		pop	es
  2699 00000806 06                      		push	es
  2700 00000807 1F                      		pop	ds		; Simply batch FCB setup
  2701 00000808 833EF50BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2702 0000080D 7506                    		jnz	short NOBATSING
  2703 0000080F C706F50BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2704                                  NOBATSING:
  2705                                  
  2706                                  ; Enter the batch file with the current echo state
  2707                                  
  2708 00000815 58                      		pop	ax		; Get original echo state
  2709 00000816 A2EF0B                  		mov	byte [ECHOFLAG],al ; restore it
  2710 00000819 E9E8F8                  		jmp	TCOMMAND
  2711                                  
  2712                                  ; The following is executed if there isn't enough memory for batch segment
  2713                                  
  2714                                  NO_MEMORY:
  2715 0000081C 5A                      		pop	dx		; even up our stack 
  2716 0000081D 58                      		pop	ax
  2717 0000081E 58                      		pop	ax
  2718 0000081F E84EFE                  		call	ALLOC_TPA	; reallocate memory
  2719                                  
  2720                                  		; MSDOS 3.3
  2721 00000822 BA[AA3C]                		mov	dx,INSFMEMMESPTR
  2722 00000825 E90114                  		jmp	CERROR
  2723                                  
  2724                                  		; MSDOS 6.0
  2725                                  		;mov	msg_disp_class,ext_msg_class
  2726                                  		;			;AN000; set up extended error msg class
  2727                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2728                                  		;			;AC000; get extended message pointer
  2729                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2730                                  		;			;AN000; get message number in control block
  2731                                  		;jmp	cerror		;g print error message and go...
  2732                                  
  2733                                  ; =============== S U B	R O U T	I N E =======================================
  2734                                  
  2735                                  BATCHOFF:
  2736 00000828 50                      		push	ax
  2737 00000829 06                      		push	es
  2738 0000082A 1E                      		push	ds
  2739 0000082B 53                      		push	bx
  2740                                  
  2741 0000082C 2E8E06[7142]            		mov	es,[cs:RESSEG]
  2742 00000831 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  2743 00000836 A1990B                  		mov	ax,word [BATCH]	; Free the batch segment
  2744 00000839 09C0                    		or	ax,ax
  2745 0000083B 7442                    		jz	short NOTFREE
  2746                                  
  2747 0000083D 06                      		push	es
  2748 0000083E 8EC0                    		mov	es,ax
  2749 00000840 F606EF0B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2750 00000845 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2751                                  		;mov	byte [SUPPRESS],0
  2752 00000847 C606F00B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2753                                  ECHO_LAST_LINE:
  2754                                  		;mov	bl,[es:1]
  2755 0000084C 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2756 00000851 881EEF0B                		mov	byte [ECHOFLAG],bl		 ; G and restore it
  2757                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2758 00000855 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2759 0000085A 891EFC0B                		mov	word [FORPTR],bx		;G  and restore it
  2760                                  		;mov	bl,[es:6]
  2761 0000085E 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2762 00000863 881EFB0B                		mov	byte [FORFLAG],bl		;G  and restore it
  2763                                  		;mov	bx,word [es:2] ; MSDOS 3.3
  2764 00000867 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment
  2765                                  
  2766 0000086C B449                    		mov	ah,DEALLOC ; 49h
  2767 0000086E CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2768                                  				; ES = segment address of area to be freed
  2769 00000870 07                      		pop	es
  2770 00000871 891E020C                		mov	word [NEXT_BATCH],bx ;G  reset batch segment	
  2771 00000875 26FF0EFE0B              		dec	word [es:NEST]
  2772 0000087A 31C0                    		xor	ax,ax
  2773 0000087C A3990B                  		mov	word [BATCH],ax	; No batch in progress
  2774                                  NOTFREE:
  2775 0000087F 5B                      		pop	bx
  2776 00000880 1F                      		pop	ds
  2777 00000881 07                      		pop	es
  2778 00000882 58                      		pop	ax
  2779 00000883 C3                      		retn
  2780                                  
  2781                                  ; =============== S U B	R O U T	I N E =======================================
  2782                                  
  2783                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2784                                  ;	Entry : DS:SI ==> source string
  2785                                  ;		ES:DI ==> destination string
  2786                                  ;		CX = current length of destination string
  2787                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2788                                  
  2789                                  		; MSDOS 3.3
  2790                                  STRCPY:
  2791 00000884 50                      		push	ax
  2792                                  CCYCLE:
  2793 00000885 AC                      		lodsb
  2794 00000886 AA                      		stosb
  2795 00000887 08C0                    		or	al,al
  2796 00000889 75FA                    		jnz	short CCYCLE
  2797 0000088B 58                      		pop	ax
  2798 0000088C C3                      		retn
  2799                                  
  2800                                  		; MSDOS 6.0
  2801                                  ;Procedure StrCpy,NEAR
  2802                                  		;push	ax
  2803                                  ;ccycle:
  2804                                  		;lodsb
  2805                                  		;inc	cx
  2806                                  		;cmp	cx,COMBUFLEN
  2807                                  		;jb	ccopy
  2808                                  		;stc			; set carry to signal error
  2809                                  		;jmp	short ccend
  2810                                  ;ccopy:
  2811                                  		;stosb
  2812                                  		;or	al,al
  2813                                  		;jnz	ccycle
  2814                                  ;ccend:
  2815                                  		;dec	cx		; discount extra byte
  2816                                  		;dec	di		; back up pointer
  2817                                  		;pop	ax
  2818                                  		;return			; return carry clear
  2819                                  ;EndProc StrCpy
  2820                                  
  2821                                  ;============================================================================
  2822                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2823                                  ;============================================================================
  2824                                  ; 12/10/2018 - Retro DOS v3.0
  2825                                  
  2826                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2827                                  
  2828                                  ; =============== S U B	R O U T	I N E =======================================
  2829                                  
  2830                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2831                                  
  2832                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2833                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2834                                  ; AH, DX destroyed.
  2835                                  
  2836                                  GETBATBYT:
  2837 0000088D 53                      		push	bx
  2838 0000088E 51                      		push	cx
  2839 0000088F 1E                      		push	ds
  2840 00000890 F606E50BFF              		test	byte [BATCH_ABORT],-1
  2841 00000895 755E                    		jnz	short BATEOF
  2842 00000897 F706990BFFFF            		test	word [BATCH],-1
  2843 0000089D 7456                    		jz	short BATEOF
  2844 0000089F 06                      		push	es
  2845 000008A0 8E06990B                		mov	es,word [BATCH]
  2846                                  
  2847                                  		; MSDOS 6.0
  2848                                  ;M020;
  2849                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2850                                  ;try to read from the batchfile again.
  2851                                  ;
  2852                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2853                                  		;jz	not_eof		;no, read batch file	;M020
  2854                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2855                                  ;not_eof:							;M020
  2856                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2857 000008A4 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2858 000008AA 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2859 000008B0 07                      		pop	es
  2860                                  
  2861                                  ; See if we have bytes buffered...
  2862                                  
  2863 000008B1 8CC8                    		mov	ax,cs
  2864 000008B3 8ED8                    		mov	ds,ax
  2865 000008B5 8B1E[184D]              		mov	bx,[BATBUFPOS]
  2866 000008B9 83FBFF                  		cmp	bx,-1
  2867 000008BC 751D                    		jnz	short UNBUF
  2868                                  
  2869                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2870                                  
  2871 000008BE BA[1A4D]                		mov	dx,BATBUF
  2872 000008C1 8B0E[223F]              		mov	cx,[BATBUFLEN] ; max to read.
  2873 000008C5 8B1E[9545]              		mov	bx,[BATHAND]
  2874 000008C9 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2875 000008CB CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2876                                  				; BX = file handle,CX = number	of bytes to read
  2877                                  				; DS:DX	-> buffer
  2878                                  		; MSDOS 6.0
  2879                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2880                                  		;invoke	get_ext_error_number	;AN022; get the error
  2881                                  		;push	ds			;AN022; save local segment
  2882                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2883                                  		;assume ds:resgroup		;AN022;
  2884                                  		;mov	dx,ax			;AN022; put error in DX
  2885                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2886                                  		;pop	ds			;AN022;
  2887                                  		;assume	ds:trangroup		;AN022;
  2888                                  		;invoke	std_eprintf		;AN022; print out the error
  2889                                  		;mov	byte ptr combuf+2,end_of_line_in
  2890                                  		;				;AN022; terminate the batch line for parsing
  2891                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2892                                  		;				;AN022; terminate the batch line for output
  2893                                  ;M020;
  2894                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2895                                  ;error is never hit (and it shouldn't be)
  2896                                  ;
  2897                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2898                                  		;
  2899                                  		;jmp	short bateof		;AN022; terminate the batch file
  2900                                  ;bat_read_ok:					;AN022;
  2901                                  
  2902                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2903 000008CD 89C1                    		mov	cx,ax
  2904 000008CF E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2905                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2906 000008D1 890E[3A4D]              		mov	[BATBUFEND],cx
  2907 000008D5 31DB                    		xor	bx,bx
  2908 000008D7 891E[184D]              		mov	[BATBUFPOS],bx
  2909                                  
  2910                                  ; Buffered bytes!
  2911                                  
  2912                                  UNBUF:
  2913 000008DB 8A87[1A4D]              		mov	al,[BATBUF+bx]		; get next byte
  2914 000008DF 43                      		inc	bx
  2915 000008E0 3B1E[3A4D]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2916 000008E4 7203                    		jb	short SETBUFPOS
  2917 000008E6 BBFFFF                  		mov	bx,-1
  2918                                  SETBUFPOS:
  2919 000008E9 891E[184D]              		mov	[BATBUFPOS],bx
  2920 000008ED 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2921 000008EF 7533                    		jnz	short GETBYTEDONE
  2922                                  
  2923                                  ;We get here only when we hit an EOF
  2924                                  		
  2925                                  		; MSDOS 6.0
  2926                                  ;BatEOFDS:
  2927                                  ;SR;
  2928                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2929                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2930                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2931                                  ;batch processing is turned off before the last line is processed and so 
  2932                                  ;this line would never be executed. 
  2933                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2934                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2935                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2936                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2937                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2938                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2939                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2940                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2941                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2942                                  ;another redundant CR-LF. There is no work-around I can think of.
  2943                                  ; 	I would love to restructure this entire routine and its caller to
  2944                                  ;make the flow really easy to understand but I guess this will have to wait.
  2945                                  ;
  2946                                  		;push	es
  2947                                  		;mov	es,ResSeg
  2948                                  ;SR;
  2949                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2950                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2951                                  ;
  2952                                  		;mov	es,es:Batch
  2953                                  		;cmp	es:BatchEOF,0
  2954                                  		;jnz	crpresent
  2955                                  
  2956                                  		;inc	es:BatchEOF		;match the dec following
  2957                                  		;mov	bx,BatBufEnd
  2958                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2959                                  		;je	crpresent		;yes, no need to fake it
  2960                                  
  2961                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2962                                  
  2963                                  ;crpresent:
  2964                                  ;;;		;pop	es
  2965                                  
  2966                                  		;ASSUME	DS:TranGroup
  2967                                  		;MOV	DS,ResSeg
  2968                                  		;ASSUME	DS:ResGroup
  2969                                  
  2970                                  ;SR;
  2971                                  ; The shift operation is done here to replace the decrement. This is because
  2972                                  ;we can jump to this label directly from above when bogus calls are made to
  2973                                  ;this routine even after batch processing is turned off. The shift ensures
  2974                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  2975                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  2976                                  ;calls.
  2977                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  2978                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  2979                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  2980                                  ;turning batch processing off.
  2981                                  
  2982                                  ;At_EOF:						;new label added ;M020
  2983                                  		;shr	es:BatchEOF,1		;decrement the flag
  2984                                  		;jz	turn_off		;zero,turn batch off
  2985                                  		;cmp	es:BatchEOF,1				
  2986                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  2987                                  ;
  2988                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  2989                                  ;
  2990                                  		;mov	al,0dh			;return fake CR.
  2991                                  		;pop	es
  2992                                  		;jmp	short GetByteDone
  2993                                  ;ret_lf:
  2994                                  		;mov	al,0ah			;return fake LF
  2995                                  		;pop	es
  2996                                  		;jmp	short	GetByteDone			
  2997                                  ;turn_off:
  2998                                  		;pop	es
  2999                                  
  3000                                  ;BATEOF:
  3001                                  
  3002                                  		; MSDOS 3.3
  3003                                  TURN_OFF:
  3004 000008F1 8E1E[7142]              		mov	ds,[RESSEG]
  3005                                  
  3006                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3007                                  BATEOF:
  3008 000008F5 E830FF                  		call	BATCHOFF
  3009 000008F8 E89A02                  		call	BATCLOSE
  3010                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3011                                  
  3012                                  ;SR; BugBug
  3013                                  ; There is a good reason why this carriage return is being returned here. 
  3014                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3015                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3016                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3017                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3018                                  ;the batchfile already had a CR-LF. 
  3019                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3020                                  ;the end-of-line. This CR is to mark the end-of-file.
  3021                                  
  3022 000008FB B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3023 000008FD F606E50BFF              		test	byte [BATCH_ABORT],-1
  3024 00000902 C606E50B00              		mov	byte [BATCH_ABORT],0
  3025 00000907 7407                    		jz	short CONT_GET_BYT
  3026 00000909 BF[D240]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3027 0000090C 31C9                    		xor	cx,cx		; zero line length
  3028 0000090E EB14                    		jmp	short GETBYTEDONE
  3029                                  CONT_GET_BYT:
  3030 00000910 833EF50BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3031 00000915 750D                    		jnz	short GETBYTEDONE
  3032 00000917 833EFE0B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3033 0000091C 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3034 0000091E C706F50BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3035                                  GETBYTEDONE:
  3036 00000924 1F                      		pop	ds
  3037 00000925 59                      		pop	cx
  3038 00000926 5B                      		pop	bx
  3039 00000927 C3                      		retn
  3040                                  
  3041                                  ; ---------------------------------------------------------------------------
  3042                                  
  3043                                  ;break	<$If - conditional execution>
  3044                                  
  3045                                  IFERRORP:
  3046 00000928 58                      		pop	ax
  3047                                  IFERROR:
  3048                                  FORERROR:
  3049 00000929 BA[783C]                		mov	dx,SYNTMESPTR
  3050 0000092C E9FA12                  		jmp	CERROR
  3051                                  
  3052                                  ; ---------------------------------------------------------------------------
  3053                                  
  3054                                  _$IF:
  3055                                  		; MSDOS 6.0
  3056                                  ; Turn off any pipes in progress.
  3057                                  		;push	ds			;AN004; save local DS
  3058                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3059                                  		;assume	ds:resgroup		;AN004;
  3060                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3061                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3062                                  		;invoke	PipeDel 		;AN004; turn off piping
  3063                                  ;IFNoPipe:					;AN004;
  3064                                  		;pop	ds			;AN004; get local DS back
  3065                                  		;assume	ds:trangroup		;AN004;
  3066                                  
  3067                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3068 0000092F C606[8442]00            		mov	byte [IFNOTFLAG],0
  3069 00000934 C706[F54B]0000          		mov	word [IF_NOT_COUNT],0
  3070 0000093A BE8100                  		mov	si,81h
  3071                                  IFREENT:
  3072 0000093D E83910                  		call	SCANOFF
  3073 00000940 3C0D                    		cmp	al,0Dh
  3074 00000942 74E5                    		jz	short IFERROR
  3075 00000944 89F5                    		mov	bp,si
  3076 00000946 BF[C73D]                		mov	di,IFTAB	; Prepare to search if table	
  3077 00000949 B500                    		mov	ch,0
  3078                                  IFINDCOM:
  3079 0000094B 89EE                    		mov	si,bp
  3080 0000094D 8A0D                    		mov	cl,[di]
  3081 0000094F 47                      		inc	di
  3082 00000950 E337                    		jcxz	IFSTRING
  3083 00000952 EB02                    		jmp	short FIRSTCOMP
  3084                                  
  3085                                  IFCOMP:
  3086 00000954 7510                    		jnz	short IF_DIF
  3087                                  FIRSTCOMP:
  3088 00000956 AC                      		lodsb
  3089 00000957 268A25                  		mov	ah,[es:di]
  3090 0000095A 47                      		inc	di
  3091 0000095B 38E0                    		cmp	al,ah
  3092 0000095D 7405                    		jz	short IFLP
  3093 0000095F 80CC20                  		or	ah,20h		; Try lower case
  3094 00000962 38E0                    		cmp	al,ah
  3095                                  IFLP:
  3096 00000964 E2EE                    		loop	IFCOMP
  3097                                  IF_DIF:
  3098 00000966 9F                      		lahf
  3099 00000967 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3100 00000969 8B1D                    		mov	bx,[di]		; Get handler address
  3101 0000096B 47                      		inc	di
  3102 0000096C 47                      		inc	di
  3103 0000096D 9E                      		sahf
  3104 0000096E 75DB                    		jnz	short IFINDCOM
  3105 00000970 AC                      		lodsb
  3106 00000971 3C0D                    		cmp	al,0Dh
  3107                                  IFERRJ:
  3108 00000973 74B4                    		jz	short IFERROR
  3109 00000975 E80910                  		call	DELIM
  3110 00000978 75D1                    		jnz	short IFINDCOM
  3111 0000097A E8FC0F                  		call	SCANOFF
  3112 0000097D FFE3                    		jmp	bx
  3113                                  
  3114                                  IFNOT:
  3115 0000097F F616[8442]              		not	byte [IFNOTFLAG]
  3116 00000983 FF06[F54B]              		inc	word [IF_NOT_COUNT]
  3117 00000987 EBB4                    		jmp	short IFREENT
  3118                                  
  3119                                  ; We are comparing two strings for equality. First, find the end of the
  3120                                  ; first string.
  3121                                  
  3122                                  IFSTRING:
  3123 00000989 56                      		push	si		; save away pointer for later compare
  3124 0000098A 31C9                    		xor	cx,cx		; count of chars in first string
  3125                                  FIRST_STRING:
  3126 0000098C AC                      		lodsb			; get character
  3127 0000098D 3C0D                    		cmp	al,0Dh		; end of line?
  3128 0000098F 7497                    		jz	short IFERRORP	; yes => error
  3129 00000991 E8ED0F                  		call	DELIM		; is it a delimiter?
  3130 00000994 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3131 00000996 41                      		inc	cx		; remember 1 byte for the length
  3132 00000997 EBF3                    		jmp	short FIRST_STRING ; go back for more
  3133                                  EQUAL_CHECK:
  3134 00000999 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3135 0000099B 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3136 0000099D 3C0D                    		cmp	al,0Dh		; end of line?
  3137 0000099F 7487                    		jz	short IFERRORP	; yes, syntax error
  3138 000009A1 AC                      		lodsb			; get next char
  3139 000009A2 EBF5                    		jmp	short EQUAL_CHECK
  3140                                  
  3141                                  ; The first = has been found. The next char had better be an = too.
  3142                                  
  3143                                  EQUAL_CHECK2:
  3144 000009A4 AC                      		lodsb			; get potential = char
  3145 000009A5 3C3D                    		cmp	al,'='		; is it good?	
  3146 000009A7 7520                    		jnz	short IFERRPJ	; no, error
  3147                                  
  3148                                  ; Find beginning of second string.
  3149                                  
  3150 000009A9 E8CD0F                  		call	SCANOFF
  3151 000009AC 3C0D                    		cmp	al,0Dh
  3152 000009AE 7419                    		jz	short IFERRPJ
  3153 000009B0 5F                      		pop	di
  3154                                  
  3155                                  ; DS:SI points to second string
  3156                                  ; CX has number of chars in first string
  3157                                  ; ES:DI points to first string
  3158                                  
  3159 000009B1 F3A6                    		repe cmpsb
  3160 000009B3 7417                    		jz	short MATCH	; match found!
  3161                                  
  3162                                  ; No match.  Let's find out what was wrong. The character that did not match
  3163                                  ; has been advanced over. Let's back up to it.
  3164                                  
  3165 000009B5 4E                      		dec	si
  3166                                  
  3167                                  ; If it is EOL, then syntax error
  3168                                  
  3169 000009B6 803C0D                  		cmp	byte [si],0Dh
  3170 000009B9 74B8                    		jz	short IFERRJ
  3171                                  
  3172                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3173                                  
  3174                                  SKIPSTRINGEND:
  3175 000009BB AC                      		lodsb
  3176                                  NOTMATCH:
  3177 000009BC 3C0D                    		cmp	al,0Dh
  3178                                  IFERRORJ2:
  3179 000009BE 74B3                    		jz	short IFERRJ
  3180 000009C0 E8BE0F                  		call	DELIM
  3181 000009C3 75F6                    		jnz	short SKIPSTRINGEND
  3182                                  
  3183                                  ; Signal that we did NOT have a match
  3184                                  
  3185 000009C5 B0FF                    		mov	al,-1
  3186 000009C7 EB3A                    		jmp	short IFRET
  3187                                  IFERRPJ:
  3188 000009C9 E95CFF                  		jmp	IFERRORP
  3189                                  
  3190                                  ; The compare succeeded. Was the second string longer than the first?
  3191                                  ; We do this by seeing if the next char is a delimiter.
  3192                                  
  3193                                  MATCH:
  3194 000009CC AC                      		lodsb
  3195 000009CD E8B10F                  		call	DELIM
  3196 000009D0 75EA                    		jnz	short NOTMATCH ; not same.
  3197 000009D2 30C0                    		xor	al,al
  3198 000009D4 EB2D                    		jmp	short IFRET
  3199                                  
  3200                                  ; ---------------------------------------------------------------------------
  3201                                  
  3202                                  IFEXISTS:
  3203                                  
  3204                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3205                                  
  3206                                  ;MOREDELIM:
  3207 000009D6 AC                      		lodsb
  3208 000009D7 E8A70F                  		call	DELIM
  3209 000009DA 75FA                    		jnz	short IFEXISTS
  3210                                  		;jnz	short MOREDELIM
  3211                                  
  3212 000009DC BA[6A43]                		mov	dx,DIRBUF
  3213 000009DF B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3214 000009E2 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3215                                  				; DS:DX	-> disk	transfer buffer
  3216 000009E4 BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3217 000009E7 031E[F54B]              		add	bx,[IF_NOT_COUNT]
  3218                                  		;mov	ax,ARG_ARGV
  3219                                  		;mov	ax,ARG+ARG_UNIT.argv
  3220 000009EB B8[A945]                		mov	ax,ARG
  3221 000009EE E8E91A                  		call	ARGV_CALC	; convert arg index to pointer
  3222 000009F1 8B17                    		mov	dx,[bx]
  3223                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3224                                  		;mov	cx,6
  3225 000009F3 B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3226 000009F6 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3227 000009F9 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3228                                  				; CX = search attributes
  3229                                  				; DS:DX	-> ASCIZ filespec
  3230                                  				; (drive,path, and wildcards allowed)
  3231 000009FB 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3232 000009FD 30C0                    		xor	al,al
  3233 000009FF EB02                    		jmp	short IFRET
  3234                                  
  3235                                  		;nop
  3236                                  IF_EX_C:
  3237 00000A01 B0FF                    		mov	al,-1		; false 'n' fall through...
  3238                                  IFRET:
  3239 00000A03 F606[8442]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3240 00000A08 7402                    		jz	short REALTEST
  3241 00000A0A F6D0                    		not	al
  3242                                  REALTEST:
  3243 00000A0C 08C0                    		or	al,al
  3244 00000A0E 7403                    		jz	short IFTRUE
  3245 00000A10 E9F1F6                  		jmp	TCOMMAND
  3246                                  
  3247                                  IFTRUE:
  3248 00000A13 E8630F                  		call	SCANOFF
  3249 00000A16 89F1                    		mov	cx,si
  3250 00000A18 81E98100                		sub	cx,81h
  3251 00000A1C 280E8000                		sub	[80h],cl
  3252 00000A20 8A0E8000                		mov	cl,[80h]
  3253 00000A24 880E[D140]              		mov	[COMBUF+1],cl
  3254 00000A28 BF[D240]                		mov	di,COMBUF+2
  3255 00000A2B FC                      		cld
  3256 00000A2C F3A4                    		rep movsb
  3257 00000A2E B00D                    		mov	al,0Dh
  3258 00000A30 AA                      		stosb
  3259                                  
  3260                                  ; Signal that an IF was done. 
  3261                                  ; This prevents the redirections from getting lost.
  3262                                  
  3263 00000A31 1E                      		push	ds
  3264 00000A32 8E1E[7142]              		mov	ds,[RESSEG]
  3265 00000A36 C606FA0BFF              		mov	byte [IFFLAG],-1
  3266 00000A3B 1F                      		pop	ds
  3267                                  
  3268                                  ; Go do the command
  3269                                  
  3270 00000A3C E96EF8                  		jmp	DOCOM1
  3271                                  
  3272                                  ; ---------------------------------------------------------------------------
  3273                                  
  3274                                  IFERRORJ3:
  3275 00000A3F E97CFF                  		jmp	IFERRORJ2
  3276                                  
  3277                                  IFERLEV:
  3278 00000A42 B70A                    		mov	bh,10
  3279 00000A44 30DB                    		xor	bl,bl
  3280                                  GETNUMLP:
  3281 00000A46 AC                      		lodsb
  3282 00000A47 3C0D                    		cmp	al,0Dh
  3283 00000A49 74F4                    		jz	short IFERRORJ3
  3284 00000A4B E8330F                  		call	DELIM
  3285 00000A4E 740C                    		jz	short GOTNUM
  3286 00000A50 2C30                    		sub	al,'0'
  3287 00000A52 86C3                    		xchg	al,bl
  3288 00000A54 F6E7                    		mul	bh
  3289 00000A56 00D8                    		add	al,bl
  3290 00000A58 86C3                    		xchg	al,bl
  3291 00000A5A EBEA                    		jmp	short GETNUMLP
  3292                                  GOTNUM:
  3293 00000A5C 1E                      		push	ds
  3294 00000A5D 8E1E[7142]              		mov	ds,[RESSEG]
  3295 00000A61 8A26EC0B                		mov	ah,byte [RETCODE]  ; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3296 00000A65 1F                      		pop	ds
  3297 00000A66 30C0                    		xor	al,al
  3298 00000A68 38DC                    		cmp	ah,bl
  3299 00000A6A 7397                    		jnb	short IFRET
  3300 00000A6C FEC8                    		dec	al
  3301 00000A6E EB93                    		jmp	short IFRET
  3302                                  
  3303                                  ; ---------------------------------------------------------------------------
  3304                                  
  3305                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3306                                  ; This is a NOP if no batch in progress.
  3307                                  
  3308                                  SHIFT:
  3309 00000A70 8E1E[7142]              		mov	ds,[RESSEG]
  3310 00000A74 A1990B                  		mov	ax,word [BATCH]	; get batch pointer
  3311 00000A77 09C0                    		or	ax,ax		; in batch mode?
  3312 00000A79 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3313                                  SHIFT_RETN:				; no, done.
  3314 00000A7B C3                      		retn
  3315                                  SHIFT1:
  3316 00000A7C 8EC0                    		mov	es,ax
  3317 00000A7E 8ED8                    		mov	ds,ax
  3318                                  
  3319                                  ; Now move the batch args down by 1 word
  3320                                  
  3321                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3322 00000A80 BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3323 00000A83 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3324 00000A86 B90900                  		mov	cx,9		; move 9 parameters
  3325 00000A89 F3A5                    		rep movsw		; SHIFT down
  3326                                  
  3327                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3328                                  ; We have copied it into the previous position.
  3329                                  
  3330 00000A8B 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3331 00000A8E 74EB                    		jz	short SHIFT_RETN ; No new parm
  3332                                  
  3333                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3334                                  ; Assume, first, that there is no next argument.
  3335                                   
  3336 00000A90 8B35                    		mov	si,[di]
  3337 00000A92 C705FFFF                		mov	word [di],-1	; Assume no parm
  3338                                  
  3339                                  ; The parameters are CR separated. Scan for end of this parm.
  3340                                  
  3341                                  SKIPCRLP:
  3342 00000A96 AC                      		lodsb
  3343 00000A97 3C0D                    		cmp	al,0Dh
  3344 00000A99 75FB                    		jnz	short SKIPCRLP
  3345                                  
  3346                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3347                                  ; are finished. There are no more parms and the pointer has been previously
  3348                                  ; initialized to indicate it.
  3349                                  
  3350 00000A9B 803C00                  		cmp	byte [si],0
  3351 00000A9E 74DB                    		jz	short SHIFT_RETN ; End of parms
  3352 00000AA0 8935                    		mov	[di],si		; Pointer to next parm as %9
  3353 00000AA2 C3                      		retn
  3354                                  
  3355                                  ; =============== S U B	R O U T	I N E =======================================
  3356                                  
  3357                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3358                                  ; returns char in AL, carry set -> eof
  3359                                  
  3360                                  SKIPDELIM:
  3361 00000AA3 F706990BFFFF            		test	word [BATCH],-1	; batch file empty.  OOPS!
  3362 00000AA9 740A                    		jz	short SKIPERR
  3363 00000AAB E8DFFD                  		call	GETBATBYT	; get a char
  3364 00000AAE E8D00E                  		call	DELIM		; check for ignoreable chars
  3365 00000AB1 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3366 00000AB3 F8                      		clc
  3367 00000AB4 C3                      		retn
  3368                                  SKIPERR:
  3369 00000AB5 F9                      		stc
  3370                                  GOTO_RETN:
  3371 00000AB6 C3                      		retn
  3372                                  
  3373                                  ; ---------------------------------------------------------------------------
  3374                                  
  3375                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3376                                  ;  .com file. This routine strips the CALL off the command line, sets
  3377                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3378                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3379                                  ;  being CALLed.
  3380                                  
  3381                                  _$CALL:
  3382                                  
  3383                                  ;  strip off CALL from command line
  3384                                  
  3385                                  		;ASSUME DS:trangroup,ES:trangroup
  3386                                  
  3387 00000AB7 56                      		push	si
  3388 00000AB8 57                      		push	di
  3389 00000AB9 50                      		push	ax
  3390 00000ABA 51                      		push	cx
  3391 00000ABB BE[D240]                		mov	si,COMBUF+2
  3392 00000ABE E8B80E                  		call	SCANOFF		;get to first non-delimeter
  3393                                  		;add	si,4
  3394 00000AC1 83C604                  		add	si,length_call	;point to char past CALL
  3395 00000AC4 BF[D240]                		mov	di,COMBUF+2
  3396                                  		;mov	cx,124		
  3397 00000AC7 B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3398 00000ACA F3A4                    		rep movsb		;move it
  3399 00000ACC 59                      		pop	cx
  3400 00000ACD 58                      		pop	ax
  3401 00000ACE 5F                      		pop	di
  3402 00000ACF 5E                      		pop	si
  3403                                  
  3404                                  ;  set call flag to indicate call in progress
  3405                                  
  3406 00000AD0 1E                      		push	ds
  3407 00000AD1 8E1E[7142]              		mov	ds,[RESSEG]
  3408 00000AD5 C606000C01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3409 00000ADA C606010C01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3410                                  
  3411                                  ; Turn off any pipes in progress.
  3412                                  
  3413 00000ADF 803E5D0C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3414 00000AE4 7403                    		jz	short _NOPIPE
  3415 00000AE6 E82D14                  		call	PIPEDEL
  3416                                  _NOPIPE:
  3417 00000AE9 1F                      		pop	ds
  3418 00000AEA C3                      		retn
  3419                                  
  3420                                  ; ---------------------------------------------------------------------------
  3421                                  
  3422                                  GOTO:
  3423 00000AEB 8E1E[7142]              		mov	ds,[RESSEG]
  3424 00000AEF F706990BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3425 00000AF5 74BF                    		jz	short GOTO_RETN
  3426 00000AF7 31D2                    		xor	dx,dx
  3427 00000AF9 1E                      		push	ds
  3428 00000AFA 8E1E990B                		mov	ds,word [BATCH]
  3429 00000AFE 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3430 00000B02 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3431                                  
  3432                                  		; MSDOS 6.0
  3433                                  ;M037
  3434                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3435                                  ;
  3436                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3437                                  
  3438                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3439                                  
  3440 00000B06 1F                      		pop	ds
  3441                                  GOTOOPEN:
  3442 00000B07 E8ADF9                  		call	PROMPTBAT
  3443                                  		;mov	di,5Dh
  3444 00000B0A BF5D00                  		mov	di,FCB+1	; Get the label
  3445 00000B0D B90B00                  		mov	cx,11
  3446 00000B10 B020                    		mov	al,' '
  3447 00000B12 F2AE                    		repne scasb
  3448 00000B14 7501                    		jnz	short NOINC
  3449 00000B16 41                      		inc	cx
  3450                                  NOINC:
  3451 00000B17 83E90B                  		sub	cx,11
  3452 00000B1A F7D9                    		neg	cx
  3453 00000B1C 2E890E[6A43]            		mov	[cs:GOTOLEN],cx
  3454                                  
  3455                                  ; At beginning of file. Skip to first non-delimiter char
  3456                                  
  3457 00000B21 E87FFF                  		call	SKIPDELIM
  3458 00000B24 721C                    		jb	short BADGOTO
  3459 00000B26 3C3A                    		cmp	al,':'
  3460 00000B28 7423                    		jz	short CHKLABEL
  3461                                  LABLKLP:				; Look for the label
  3462 00000B2A E860FD                  		call	GETBATBYT
  3463 00000B2D 3C0A                    		cmp	al,0Ah
  3464 00000B2F 7509                    		jnz	short LABLKTST
  3465                                  
  3466                                  ; At beginning of line.  Skip to first non-delimiter char
  3467                                  
  3468 00000B31 E86FFF                  		call	SKIPDELIM
  3469 00000B34 720C                    		jb	short BADGOTO
  3470 00000B36 3C3A                    		cmp	al,':'
  3471 00000B38 7413                    		jz	short CHKLABEL
  3472                                  LABLKTST:
  3473 00000B3A F706990BFFFF            		test	word [BATCH],0FFFFh ; -1
  3474 00000B40 75E8                    		jnz	short LABLKLP
  3475                                  BADGOTO:
  3476 00000B42 E85000                  		call	BATCLOSE
  3477                                  
  3478                                  		; MSDOS 6.0
  3479                                  ;SR;
  3480                                  ; At this point we are terminating without freeing up any nested batch 
  3481                                  ;segments i.e if the error occurred within a called batch file. This routine
  3482                                  ;will traverse the linked list of batch segments and free all of them.
  3483                                  ;
  3484                                  		;call	free_batch	;free up nested batch segments
  3485                                  
  3486                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3487 00000B45 0E                      		push	cs
  3488 00000B46 1F                      		pop	ds
  3489 00000B47 BA[673C]                		mov	dx,BADLABPTR
  3490 00000B4A E9DC10                  		jmp	CERROR
  3491                                  
  3492                                  ; Found the :.	Skip to first non-delimiter char
  3493                                  
  3494                                  CHKLABEL:
  3495 00000B4D E853FF                  		call	SKIPDELIM
  3496 00000B50 72F0                    		jb	short BADGOTO
  3497 00000B52 BF5D00                  		mov	di,FCB+1 ; 5Dh
  3498 00000B55 2E8B0E[6A43]            		mov	cx,[cs:GOTOLEN]
  3499 00000B5A EB05                    		jmp	short GOTBYTE
  3500                                  
  3501                                  NEXTCHRLP:
  3502 00000B5C 51                      		push	cx
  3503 00000B5D E82DFD                  		call	GETBATBYT
  3504 00000B60 59                      		pop	cx
  3505                                  GOTBYTE:
  3506 00000B61 0C20                    		or	al,20h
  3507 00000B63 263A05                  		cmp	al,[es:di]
  3508 00000B66 7502                    		jnz	short TRYUPPER
  3509 00000B68 EB07                    		jmp	short NEXTLABCHR
  3510                                  TRYUPPER:
  3511 00000B6A 2C20                    		sub	al,20h
  3512 00000B6C 263A05                  		cmp	al,[es:di]
  3513 00000B6F 75C9                    		jnz	short LABLKTST
  3514                                  NEXTLABCHR:
  3515 00000B71 47                      		inc	di
  3516 00000B72 E2E8                    		loop	NEXTCHRLP
  3517 00000B74 E816FD                  		call	GETBATBYT
  3518 00000B77 2E833E[6A43]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3519 00000B7D 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3520 00000B7F 3C20                    		cmp	al,' '
  3521 00000B81 77B7                    		ja	short LABLKTST
  3522                                  GOTOCONT:
  3523 00000B83 3C0D                    		cmp	al,0Dh
  3524 00000B85 7407                    		jz	short SKIPLFEED
  3525                                  TONEXTBATLIN:
  3526 00000B87 E803FD                  		call	GETBATBYT
  3527 00000B8A 3C0D                    		cmp	al,0Dh
  3528 00000B8C 75F9                    		jnz	short TONEXTBATLIN
  3529                                  SKIPLFEED:
  3530 00000B8E E8FCFC                  		call	GETBATBYT
  3531                                  
  3532                                  		; MSDOS 6.0
  3533                                  ;SR;
  3534                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3535                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3536                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3537                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3538                                  ;all other cases, EOF will be hit while trying to read the next line and
  3539                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3540                                  ;
  3541                                  		;push	es
  3542                                  		;mov	es,Batch
  3543                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3544                                  		;pop	es
  3545                                  
  3546                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3547 00000B91 E80100                  		call	BATCLOSE
  3548 00000B94 C3                      		retn
  3549                                  
  3550                                  ; =============== S U B	R O U T	I N E =======================================
  3551                                  
  3552                                  BATCLOSE:
  3553 00000B95 2E8B1E[9545]            		mov	bx,[cs:BATHAND]
  3554 00000B9A 83FB05                  		cmp	bx,5
  3555 00000B9D 7204                    		jb	short CLOSERETURN
  3556 00000B9F B43E                    		mov	ah,CLOSE ; 3Eh
  3557 00000BA1 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3558                                  				; BX = file handle
  3559                                  CLOSERETURN:
  3560 00000BA3 C606E40B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3561 00000BA8 C3                      		retn
  3562                                  
  3563                                  ; =============== S U B	R O U T	I N E =======================================
  3564                                  
  3565                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3566                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3567                                  
  3568                                  BATOPEN:
  3569 00000BA9 1E                      		push	ds
  3570 00000BAA 8E1E990B                		mov	ds,word [BATCH]
  3571                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3572 00000BAE BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3573 00000BB1 B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3574 00000BB4 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3575                                  				; DS:DX	-> ASCIZ filename
  3576                                  				; AL = access mode
  3577                                  				; 0 - read
  3578 00000BB6 721C                    		jb	short SETERRDL
  3579 00000BB8 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3580 00000BBC 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3581 00000BC0 1F                      		pop	ds
  3582 00000BC1 2EA3[9545]              		mov	[cs:BATHAND],ax
  3583 00000BC5 89C3                    		mov	bx,ax
  3584 00000BC7 B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3585 00000BCA CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3586                                  				; AL = method: offset from beginning of	file
  3587                                  
  3588 00000BCC 2EC706[184D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3589                                  BATOPEN_RETN:
  3590 00000BD3 C3                      		retn
  3591                                  
  3592                                  SETERRDL:
  3593 00000BD4 89D3                    		mov	bx,dx
  3594                                  		; MSDOS 6.0
  3595                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3596                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3597                                  
  3598                                  		; MSDOS 3.3
  3599 00000BD6 BA[9E37]                		mov	dx,INSERTDSKPTR
  3600 00000BD9 E8EE12                  		call	GET_EXT_ERR_NUMBER
  3601                                  
  3602                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3603 00000BDC 8A07                    		mov	al,[bx]		; Get drive spec
  3604 00000BDE 2C40                    		sub	al,'@'		; A = 1
  3605 00000BE0 1F                      		pop	ds
  3606 00000BE1 F9                      		stc			; SUB mucked over carry
  3607 00000BE2 C3                      		retn
  3608                                  
  3609                                  ;============================================================================
  3610                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3611                                  ;============================================================================
  3612                                  ; 10/10/2018 - Retro DOS v3.0
  3613                                  
  3614                                  ; All batch proccessing has DS set to segment of resident portion
  3615                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3616                                  
  3617                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3618                                  
  3619                                  ; ---------------------------------------------------------------------------
  3620                                  
  3621                                  FORTERM:
  3622                                  		; MSDOS 6.0
  3623                                  		;push	cs		;AN037; Get local segment into
  3624                                  		;pop	ds		;AN037;    DS, ES
  3625                                  		;push	cs		;AN037;
  3626                                  		;pop	es		;AN037;
  3627                                  
  3628                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3629 00000BE3 E8B502                  		call	FOROFF
  3630 00000BE6 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  3631 00000BEB 813EF50B00FF            		cmp	word [SINGLECOM],0FF00h
  3632 00000BF1 750F                    		jne	short BAT_CRLF
  3633 00000BF3 833EFE0B00              		cmp	word [NEST],0	;See if we have nested batch files
  3634 00000BF8 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3635 00000BFA C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3636 00000C00 EB12                    		jmp	short NOFORP2
  3637                                  BAT_CRLF:
  3638 00000C02 F606EF0B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3639 00000C07 740B                    		jz	short NOFORP2	; no - exit
  3640 00000C09 F706990BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3641 00000C0F 7403                    		jz	short NOFORP2
  3642 00000C11 E8580D                  		call	CRLF2
  3643                                  NOFORP2:
  3644 00000C14 E9EDF4                  		jmp	TCOMMAND
  3645                                  
  3646                                  ; ---------------------------------------------------------------------------
  3647                                  
  3648                                  ;------
  3649                                  ;   For-loop processing.  For loops are of the form:
  3650                                  ;	    for %<loop-variable> in (<list>) do <command>
  3651                                  ; where <command> may contain references of the form %<variable>, which are
  3652                                  ; later substituted with the items in <list>. The for-loop structure is
  3653                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3654                                  ; <command> once for each item in <list>. All of the information needed for
  3655                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3656                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3657                                  ; a complete copy of the original command-line structure as parsed by
  3658                                  ; 'parseline', loop control variables, and a dma buffer for the
  3659                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3660                                  ; processing has completed, this chunk of memory is returned to the system.
  3661                                  ;
  3662                                  ;   All of the previously defined variables, in 'datares', used for loop
  3663                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3664                                  ;
  3665                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3666                                  ; containing all of the other error messages.
  3667                                  ;
  3668                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3669                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3670                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3671                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3672                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3673                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3674                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3675                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3676                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3677                                  ; instead of
  3678                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3679                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3680                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3681                                  ; doesn't matter whether we put brackets around the location or not -- the
  3682                                  ; assembler is "smart" enough to know that we want an address instead of the
  3683                                  ; contents of that location.
  3684                                  ;
  3685                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3686                                  ; One method would be to have a link field in each for-structure pointing to
  3687                                  ; its parent.  Variable references that couldn't be resolved in the local
  3688                                  ; frame would cause a search of prior frames. For-structures would still be
  3689                                  ; allocated and released in exactly the same fashion. The only limit on the
  3690                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3691                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3692                                  ; maintained in the resident data area. This structure would be an array of
  3693                                  ; control-variable names and pointers to for-structure blocks. This would
  3694                                  ; greatly speed up the resolution of non-local variable references. However,
  3695                                  ; since space in the resident is precious, we would have to compromise on a
  3696                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3697                                  ; allocation and de-allocation would have to be modified slightly to take this
  3698                                  ; new structure into account.
  3699                                  ;
  3700                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3701                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3702                                  ; it may be easier to allocate it as part of 'for_segment'.
  3703                                  ;------
  3704                                  
  3705                                  		; include fordata.asm
  3706                                  
  3707                                  ; Data structure definitions included by tfor.asm
  3708                                  
  3709                                  struc FOR_INFO
  3710 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3711 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
  3712 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3713 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
  3714 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
  3715 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
  3716 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
  3717 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
  3718                                    .size:
  3719                                  endstruc
  3720                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3721                                  
  3722                                  _$FOR_EXIT:
  3723 00000C17 EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3724                                  
  3725                                  ; ---------------------------------------------------------------------------
  3726                                  
  3727                                  FORPROC:
  3728 00000C19 A1FC0B                  		mov	ax,word [FORPTR]
  3729 00000C1C 8ED8                    		mov	ds,ax
  3730 00000C1E 8EC0                    		mov	es,ax		; operate in for-info area
  3731 00000C20 BACB05                  		mov	dx,FOR_INFO.FORDMA
  3732 00000C23 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3733 00000C26 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3734                                  				; DS:DX	-> disk	transfer buffer
  3735                                  FOR_BEGIN:
  3736 00000C28 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3737 00000C2D 7404                    		jz	short FOR_BEGIN1
  3738                                  					; non-zero for_expand equals FALSE
  3739 00000C2F FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3740                                  
  3741                                  FOR_BEGIN1:
  3742 00000C33 8B1E4705                		mov	bx,word [FOR_INFO.FOR_MINARG]
  3743                                  					; current item in <list> to examine
  3744 00000C37 3B1E4905                		cmp	bx,word [FOR_INFO.FOR_MAXARG]	; [549h]
  3745 00000C3B 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3746                                  		;mov	ax,0
  3747 00000C3D B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3748 00000C40 E89718                  		call	ARGV_CALC	; compute argv[x] address
  3749                                  		;mov	cx,[bx+3]
  3750 00000C43 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3751 00000C46 8B17                    		mov	dx,[bx]
  3752                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3753                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3754 00000C48 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3755 00000C4C 7516                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3756 00000C4E 8B37                    		mov	si,[bx]
  3757                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3758                                  
  3759 00000C50 2EA0[F53E]              		mov	al,[cs:LPAREN]
  3760 00000C54 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3761 00000C57 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3762 00000C59 41                      		inc	cx		;  the opening paren as its first char,
  3763                                  					;  the argstartel ptr needs to be
  3764                                  					;  advanced passed it before the prefix
  3765                                  					;  length is computed.
  3766 00000C5A B03A                    		mov	al,':'
  3767 00000C5C 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3768 00000C5F 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3769 00000C61 83C102                  		add	cx,2		;  rest of the prefix as well.
  3770                                  FORSUB:
  3771 00000C64 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3772 00000C66 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3773 00000C6B 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3774                                  		;test	byte [bx+2],2
  3775 00000C6D F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3776 00000C71 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3777                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3778 00000C73 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3779 00000C76 EB1F                    		jmp	short FOR_SMOOSH
  3780                                  
  3781                                  		;nop
  3782                                  FOR_FIND_FIRST:
  3783 00000C78 51                      		push	cx
  3784 00000C79 31C9                    		xor	cx,cx
  3785 00000C7B B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3786 00000C7E CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3787                                  				; CX = search attributes
  3788                                  				; DS:DX	-> ASCIZ filespec
  3789                                  				; (drive,path, and wildcards allowed)
  3790 00000C80 59                      		pop	cx
  3791 00000C81 EB05                    		jmp	short FOR_RESULT
  3792                                  
  3793                                  		;nop
  3794                                  FOR_FIND_NEXT:
  3795 00000C83 B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3796 00000C86 CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3797                                  				; [DTA]	= data block from
  3798                                  				; last AH = 4Eh/4Fh call
  3799                                  FOR_RESULT:
  3800 00000C88 B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3801 00000C8B 7203                    		jc	short FOR_CHECK
  3802 00000C8D B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3803                                  FOR_CHECK:				; record success of findfirst/next
  3804 00000C90 A34505                  		mov	word [FOR_INFO.FOR_EXPAND],ax
  3805 00000C93 09C0                    		or	ax,ax	; anything out there?
  3806 00000C95 7591                    		jnz	short FOR_BEGIN	; if not, try next arg
  3807                                  FOR_SMOOSH:
  3808                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3809 00000C97 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3810 00000C99 BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3811 00000C9C F3A4                    		rep movsb		; arg, some days just the path prefix
  3812                                  					
  3813 00000C9E 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3814                                  					; if we're not expanding, we can
  3815 00000CA3 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3816                                  
  3817                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3818 00000CA5 BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3819                                  FOR_MORE:
  3820 00000CA8 803C00                  		cmp	byte [si],0	; tack on matching filename
  3821 00000CAB 7403                    		jz	short FOR_MAKE_COM
  3822 00000CAD A4                      		movsb
  3823 00000CAE 75F8                    		jnz	short FOR_MORE
  3824                                  FOR_MAKE_COM:
  3825 00000CB0 30C0                    		xor	al,al		; tack a null byte onto the end
  3826 00000CB2 AA                      		stosb			; of the substitute string
  3827 00000CB3 31C9                    		xor	cx,cx		; character count for command line
  3828 00000CB5 F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3829 00000CB7 31DB                    		xor	bx,bx		; argpointer
  3830 00000CB9 BF[D240]                		mov	di,COMBUF+2
  3831 00000CBC 8A1E4405                		mov	bl,byte [FOR_INFO.FOR_COM_START] ; argindex
  3832 00000CC0 8A364B06                		mov	dh,byte [FOR_INFO.FOR_VAR] 
  3833                                  					; %<for-var> is replaced by [forbuf]
  3834 00000CC4 0E                      		push	cs		; time to form the <command> string
  3835 00000CC5 07                      		pop	es
  3836                                  		;assume ES:trangroup
  3837                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3838 00000CC6 B80000                  		mov	ax,0		; translate offset to pointer
  3839 00000CC9 E80E18                  		call	ARGV_CALC
  3840                                  		;mov	si,[bx+9]
  3841 00000CCC 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3842                                  					; mov ptr passed beginning space
  3843 00000CCF 46                      		inc	si
  3844                                  FOR_MAKE_LOOP:
  3845 00000CD0 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3846 00000CD2 46                      		inc	si
  3847 00000CD3 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3848 00000CD5 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3849 00000CD7 3834                    		cmp	[si],dh		; got the right <variable>?
  3850 00000CD9 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3851 00000CDB 46                      		inc	si		; skip over <for-variable>
  3852                                  
  3853 00000CDC 56                      		push	si
  3854 00000CDD BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3855                                  					; to make a final <command> to execute
  3856                                  SLOOP:					
  3857 00000CE0 AC                      		lodsb			; grab all those <item> bytes, and
  3858 00000CE1 AA                      		stosb			; add 'em to the <command> string,
  3859 00000CE2 08C0                    		or	al,al		; until we run into a null
  3860 00000CE4 E0FA                    		loopne	SLOOP
  3861 00000CE6 4F                      		dec	di		; adjust length and <command> pointer
  3862 00000CE7 41                      		inc	cx		; so we can overwrite the null
  3863 00000CE8 5E                      		pop	si
  3864 00000CE9 EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3865                                  
  3866                                  FOR_STOSB:
  3867 00000CEB AA                      		stosb			; take a byte from the <command> arg
  3868 00000CEC 49                      		dec	cx		; and put it into the <command> to be
  3869                                  					; executed (and note length, too)
  3870 00000CED 3C0D                    		cmp	al,0Dh		
  3871 00000CEF 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3872                                  FOR_MADE_COM:
  3873 00000CF1 F6D1                    		not	cl
  3874 00000CF3 2E880E[D140]            		mov	[cs:COMBUF+1],cl
  3875                                  
  3876 00000CF8 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  3877                                  		;assume DS:resgroup
  3878 00000CFD F606EF0B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3879 00000D02 742F                    		jz	short NOECHO3
  3880                                  		;cmp	byte [NULLFLAG],nullcommand
  3881 00000D04 803E040C01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3882 00000D09 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3883                                  
  3884 00000D0B E85E0C                  		call	CRLF2		  ;G  Print out prompt
  3885                                  NO_CRLF_PR:
  3886 00000D0E C606040C00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3887 00000D13 0E                      		push	cs
  3888 00000D14 1F                      		pop	ds
  3889 00000D15 57                      		push	di
  3890 00000D16 E87106                  		call	PRINT_PROMPT	  ;G Prompt the user
  3891 00000D19 5F                      		pop	di
  3892                                  
  3893 00000D1A 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3894 00000D1F C706[4E44][D240]        		mov	word [STRING_PTR_2],COMBUF+2
  3895 00000D25 BA[3F37]                		mov	dx,STRINGBUF2PTR
  3896 00000D28 E8A827                  		call	STD_PRINTF
  3897 00000D2B 26C645FF0D              		mov	byte [es:di-1],0Dh
  3898 00000D30 E977F5                  		jmp	DOCOM		  ; run silent, run deep...
  3899                                  NOECHO3:
  3900 00000D33 C606040C00              		mov	byte [NULLFLAG],0
  3901 00000D38 0E                      		push	cs
  3902 00000D39 1F                      		pop	ds
  3903 00000D3A E970F5                  		jmp	DOCOM1
  3904                                  
  3905                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3906 00000D3D E85B01                  		call	FOROFF
  3907 00000D40 E93E01                  		jmp	FORNESTERR
  3908                                  
  3909                                  ; ---------------------------------------------------------------------------
  3910                                  
  3911                                  FORERRORJ:
  3912 00000D43 E9E3FB                  		jmp	FORERROR
  3913                                  
  3914                                  ; ---------------------------------------------------------------------------
  3915                                  
  3916                                  _$FOR:
  3917 00000D46 8E06[7142]              		mov	es,[RESSEG]
  3918 00000D4A 26803EFB0B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3919 00000D50 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3920                                  
  3921                                  ; Turn off any pipes in progress.
  3922                                  
  3923 00000D52 26803E5D0C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3924 00000D58 7403                    		jz	short NO_PIPE
  3925 00000D5A E8B911                  		call	PIPEDEL
  3926                                  NO_PIPE:
  3927 00000D5D 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3928 00000D5F E80901                  		call	NEXTARG		; move to next argv[n]
  3929 00000D62 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3930 00000D64 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3931 00000D66 75DB                    		jnz	short FORERRORJ
  3932 00000D68 89C5                    		mov	bp,ax		; save forloop variable
  3933 00000D6A AC                      		lodsb
  3934 00000D6B 08C0                    		or	al,al		; and MUST end immediately...
  3935 00000D6D 75D4                    		jnz	short FORERRORJ
  3936 00000D6F E8F900                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3937 00000D72 72CF                    		jb	short FORERRORJ
  3938                                  		;and	ax,0DFDFh
  3939 00000D74 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3940 00000D77 3B06[F93E]              		cmp	ax,word [IN_WORD]
  3941 00000D7B 75C6                    		jnz	short FORERRORJ
  3942 00000D7D AC                      		lodsb
  3943                                  
  3944                                  		; MSDOS 3.3
  3945 00000D7E 08C0                    		or	al,al		; it, too, must end right away
  3946 00000D80 7416                    		jz	short CHECKLPAREN
  3947 00000D82 3A06[F53E]              		cmp	al,[LPAREN]
  3948 00000D86 75BB                    		jnz	short FORERRORJ
  3949                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3950 00000D88 830702                  		add	word [bx],2
  3951                                  		;add	word [bx+9],2
  3952 00000D8B 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3953                                  		;sub	word [bx+5],2
  3954 00000D8F 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3955 00000D93 8B44FF                  		mov	ax,[si-1]
  3956 00000D96 EB05                    		jmp	short LPCHECK
  3957                                  
  3958                                  		; MSDOS 6.0
  3959                                  ;; Compaq bug fix -- exit from this loop on error
  3960                                  ;
  3961                                  ;		or	al,al
  3962                                  ;		jne	forerrorj	; jump on error
  3963                                  ;
  3964                                  ;;;		je	CheckLParen
  3965                                  ;;
  3966                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  3967                                  ;;   FOR %i in(foo bar...
  3968                                  ;; Check for the Lparen here
  3969                                  ;;
  3970                                  ;;;		CMP	AL,lparen
  3971                                  ;;;		JNZ	forerrorj
  3972                                  ;;
  3973                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  3974                                  ;; being there in the first place.
  3975                                  ;;
  3976                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  3977                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  3978                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  3979                                  ;;
  3980                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  3981                                  ;; current value.
  3982                                  ;;
  3983                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  3984                                  ;;;		jmp	short lpcheck
  3985                                  ;;
  3986                                  ;; end of Compaq bug fix
  3987                                  
  3988                                  ; ---------------------------------------------------------------------------
  3989                                  
  3990                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3991                                  CHECKLPAREN:
  3992 00000D98 E8D000                  		call	NEXTARG		; lparen delimits beginning of <list>
  3993 00000D9B 72A6                    		jc	short FORERRORJ
  3994                                  LPCHECK:
  3995 00000D9D 3A06[F53E]              		cmp	al,[LPAREN]
  3996 00000DA1 75A0                    		jne	short FORERRORJ
  3997 00000DA3 80FC00                  		cmp	ah,0
  3998 00000DA6 7411                    		je	short FOR_PAREN_TOKEN
  3999 00000DA8 3A26[F63E]              		cmp	ah,byte [RPAREN] ; special case:  null list	
  4000 00000DAC 7503                    		jne	short FOR_LIST_NOT_EMPTY
  4001 00000DAE E932FE                  		jmp	FORTERM
  4002                                  FOR_LIST_NOT_EMPTY:
  4003                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4004 00000DB1 FF07                    		inc	word [bx]	; Advance ptr past "("
  4005                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4006 00000DB3 FF4F05                  		dec	word [bx+ARGV_ELE.arglen] 	;  to agree.
  4007 00000DB6 46                      		inc	si		; Inc si so check for ")" works
  4008 00000DB7 EB11                    		jmp	short FOR_LIST
  4009                                  
  4010                                  		;nop
  4011                                  FOR_PAREN_TOKEN:
  4012 00000DB9 E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4013 00000DBC 7285                    		jc	short FORERRORJ
  4014                                  		;cmp	ax,[RPAREN+1]	
  4015 00000DBE 3B06[F73E]              		cmp	ax,[NULLRPAREN]	; special case:  null list
  4016 00000DC2 7506                    		jne	short FOR_LIST
  4017 00000DC4 E91CFE                  		jmp	FORTERM
  4018                                  
  4019                                  FORERORJJ:
  4020 00000DC7 E95FFB                  		jmp	FORERROR
  4021                                  
  4022                                  FOR_LIST:				; skip over rest of <list>
  4023 00000DCA 89D1                    		mov	cx,dx		; first arg of <list>
  4024                                  
  4025                                  SKIP_LIST:
  4026                                  		;add	si,[bx+5]
  4027 00000DCC 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4028 00000DCF 83EE03                  		sub	si,3		; si = ptr to last char of token
  4029 00000DD2 A0[F63E]                		mov	al,byte [RPAREN]
  4030 00000DD5 3804                    		cmp	[si],al		; Is this the last element in <list>
  4031 00000DD7 7407                    		je	short FOR_END_LIST ; Yes, exit loop.
  4032 00000DD9 E88F00                  		call	NEXTARG		; No, get next arg <list>
  4033 00000DDC 72E9                    		jc	short FORERORJJ	; If no more and no rparen, error.
  4034 00000DDE EBEC                    		jmp	short SKIP_LIST
  4035                                  
  4036                                  FOR_END_LIST:
  4037 00000DE0 89D7                    		mov	di,dx		; record position of last arg in <list>
  4038 00000DE2 C60400                  		mov	byte [si],0	; Zap the rparen
  4039                                  		;cmp	ax,[RPAREN+1]	
  4040 00000DE5 3B06[F73E]              		cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4041 00000DE9 7401                    		je	short FOR_DO	; Yes, continue
  4042 00000DEB 47                      		inc	di		; No, inc position of last arg
  4043                                  FOR_DO:
  4044 00000DEC E87C00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4045 00000DEF 72D6                    		jc	short FORERORJJ
  4046                                  		;and	ax,0DFDFh	
  4047 00000DF1 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4048 00000DF4 3B06[FB3E]              		cmp	ax,word [DO_WORD]
  4049 00000DF8 75CD                    		jne	short FORERORJJ
  4050 00000DFA AC                      		lodsb
  4051 00000DFB 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4052 00000DFD 75C8                    		jnz	short FORERORJJ
  4053                                  		
  4054 00000DFF E86900                  		call	NEXTARG		; on to the beginning of <command>
  4055 00000E02 72C3                    		jc	short FORERORJJ	; null <command> not legal
  4056                                  
  4057 00000E04 50                      		push	ax
  4058 00000E05 53                      		push	bx
  4059 00000E06 51                      		push	cx
  4060 00000E07 52                      		push	dx		; preserve registers against disaster
  4061 00000E08 57                      		push	di
  4062 00000E09 56                      		push	si
  4063 00000E0A 55                      		push	bp
  4064 00000E0B E852F8                  		call	FREE_TPA	; need to make free memory, first
  4065 00000E0E E88A00                  		call	FOROFF
  4066                                  		;mov	bx,264
  4067 00000E11 BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4068 00000E14 E8A519                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4069 00000E17 9C                      		pushf
  4070 00000E18 26A3FC0B                		mov	word [es:FORPTR],ax
  4071 00000E1C E851F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4072 00000E1F 9D                      		popf
  4073 00000E20 5D                      		pop	bp
  4074 00000E21 5E                      		pop	si
  4075 00000E22 5F                      		pop	di
  4076 00000E23 5A                      		pop	dx
  4077 00000E24 59                      		pop	cx
  4078 00000E25 5B                      		pop	bx
  4079 00000E26 58                      		pop	ax
  4080 00000E27 723C                    		jc	short FOR_ALLOC_ERR
  4081                                  
  4082 00000E29 06                      		push	es		; save resgroup seg...
  4083 00000E2A 26FF36FC0B              		push	word [es:FORPTR]
  4084 00000E2F 07                      		pop	es
  4085                                  		;assume ES:for_segment	
  4086 00000E30 49                      		dec	cx		; forproc wants min pointing before
  4087 00000E31 4F                      		dec	di		; first arg, max right at last one
  4088 00000E32 26890E4705              		mov	word [es:FOR_INFO.FOR_MINARG],cx
  4089 00000E37 26893E4905              		mov	word [es:FOR_INFO.FOR_MAXARG],di
  4090 00000E3C 2688164405              		mov	byte [es:FOR_INFO.FOR_COM_START],dl
  4091 00000E41 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4092 00000E48 89E8                    		mov	ax,bp
  4093 00000E4A 2688264B06              		mov	byte [es:FOR_INFO.FOR_VAR],ah
  4094 00000E4F 07                      		pop	es
  4095                                  		;assume ES:resgroup	
  4096 00000E50 26FE06FB0B              		inc	byte [es:FORFLAG]
  4097 00000E55 26833EF50BFF            		cmp	word [es:SINGLECOM],-1
  4098 00000E5B 7507                    		jne	short FOR_RET
  4099 00000E5D 26C706F50B00FF          		mov	word [es:SINGLECOM],0FF00h
  4100                                  FOR_RET:
  4101 00000E64 C3                      		retn
  4102                                  
  4103                                  FOR_ALLOC_ERR:
  4104                                  		; MSDOS 3.0
  4105 00000E65 BA[AA3C]                		mov	dx,INSFMEMMESPTR
  4106 00000E68 E9BE0D                  		jmp	CERROR
  4107                                  
  4108                                  		; MSDOS 6.0
  4109                                  		;mov	msg_disp_class,ext_msg_class	
  4110                                  		;			;AN000; set up extended error msg class
  4111                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4112                                  		;			;AC000; get extended message pointer
  4113                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4114                                  		;			;AN000; get message number in control block
  4115                                  		;jmp	cerror
  4116                                  
  4117                                  
  4118                                  ; =============== S U B	R O U T	I N E =======================================
  4119                                  
  4120                                  NEXTARG:
  4121 00000E6B 42                      		inc	dx		; next argv[n]
  4122                                  		;cmp	dx,[ARG_ARGVCNT]
  4123 00000E6C 3B16[6948]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4124 00000E70 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4125 00000E72 89D3                    		mov	bx,dx
  4126                                  		;mov	ax,ARG_ARGV
  4127                                  		;mov	ax,ARG+ARG_UNIT.argv
  4128 00000E74 B8[A945]                		mov	ax,ARG
  4129 00000E77 E86016                  		call	ARGV_CALC	; convert array index to pointer
  4130 00000E7A 8B37                    		mov	si,[bx]		; load pointer to argstring
  4131                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4132 00000E7C AD                      		lodsw			; and load first two chars
  4133 00000E7D F8                      		clc
  4134 00000E7E C3                      		retn
  4135                                  NEXTARG_ERR:
  4136 00000E7F F9                      		stc
  4137 00000E80 C3                      		retn
  4138                                  
  4139                                  ; ---------------------------------------------------------------------------
  4140                                  
  4141                                  FORNESTERR:
  4142 00000E81 1E                      		push	ds
  4143 00000E82 8E1E[7142]              		mov	ds,[RESSEG]
  4144                                  		;ASSUME DS:RESGROUP
  4145 00000E86 BA[923C]                		mov	dx,FORNESTMESTR
  4146 00000E89 813EF50B00FF            		cmp	word [SINGLECOM],0FF00h
  4147 00000E8F 7506                    		jnz	short NOFORP3
  4148 00000E91 C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4149                                  NOFORP3:
  4150 00000E97 1F                      		pop	ds
  4151 00000E98 E98E0D                  		jmp	CERROR
  4152                                  
  4153                                  ; =============== S U B	R O U T	I N E =======================================
  4154                                  
  4155                                  ; General routine called to free the for segment. We also clear the forflag
  4156                                  ; too. Change no registers.
  4157                                  
  4158                                  FOROFF:
  4159 00000E9B 50                      		push	ax
  4160 00000E9C 06                      		push	es
  4161 00000E9D 2E8E06[7142]            		mov	es,[cs:RESSEG]
  4162 00000EA2 26A1FC0B                		mov	ax,word [es:FORPTR]
  4163 00000EA6 09C0                    		or	ax,ax
  4164 00000EA8 7408                    		jz	short FREEDONE
  4165 00000EAA 06                      		push	es
  4166 00000EAB 8EC0                    		mov	es,ax
  4167 00000EAD B449                    		mov	ah,DEALLOC ; 49h
  4168 00000EAF CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4169                                  				; ES = segment address of area to be freed
  4170 00000EB1 07                      		pop	es
  4171                                  FREEDONE:
  4172 00000EB2 26C706FC0B0000          		mov	word [es:FORPTR],0
  4173 00000EB9 26C606FB0B00            		mov	byte [es:FORFLAG],0
  4174 00000EBF 07                      		pop	es
  4175 00000EC0 58                      		pop	ax
  4176 00000EC1 C3                      		retn
  4177                                  
  4178                                  ;============================================================================
  4179                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4180                                  ;============================================================================
  4181                                  ; 09/10/2018 - Retro DOS v3.0
  4182                                  
  4183                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4184                                  
  4185                                  ; ---------------------------------------------------------------------------
  4186                                  
  4187                                  ; The DIR command displays the contents of a directory.
  4188                                  ;
  4189                                  ; ****************************************************************
  4190                                  ; *
  4191                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4192                                  ; *
  4193                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4194                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4195                                  ; *		 If an error occurs issue and error message and
  4196                                  ; *		 transfer control to CERROR.
  4197                                  ; *
  4198                                  ; * INPUT:	 command line at offset 81H
  4199                                  ; *
  4200                                  ; * OUTPUT:	 none
  4201                                  ; *
  4202                                  ; ****************************************************************
  4203                                  
  4204                                  CATALOG:
  4205                                  		; MSDOS 3.3
  4206                                  
  4207                                  		;mov	ax,ARG_ARGV
  4208                                  		;mov	ax,ARG+ARG_UNIT.argv
  4209 00000EC2 B8[A945]                		mov	ax,ARG
  4210 00000EC5 BAFFFF                  		mov	dx,0FFFFh
  4211 00000EC8 31C9                    		xor	cx,cx
  4212 00000ECA 31F6                    		xor	si,si
  4213                                  
  4214                                  DIR1:
  4215                                  		;cmp	cx,[ARG_ARGVCNT]
  4216 00000ECC 3B0E[6948]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4217 00000ED0 733F                    		jnb	short DIR6 ; No more arguments
  4218 00000ED2 89CB                    		mov	bx,cx
  4219 00000ED4 E80316                  		call	ARGV_CALC
  4220                                  		;or	si,[bx+7]
  4221 00000ED7 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4222 00000EDA F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4223 00000EDE 7508                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4224                                  		;test	byte [bx+2],1
  4225 00000EE0 F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4226 00000EE4 7408                    		jz	short DIR3
  4227 00000EE6 EB26                    		jmp	short DIR5
  4228                                  DIR2:
  4229 00000EE8 BA[223A]                		mov	dx,BADPARMPTR
  4230 00000EEB E93B0D                  		jmp	CERROR
  4231                                  DIR3:
  4232 00000EEE 09C9                    		or	cx,cx
  4233 00000EF0 7515                    		jnz	short DIR4	
  4234                                  		;cmp	word [bx+5],3
  4235 00000EF2 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4236 00000EF6 7416                    		jz	short DIR5
  4237                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4238 00000EF8 830703                  		add	word [bx],3
  4239                                  		;add	word [bx+9],3
  4240 00000EFB 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4241                                  		;add	word [bx+3],3
  4242 00000EFF 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4243                                  		;sub	word [bx+5],3
  4244 00000F03 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4245                                  DIR4:
  4246 00000F07 83FAFF                  		cmp	dx,0FFFFh
  4247 00000F0A 75DC                    		jnz	short DIR2
  4248 00000F0C 89DA                    		mov	dx,bx
  4249                                  
  4250 00000F0E 41                      DIR5:		inc	cx
  4251 00000F0F EBBB                    		jmp	short DIR1
  4252                                  DIR6:
  4253 00000F11 8936[8842]              		mov	[COMSW],si
  4254 00000F15 52                      		push	dx
  4255 00000F16 30C0                    		xor	al,al
  4256 00000F18 83FAFF                  		cmp	dx,0FFFFh
  4257 00000F1B 7410                    		jz	short DIR7
  4258 00000F1D 89D3                    		mov	bx,dx
  4259                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4260 00000F1F 8B3F                    		mov	di,[bx]
  4261 00000F21 807D013A                		cmp	byte [di+1],':'
  4262 00000F25 7506                    		jnz	short DIR7
  4263 00000F27 8A05                    		mov	al,[di]
  4264 00000F29 0C20                    		or	al,20h		; Lowercase drive name	
  4265 00000F2B 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4266                                  DIR7:
  4267                                  		;mov	[5CH],al
  4268 00000F2D A25C00                  		mov	[FCB],al
  4269 00000F30 E80A04                  		call	OKVOLARG
  4270 00000F33 B03F                    		mov	al,'?'		; *.* is default file spec.
  4271                                  		;mov	di,5Dh
  4272 00000F35 BF5D00                  		mov	di,FCB+1
  4273 00000F38 B90B00                  		mov	cx,11
  4274 00000F3B F3AA                    		rep stosb
  4275                                  
  4276                                  ; Begin by processing any switches that may have been specified.
  4277                                  ; BITS will contain any information about switches that was
  4278                                  ; found when the command line was parsed.
  4279                                  
  4280 00000F3D A1[8842]                		mov	ax,[COMSW]	; Get switches from command
  4281 00000F40 A3[BC43]                		mov	word [_BITS],ax	; initialize switches
  4282 00000F43 C706[8842]0000          		mov	word [COMSW],0	; initialize flags
  4283 00000F49 C606[C443]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4284                                  		;test	al,1
  4285 00000F4E A801                    		test	al,SWITCHW	; /W ?
  4286                                  		;mov	al,1
  4287 00000F50 B001                    		mov	al,NORMPERLIN
  4288 00000F52 7402                    		jz	short DIR8
  4289                                  		;mov	al,5
  4290 00000F54 B005                    		mov	al,WIDEPERLIN
  4291                                  DIR8:
  4292 00000F56 A2[9842]                		mov	[LINLEN],al	; Set number of entries per line
  4293 00000F59 A2[9742]                		mov	[LINCNT],al
  4294 00000F5C C706[9942]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4295 00000F62 BA[6A43]                		mov	dx,DIRBUF
  4296 00000F65 B41A                    		mov	ah,SET_DMA ; 1Ah
  4297 00000F67 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4298                                  				; DS:DX	-> disk	transfer buffer
  4299                                  		;mov	dl,[5Ch]
  4300 00000F69 8A165C00                		mov	dl,[FCB]
  4301 00000F6D E8D609                  		call	SAVUDIR
  4302 00000F70 5B                      		pop	bx
  4303 00000F71 83FBFF                  		cmp	bx,0FFFFh
  4304 00000F74 7415                    		jz	short DIR9
  4305                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4306 00000F76 8B17                    		mov	dx,[bx]
  4307                                  
  4308                                  ; The user may have specified a device. Search for the path and see if the
  4309                                  ; attributes indicate a device.
  4310                                  
  4311 00000F78 B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4312 00000F7A CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4313                                  				; CX = search attributes
  4314                                  				; DS:DX	-> ASCIZ filespec
  4315                                  				; (drive,path, and wildcards allowed)
  4316 00000F7C 720F                    		jc	short DIR10
  4317                                  				; Check device atrribute..
  4318                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4319                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4320                                  		; 14/10/2018
  4321                                  		;test	byte [DIRBUF+21],40h
  4322 00000F7E F606[7F43]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4323 00000F83 7408                    		jz	short DIR10	; no, go do normal operation
  4324 00000F85 C706[8842]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4325                                  DIR9:
  4326 00000F8B EB7B                    		jmp	short DOHEADER
  4327                                  DIR10:
  4328                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4329 00000F8D 8B17                    		mov	dx,[bx]
  4330 00000F8F B43B                    		mov	ah,CHDIR ; 3Bh
  4331 00000F91 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4332                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4333 00000F93 7373                    		jnc	short DOHEADER
  4334                                  		;mov	si,[bx+3]
  4335 00000F95 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4336 00000F98 39F2                    		cmp	dx,si
  4337 00000F9A 7449                    		jz	short DIR_NO_DRIVE
  4338 00000F9C 30C9                    		xor	cl,cl
  4339 00000F9E 860C                    		xchg	cl,[si]
  4340 00000FA0 B43B                    		mov	ah,CHDIR ; 3Bh
  4341 00000FA2 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4342                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4343 00000FA4 860C                    		xchg	cl,[si]
  4344 00000FA6 733D                    		jnc	short DIR_NO_DRIVE
  4345 00000FA8 8A44FF                  		mov	al,[si-1]
  4346 00000FAB E85E0A                  		call	PATHCHRCMP
  4347 00000FAE 7514                    		jnz	short DIR11
  4348 00000FB0 8A44FE                  		mov	al,[si-2]
  4349 00000FB3 E8560A                  		call	PATHCHRCMP
  4350 00000FB6 741E                    		jz	short DIR12
  4351 00000FB8 864CFF                  		xchg	cl,[si-1]
  4352 00000FBB B43B                    		mov	ah,CHDIR ; 3Bh
  4353 00000FBD CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4354                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4355 00000FBF 864CFF                  		xchg	cl,[si-1]
  4356 00000FC2 7321                    		jnc	short DIR_NO_DRIVE
  4357                                  DIR11:
  4358 00000FC4 B53A                    		mov	ch,':'
  4359 00000FC6 3A6CFF                  		cmp	ch,[si-1]
  4360 00000FC9 750B                    		jnz	short DIR12
  4361                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4362 00000FCB 8B0F                    		mov	cx,[bx]
  4363 00000FCD 87CE                    		xchg	cx,si
  4364 00000FCF 29F1                    		sub	cx,si
  4365 00000FD1 83F902                  		cmp	cx,2
  4366 00000FD4 740F                    		jz	short DIR_NO_DRIVE
  4367                                  DIR12:
  4368 00000FD6 BA[763B]                		mov	dx,BADCDPTR
  4369                                  		;test	byte [bx+2],4
  4370 00000FD9 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4371 00000FDD 7503                    		jnz	short DIRERROR
  4372                                  DIRNF:
  4373 00000FDF BA[F837]                		mov	dx,FNOTFOUNDPTR
  4374                                  DIRERROR:
  4375 00000FE2 E9440C                  		jmp	CERROR
  4376                                  DIR_NO_DRIVE:
  4377 00000FE5 813C2E2E                		cmp	word [si],'..'
  4378 00000FE9 750C                    		jnz	short DOREALPARSE
  4379 00000FEB 807C0200                		cmp	byte [si+2],0
  4380 00000FEF 7506                    		jnz	short DOREALPARSE
  4381 00000FF1 FF06[8842]              		inc	word [COMSW]
  4382 00000FF5 EB11                    		jmp	short DOHEADER
  4383                                  DOREALPARSE:
  4384 00000FF7 BF5C00                  		mov	di,FCB ; 5Ch	
  4385                                  		;mov	ax,290Eh
  4386 00000FFA B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4387 00000FFD CD21                    		int	21h	; DOS -	PARSE FILENAME
  4388                                  				; DS:SI	-> string to parse
  4389                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4390                                  				; AL = bit mask	to control parsing
  4391 00000FFF 803C00                  		cmp	byte [si],0
  4392 00001002 7404                    		jz	short DOHEADER
  4393 00001004 FF0E[8842]              		dec	word [COMSW]
  4394                                  DOHEADER:
  4395                                  
  4396                                  ; Display the header
  4397                                  
  4398 00001008 53                      		push	bx
  4399 00001009 E84804                  		call	BUILD_DIR_STRING
  4400 0000100C BA[6A43]                		mov	dx,DIRBUF
  4401 0000100F 8916[6544]              		mov	[VOL_DIR],dx
  4402 00001013 BA[FF3B]                		mov	dx,DIRHEADPTR
  4403 00001016 E8AA24                  		call	PRINTF_CRLF
  4404 00001019 5B                      		pop	bx
  4405 0000101A 83FBFF                  		cmp	bx,0FFFFh
  4406 0000101D 7417                    		jz	short DOSEARCH
  4407                                  
  4408                                  ; If there were chars left after parse or device, then invalid file name
  4409                                  
  4410 0000101F 833E[8842]00            		cmp	word [COMSW],0
  4411 00001024 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4412 00001026 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4413 00001028 E87008                  		call	RESTUDIR
  4414 0000102B BA[763B]                		mov	dx,BADCDPTR
  4415 0000102E E9F80B                  		jmp	CERROR		; was .. => error directory not found
  4416                                  DIRNFFIX:
  4417 00001031 E86708                  		call	RESTUDIR
  4418 00001034 EBA9                    		jmp	short DIRNF
  4419                                  
  4420                                  ; We are assured that everything is correct. Let's go and search. Use
  4421                                  ; attributes that will include finding directories. Perform the first search
  4422                                  ; and reset our directory afterward.
  4423                                  
  4424                                  DOSEARCH:
  4425                                  		;mov	byte [55h],0FFh
  4426 00001036 C6065500FF              		mov	byte [FCB-7],0FFh
  4427                                  		;mov	byte [5Bh],10h
  4428 0000103B C6065B0010              		mov	byte [FCB-1],10h
  4429                                  
  4430                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4431                                  ; the directory information as an extended FCB. We must bias all fetches into
  4432                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4433                                  
  4434 00001040 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4435 00001042 BA5500                  		mov	dx,FCB-7 ; 55h
  4436 00001045 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4437                                  				; DS:DX	-> FCB
  4438                                  
  4439                                  ; Restore the user's directory. We preserve, though, the return from the
  4440                                  ; previous system call for later checking.
  4441                                  
  4442                                  FOUND_FIRST_FILE:
  4443 00001047 50                      		push	ax		; save return state
  4444 00001048 E85008                  		call	RESTUDIR	; restore user's dir	
  4445 0000104B 58                      		pop	ax		; get return state back
  4446                                  
  4447                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4448                                  ; no more.
  4449                                  
  4450                                  DIRSTART:
  4451 0000104C FEC0                    		inc	al		; 0FFh = file not found
  4452 0000104E 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4453 00001050 E9D200                  		jmp	CHKCNT
  4454                                  DISPLAY:
  4455 00001053 FF06[9942]              		inc	word [FILECNT]	; Keep track of how many we find
  4456 00001057 BE[7243]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4457                                  		;call	SHONAME
  4458 0000105A E80C01                  		call	DISPLAYNAME
  4459                                  		;test	byte [_BITS],1
  4460 0000105D F606[BC43]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4461 00001062 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4462 00001064 E98800                  		jmp	NEXENT
  4463                                  DIRTEST:
  4464                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4465                                  		; 14/10/2018
  4466                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4467                                  		;test	byte [DIRBUF+19],10h
  4468 00001067 F606[7D43]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4469 0000106C 7408                    		jz	short FILEENT
  4470 0000106E BA[F83A]                		mov	dx,DMESPTR
  4471 00001071 E85F24                  		call	STD_PRINTF
  4472 00001074 EB16                    		jmp	short NOFSIZ
  4473                                  FILEENT:
  4474                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4475                                  		;mov	dx,[DIRBUF+36]
  4476 00001076 8B16[8E43]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4477 0000107A 8916[4A44]              		mov	[FILESIZE_L],dx
  4478                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4479                                  		;mov	dx,[DIRBUF+38]
  4480 0000107E 8B16[9043]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4481 00001082 8916[4C44]              		mov	[FILESIZE_H],dx
  4482 00001086 BA[3637]                		mov	dx,FSIZEMESPTR
  4483 00001089 E84724                  		call	STD_PRINTF	; Print size of file
  4484                                  NOFSIZ:
  4485                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4486                                  		;mov	ax,[DIRBUF+32]
  4487 0000108C A1[8A43]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4488 0000108F 09C0                    		or	ax,ax
  4489 00001091 745C                    		jz	short NEXENT	; Skip if no date
  4490 00001093 BF[9B42]                		mov	di,CHARBUF
  4491 00001096 50                      		push	ax
  4492 00001097 B82020                  		mov	ax,'  '
  4493 0000109A AB                      		stosw
  4494 0000109B 58                      		pop	ax
  4495 0000109C 89C3                    		mov	bx,ax
  4496 0000109E 83E01F                  		and	ax,1Fh		; Get day
  4497 000010A1 88C2                    		mov	dl,al
  4498 000010A3 89D8                    		mov	ax,bx
  4499 000010A5 B105                    		mov	cl,5
  4500 000010A7 D3E8                    		shr	ax,cl		; Align month
  4501 000010A9 240F                    		and	al,0Fh		; Get month
  4502 000010AB 88C6                    		mov	dh,al
  4503 000010AD 88F9                    		mov	cl,bh
  4504 000010AF D0E9                    		shr	cl,1		; Align year
  4505 000010B1 30ED                    		xor	ch,ch
  4506 000010B3 83C150                  		add	cx,80		; Relative 1980
  4507 000010B6 80F964                  		cmp	cl,100
  4508 000010B9 7203                    		jb	short MILLENIUM
  4509 000010BB 80E964                  		sub	cl,100
  4510                                  MILLENIUM:
  4511 000010BE E8DB0F                  		call	DATE_CXDX
  4512                                  		;mov	cx,[DIRBUF_FTIME]
  4513                                  		;mov	cx,[DIRBUF+30]
  4514 000010C1 8B0E[8843]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4515 000010C5 E318                    		jcxz	PRBUF		; Time field present?
  4516 000010C7 B82020                  		mov	ax,2020h
  4517 000010CA AB                      		stosw
  4518 000010CB D1E9                    		shr	cx,1
  4519 000010CD D1E9                    		shr	cx,1
  4520 000010CF D1E9                    		shr	cx,1
  4521 000010D1 D0E9                    		shr	cl,1
  4522 000010D3 D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4523 000010D5 8A1E[094D]              		mov	bl,[TIME_24]
  4524 000010D9 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4525 000010DC E87011                  		call	P_TIME		; Don't care about DX, never used with DIR
  4526                                  PRBUF:
  4527 000010DF 31C0                    		xor	ax,ax
  4528 000010E1 AA                      		stosb
  4529 000010E2 BA[9B42]                		mov	dx,CHARBUF
  4530 000010E5 8916[4E44]              		mov	[STRING_PTR_2],dx
  4531 000010E9 BA[3F37]                		mov	dx,STRINGBUF2PTR
  4532 000010EC E8E423                  		call	STD_PRINTF
  4533                                  NEXENT:
  4534 000010EF FE0E[9742]              		dec	byte [LINCNT]
  4535 000010F3 7520                    		jnz	short SAMLIN
  4536                                  NEXLIN:
  4537 000010F5 A0[9842]                		mov	al,[LINLEN]
  4538 000010F8 A2[9742]                		mov	[LINCNT],al
  4539 000010FB E86E08                  		call	CRLF2
  4540 000010FE FE0E[C443]              		dec	byte [LINPERPAG]
  4541 00001102 7517                    		jnz	short SCROLL
  4542                                  		;test	byte [_BITS],2
  4543 00001104 F606[BC43]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4544 00001109 7410                    		jz	short SCROLL	; If not, just continue
  4545 0000110B C606[C443]17            		mov	byte [LINPERPAG],23
  4546 00001110 E87900                  		call	PAUSE
  4547 00001113 EB06                    		jmp	short SCROLL
  4548                                  SAMLIN:
  4549 00001115 BA[4537]                		mov	dx,TABPTR	; Output a tab
  4550 00001118 E8B823                  		call	STD_PRINTF
  4551                                  SCROLL:
  4552 0000111B B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4553                                  		;mov	dx,55h
  4554 0000111D BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4555 00001120 CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4556                                  				; DS:DX	-> FCB
  4557                                  				; Return: AL = status
  4558 00001122 E927FF                  		jmp	DIRSTART
  4559                                  CHKCNT:
  4560 00001125 F706[9942]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4561 0000112B 7503                    		jnz	short TRAILER
  4562 0000112D E9AFFE                  		jmp	DIRNF
  4563                                  TRAILER:
  4564 00001130 A0[9842]                		mov	al,[LINLEN]
  4565 00001133 3A06[9742]              		cmp	al,[LINCNT]
  4566 00001137 7403                    		jz	short MMESSAGE
  4567 00001139 E83008                  		call	CRLF2
  4568                                  MMESSAGE:
  4569 0000113C BA[0F39]                		mov	dx,DIRMESPTR
  4570 0000113F 8B36[9942]              		mov	si,[FILECNT]
  4571 00001143 8936[5744]              		mov	[DIR_NUM],si
  4572 00001147 E88923                  		call	STD_PRINTF
  4573                                  DTFREE:
  4574 0000114A B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4575                                  		;mov	dl,[5Ch]
  4576 0000114C 8A165C00                		mov	dl,[FCB]
  4577 00001150 CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4578                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4579 00001152 83F8FF                  		cmp	ax,-1
  4580 00001155 7501                    		jnz	short DTFREE1
  4581                                  DTRET:
  4582 00001157 C3                      		retn
  4583                                  DTFREE1:
  4584 00001158 F7E1                    		mul	cx
  4585 0000115A F7E3                    		mul	bx
  4586 0000115C A3[5944]                		mov	[BYTES_FREE],ax
  4587 0000115F 8916[5B44]              		mov	[BYTES_FREE+2],dx
  4588 00001163 BA[2539]                		mov	dx,BYTEMESPTR
  4589 00001166 E96A23                  		jmp	STD_PRINTF
  4590                                  
  4591                                  
  4592                                  	; MSDOS 6.0
  4593                                  ;CATALOG:
  4594                                  
  4595                                  ;;
  4596                                  ;; Set up DTA for dir search firsts
  4597                                  ;;
  4598                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4599                                  ;	mov	ah,Set_DMA			;AC000;
  4600                                  ;	int	int_command			;AC000;
  4601                                  ;;
  4602                                  ;; Set up defaults for switches and parse the command line.
  4603                                  ;;
  4604                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4605                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4606                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4607                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4608                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4609                                  ;	stosb					;AN000;
  4610                                  ;	mov	al,end_of_line_in		;AN000;
  4611                                  ;	stosb					;AN000;
  4612                                  ;	mov	si,81H				;AN000; Get command line
  4613                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
  4614                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4615                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4616                                  ;	mov	bits,cx 			;AC000; initialize switches
  4617                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4618                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4619                                  ;	mov	lincnt,normperlin		;AC000;
  4620                                  ;
  4621                                  ;dirscan:
  4622                                  ;	xor	dx,dx				;AN000;
  4623                                  ;	invoke	parse_with_msg			;AC018; call parser
  4624                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4625                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4626                                  ;	jmp	scandone			;AN000; yes - go process
  4627                                  ;
  4628                                  ;dirscan_cont:
  4629                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4630                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4631                                  ;	jmp	badparm 			;AN000; yes - exit
  4632                                  ;
  4633                                  ;dirscan_cont2:
  4634                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4635                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4636                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4637                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4638                                  ;;
  4639                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4640                                  ;;
  4641                                  ;	push	si				;AC000; save position in line
  4642                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4643                                  ;	push	si				;AN000; save address
  4644                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4645                                  ;	pop	dx				;AC000; get address in DX
  4646                                  ;
  4647                                  ;;
  4648                                  ;; The user may have specified a device. Search for the path and see if the
  4649                                  ;; attributes indicate a device.
  4650                                  ;;
  4651                                  ;	mov	ah,Find_First			;AC000; find the file
  4652                                  ;	int	int_command			;AC000;
  4653                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4654                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4655                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4656                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4657                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4658                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4659                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4660                                  ;
  4661                                  ;dir_check_device:				;AN022;
  4662                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4663                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4664                                  ;	mov	ComSw,-2			;AC000; signal device
  4665                                  ;
  4666                                  ;dir_fspec_end:
  4667                                  ;	pop	si				;AC000; restore position in line
  4668                                  ;	jmp	short dirscan			;AC000; keep parsing
  4669                                  ;
  4670                                  ;set_dir_width:
  4671                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4672                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4673                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4674                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4675                                  ;	jmp	badparm 			;AN018; exit
  4676                                  ;
  4677                                  ;ok_set_width:
  4678                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4679                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4680                                  ;	mov	lincnt,wideperlin		;AC000;
  4681                                  ;	jmp	short dirscan			;AC000; keep parsing
  4682                                  ;
  4683                                  ;set_dir_pause:
  4684                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4685                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4686                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4687                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4688                                  ;	jmp	badparm 			;AN018; exit
  4689                                  ;
  4690                                  ;ok_set_pause:
  4691                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4692                                  ;	push	cx				;AN000; save necessary registers
  4693                                  ;	push	si				;AN000;
  4694                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4695                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4696                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4697                                  ;	mov	cl,get_generic			;AN000; get information
  4698                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4699                                  ;	int	int_command			;AN000;
  4700                                  ;
  4701                                  ;lines_set:
  4702                                  ;	dec	linperpag			;AN000; lines per actual page should
  4703                                  ;	dec	linperpag			;AN000;     two less than the max
  4704                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4705                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4706                                  ;	pop	si				;AN000; restore registers
  4707                                  ;	pop	cx				;AN000;
  4708                                  ;	jmp	dirscan 			;AC000; keep parsing
  4709                                  ;
  4710                                  ;;
  4711                                  ;; The syntax is incorrect. Report only message we can.
  4712                                  ;;
  4713                                  ;BadParm:
  4714                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4715                                  ;
  4716                                  ;ScanDone:
  4717                                  ;
  4718                                  ;;
  4719                                  ;; Find and display the volume ID on the drive.
  4720                                  ;;
  4721                                  ;
  4722                                  ;	invoke	okvolarg			;AC000;
  4723                                  ;;
  4724                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4725                                  ;; in the HeadFix routine, after we're done.
  4726                                  ;;
  4727                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4728                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4729                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4730                                  ;
  4731                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4732                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4733                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4734                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4735                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4736                                  ;	mov	si,[desttail]			;AN015; get filename back
  4737                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4738                                  ;
  4739                                  ;DirCheckPath:
  4740                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4741                                  ;	cmp	ax,0				;AN022; Is there a message?
  4742                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4743                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4744                                  ;	jz	doparse 			;AC000; no - no problem
  4745                                  ;	inc	comsw				;AC000; indicate error
  4746                                  ;	jmp	short doheader			;AC000; go print header
  4747                                  ;
  4748                                  ;DirNF:
  4749                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4750                                  ;
  4751                                  ;dir_err_setup:
  4752                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4753                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4754                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4755                                  ;
  4756                                  ;DirError:
  4757                                  ;	jmp	Cerror
  4758                                  ;
  4759                                  ;;
  4760                                  ;; We have changed to something. We also have a file. Parse it into a
  4761                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4762                                  ;; filename alone. We need to special case ... If we are at the root, the
  4763                                  ;; parse will fail and it will give us a file not found instead of file not
  4764                                  ;; found.
  4765                                  ;;
  4766                                  ;DoParse:
  4767                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4768                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4769                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4770                                  ;	lodsw					;AN000; bypass drive
  4771                                  ;
  4772                                  ;dir_no_drive:
  4773                                  ;	cmp	[si],".."
  4774                                  ;	jnz	DoRealParse
  4775                                  ;	cmp	byte ptr [si+2],0
  4776                                  ;	jnz	DoRealParse
  4777                                  ;	inc	ComSw
  4778                                  ;	jmp	short DoHeader
  4779                                  ;
  4780                                  ;DoRealParse:
  4781                                  ;	mov	di,FCB			; where to put the file name
  4782                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4783                                  ;	int	int_command
  4784                                  ;
  4785                                  ;;
  4786                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4787                                  ;; off.	This will be reset in the HEADFIX routine
  4788                                  ;;
  4789                                  ;
  4790                                  ;DoHeader:
  4791                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4792                                  ;
  4793                                  ;;
  4794                                  ;; Display the header
  4795                                  ;;
  4796                                  ;
  4797                                  ;DoHeaderCont:
  4798                                  ;	mov	al,blank			;AN051; Print out a blank
  4799                                  ;	invoke	print_char			;AN051;   before DIR header
  4800                                  ;	invoke	build_dir_string		; get current dir string
  4801                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4802                                  ;	invoke	printf_crlf			; bang!
  4803                                  ;
  4804                                  ;;
  4805                                  ;; If there were chars left after parse or device, then invalid file name
  4806                                  ;;
  4807                                  ;	cmp	ComSw,0
  4808                                  ;	jz	DoSearch			; nothing left; good parse
  4809                                  ;	jl	DirNFFix			; not .. => error file not found
  4810                                  ;	invoke	RestUDir
  4811                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4812                                  ;	jmp	Cerror				; was .. => error directory not found
  4813                                  ;DirNFFix:
  4814                                  ;	invoke	RestUDir
  4815                                  ;	jmp	DirNF
  4816                                  ;;
  4817                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4818                                  ;; attributes that will include finding directories.  perform the first search
  4819                                  ;; and reset our directory afterward.
  4820                                  ;;
  4821                                  ;DoSearch:
  4822                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4823                                  ;	mov	byte ptr DS:[FCB-1],010H
  4824                                  ;;
  4825                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4826                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4827                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4828                                  ;;
  4829                                  ;	mov	ah,Dir_Search_First
  4830                                  ;	mov	dx,FCB-7
  4831                                  ;	int	int_command
  4832                                  ;
  4833                                  ;	push	ax				;AN022; save return state
  4834                                  ;	inc	al				;AN022; did an error occur?
  4835                                  ;	pop	ax				;AN022; get return state back
  4836                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4837                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4838                                  ;	push	dx				;AN022; save message
  4839                                  ;	invoke	restudir			;AN022; restore user's dir
  4840                                  ;	pop	dx				;AN022; restore message
  4841                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4842                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4843                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4844                                  ;
  4845                                  ;DirCerrorJ:					;AN022;
  4846                                  ;	jmp	Cerror				;AN022; exit
  4847                                  ;
  4848                                  ;;
  4849                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4850                                  ;; previous system call for later checking.
  4851                                  ;;
  4852                                  ;
  4853                                  ;found_first_file:
  4854                                  ;	push	ax
  4855                                  ;	invoke	restudir
  4856                                  ;	pop	ax
  4857                                  ;;
  4858                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4859                                  ;; no more.
  4860                                  ;;
  4861                                  ;DIRSTART:
  4862                                  ;	inc	al				; FF = file not found
  4863                                  ;	jnz	Display
  4864                                  ;	jmp	DirDone 			; Either an error or we are finished
  4865                                  ;;
  4866                                  ;; Note that we've seen a file and display the found file.
  4867                                  ;;
  4868                                  ;
  4869                                  ;Display:
  4870                                  ;	inc	[filecnt]			; Keep track of how many we find
  4871                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4872                                  ;	call	shoname
  4873                                  ;;
  4874                                  ;; If we are displaying in wide mode, do not output the file info
  4875                                  ;;
  4876                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4877                                  ;	jz	DirTest
  4878                                  ;	jmp	nexent				; If so, no size, date, or time
  4879                                  ;
  4880                                  ;;
  4881                                  ;; Test for directory.
  4882                                  ;;
  4883                                  ;DirTest:
  4884                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4885                                  ;	jz	fileent
  4886                                  ;;
  4887                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4888                                  ;;
  4889                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4890                                  ;	call	std_printf
  4891                                  ;	jmp	short nofsiz
  4892                                  ;;
  4893                                  ;; We have a file.  Display the file size
  4894                                  ;;
  4895                                  ;fileent:
  4896                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4897                                  ;	mov	file_size_low,dx
  4898                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4899                                  ;	mov	file_size_high,dx
  4900                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4901                                  ;	call	std_printf
  4902                                  ;;
  4903                                  ;; Display time and date of last modification
  4904                                  ;;
  4905                                  ;nofsiz:
  4906                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4907                                  ;;
  4908                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4909                                  ;; date/time fields as 1.x did not have them.
  4910                                  ;;
  4911                                  ;	or	ax,ax
  4912                                  ;	jz	nexent				; Skip if no date
  4913                                  ;	mov	bx,ax
  4914                                  ;	and	ax,1FH				; get day
  4915                                  ;	mov	dl,al
  4916                                  ;	mov	ax,bx
  4917                                  ;	mov	cl,5
  4918                                  ;	shr	ax,cl				; Align month
  4919                                  ;	and	al,0FH				; Get month
  4920                                  ;	mov	dh,al
  4921                                  ;	mov	cl,bh
  4922                                  ;	shr	cl,1				; Align year
  4923                                  ;	xor	ch,ch
  4924                                  ;	add	cx,80				; Relative 1980
  4925                                  ;	cmp	cl,100
  4926                                  ;	jb	millenium
  4927                                  ;	sub	cl,100
  4928                                  ;
  4929                                  ;millenium:
  4930                                  ;	xchg	dh,dl				;AN000; switch month & day
  4931                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  4932                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  4933                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  4934                                  ;	jcxz	prbuf				; Time field present?
  4935                                  ;	shr	cx,1
  4936                                  ;	shr	cx,1
  4937                                  ;	shr	cx,1
  4938                                  ;	shr	cl,1
  4939                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  4940                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  4941                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  4942                                  ;
  4943                                  ;prbuf:
  4944                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  4945                                  ;	call	std_printf
  4946                                  ;	invoke	crlf2				;AC066;end the line
  4947                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  4948                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  4949                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  4950                                  ;	endif04:				;AN066;
  4951                                  ;	jmp	scroll				; If not, just continue
  4952                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  4953                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  4954                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  4955                                  ;;
  4956                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  4957                                  ;; is only for /W case.
  4958                                  ;;
  4959                                  ;nexent:
  4960                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  4961                                  ;	dec	[lincnt]			      ;count this entry on the line
  4962                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  4963                                  ;	   mov	   al,[linlen]
  4964                                  ;	   mov	   [lincnt],al
  4965                                  ;	   invoke  crlf2
  4966                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  4967                                  ;	   jnz	   endif02			;AN066;
  4968                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  4969                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  4970                                  ;	   jmp	   short endif01		;AN066;
  4971                                  ;	else01: 				;AN066;ELSE since screen not full
  4972                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  4973                                  ;	   jne	   endif03			;	     count the line
  4974                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  4975                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  4976                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  4977                                  ;	   call    std_printf
  4978                                  ;	endif01:				;AX066;
  4979                                  ;;
  4980                                  ;; All we need to do now is to get the next directory entry.
  4981                                  ;;
  4982                                  ;scroll:
  4983                                  ;	mov	ah,Dir_Search_Next
  4984                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  4985                                  ;	int	int_command			; Search for a file to match FCB
  4986                                  ;	jmp	DirStart
  4987                                  ;;
  4988                                  ;; If no files have been found, display a not-found message
  4989                                  ;;
  4990                                  ;DirDone:
  4991                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  4992                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  4993                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  4994                                  ;	test	[filecnt],-1
  4995                                  ;	jnz	Trailer
  4996                                  ;	mov	ax,error_file_not_found 	;AN022;
  4997                                  ;
  4998                                  ;dir_err_setup_jmp:				;AN022;
  4999                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  5000                                  ;;
  5001                                  ;; If we have printed the maximum number of files per line, terminate it with
  5002                                  ;; CRLF.
  5003                                  ;;
  5004                                  ;Trailer:
  5005                                  ;	mov	al,[linlen]
  5006                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5007                                  ;	jz	mmessage
  5008                                  ;	invoke	crlf2
  5009                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5010                                  ;	jnz	endif06 			;AN066;   pause before going on
  5011                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5012                                  ;	endif06:				;AN066;   displays
  5013                                  ;
  5014                                  ;mmessage:
  5015                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5016                                  ;	mov	si,[filecnt]
  5017                                  ;	mov	dir_num,si
  5018                                  ;	call	std_printf
  5019                                  ;	mov	ah,Get_Drive_Freespace
  5020                                  ;	mov	dl,byte ptr DS:[FCB]
  5021                                  ;	int	int_command
  5022                                  ;	cmp	ax,-1
  5023                                  ;	retz
  5024                                  ;	mul	cx				; AX is bytes per cluster
  5025                                  ;	mul	bx
  5026                                  ;	mov	bytes_free,ax			;AC000;
  5027                                  ;	mov	bytes_free+2,dx 		;AC000;
  5028                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5029                                  ;	jmp	std_printf
  5030                                  ;
  5031                                  ;shoname:
  5032                                  ;	mov	di,offset trangroup:charbuf
  5033                                  ;	mov	cx,8
  5034                                  ;	rep	movsb
  5035                                  ;	mov	al,' '
  5036                                  ;	stosb
  5037                                  ;	mov	cx,3
  5038                                  ;	rep	movsb
  5039                                  ;	xor	ax,ax
  5040                                  ;	stosb
  5041                                  ;	push	dx
  5042                                  ;	mov	dx,offset trangroup:charbuf
  5043                                  ;	mov	string_ptr_2,dx
  5044                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5045                                  ;	call	std_printf
  5046                                  ;	pop	DX
  5047                                  ;	return
  5048                                  ;
  5049                                  ;check_for_P    PROC  NEAR		;AN066;
  5050                                  ;
  5051                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5052                                  ;	jz	endif05 		;AN066;
  5053                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5054                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5055                                  ;   	invoke  Pause
  5056                                  ;endif05:
  5057                                  ;	ret				;AN066;
  5058                                  ;
  5059                                  ;check_for_P    ENDP			;AN066;
  5060                                  
  5061                                  ; =============== S U B	R O U T	I N E =======================================
  5062                                  
  5063                                  SHONAME:
  5064                                  DISPLAYNAME:
  5065                                  		; MSDOS 3.3
  5066 00001169 BF[9B42]                		mov	di,CHARBUF
  5067 0000116C B90800                  		mov	cx,8
  5068 0000116F F3A4                    		rep movsb
  5069 00001171 B020                    		mov	al,' '
  5070 00001173 AA                      		stosb
  5071 00001174 B90300                  		mov	cx,3
  5072 00001177 F3A4                    		rep movsb
  5073 00001179 31C0                    		xor	ax,ax
  5074 0000117B AA                      		stosb
  5075 0000117C 52                      		push	dx
  5076 0000117D BA[9B42]                		mov	dx,CHARBUF
  5077 00001180 8916[4E44]              		mov	[STRING_PTR_2],dx
  5078 00001184 BA[3F37]                		mov	dx,STRINGBUF2PTR
  5079 00001187 E84923                  		call	STD_PRINTF
  5080 0000118A 5A                      		pop	dx
  5081 0000118B C3                      		retn
  5082                                  
  5083                                  ;============================================================================
  5084                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5085                                  ;============================================================================
  5086                                  ; 09/10/2018 - Retro DOS v3.0
  5087                                  
  5088                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5089                                  
  5090                                  
  5091                                  ; =============== S U B	R O U T	I N E =======================================
  5092                                  
  5093                                  PAUSE:
  5094 0000118C BA[0C3A]                		mov	dx,PAUSEMESPTR
  5095 0000118F E84123                  		call	STD_PRINTF
  5096 00001192 E858F3                  		call	GETKEYSTROKE
  5097 00001195 E8D407                  		call	CRLF2
  5098 00001198 C3                      		retn
  5099                                  
  5100                                  ; ---------------------------------------------------------------------------
  5101                                  
  5102                                  ;****************************************************************
  5103                                  ;*
  5104                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5105                                  ;*
  5106                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5107                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5108                                  ;*		up an error message and transfer control to CERROR.
  5109                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5110                                  ;*		entered or SLASHP_ERASE if /P entered.
  5111                                  ;*
  5112                                  ;* INPUT:	command line at offset 81H
  5113                                  ;*
  5114                                  ;* OUTPUT:	if no error:
  5115                                  ;*		FCB at 5ch set up with filename(s) entered
  5116                                  ;*		Current directory set to entered directory
  5117                                  ;*
  5118                                  ;****************************************************************
  5119                                  
  5120                                  ERASE:
  5121                                  		; MSDOS 6.0
  5122                                  
  5123                                  ;assume	ds:trangroup,es:trangroup
  5124                                  
  5125                                  ;		mov	si,81H		;AC000; get command line
  5126                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5127                                  ;		mov	di,offset trangroup:parse_erase
  5128                                  ;					;AN000; Get adderss of PARSE_erase
  5129                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5130                                  ;
  5131                                  ;erase_scan:
  5132                                  ;		xor	dx,dx		;AN000;
  5133                                  ;		invoke	parse_with_msg	;AC018; call parser
  5134                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5135                                  ;		jz	good_line	;AN000; yes - done parsing
  5136                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5137                                  ;		jnz	errj2		;AC000; yes exit
  5138                                  ;
  5139                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5140                                  ;					;AN000; was /P entered?
  5141                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5142                                  ;
  5143                                  ;;
  5144                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5145                                  ;;
  5146                                  ;		push	si		;AC000; save position in line
  5147                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5148                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5149                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5150                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5151                                  ;					;AC000; was only drive entered?
  5152                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5153                                  ;		mov	ax,error_file_not_found 
  5154                                  ;					;AN022; get message number in control block
  5155                                  ;		jmp	short extend_setup ;AC000; exit
  5156                                  ;
  5157                                  ;erase_drive_ok:
  5158                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5159                                  ;		pop	si		;AC000; get position back
  5160                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5161                                  ;
  5162                                  ;set_erase_prompt:
  5163                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5164                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5165                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5166                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5167                                  ;		jmp	short errj2	;AN018; exit
  5168                                  ;
  5169                                  ;ok_to_set_erase_prompt: 		;AN018;
  5170                                  ;		inc	comsw		;AN000; indicate /p specified
  5171                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5172                                  ;
  5173                                  ;good_line:				;G  We know line is good
  5174                                  ;		invoke	pathcrunch
  5175                                  ;		jnc	checkdr
  5176                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5177                                  ;		cmp	ax,0		;AN022; was message flag set?
  5178                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5179                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5180                                  ;		jnz	badpath_err	;AC022; see if they should have
  5181                                  ;
  5182                                  ;checkdr:
  5183                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5184                                  ;		jz	notest2j	;AN000; no - go to notest2
  5185                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5186                                  ;
  5187                                  ;notest2j:
  5188                                  ;		jmp	notest2
  5189                                  ;
  5190                                  ;badpath_err:				;AN022; "Path not found" message
  5191                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5192                                  ;
  5193                                  ;extend_setup:				;AN022;
  5194                                  ;		mov	msg_disp_class,ext_msg_class
  5195                                  ;					;AN022; set up extended error msg class
  5196                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5197                                  ;					;AC022; get extended message pointer
  5198                                  ;		mov	Extend_Buf_ptr,ax
  5199                                  ;					;AN022; get message number in control block
  5200                                  ;errj2:					;AC022; exit jump
  5201                                  ;		jmp	Cerror		;AN022;
  5202                                  
  5203                                  		; MSDOS 3.3
  5204 00001199 BA[6D3D]                		mov	dx,BADARGSPTR
  5205 0000119C BE8000                  		mov	si,80h
  5206 0000119F AC                      		lodsb
  5207 000011A0 08C0                    		or	al,al
  5208 000011A2 743E                    		jz	short ERRJ2
  5209 000011A4 E8D207                  		call	SCANOFF
  5210 000011A7 3C0D                    		cmp	al,0Dh		; Return key
  5211 000011A9 7437                    		jz	short ERRJ2	; If so no parameters specified
  5212 000011AB 52                      		push	dx
  5213 000011AC 56                      		push	si
  5214 000011AD BA[F837]                		mov	dx,FNOTFOUNDPTR
  5215                                  ERASE_SCAN:
  5216 000011B0 AC                      		lodsb
  5217 000011B1 E8CD07                  		call	DELIM
  5218 000011B4 7406                    		jz	short ERASE_CHKDELIMCHR
  5219 000011B6 3C0D                    		cmp	al,0Dh
  5220 000011B8 7415                    		jz	short GOOD_LINE
  5221 000011BA EBF4                    		jmp	short ERASE_SCAN
  5222                                  ERASE_CHKDELIMCHR:
  5223 000011BC 3C20                    		cmp	al,20h
  5224 000011BE 7F22                    		jg	short ERRJ2
  5225 000011C0 AC                      		lodsb
  5226 000011C1 E8BD07                  		call	DELIM
  5227 000011C4 74F6                    		jz	short ERASE_CHKDELIMCHR
  5228 000011C6 3C0D                    		cmp	al,0Dh
  5229 000011C8 7405                    		jz	short GOOD_LINE
  5230 000011CA BA[6D3D]                		mov	dx,BADARGSPTR
  5231 000011CD EB13                    		jmp	short ERRJ2
  5232                                  GOOD_LINE:
  5233 000011CF 5E                      		pop	si
  5234 000011D0 5A                      		pop	dx
  5235 000011D1 56                      		push	si
  5236 000011D2 E84808                  		call	PATHCRUNCH
  5237 000011D5 730E                    		jnc	short CHECKDR
  5238 000011D7 803E[6C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5239 000011DC 7407                    		jz	short CHECKDR	   ; see if they should have
  5240                                  BADCDERR:
  5241 000011DE 5E                      		pop	si
  5242 000011DF BA[763B]                		mov	dx,BADCDPTR
  5243                                  ERRJ2:
  5244 000011E2 E9440A                  		jmp	CERROR
  5245                                  CHECKDR:
  5246 000011E5 BA[F837]                		mov	dx,FNOTFOUNDPTR
  5247 000011E8 59                      		pop	cx
  5248 000011E9 B020                    		mov	al,' '
  5249                                  		;cmp	[5Dh],al
  5250 000011EB 38065D00                		cmp	[FCB+1],al
  5251 000011EF 74F1                    		jz	short ERRJ2
  5252 000011F1 83C103                  		add	cx,3
  5253 000011F4 39CE                    		cmp	si,cx
  5254 000011F6 7507                    		jnz	short NOTEST2J
  5255 000011F8 B03A                    		mov	al,':'
  5256 000011FA 3844FE                  		cmp	[si-2],al
  5257 000011FD 74E3                    		jz	short ERRJ2
  5258                                  NOTEST2J:
  5259 000011FF E92116                  		jmp	NOTEST2
  5260                                  
  5261                                  ; ---------------------------------------------------------------------------
  5262                                  
  5263                                  ; ****************************************************************
  5264                                  ; *
  5265                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5266                                  ; *
  5267                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5268                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5269                                  ; *		 Make sure the second filespec only contains a
  5270                                  ; *		 filename.  If both openands are valid, attempt
  5271                                  ; *		 to rename the file.
  5272                                  ; *
  5273                                  ; * INPUT:	 command line at offset 81H
  5274                                  ; *
  5275                                  ; * OUTPUT:	 none
  5276                                  ; *
  5277                                  ; ****************************************************************
  5278                                  
  5279                                  CRENAME:
  5280                                  		; MSDOS 6.0
  5281                                  		;assume	ds:trangroup,es:trangroup
  5282                                  ;
  5283                                  ;		mov	si,81H		;AC000; Point to command line
  5284                                  ;		mov	di,offset trangroup:parse_rename
  5285                                  ;					;AN000; Get adderss of PARSE_RENAME
  5286                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5287                                  ;		xor	dx,dx		;AN000;
  5288                                  ;		invoke	parse_with_msg	;AC018; call parser
  5289                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5290                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5291                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5292                                  ;;
  5293                                  ;;  Get first file name returned from parse into our buffer
  5294                                  ;;
  5295                                  ;crename_no_parse_error:
  5296                                  ;		push	si		;AN000; save position in line
  5297                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5298                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5299                                  ;		pop	si		;AN000; restore position in line
  5300                                  ;
  5301                                  ;		xor	dx,dx		;AN000; clear dx
  5302                                  ;		invoke	parse_with_msg	;AC018; call parser
  5303                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5304                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5305                                  ;;
  5306                                  ;;  Check the second file name for drive letter colon
  5307                                  ;;
  5308                                  ;		push	si		;AN000; save position in line
  5309                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5310                                  ;
  5311                                  ;		mov	al,':'		;AC000;
  5312                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5313                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5314                                  ;		mov	msg_disp_class,parse_msg_class
  5315                                  ;					;AN000; set up parse error msg class
  5316                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5317                                  ;					;AC000; get extended message pointer
  5318                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5319                                  ;					;AN000; get "Invalid parameter" message number
  5320                                  ;		pop	si		;AN000;
  5321                                  ;crename_parse_error:			;AC022;
  5322                                  ;		jmp	short errj	;AC000;
  5323                                  ;
  5324                                  ;;  Get second file name returned from parse into the fCB. Save
  5325                                  ;;  character after file name so we can later check to make sure it
  5326                                  ;;  isn't a path character.
  5327                                  ;
  5328                                  ;
  5329                                  ;ren_no_drive:
  5330                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5331                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5332                                  ;		int	21h		;AC000; do the function
  5333                                  ;		lodsb			;AC000; Load char after filename
  5334                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5335                                  ;		pop	si		;AN000; get line position back
  5336                                  ;
  5337                                  ;;
  5338                                  ;; We have source and target.  See if any args beyond.
  5339                                  ;;
  5340                                  ;
  5341                                  ;		mov	di,offset trangroup:parse_rename
  5342                                  ;					;AC000; get address of parse_rename
  5343                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5344                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5345                                  ;
  5346                                  ;		invoke	pathcrunch
  5347                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5348                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5349                                  ;		jnc	notest3
  5350                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5351                                  ;		cmp	ax,0		;AN022; was message flag set?
  5352                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5353                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5354                                  ;		jz	notest3 	; see if they should have
  5355                                  ;		Jmp	badpath_err	;AC022; set up error
  5356                                  ;
  5357                                  ;notest3:
  5358                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5359                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5360                                  ;					; Load invalid fname error ptr
  5361                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5362                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5363                                  ;					;  filename only.
  5364                                  ;		mov	ah,FCB_Rename
  5365                                  ;		mov	dx,FCB
  5366                                  ;		int	21h
  5367                                  ;		cmp	al, 0FFH	; Did an error occur??
  5368                                  ;		jnz	renameok
  5369                                  ;
  5370                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5371                                  ;		SaveReg <AX>		;AC022; Save results
  5372                                  ;		mov	al, 0FFH	; Restore original error state
  5373                                  ;
  5374                                  ;renameok:
  5375                                  ;		push	ax
  5376                                  ;		invoke	restudir
  5377                                  ;		pop	ax
  5378                                  ;		inc	al
  5379                                  ;		retnz
  5380                                  ;
  5381                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5382                                  ;		cmp	ax,error_file_not_found 
  5383                                  ;					;AN022; error file not found?
  5384                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5385                                  ;		cmp	ax,error_access_denied
  5386                                  ;					;AN022; error file not found?
  5387                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5388                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5389                                  ;
  5390                                  ;use_renerr:
  5391                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5392                                  ;ERRJ:
  5393                                  ;		jmp	Cerror
  5394                                  ;
  5395                                  ;ret56:		ret
  5396                                  
  5397                                  		; MSDOS 3.3
  5398 00001202 BA[6D3D]                		mov	dx,BADARGSPTR
  5399 00001205 E87107                  		call	SCANOFF
  5400 00001208 3C0D                    		cmp	al,0Dh
  5401 0000120A 74D6                    		jz	short ERRJ2
  5402 0000120C E80E08                  		call	PATHCRUNCH
  5403 0000120F BA[4C3D]                		mov	dx,BADCPMESPTR
  5404 00001212 74CE                    		jz	short ERRJ2
  5405 00001214 7309                    		jnb	short CRENAME_NO_PARSE_ERROR
  5406 00001216 803E[6C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5407 0000121B 7402                    		jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5408 0000121D EBBF                    		jmp	short BADCDERR
  5409                                  
  5410                                  ;  Get first file name returned from parse into our buffer
  5411                                  
  5412                                  CRENAME_NO_PARSE_ERROR:
  5413 0000121F 8B36[C043]              		mov	si,[PATHPOS]
  5414 00001223 E85307                  		call	SCANOFF
  5415 00001226 3C0D                    		cmp	al,0Dh
  5416 00001228 BA[6D3D]                		mov	dx,BADARGSPTR
  5417 0000122B 7443                    		jz	short ERRJ
  5418 0000122D B03A                    		mov	al,':'
  5419 0000122F BA[223A]                		mov	dx,BADPARMPTR
  5420 00001232 384401                  		cmp	[si+1],al
  5421 00001235 7439                    		jz	short ERRJ
  5422                                  
  5423                                  ;  Get second file name returned from parse into the FCB. Save
  5424                                  ;  character after file name so we can later check to make sure it
  5425                                  ;  isn't a path character.
  5426                                  
  5427                                  REN_NO_DRIVE:
  5428                                  		;mov	di,6Ch
  5429 00001237 BF6C00                  		mov	di,FCB+10h
  5430 0000123A B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5431 0000123D CD21                    		int	21h	; DOS -	PARSE FILENAME
  5432                                  				; DS:SI	-> string to parse
  5433                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5434                                  				; AL = bit mask	to control parsing
  5435 0000123F B020                    		mov	al,' '
  5436                                  		;cmp	[6Dh],al
  5437 00001241 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5438 00001245 7429                    		jz	short ERRJ	; Error if missing parameter
  5439 00001247 AC                      		lodsb
  5440 00001248 BA[E738]                		mov	dx,INORNOTPTR
  5441 0000124B E8BE07                  		call	PATHCHRCMP
  5442 0000124E 7420                    		jz	short ERRJ
  5443 00001250 B417                    		mov	ah,FCB_RENAME ; 17h
  5444 00001252 BA5C00                  		mov	dx,FCB ; 5Ch
  5445 00001255 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5446                                  				; DS:DX	-> FCB
  5447                                  				; FCB contains new name	starting at byte 17h.
  5448 00001257 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5449 00001259 750A                    		jnz	short RENAMEOK
  5450 0000125B F9                      		stc
  5451 0000125C BA[E537]                		mov	dx,RENERRPTR
  5452 0000125F E8680C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5453 00001262 52                      		push	dx
  5454 00001263 B0FF                    		mov	al,0FFh		; Restore original error state
  5455                                  RENAMEOK:
  5456 00001265 50                      		push	ax
  5457 00001266 E83206                  		call	RESTUDIR
  5458 00001269 58                      		pop	ax
  5459 0000126A FEC0                    		inc	al
  5460 0000126C 7401                    		jz	short RENAME_ERR
  5461                                  RENAME_RETN:
  5462                                  TYPELP_RET:
  5463 0000126E C3                      		retn
  5464                                  RENAME_ERR:
  5465 0000126F 5A                      		pop	dx
  5466                                  ERRJ:					; Retro DOS v3.0
  5467 00001270 E85722                  		call	STD_EPRINTF
  5468 00001273 E98EEE                  		jmp	TCOMMAND
  5469                                  
  5470                                  ; ---------------------------------------------------------------------------
  5471                                  
  5472                                  ;ERRJ:
  5473                                  ;		jmp	CERROR
  5474                                  
  5475                                  ; ---------------------------------------------------------------------------
  5476                                  
  5477                                  ;TYPELP_RET:
  5478                                  ;		retn
  5479                                  
  5480                                  ; ---------------------------------------------------------------------------
  5481                                  
  5482                                  ;****************************************************************
  5483                                  ;*
  5484                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5485                                  ;*		standard output device
  5486                                  ;*
  5487                                  ;* SYNTAX:	TYPE filespec
  5488                                  ;*
  5489                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5490                                  ;*		1Ah and display the contents to STDOUT.
  5491                                  ;*
  5492                                  ;* INPUT:	command line at offset 81H
  5493                                  ;*
  5494                                  ;* OUTPUT:	none
  5495                                  ;*
  5496                                  ;****************************************************************
  5497                                  
  5498                                  TYPEFIL:
  5499                                  		; MSDOS 6.0	
  5500                                  		;assume	ds:trangroup,es:trangroup
  5501                                  
  5502                                  ;		mov	si,81H
  5503                                  ;		mov	di,offset trangroup:parse_mrdir 
  5504                                  ;					;AN000; Get adderss of PARSE_MRDIR
  5505                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5506                                  ;		xor	dx,dx		;AN000;
  5507                                  ;		invoke	parse_with_msg	;AC018; call parser
  5508                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5509                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5510                                  ;
  5511                                  ;		push	si		;AC000; save position in line
  5512                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5513                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5514                                  ;		pop	si		;AC000; get position back
  5515                                  ;		mov	di,offset trangroup:parse_mrdir 
  5516                                  ;					;AC000; get address of parse_mrdir
  5517                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5518                                  ;		jz	gottarg 	;AC000; yes - continue
  5519                                  ;
  5520                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5521                                  ;		jmp	Cerror
  5522                                  ;
  5523                                  ;gottarg:
  5524                                  ;		invoke	setpath
  5525                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5526                                  ;		jz	nowilds 	; No, continue processing
  5527                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5528                                  ;		jmp	Cerror
  5529                                  ;nowilds:
  5530                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5531                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5532                                  ;		xor	cx,cx		;AN000; no special files
  5533                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5534                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5535                                  ;		int	21h
  5536                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5537                                  ;
  5538                                  ;Typerr: 				;AN022;
  5539                                  ;		push	cs		;AN022; make sure we have local segment
  5540                                  ;		pop	ds		;AN022;
  5541                                  ;		invoke	set_ext_error_msg ;AN022;
  5542                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5543                                  ;					;AC022; get address of failed string
  5544                                  ;		mov	Extend_buf_sub,one_subst
  5545                                  ;					;AC022; put number of subst in control block
  5546                                  ;		jmp	cerror		;AC022; exit
  5547                                  ;
  5548                                  ;typecont:
  5549                                  ;		mov	bx,ax		;AC000; get  Handle
  5550                                  ;;M043
  5551                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5552                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5553                                  ;;indicate it is a device.
  5554                                  ;;
  5555                                  ;		mov	ax,(IOCTL shl 8) or 0
  5556                                  ;		int	21h
  5557                                  ;
  5558                                  ;		test	dl,80h		;is it a device?
  5559                                  ;		jz	not_device	;no, a file
  5560                                  ;
  5561                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5562                                  ;		jmp	short dotype
  5563                                  ;not_device:
  5564                                  ;
  5565                                  ;;SR;
  5566                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5567                                  ;;start of file
  5568                                  ;;
  5569                                  ;		mov	ax,(LSEEK shl 8) or 2
  5570                                  ;		xor	dx,dx
  5571                                  ;		mov	cx,dx		;seek  to end of file
  5572                                  ;		int	21h
  5573                                  ;
  5574                                  ;		mov	word ptr TypeFilSiz,ax
  5575                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5576                                  ;
  5577                                  ;		mov	ax,(LSEEK shl 8) or 0
  5578                                  ;		xor	dx,dx
  5579                                  ;		int	21h	        ;reset file pointer to start
  5580                                  ;dotype:					;M043
  5581                                  ;		mov	zflag,0 	; Reset ^Z flag
  5582                                  ;		mov	ds,[TPA]
  5583                                  ;		xor	dx,dx
  5584                                  ;		;ASSUME	DS:NOTHING
  5585                                  ;
  5586                                  ;typelp:
  5587                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5588                                  ;		retnz			; Yes, return
  5589                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5590                                  ;;
  5591                                  ;;Update the filesize left to read
  5592                                  ;;
  5593                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5594                                  ;		je	typ_read	;yes, just read from it; M043
  5595                                  ;
  5596                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5597                                  ;		jz	lt64k		;no, do word subtraction
  5598                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5599                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5600                                  ;      		jmp	short typ_read	;do the read
  5601                                  ;lt64k:
  5602                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5603                                  ;		jbe	gtbuf		; yes, just update readsize
  5604                                  ;;
  5605                                  ;;Buffer size is larger than bytes to read
  5606                                  ;;
  5607                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5608                                  ;		jcxz	typelp_ret
  5609                                  ;		mov	word ptr cs:TypeFilSiz,0
  5610                                  ;		jmp	short typ_read
  5611                                  ;gtbuf:
  5612                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5613                                  ;typ_read:
  5614                                  ;		mov	ah,read
  5615                                  ;		int	21h		
  5616                                  ;		jnc	@f		;M043
  5617                                  ;		jmp	typerr		;M043
  5618                                  ;@@:					;M043
  5619                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5620                                  ;
  5621                                  ;		mov	cx,ax
  5622                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5623                                  ;		push	ds
  5624                                  ;		pop	es		; Check to see if a ^Z was read.
  5625                                  ;		;assume es:nothing
  5626                                  ;		xor	di,di
  5627                                  ;		push	ax
  5628                                  ;		mov	al,1ah
  5629                                  ;		repnz	scasb
  5630                                  ;		pop	ax
  5631                                  ;		xchg	ax,cx
  5632                                  ;		cmp	ax,0
  5633                                  ;		jnz	foundz		; Yes, handle it
  5634                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5635                                  ;		jnz	typecont2	; No ^Z, continue
  5636                                  ;
  5637                                  ;foundz:
  5638                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5639                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5640                                  ;		push	cs		;  will be typed.
  5641                                  ;		pop	es
  5642                                  ;		;assume es:trangroup
  5643                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5644                                  ;typecont2:				;  will quit after this write.
  5645                                  ;		push	bx
  5646                                  ;		mov	bx,1
  5647                                  ;		mov	ah,write
  5648                                  ;		int	21h
  5649                                  ;		pop	bx
  5650                                  ;		jc	Error_outputj
  5651                                  ;		cmp	ax,cx
  5652                                  ;		jnz	@f		;M043
  5653                                  ;		jmp	typelp		;M043
  5654                                  ;@@:					;M043
  5655                                  ;;M043;		jz	typelp
  5656                                  ;		dec	cx
  5657                                  ;		cmp	ax,cx
  5658                                  ;		retz			; One less byte OK (^Z)
  5659                                  ;Error_outputj:
  5660                                  ;		mov	bx,1
  5661                                  ;		mov	ax,IOCTL SHL 8
  5662                                  ;		int	21h
  5663                                  ;		test	dl,devid_ISDEV
  5664                                  ;		retnz			; If device, no error message
  5665                                  ;		jmp	error_output
  5666                                  ;typelp_ret:
  5667                                  ;		ret
  5668                                  
  5669                                  		; MSDOS 3.3
  5670 00001276 BE8100                  		mov	si,81h
  5671 00001279 E8FD06                  		call	SCANOFF		; Skip to first non-delim
  5672 0000127C 3C0D                    		cmp	al,0Dh
  5673 0000127E 7505                    		jnz	short GOTTARG
  5674 00001280 BA[6D3D]                		mov	dx,BADARGSPTR
  5675                                  
  5676                                  		;jmp	CERROR
  5677 00001283 EBEB                    		jmp	short ERRJ	; No args
  5678                                  GOTTARG:
  5679 00001285 E8EF0A                  		call	SETPATH
  5680 00001288 F606[7044]02            		test	byte [DESTINFO],2
  5681 0000128D 7405                    		jz	short NOWILDS
  5682 0000128F BA[E738]                		mov	dx,INORNOTPTR
  5683                                  
  5684                                  		;jmp	CERROR
  5685 00001292 EBDC                    		jmp	short ERRJ
  5686                                  NOWILDS:
  5687 00001294 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5688 00001297 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5689                                  				; DS:DX	-> ASCIZ filename
  5690                                  				; AL = access mode
  5691                                  				; 0 - read
  5692 00001299 7311                    		jnc	short TYPECONT
  5693 0000129B BA[F837]                		mov	dx,FNOTFOUNDPTR
  5694 0000129E 83F802                  		cmp	ax,2
  5695 000012A1 74CD                    		jz	short ERRJ
  5696 000012A3 BA[4C3D]                		mov	dx,BADCPMESPTR
  5697 000012A6 F9                      		stc
  5698 000012A7 E8200C                  		call	GET_EXT_ERR_NUMBER
  5699                                  
  5700                                  		;jmp	CERROR
  5701 000012AA EBC4                    		jmp	short ERRJ
  5702                                  TYPECONT:
  5703 000012AC C606[F74B]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5704 000012B1 89C3                    		mov	bx,ax		; Handle
  5705 000012B3 8E1E[7342]              		mov	ds,[TPA]
  5706 000012B7 31D2                    		xor	dx,dx
  5707                                  TYPELP:
  5708 000012B9 2E803E[F74B]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5709 000012BF 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5710 000012C1 2E8B0E[9242]            		mov	cx,[cs:BYTCNT]	; No, continue
  5711 000012C6 B43F                    		mov	ah,READ ; 3Fh
  5712 000012C8 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5713                                  				; BX = file handle,CX = number	of bytes to read
  5714                                  				; DS:DX	-> buffer
  5715 000012CA 89C1                    		mov	cx,ax
  5716 000012CC E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5717                                  					; Check to see if a ^Z was read.
  5718 000012CE 1E                      		push	ds
  5719 000012CF 07                      		pop	es		
  5720 000012D0 31FF                    		xor	di,di
  5721 000012D2 50                      		push	ax
  5722 000012D3 B01A                    		mov	al,1Ah
  5723 000012D5 F2AE                    		repne scasb
  5724 000012D7 58                      		pop	ax
  5725 000012D8 91                      		xchg	ax,cx
  5726 000012D9 83F800                  		cmp	ax,0
  5727 000012DC 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5728 000012DE 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5729 000012E2 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5730                                  FOUNDZ:
  5731 000012E4 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5732 000012E6 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5733 000012E7 0E                      		push	cs		;  will be typed.
  5734 000012E8 07                      		pop	es
  5735 000012E9 2EF616[F74B]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5736                                  					;  will quit after this write.
  5737                                  TYPECONT2:
  5738 000012EE 53                      		push	bx
  5739 000012EF BB0100                  		mov	bx,1
  5740 000012F2 B440                    		mov	ah,WRITE ; 40h
  5741 000012F4 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5742                                  				; BX = file handle, CX = number of bytes to write,
  5743                                  				; DS:DX -> buffer
  5744 000012F6 5B                      		pop	bx
  5745 000012F7 720A                    		jc	short ERROR_OUTPUTJ
  5746 000012F9 39C8                    		cmp	ax,cx
  5747 000012FB 74BC                    		jz	short TYPELP
  5748 000012FD 49                      		dec	cx
  5749 000012FE 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5750 00001300 7501                    		jnz	short ERROR_OUTPUTJ
  5751                                  TYPEFIL_RETN:
  5752 00001302 C3                      		retn
  5753                                  ERROR_OUTPUTJ:
  5754 00001303 BB0100                  		mov	bx,1
  5755 00001306 B80044                  		mov	ax,IOCTL*256 ; 4400h
  5756 00001309 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5757                                  				; BX = file or device handle
  5758                                  		;test	dl,devid_ISDEV
  5759 0000130B F6C280                  		test	dl,80h
  5760 0000130E 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5761 00001310 E9DF06                  		jmp	ERROR_OUTPUT
  5762                                  
  5763                                  ; ---------------------------------------------------------------------------
  5764                                  
  5765                                  ; VOLUME command displays the volume ID on the specified drive
  5766                                  
  5767                                  VOLUME:
  5768                                  		; MSDOS 6.0
  5769                                  		;mov	si,81H
  5770                                  		;mov	di,offset trangroup:parse_vol
  5771                                  		;			;AN000; Get adderss of PARSE_VOL
  5772                                  		;xor	cx,cx		;AN000; clear cx,dx
  5773                                  		;xor	dx,dx		;AN000;
  5774                                  		;invoke	parse_with_msg	;AC018; call parser
  5775                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5776                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5777                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5778                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5779                                  
  5780                                  ; We have parsed off the drive. See if there are any more chars left
  5781                                  
  5782                                  		;mov	di,offset trangroup:parse_vol	
  5783                                  					;AC000; get address of parse_vol
  5784                                  		;xor	dx,dx		;AC000;
  5785                                  		;invoke	parse_check_eol ;AC000; call parser
  5786                                  		;jz	OkVolArg	;AC000; yes, end of road
  5787                                  
  5788                                  ; The line was not interpretable. Report an error.
  5789                                  
  5790                                  ;badvolarg:
  5791                                  		;jmp	Cerror
  5792                                  
  5793                                  		; MSDOS 3.3
  5794 00001313 BE8100                  		mov	si,81h
  5795 00001316 E86006                  		call	SCANOFF		; Skip to first non-delim
  5796                                  		;mov	ah,[5Ch]
  5797 00001319 8A265C00                		mov	ah,[FCB]
  5798                                  		;mov	byte [5Ch],0
  5799 0000131D C6065C0000              		mov	byte [FCB],0
  5800 00001322 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5801 00001324 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5802                                  		;mov	[5Ch],ah
  5803 00001326 88265C00                		mov	[FCB],ah
  5804 0000132A AC                      		lodsb
  5805 0000132B AC                      		lodsb
  5806 0000132C 3C3A                    		cmp	al,':'
  5807 0000132E 7507                    		jnz	short VOLUME_ERR
  5808 00001330 E84606                  		call	SCANOFF
  5809 00001333 3C0D                    		cmp	al,0Dh
  5810 00001335 7406                    		jz	short OKVOLARG
  5811                                  VOLUME_ERR:
  5812 00001337 BA[4939]                		mov	dx,BADDRVPTR
  5813 0000133A E9EC08                  		jmp	CERROR
  5814                                  
  5815                                  ; ---------------------------------------------------------------------------
  5816                                  
  5817                                  OKVOLARG:
  5818 0000133D E82C06                  		call	CRLF2
  5819 00001340 1E                      		push	ds
  5820 00001341 07                      		pop	es
  5821                                  		;mov	di,55h
  5822 00001342 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5823 00001345 B0FF                    		mov	al,-1
  5824 00001347 AA                      		stosb
  5825 00001348 31C0                    		xor	ax,ax
  5826 0000134A AB                      		stosw
  5827 0000134B AB                      		stosw
  5828 0000134C AA                      		stosb
  5829 0000134D B008                    		mov	al,8		; Look for volume label
  5830 0000134F AA                      		stosb
  5831 00001350 47                      		inc	di		; Skip drive byte
  5832 00001351 B90B00                  		mov	cx,11
  5833 00001354 B03F                    		mov	al,'?'
  5834 00001356 F3AA                    		rep stosb
  5835 00001358 BA[6A43]                		mov	dx,DIRBUF
  5836 0000135B B41A                    		mov	ah,SET_DMA ; 1Ah
  5837 0000135D CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5838                                  				; DS:DX	-> disk	transfer buffer
  5839                                  		;mov	dx,55h
  5840 0000135F BA5500                  		mov	dx,FCB-7
  5841 00001362 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5842 00001364 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5843                                  				; DS:DX	-> FCB
  5844 00001366 E9F915                  		jmp	PRINTVOL
  5845                                  
  5846                                  ;============================================================================
  5847                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5848                                  ;============================================================================
  5849                                  ; 08/10/2018 - Retro DOS v3.0
  5850                                  
  5851                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5852                                  
  5853                                  ; ---------------------------------------------------------------------------
  5854                                  
  5855                                  ; MSDOS 6.0
  5856                                  ;***	Version - display DOS version
  5857                                  ;
  5858                                  ;	SYNTAX	ver [/debug]
  5859                                  ;
  5860                                  ;		/debug - display additional DOS configuration info
  5861                                  ;
  5862                                  ;	ENTRY	command-line tail is in PSP
  5863                                  ;
  5864                                  ;	EXIT	if successful, nothing
  5865                                  ;		if parse fails,
  5866                                  ;		  parse error message is set up (for Std_EPrintf)
  5867                                  ;		    AX = system parser error code
  5868                                  ;		    DX = ptr to message block
  5869                                  ;		  we jump to CError
  5870                                  ;
  5871                                  ;	EFFECTS
  5872                                  ;	  If parse fails, a parse error message is displayed.
  5873                                  ;	  Otherwise, version message is displayed.
  5874                                  ;	  If /debug is specified, additional DOS info is displayed.
  5875                                  
  5876                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5877                                  ;
  5878                                  ;;	Parse command line for /debug switch.
  5879                                  ;
  5880                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5881                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5882                                  ;	xor	cx,cx				; CX = # positional param's found
  5883                                  ;	invoke	Parse_With_Msg
  5884                                  ;
  5885                                  ;	mov	bl,1			; BL = flag = /debug present
  5886                                  ;	cmp	ax,RESULT_NO_ERROR
  5887                                  ;	je	verPrintVer		; something parsed - must be /debug
  5888                                  ;	dec	bl			; BL = flag = no /debug present
  5889                                  ;	cmp	ax,END_OF_LINE
  5890                                  ;	je	verPrintVer		; reached end of line - ok
  5891                                  ;
  5892                                  ;;	The parse failed.  Error message has been set up.
  5893                                  ;
  5894                                  ;	jmp	CError
  5895                                  ;
  5896                                  ;verPrintVer:
  5897                                  ;	push	bx			; save /debug flag
  5898                                  ;	call	Crlf2
  5899                                  ;	call	Print_Version
  5900                                  ;	call	Crlf2
  5901                                  ;	pop	bx   			; BL = /debug flag
  5902                                  ;	or	bl,bl
  5903                                  ;	jz	verDone			; /debug is false - we're done
  5904                                  ;
  5905                                  ;;*	For /debug, display DOS internal revision and DOS location
  5906                                  ;;	(low memory, HMA, or ROM).
  5907                                  ;
  5908                                  ;;	Bugbug:	use symbols for bitmasks below.
  5909                                  ;
  5910                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5911                                  ;	int	21h
  5912                                  ;	mov	al,dl			;revision number in dl; M013
  5913                                  ;	mov	bh,dh			;flags in dh now; M013
  5914                                  ;;M032	and	al,7			; AL = DOS internal revision
  5915                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5916                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5917                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5918                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5919                                  ;	mov	One_Char_Val,al
  5920                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5921                                  ;	invoke	Std_Printf		; print DOS internal revision
  5922                                  ;
  5923                                  ;	mov	cl,4
  5924                                  ;	shr	bh,cl			; CY = DOS in ROM
  5925                                  ;	jc	verRom
  5926                                  ;	shr	bh,1			; CY = DOS in HMA
  5927                                  ;	jc	verHma
  5928                                  ;
  5929                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  5930                                  ;
  5931                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  5932                                  ;	jmp	short verPrintLoc
  5933                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  5934                                  ;	jmp	short verPrintLoc
  5935                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  5936                                  ;verPrintLoc:
  5937                                  ;	invoke	Std_Printf
  5938                                  ;verDone:
  5939                                  ;	jmp	Crlf2
  5940                                  
  5941                                  		; MSDOS 3.3
  5942                                  VERSION:
  5943 00001369 E80006                  		call	CRLF2
  5944 0000136C E80300                  		call	PRINT_VERSION
  5945 0000136F E9FA05                  		jmp	CRLF2
  5946                                  
  5947                                  ; =============== S U B	R O U T	I N E =======================================
  5948                                  
  5949                                  PRINT_VERSION:
  5950 00001372 B430                    		mov	ah,GET_VERSION ; 30h
  5951 00001374 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  5952                                  				; Return: AL = major version number (00h for DOS 1.x)
  5953 00001376 50                      		push	ax
  5954 00001377 30E4                    		xor	ah,ah
  5955 00001379 A3[5D44]                		mov	[MAJOR_VER_NUM],ax
  5956 0000137C 58                      		pop	ax
  5957 0000137D 86E0                    		xchg	ah,al
  5958 0000137F 30E4                    		xor	ah,ah
  5959 00001381 A3[5F44]                		mov	[MINOR_VER_NUM],ax
  5960 00001384 BA[273B]                		mov	dx,VERMESPTR
  5961 00001387 E94921                  		jmp	STD_PRINTF
  5962                                  
  5963                                  ; =============== S U B	R O U T	I N E =======================================
  5964                                  
  5965                                  PRINT_PROMPT:
  5966 0000138A 1E                      		push	ds
  5967 0000138B 0E                      		push	cs
  5968 0000138C 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  5969 0000138D 06                      		push	es
  5970 0000138E E80304                  		call	FIND_PROMPT	; Look for prompt string
  5971 00001391 7206                    		jc	short PP0	; Can't find one	
  5972 00001393 26803D00                		cmp	byte [es:di],0
  5973 00001397 750A                    		jnz	short PP1
  5974                                  PP0:					; Use default prompt
  5975 00001399 E87200                  		call	PRINT_DRIVE
  5976                                  		;mov	al,'>'
  5977 0000139C B03E                    		mov	al,SYM
  5978 0000139E E85A00                  		call	PRINT_CHAR
  5979 000013A1 EB3A                    		jmp	short PP5
  5980                                  PP1:
  5981 000013A3 268A05                  		mov	al,[es:di]	; Get a char
  5982 000013A6 47                      		inc	di
  5983 000013A7 08C0                    		or	al,al
  5984 000013A9 7432                    		jz	short PP5	; Nul terminated
  5985 000013AB 3A06[F43E]              		cmp	al,[DOLLAR]	; Meta character
  5986 000013AF 7405                    		jz	short PP2	; Nope
  5987 000013B1 E84700                  		call	PRINT_CHAR
  5988 000013B4 EBED                    		jmp	short PP1
  5989                                  PP2:
  5990 000013B6 268A05                  		mov	al,[es:di]
  5991 000013B9 47                      		inc	di
  5992                                  		;mov	bx,CLSSTRING+2	; "[2J"
  5993 000013BA BB[9C3D]                		mov	bx,PROMPT_TABLE-3
  5994 000013BD 08C0                    		or	al,al
  5995 000013BF 741C                    		jz	short PP5
  5996                                  PP3:
  5997 000013C1 83C303                  		add	bx,3
  5998                                  		;call	UPCONV
  5999 000013C4 E85704                  		call	UPCONV_MAPCALL
  6000 000013C7 3A07                    		cmp	al,[bx]
  6001 000013C9 7407                    		jz	short PP4
  6002 000013CB 803F00                  		cmp	byte [bx],0
  6003 000013CE 75F1                    		jnz	short PP3
  6004 000013D0 EBD1                    		jmp	short PP1
  6005                                  PP4:
  6006 000013D2 06                      		push	es
  6007 000013D3 57                      		push	di
  6008 000013D4 0E                      		push	cs
  6009 000013D5 07                      		pop	es
  6010 000013D6 FF5701                  		call	word [bx+1]
  6011 000013D9 5F                      		pop	di
  6012 000013DA 07                      		pop	es
  6013 000013DB EBC6                    		jmp	short PP1
  6014                                  PP5:
  6015 000013DD 07                      		pop	es		; Restore segments
  6016 000013DE 1F                      		pop	ds
  6017 000013DF C3                      		retn
  6018                                  
  6019                                  ; ---------------------------------------------------------------------------
  6020                                  
  6021                                  PRINT_BACK:
  6022 000013E0 BA[943D]                		mov	dx,DBACKPTR
  6023 000013E3 E9ED20                  		jmp	STD_PRINTF
  6024                                  
  6025                                  ; ---------------------------------------------------------------------------
  6026                                  
  6027                                  PRINT_EQ:
  6028 000013E6 B03D                    		mov	al,'='
  6029 000013E8 EB11                    		jmp	short PRINT_CHAR
  6030                                  
  6031                                  ; ---------------------------------------------------------------------------
  6032                                  
  6033                                  PRINT_ESC:
  6034 000013EA B01B                    		mov	al,1Bh
  6035 000013EC EB0D                    		jmp	short PRINT_CHAR
  6036                                  
  6037                                  ; ---------------------------------------------------------------------------
  6038                                  
  6039                                  PRINT_G:
  6040 000013EE A0[F33E]                		mov	al,[RABRACKET]
  6041 000013F1 EB08                    		jmp	short PRINT_CHAR
  6042                                  
  6043                                  ; ---------------------------------------------------------------------------
  6044                                  
  6045                                  PRINT_L:
  6046 000013F3 A0[F23E]                		mov	al,[LABRACKET]
  6047 000013F6 EB03                    		jmp	short PRINT_CHAR
  6048                                  
  6049                                  ; ---------------------------------------------------------------------------
  6050                                  
  6051                                  PRINT_B:
  6052 000013F8 A0[F13E]                		mov	al,[VBAR]
  6053                                  
  6054                                  ; =============== S U B	R O U T	I N E =======================================
  6055                                  
  6056                                  PRINT_CHAR:
  6057                                  		; MSDOS 6.0
  6058                                  
  6059                                  ;	Bugbug:	Why bother with ds,es here?
  6060                                  		
  6061                                  		;push	es
  6062                                  		;push	ds
  6063                                  		;pop	es
  6064                                  		;push	di
  6065                                  		;push	dx
  6066                                  		;mov	dl,al		;AC000; Get char into al
  6067                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6068                                  		;int	21h		;AC000;
  6069                                  		;pop	dx
  6070                                  		;pop	di
  6071                                  		;pop	es
  6072                                  		;retn
  6073                                  
  6074                                  		; MSDOS 3.3
  6075 000013FB 06                      		push	es
  6076 000013FC 1E                      		push	ds
  6077 000013FD 07                      		pop	es
  6078 000013FE 57                      		push	di
  6079 000013FF 52                      		push	dx
  6080 00001400 BF[6144]                		mov	di,ONE_CHAR_VAL	
  6081 00001403 AA                      		stosb
  6082 00001404 BA[303B]                		mov	dx,ONECHRVALPTR
  6083 00001407 E8C920                  		call	STD_PRINTF
  6084 0000140A 5A                      		pop	dx
  6085 0000140B 5F                      		pop	di
  6086 0000140C 07                      		pop	es
  6087 0000140D C3                      		retn
  6088                                  
  6089                                  ; ---------------------------------------------------------------------------
  6090                                  
  6091                                  PRINT_DRIVE:
  6092 0000140E B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6093 00001410 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6094                                  		;add	al,'A'
  6095 00001412 0206[F03E]              		add	al,[CAPITAL_A]
  6096 00001416 E8E2FF                  		call	PRINT_CHAR
  6097 00001419 C3                      		retn
  6098                                  
  6099                                  ; ---------------------------------------------------------------------------
  6100                                  
  6101                                  BUILD_DIR_FOR_PROMPT:
  6102 0000141A 30D2                    		xor	dl,dl
  6103 0000141C BE[6A43]                		mov	si,BWDBUF
  6104 0000141F 89F7                    		mov	di,si
  6105 00001421 A0[8542]                		mov	al,[CURDRV]
  6106 00001424 0441                    		add	al,'A'
  6107 00001426 B43A                    		mov	ah,':'
  6108 00001428 AB                      		stosw
  6109 00001429 A0[7642]                		mov	al,[DIRCHAR]
  6110 0000142C AA                      		stosb
  6111 0000142D 87F7                    		xchg	si,di
  6112 0000142F 893E[4E44]              		mov	[STRING_PTR_2],di
  6113 00001433 B447                    		mov	ah,CURRENT_DIR ; 47h
  6114 00001435 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6115                                  				; DL = drive (0=default,1=A,etc.)
  6116                                  				; DS:SI	points to 64-byte buffer area
  6117 00001437 BA[3F37]                		mov	dx,STRINGBUF2PTR
  6118 0000143A 7303                    		jnc	short DOPRINT
  6119 0000143C BA[EB39]                		mov	dx,BADCURDRVPTR
  6120                                  DOPRINT:
  6121 0000143F E89120                  		call	STD_PRINTF
  6122 00001442 C3                      		retn
  6123                                  
  6124                                  ; =============== S U B	R O U T	I N E =======================================
  6125                                  
  6126                                  BUILD_DIR_FOR_CHDIR:
  6127 00001443 E80E00                  		call	BUILD_DIR_STRING
  6128 00001446 BA[6A43]                		mov	dx,DIRBUF
  6129 00001449 8916[4E44]              		mov	[STRING_PTR_2],dx
  6130                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6131 0000144D BA[3F37]                		mov	dx,STRINGBUF2PTR
  6132 00001450 E88020                  		call	STD_PRINTF
  6133 00001453 C3                      		retn
  6134                                  
  6135                                  
  6136                                  ; =============== S U B	R O U T	I N E =======================================
  6137                                  
  6138                                  BUILD_DIR_STRING:
  6139 00001454 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6140 00001458 88D0                    		mov	al,dl
  6141 0000145A 0440                    		add	al,'@'
  6142 0000145C 3C40                    		cmp	al,'@'
  6143 0000145E 7506                    		jnz	short GOTDRIVE
  6144 00001460 0206[8542]              		add	al,[CURDRV]
  6145 00001464 FEC0                    		inc	al
  6146                                  GOTDRIVE:
  6147 00001466 50                      		push	ax
  6148 00001467 BE[6D43]                		mov	si,BWDBUF+3
  6149 0000146A B447                    		mov	ah,CURRENT_DIR ; 47h
  6150 0000146C CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6151                                  				; DL = drive (0=default,1=A,etc.)
  6152                                  				; DS:SI	points to 64-byte buffer area
  6153 0000146E 7305                    		jnc	short DPBISOK
  6154 00001470 0E                      		push	cs
  6155 00001471 1F                      		pop	ds
  6156 00001472 E96306                  		jmp	DRVBAD
  6157                                  DPBISOK:
  6158 00001475 BF[6A43]                		mov	di,BWDBUF
  6159 00001478 89FA                    		mov	dx,di
  6160 0000147A 58                      		pop	ax
  6161 0000147B B43A                    		mov	ah,':'
  6162 0000147D AB                      		stosw
  6163 0000147E A0[7642]                		mov	al,[DIRCHAR]
  6164 00001481 AA                      		stosb
  6165 00001482 C3                      		retn
  6166                                  
  6167                                  ; ---------------------------------------------------------------------------
  6168                                  
  6169                                  PATH:
  6170                                  		; MSDOS 6.0
  6171                                  		;xor	al,al		;AN049; Set up holding buffer
  6172                                  		;mov	di,offset Trangroup:srcxname
  6173                                  					;AN049;   for PATH while parsing
  6174                                  		;stosb				;AN049; Initialize PATH to null
  6175                                  		;dec	di			;AN049; point to the start of buffer
  6176                                  		;invoke	PGetarg 		; Pre scan for arguments
  6177                                  		;jz	disppath		; Print the current path
  6178                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6179                                  		;jnz	pathslp 		;AC049;
  6180                                  		;inc	si			;AN049; point past semicolon
  6181                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6182                                  ;pathslp:					; Get the user specified path
  6183                                  		;lodsb				; Get a character
  6184                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6185                                  		;jz	path_eol		;AC049; yes - end of command
  6186                                  		;invoke	testkanj		;See if DBCS
  6187                                  		;jz	notkanj2		;No - continue
  6188                                  		;stosb				;AC049; Yes - store the first byte
  6189                                  		;lodsb				;skip second byte of DBCS
  6190                                  ;path_hold:					;AN049;
  6191                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6192                                  		;jmp	short pathslp		;continue parsing
  6193                                  ;notkanj2:
  6194                                  		;invoke	upconv			;upper case the character
  6195                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6196                                  		;jz	path_hold		;AC049; go store it
  6197                                  		;invoke	delim			;delimiter?
  6198                                  		;jnz	path_hold		;AC049; no - go store character
  6199                                  ;scan_white:					;AN049; make sure were at EOL
  6200                                  		;lodsb				;AN049; get a character
  6201                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6202                                  		;jz	path_eol		;AN049; yes - go set path
  6203                                  		;cmp	al,blank		;AN049; whitespace?
  6204                                  		;jz	scan_white		;AN049; yes - continue scanning
  6205                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6206                                  		;jz	scan_white		;AN049; yes - continue scanning
  6207                                  
  6208                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6209                                  						;AN049; no - set up error message
  6210                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6211                                  						;AN049; get "Too many parameters" message number
  6212                                  		;mov	msg_disp_class,parse_msg_class
  6213                                  						;AN049; set up parse error msg class
  6214                                  		;jmp	cerror			;AN049;
  6215                                  ;path_eol:					;AN049; Parsing was clean
  6216                                  		;xor	al,al			;AN049; null terminate the PATH
  6217                                  		;stosb				;AN049;    buffer
  6218                                  		;invoke	find_path		;AN049; Find PATH in environment
  6219                                  		;invoke	delete_path		;AC049; Delete any offending name
  6220                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6221                                  		;invoke	move_name		;AC049; move in PATH=
  6222                                  		;mov	si,offset Trangroup:srcxname	
  6223                                  						;AN049; Set up source as PATH buffer
  6224                                  ;store_path:					;AN049; Store the PATH in the environment
  6225                                  		;lodsb				;AN049; Get a character
  6226                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6227                                  		;jz	got_paths		;AN049; yes - exit
  6228                                  		;invoke	store_char		;AN049; no - store character
  6229                                  		;jmp	short store_path	;AN049; continue
  6230                                  ;got_paths:					;AN049; we're finished
  6231                                  		;xor	ax,ax			;	null terminate the PATH in
  6232                                  		;stosw				;    	the environment
  6233                                  		;return
  6234                                  ;disppath:
  6235                                  		;invoke	find_path		;AN049;
  6236                                  		;call	print_path
  6237                                  		;call	crlf2
  6238                                  		;retn
  6239                                  
  6240                                  		; MSDOS 3.3
  6241 00001483 E80903                  		call	FIND_PATH		; Find PATH in environment
  6242 00001486 E86209                  		call	PGETARG			; Pre scan for arguments
  6243 00001489 742A                    		jz	short DISPPATH		; Print the current path
  6244 0000148B E8DF02                  		call	DELETE_PATH		; Delete any offending name
  6245 0000148E E86B03                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6246 00001491 E84903                  		call	MOVE_NAME		; Move in PATH=
  6247 00001494 E85409                  		call	PGETARG
  6248 00001497 3C3B                    		cmp	al,';'
  6249 00001499 7416                    		jz	short GOTPATHS
  6250                                  PATHSLP:
  6251 0000149B AC                      		lodsb
  6252 0000149C 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6253 0000149E 7411                    		jz	short GOTPATHS		; yes - exit
  6254                                  		;call	UPCONV
  6255 000014A0 E87B03                  		call	UPCONV_MAPCALL		; convert to uppercase
  6256 000014A3 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6257 000014A5 7405                    		jz	short NOTDELIM		; go set path
  6258 000014A7 E8D704                  		call	DELIM			; is it delim/null char ?
  6259 000014AA 7405                    		jz	short GOTPATHS		; yes - exit
  6260                                  NOTDELIM:
  6261 000014AC E88303                  		call	STORE_CHAR		; no - store character
  6262 000014AF EBEA                    		jmp	short PATHSLP
  6263                                  GOTPATHS:
  6264 000014B1 31C0                    		xor	ax,ax			; null terminate the PATH
  6265 000014B3 AB                      		stosw				; in the environment
  6266 000014B4 C3                      		retn
  6267                                  DISPPATH:
  6268 000014B5 E80400                  		call	PRINT_PATH
  6269 000014B8 E8B104                  		call	CRLF2
  6270 000014BB C3                      		retn
  6271                                  
  6272                                  ; =============== S U B	R O U T	I N E =======================================
  6273                                  
  6274                                  PRINT_PATH:
  6275 000014BC 26803D00                		cmp	byte [es:di],0
  6276 000014C0 750A                    		jnz	short PATH1
  6277                                  PATH0:
  6278 000014C2 BA[0B3C]                		mov	dx,NULLPATHPTR
  6279 000014C5 0E                      		push	cs
  6280 000014C6 07                      		pop	es
  6281 000014C7 0E                      		push	cs
  6282 000014C8 1F                      		pop	ds
  6283 000014C9 E90720                  		jmp	STD_PRINTF
  6284                                  PATH1:
  6285 000014CC 06                      		push	es
  6286 000014CD 1F                      		pop	ds
  6287 000014CE 83EF05                  		sub	di,5
  6288 000014D1 89FE                    		mov	si,di
  6289 000014D3 E84003                  		call	SCASB2		; Look for null
  6290 000014D6 81F9FF00                		cmp	cx,0FFh
  6291 000014DA 74E6                    		jz	short PATH0
  6292 000014DC 0E                      		push	cs
  6293 000014DD 07                      		pop	es
  6294 000014DE BF[C843]                		mov	di,ARG_BUF
  6295 000014E1 BA0001                  		mov	dx,100h
  6296 000014E4 29CA                    		sub	dx,cx
  6297 000014E6 87D1                    		xchg	dx,cx
  6298 000014E8 F3A4                    		rep movsb
  6299 000014EA BA[2337]                		mov	dx,ARG_BUF_PTR
  6300 000014ED 0E                      		push	cs
  6301 000014EE 1F                      		pop	ds
  6302 000014EF E9E11F                  		jmp	STD_PRINTF
  6303                                  
  6304                                  ; ---------------------------------------------------------------------------
  6305                                  
  6306                                  ; ****************************************************************
  6307                                  ; *
  6308                                  ; * ROUTINE:	 CLS
  6309                                  ; *
  6310                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6311                                  ; *		 installed, send a control string to clear the
  6312                                  ; *		 screen.
  6313                                  ; *
  6314                                  ; * INPUT:	 command line at offset 81H
  6315                                  ; *
  6316                                  ; * OUTPUT:	 none
  6317                                  ; *
  6318                                  ; ****************************************************************
  6319                                  
  6320                                  ; MSDOS 3.3
  6321                                  
  6322                                  CLS:
  6323 000014F2 BB0100                  		mov	bx,STDOUT ; 1
  6324 000014F5 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6325 000014F8 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6326                                  				; BX = file or device handle
  6327 000014FA F6C280                  		test	dl,80h	; devid_ISDEV
  6328 000014FD 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6329 000014FF F6C210                  		test	dl,10h  ; devid_SPECIAL
  6330 00001502 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6331                                  
  6332 00001504 B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6333 00001507 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6334                                  				; AL = interrupt number
  6335                                  				; Return: ES:BX	= value	of interrupt vector
  6336 00001509 8CC2                    		mov	dx,es
  6337 0000150B B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6338 0000150E CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6339                                  				; AL = interrupt number
  6340                                  				; Return: ES:BX	= value	of interrupt vector
  6341 00001510 8CC0                    		mov	ax,es
  6342 00001512 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6343 00001514 7735                    		ja	short ANSICLS
  6344                                  
  6345 00001516 B40F                    		mov	ah,0Fh
  6346 00001518 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6347                                  				; Return: AH = number of columns on screen
  6348                                  				; AL = current video mode
  6349                                  				; BH = current active display page
  6350 0000151A 3C03                    		cmp	al,3
  6351 0000151C 7609                    		jbe	short DOALPHA
  6352 0000151E 3C07                    		cmp	al,7
  6353 00001520 7405                    		jz	short DOALPHA
  6354 00001522 B400                    		mov	ah,0
  6355 00001524 CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6356                                  				; AL = mode
  6357 00001526 C3                      		retn
  6358                                  
  6359                                  DOALPHA:
  6360 00001527 B40B                    		mov	ah,0Bh	; Set overscan to black
  6361 00001529 31DB                    		xor	bx,bx
  6362 0000152B CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6363                                  				; BH = 00h, BL = border color
  6364                                  				; BH = 01h, BL = palette (0-3)
  6365 0000152D B40F                    		mov	ah,0Fh
  6366 0000152F CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6367                                  				; Return: AH = number of columns on screen
  6368                                  				; AL = current video mode
  6369                                  				; BH = current active display page
  6370 00001531 88E2                    		mov	dl,ah
  6371 00001533 FECA                    		dec	dl
  6372 00001535 B618                    		mov	dh,24
  6373 00001537 31C0                    		xor	ax,ax
  6374 00001539 89C1                    		mov	cx,ax
  6375 0000153B BB0007                  		mov	bx,700h
  6376 0000153E B406                    		mov	ah,6
  6377 00001540 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6378                                  				; AL = number of lines to scroll window	
  6379                                  				;	(0 = blank whole window)
  6380                                  				; BH = attributes to be	used on	blanked	lines
  6381                                  				; CH,CL	= row,column of	upper left corner of window 
  6382                                  				;	  to scroll
  6383                                  				; DH,DL	= row,column of	lower right corner of window
  6384 00001542 31D2                    		xor	dx,dx
  6385 00001544 B700                    		mov	bh,0
  6386 00001546 B402                    		mov	ah,2
  6387 00001548 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6388                                  				; DH,DL	= row,column (0,0 = upper left)
  6389                                  				; BH = page number
  6390 0000154A C3                      		retn
  6391                                  
  6392                                  ANSICLS:
  6393 0000154B BE[9A3D]                		mov	si,CLSSTRING
  6394 0000154E AC                      		lodsb
  6395 0000154F 88C1                    		mov	cl,al
  6396 00001551 30ED                    		xor	ch,ch
  6397 00001553 B406                    		mov	ah,RAW_CON_IO ; 6
  6398                                  CLRLOOP:
  6399 00001555 AC                      		lodsb
  6400 00001556 88C2                    		mov	dl,al
  6401 00001558 CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6402                                  				; DL = character <> FFh
  6403                                  				;  Return: ZF set = no character
  6404                                  				;   ZF clear = character recieved, AL = character
  6405 0000155A E2F9                    		loop	CLRLOOP
  6406 0000155C C3                      		retn
  6407                                  
  6408                                  ; ---------------------------------------------------------------------------
  6409                                  
  6410                                  ; MSDOS 6.0
  6411                                  
  6412                                  ;ANSI_installed		equ    0ffh
  6413                                  ;
  6414                                  ;CLS:
  6415                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6416                                  ;	mov	al,0			;AN000;
  6417                                  ;	int	2fh			;AN000;
  6418                                  ;	cmp	al,ANSI_installed	;AN000;
  6419                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6420                                  ;
  6421                                  ;check_lines:
  6422                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6423                                  ;					;AN000; get lines per page on display
  6424                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6425                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6426                                  ;	mov	cl,get_generic		;AN000; get information
  6427                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6428                                  ;	int	21h			;AN000;
  6429                                  ;	jc	no_variable		;AN000; function had error, use default
  6430                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6431                                  ;	mov	dh,al			;AN000; set number of rows
  6432                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6433                                  ;	mov	dl,al			;AN000; set number of columns
  6434                                  ;	jmp	short regcls		;AN000; go do cls
  6435                                  ;
  6436                                  ;no_variable:
  6437                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6438                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6439                                  ;	int	21h			;AC000;
  6440                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6441                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6442                                  ;	test	dl,devid_SPECIAL	;AC000;
  6443                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6444                                  ;
  6445                                  ;ansicls:
  6446                                  ;	call	ansi_cls		;AN000; clear the screen
  6447                                  ;	jmp	short cls_ret		;AN000; exit
  6448                                  ;
  6449                                  ;;
  6450                                  ;; Get video mode
  6451                                  ;;
  6452                                  ;
  6453                                  ;cls_normal:				;AC000;
  6454                                  ;
  6455                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6456                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6457                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6458                                  ;	jbe	DoAlpha
  6459                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6460                                  ;	jz	DoAlpha
  6461                                  ;;
  6462                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6463                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6464                                  ;; screen too.
  6465                                  ;;
  6466                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6467                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6468                                  ;	jmp	short cls_ret		;AC000; exit
  6469                                  ;
  6470                                  ;DoAlpha:
  6471                                  ;;
  6472                                  ;; Get video mode and number of columns to scroll
  6473                                  ;;
  6474                                  ;
  6475                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6476                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6477                                  ;;M01   area
  6478                                  ;;M01   Commented out code here is the original
  6479                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6480                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6481                                  ;;M01	mov	dl,ah
  6482                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6483                                  ;
  6484                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6485                                  ;
  6486                                  ;	push	ds
  6487                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6488                                  ;	MOV	DS,AX			;  *			M01
  6489                                  ;	Assume	DS:ROMBIOS_DATA
  6490                                  ;
  6491                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6492                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6493                                  ;	pop	ds			;			M01
  6494                                  ;	Assume	DS:Trangroup
  6495                                  ;
  6496                                  ;	or	dh,dh			; Q:ZERO		M01
  6497                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6498                                  ;
  6499                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6500                                  ;
  6501                                  ;regcls:
  6502                                  ;	inc	dh			; height+1		M018
  6503                                  ;	call	reg_cls 		; go clear the screen
  6504                                  ;
  6505                                  ;cls_ret:
  6506                                  ;	ret				; exit
  6507                                  
  6508                                  ; ---------------------------------------------------------------------------
  6509                                  
  6510                                  ; MSDOS 6.0
  6511                                  
  6512                                  ; ****************************************************************
  6513                                  ; *
  6514                                  ; * ROUTINE:	 REG_CLS
  6515                                  ; *
  6516                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6517                                  ; *
  6518                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6519                                  ; *		 DH = NUMBER OF ROWS
  6520                                  ; *
  6521                                  ; * OUTPUT:	 none
  6522                                  ; *
  6523                                  ; ****************************************************************
  6524                                  
  6525                                  ;reg_cls proc	near
  6526                                  ;
  6527                                  ;;
  6528                                  ;; Set overscan to black.
  6529                                  ;;
  6530                                  ;	dec	dh			;  decrement rows and columns
  6531                                  ;	dec	dl			;     to zero base
  6532                                  ;	push	dx			;  save rows,columns
  6533                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6534                                  ;	xor	bx,bx
  6535                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6536                                  ;	pop	dx			;  retore rows,colums
  6537                                  ;
  6538                                  ;	xor	ax,ax			;  zero out ax
  6539                                  ;	mov	CX,ax			;     an cx
  6540                                  ;;
  6541                                  ;; Scroll active page
  6542                                  ;;
  6543                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6544                                  ;	mov	bh,video_attribute	; attribute for blank line
  6545                                  ;	xor	bl,bl			; set BL to 0
  6546                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6547                                  ;;
  6548                                  ;; Seek to cursor to 0,0
  6549                                  ;;
  6550                                  ;;M022 following two lines added
  6551                                  ;	mov	ah,get_video_state	; get current video page in BH
  6552                                  ;	int	video_io_int
  6553                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6554                                  ;	xor	dx,dx			; row and column 0
  6555                                  ;;M022	mov	bh.0
  6556                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6557                                  ;
  6558                                  ;	ret
  6559                                  ;
  6560                                  ;reg_cls endp
  6561                                  
  6562                                  ; ---------------------------------------------------------------------------
  6563                                  
  6564                                  ; MSDOS 6.0
  6565                                  
  6566                                  ; ****************************************************************
  6567                                  ; *
  6568                                  ; * ROUTINE:	 ANSI_CLS
  6569                                  ; *
  6570                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6571                                  ; *		 to STDOUT.
  6572                                  ; *
  6573                                  ; * INPUT:	 none
  6574                                  ; *
  6575                                  ; * OUTPUT:	 none
  6576                                  ; *
  6577                                  ; ****************************************************************
  6578                                  
  6579                                  ;ansi_cls proc	near			;AC000;
  6580                                  ;
  6581                                  ;	mov	si,offset trangroup:clsstring
  6582                                  ;	lodsb
  6583                                  ;	mov	cl,al
  6584                                  ;	xor	ch,ch
  6585                                  ;	mov	ah,Raw_CON_IO
  6586                                  ;clrloop:
  6587                                  ;	lodsb
  6588                                  ;	mov	DL,al
  6589                                  ;	int	21h
  6590                                  ;	loop	clrloop
  6591                                  ;	return
  6592                                  ;
  6593                                  ;ansi_cls	endp			;AC000;
  6594                                  
  6595                                  ;============================================================================
  6596                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6597                                  ;============================================================================
  6598                                  ; 08/10/2018 - Retro DOS v3.0
  6599                                  
  6600                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6601                                  
  6602                                  ; ---------------------------------------------------------------------------
  6603                                  
  6604                                  ; ****************************************************************
  6605                                  ; *
  6606                                  ; * ROUTINE:	 CTTY - Change console
  6607                                  ; *
  6608                                  ; * SYNTAX:	 CTTY device
  6609                                  ; *
  6610                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6611                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6612                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6613                                  ; *
  6614                                  ; * INPUT:	 command line at offset 81H
  6615                                  ; *
  6616                                  ; * OUTPUT:	 none
  6617                                  ; *
  6618                                  ; ****************************************************************
  6619                                  
  6620                                  CTTY:
  6621                                  		; MSDOS 6.0
  6622                                  		;push	ds			;AN000; Get local ES
  6623                                  		;pop	es			;AN000;
  6624                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6625                                  
  6626                                  		;mov	di,offset trangroup:parse_ctty	
  6627                                  						;AC000; Get adderss of PARSE_CTTY
  6628                                  		;xor	cx,cx			;AC000; clear cx,dx
  6629                                  		;xor	dx,dx			;AC000;
  6630                                  		;invoke	cmd_parse		;AC000; call parser
  6631                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6632                                  		;jz	ctty_error		;AN000; yes - error
  6633                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6634                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6635                                  
  6636                                  		;push	si			;AN000; save position in line
  6637                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6638                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6639                                  
  6640                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6641                                  		;lodsb				;AN000; get a char from buffer
  6642                                  		;stosb				;AN000; store in srcbuf
  6643                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6644                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6645                                  		;pop	si			;AN000; get line position back
  6646                                  		;mov	di,offset trangroup:parse_ctty	
  6647                                  						;AC000; Get adderss of PARSE_CTTY
  6648                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6649                                  		;jz	nocolon 		;AN000; yes - continue
  6650                                  
  6651                                  ;ctty_error:
  6652                                  		;jmp	short isbaddev		;AC000; yes - exit
  6653                                  
  6654                                  		; MSDOS 3.3
  6655 0000155D E81708                  		call	SETPATH
  6656 00001560 4E                      		dec	si
  6657 00001561 4E                      		dec	si
  6658 00001562 803C3A                  		cmp	byte [si],':'
  6659 00001565 7503                    		jnz	short NOCOLON
  6660 00001567 C60400                  		mov	byte [si],0
  6661                                  NOCOLON:
  6662                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6663                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6664 0000156A B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6665 0000156D CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6666                                  				; DS:DX	-> ASCIZ filename
  6667                                  				; AL = access mode
  6668                                  				; 2 - read & write
  6669 0000156F 7210                    		jc	short ISBADDEV
  6670 00001571 89C3                    			mov	bx,ax
  6671 00001573 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6672 00001576 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6673                                  				; BX = file or device handle
  6674 00001578 F6C280                  		test	dl,80h
  6675 0000157B 750C                    		jnz	short DEVISOK
  6676                                  CLOSEDEV:
  6677 0000157D B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6678 0000157F CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6679                                  				; BX = file handle
  6680                                  ISBADDEV:
  6681 00001581 BA[533C]                		mov	dx,BADDEVPTR
  6682 00001584 E84C1F                  		call	STD_PRINTF
  6683 00001587 EB28                    		jmp	short RESRET
  6684                                  
  6685                                  		;nop
  6686                                  DEVISOK:
  6687                                  		; MSDOS 6.0
  6688                                  		;push	dx		;AN007; save device info
  6689                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6690                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6691                                  		;push	bx		;AN021; save handle
  6692                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6693                                  		;mov	dx,si		;AN021; get address into dx
  6694                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6695                                  		;mov	cx,2		;AN007; write two bytes
  6696                                  		;int	21h		;AN007;
  6697                                  		;pop	bx		;AN021; get back handle
  6698                                  		;pop	dx		;AN007; get back device info
  6699                                  		;jc	closedev	;AN007; if error, quit
  6700                                  
  6701                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6702 00001589 30F6                    		xor	dh,dh
  6703 0000158B 80CA03                  		or	dl,3
  6704                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6705 0000158E B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6706 00001591 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6707                                  				; BX = device handle,DH = 0
  6708                                  				; DL = device information to set 
  6709                                  				;		(bits 0-7 from	function 0)
  6710 00001593 53                      		push	bx
  6711 00001594 B90300                  		mov	cx,3
  6712 00001597 31DB                    		xor	bx,bx
  6713                                  
  6714                                  ICLLOOP:				; Close basic handles
  6715 00001599 B43E                    		mov	ah,CLOSE ; 3Eh
  6716 0000159B CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6717                                  				; BX = file handle
  6718 0000159D 43                      		inc	bx
  6719 0000159E E2F9                    		loop	ICLLOOP
  6720 000015A0 5B                      		pop	bx		; Get handle
  6721 000015A1 B445                    		mov	ah,XDUP ; 45h
  6722 000015A3 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6723                                  				; BX = file handle to duplicate
  6724 000015A5 B445                    		mov	ah,XDUP ; 45h
  6725 000015A7 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6726                                  				; BX = file handle to duplicate
  6727 000015A9 B445                    		mov	ah,XDUP ;45h
  6728 000015AB CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6729                                  				; BX = file handle to duplicate
  6730 000015AD B43E                    		mov	ah,CLOSE ; 3Eh
  6731 000015AF CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6732                                  				; BX = file handle
  6733                                  RESRET:
  6734 000015B1 8E1E[7142]              		mov	ds,[RESSEG]
  6735 000015B5 1E                      		push	ds
  6736 000015B6 A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6737 000015B9 A3F10B                  		mov	word [IO_SAVE],ax
  6738                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6739                                  		;mov	ax,31Eh ;  MSDOS 3.3
  6740 000015BC B81903                  		mov	ax,LODCOM1
  6741 000015BF 50                      		push	ax
  6742                                  
  6743 000015C0 CB                      		retf		; Far return
  6744                                  
  6745                                  ; ---------------------------------------------------------------------------
  6746                                  
  6747                                  ;****************************************************************
  6748                                  ;*
  6749                                  ;* ROUTINE:	CHCP - Change code page internal command
  6750                                  ;*		(added DOS 3.30 07/21/86)
  6751                                  ;*
  6752                                  ;* SYNTAX:	CHCP [xxx]
  6753                                  ;*		where xxx is a valid code page
  6754                                  ;*
  6755                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6756                                  ;*		6402H to set the code page to xxxx. If no parameters
  6757                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6758                                  ;*		to get global code page and display it to the user.
  6759                                  ;*
  6760                                  ;* INPUT:	command line at offset 81H
  6761                                  ;*
  6762                                  ;* OUTPUT:	none
  6763                                  ;*
  6764                                  ;****************************************************************
  6765                                  
  6766                                  ;NLSFUNC_installed equ  0FFh
  6767                                  set_global_cp	  equ   2
  6768                                  get_global_cp	  equ   1
  6769                                  
  6770                                  CHCP:
  6771                                  		; MSDOS 6.0
  6772                                  		;push	ds		;AN000; Get local ES
  6773                                  		;pop	es		;AN000;
  6774                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6775                                  
  6776                                  		;mov	di,offset trangroup:parse_chcp	
  6777                                  					;AN000; Get adderss of PARSE_CHCP
  6778                                  		;xor	cx,cx		;AC000; clear cx,dx
  6779                                  		;xor	dx,dx		;AC000;
  6780                                  		;call	parse_with_msg	;AC018; call parser
  6781                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6782                                  
  6783                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6784                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6785                                  ;setcp:
  6786                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6787                                  		;jne	cp_error	;AC018; yes - go issue message
  6788                                  
  6789                                  		;push	cx		;AN000; save positional count
  6790                                  		;mov	bx,offset trangroup:parse1_addr 
  6791                                  					;AN000; get number returned
  6792                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6793                                  		;mov	system_cpage,cx ;AN000; save user input number
  6794                                  		;pop	cx		;AC000; restore positional count
  6795                                  		;mov	di,offset trangroup:parse_chcp	
  6796                                  					;AN000; Get adderss of PARSE_CHCP
  6797                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6798                                  		;jnz	cp_error	;AC000; no - exit
  6799                                  ;okset:
  6800                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6801                                  		;mov	al,0		;AN000;
  6802                                  		;int	2fh		;AN000;
  6803                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6804                                  		;jz	got_NLS 	;AN000; Yes - continue
  6805                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6806                                  					;AN000; no - set up error message
  6807                                  		;jmp	short cp_error	;AN000; error exit
  6808                                  ;got_NLS:
  6809                                  
  6810                                  		; MSDOS 3.3
  6811 000015C1 BE8100                  		mov	si,81h
  6812 000015C4 E8B203                  		call	SCANOFF
  6813 000015C7 3C0D                    		cmp	al,0Dh ; CR
  6814 000015C9 7502                    		jnz	short SETCP
  6815 000015CB EB72                    		jmp	short GETCP
  6816                                  
  6817                                  		;nop
  6818                                  SETCP:
  6819 000015CD 31DB                    		xor	bx,bx
  6820 000015CF 89D9                    		mov	cx,bx
  6821 000015D1 89D8                    		mov	ax,bx
  6822                                  GET_CP_DIGIT:
  6823 000015D3 AC                      		lodsb
  6824 000015D4 3C30                    		cmp	al,'0'
  6825 000015D6 721C                    		jb	short CHRNOTNUMBER
  6826 000015D8 3C39                    		cmp	al,'9'
  6827 000015DA 7718                    		ja	short CHRNOTNUMBER
  6828 000015DC 2C30                    		sub	al,'0'
  6829 000015DE FEC1                    		inc	cl
  6830 000015E0 80F904                  		cmp	cl,4
  6831 000015E3 771B                    		ja	short CHCP_BADPARM
  6832 000015E5 89DA                    		mov	dx,bx
  6833 000015E7 D1E2                    		shl	dx,1
  6834 000015E9 D1E2                    		shl	dx,1
  6835 000015EB 01D3                    		add	bx,dx
  6836 000015ED D1E3                    		shl	bx,1
  6837 000015EF 01C3                    		add	bx,ax
  6838 000015F1 EBE0                    		jmp	short GET_CP_DIGIT
  6839                                  CP_NEXTCHR:
  6840 000015F3 AC                      		lodsb
  6841                                  CHRNOTNUMBER:
  6842 000015F4 3C20                    		cmp	al,' '		; SPACE
  6843 000015F6 74FB                    		jz	short CP_NEXTCHR
  6844 000015F8 3C09                    		cmp	al,9		; TAB
  6845 000015FA 74F7                    		jz	short CP_NEXTCHR
  6846 000015FC 3C0D                    		cmp	al,0Dh		; CR
  6847 000015FE 7406                    		jz	short SET_CP_TBL_NUM
  6848                                  CHCP_BADPARM:
  6849 00001600 BA[223A]                		mov	dx,BADPARMPTR
  6850 00001603 E92306                  		jmp	CERROR
  6851                                  ;GOT_NLS:
  6852                                  SET_CP_TBL_NUM:
  6853                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6854 00001606 891E[0F3F]              		mov	word [SYSTEM_CPAGE],bx
  6855 0000160A B466                    		mov	ah,GETSETCDPG  ; 66h
  6856 0000160C B002                    		mov	al,set_global_cp ; 2
  6857 0000160E CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6858                                  				; BX = active code page
  6859                                  				; DX = system code page	(active	page at	boot time)
  6860 00001610 733D                    		jnc	short CHCP_RETURN
  6861                                  
  6862 00001612 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6863 00001615 7511                    		jnz	short CHCP_OTHER_ERROR
  6864                                  
  6865 00001617 B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6866 00001619 31DB                    		xor	bx,bx
  6867 0000161B CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6868                                  				; BX = version code (0000h for DOS 3.x)
  6869 0000161D 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6870 00001620 7417                    		jz	short NONE_SET
  6871 00001622 BA[F837]                		mov	dx,FNOTFOUNDPTR
  6872 00001625 E90106                  		jmp	CERROR
  6873                                  CHCP_OTHER_ERROR:			; end of p716
  6874 00001628 B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6875 0000162A 31DB                    		xor	bx,bx
  6876 0000162C CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6877                                  				; BX = version code (0000h for DOS 3.x)
  6878 0000162E 83F841                  		cmp	ax,65		;was it access denied?
  6879 00001631 7506                    		jnz	short NONE_SET	;no - assume all failed
  6880 00001633 BA[A839]                		mov	dx,CPNOTALLPTR	;set up message
  6881 00001636 E9F005                  		jmp	CERROR		;AC000; error exit
  6882                                  NONE_SET:
  6883 00001639 BA[7539]                		mov	dx,CPNOTSETPTR	;set up message
  6884                                  CP_ERROR:
  6885 0000163C E9EA05                  		jmp	CERROR		;exit
  6886                                  GETCP:
  6887 0000163F B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6888 00001641 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6889 00001643 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6890 00001645 891E[0F3F]              		mov	word [SYSTEM_CPAGE],bx ;get active cp for output
  6891 00001649 BA[C639]                		mov	dx,CPACTIVEPTR
  6892 0000164C E8841E                  		call	STD_PRINTF	;print it out
  6893                                  CHCP_RETURN:
  6894 0000164F C3                      		retn
  6895                                  
  6896                                  ; ---------------------------------------------------------------------------
  6897                                  
  6898                                  ; ****************************************************************
  6899                                  ; *
  6900                                  ; * ROUTINE:	 TRUENAME
  6901                                  ; *
  6902                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  6903                                  ; *		 Parses the command line. If a path is found, set
  6904                                  ; *		 SRCXNAME to path.  If only a drive letter is
  6905                                  ; *		 found, set SRCXNAME to the drive letter.  If
  6906                                  ; *		 no path is found, set the path of SRCXNAME to
  6907                                  ; *		 dot (.) for current directory.  Use the NAME
  6908                                  ; *		 TRANSLATE system call to get the real name and
  6909                                  ; *		 then display the real name.  If an error occurs
  6910                                  ; *		 issue an error message and transfer control to
  6911                                  ; *		 CERROR.
  6912                                  ; *
  6913                                  ; * INPUT:	 command line at offset 81H
  6914                                  ; *
  6915                                  ; * OUTPUT:	 none
  6916                                  ; *
  6917                                  ; ****************************************************************
  6918                                  
  6919                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  6920                                  ;
  6921                                  ;TRUENAME:					;AN000; TRUENAME entry point
  6922                                  ;	push	ds				;AN000; Get local ES
  6923                                  ;	pop	es				;AN000;
  6924                                  ;	mov	si,81H				;AN000; Get command line
  6925                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
  6926                                  ;	xor	cx,cx				;AN000; clear cx,dx
  6927                                  ;	xor	dx,dx				;AN000;
  6928                                  ;	call	parse_with_msg			;AC018; call parser
  6929                                  ;
  6930                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  6931                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  6932                                  ;	je	tn_eol				;AN000; yes - go process
  6933                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  6934                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  6935                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  6936                                  ;	je	tn_drive			;AN000; yes - go process
  6937                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  6938                                  ;
  6939                                  ;tn_eol: 					;AN000; no parameters on line
  6940                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  6941                                  ;	mov	al,dot_chr			;AN000;     for current dir
  6942                                  ;	stosw					;AN000; store in srcxname
  6943                                  ;	jmp	short tn_doit			;AN000; go do command
  6944                                  ;
  6945                                  ;tn_drive:					;AN000; a drive was entered
  6946                                  ;	push	si				;AN000; save position in line
  6947                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  6948                                  ;	lodsb					;AN000; get the drive number
  6949                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  6950                                  ;	stosb					;AN000; store it in srcxname
  6951                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  6952                                  ;	stosw					;AN000;    store in srcxname
  6953                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  6954                                  ;	stosb					;AN000;
  6955                                  ;	pop	si				;AN000; get line position back
  6956                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  6957                                  ;
  6958                                  ;tn_filespec:					;AN000; a filespec was entered
  6959                                  ;	push	si				;AN000; save position in line
  6960                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  6961                                  ;
  6962                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  6963                                  ;	lodsb					;AN000; get a char from buffer
  6964                                  ;	stosb					;AN000; store in srcxname
  6965                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  6966                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  6967                                  ;	pop	si				;AN000; get line position back
  6968                                  ;
  6969                                  ;tn_check_eol:					;AN000; make sure no extra parms
  6970                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  6971                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  6972                                  ;	je	tn_doit 			;AN000; Yes - do the command
  6973                                  ;
  6974                                  ;tn_parse_error: 				;AN000; A parse error occurred
  6975                                  ;	jmp	cerror				;AN000; Go to error routine
  6976                                  ;
  6977                                  ;tn_doit:					;AN000;
  6978                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  6979                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  6980                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  6981                                  ;	int	21h			;AN000;
  6982                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  6983                                  ;
  6984                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  6985                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  6986                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  6987                                  ;	jmp	cerror				;AN000; Go to error routine
  6988                                  ;
  6989                                  ;tn_print_xname: 				;AN000;
  6990                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  6991                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  6992                                  ;	invoke	crlf2				;AN000; print a crlf
  6993                                  ;	invoke	printf_crlf			;AN000; print it out
  6994                                  ;
  6995                                  ;	ret					;AN000;
  6996                                  ;
  6997                                  
  6998                                  ; ---------------------------------------------------------------------------
  6999                                  
  7000                                  _$EXIT:
  7001                                  		; MSDOS 3.3
  7002 00001650 8E06[7142]              		mov	es,[RESSEG]
  7003 00001654 26A18E0B                		mov	ax,word [es:PARENT]
  7004                                  		;mov	[es:16h],ax
  7005 00001658 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7006 0000165C 26A1900B                		mov	ax,word [es:OLDTERM]
  7007                                  		;mov	[es:0Ah],ax
  7008 00001660 26A30A00                		mov	[es:PDB.EXIT],ax
  7009 00001664 26A1920B                		mov	ax,word [es:OLDTERM+2]
  7010                                  		;mov	[es:0Ch],ax
  7011 00001668 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7012 0000166C 06                      		push	es
  7013 0000166D 8E06[8142]              		mov	es,[TRAN_TPA]
  7014 00001671 B449                    		mov	ah,DEALLOC ; 49h
  7015 00001673 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7016                                  				; ES = segment address of area to be freed
  7017 00001675 07                      		pop	es
  7018 00001676 B44C                    		mov	ah,EXIT ; 4Ch
  7019                                  		;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
  7020 00001678 26A0EC0B                		mov	al,byte [es:RETCODE]
  7021 0000167C CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7022                                  
  7023                                  ;;here:
  7024                                  ;;		jmp	short here
  7025                                  
  7026                                  		; MSDOS 6.0
  7027                                  		;push	ds			;AN000; save data segment
  7028                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7029                                  
  7030                                  		;assume	ds:resgroup		;AN000;
  7031                                  
  7032                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7033                                  		;jz	free_com		;AN045; no - free everything
  7034                                  
  7035                                  ;	We're a permanent command.
  7036                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7037                                  
  7038                                  		;cmp	[singlecom],-1		;M034
  7039                                  		;je	no_reset		;M034	;exit singlecom
  7040                                  
  7041                                  		;jmp	TCommand		;permanent command, recycle
  7042                                  
  7043                                  ;free_com:
  7044                                  		;mov	ax,(multdos shl 8 or message_2f)
  7045                                  						;AN060; reset parse message pointers
  7046                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7047                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7048                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7049                                  		;int	2fh			;AN000; go set it
  7050                                  ;no_reset:					;AN045;
  7051                                  		;pop	ds			;AN000; restore local data segment
  7052                                  
  7053                                  		;assume	ds:trangroup		;AN000;
  7054                                  ;
  7055                                  ;M040
  7056                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7057                                  ;this, restores user dir if flag is set and resets the flag.
  7058                                  ;
  7059                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7060                                  		;MOV	ES,[RESSEG]
  7061                                  
  7062                                  		;assume	es:resgroup
  7063                                  
  7064                                  		;MOV	AX,[PARENT]
  7065                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7066                                  		;MOV	AX,WORD PTR OldTerm
  7067                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7068                                  		;MOV	AX,WORD PTR OldTerm+2
  7069                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7070                                  
  7071                                  		;PUSH	ES
  7072                                  		;MOV	ES,[TRAN_TPA]
  7073                                  		;MOV	AH,DEALLOC
  7074                                  		;INT	21h			; Now running in "free" space
  7075                                  		;POP	ES
  7076                                  
  7077                                  		;MOV	AH,Exit
  7078                                  		;MOV	AL,BYTE PTR RetCode
  7079                                  		;INT	21h
  7080                                  
  7081                                  ; ---------------------------------------------------------------------------
  7082                                  
  7083                                  ; MSDOS 6.0
  7084                                  ; ****************************************************************
  7085                                  ; *
  7086                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7087                                  ; *
  7088                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7089                                  ; *		 If not end of line, set up to print parse
  7090                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7091                                  ; *		 EXPECTED!
  7092                                  ; *
  7093                                  ; * INPUT:	 DS:SI	  last output from parser
  7094                                  ; *		 ES:DI	  points to parse block
  7095                                  ; *		 CX	  last output from parser
  7096                                  ; *
  7097                                  ; * OUTPUT:	 AX	  parser return code
  7098                                  ; *
  7099                                  ; *		 if end of line found
  7100                                  ; *		     zero flag set
  7101                                  ; *		 else
  7102                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7103                                  ; *
  7104                                  ; ****************************************************************
  7105                                  
  7106                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7107                                  ;
  7108                                  ;parse_check_eol Proc near			;AN000;
  7109                                  ;
  7110                                  ;	xor	dx,dx				;AN000;
  7111                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7112                                  ;	invoke	cmd_parse			;AN000; call parser
  7113                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7114                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7115                                  ;
  7116                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7117                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7118                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7119                                  ;
  7120                                  ;ok_to_setup_pmsg:
  7121                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7122                                  ;
  7123                                  ;parse_good_eol:
  7124                                  ;	ret					;AN000;
  7125                                  ;
  7126                                  ;parse_check_eol endp				;AN000;
  7127                                  
  7128                                  ; ---------------------------------------------------------------------------
  7129                                  
  7130                                  ; MSDOS 6.0
  7131                                  ; ****************************************************************
  7132                                  ; *
  7133                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7134                                  ; *
  7135                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7136                                  ; *		 message is set up.
  7137                                  ; *
  7138                                  ; * INPUT:	 DS:SI	  last output from parser
  7139                                  ; *		 ES:DI	  points to parse block
  7140                                  ; *		 CX	  last output from parser
  7141                                  ; *
  7142                                  ; * OUTPUT:	 AX	  parser return code
  7143                                  ; *
  7144                                  ; *		 if no error
  7145                                  ; *		     outputs from parser
  7146                                  ; *		 else
  7147                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7148                                  ; *		     error message set up for STD_PRINTF
  7149                                  ; *
  7150                                  ; ****************************************************************
  7151                                  
  7152                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7153                                  ;
  7154                                  ;parse_with_msg	Proc near			;AN018;
  7155                                  ;
  7156                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7157                                  ;	invoke	cmd_parse			;AN018; call parser
  7158                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7159                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7160                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7161                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7162                                  ;
  7163                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7164                                  ;
  7165                                  ;parse_msg_good:
  7166                                  ;	ret					;AN018;
  7167                                  ;
  7168                                  ;parse_with_msg endp				;AN018;
  7169                                  
  7170                                  ; ---------------------------------------------------------------------------
  7171                                  
  7172                                  ; MSDOS 6.0
  7173                                  ; ****************************************************************
  7174                                  ; *
  7175                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7176                                  ; *
  7177                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7178                                  ; *		 message is set up.
  7179                                  ; *
  7180                                  ; * INPUT:	 AX	     Parse error number
  7181                                  ; *		 SI	     Set to past last parameter
  7182                                  ; *		 Parse_last  Set to start of last parameter
  7183                                  ; *
  7184                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7185                                  ; *		 error message set up for STD_PRINTF
  7186                                  ; *
  7187                                  ; ****************************************************************
  7188                                  
  7189                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7190                                  ;
  7191                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7192                                  ;
  7193                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7194                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7195                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7196                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7197                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7198                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7199                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7200                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7201                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7202                                  ;
  7203                                  ;setup_parse_msg_ret:
  7204                                  ;	inc	si				;AN018; make sure zero flag not set
  7205                                  ;
  7206                                  ;	ret					;AC018;
  7207                                  ;
  7208                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7209                                  
  7210                                  ;============================================================================
  7211                                  ; TENV.ASM, MSDOS 6.0, 1991
  7212                                  ;============================================================================
  7213                                  ; 08/10/2018 - Retro DOS v3.0
  7214                                  
  7215                                  ; TITLE	Part6 COMMAND Transient routines.
  7216                                  
  7217                                  ;	Environment utilities and misc. routines
  7218                                  
  7219                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7220                                  
  7221                                  ; ---------------------------------------------------------------------------
  7222                                  
  7223                                  ADD_PROMPT:
  7224 0000167E E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7225 00001681 E87801                  		call	SCAN_DOUBLE_NULL
  7226                                  
  7227                                  ADD_PROMPT2:
  7228 00001684 56                      		push	si
  7229 00001685 E86601                  		call	GETARG
  7230 00001688 5E                      		pop	si
  7231 00001689 7501                    		jnz	short ADD_PROMPT3
  7232                                  ADD_PROMPT_RETN:
  7233 0000168B C3                      		retn
  7234                                  ADD_PROMPT3:				; Pre scan for arguments
  7235 0000168C E84E01                  		call	MOVE_NAME	 ;Move in name
  7236 0000168F E85C01                  		call	GETARG
  7237 00001692 56                      		push	si
  7238 00001693 EB4F                    		jmp	short ADD_NAME
  7239                                  
  7240                                  ;break	The SET command
  7241                                  
  7242                                  ; Input: DS:SI points to a CR terminated string
  7243                                  ; Output: carry flag is set if no room
  7244                                  ;	  otherwise name is added to environment
  7245                                  
  7246                                  DISP_ENVJ:
  7247 00001695 E9B100                  		jmp	DISP_ENV
  7248                                  
  7249                                  ADD_NAME_TO_ENVIRONMENT:
  7250 00001698 E85301                  		call	GETARG
  7251 0000169B 74F8                    		jz	short DISP_ENVJ
  7252                                  
  7253                                  ; check if line contains exactly one equals sign
  7254                                  
  7255 0000169D 31DB                    		xor	bx,bx		; = count is 0
  7256 0000169F 56                      		push	si		; Save pointer to beginning of line
  7257                                  EQLP:
  7258 000016A0 AC                      		lodsb			; Get a char
  7259 000016A1 3C0D                    		cmp	al,13		; IF CR we're all done
  7260 000016A3 740F                    		jz	short QUEQ	
  7261 000016A5 3C3D                    		cmp	al,'='		; Look for = sign	
  7262 000016A7 75F7                    		jnz	short EQLP	; not there, get next char
  7263 000016A9 FEC3                    		inc	bl		; Otherwise increment EQ count
  7264 000016AB 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7265 000016AE 75F0                    		jnz	short EQLP
  7266 000016B0 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7267 000016B2 EBEC                    		jmp	short EQLP	; And look for more
  7268                                  QUEQ:
  7269 000016B4 5E                      		pop	si		; Restore beginning of line
  7270 000016B5 FECB                    		dec	bl		; Zero flag means only one EQ
  7271 000016B7 7406                    		jz	short ONEQ	; Good line
  7272 000016B9 BA[783C]                		mov	dx,SYNTMESPTR
  7273 000016BC E96A05                  		jmp	CERROR
  7274                                  ONEQ:
  7275 000016BF 53                      		push	bx
  7276 000016C0 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7277 000016C3 5B                      		pop	bx
  7278 000016C4 FECF                    		dec	bh
  7279 000016C6 74C3                    		jz	short ADD_PROMPT_RETN
  7280 000016C8 E83101                  		call	SCAN_DOUBLE_NULL
  7281 000016CB 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7282 000016CD E80D01                  		call	MOVE_NAME
  7283 000016D0 56                      		push	si
  7284 000016D1 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7285                                  					;  env var name
  7286                                  		
  7287                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7288                                  ; necessary in the resident for re-reading the transient. Let's look for
  7289                                  ; COMSPEC=
  7290                                  
  7291                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7292 000016D3 BE[193C]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7293 000016D6 B90400                  		mov	cx,4
  7294 000016D9 F3A7                    		repe cmpsw
  7295 000016DB 7505                    		jnz	short NOT_COMSPEC
  7296                                  					; Zero set => exact match
  7297                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7298 000016DD C606[A845]01            		mov	byte [COMSPEC_FLAG],1
  7299                                  NOT_COMSPEC:
  7300 000016E2 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7301                                  ADD_NAME:
  7302 000016E4 5E                      		pop	si		; Add the value of the new env var
  7303 000016E5 56                      		push	si		;  to the environment.
  7304                                  ADD_NAME1:
  7305 000016E6 AC                      		lodsb
  7306 000016E7 3C0D                    		cmp	al,13
  7307 000016E9 7405                    		jz	short ADD_NAME_RET
  7308 000016EB E84401                  		call	STORE_CHAR
  7309 000016EE EBF6                    		jmp	short ADD_NAME1
  7310                                  ADD_NAME_RET:
  7311 000016F0 5E                      		pop	si
  7312 000016F1 803E[A845]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7313                                  ADD_NAME_JZ_RET:
  7314 000016F6 7493                    		jz	short ADD_PROMPT_RETN 
  7315                                  					;  copy the value into the
  7316                                  					;  comspec var in the resident
  7317                                  
  7318                                  ; We have changed the COMSPEC variable. We need to update the resident
  7319                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7320                                  
  7321 000016F8 E87E02                  		call	SCANOFF
  7322 000016FB 8E06[7142]              		mov	es,[RESSEG]	;  comspec var in the resident
  7323                                  
  7324                                  ; Make sure that the printer knows where the beginning of the string is
  7325                                  
  7326 000016FF BF9B0B                  		mov	di,COMSPEC
  7327 00001702 89FB                    		mov	bx,di
  7328                                  
  7329                                  ; Generate drive letter for display
  7330                                  
  7331 00001704 31C0                    		xor	ax,ax		;g assume no drive first
  7332 00001706 26A2E60B                		mov	byte [es:COMDRV],al ;g
  7333 0000170A 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7334 0000170E 7512                    		jnz	short _GOTDRIVE
  7335 00001710 8A04                    		mov	al,[si]		; get his specified drive
  7336                                  		;call	UPCONV
  7337 00001712 E80901                  		call	UPCONV_MAPCALL	; convert to uppercase
  7338 00001715 2C41                    		sub	al,'A'		; convert to 0-based
  7339 00001717 83C702                  		add	di,2
  7340 0000171A FEC0                    		inc	al		; convert to 1-based number
  7341 0000171C 26A2E60B                		mov	byte [es:COMDRV],al
  7342                                  
  7343                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7344                                  ; done here..
  7345                                  		;add	al,40h
  7346 00001720 0440                    		add	al,'A'-1
  7347                                  _GOTDRIVE:
  7348                                  		;mov	word [es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7349 00001722 26893EDB0B              		mov	word [es:PUTBACKSUBSTPTR],di
  7350                                  					;g point to beginning of name after drive
  7351                                  		;mov	byte [es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7352 00001727 26A2230A                		mov	byte [es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7353                                  
  7354                                  ; Copy chars until delim      	
  7355                                  
  7356 0000172B 89DF                    		mov	di,bx
  7357                                  COPY_COMSPEC:
  7358 0000172D AC                      		lodsb
  7359 0000172E E85002                  		call	DELIM
  7360 00001731 7407                    		jz	short COPYDONE
  7361 00001733 3C0D                    		cmp	al,13
  7362 00001735 7403                    		jz	short COPYDONE
  7363 00001737 AA                      		stosb
  7364 00001738 EBF3                    		jmp	short COPY_COMSPEC
  7365                                  COPYDONE:
  7366 0000173A 30C0                    		xor	al,al		; Null terminate the string and quit
  7367 0000173C AA                      		stosb
  7368 0000173D C606[A845]00            		mov	byte [COMSPEC_FLAG],0
  7369 00001742 4F                      		dec	di
  7370 00001743 26893EDD0B              		mov	word [es:COMSPEC_END],di
  7371 00001748 C3                      		retn
  7372                                  DISP_ENV:
  7373 00001749 8E1E[7142]              		mov	ds,[RESSEG]
  7374 0000174D 8E1E050D                		mov	ds,word [ENVIRSEG]
  7375                                  		; assume ds:nothing
  7376 00001751 31F6                    		xor	si,si
  7377                                  PENVLP:
  7378 00001753 803C00                  		cmp	byte [si],0
  7379 00001756 749E                    		jz	short ADD_NAME_JZ_RET
  7380 00001758 BF[C843]                		mov	di,ARG_BUF
  7381                                  PENVLP2:
  7382 0000175B AC                      		lodsb
  7383 0000175C AA                      		stosb
  7384 0000175D 08C0                    		or	al,al
  7385 0000175F 75FA                    		jnz	short PENVLP2
  7386 00001761 BA[2337]                		mov	dx,ARG_BUF_PTR
  7387 00001764 1E                      		push	ds
  7388 00001765 06                      		push	es
  7389 00001766 1F                      		pop	ds
  7390                                  		; assume ds:nothing
  7391 00001767 E8591D                  		call	PRINTF_CRLF
  7392 0000176A 1F                      		pop	ds
  7393 0000176B EBE6                    		jmp	short PENVLP
  7394                                  
  7395                                  ; =============== S U B	R O U T	I N E =======================================
  7396                                  
  7397                                  DELETE_PATH:
  7398 0000176D BE[0D3C]                		mov	si,PATH_TEXT ; "PATH="
  7399 00001770 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7400                                  
  7401                                  ; =============== S U B	R O U T	I N E =======================================
  7402                                  
  7403                                  DELETE_PROMPT:
  7404 00001772 BE[123C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7405                                  
  7406                                  ; ---------------------------------------------------------------------------
  7407                                  
  7408                                  DELETE_NAME_IN_ENVIRONMENT:
  7409                                  
  7410                                  ; Input: DS:SI points to a "=" terminated string
  7411                                  ; Output: carry flag is set if name not found
  7412                                  ;	  otherwise name is deleted
  7413                                  
  7414 00001775 56                      		push	si
  7415 00001776 1E                      		push	ds
  7416 00001777 E82400                  		call	FIND		; ES:DI points to name
  7417 0000177A 7210                    		jc	short DEL1
  7418 0000177C 89FE                    		mov	si,di		; Save it
  7419 0000177E E89500                  		call	SCASB2		; Scan for the nul
  7420 00001781 87F7                    		xchg	si,di
  7421                                  ;SR;
  7422                                  ; If we have only one env string, then the double null is lost when the last
  7423                                  ;string is deleted and we have an invalid empty environment with only a 
  7424                                  ;single null. To avoid this, we will look for the double null case and then
  7425                                  ;move an extra null char.
  7426                                  ; Bugbug: The only possible problem is that the last pathstring 
  7427                                  ;will be followed by a triple null. Is this really a problem?
  7428                                  
  7429                                  		; MSDOS 6.0
  7430                                  		;cmp	byte ptr es:[si],0 ;null char?
  7431                                  		;jnz	not_dnull	   ;no, we are at a double null
  7432                                  		;dec	si		   ;point at the double null
  7433                                  ;not_dnull:
  7434                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7435 00001783 E8F400                  		call	GETENVSIZ
  7436 00001786 29F1                    		sub	cx,si
  7437 00001788 06                      		push	es
  7438 00001789 1F                      		pop	ds		; ES:DI points to name
  7439                                  					; DS:SI points to next name
  7440 0000178A F3A4                    		rep movsb
  7441                                  DEL1:
  7442 0000178C 1F                      		pop	ds
  7443 0000178D 5E                      		pop	si
  7444                                  FIND_RETN:
  7445 0000178E C3                      		retn
  7446                                  
  7447                                  ; =============== S U B	R O U T	I N E =======================================
  7448                                  
  7449                                  FIND_PATH:
  7450 0000178F BE[0D3C]                		mov	si,PATH_TEXT ; "PATH="
  7451 00001792 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7452                                  
  7453                                  
  7454                                  ; =============== S U B	R O U T	I N E =======================================
  7455                                  
  7456                                  FIND_PROMPT:
  7457 00001794 BE[123C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7458                                  
  7459                                  ; ---------------------------------------------------------------------------
  7460                                  
  7461                                  FIND_NAME_IN_ENVIRONMENT:
  7462                                  
  7463                                  ; Input: DS:SI points to a "=" terminated string
  7464                                  ; Output: ES:DI points to the arguments in the environment
  7465                                  ;	  zero is set if name not found
  7466                                  ;	  carry flag is set if name not valid format
  7467                                  
  7468 00001797 E80400                  		call	FIND		; Find the name
  7469 0000179A 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7470 0000179C EB74                    		jmp	short SCASB1	; Scan for = sign
  7471                                  
  7472                                  ; ---------------------------------------------------------------------------
  7473                                  		;nop
  7474                                  
  7475                                  ; =============== S U B	R O U T	I N E =======================================
  7476                                  
  7477                                  ; On return of FIND1, ES:DI points to beginning of name
  7478                                  
  7479                                  FIND:
  7480 0000179E FC                      		cld
  7481 0000179F E82D00                  		call	COUNT0		; CX = Length of name
  7482 000017A2 8E06[7142]              		mov	es,[RESSEG]
  7483                                  		; assume es:RESGROUP
  7484 000017A6 268E06050D              		mov	es,word [es:ENVIRSEG]
  7485                                  		; assume es:NOTHING
  7486 000017AB 31FF                    		xor	di,di
  7487                                  FIND1:	
  7488 000017AD 51                      		push	cx
  7489 000017AE 56                      		push	si
  7490 000017AF 57                      		push	di
  7491                                  FIND11:
  7492 000017B0 AC                      		lodsb
  7493                                  		;call	UPCONV
  7494 000017B1 E86A00                  		call	UPCONV_MAPCALL
  7495 000017B4 47                      		inc	di
  7496 000017B5 263A45FF                		cmp	al,[es:di-1]
  7497 000017B9 7502                    		jnz	short FIND12
  7498 000017BB E2F3                    		loop	FIND11
  7499                                  FIND12:
  7500 000017BD 5F                      		pop	di
  7501 000017BE 5E                      		pop	si
  7502 000017BF 59                      		pop	cx
  7503 000017C0 74CC                    		jz	short FIND_RETN
  7504 000017C2 51                      		push	cx
  7505 000017C3 E85000                  		call	SCASB2		; Scan for a nul
  7506 000017C6 59                      		pop	cx
  7507 000017C7 26803D00                		cmp	byte [es:di],0
  7508 000017CB 75E0                    		jnz	short FIND1
  7509 000017CD F9                      		stc			; Indicate not found
  7510 000017CE C3                      		retn
  7511                                  
  7512                                  ; =============== S U B	R O U T	I N E =======================================
  7513                                  
  7514                                  COUNT0:
  7515 000017CF 1E                      		push	ds
  7516 000017D0 07                      		pop	es
  7517                                  		; assume es:nothing
  7518 000017D1 89F7                    		mov	di,si
  7519                                  ;COUNT1:
  7520 000017D3 57                      		push	di		; Count number of chars until "="
  7521 000017D4 E83B00                  		call	SCASB1
  7522                                  		; 24/02/2023
  7523                                  		;jmp	short COUNTX
  7524                                  ;COUNT2:
  7525                                  ;		push	di		; Count number of chars until nul
  7526                                  ;		call	SCASB2
  7527                                  ;COUNTX:
  7528 000017D7 59                      		pop	cx
  7529 000017D8 29CF                    		sub	di,cx
  7530 000017DA 87F9                    		xchg	di,cx
  7531                                  MOVE_NAME_RETN:
  7532 000017DC C3                      		retn
  7533                                  
  7534                                  ; =============== S U B	R O U T	I N E =======================================
  7535                                  
  7536                                  MOVE_NAME:
  7537 000017DD 803C0D                  		cmp	byte [si],13
  7538 000017E0 74FA                    		jz	short MOVE_NAME_RETN
  7539 000017E2 AC                      		lodsb
  7540                                  		;call	UPCONV
  7541 000017E3 E83800                  		call	UPCONV_MAPCALL
  7542 000017E6 E84900                  		call	STORE_CHAR
  7543 000017E9 3C3D                    		cmp	al,'='
  7544 000017EB 75F0                    		jnz	short MOVE_NAME
  7545                                  GETARG_RETN:
  7546 000017ED C3                      		retn
  7547                                  
  7548                                  ; =============== S U B	R O U T	I N E =======================================
  7549                                  
  7550                                  GETARG:
  7551 000017EE BE8000                  		mov	si,80h
  7552 000017F1 AC                      		lodsb
  7553 000017F2 08C0                    		or	al,al
  7554 000017F4 74F7                    		jz	short GETARG_RETN
  7555 000017F6 E88001                  		call	SCANOFF
  7556 000017F9 3C0D                    		cmp	al,13
  7557                                  SDN_RETN:
  7558 000017FB C3                      		retn
  7559                                  
  7560                                  ; =============== S U B	R O U T	I N E =======================================
  7561                                  
  7562                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7563                                  ; there is NO double NULL, merely a string that is empty.
  7564                                  
  7565                                  SCAN_DOUBLE_NULL:
  7566 000017FC 8E06[7142]              		mov	es,[RESSEG]
  7567                                  		; ASSUME ES:RESGROUP
  7568 00001800 268E06050D              		mov	es,word [es:ENVIRSEG]
  7569                                  		; ASSUME ES:NOTHING
  7570 00001805 31FF                    		xor	di,di
  7571                                  
  7572                                  ; Top cycle-point. If the string here is empty, then we are done
  7573                                  
  7574                                  SDN1:
  7575 00001807 26803D00                		cmp	byte [es:di],0	; nul string?
  7576 0000180B 74EE                    		jz	short SDN_RETN	; yep, all done
  7577 0000180D E80600                  		call	SCASB2
  7578 00001810 EBF5                    		jmp	short SDN1
  7579                                  
  7580                                  ; =============== S U B	R O U T	I N E =======================================
  7581                                  
  7582                                  SCASB1:
  7583 00001812 B03D                    		mov	al,'='		; Scan for an =
  7584 00001814 EB02                    		jmp	short SCASBX
  7585                                  
  7586                                  ; =============== S U B	R O U T	I N E =======================================
  7587                                  
  7588                                  SCASB2:
  7589 00001816 30C0                    		xor	al,al		; Scan for a nul
  7590                                  
  7591                                  ; ---------------------------------------------------------------------------
  7592                                  
  7593                                  SCASBX:
  7594 00001818 B90001                  		mov	cx,256
  7595 0000181B F2AE                    		repne scasb
  7596 0000181D C3                      		retn
  7597                                  
  7598                                  ; =============== S U B	R O U T	I N E =======================================
  7599                                  
  7600                                  ; MSDOS 6.0
  7601                                  
  7602                                  ; ****************************************************************
  7603                                  ; *
  7604                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7605                                  ; *
  7606                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7607                                  ; *		 the character in AL from the file upper case table
  7608                                  ; *		 in DOS if character if above  ascii 128, else
  7609                                  ; *		 subtracts 20H if between "a" and "z".
  7610                                  ; *
  7611                                  ; * INPUT:	 AL	      char to be upper cased
  7612                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7613                                  ; *
  7614                                  ; * OUTPUT:	 AL	      upper cased character
  7615                                  ; *
  7616                                  ; ****************************************************************
  7617                                  
  7618                                  ;assume	ds:trangroup			;AN000;
  7619                                  ;
  7620                                  ;upconv	proc	near			;AN000;
  7621                                  ;
  7622                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7623                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7624                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7625                                  ;	push	ds			;AN000;
  7626                                  ;	push	bx			;AN000;
  7627                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7628                                  ;assume	ds:resgroup			;AN000;
  7629                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7630                                  ;	add	bx,2			;AN000;  skip over first word
  7631                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7632                                  ;	pop	bx			;AN000;
  7633                                  ;	pop	ds			;AN000;
  7634                                  ;assume	ds:trangroup			;AN000;
  7635                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7636                                  ;
  7637                                  ;oth_fucase:				;AN000;
  7638                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7639                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7640                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7641                                  ;	ja	upconv_end		;AC000;
  7642                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7643                                  ;
  7644                                  ;upconv_end:				;AN000;
  7645                                  ;	ret
  7646                                  ;
  7647                                  ;upconv	endp				;AN000;
  7648                                  
  7649                                  ; ---------------------------------------------------------------------------
  7650                                  
  7651                                  ; MSDOS 3.3
  7652                                  
  7653                                  UPCONV_MAPCALL:
  7654                                  					; If between "a" and "z"
  7655 0000181E 3A06[023F]              		cmp	al,[small_a]
  7656 00001822 7208                    		jb	short UPCONV_END
  7657 00001824 3A06[033F]              		cmp	al,[small_z]
  7658 00001828 7702                    		ja	short UPCONV_END
  7659 0000182A 2C20                    		sub	al,20h		; Change lower-case to upper
  7660                                  UPCONV_END:
  7661 0000182C 2EFF1E[0A4D]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7662                                  					  ; 	  for (current) country
  7663 00001831 C3                      		retn
  7664                                  
  7665                                  ; =============== S U B	R O U T	I N E =======================================
  7666                                  
  7667                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7668                                  
  7669                                  STORE_CHAR:
  7670 00001832 51                      		push	cx
  7671 00001833 53                      		push	bx
  7672                                  
  7673                                  		; 16/10/2018
  7674                                  		; MSDOS 6.0
  7675                                  		;PUSH	ES		;AN056;*
  7676                                  		;PUSH	DS		;AN056; Save local DS
  7677                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7678                                  		;;ASSUME DS:RESGROUP	;AN056;
  7679                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7680                                  		;; ASSUME ES:NOTHING	;AN056;
  7681                                  		;POP	DS		;AN056; Get local segment back
  7682                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7683                                  
  7684                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7685 00001834 E84300                  		call	GETENVSIZ
  7686 00001837 89CB                    		mov	bx,cx		; Save room for double nul	
  7687 00001839 83EB02                  		sub	bx,2
  7688 0000183C 39DF                    		cmp	di,bx
  7689 0000183E 7231                    		jb	short STORE1
  7690                                  
  7691 00001840 50                      		push	ax
  7692 00001841 51                      		push	cx
  7693 00001842 53                      		push	bx		; Save Size of environment
  7694 00001843 E81AEE                  		call	FREE_TPA
  7695 00001846 5B                      		pop	bx
  7696 00001847 83C302                  		add	bx,2		; Recover true environment size
  7697                                  
  7698 0000184A 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7699 0000184E 7203                    		jb	short ENVSIZ_OK
  7700                                  BAD_ENV_SIZE:				;AN056;
  7701 00001850 F9                      		stc
  7702 00001851 EB09                    		jmp	short ENVNOSET
  7703                                  
  7704                                  		;nop
  7705                                  ENVSIZ_OK:
  7706 00001853 B104                    		mov	cl,4
  7707 00001855 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7708 00001857 43                      		inc	bx
  7709                                  
  7710                                  		; MSDOS 6.0
  7711                                  		;MOV	CX,ES		;AN056; Get environment segment
  7712                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7713                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7714                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7715                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7716                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7717                                  
  7718                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7719 00001858 B44A                    		mov	ah,SETBLOCK ; 4Ah
  7720 0000185A CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7721                                  				; ES = segment address of block	to change
  7722                                  				; BX = new size	in paragraphs
  7723                                  ENVNOSET:
  7724 0000185C 9C                      		pushf
  7725 0000185D 06                      		push	es
  7726 0000185E 8E06[7142]              		mov	es,[RESSEG]
  7727                                  		;ASSUME ES:RESGROUP
  7728 00001862 E80BEE                  		call	ALLOC_TPA
  7729 00001865 07                      		pop	es
  7730 00001866 9D                      		popf
  7731 00001867 59                      		pop	cx
  7732 00001868 58                      		pop	ax
  7733                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7734 00001869 7306                    		jnc	short STORE1
  7735 0000186B BA[5638]                		mov	dx,ENVERRPTR
  7736 0000186E E9B803                  		jmp	CERROR
  7737                                  
  7738                                  STORE1:	
  7739 00001871 AA                      		stosb
  7740 00001872 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7741                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7742 00001877 5B                      		pop	bx
  7743 00001878 59                      		pop	cx
  7744 00001879 C3                      		retn
  7745                                  
  7746                                  ; =============== S U B	R O U T	I N E =======================================
  7747                                  
  7748                                  GETENVSIZ:
  7749                                  
  7750                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7751                                  ;ES has environment segment
  7752                                  ;Size returned in CX, all other registers preserved
  7753                                  
  7754 0000187A 06                      		push	es
  7755 0000187B 50                      		push	ax
  7756 0000187C 8CC0                    		mov	ax,es
  7757 0000187E 48                      		dec	ax	;Point at arena	
  7758 0000187F 8EC0                    		mov	es,ax
  7759 00001881 26A10300                		mov	ax,word [es:ARENA.size]
  7760 00001885 B104                    		mov	cl,4
  7761 00001887 D3E0                    		shl	ax,cl	;Convert to bytes
  7762 00001889 89C1                    		mov	cx,ax
  7763 0000188B 58                      		pop	ax
  7764 0000188C 07                      		pop	es
  7765                                  GETENVSIZ_RETN:
  7766 0000188D C3                      		retn
  7767                                  
  7768                                  ; =============== S U B	R O U T	I N E =======================================
  7769                                  
  7770                                  RESTUDIR1:
  7771 0000188E 1E                      		push	ds
  7772 0000188F 8E1E[7142]              		mov	ds,[RESSEG]
  7773                                  		;ASSUME	DS:RESGROUP
  7774 00001893 803EF30B00              		cmp	byte [RESTDIR],0
  7775 00001898 1F                      		pop	ds
  7776                                  		;ASSUME	DS:TRANGROUP
  7777 00001899 74F2                    		jz	short GETENVSIZ_RETN
  7778                                  
  7779                                  ; =============== S U B	R O U T	I N E =======================================
  7780                                  
  7781                                  RESTUDIR:
  7782 0000189B BA[5341]                		mov	dx,USERDIR1
  7783 0000189E B43B                    		mov	ah,CHDIR ; 3Bh
  7784 000018A0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7785                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7786 000018A2 30C0                    		xor	al,al
  7787 000018A4 E86506                  		call	SETREST
  7788 000018A7 C3                      		retn
  7789                                  
  7790                                  ;============================================================================
  7791                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7792                                  ;============================================================================
  7793                                  ; 07/10/2018 - Retro DOS v3.0
  7794                                  
  7795                                  ; TITLE	Part6 COMMAND Transient routines.
  7796                                  
  7797                                  ;	Environment utilities and misc. routines
  7798                                  
  7799                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7800                                  
  7801                                  ; ---------------------------------------------------------------------------
  7802                                  
  7803                                  ; ****************************************************************
  7804                                  ; *
  7805                                  ; * ROUTINE:	 $CHDIR
  7806                                  ; *
  7807                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7808                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7809                                  ; *		 letter is found, get and display the current dir
  7810                                  ; *		 of the specified drive. If nothing is found, get
  7811                                  ; *		 and display the current dir of the default drive.
  7812                                  ; *
  7813                                  ; * INPUT:	 command line at offset 81H
  7814                                  ; *
  7815                                  ; * OUTPUT:	 none
  7816                                  ; *
  7817                                  ; ****************************************************************
  7818                                  
  7819                                  _$CHDIR:
  7820                                  		; MSDOS 6.0
  7821                                  		;mov	si,81H
  7822                                  		;mov	di,offset trangroup:parse_chdir 
  7823                                  		;			;AN000; Get address of PARSE_CHDIR
  7824                                  		;xor	cx,cx		;AN000; clear cx,dx
  7825                                  		;xor	dx,dx		;AN000;
  7826                                  		;invoke	parse_with_msg	;AC018; call parser
  7827                                  
  7828                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7829                                  		;jz	bwdJ		; No args
  7830                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7831                                  		;jnz	ChDirErr	;AC018; yes - exit
  7832                                  
  7833                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7834                                  		;jnz	REALCD		; no
  7835                                  ;;
  7836                                  ;; D: was found. See if there is anything more.
  7837                                  ;;
  7838                                  		;mov	di,offset trangroup:parse_chdir 
  7839                                  					;AC000; get address of parse_chdir
  7840                                  		;xor	dx,dx		;AC000;
  7841                                  		;invoke	parse_check_eol ;AC000; call parser
  7842                                  		;jnz	ChDirErr	;AC000;
  7843                                  	;bwdJ:
  7844                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7845                                  		;call	crlf2
  7846                                  		;return
  7847                                  
  7848                                  		; MSDOS 3.3
  7849 000018A8 A1[8842]                		mov	ax,[COMSW]
  7850 000018AB 0B06[8E42]              		or	ax,[ALLSWITCH]
  7851 000018AF BA[223A]                		mov	dx,BADPARMPTR
  7852 000018B2 7533                    		jnz	short CHDIR_ERR
  7853 000018B4 BE8100                  		mov	si,81h
  7854 000018B7 E8BF00                  		call	SCANOFF
  7855 000018BA 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7856 000018BC 740F                    		je	short BWDJ	; No args
  7857 000018BE 46                      		inc	si
  7858 000018BF AC                      		lodsb
  7859 000018C0 3C3A                    		cmp	al,':'
  7860 000018C2 7510                    		jne	short REALCD
  7861 000018C4 56                      		push	si
  7862 000018C5 E8B100                  		call	SCANOFF
  7863 000018C8 5E                      		pop	si
  7864 000018C9 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7865 000018CB 7507                    		jne	short REALCD	; no
  7866                                  BWDJ:
  7867 000018CD E873FB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7868 000018D0 E89900                  		call	CRLF2
  7869                                  CHDIR_RETN:
  7870 000018D3 C3                      		retn
  7871                                  
  7872                                  		; MSDOS 6.0
  7873                                  ;REALCD:
  7874                                  		;push	si		;AN000; save position in line
  7875                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7876                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7877                                  		;pop	si		;AN000; restore position in line
  7878                                  		;mov	di,offset trangroup:parse_chdir 
  7879                                  		;			;AC000; get address of parse_chdir
  7880                                  		;xor	dx,dx		;AC000;
  7881                                  		;invoke	parse_check_eol ;AC000; call parser
  7882                                  		;jnz	ChDirErr	;AC000;
  7883                                  		;
  7884                                  		;invoke	SETPATH
  7885                                  		;TEST	[DESTINFO],2
  7886                                  		;JNZ	BadChdir
  7887                                  		;MOV	AH,CHDIR
  7888                                  		;INT	21h
  7889                                  		;retnc
  7890                                  		;
  7891                                  		;invoke	get_ext_error_number
  7892                                  		;			;AN022; get the extended error
  7893                                  		;cmp	ax,error_path_not_found
  7894                                  		;			;AN022; see if path not found
  7895                                  		;jz	BadChDir	;AN022; yes - issue old message
  7896                                  ;;SR;
  7897                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  7898                                  ;;but is not a directory. The extended error returns "Access denied" which
  7899                                  ;;is kind of confusing. Issue the old message if access denied error is 
  7900                                  ;;returned
  7901                                  ;;
  7902                                  		;cmp	ax,error_access_denied
  7903                                  		;jz	BadChDir
  7904                                  		;
  7905                                  		;call	Set_Ext_Error_Subst ;AN022;
  7906                                  		;jmp	short  chdirerr ;AN022;
  7907                                  ;BadChDir:
  7908                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  7909                                  ;ChDirErr:
  7910                                  		;invoke	Std_Eprintf
  7911                                  		;return
  7912                                  
  7913                                  		; MSDOS 3.3
  7914                                  REALCD:
  7915 000018D4 E8A004                  		call	SETPATH
  7916 000018D7 F606[7044]02            		test	byte [DESTINFO],2
  7917 000018DC 7506                    		jnz	short BADCHDIR
  7918 000018DE B43B                    		mov	ah,CHDIR ; 3Bh
  7919 000018E0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7920                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7921 000018E2 73EF                    		jnc	short CHDIR_RETN
  7922                                  BADCHDIR:
  7923 000018E4 BA[763B]                		mov	dx,BADCDPTR
  7924                                  CHDIR_ERR:
  7925 000018E7 E8E01B                  		call	STD_EPRINTF
  7926                                  MKDIR_RETN:
  7927 000018EA C3                      		retn
  7928                                  
  7929                                  ; ---------------------------------------------------------------------------
  7930                                  
  7931                                  _$MKDIR:
  7932                                  		; MSDOS 6.0
  7933                                  		;CALL	SETRMMK
  7934                                  		;JC	MkDirErr
  7935                                  		;MOV	AH,MKDIR
  7936                                  		;INT	21h
  7937                                  		;retnc
  7938                                  
  7939                                  		;invoke	get_ext_error_number	
  7940                                  		;			;AN022; get the extended error
  7941                                  		;cmp	ax,error_path_not_found 
  7942                                  		;			;AN022; see if path not found
  7943                                  		;jz	MD_other_err	;AN022; yes - issue old message
  7944                                  		;cmp	ax,error_access_denied
  7945                                  		;			;AN022; access denied?
  7946                                  		;jz	badmderr	;AN022; yes - see if file exists
  7947                                  		
  7948                                  		;call	Set_Ext_Error_Subst ;AN022;
  7949                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  7950                                  ;BADMDERR:
  7951                                  		;mov	dx,offset trangroup:srcxname	
  7952                                  		;			;AN006; Set Disk transfer address
  7953                                  		;mov	ah,Set_DMA	;AN006;
  7954                                  		;int	21h		;AN006;
  7955                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  7956                                  		;mov	cx,attr_directory ;AN006;   search for directory
  7957                                  		;INT	21h		;AN006;
  7958                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  7959                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  7960                                  		;test	dl,attr_directory ;AN006; was it a directory?
  7961                                  		;jz	MD_other_err	;AN006; no - must have been a file
  7962                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  7963                                  		;			;AN006; set up already exists error
  7964                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  7965                                  ;MD_other_err:				;AN006;
  7966                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  7967                                  ;MkDirErr:
  7968                                  		;invoke	Std_Eprintf
  7969                                  		;return
  7970                                  
  7971                                  		; MSDOS 3.3
  7972 000018EB E81200                  		call	SETRMMK
  7973 000018EE 720C                    		jb	short MKDIRERR
  7974 000018F0 B439                    		mov	ah,MKDIR ; 39h
  7975 000018F2 CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  7976                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  7977 000018F4 73F4                    		jnc	short MKDIR_RETN
  7978 000018F6 BA[953B]                		mov	dx,BADMKDPTR
  7979 000018F9 E8CE05                  		call	GET_EXT_ERR_NUMBER
  7980                                  MKDIRERR:
  7981 000018FC E8CB1B                  		call	STD_EPRINTF
  7982 000018FF C3                      		retn
  7983                                  
  7984                                  ; =============== S U B	R O U T	I N E =======================================
  7985                                  
  7986                                  ; 	<Common MkDir/RmDir set up code>
  7987                                  ;****************************************************************
  7988                                  ;*
  7989                                  ;* ROUTINE:	SETRMMK
  7990                                  ;*
  7991                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  7992                                  ;*		commands. Parses the command line for a required
  7993                                  ;*		filespec.
  7994                                  ;*
  7995                                  ;* INPUT:	command line at offset 81H
  7996                                  ;*
  7997                                  ;* OUTPUT:	carry clear
  7998                                  ;*		    DS:DX points to ASCIIZ argument
  7999                                  ;*		carry set
  8000                                  ;*		    DS:DX has error message pointer
  8001                                  ;*
  8002                                  ;****************************************************************
  8003                                  
  8004                                  		; MSDOS 6.0
  8005                                  		;mov	si,81H
  8006                                  		;mov	di,offset trangroup:parse_mrdir 
  8007                                  					;AN000; Get adderss of PARSE_MRDIR
  8008                                  		;xor	cx,cx		;AN000; clear cx,dx
  8009                                  		;xor	dx,dx		;AN000;
  8010                                  		;invoke	parse_with_msg	;AC000; call parser
  8011                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8012                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8013                                  
  8014                                  		;mov	di,offset trangroup:srcxname
  8015                                  		;			;AN000; get address of srcxname
  8016                                  		;push	di		;AN000; save address
  8017                                  		;push	si		;AN000; save position in line
  8018                                  		;lds	si,parse1_addr	;AN000; get address of path
  8019                                  
  8020                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8021                                  		;lodsb			;get a char from buffer
  8022                                  		;stosb			;AN000; store in srcxname
  8023                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8024                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8025                                  		;pop	si		;AN000; get line position back
  8026                                  ;;
  8027                                  ;; we have scanned an argument.	See if any args beyond.
  8028                                  ;;
  8029                                  		;mov	di,offset trangroup:parse_mrdir 
  8030                                  		;			;AC000; get address of parse_mrdir
  8031                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8032                                  		;pop	dx		;AC000; get address of SRCXNAME
  8033                                  		;retz			;yes - return no error
  8034                                  ;NOARGERR:
  8035                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8036                                  		;			;AC000; get extended message pointer
  8037                                  		;XOR	AX,AX
  8038                                  		;STC
  8039                                  		;return
  8040                                  
  8041                                  		; MSDOS 3.3
  8042                                  SETRMMK:
  8043 00001900 BE8100                  		mov	si,81h
  8044 00001903 E87300                  		call	SCANOFF
  8045 00001906 3C0D                    		cmp	al,0Dh
  8046 00001908 741E                    		je	short NOARGERR
  8047 0000190A 89F2                    		mov	dx,si
  8048                                  SETRMMK1:
  8049 0000190C AC                      		lodsb
  8050 0000190D E87100                  		call	DELIM
  8051 00001910 7409                    		jz	short SETRMMK3
  8052 00001912 3C0D                    		cmp	al,0Dh
  8053 00001914 75F6                    		jne	short SETRMMK1
  8054 00001916 C644FF00                		mov	byte [si-1],0
  8055                                  SETRMMK2:
  8056 0000191A C3                      		retn
  8057                                  SETRMMK3:
  8058 0000191B C644FF00                		mov	byte [si-1],0
  8059 0000191F 56                      		push	si
  8060 00001920 E85600                  		call	SCANOFF
  8061 00001923 5E                      		pop	si
  8062 00001924 3C0D                    		cmp	al,0Dh
  8063 00001926 74F2                    		je	short SETRMMK2
  8064                                  NOARGERR:
  8065 00001928 BA[6D3D]                		mov	dx,BADARGSPTR
  8066 0000192B 31C0                    		xor	ax,ax
  8067 0000192D F9                      		stc
  8068                                  SETRMMK_RETN:
  8069 0000192E C3                      		retn
  8070                                  
  8071                                  ; ---------------------------------------------------------------------------
  8072                                  
  8073                                  _$RMDIR:
  8074 0000192F E8CEFF                  		call	SETRMMK
  8075 00001932 720E                    		jb	short RMDIRERR
  8076 00001934 7506                    		jnz	short BADRDERR
  8077 00001936 B43A                    		mov	ah,RMDIR ; 3Ah
  8078 00001938 CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8079                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8080 0000193A 73F2                    		jnc	short SETRMMK_RETN
  8081                                  
  8082                                  		; MSDOS 6.0
  8083                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8084                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8085                                  		;jz	badrderr	;AN022; yes - issue old message
  8086                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8087                                  		;jz	badrderr	;AN022; yes - issue old message
  8088                                  
  8089                                  		;call	Set_Ext_Error_Subst ;AN022;
  8090                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8091                                  
  8092                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8093                                  BADRDERR:
  8094 0000193C BA[CE3B]                		mov	dx,BADRMDPTR
  8095 0000193F E88805                  		call	GET_EXT_ERR_NUMBER
  8096                                  RMDIRERR:
  8097 00001942 E8851B                  		call	STD_EPRINTF
  8098                                  RMDIR_RETN:
  8099 00001945 C3                      		retn
  8100                                  
  8101                                  ; =============== S U B	R O U T	I N E =======================================
  8102                                  
  8103                                  ; MSDOS 6.0
  8104                                  
  8105                                  ;****************************************************************
  8106                                  ;*
  8107                                  ;* ROUTINE:	Set_ext_error_subst
  8108                                  ;*
  8109                                  ;* FUNCTION:	Sets up substitution for extended error
  8110                                  ;*
  8111                                  ;* INPUT:	AX - extended error number
  8112                                  ;*		DX - offset of string
  8113                                  ;*
  8114                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8115                                  ;*
  8116                                  ;****************************************************************
  8117                                  
  8118                                  ;Set_ext_error_subst  proc near		;AN022;
  8119                                  ;
  8120                                  ;	mov	msg_disp_class,ext_msg_class
  8121                                  ;					;AN022; set up extended error msg class
  8122                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8123                                  ;	mov	Extend_buf_sub,one_subst 
  8124                                  ;					;AN022; put number of subst in control block
  8125                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8126                                  ;					;AN022; get extended message pointer
  8127                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8128                                  ;
  8129                                  ;	ret				;AN022; return
  8130                                  ;
  8131                                  ;Set_ext_error_subst  endp		;AN022;
  8132                                  
  8133                                  ; =============== S U B	R O U T	I N E =======================================
  8134                                  
  8135                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8136                                  
  8137                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8138                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8139                                  ;   buffer
  8140                                  ;
  8141                                  ;   Inputs:	DL has 1-based drive number
  8142                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8143                                  ;   Outputs:	Carry Clear
  8144                                  ;		    DS = TranGroup
  8145                                  ;		Carry Set
  8146                                  ;		    AX has error code
  8147                                  ;   Registers Modified: AX, SI
  8148                                  
  8149                                  SAVUDIR:
  8150 00001946 BF[5341]                		mov	di,USERDIR1
  8151                                  
  8152                                  ; ---------------------------------------------------------------------------
  8153                                  
  8154                                  SAVUDIR1:
  8155 00001949 88D0                    		mov	al,dl
  8156 0000194B 0440                    		add	al,'@'
  8157 0000194D 3C40                    		cmp	al,'@'
  8158 0000194F 7506                    		jnz	short GOTUDRV
  8159 00001951 0206[8542]              		add	al,[CURDRV]
  8160 00001955 FEC0                    		inc	al		; A = 1
  8161                                  GOTUDRV:
  8162 00001957 AA                      		stosb
  8163 00001958 8A26[7642]              		mov	ah,[DIRCHAR]
  8164 0000195C B03A                    		mov	al,':'
  8165 0000195E AB                      		stosw
  8166 0000195F 06                      		push	es
  8167 00001960 1F                      		pop	ds
  8168 00001961 89FE                    		mov	si,di
  8169 00001963 B447                    		mov	ah,CURRENT_DIR	; 47h
  8170 00001965 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8171                                  				; DL = drive (0=default,1=A,etc.)
  8172                                  				; DS:SI	points to 64-byte buffer area
  8173 00001967 72DC                    		jc	short RMDIR_RETN
  8174 00001969 0E                      		push	cs
  8175 0000196A 1F                      		pop	ds
  8176 0000196B C3                      		retn
  8177                                  
  8178                                  ; =============== S U B	R O U T	I N E =======================================
  8179                                  
  8180                                  CRLF2:
  8181 0000196C 52                      		push	dx
  8182 0000196D BA[8E3D]                		mov	dx,ACRLFPTR
  8183 00001970 1E                      		push	ds
  8184 00001971 0E                      		push	cs
  8185 00001972 1F                      		pop	ds
  8186 00001973 E85D1B                  		call	STD_PRINTF
  8187 00001976 1F                      		pop	ds
  8188 00001977 5A                      		pop	dx
  8189 00001978 C3                      		retn
  8190                                  
  8191                                  ; =============== S U B	R O U T	I N E =======================================
  8192                                  
  8193                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8194                                  ; may NOT be TRANGROUP
  8195                                  
  8196                                  SCANOFF:
  8197 00001979 AC                      		lodsb
  8198 0000197A E80400                  		call	DELIM
  8199 0000197D 74FA                    		jz	short SCANOFF
  8200 0000197F 4E                      		dec	si		; Point to first non-delimiter
  8201                                  SCANOFF_RETN:
  8202 00001980 C3                      		retn
  8203                                  
  8204                                  ; ---------------------------------------------------------------------------
  8205                                  
  8206                                  ; Input:    AL is character to classify
  8207                                  ; Output:   Z set if delimiter
  8208                                  ;	    NZ set otherwise
  8209                                  ; Registers modified: none
  8210                                  
  8211                                  DELIM:
  8212 00001981 3C20                    		cmp	al,' '
  8213 00001983 74FB                    		jz	short SCANOFF_RETN
  8214 00001985 3C3D                    		cmp	al,'='
  8215 00001987 74F7                    		jz	short SCANOFF_RETN
  8216 00001989 3C2C                    		cmp	al,','
  8217 0000198B 74F3                    		jz	short SCANOFF_RETN
  8218 0000198D 3C3B                    		cmp	al,';'
  8219 0000198F 74EF                    		jz	short SCANOFF_RETN
  8220 00001991 3C09                    		cmp	al,9		; Check for TAB character
  8221 00001993 74EB                    		jz	short SCANOFF_RETN
  8222 00001995 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8223 00001997 C3                      		retn
  8224                                  
  8225                                  
  8226                                  ; =============== S U B	R O U T	I N E =======================================
  8227                                  
  8228                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8229 00001998 B90800                  		mov	cx,8
  8230                                  MAINNAME:
  8231 0000199B AC                      		lodsb
  8232 0000199C 3C20                    		cmp	al,' '
  8233 0000199E 7401                    		jz	short SKIPSPC
  8234 000019A0 AA                      		stosb
  8235                                  SKIPSPC:
  8236 000019A1 E2F8                    		loop	MAINNAME
  8237 000019A3 AC                      		lodsb
  8238 000019A4 3C20                    		cmp	al,' '
  8239 000019A6 7413                    		jz	short GOTNAME
  8240 000019A8 88C4                    		mov	ah,al
  8241                                  		;mov	al,'.'
  8242 000019AA A0[083F]                		mov	al,[DOT_CHR]
  8243 000019AD AA                      		stosb
  8244 000019AE 86C4                    		xchg	al,ah
  8245 000019B0 AA                      		stosb
  8246 000019B1 B102                    		mov	cl,2
  8247                                  EXTNAME:
  8248 000019B3 AC                      		lodsb
  8249 000019B4 3C20                    		cmp	al,' '
  8250 000019B6 7403                    		jz	short GOTNAME
  8251 000019B8 AA                      		stosb
  8252 000019B9 E2F8                    		loop	EXTNAME
  8253                                  GOTNAME:
  8254 000019BB 30C0                    		xor	al,al
  8255 000019BD AA                      		stosb
  8256                                  STRCOMP_RETN:
  8257 000019BE C3                      		retn
  8258                                  
  8259                                  ; =============== S U B	R O U T	I N E =======================================
  8260                                  
  8261                                  ; Compare ASCIZ DS:SI with ES:DI.
  8262                                  ; SI,DI destroyed.
  8263                                  
  8264                                  STRCOMP:	
  8265 000019BF A6                      		cmpsb
  8266 000019C0 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8267 000019C2 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8268 000019C6 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8269 000019C8 EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8270                                  
  8271                                  ; =============== S U B	R O U T	I N E =======================================
  8272                                  
  8273                                  CRPRINT:
  8274 000019CA 50                      		push	ax
  8275                                  		;mov	al,13
  8276 000019CB B00D                    		mov	al,0Dh
  8277 000019CD 51                      		push	cx
  8278 000019CE 57                      		push	di
  8279 000019CF 89D7                    		mov	di,dx
  8280 000019D1 B9FFFF                  		mov	cx,65535
  8281 000019D4 06                      		push	es
  8282 000019D5 1E                      		push	ds
  8283 000019D6 07                      		pop	es
  8284 000019D7 F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8285 000019D9 C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8286 000019DD 07                      		pop	es
  8287 000019DE 8916[4E44]              		mov	[STRING_PTR_2],dx
  8288 000019E2 BA[3F37]                		mov	dx,STRINGBUF2PTR
  8289 000019E5 E8EB1A                  		call	STD_PRINTF
  8290                                  		;mov	byte [di-1],13
  8291 000019E8 C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8292 000019EC 7204                    		jb	short ERROR_OUTPUT
  8293 000019EE 5F                      		pop	di
  8294 000019EF 59                      		pop	cx
  8295 000019F0 58                      		pop	ax
  8296 000019F1 C3                      		retn
  8297                                  
  8298                                  ; ---------------------------------------------------------------------------
  8299                                  
  8300                                  ERROR_OUTPUT:
  8301 000019F2 0E                      		push	cs
  8302 000019F3 1F                      		pop	ds
  8303 000019F4 8E06[7142]              		mov	es,[RESSEG]
  8304 000019F8 BA[3938]                		mov	dx,NOSPACEPTR
  8305 000019FB 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  8306 00001A01 7406                    		jz	short GO_TO_ERROR
  8307 00001A03 E88609                  		call	PIPEOFF
  8308 00001A06 BA[D23C]                		mov	dx,PIPEEMESPTR
  8309                                  GO_TO_ERROR:
  8310 00001A09 E91D02                  		jmp	CERROR
  8311                                  
  8312                                  ; =============== S U B	R O U T	I N E =======================================
  8313                                  
  8314                                  ;---- Mod for path invocation ----
  8315                                  
  8316                                  PATHCHRCMP:
  8317 00001A0C 50                      		push	ax
  8318 00001A0D B42F                    		mov	ah,'/'
  8319 00001A0F 3826[7542]              		cmp	[SWITCHAR],ah
  8320 00001A13 7404                    		jz	short NOSLASHT
  8321 00001A15 3C2F                    		cmp	al,'/'
  8322 00001A17 7402                    		jz	short PCCONT
  8323                                  NOSLASHT:
  8324 00001A19 3C5C                    		cmp	al,'\'
  8325                                  PCCONT:	
  8326 00001A1B 58                      		pop	ax
  8327 00001A1C C3                      		retn
  8328                                  
  8329                                  ; =============== S U B	R O U T	I N E =======================================
  8330                                  
  8331                                  ; PATHCRUNCH -
  8332                                  ;
  8333                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8334                                  ;       PathPos = ptr to string with pathname in it
  8335                                  ;       PathCnt = length of string
  8336                                  ;
  8337                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8338                                  ;       PathCnt = length left in string
  8339                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8340                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8341                                  ;       If path crunched successfully,
  8342                                  ;         CY = clear
  8343                                  ;         Current directory is changed to directory in pathname
  8344                                  ;         UserDir1 contains previous directory for use by RestUDir
  8345                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8346                                  ;         DestTail = ptr to beginning of filename
  8347                                  ;         If filename found in pathname,
  8348                                  ;           ZR = clear
  8349                                  ;           FCB filename fields contain filename
  8350                                  ;         If filename not found (pure directory path),
  8351                                  ;           ZR = set
  8352                                  ;           FCB filename fields are wildcarded with ?'s
  8353                                  ;       If pathcrunch failed (no ChDir's worked),
  8354                                  ;         CY = set
  8355                                  ;         Msg_Numb = extended error code
  8356                                  ;
  8357                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8358                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8359                                  ;       with the filename wildcarded.
  8360                                  
  8361                                  PATHCRUNCH:
  8362                                  		; MSDOS 6.0
  8363                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8364                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8365                                  		;mov	dl,[5CH]
  8366 00001A1D 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8367 00001A21 E822FF                  		call	SAVUDIR		; save current directory in UserDir1
  8368 00001A24 E85003                  		call	SETPATH
  8369                                  		; MSDOS 6.0
  8370                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8371                                  
  8372                                  ;       DX = ptr to pathname, NULL-terminated
  8373                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8374                                  
  8375                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8376 00001A27 F606[7044]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8377 00001A2C 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8378                                  
  8379 00001A2E B43B                    		mov	ah,CHDIR ; 3Bh
  8380 00001A30 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8381                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8382                                  		; MSDOS 6.0
  8383                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8384                                  		;
  8385                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8386                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8387                                  		;jz	trypeel                 ;AC022;     keep trying
  8388                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8389                                  		;jz	trypeel                 ;AC022;     keep trying
  8390                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8391                                  		;jmp	peelfail                ;AN022; exit with other error
  8392                                  
  8393                                  		; MSDOS 3.3
  8394 00001A32 7210                    		jc	short TRYPEEL
  8395                                  ;chdir_worked:
  8396                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8397 00001A34 E8D304                  		call	SETREST1	; set 'Restore Directory' flag true
  8398 00001A37 B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8399 00001A39 BF5D00                  		mov	di,5Dh
  8400 00001A3C B90B00                  		mov	cx,11
  8401 00001A3F F3AA                    		rep stosb
  8402 00001A41 30C0                    		xor	al,al		; return carry clear, zero set
  8403 00001A43 C3                      		retn
  8404                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8405                                  		;jmp	pcrunch_cderr	;AN022;
  8406                                  TRYPEEL:
  8407 00001A44 8B36[C043]              		mov	si,[PATHPOS]
  8408 00001A48 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8409 00001A49 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8410 00001A4C E8BDFF                  		call	PATHCHRCMP
  8411 00001A4F 7424                    		jz	short PEELFAIL
  8412                                  DELLOOP:
  8413 00001A51 39D6                    		cmp	si,dx
  8414 00001A53 742C                    		jz	short BADRET
  8415 00001A55 8A04                    		mov	al,[si]
  8416 00001A57 E8B2FF                  		call	PATHCHRCMP
  8417 00001A5A 7403                    		jz	short TRYCD
  8418 00001A5C 4E                      		dec	si
  8419 00001A5D EBF2                    		jmp	short DELLOOP
  8420                                  TRYCD:
  8421 00001A5F 50                      		push	ax
  8422                                  		;mov	al,'.'
  8423 00001A60 A0[083F]                		mov	al,[DOT_CHR]	; AL = '.'
  8424                                  		; MSDOS 6.0
  8425                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8426                                  					;M019; allow continuation if '. ' or 
  8427                                  					;M019; '..' is not found.
  8428                                  		;jnz	@f		;M019; '.' not found
  8429                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8430                                  		;jz	@f		;M019; found '..'
  8431                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8432                                  ;@@:		;pop     ax
  8433                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8434                                  
  8435                                  		; MSDOS 3.3
  8436 00001A63 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8437 00001A66 58                      		pop	ax
  8438 00001A67 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8439                                  
  8440                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8441 00001A69 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8442 00001A6C 3C3A                    		cmp	al,':'
  8443 00001A6E 7411                    		jz	short BADRET
  8444 00001A70 E899FF                  		call	PATHCHRCMP
  8445 00001A73 7502                    		jnz	short NODOUBLESL
  8446                                  PEELFAIL:
  8447 00001A75 F9                      		stc
  8448 00001A76 C3                      		retn
  8449                                  NODOUBLESL:
  8450 00001A77 C60400                  		mov	byte [si],0
  8451 00001A7A B43B                    		mov	ah,CHDIR ; 3Bh
  8452 00001A7C CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8453                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8454 00001A7E 7317                    		jnc	short CDSUCC
  8455                                  
  8456                                  		; MSDOS 6.0
  8457                                  ;pcrunch_cderr:
  8458                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8459                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8460                                  		;or	si,si		;AN022; set up zero flag to not zero
  8461                                  		;stc			;AN022; set up carry flag
  8462                                  		;return
  8463                                  		
  8464                                  		; MSDOS 3.3
  8465                                  PATHCRUNCH_RETN:
  8466 00001A80 C3                      		retn
  8467                                  
  8468                                  BADRET:
  8469 00001A81 8A04                    		mov	al,[si]
  8470 00001A83 E886FF                  		call	PATHCHRCMP
  8471 00001A86 F9                      		stc
  8472 00001A87 75F7                    		jnz	short PATHCRUNCH_RETN
  8473 00001A89 30DB                    		xor	bl,bl
  8474 00001A8B 865C01                  		xchg	bl,[si+1]
  8475 00001A8E B43B                    		mov	ah,CHDIR ; 3Bh
  8476 00001A90 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8477                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8478 00001A92 72EC                    		jb	short PATHCRUNCH_RETN
  8479 00001A94 885C01                  		mov	[si+1],	bl
  8480                                  CDSUCC:
  8481 00001A97 E87004                  		call	SETREST1
  8482 00001A9A 46                      		inc	si
  8483 00001A9B 8936[6E44]              		mov	[DESTTAIL],si
  8484                                  		; MSDOS 6.0
  8485                                  		;pushf			;AN015; save flags
  8486                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8487                                  		;jz	pcrunch_end	;AN015;
  8488                                  		;MOV	DI,FCB
  8489                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8490                                  					; Parse with default drive
  8491                                  		;INT	21h
  8492                                  ;pcrunch_end:
  8493                                  		;popf			;AN015; get flags back
  8494                                  		;return
  8495                                  
  8496                                  		; MSDOS 3.3
  8497 00001A9F BF5C00                  		mov	di,FCB ; 5Ch
  8498 00001AA2 B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8499 00001AA5 CD21                    		int	21h	; DOS -	PARSE FILENAME
  8500                                  				; DS:SI	-> string to parse
  8501                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8502                                  				; AL = bit mask	to control parsing
  8503 00001AA7 C3                      		retn
  8504                                  
  8505                                  ;============================================================================
  8506                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8507                                  ;============================================================================
  8508                                  ; 05/10/2018 - Retro DOS v3.0
  8509                                  
  8510                                  ;TITLE	Part7 COMMAND Transient Routines
  8511                                  
  8512                                  ;	More misc routines
  8513                                  
  8514                                  ;---------------------------
  8515                                  ; We can get rid of this switch processing code if we can take
  8516                                  ; care of the remaining two calls to switch, later in the file.
  8517                                  ; However, I have not checked whether or not any other files use
  8518                                  ; switch -- after all, it IS public!
  8519                                  ;---------------------------
  8520                                  
  8521                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8522                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8523                                  
  8524                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8525                                  
  8526                                  ; ---------------------------------------------------------------------------
  8527                                  
  8528 00001AA8 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8529 00001AA9 C3                      		retn
  8530                                  
  8531                                  ; =============== S U B	R O U T	I N E =======================================
  8532                                  
  8533                                  SWITCH:
  8534 00001AAA 31DB                    		xor	bx,bx		; Initialize - no switches set
  8535                                  SWLOOP:
  8536 00001AAC E8CAFE                  		call	SCANOFF		; Skip any delimiters
  8537 00001AAF 3A06[7542]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8538 00001AB3 75F3                    		jnz	short RETSW	; No -- we're finished
  8539                                  		;or	bx,8000h
  8540 00001AB5 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8541 00001AB9 46                      		inc	si		; Skip over the switch character
  8542 00001ABA E8BCFE                  		call	SCANOFF
  8543 00001ABD 3C0D                    		cmp	al,0Dh
  8544 00001ABF 74E7                    		je	short RETSW	; Oops
  8545 00001AC1 46                      		inc	si
  8546                                  
  8547                                  		; Convert lower case input to upper case
  8548                                  
  8549                                  		;call	UPCONV
  8550 00001AC2 E859FD                  		call	UPCONV_MAPCALL
  8551                                  
  8552 00001AC5 BF[1D3F]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8553                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8554                                  		;mov	cx,5  ; MSDOS 3.3
  8555 00001AC8 B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8556                                  		
  8557                                  		;nop
  8558                                  		
  8559 00001ACB F2AE                    		repne scasb		; Look for matching switch
  8560 00001ACD 7507                    		jnz	short BADSW
  8561 00001ACF B80100                  		mov	ax,1
  8562 00001AD2 D3E0                    		shl	ax,cl		; Set a bit for the switch
  8563 00001AD4 09C3                    		or	bx,ax
  8564                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8565 00001AD6 EBD4                    		jmp	short SWLOOP
  8566                                  
  8567                                  ;BADSW:
  8568                                  		;jmp	short SWLOOP
  8569                                  
  8570                                  DRVBAD:
  8571 00001AD8 BA[4939]                		mov	dx,BADDRVPTR
  8572 00001ADB E94B01                  		jmp	CERROR
  8573                                  
  8574                                  EXTERNALJ:
  8575 00001ADE E9B100                  		jmp	EXTERNAL
  8576                                  
  8577                                  FNDCOM:					; search the internal command table
  8578 00001AE1 08C0                    		or	al,al		; Get real length of first arg
  8579 00001AE3 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8580                                  					;  to be external.
  8581                                  ; barryf code starts here
  8582                                  
  8583 00001AE5 E87E02                  		call	TEST_APPEND	; see if APPEND installed
  8584 00001AE8 7421                    		jz	short CONTCOM	; not loaded
  8585                                  
  8586                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8587 00001AEA 8A0E[EB42]              		mov	cl,[IDLEN]
  8588 00001AEE B500                    		mov	ch,0
  8589 00001AF0 890E[C043]              		mov	[PATHPOS],cx
  8590                                  		
  8591                                  		; MSDOS 6.0
  8592                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8593                                  
  8594 00001AF4 E80E03                  		call	IOSET		; re-direct the o'l io
  8595                                  
  8596 00001AF7 BE[EB42]                		mov	si,IDLEN	; address command name, DS already set	
  8597 00001AFA BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8598                                  		
  8599                                  		; MSDOS 6.0
  8600                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8601                                  					;AN010; Get the entry point for PARSE for APPEND
  8602                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8603 00001AFD B801AE                  		mov	ax,0AE01h
  8604 00001B00 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8605                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8606                                  				; DX = FFFFh,[SI -> buffer
  8607                                  				; Return: buffer at DS:SI filled with a	length byte
  8608                                  				;		 followed by the uppercase
  8609                                  				; internal command to execute (if length not 0)
  8610 00001B02 803E[EB42]00            		cmp	byte [IDLEN],0 ; execute requested
  8611 00001B07 7502                    		jne	short CONTCOM
  8612 00001B09 EB57                    		jmp	short CMD_DONE
  8613                                  
  8614                                  		;nop
  8615                                  CONTCOM:				; continue with internal scan
  8616 00001B0B BF[E33D]                		mov	di,COMTAB
  8617 00001B0E 31C9                    		xor	cx,cx
  8618                                  FINDCOM:
  8619 00001B10 BE[EC42]                		mov	si,ID		; pointer to command argument
  8620 00001B13 8A0D                    		mov	cl,[di]		; load length of internal command
  8621 00001B15 47                      		inc	di		; advance past length
  8622 00001B16 E3C6                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8623 00001B18 3A0E[EB42]              		cmp	cl,[IDLEN]	; that of the command argument
  8624 00001B1C 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8625 00001B1E 890E[C043]              		mov	[PATHPOS],cx	; store length of command
  8626 00001B22 F3A6                    		repe cmpsb
  8627                                  ABCD:					
  8628 00001B24 9F                      		lahf			; save the good ol' flags
  8629 00001B25 01CF                    		add	di,cx		; skip over remaining internal, if any
  8630 00001B27 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8631 00001B29 A2[8342]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8632 00001B2C 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8633 00001B2D 8B1D                    		mov	bx,[di]		; load internal command address
  8634 00001B2F 47                      		inc	di		; skip over the puppy
  8635 00001B30 47                      		inc	di
  8636                                  		
  8637                                  		; MSDOS 6.0
  8638                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8639                                  		;inc     DI
  8640                                  		;inc     DI
  8641                                  		;sahf			; remember those flags?
  8642                                  		;jnz     findcom	; well, if all the cmps worked...
  8643                                  ;;
  8644                                  ;; All messages get redirected.
  8645                                  ;;
  8646                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8647                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8648                                  		;invoke  ioset		; re-direct the ol' i/o
  8649                                  
  8650                                  ;dont_set_io:					;AN041;
  8651                                  ;;
  8652                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8653                                  ;; respond to /? only if it is the only command-line argument.
  8654                                  ;;
  8655                                  		;mov     ax,[COMSW]	; AX = switches after command
  8656                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8657                                  		;and     ax,SwitchQues	
  8658                                  		;jz      drive_check	; /? not in command line
  8659                                  		;	
  8660                                  		;test    [CHKDRV],fLimitHelp
  8661                                  		;jz      do_help	; /? allowed in combination
  8662                                  ;;
  8663                                  ;; Make sure /? is the only argument on the command line.
  8664                                  ;;
  8665                                  		;cmp     [arg.argvcnt],2
  8666                                  		;jne     drive_check	; /? not only arg - ignore
  8667                                  ;;
  8668                                  ;; Note:  this is all the check we need, even against things like /??.
  8669                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8670                                  ;;
  8671                                  
  8672                                  ;do_help:
  8673                                  ;
  8674                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8675                                  
  8676                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8677                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8678                                  		;push    ax		; build subst block on stack
  8679                                  
  8680                                  ;next_help_msg:
  8681                                  		;lodsw			; AX = help msg # or zero
  8682                                  		;or      ax,ax
  8683                                  		;jz      help_done
  8684                                  		;push    ax		; SS:SP = ptr to subst block
  8685                                  					;  (msg # and no_subst byte)
  8686                                  ;; We assume DS = SS.
  8687                                  
  8688                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8689                                      		;invoke  Std_PrintF	; display help message
  8690                                      		;pop     ax		; remove msg # from stack
  8691                                     		;jmp     next_help_msg
  8692                                  
  8693                                  ;help_done:
  8694                                  		;pop     ax		; clean up stack
  8695                                  		;jmp     TCommand	
  8696                                  
  8697                                  		; MSDOS 3.3
  8698 00001B31 9E                      		sahf			; remember those flags?
  8699 00001B32 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8700 00001B34 E8CE02                  		call	IOSET		; re-direct the ol' i/o
  8701                                  
  8702                                  DRIVE_CHECK:
  8703                                  		;test	byte [CHKDRV],1
  8704 00001B37 F606[8342]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8705                                  					; did we wanna check those drives?
  8706 00001B3C 740D                    		jz	short NOCHECK
  8707 00001B3E A0[8642]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8708 00001B41 0A06[8742]              		or	al,[PARM2]	; us whether those drives were OK
  8709 00001B45 3CFF                    		cmp	al,-1
  8710 00001B47 7502                    		jnz	short NOCHECK
  8711 00001B49 EB8D                    		jmp	short DRVBAD
  8712                                  
  8713                                  ; The user may have omitted the space between the command and its arguments.
  8714                                  ; We need to copy the remainder of the user's command line into the buffer.
  8715                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8716                                  ; into the command line at 80.
  8717                                  
  8718                                  NOCHECK:
  8719 00001B4B E8FB01                  		call	CMD_COPY
  8720                                  SWITCHECK:
  8721                                  		;test	byte [CHKDRV],2
  8722 00001B4E F606[8342]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8723                                  					; Does the command take switches
  8724 00001B53 750B                    		jnz	short REALWORK	; Yes, process the command
  8725 00001B55 E82400                  		call	NOSWIT		; No, check to see if any switches
  8726 00001B58 7506                    		jnz	short REALWORK	; None, process the command
  8727                                  
  8728                                  		; MSDOS 6.0
  8729                                  		;mov	msg_disp_class,parse_msg_class	
  8730                                  		;			;AN000; set up parse error msg class
  8731                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8732                                  		;			;AC000; get extended message pointer
  8733                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8734                                  		;			;AN000; get "Invalid switch" message number
  8735                                  		;jmp	CERROR		; Print error and chill out...
  8736                                  
  8737                                  		; MSDOS 3.0
  8738 00001B5A BA[223A]                		mov	dx,BADPARMPTR
  8739 00001B5D E9C900                  		jmp	CERROR
  8740                                  
  8741                                  REALWORK:
  8742 00001B60 FFD3                    		call	bx		; do some real work, at last
  8743                                  
  8744                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8745                                  ; otherwise, go get another command.
  8746                                  
  8747                                  CMD_DONE:
  8748 00001B62 0E                      		push	cs		; g  restore data segment
  8749 00001B63 1F                      		pop	ds		; g
  8750 00001B64 1E                      		push	ds
  8751 00001B65 8E1E[7142]              		mov	ds,[RESSEG]	; g  save data segment
  8752                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8753 00001B69 803E000C01              		cmp	byte [CALL_FLAG],call_in_progress
  8754 00001B6E C606000C00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8755 00001B73 1F                      		pop	ds		; g  get data segment back
  8756 00001B74 7403                    		jz	short INCALL	; G
  8757 00001B76 E98BE5                  		jmp	TCOMMAND	; chill out...
  8758                                  INCALL:
  8759 00001B79 E931E7                  		jmp	DOCOM1
  8760                                  
  8761                                  ; =============== S U B	R O U T	I N E =======================================
  8762                                  
  8763                                  NOSWIT:
  8764 00001B7C 57                      		push	di		; Save di
  8765 00001B7D BF8100                  		mov	di,81h		; di = ptr to command args
  8766 00001B80 BE8000                  		mov	si,80h		; Get address of length of command args
  8767 00001B83 AC                      		lodsb			; Load length
  8768 00001B84 88C1                    		mov	cl,al		; Move length to cl
  8769 00001B86 30ED                    		xor	ch,ch		; Zero ch
  8770 00001B88 2EA0[7542]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8771 00001B8C 3C00                    		cmp	al,0		; Turn off ZF
  8772 00001B8E F2AE                    		repne scasb		; Scan for a switch character and return
  8773 00001B90 5F                      		pop	di		;  with ZF set if one was found
  8774 00001B91 C3                      		retn
  8775                                  
  8776                                  ; ---------------------------------------------------------------------------
  8777                                  
  8778                                  EXTERNAL:
  8779 00001B92 E8D101                  		call	TEST_APPEND	; check to see if append installed
  8780 00001B95 7403                    		jz	short NOT_BARRYF ; no - truly external command
  8781 00001B97 E950FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8782                                  
  8783                                  NOT_BARRYF:
  8784 00001B9A 2EC606[8442]00          		mov	byte [cs:FILTYP],0
  8785 00001BA0 2E8A16[9142]            		mov	dl,[cs:SPECDRV]
  8786 00001BA5 2E8816[EB42]            		mov	[cs:IDLEN],dl
  8787 00001BAA 2EC606[6744]00          		mov	byte [cs:ROM_CALL],0
  8788 00001BB0 52                      		push	dx
  8789 00001BB1 BA[EB42]                		mov	dx,IDLEN
  8790 00001BB4 E819E8                  		call	ROM_SCAN
  8791 00001BB7 5A                      		pop	dx
  8792                                  		;jnc	short POSTSAVE
  8793 00001BB8 7305                    		jnc	short DO_SCAN
  8794 00001BBA 2EFE06[6744]            		inc	byte [cs:ROM_CALL]
  8795                                  		;jmp	short POSTSAVE
  8796                                  
  8797                                  		;nop
  8798                                  DO_SCAN:
  8799                                  POSTSAVE:
  8800 00001BBF BF[9941]                		mov	di,EXECPATH
  8801 00001BC2 C60500                  		mov	byte [di],0	; Initialize to current directory
  8802                                  	
  8803 00001BC5 2E803E[6744]00          		cmp	byte [cs:ROM_CALL],0
  8804 00001BCB 7402                    		jz	short RESEARCH
  8805 00001BCD EB13                    		jmp	short NEOEXECUTE
  8806                                  		
  8807                                  		;nop
  8808                                  RESEARCH:
  8809 00001BCF E81E09                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8810 00001BD2 09C0                    		or	ax,ax		; did we find anything?
  8811 00001BD4 740A                    		jz	short BADCOMJ45	; null means no (sob)
  8812 00001BD6 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8813                                  					; fuckin' sixteen-bit machine ought
  8814 00001BD9 7C02                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8815                                  					; DISPLACEMENT!!
  8816                                  		;jmp	short NEOEXECUTE
  8817 00001BDB EB05                    		jmp	short EXECUTE	
  8818                                  
  8819                                  		; 02H is .bat
  8820                                  
  8821                                  		;nop
  8822                                  BATCOMJ:
  8823 00001BDD E906EB                  		jmp	BATCOM
  8824                                  
  8825                                  BADCOMJ45:
  8826 00001BE0 EB42                    		jmp	short BADCOM
  8827                                  
  8828                                  		;nop
  8829                                  EXECUTE:
  8830                                  NEOEXECUTE:
  8831 00001BE2 E82002                  		call	IOSET
  8832                                  
  8833                                  ; MSDOS 6.0
  8834                                  ;M051
  8835                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8836                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8837                                  ;After a close, this would still leave one open active resulting in sharing
  8838                                  ;errors on subsequent opens of the redirected file.
  8839                                  ;
  8840                                  ;LH_EXECUTE:				;M051	
  8841 00001BE5 8E06[8142]              		mov	es,[TRAN_TPA]
  8842 00001BE9 B449                    		mov	ah,DEALLOC ; 49h
  8843 00001BEB CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8844                                  				; ES = segment address of area to be freed
  8845                                  					; Now running in "free" space
  8846 00001BED 8E06[7142]              		mov	es,[RESSEG]
  8847 00001BF1 26FE06EB0B              		inc	byte [es:EXTCOM] ; Indicate external command
  8848 00001BF6 26C606F30B00            		mov	byte [es:RESTDIR],0 
  8849                                  					; Since USERDIR1 is in transient, insure
  8850                                  					; this flag value for re-entry to COMMAND
  8851                                  		; MSDOS 6.0
  8852                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8853                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8854                                  		;MOV	CX,LenMsgOrPathBuf
  8855                                  		;CLD
  8856                                  		;REP	MOVSB		; copy program pathname to resident
  8857                                  
  8858                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8859 00001BFC BF5C00                  		mov	di,FCB ; 5Ch
  8860 00001BFF 89FE                    		mov	si,di
  8861 00001C01 B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8862 00001C04 F3A5                    		rep movsw		; Transfer parameters to resident header
  8863 00001C06 BA[9941]                		mov	dx,EXECPATH
  8864                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8865 00001C09 BB050D                  		mov	bx,EXEC_BLOCK
  8866 00001C0C B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8867 00001C0F F606[6744]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8868 00001C14 7403                    		jz	short OK_EXEC
  8869 00001C16 E930E8                  		jmp	ROM_EXEC
  8870                                  OK_EXEC:
  8871                                  ;
  8872                                  ; we are now running in free space. Anything we do from here on may get
  8873                                  ; trashed. Move the stack (also in free space) to allocated space because
  8874                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  8875                                  ;
  8876 00001C19 8CC1                    		mov	cx,es
  8877 00001C1B 8ED1                    		mov	ss,cx
  8878 00001C1D BC3E08                  		mov	sp,RSTACK
  8879 00001C20 FF2E[7742]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  8880                                  
  8881                                  ; ---------------------------------------------------------------------------
  8882                                  
  8883                                  BADCOM:
  8884 00001C24 0E                      		push	cs
  8885 00001C25 1F                      		pop	ds
  8886 00001C26 BA[BB37]                		mov	dx,BADNAMPTR
  8887                                  CERROR:		
  8888 00001C29 E89E18                  		call	STD_EPRINTF
  8889 00001C2C E9D5E4                  		jmp	TCOMMAND
  8890                                  
  8891                                  
  8892                                  ; =============== S U B	R O U T	I N E =======================================
  8893                                  
  8894                                  ; Prescan converts the input buffer into a canonicalized form.
  8895                                  ; All redirections and pipes are removed.
  8896                                  
  8897                                  PRESCAN:
  8898 00001C2F 31C9                    		xor	cx,cx
  8899 00001C31 8E06[7142]              		mov	es,[RESSEG]
  8900 00001C35 BE[D240]                		mov	si,COMBUF+2
  8901 00001C38 89F7                    		mov	di,si
  8902                                  COUNTQUOTES:
  8903 00001C3A AC                      		lodsb			; get a byte
  8904 00001C3B 3C22                    		cmp	al,22h		; is it a quote?
  8905 00001C3D 7504                    		jne	short COUNTEND	; no, try for end of road
  8906 00001C3F FEC5                    		inc	ch		; bump count
  8907 00001C41 EBF7                    		jmp	short COUNTQUOTES ; go get next char
  8908                                  COUNTEND:
  8909 00001C43 3C0D                    		cmp	al,0Dh		; end of road?
  8910 00001C45 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  8911 00001C47 89FE                    		mov	si,di		; restore pointer to begining
  8912                                  PRESCANLP:
  8913 00001C49 AC                      		lodsb
  8914 00001C4A 3C22                    		cmp	al,'"'		; " character
  8915 00001C4C 7510                    		jne	short TRYGREATER
  8916 00001C4E FECD                    		dec	ch
  8917 00001C50 740C                    		jz	short TRYGREATER
  8918                                  QLOOP:
  8919 00001C52 8805                    		mov	[di],al
  8920 00001C54 47                      		inc	di
  8921 00001C55 FEC1                    		inc	cl
  8922 00001C57 AC                      		lodsb
  8923 00001C58 3C22                    		cmp	al,'"'		; " character
  8924 00001C5A 75F6                    		jne	short QLOOP
  8925 00001C5C FECD                    		dec	ch
  8926                                  TRYGREATER:
  8927 00001C5E 3A06[F33E]              		cmp	al,[RABRACKET]
  8928 00001C62 753E                    		jne	short NOOUT
  8929                                  
  8930                                  ; We have found a ">" char. We need to see if there is another ">"
  8931                                  ; following it.
  8932                                  
  8933 00001C64 3804                    		cmp	[si],al
  8934 00001C66 7506                    		jnz	short NOAPPND
  8935 00001C68 AC                      		lodsb
  8936 00001C69 26FE060A0C              		inc	byte [es:RE_OUT_APP] ; Flag >>
  8937                                  NOAPPND:
  8938                                  ; Now we attempt to find the file name. First, scan off all whitespace
  8939                                  
  8940 00001C6E E808FD                  		call	SCANOFF
  8941                                  
  8942                                  		; MSDOS 6.0
  8943                                  		;CMP	AL,[LABRACKET]	   ;AN040; was there no filename?
  8944                                  		;Je	short REOUT_ERRSET ;AN040; yes - set up error
  8945                                  
  8946                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8947 00001C71 3C0D                    		cmp	al,0Dh
  8948 00001C73 750D                    		jnz	short GOTREOFIL
  8949                                  
  8950                                  ; There was no file present.  Set us up at end-of-line.
  8951                                  
  8952                                  REOUT_ERRSET:				;AN040; set up for an error
  8953 00001C75 C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  8954 00001C78 26C7060B0C0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  8955 00001C7F E99E00                  		jmp	PRESCANEND
  8956                                  
  8957                                  GOTREOFIL:
  8958 00001C82 57                      		push	di
  8959                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  8960 00001C83 BF0B0C                  		mov	di,RE_OUTSTR
  8961 00001C86 89FB                    		mov	bx,di
  8962 00001C88 06                      		push	es
  8963                                  
  8964                                  		; MSDOS 6.0
  8965                                  SETREOUTSTR:				; Get the output redirection name
  8966                                  					; MSKK06 07/14/89
  8967                                  		;push	cx		; save cx
  8968                                  		;mov	cx,64+13	; CX = max string length
  8969                                  ;SETREOUTSTR_LOOP:
  8970                                  		;LODSB
  8971                                  		;CMP	AL,0DH
  8972                                  		;JZ	GOTRESTR_J
  8973                                  		;INVOKE	DELIM
  8974                                  		;JZ	GOTRESTR_J
  8975                                  		;CMP	AL,[SWITCHAR]
  8976                                  		;JZ	GOTRESTR_J
  8977                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  8978                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  8979                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  8980                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  8981                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  8982                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  8983                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  8984                                  		;DEC	SI		;AN002; back up over symbol
  8985                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  8986                                  ;GOTRESTR_J:
  8987                                  		;pop	cx		; MSKK06 07/14/89
  8988                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  8989                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  8990                                  		;STOSB			; store it into resgroup
  8991                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  8992                                  		;jmp	GOTRESTR_j
  8993                                  ;PIPEERRSYNJ5_J:
  8994                                  		;pop	cx		; recover CX
  8995                                  		;jmp	short PIPEERRSYNJ5
  8996                                  
  8997                                  		; MSDOS 3.3
  8998                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  8999 00001C89 AC                      		lodsb
  9000 00001C8A 3C0D                    		cmp	al,0Dh
  9001 00001C8C 746E                    		jz	short GOTRESTR
  9002 00001C8E E8F0FC                  		call	DELIM
  9003 00001C91 7469                    		jz	short GOTRESTR
  9004 00001C93 3A06[7542]              		cmp	al,[SWITCHAR]
  9005 00001C97 7463                    		je	short GOTRESTR
  9006 00001C99 3C22                    		cmp	al,'"'
  9007 00001C9B 7502                    		jne	short NO_ABRACKET
  9008 00001C9D FECD                    		dec	ch
  9009                                  NO_ABRACKET:
  9010 00001C9F AA                      		stosb
  9011 00001CA0 EBE7                    		jmp	short SETREOUTSTR_LOOP
  9012                                  NOOUT:
  9013                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9014 00001CA2 3A06[F23E]              		cmp	al,[LABRACKET]
  9015 00001CA6 751F                    		jnz	short CHKPIPE
  9016 00001CA8 89F3                    		mov	bx,si		; Save loc of "<"
  9017 00001CAA E8CCFC                  		call	SCANOFF
  9018                                  		; MSDOS 6.0
  9019                                  		;CMP	AL,[RABRACKET]	;AN040; was there no filename?
  9020                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9021                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9022 00001CAD 3C0D                    		cmp	al,0Dh
  9023 00001CAF 750B                    		jnz	short GOTREIFIL
  9024                                  REIN_ERRSET:				;AN040; set up for error
  9025 00001CB1 C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9026 00001CB4 C706[1C42]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9027 00001CBA EB64                    		jmp	short PRESCANEND
  9028                                  GOTREIFIL:
  9029 00001CBC 57                      		push	di
  9030 00001CBD BF[1C42]                		mov	di,RE_INSTR
  9031 00001CC0 89FB                    		mov	bx,di
  9032 00001CC2 06                      		push	es
  9033 00001CC3 0E                      		push	cs
  9034 00001CC4 07                      		pop	es		; store in TRANGROUP
  9035 00001CC5 EBC2                    		jmp	short SETREOUTSTR_LOOP 
  9036                                  					; Get the input redirection name
  9037                                  CHKPIPE:
  9038 00001CC7 88C4                    		mov	ah,al
  9039                                  		;cmp	ah,'|'
  9040 00001CC9 80FC7C                  		cmp	ah,ALTPIPECHR
  9041 00001CCC 7406                    		je	short ISPIPE3
  9042 00001CCE 3A26[F13E]              		cmp	ah,[VBAR]
  9043 00001CD2 753F                    		jne	short CONTPRESCAN
  9044                                  ISPIPE3:
  9045                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9046                                  
  9047 00001CD4 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9048 00001CDA 7505                    		jne	short NOECHOPUSH
  9049 00001CDC 26D026EF0B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9050                                  NOECHOPUSH:
  9051 00001CE1 26FE065C0C              		inc	byte [es:PIPEFLAG]
  9052 00001CE6 E890FC                  		call	SCANOFF
  9053 00001CE9 3C0D                    		cmp	al,0Dh
  9054 00001CEB 740A                    		jz	short PIPEERRSYNJ5
  9055                                  		;cmp	al,'|'
  9056 00001CED 3C7C                    		cmp	al,ALTPIPECHR
  9057 00001CEF 7406                    		jz	short PIPEERRSYNJ5
  9058 00001CF1 3A06[F13E]              		cmp	al,[VBAR]	; Double '|'?	
  9059 00001CF5 751C                    		jnz	short CONTPRESCAN
  9060                                  
  9061                                  PIPEERRSYNJ5:
  9062 00001CF7 06                      		push	es
  9063 00001CF8 1F                      		pop	ds
  9064 00001CF9 E93A02                  		jmp	PIPEERRSYN
  9065                                  
  9066                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9067                                  ; than just a : in the redir string.
  9068                                  
  9069                                  GOTRESTR:
  9070 00001CFC 86E0                    		xchg	ah,al
  9071 00001CFE B03A                    		mov	al,':'
  9072 00001D00 29FB                    		sub	bx,di		; compute negative of number of chars
  9073 00001D02 83FBFF                  		cmp	bx,-1		; is there just a :?
  9074 00001D05 7407                    		je	short NOTRAILCOL ; yep, don't change
  9075 00001D07 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9076 00001D0B 7501                    		jne	short NOTRAILCOL
  9077 00001D0D 4F                      		dec	di		; Back up over trailing ':'
  9078                                  NOTRAILCOL:
  9079 00001D0E 30C0                    		xor	al,al
  9080 00001D10 AA                      		stosb			; NUL terminate the string
  9081 00001D11 07                      		pop	es
  9082 00001D12 5F                      		pop	di		; Remember the start
  9083                                  CONTPRESCAN:
  9084 00001D13 8825                    		mov	[di],ah		; "delete" the redirection string
  9085 00001D15 47                      		inc	di
  9086 00001D16 80FC0D                  		cmp	ah,0Dh
  9087 00001D19 7405                    		je	short PRESCANEND
  9088 00001D1B FEC1                    		inc	cl
  9089 00001D1D E929FF                  		jmp	PRESCANLP
  9090                                  PRESCANEND:
  9091 00001D20 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9092 00001D26 7414                    		je	short ISNOPIPE
  9093                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9094 00001D28 BF800C                  		mov	di,PIPESTR
  9095 00001D2B 26893E7E0C              		mov	word [es:PIPEPTR],di
  9096 00001D30 BE[D240]                		mov	si,COMBUF+2
  9097 00001D33 E843FC                  		call	SCANOFF
  9098                                  PIPESETLP:				; Transfer the pipe into the resident
  9099 00001D36 AC                      		lodsb			; pipe buffer
  9100 00001D37 AA                      		stosb
  9101 00001D38 3C0D                    		cmp	al,0Dh
  9102 00001D3A 75FA                    		jnz	short PIPESETLP
  9103                                  ISNOPIPE:
  9104 00001D3C 880E[D140]              		mov	[COMBUF+1],cl
  9105 00001D40 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9106 00001D46 0E                      		push	cs
  9107 00001D47 07                      		pop	es
  9108 00001D48 C3                      		retn
  9109                                  
  9110                                  ; =============== S U B	R O U T	I N E =======================================
  9111                                  
  9112                                  CMD_COPY:
  9113 00001D49 BE[D240]                		mov	si,COMBUF+2
  9114 00001D4C E82AFC                  		call	SCANOFF		; advance past separators...
  9115 00001D4F 0336[C043]              		add	si,[PATHPOS]
  9116 00001D53 BF8100                  		mov	di,81h
  9117 00001D56 31C9                    		xor	cx,cx
  9118                                  CMDCOPY:
  9119 00001D58 AC                      		lodsb
  9120 00001D59 AA                      		stosb
  9121 00001D5A 3C0D                    		cmp	al,0Dh
  9122 00001D5C 7403                    		je	short COPY_DONE
  9123 00001D5E 41                      		inc	cx
  9124 00001D5F EBF7                    		jmp	short CMDCOPY
  9125                                  COPY_DONE:
  9126 00001D61 880E8000                		mov	[80h],cl
  9127 00001D65 C3                      		retn
  9128                                  
  9129                                  ; =============== S U B	R O U T	I N E =======================================
  9130                                  
  9131                                  TEST_APPEND:
  9132 00001D66 BB[D040]                		mov	bx,COMBUF	; barry can address
  9133 00001D69 BE[EB42]                		mov	si,IDLEN	; address command name, DS already set 	
  9134 00001D6C BAFFFF                  		mov	dx,-1
  9135 00001D6F B800AE                  		mov	ax,0AE00h
  9136 00001D72 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9137                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9138                                  				; DX = FFFFh,[BX -> command line
  9139                                  				; Return: AL = FFh if this command is a TSR extension 
  9140                                  				;		   to COMMAND.COM
  9141                                  				; AL = 00h if the command should be executed as	usual
  9142 00001D74 3C00                    		cmp	al,0
  9143 00001D76 C3                      		retn
  9144                                  
  9145                                  ;============================================================================
  9146                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9147                                  ;============================================================================
  9148                                  ; 05/10/2018 - Retro DOS v3.0
  9149                                  
  9150                                  ;	More misc routines
  9151                                  
  9152                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9153                                  
  9154                                  ; =============== S U B	R O U T	I N E =======================================
  9155                                  
  9156                                  SETPATH:
  9157                                  
  9158                                  ; ENTRY PathPos = ptr to string
  9159                                  ;       PathCnt = length of string
  9160                                  ;
  9161                                  ; EXIT  PathPos = ptr to string after pathname
  9162                                  ;       PathCnt = length of rest of string
  9163                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9164                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9165                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9166                                  ;
  9167                                  ;       A null character is dropped at the end of the pathname. If the
  9168                                  ;       character in that spot previously was CR, it is copied into the
  9169                                  ;       following byte. So there must be at least two two character 
  9170                                  ;       positions in the buffer following the pathname.
  9171                                  
  9172                                  		; MSDOS 6.0
  9173                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9174                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9175                                  
  9176                                  		; MSDOS 3.3
  9177 00001D77 BE8000                  		mov	si,80h
  9178 00001D7A AC                      		lodsb
  9179 00001D7B 30E4                    		xor	ah,ah
  9180 00001D7D A3[BE43]                		mov	[PATHCNT],ax
  9181 00001D80 8936[C043]              		mov	[PATHPOS],si
  9182                                  GETPATH:
  9183                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9184 00001D84 C606[7044]00            		mov	byte [DESTINFO],0
  9185 00001D89 C606[6C44]00            		mov	byte [DESTVARS],0
  9186 00001D8E 8B36[C043]              		mov	si,[PATHPOS]	; SI = ptr to string
  9187 00001D92 8B0E[BE43]              		mov	cx,[PATHCNT]	; CX = string length
  9188 00001D96 89F2                    		mov	dx,si		; DX = ptr to string
  9189 00001D98 E33D                    		jcxz	PATHDONE	; string length is zero, we're done
  9190 00001D9A 51                      		push	cx		; save string length
  9191 00001D9B 56                      		push	si		; save ptr to string
  9192 00001D9C E80BFD                  		call	SWITCH
  9193                                  
  9194                                  ;       After Switch, SI has been scanned past any switches, and
  9195                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9196                                  
  9197 00001D9F A3[C243]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9198 00001DA2 5B                      		pop	bx		; BX = ptr to original string
  9199 00001DA3 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9200 00001DA5 59                      		pop	cx		; CX = string length
  9201 00001DA6 01D9                    		add	cx,bx		; CX = string length from current SI
  9202 00001DA8 89F2                    		mov	dx,si		; DX = ptr to current string
  9203                                  SKIPPATH:
  9204 00001DAA E32B                    		jcxz	PATHDONE	; string length is zero, we're done
  9205 00001DAC 49                      		dec	cx		; CX = length left after next char
  9206 00001DAD AC                      		lodsb			; AL = next char of string
  9207                                  					; SI = ptr to char after this one
  9208 00001DAE E85BFC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9209 00001DB1 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9210 00001DB3 FE06[6C44]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9211                                  TESTPMETA:
  9212 00001DB7 3C3F                    		cmp	al,'?'
  9213 00001DB9 7505                    		jne	short TESTPSTAR	; char is not '?'
  9214 00001DBB 800E[7044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9215                                  TESTPSTAR:
  9216                                  		;cmp	al,'*'
  9217 00001DC0 3A06[FD3E]              		cmp	al,[STAR]
  9218 00001DC4 7505                    		jne	short TESTPDELIM ; char is not '*'
  9219 00001DC6 800E[7044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9220                                  TESTPDELIM:
  9221 00001DCB E8B3FB                  		call	DELIM		; compare AL to all delimiters
  9222 00001DCE 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9223 00001DD0 3A06[7542]              		cmp	al,[SWITCHAR]
  9224 00001DD4 75D4                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9225                                  PATHDONEDEC:
  9226 00001DD6 4E                      		dec	si		; SI = ptr to char after pathname
  9227                                  PATHDONE:
  9228 00001DD7 30C0                    		xor	al,al		; AL = NULL
  9229 00001DD9 8604                    		xchg	al,[si]		; place NULL after pathname
  9230 00001DDB 46                      		inc	si		; SI = ptr to byte after NULL
  9231 00001DDC 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9232 00001DDE 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9233 00001DE0 8804                    		mov	[si],al		; save EOL after NULL
  9234                                  NOPSTORE:
  9235 00001DE2 8936[C043]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9236 00001DE6 890E[BE43]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9237                                  SETPATH_RETN:
  9238 00001DEA C3                      		retn
  9239                                  
  9240                                  ; ---------------------------------------------------------------------------
  9241                                  
  9242                                  PGETARG:
  9243 00001DEB BE8000                  		mov	si,80h
  9244 00001DEE AC                      		lodsb
  9245 00001DEF 08C0                    		or	al,al
  9246 00001DF1 74F7                    		jz	short SETPATH_RETN
  9247 00001DF3 E80300                  		call	PSCANOFF
  9248 00001DF6 3C0D                    		cmp	al,0Dh
  9249 00001DF8 C3                      		retn
  9250                                  
  9251                                  ; ---------------------------------------------------------------------------
  9252                                  
  9253                                  PSCANOFF:
  9254 00001DF9 AC                      		lodsb
  9255 00001DFA E884FB                  		call	DELIM
  9256 00001DFD 7504                    		jnz	short PSCANOFFD
  9257 00001DFF 3C3B                    		cmp	al,';'
  9258 00001E01 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9259                                  PSCANOFFD:
  9260 00001E03 4E                      		dec	si		; Point to first non-delimiter
  9261 00001E04 C3                      		retn
  9262                                  
  9263                                  ; =============== S U B	R O U T	I N E =======================================
  9264                                  
  9265                                  IOSET:
  9266                                  		; ALL REGISTERS PRESERVED
  9267 00001E05 1E                      		push	ds
  9268 00001E06 52                      		push	dx
  9269 00001E07 50                      		push	ax
  9270 00001E08 53                      		push	bx
  9271 00001E09 51                      		push	cx
  9272 00001E0A 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9273 00001E0F 803E5C0C00              		cmp	byte [PIPEFLAG],0
  9274 00001E14 750D                    		jne	short NOREDIR
  9275 00001E16 F606FA0BFF              		test	byte [IFFLAG],0FFh
  9276 00001E1B 7506                    		jnz	short NOREDIR
  9277 00001E1D E80900                  		call	TESTDOREIN
  9278 00001E20 E85400                  		call	TESTDOREOUT
  9279                                  NOREDIR:
  9280 00001E23 59                      		pop	cx
  9281 00001E24 5B                      		pop	bx
  9282 00001E25 58                      		pop	ax
  9283 00001E26 5A                      		pop	dx
  9284 00001E27 1F                      		pop	ds
  9285                                  IOSET_RETN:
  9286 00001E28 C3                      		retn
  9287                                  
  9288                                  ; =============== S U B	R O U T	I N E =======================================
  9289                                  
  9290                                  TESTDOREIN:
  9291 00001E29 2E803E[1C42]00          		cmp	byte [cs:RE_INSTR],0
  9292 00001E2F 74F7                    		jz	short IOSET_RETN
  9293 00001E31 1E                      		push	ds
  9294 00001E32 0E                      		push	cs
  9295 00001E33 1F                      		pop	ds
  9296 00001E34 BA[1C42]                		mov	dx,RE_INSTR
  9297 00001E37 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9298 00001E3A 89C3                    		mov	bx,ax
  9299 00001E3C CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9300                                  				; DS:DX	-> ASCIZ filename
  9301                                  				; AL = access mode
  9302                                  				; 0 - read
  9303 00001E3E 1F                      		pop	ds
  9304 00001E3F 720B                    		jb	short REDIRERR
  9305 00001E41 89C3                    		mov	bx,ax
  9306 00001E43 B0FF                    		mov	al,0FFh
  9307                                  
  9308                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9309                                  ; spot. We invalidate the new JFN we got.
  9310                                  
  9311                                  		;xchg	al,[bx+18h]
  9312 00001E45 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9313 00001E48 A21800                  		mov	byte [PDB.JFN_TABLE],al
  9314 00001E4B C3                      		retn
  9315                                  
  9316                                  ; ---------------------------------------------------------------------------
  9317                                  
  9318                                  ; We had some kind of error on the redirection. Figure out what the
  9319                                  ; appropriate message should be; BX has the system call that failed
  9320                                  
  9321                                  REDIRERR:
  9322 00001E4C 0E                      		push	cs
  9323 00001E4D 1F                      		pop	ds
  9324                                  		;call	TriageError
  9325 00001E4E E87900                  		call	GET_EXT_ERR_NUMBER
  9326                                  
  9327                                  ; At this point, we have recognized the network-generated access denied error.
  9328                                  ; The correct message is in DX
  9329                                  
  9330 00001E51 83F841                  		cmp	ax,65
  9331 00001E54 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9332 00001E56 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9333 00001E59 7406                    		jz	short OPENERR
  9334 00001E5B BA[6E38]                		mov	dx,FULDIRPTR
  9335                                  _CERRORJ:
  9336 00001E5E E9C8FD                  		jmp	CERROR
  9337                                  
  9338                                  OPENERR:
  9339                                  ; The system call was an OPEN. Report either file not found or path not found.
  9340                                  
  9341                                  		; MSDOS 6.0
  9342                                  		;mov	msg_disp_class,ext_msg_class 
  9343                                  		;			;AN000; set up extended error msg class
  9344                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9345                                  		;			;AC000; get extended message pointer
  9346                                  		;mov	Extend_Buf_ptr,ax	
  9347                                  		;			;AN000; get message number in control block
  9348                                  		;JMP	CERROR
  9349                                  
  9350                                  		; MSDOS 3.3
  9351 00001E61 BA[F837]                		mov	dx,FNOTFOUNDPTR
  9352                                  		;cmp	ax,2
  9353 00001E64 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9354 00001E67 74F5                    		je	short _CERRORJ
  9355 00001E69 BA[1D38]                		mov	dx,ACCDENPTR
  9356                                  		;cmp	ax,5 ; Access denied error
  9357 00001E6C 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9358 00001E6F 74ED                    		je	short _CERRORJ
  9359                                  			; ERROR_PATH_NOT_FOUND
  9360 00001E71 BA[0B38]                		mov	dx,PNOTFOUNDPTR
  9361 00001E74 E9B2FD                  		jmp	CERROR
  9362                                  
  9363                                  ; =============== S U B	R O U T	I N E =======================================
  9364                                  
  9365                                  TESTDOREOUT:
  9366 00001E77 803E0B0C00              		cmp	byte [RE_OUTSTR],0
  9367 00001E7C 743D                    		je	short NOREOUT
  9368                                  
  9369                                  REOUTEXISTS:
  9370 00001E7E 803E0A0C00              		cmp	byte [RE_OUT_APP],0
  9371 00001E83 741F                    		je	short REOUTCRT
  9372                                  
  9373 00001E85 BA0B0C                  		mov	dx,RE_OUTSTR
  9374                                  
  9375                                  		; MSDOS 6.0
  9376                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9377                                  		;mov	ax,3D02h
  9378                                  
  9379                                  		; MSDOS 3.3
  9380 00001E88 B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9381                                  	
  9382                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9383 00001E8B 50                      		push	ax
  9384 00001E8C CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9385                                  				; DS:DX	-> ASCIZ filename
  9386                                  				; AL = access mode
  9387                                  				; 1 - write
  9388 00001E8E 5B                      		pop	bx
  9389 00001E8F 720D                    		jc	short OPENWRITEERROR
  9390                                  
  9391                                  		; MSDOS 6.0
  9392                                  		;MOV	BX,AX
  9393                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9394                                  		;INT	21h			;AN035;
  9395                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9396                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9397                                  		;
  9398                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9399                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9400                                  		;MOV	DX,CX			;AC011;
  9401                                  		;INT	21h
  9402                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9403                                  		;POP	DS			;AN011;
  9404                                  		;assume	DS:Trangroup		;AN011;
  9405                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9406                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9407                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9408                                  		;INT	21h			;AN011;
  9409                                  		;JC	OpenWriteError		;AN011; If error, exit
  9410                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9411                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9412                                  		;
  9413                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9414                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9415                                  		;assume	DS:Resgroup		;AN011;
  9416                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9417                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9418                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9419                                  		;MOV	DX,CX			;AN011;
  9420                                  		;INT	21h			;AN011;
  9421                                  		;JMP	SHORT SET_REOUT
  9422                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9423                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9424                                  		;assume	DS:Resgroup		;AN017;
  9425                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9426                                  		;XOR	CX,CX			;AN017; Offset is 0
  9427                                  		;MOV	DX,CX			;AN017;
  9428                                  		;INT	21h			;AN017;
  9429                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9430                                  
  9431                                  		; MSDOS 3.3
  9432 00001E91 31D2                    		xor	dx,dx
  9433 00001E93 31C9                    		xor	cx,cx
  9434 00001E95 89C3                    		mov	bx,ax
  9435 00001E97 B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9436 00001E9A CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9437                                  				; AL = method: offset from end of file
  9438 00001E9C EB15                    		jmp	short SET_REOUT
  9439                                  		
  9440                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9441                                  OPENWRITEERROR:	
  9442                                  		;cmp	ax,5
  9443 00001E9E 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9444 00001EA1 F9                      		stc
  9445 00001EA2 74A8                    		je	short REDIRERR
  9446                                  REOUTCRT:	
  9447 00001EA4 BA0B0C                  		mov	dx,RE_OUTSTR
  9448 00001EA7 31C9                    		xor	cx,cx
  9449 00001EA9 B43C                    		mov	ah,CREAT ; 3Ch
  9450 00001EAB 50                      		push	ax
  9451 00001EAC CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9452                                  				; CX = attributes for file
  9453                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9454 00001EAE 5B                      		pop	bx
  9455 00001EAF 729B                    		jc	short REDIRERR
  9456                                  NOREDIRERR:
  9457 00001EB1 89C3                    		mov	bx,ax
  9458                                  SET_REOUT:
  9459                                  
  9460                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9461                                  ; spot. We invalidate the new JFN we got.
  9462                                  
  9463 00001EB3 B0FF                    		mov	al,0FFh
  9464                                  		;xchg	al,[bx+18h]
  9465 00001EB5 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9466 00001EB8 A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9467                                  NOREOUT:
  9468 00001EBB C3                      		retn
  9469                                  
  9470                                  ; =============== S U B	R O U T	I N E =======================================
  9471                                  
  9472                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9473                                  ; registers
  9474                                  
  9475                                  DSTRLEN:
  9476 00001EBC 50                      		push	ax
  9477 00001EBD 31C9                    		xor	cx,cx
  9478 00001EBF FC                      		cld
  9479                                  DLOOP:
  9480 00001EC0 AC                      		lodsb
  9481 00001EC1 41                      		inc	cx
  9482 00001EC2 08C0                    		or	al,al
  9483 00001EC4 75FA                    		jnz	short DLOOP
  9484 00001EC6 29CE                    		sub	si,cx
  9485 00001EC8 58                      		pop	ax
  9486                                  TRIAGEERR_RETN:
  9487 00001EC9 C3                      		retn
  9488                                  
  9489                                  ; =============== S U B	R O U T	I N E =======================================
  9490                                  
  9491                                  ;Break	<Extended error support>
  9492                                  
  9493                                  TriageError:  ; MSDOS 6.0
  9494                                  
  9495                                  ;
  9496                                  ; TriageError will examine the return from a carry-set system call and
  9497                                  ; return the correct error if applicable.
  9498                                  ;
  9499                                  ;   Inputs:	outputs from a carry-settable system call
  9500                                  ;		No system calls may be done in the interrim
  9501                                  ;   Outputs:	If carry was set on input
  9502                                  ;		    carry set on output
  9503                                  ;		    DX contains trangroup offset to printf message
  9504                                  ;		else
  9505                                  ;		    No registers changed
  9506                                  ;
  9507                                  
  9508                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9509                                  
  9510                                  GET_EXT_ERR_NUMBER:
  9511 00001ECA 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9512 00001ECC 9C                      		pushf
  9513 00001ECD 53                      		push	bx
  9514 00001ECE 51                      		push	cx
  9515 00001ECF 56                      		push	si
  9516 00001ED0 57                      		push	di
  9517 00001ED1 55                      		push	bp
  9518 00001ED2 06                      		push	es
  9519 00001ED3 1E                      		push	ds
  9520 00001ED4 50                      		push	ax
  9521 00001ED5 52                      		push	dx
  9522                                  		;mov	ah,59h
  9523 00001ED6 B459                    		mov	ah,GETEXTENDEDERROR
  9524 00001ED8 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9525                                  				; BX = version code (0000h for DOS 3.x)
  9526 00001EDA 59                      		pop	cx
  9527 00001EDB 5B                      		pop	bx		; restore original AX
  9528 00001EDC BA[1D38]                		mov	dx,ACCDENPTR
  9529 00001EDF 83F841                  		cmp	ax,65		; network access denied?
  9530 00001EE2 7404                    		je	short NOMOVE	; Yes, return it.
  9531 00001EE4 89D8                    		mov	ax,bx
  9532 00001EE6 89CA                    		mov	dx,cx
  9533                                  NOMOVE:
  9534 00001EE8 1F                      		pop	ds
  9535 00001EE9 07                      		pop	es
  9536 00001EEA 5D                      		pop	bp
  9537 00001EEB 5F                      		pop	di
  9538 00001EEC 5E                      		pop	si
  9539 00001EED 59                      		pop	cx
  9540 00001EEE 5B                      		pop	bx
  9541 00001EEF 9D                      		popf
  9542 00001EF0 C3                      		retn
  9543                                  
  9544                                  ; =============== S U B	R O U T	I N E =======================================
  9545                                  
  9546                                  		; Far call from resident portion/segment of COMMAND.COM
  9547                                  
  9548                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9549                                  
  9550                                  TRIAGE_INIT:
  9551                                  		;call	TriageError
  9552 00001EF1 E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9553 00001EF4 CB                      		retf
  9554                                  
  9555                                  ;============================================================================
  9556                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9557                                  ;============================================================================
  9558                                  ; 03/10/2018 - Retro DOS v3.0
  9559                                  
  9560                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9561                                  
  9562                                  ; =============== S U B	R O U T	I N E =======================================
  9563                                  
  9564                                  SINGLETEST:
  9565 00001EF5 1E                      		push	ds
  9566 00001EF6 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9567 00001EFB 833EF50B00              		cmp	word [SINGLECOM],0
  9568 00001F00 7406                    		jz	short TESTDONE
  9569 00001F02 813EF50BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9570                                  TESTDONE:
  9571 00001F08 1F                      		pop	ds
  9572 00001F09 C3                      		retn
  9573                                  
  9574                                  ; =============== S U B	R O U T	I N E =======================================
  9575                                  
  9576                                  SETREST1:
  9577 00001F0A B001                    		mov	al,1
  9578                                  
  9579                                  ; ---------------------------------------------------------------------------
  9580                                  
  9581                                  SETREST:
  9582 00001F0C 1E                      		push	ds
  9583 00001F0D 8E1E[7142]              		mov	ds,[RESSEG]
  9584 00001F11 A2F30B                  		mov	byte [RESTDIR],al
  9585 00001F14 1F                      		pop	ds
  9586 00001F15 C3                      		retn
  9587                                  
  9588                                  ; =============== S U B	R O U T	I N E =======================================
  9589                                  
  9590                                  ; Note that we need to handle the same thing that RestDir handles: the
  9591                                  ; requirement that we try only once to restore the user's environment after
  9592                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9593                                  ; disappear, we just give up.
  9594                                  
  9595                                  PIPEDEL:
  9596 00001F16 1E                      		push	ds
  9597 00001F17 52                      		push	dx
  9598 00001F18 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9599 00001F1D BA5E0C                  		mov	dx,PIPE1	; Clean up in case ^C
  9600 00001F20 B441                    		mov	ah,UNLINK ; 41h 
  9601 00001F22 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9602                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9603                                  				;		(no wildcards allowed)
  9604 00001F24 BA6E0C                  		mov	dx,PIPE2
  9605 00001F27 B441                    		mov	ah,UNLINK ; 41h
  9606 00001F29 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9607                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9608                                  				;		(no wildcards allowed)
  9609 00001F2B 5A                      		pop	dx
  9610 00001F2C E85D04                  		call	PIPEOFF
  9611 00001F2F C6065D0C00              		mov	byte [PIPEFILES],0
  9612 00001F34 1F                      		pop	ds
  9613 00001F35 C3                      		retn
  9614                                  
  9615                                  ; ---------------------------------------------------------------------------
  9616                                  
  9617                                  PIPEERRSYN:
  9618 00001F36 BA[783C]                		mov	dx,SYNTMESPTR
  9619 00001F39 E8DAFF                  		call	PIPEDEL
  9620 00001F3C 0E                      		push	cs
  9621 00001F3D 1F                      		pop	ds
  9622 00001F3E E9E8FC                  		jmp	CERROR
  9623                                  
  9624                                  ; ---------------------------------------------------------------------------
  9625                                  
  9626                                  PIPERR:
  9627 00001F41 9C                      		pushf
  9628                                  		;invoke	TRIAGEERROR
  9629 00001F42 E885FF                  		call	GET_EXT_ERR_NUMBER
  9630 00001F45 50                      		push	ax		; Save results from TriageError
  9631 00001F46 52                      		push	dx
  9632 00001F47 BA[D23C]                		mov	dx,PIPEEMESPTR
  9633 00001F4A E8C9FF                  		call	PIPEDEL
  9634 00001F4D 0E                      		push	cs
  9635 00001F4E 1F                      		pop	ds
  9636 00001F4F E87815                  		call	STD_EPRINTF
  9637 00001F52 5A                      		pop	dx		; Restore results from TriageError
  9638 00001F53 58                      		pop	ax
  9639 00001F54 9D                      		popf
  9640 00001F55 83F841                  		cmp	ax,65
  9641 00001F58 7503                    		jnz	short TCOMMANDJ
  9642 00001F5A E9CCFC                  		jmp	CERROR
  9643                                  
  9644                                  TCOMMANDJ:
  9645 00001F5D E9A4E1                  		jmp	TCOMMAND
  9646                                  
  9647                                  PIPEPROCSTRT:
  9648 00001F60 8E1E[7142]              		mov	ds,[RESSEG]
  9649 00001F64 FE065D0C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9650                                  
  9651                                  		; MSDOS 6.0
  9652                                  		;push	es
  9653                                  		;push	di
  9654                                  		;push	ds
  9655                                  		;push	si
  9656                                  		;
  9657                                  		;push	ds
  9658                                  		;push	es
  9659                                  		;pop	ds				;ds = TRANGROUP
  9660                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9661                                  ;
  9662                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9663                                  ;so the routine is not really general
  9664                                  ;
  9665                                  		;call	Find_Name_In_Environment	;es:di points at path
  9666                                  		;pop	ds				;ds = DATARES again
  9667                                  		;jc	no_temp_path
  9668                                  		;
  9669                                  		;push	ds
  9670                                  		;push	es
  9671                                  		;pop	ds
  9672                                  		;pop	es				;swap ds and es
  9673                                  		;mov	si,di				;ds:si points at path
  9674                                  		;
  9675                                  		;call	skip_white			;skip white space chars
  9676                                  ;
  9677                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9678                                  ;
  9679                                  		;call	copy_pipe_path			;copy the pipe path
  9680                                  		;
  9681                                  ;
  9682                                  ;Check if the TEMP path is valid
  9683                                  ;
  9684                                  		;push	es
  9685                                  		;pop	ds				;ds = DATARES
  9686                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9687                                  		;mov	ax, (CHMOD shl 8) or 0
  9688                                  		;int	21h
  9689                                  		;jc	no_temp_path
  9690                                  		;
  9691                                  		;test	cx,10h				;is it a directory?
  9692                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9693                                  		;
  9694                                  		;stc					;no, indicate fail
  9695                                  no_temp_path:
  9696                                  		;pop	si
  9697                                  		;pop	ds
  9698                                  		;pop	di
  9699                                  		;pop	es
  9700                                  		;jnc	crt_temp			;path found, create tempfiles
  9701                                  
  9702                                  		; MSDOS 3.3
  9703 00001F68 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9704 00001F6A CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9705 00001F6C 2E0206[F03E]            		add	al,[cs:CAPITAL_A]
  9706 00001F71 A26E0C                  		mov	byte [PIPE2],al		; Make pipe files in root of def drv
  9707 00001F74 BB5E0C                  		mov	bx,PIPE1
  9708 00001F77 8807                    		mov	[bx],al
  9709 00001F79 30E4                    		xor	ah,ah			; nul terminate path names
  9710 00001F7B 8826610C                		mov	byte [PIPE1+3],ah
  9711 00001F7F 8826710C                		mov	byte [PIPE2+3],ah
  9712                                  
  9713                                  		; MSDOS 6.0
  9714                                  ;SR;
  9715                                  ; We want to create temp files in the current directory rather than in the 
  9716                                  ;root of the drive. This is because the number of files that can be present
  9717                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9718                                  ;
  9719                                  		;mov	ah,'.'
  9720                                  		;mov	Pipe1,ah
  9721                                  		;mov	Pipe2,ah
  9722                                  		;xor	ah,ah
  9723                                  		;mov	Pipe1+1,ah
  9724                                  		;mov	Pipe2+1,ah		;create files in current dir
  9725                                  
  9726                                  ;crt_temp:
  9727                                  		; MSDOS 6.0
  9728                                  		;mov	dx,offset DATARES:Pipe1
  9729                                  		;mov	dx,PIPE1
  9730                                  	
  9731                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9732 00001F83 89DA                    		mov	dx,bx
  9733 00001F85 31C9                    		xor	cx,cx
  9734 00001F87 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9735 00001F89 CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9736                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9737                                  			; receive generated filename
  9738                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9739 00001F8B 72B4                    		jc	short PIPERR	; Couldn't create
  9740 00001F8D 89C3                    		mov	bx,ax
  9741 00001F8F B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9742 00001F91 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9743                                  				; BX = file handle
  9744 00001F93 BA6E0C                  		mov	dx,PIPE2
  9745 00001F96 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9746 00001F98 CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9747                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9748                                  			; receive generated filename
  9749                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9750 00001F9A 72A5                    		jc	short PIPERR
  9751 00001F9C 89C3                    		mov	bx,ax
  9752 00001F9E B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9753 00001FA0 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9754                                  					; BX = file handle
  9755                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9756 00001FA2 E884FE                  		call	TESTDOREIN
  9757 00001FA5 8B367E0C                		mov	si,word [PIPEPTR]
  9758 00001FA9 833EF50BFF              		cmp	word [SINGLECOM],-1
  9759 00001FAE 7506                    		jne	short NOSINGP
  9760 00001FB0 C706F50B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9761                                  NOSINGP:
  9762 00001FB6 EB30                    		jmp	short FIRSTPIPE
  9763                                  
  9764                                  ; ---------------------------------------------------------------------------
  9765                                  
  9766                                  PIPEPROC:
  9767 00001FB8 8026EF0BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9768 00001FBD 8B367E0C                		mov	si,word [PIPEPTR]
  9769 00001FC1 AC                      		lodsb
  9770                                  		;cmp	al,'|'		
  9771 00001FC2 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9772 00001FC4 740A                    		je	short ISPIPE1	; Yes
  9773 00001FC6 2E3A06[F13E]            		cmp	al,[cs:VBAR]
  9774 00001FCB 7403                    		je	short ISPIPE1
  9775 00001FCD E98900                  		jmp	PIPEEND		; Pipe done
  9776                                  ISPIPE1:
  9777 00001FD0 8B16010D                		mov	dx,word [INPIPEPTR] ; Get the input file name
  9778 00001FD4 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9779 00001FD7 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9780                                  				; DS:DX	-> ASCIZ filename
  9781                                  				; AL = access mode
  9782                                  				; 0 - read
  9783                                  PIPEERRJ:
  9784 00001FD9 7303                    		jnc	short NO_PIPEERR
  9785 00001FDB E963FF                  		jmp	PIPERR		; Lost the pipe file
  9786                                  NO_PIPEERR:
  9787 00001FDE 89C3                    		mov	bx,ax
  9788 00001FE0 B0FF                    		mov	al,0FFh
  9789                                  		;xchg	al,[bx+18h]
  9790 00001FE2 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9791 00001FE5 A21800                  		mov	byte [PDB.JFN_TABLE],al	; Redirect
  9792                                  FIRSTPIPE:
  9793 00001FE8 BF[D240]                		mov	di,COMBUF+2
  9794 00001FEB 31C9                    		xor	cx,cx
  9795 00001FED 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9796 00001FF0 7503                    		jne	short PIPEOK1
  9797                                  PIPEERRSYNJ:
  9798 00001FF2 E941FF                  		jmp	PIPEERRSYN
  9799                                  PIPEOK1:
  9800 00001FF5 2EA0[F13E]              		mov	al,[cs:VBAR]
  9801 00001FF9 3804                    		cmp	[si],al		; '||'
  9802 00001FFB 74F5                    		je	short PIPEERRSYNJ
  9803                                  		;cmp	byte [si],'|'
  9804 00001FFD 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9805 00002000 74F0                    		je	short PIPEERRSYNJ
  9806                                  PIPECOMLP:
  9807 00002002 AC                      		lodsb
  9808 00002003 AA                      		stosb
  9809 00002004 3C0D                    		cmp	al,0Dh
  9810 00002006 743F                    		je	short LASTPIPE
  9811 00002008 41                      		inc	cx
  9812                                  		;cmp	al,'|'
  9813 00002009 3C7C                    		cmp	al,ALTPIPECHR
  9814 0000200B 7407                    		je	short ISPIPE2
  9815 0000200D 2E3A06[F13E]            		cmp	al,[cs:VBAR]
  9816 00002012 75EE                    		jne	short PIPECOMLP
  9817                                  ISPIPE2:
  9818 00002014 26C645FF0D              		mov	byte [es:di-1],0Dh
  9819 00002019 49                      		dec	cx
  9820 0000201A 2E880E[D140]            		mov	[cs:COMBUF+1],cl
  9821 0000201F 4E                      		dec	si
  9822 00002020 89367E0C                		mov	word [PIPEPTR],si	; On to next pipe element
  9823 00002024 8B16030D                		mov	dx,word [OUTPIPEPTR]
  9824 00002028 51                      		push	cx
  9825 00002029 31C9                    		xor	cx,cx
  9826 0000202B B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9827 0000202E CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9828                                  				; CX = attributes for file
  9829                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9830 00002030 59                      		pop	cx
  9831 00002031 72A6                    		jc	short PIPEERRJ		; Lost the file
  9832 00002033 89C3                    		mov	bx,ax
  9833 00002035 B0FF                    		mov	al,0FFh
  9834                                  		;xchg	al,[bx+18h]
  9835 00002037 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9836 0000203A A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9837 0000203D 8716010D                		xchg	dx,word [INPIPEPTR]	; Swap for next element of pipe
  9838 00002041 8916030D                		mov	word [OUTPIPEPTR],dx
  9839 00002045 EB0D                    		jmp	short PIPECOM
  9840                                  LASTPIPE:
  9841 00002047 2E880E[D140]            		mov	[cs:COMBUF+1],cl 
  9842 0000204C 4E                      		dec	si
  9843 0000204D 89367E0C                		mov	word [PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9844 00002051 E823FE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9845                                  PIPECOM:
  9846 00002054 0E                      		push	cs
  9847 00002055 1F                      		pop	ds
  9848 00002056 E95FE2                  		jmp	NOPIPEPROC	; Process the pipe element
  9849                                  PIPEEND:
  9850 00002059 E8BAFE                  		call	PIPEDEL
  9851 0000205C 813EF50B00F0            		cmp	word [SINGLECOM],0F000h
  9852 00002062 7506                    		jnz	short NOSINGP2
  9853 00002064 C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
  9854                                  NOSINGP2:
  9855 0000206A E997E0                  		jmp	TCOMMAND
  9856                                  
  9857                                  ; =============== S U B	R O U T	I N E =======================================
  9858                                  
  9859                                  ; Date and time are set during initialization and use
  9860                                  ; this routines since they need to do a long return
  9861                                  
  9862                                  DATINIT:
  9863 0000206D 2E8C1E[7142]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
  9864 00002072 06                      		push	es
  9865 00002073 1E                      		push	ds		; Going to use the previous stack
  9866 00002074 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
  9867 00002076 8EC0                    		mov	es,ax
  9868 00002078 8ED8                    		mov	ds,ax
  9869                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
  9870 0000207A BA[F84C]                		mov	dx,INTERNATVARS
  9871 0000207D B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  9872 00002080 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9873                                  				; get current-country info
  9874                                  				; DS:DX	-> buffer for returned info
  9875                                  		; 20/10/2018
  9876 00002082 C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
  9877 00002088 C606[D040]80            		mov	byte [COMBUF],128 ; Init COMBUF
  9878 0000208D C706[D140]010D          		mov	word [COMBUF+1],0D01h
  9879 00002093 E86C00                  		call	DATE
  9880 00002096 E88001                  		call	CTIME
  9881 00002099 1F                      		pop	ds
  9882 0000209A 07                      		pop	es
  9883 0000209B CB                      		retf
  9884                                  
  9885                                  ; =============== S U B	R O U T	I N E =======================================
  9886                                  
  9887                                  ; MSDOS 6.0
  9888                                  
  9889                                  ; ****************************************************************
  9890                                  ; *
  9891                                  ; * ROUTINE:	 DATE - Set system date
  9892                                  ; *
  9893                                  ; * FUNCTION:	 If a date is specified, set the system date,
  9894                                  ; *		 otherwise display the current system date and
  9895                                  ; *		 prompt the user for a new date.  If an invalid
  9896                                  ; *		 date is specified, issue an error message and
  9897                                  ; *		 prompt for a new date.  If the user enters
  9898                                  ; *		 nothing when prompted for a date, terminate.
  9899                                  ; *
  9900                                  ; * INPUT:	 command line at offset 81H
  9901                                  ; *
  9902                                  ; * OUTPUT:	 none
  9903                                  ; *
  9904                                  ; ****************************************************************
  9905                                  
  9906                                  ;assume	ds:trangroup,es:trangroup
  9907                                  ;
  9908                                  ;DATE:
  9909                                  ;	MOV	SI,81H				; Accepting argument for date inline
  9910                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
  9911                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9912                                  ;	xor	dx,dx				;AN000;
  9913                                  ;	invoke	cmd_parse			;AC000; call parser
  9914                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9915                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
  9916                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9917                                  ;	jne	daterr				;AN000; yes - go issue message
  9918                                  ;	JMP	short COMDAT			;AC000; we have a date
  9919                                  ;
  9920                                  ;PRMTDAT:
  9921                                  ;	; Print "Current date is
  9922                                  ;
  9923                                  ;	invoke	GetDate 			;AN000; get date  for output
  9924                                  ;	xchg	dh,dl				;AN000; switch month & day
  9925                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
  9926                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
  9927                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
  9928                                  ;	invoke	std_printf
  9929                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
  9930                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
  9931                                  ;
  9932                                  ;GET_NEW_DATE:					;AN000;
  9933                                  ;	call	getdat				;AC000; prompt user for date
  9934                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9935                                  ;	jz	date_end			;AC000; yes - exit
  9936                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9937                                  ;	jne	daterr				;AN000; yes - go issue message
  9938                                  ;COMDAT:
  9939                                  ;	mov	cx,date_year			;AC000; get parts of date in
  9940                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
  9941                                  ;	mov	dl,date_day			;AC000;    date function call.
  9942                                  ;	push	cx				;AC000; save date
  9943                                  ;	push	dx				;AC000;
  9944                                  ;	mov	cx,1				;AC000; set 1 positional entered
  9945                                  ;	xor	dx,dx				;AN029;
  9946                                  ;	invoke	cmd_parse			;AN029; call parser
  9947                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
  9948                                  ;	pop	dx				;AC000; retrieve date
  9949                                  ;	pop	cx				;AC000;
  9950                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
  9951                                  ;	MOV	AH,SET_DATE			;yes - set date
  9952                                  ;	INT	21h
  9953                                  ;	OR	AL,AL
  9954                                  ;	JNZ	DATERR
  9955                                  ;date_end:
  9956                                  ;	ret
  9957                                  ;
  9958                                  ;DATERR:
  9959                                  ;	invoke	crlf2				;AN028; print out a blank line
  9960                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
  9961                                  ;	invoke	std_printf
  9962                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
  9963                                  
  9964                                  ; =============== S U B	R O U T	I N E =======================================
  9965                                  
  9966                                  ; MSDOS 6.0
  9967                                  
  9968                                  ; TIME gets and sets the time
  9969                                  
  9970                                  ; ****************************************************************
  9971                                  ; *
  9972                                  ; * ROUTINE:	 TIME - Set system time
  9973                                  ; *
  9974                                  ; * FUNCTION:	 If a time is specified, set the system time,
  9975                                  ; *		 otherwise display the current system time and
  9976                                  ; *		 prompt the user for a new time.  If an invalid
  9977                                  ; *		 time is specified, issue an error message and
  9978                                  ; *		 prompt for a new time.  If the user enters
  9979                                  ; *		 nothing when prompted for a time, terminate.
  9980                                  ; *
  9981                                  ; * INPUT:	 command line at offset 81H
  9982                                  ; *
  9983                                  ; * OUTPUT:	 none
  9984                                  ; *
  9985                                  ; ****************************************************************
  9986                                  
  9987                                  ;assume	ds:trangroup,es:trangroup
  9988                                  ;
  9989                                  ;CTIME:
  9990                                  ;	MOV	SI,81H				; Accepting argument for time inline
  9991                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
  9992                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9993                                  ;	xor	dx,dx				;AN000;
  9994                                  ;	invoke	cmd_parse			;AC000; call parser
  9995                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9996                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
  9997                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9998                                  ;	jne	timerr				;AN000; yes - go issue message
  9999                                  ;	JMP	short COMTIM			;AC000; we have a time
 10000                                  ;
 10001                                  ;PRMTTIM:
 10002                                  ;	;Printf "Current time is ... "
 10003                                  ;
 10004                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10005                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10006                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10007                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10008                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10009                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10010                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10011                                  ;	invoke	std_printf
 10012                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10013                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10014                                  ;
 10015                                  ;GET_NEW_TIME:
 10016                                  ;	call	gettim				;AC000;
 10017                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10018                                  ;	jz	time_end			;AC000;
 10019                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10020                                  ;	jne	timerr				;AN000; yes - go issue message
 10021                                  ;
 10022                                  ;COMTIM:
 10023                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10024                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10025                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10026                                  ;	mov	dl,time_fraction		;AC000;
 10027                                  ;	push	cx				;AC000; save time
 10028                                  ;	push	dx				;AC000;
 10029                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10030                                  ;	xor	dx,dx				;AN029;
 10031                                  ;	invoke	cmd_parse			;AN029; call parser
 10032                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10033                                  ;	pop	dx				;AC000; retieve time
 10034                                  ;	pop	cx				;AC000;
 10035                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10036                                  ;
 10037                                  ;SAVTIM:
 10038                                  ;	MOV	AH,SET_TIME
 10039                                  ;	INT	21h
 10040                                  ;	OR	AL,AL
 10041                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10042                                  ;
 10043                                  ;TIME_END:
 10044                                  ;
 10045                                  ;	ret
 10046                                  ;
 10047                                  ;TIMERR:
 10048                                  ;	invoke	crlf2				;AN028; print out a blank line
 10049                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10050                                  ;	invoke	std_printf			; Print error message
 10051                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10052                                  
 10053                                  ; =============== S U B	R O U T	I N E =======================================
 10054                                  
 10055                                  ; MSDOS 6.0
 10056                                  
 10057                                  ;
 10058                                  ; Set the special flag in the INIT flag to the value in CX.
 10059                                  ;
 10060                                  
 10061                                  ;SetInitFlag:
 10062                                  ;	mov	ds,[RESSEG]
 10063                                  ;assume ds:resgroup
 10064                                  ;	and	InitFlag,NOT initSpecial
 10065                                  ;	or	InitFlag,cL
 10066                                  ;	push	cs
 10067                                  ;	pop	ds
 10068                                  ;	return
 10069                                  ;
 10070                                  ;Public	PipeOff
 10071                                  ;PipeOff:
 10072                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10073                                  ;	SaveReg <DS,AX>
 10074                                  ;	MOV	DS,ResSeg
 10075                                  ;	ASSUME	DS:RESGroup
 10076                                  ;	XOR	AL,AL
 10077                                  ;	XCHG	PipeFlag,AL
 10078                                  ;	OR	AL,AL
 10079                                  ;	JZ	PipeOffDone
 10080                                  ;	SHR	EchoFlag,1
 10081                                  ;PipeOffDone:
 10082                                  ;	RestoreReg  <AX,DS>
 10083                                  ;	return
 10084                                  
 10085                                  ; =============== S U B	R O U T	I N E =======================================
 10086                                  
 10087                                  ; MSDOS 6.0
 10088                                  
 10089                                  ;PRINT_TIME:
 10090                                  ;
 10091                                  ;	MOV	AH,GET_TIME
 10092                                  ;	INT	21h			; Get time in CX:DX
 10093                                  ;
 10094                                  ;	PUSH	ES
 10095                                  ;	PUSH	CS
 10096                                  ;	POP	ES
 10097                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10098                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10099                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10100                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10101                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10102                                  ;	invoke	std_printf
 10103                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10104                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10105                                  ;
 10106                                  ;	POP	ES
 10107                                  ;	return
 10108                                  
 10109                                  ; =============== S U B	R O U T	I N E =======================================
 10110                                  
 10111                                  ; MSDOS 6.0
 10112                                  
 10113                                  ; ****************************************************************
 10114                                  ; *
 10115                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10116                                  ; *
 10117                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10118                                  ; *		 INFORMATION and issues the "Enter new date"
 10119                                  ; *		 message with the proper date format.  COMBUF
 10120                                  ; *		 is reset to get a date from the command line.
 10121                                  ; *		 The PARSE_DATE blocks are then reset and the
 10122                                  ; *		 PARSE function call is issued.
 10123                                  ; *
 10124                                  ; * INPUT:	 NONE
 10125                                  ; *
 10126                                  ; * OUTPUT:	 COMBUF
 10127                                  ; *		 PARSER RETURN CODES
 10128                                  ; *
 10129                                  ; ****************************************************************
 10130                                  
 10131                                  ;GETDAT	proc	near				;AC000;
 10132                                  ;
 10133                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10134                                  ;	mov	dx,5ch				;  should be entered in and
 10135                                  ;	int	21h			;  print a message describing it
 10136                                  ;	mov	si,dx
 10137                                  ;	lodsw
 10138                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10139                                  ;	dec	ax
 10140                                  ;	js	printformat
 10141                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10142                                  ;	jz	printformat
 10143                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10144                                  ;printformat:
 10145                                  ;	mov	ax,dx				;AN000; get message number of format
 10146                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10147                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10148                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10149                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10150                                  ;	invoke	std_printf
 10151                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10152                                  ;
 10153                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10154                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10155                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10156                                  ;	call	SetInitFlag			;  prompting for date.
 10157                                  ;	INT	21h			; Get input line
 10158                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10159                                  ;	call	SetInitFlag			;  prompting for date.
 10160                                  ;	invoke	CRLF2
 10161                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10162                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
 10163                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10164                                  ;	xor	dx,dx				;AN000;
 10165                                  ;	invoke	cmd_parse			;AC000; call parser
 10166                                  ;
 10167                                  ;	ret
 10168                                  ;
 10169                                  ;GETDAT	endp					;AC000;
 10170                                  
 10171                                  ; =============== S U B	R O U T	I N E =======================================
 10172                                  
 10173                                  ; MSDOS 6.0
 10174                                  
 10175                                  ; ****************************************************************
 10176                                  ; *
 10177                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10178                                  ; *
 10179                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10180                                  ; *		 INFORMATION and issues the "Enter new time"
 10181                                  ; *		 message. COMBUF is reset to get a time from the
 10182                                  ; *		 command line.	The PARSE_TIME blocks are then
 10183                                  ; *		 reset and the PARSE function call is issued.
 10184                                  ; *
 10185                                  ; * INPUT:	 NONE
 10186                                  ; *
 10187                                  ; * OUTPUT:	 COMBUF
 10188                                  ; *		 PARSER RETURN CODES
 10189                                  ; *
 10190                                  ; ****************************************************************
 10191                                  
 10192                                  ;GETTIM	proc	near				;AC000;
 10193                                  ;
 10194                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10195                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10196                                  ;	invoke	std_printf
 10197                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10198                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10199                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10200                                  ;	call	SetInitFlag			;  prompting for time.
 10201                                  ;	INT	21h			; Get input line
 10202                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10203                                  ;	call	SetInitFlag			;  prompting for time.
 10204                                  ;	invoke	CRLF2
 10205                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10206                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
 10207                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10208                                  ;	xor	dx,dx				;AN000;
 10209                                  ;	invoke	cmd_parse			;AC000; call parser
 10210                                  ;
 10211                                  ;	ret
 10212                                  ;
 10213                                  ;GETTIM	endp					;AC000;
 10214                                  
 10215                                  ; =============== S U B	R O U T	I N E =======================================
 10216                                  
 10217                                  ; MSDOS 6.0
 10218                                  
 10219                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10220                                  ;the '=' sign in the environment variable before the actual path.
 10221                                  ;
 10222                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10223                                  ;
 10224                                  ;	EXIT:	ds:si = start of the path
 10225                                  ;
 10226                                  ;	REGISTERS AFFECTED: ax
 10227                                  ;
 10228                                  
 10229                                  ;Skip_white	proc	near
 10230                                  ;
 10231                                  ;	cld
 10232                                  ;skw_lp:
 10233                                  ;	lodsb
 10234                                  ;	cmp	al,' '				;blank char?
 10235                                  ;	jz	skw_lp				;yes, skip it
 10236                                  ;	cmp	al,09				;tab char?
 10237                                  ;	jz	skw_lp				;yes, skip it
 10238                                  ;
 10239                                  ;	dec	si				;point at first non-white
 10240                                  ;
 10241                                  ;	ret
 10242                                  ;
 10243                                  ;Skip_white	endp
 10244                                  
 10245                                  ; =============== S U B	R O U T	I N E =======================================
 10246                                  
 10247                                  ; MSDOS 6.0
 10248                                  
 10249                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10250                                  ;variable into the path buffers Pipe1 & Pipe2.
 10251                                  ;
 10252                                  ;	ENTRY:	ds:si = path to be copied
 10253                                  ;		es = RESGROUP
 10254                                  ;
 10255                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10256                                  ;
 10257                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10258                                  ;
 10259                                  
 10260                                  ;Copy_pipe_path	proc	near
 10261                                  ;
 10262                                  ;	mov	cx,0ffffh
 10263                                  ;	xor	al,al
 10264                                  ;
 10265                                  ;	mov	di,si
 10266                                  ;	push	es			;save es
 10267                                  ;	push	ds
 10268                                  ;	pop	es			;es:di = path to be copied
 10269                                  ;	
 10270                                  ;	cld
 10271                                  ;	push	di
 10272                                  ;	repnz	scasb			;look for the null char
 10273                                  ;	pop	di
 10274                                  ;
 10275                                  ;	pop	es			;es = RESGROUP again
 10276                                  ;
 10277                                  ;	not	cx			;length including the null
 10278                                  ;
 10279                                  ;	mov	di,offset DATARES:Pipe1	
 10280                                  ;	push	di
 10281                                  ;	push	cx			
 10282                                  ;	rep	movsb			;copy path into Pipe1
 10283                                  ;	pop	cx
 10284                                  ;	pop	di
 10285                                  ;
 10286                                  ;	push	ds
 10287                                  ;	push	es
 10288                                  ;	pop	ds			;ds:si = Pipe1
 10289                                  ;	mov	si,di
 10290                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10291                                  ;	rep	movsb			;copy path into Pipe2
 10292                                  ;	pop	ds
 10293                                  ;
 10294                                  ;	ret				;
 10295                                  ;
 10296                                  ;Copy_pipe_path	endp
 10297                                  
 10298                                  ;============================================================================
 10299                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10300                                  ;============================================================================
 10301                                  ; 05/10/2018 - Retro DOS v3.0
 10302                                  
 10303                                  ; DATE - Gets and sets the time
 10304                                  
 10305                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10306                                  
 10307                                  ; =============== S U B	R O U T	I N E =======================================
 10308                                  
 10309                                  DATE_CXDX:
 10310 0000209C 89CB                    		mov	bx,cx
 10311                                  
 10312                                  ; =============== S U B	R O U T	I N E =======================================
 10313                                  
 10314                                  P_DATE:
 10315 0000209E 89D8                    		mov	ax,bx
 10316 000020A0 89D1                    		mov	cx,dx
 10317 000020A2 B264                    		mov	dl,100
 10318 000020A4 F6F2                    		div	dl
 10319 000020A6 86C4                    		xchg	al,ah
 10320 000020A8 92                      		xchg	ax,dx
 10321 000020A9 B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10322                                  		;mov	ax,[INTERNATVARS]
 10323 000020AB A1[F84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10324 000020AE 09C0                    		or	ax,ax
 10325 000020B0 7415                    		jz	short USPDAT
 10326 000020B2 48                      		dec	ax
 10327 000020B3 7422                    		jz	short EUPDAT
 10328 000020B5 B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10329 000020B7 E83900                  		call	P_YR
 10330 000020BA E82B00                  		call	P_DSEP
 10331 000020BD E82200                  		call	P_MON
 10332 000020C0 E82500                  		call	P_DSEP
 10333 000020C3 E82700                  		call	P_DAY
 10334 000020C6 C3                      		retn
 10335                                  
 10336                                  USPDAT:
 10337 000020C7 E81800                  		call	P_MON
 10338 000020CA E81B00                  		call	P_DSEP
 10339 000020CD E81D00                  		call	P_DAY
 10340                                  PLST:
 10341 000020D0 E81500                  		call	P_DSEP
 10342 000020D3 E81D00                  		call	P_YR
 10343 000020D6 C3                      		retn
 10344                                  
 10345                                  EUPDAT:
 10346 000020D7 E81300                  		call	P_DAY
 10347 000020DA E80B00                  		call	P_DSEP
 10348 000020DD E80200                  		call	P_MON
 10349 000020E0 EBEE                    		jmp	short PLST
 10350                                  
 10351                                  ; ---------------------------------------------------------------------------
 10352                                  
 10353                                  P_MON:
 10354 000020E2 88E8                    		mov	al,ch
 10355 000020E4 E88402                  		call	OUT2
 10356 000020E7 C3                      		retn
 10357                                  
 10358                                  ; ---------------------------------------------------------------------------
 10359                                  
 10360                                  P_DSEP:
 10361                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10362 000020E8 A0[034D]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10363 000020EB AA                      		stosb
 10364 000020EC C3                      		retn
 10365                                  
 10366                                  ; ---------------------------------------------------------------------------
 10367                                  
 10368                                  P_DAY:
 10369 000020ED 88C8                    		mov	al,cl
 10370 000020EF E87902                  		call	OUT2
 10371 000020F2 C3                      		retn
 10372                                  
 10373                                  ; ---------------------------------------------------------------------------
 10374                                  
 10375                                  P_YR:
 10376 000020F3 88F0                    		mov	al,dh
 10377 000020F5 08C0                    		or	al,al
 10378 000020F7 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10379 000020F9 E86F02                  		call	OUT2
 10380                                  TWODIGYR:
 10381 000020FC 88D0                    		mov	al,dl
 10382 000020FE E86A02                  		call	OUT2
 10383                                  DATE_RETN:
 10384 00002101 C3                      		retn
 10385                                  
 10386                                  ; =============== S U B	R O U T	I N E =======================================
 10387                                  
 10388                                  DATE:				 	; Accepting argument for date inline
 10389 00002102 BE8100                  		mov	si,81h
 10390 00002105 E871F8                  		call	SCANOFF
 10391 00002108 3C0D                    		cmp	al,0Dh
 10392 0000210A 7402                    		jz	short PRMTDAT
 10393 0000210C EB48                    		jmp	short COMDAT
 10394                                  
 10395                                  		;nop
 10396                                  
 10397                                  PRMTDAT:
 10398                                  		; MSDOS 3.3
 10399 0000210E BA[5B3A]                		mov	dx,CURDATPTR
 10400 00002111 E8BF13                  		call	STD_PRINTF	; Print "Current date is "	
 10401 00002114 E88808                  		call	PRINT_DATE
 10402                                  
 10403                                  GETDAT:	
 10404 00002117 BA[6F3A]                		mov	dx,NEWDATPTR
 10405 0000211A E8B613                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10406                                  
 10407 0000211D B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10408                                  					; Determine what format the date
 10409 00002120 BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10410 00002123 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10411                                  				; get current-country info
 10412                                  				; DS:DX	-> buffer for returned info
 10413 00002125 89D6                    		mov	si,dx		;  print a message describing it
 10414 00002127 AD                      		lodsw
 10415 00002128 BA[7E3A]                		mov	dx,USADATPTR	; get mm-dd-yy
 10416 0000212B 48                      		dec	ax
 10417 0000212C 7808                    		js	short PRINTFORMAT
 10418 0000212E BA[8D3A]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10419 00002131 7403                    		jz	short PRINTFORMAT
 10420 00002133 BA[9C3A]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10421                                  PRINTFORMAT:
 10422 00002136 E89A13                  		call	STD_PRINTF
 10423 00002139 B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10424 0000213B BA[D040]                		mov	dx,COMBUF
 10425 0000213E B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10426 00002141 E83802                  		call	SETINITFLAG	;  prompting for date.
 10427 00002144 CD21                    		int	21h		; Get input line
 10428 00002146 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10429 00002148 E83102                  		call	SETINITFLAG	;  prompting for date.
 10430 0000214B E81EF8                  		call	CRLF2
 10431 0000214E BE[D240]                		mov	si,COMBUF+2
 10432 00002151 803C0D                  		cmp	byte [si],0Dh
 10433 00002154 74AB                    		jz	short DATE_RETN
 10434                                  COMDAT:
 10435                                  		;mov	ax,[INTERNATVARS]
 10436 00002156 A1[F84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10437 00002159 09C0                    		or	ax,ax
 10438 0000215B 7435                    		jz	short USSDAT
 10439 0000215D 48                      		dec	ax
 10440 0000215E 744B                    		jz	short EUSDAT
 10441 00002160 E86500                  		call	GET_YR
 10442 00002163 7235                    		jc	short DATERRJ
 10443 00002165 E89E00                  		call	GET_DSEP
 10444 00002168 7230                    		jc	short DATERRJ
 10445 0000216A E84D00                  		call	GET_MON
 10446 0000216D 722B                    		jc	short DATERRJ
 10447 0000216F E89400                  		call	GET_DSEP
 10448 00002172 7226                    		jc	short DATERRJ
 10449 00002174 E84B00                  		call	GET_DAY
 10450                                  DAT_SET:
 10451 00002177 7303                    		jnc	short DATSET
 10452 00002179 E98100                  		jmp	DATERR
 10453                                  
 10454                                  ; ---------------------------------------------------------------------------
 10455                                  
 10456                                  DATSET:
 10457 0000217C AC                      		lodsb
 10458 0000217D 3C20                    		cmp	al,' '
 10459 0000217F 74FB                    		jz	short DATSET
 10460 00002181 3C09                    		cmp	al,9
 10461 00002183 74F7                    		jz	short DATSET
 10462 00002185 3C0D                    		cmp	al,0Dh
 10463 00002187 7574                    		jnz	short DATERR
 10464 00002189 B42B                    		mov	ah,SET_DATE ; 2Bh
 10465 0000218B CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10466                                  				; DL = day,DH = month,	CX = year
 10467                                  				; Return: AL = 00h if no error 
 10468                                  				; 	     = FFh if bad value sent to routine
 10469 0000218D 08C0                    		or	al,al
 10470 0000218F 756C                    		jnz	short DATERR
 10471                                  DAT_SET_RETN:
 10472 00002191 C3                      		retn
 10473                                  
 10474                                  ; ---------------------------------------------------------------------------
 10475                                  
 10476                                  USSDAT:
 10477 00002192 E82500                  		call	GET_MON
 10478 00002195 7266                    		jb	short DATERR
 10479 00002197 E86C00                  		call	GET_DSEP
 10480                                  DATERRJ:
 10481 0000219A 7261                    		jc	short DATERR
 10482 0000219C E82300                  		call	GET_DAY
 10483                                  TGET:
 10484 0000219F 725C                    		jc	short DATERR
 10485 000021A1 E86200                  		call	GET_DSEP
 10486 000021A4 7257                    		jc	short DATERR
 10487 000021A6 E81F00                  		call	GET_YR
 10488 000021A9 EBCC                    		jmp	short DAT_SET
 10489                                  
 10490                                  ; ---------------------------------------------------------------------------
 10491                                  
 10492                                  EUSDAT:
 10493 000021AB E81400                  		call	GET_DAY
 10494 000021AE 724D                    		jc	short DATERR
 10495 000021B0 E85300                  		call	GET_DSEP
 10496 000021B3 7248                    		jc	short DATERR
 10497 000021B5 E80200                  		call	GET_MON
 10498 000021B8 EBE5                    		jmp	short TGET
 10499                                  
 10500                                  
 10501                                  ; =============== S U B	R O U T	I N E =======================================
 10502                                  
 10503                                  GET_MON:
 10504 000021BA E88E01                  		call	GETNUM		; Get one or two digit number
 10505 000021BD 72D2                    		jc	short DAT_SET_RETN
 10506 000021BF 88E6                    		mov	dh,ah		; Put in position
 10507 000021C1 C3                      		retn
 10508                                  
 10509                                  
 10510                                  ; =============== S U B	R O U T	I N E =======================================
 10511                                  
 10512                                  GET_DAY:
 10513 000021C2 E88601                  		call	GETNUM
 10514 000021C5 88E2                    		mov	dl,ah		; Put in position
 10515                                  GET_DAY_RETN:
 10516 000021C7 C3                      		retn
 10517                                  
 10518                                  ; =============== S U B	R O U T	I N E =======================================
 10519                                  
 10520                                  GET_YR:
 10521 000021C8 E88001                  		call	GETNUM
 10522 000021CB 72FA                    		jc	short GET_DAY_RETN
 10523 000021CD B96C07                  		mov	cx,1900
 10524 000021D0 E83300                  		call	GET_DSEP
 10525 000021D3 9C                      		pushf
 10526 000021D4 4E                      		dec	si
 10527 000021D5 9D                      		popf
 10528 000021D6 741E                    		jz	short BIAS
 10529 000021D8 803C0D                  		cmp	byte [si],0Dh
 10530 000021DB 7419                    		je	short BIAS
 10531 000021DD 803C20                  		cmp	byte [si],' '
 10532 000021E0 7414                    		je	short BIAS
 10533 000021E2 803C09                  		cmp	byte [si],9
 10534 000021E5 740F                    		je	short BIAS
 10535 000021E7 53                      		push	bx
 10536 000021E8 B364                    		mov	bl,100
 10537 000021EA 88E0                    		mov	al,ah
 10538 000021EC F6E3                    		mul	bl
 10539 000021EE 5B                      		pop	bx
 10540 000021EF 89C1                    		mov	cx,ax
 10541 000021F1 E85701                  		call	GETNUM
 10542 000021F4 72D1                    		jc	short GET_DAY_RETN
 10543                                  BIAS:
 10544 000021F6 88E0                    		mov	al,ah
 10545 000021F8 B400                    		mov	ah,0
 10546 000021FA 01C1                    		add	cx,ax
 10547                                  BIAS_RETN:
 10548 000021FC C3                      		retn
 10549                                  
 10550                                  ; ---------------------------------------------------------------------------
 10551                                  
 10552                                  DATERR:
 10553 000021FD BA[483A]                		mov	dx,BADDATPTR
 10554 00002200 E8D012                  		call	STD_PRINTF
 10555 00002203 E911FF                  		jmp	GETDAT
 10556                                  
 10557                                  ; =============== S U B	R O U T	I N E =======================================
 10558                                  
 10559                                  GET_DSEP:
 10560 00002206 AC                      		lodsb
 10561 00002207 3C2F                    		cmp	al,'/'
 10562 00002209 74F1                    		je	short BIAS_RETN
 10563                                  		;cmp	al,'.'
 10564 0000220B 3A06[083F]              		cmp	al,[DOT_CHR]
 10565 0000220F 74EB                    		je	short BIAS_RETN
 10566                                  		;cmp	al,'-'
 10567 00002211 3A06[FE3E]              		cmp	al,[CHAR_SUB]
 10568 00002215 74E5                    		je	short BIAS_RETN
 10569 00002217 F9                      		stc
 10570 00002218 C3                      		retn
 10571                                  
 10572                                  ; =============== S U B	R O U T	I N E =======================================
 10573                                  
 10574                                  ; TIME gets and sets the time
 10575                                  
 10576                                  CTIME:
 10577 00002219 BE8100                  		mov	si,81h		; Accepting argument for time inline
 10578 0000221C E85AF7                  		call	SCANOFF
 10579 0000221F 3C0D                    		cmp	al,0Dh
 10580 00002221 747C                    		je	short PRMTTIM
 10581 00002223 BB3A2E                  		mov	bx,2E3Ah ; ":."
 10582 00002226 E80601                  		call	INLINE
 10583 00002229 E98B00                  		jmp	COMTIM
 10584                                  
 10585                                  ; =============== S U B	R O U T	I N E =======================================
 10586                                  
 10587                                  PRINT_TIME:
 10588 0000222C B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10589 0000222E CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10590                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10591                                  				; DL = hundredths of seconds
 10592 00002230 57                      		push	di
 10593 00002231 06                      		push	es
 10594 00002232 0E                      		push	cs
 10595 00002233 07                      		pop	es
 10596 00002234 BF[9B42]                		mov	di,CHARBUF
 10597 00002237 B301                    		mov	bl,1	; Always 24 hour time
 10598 00002239 E81300                  		call	P_TIME
 10599 0000223C 31C0                    		xor	ax,ax
 10600 0000223E AA                      		stosb
 10601 0000223F BA[9B42]                		mov	dx,CHARBUF
 10602 00002242 8916[4E44]              		mov	[STRING_PTR_2],dx
 10603 00002246 BA[3F37]                		mov	dx,STRINGBUF2PTR
 10604 00002249 E88712                  		call	STD_PRINTF
 10605 0000224C 07                      		pop	es
 10606 0000224D 5F                      		pop	di
 10607                                  P_TIME_RETN:
 10608 0000224E C3                      		retn
 10609                                  
 10610                                  ; =============== S U B	R O U T	I N E =======================================
 10611                                  
 10612                                  P_TIME:
 10613 0000224F 88E8                    		mov	al,ch	
 10614 00002251 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10615 00002254 7512                    		jnz	short T24	; 24 hr time?
 10616 00002256 B761                    		mov	bh,'a'		; Assume A.M.
 10617 00002258 3C0C                    		cmp	al,12		; In the afternoon?
 10618 0000225A 7206                    		jb	short MORN
 10619 0000225C B770                    		mov	bh,'p'
 10620 0000225E 7402                    		jz	short MORN
 10621 00002260 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10622                                  MORN:
 10623 00002262 08C0                    		or	al,al		; Before 1 am?
 10624 00002264 7502                    		jnz	short T24
 10625 00002266 B00C                    		mov	al,12
 10626                                  T24:
 10627 00002268 53                      		push	bx
 10628 00002269 B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10629 0000226B E8FD00                  		call	OUT2
 10630 0000226E E82900                  		call	P_TSEP
 10631 00002271 88C8                    		mov	al,cl
 10632 00002273 E8F500                  		call	OUT2
 10633 00002276 5B                      		pop	bx
 10634 00002277 53                      		push	bx
 10635 00002278 F6C380                  		test	bl,80h
 10636 0000227B 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10637 0000227D B700                    		mov	bh,0		; Disable leading zero suppression
 10638 0000227F E81800                  		call	P_TSEP
 10639 00002282 88F0                    		mov	al,dh
 10640 00002284 E8E400                  		call	OUT2
 10641                                  		;mov	al,'.'
 10642 00002287 A0[014D]                		mov	al,[DECIMAL_SEP]
 10643 0000228A AA                      		stosb
 10644 0000228B 88D0                    		mov	al,dl
 10645 0000228D E8DB00                  		call	OUT2
 10646                                  PAP:
 10647 00002290 5B                      		pop	bx
 10648 00002291 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10649 00002294 75B8                    		jnz	short P_TIME_RETN
 10650 00002296 88F8                    		mov	al,bh
 10651 00002298 AA                      		stosb
 10652 00002299 C3                      		retn
 10653                                  
 10654                                  ; =============== S U B	R O U T	I N E =======================================
 10655                                  
 10656                                  P_TSEP:
 10657                                  		;mov	al,[TIME_SEP]
 10658 0000229A A0[054D]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10659 0000229D AA                      		stosb
 10660                                  P_TSEP_RETN:
 10661 0000229E C3                      		retn
 10662                                  
 10663                                  ; ---------------------------------------------------------------------------
 10664                                  
 10665                                  PRMTTIM:
 10666 0000229F BA[C13A]                		mov	dx,CURTIMPTR
 10667 000022A2 E82E12                  		call	STD_PRINTF	; Print "Current time is "
 10668 000022A5 E884FF                  		call	PRINT_TIME
 10669                                  GETTIM:
 10670 000022A8 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10671 000022AA BA[D63A]                		mov	dx,NEWTIMPTR
 10672 000022AD E82312                  		call	STD_PRINTF
 10673                                  		;mov	bx,':.'
 10674 000022B0 8B1E[0C3F]              		mov	bx,[TIMECHARS] 
 10675 000022B4 E85B00                  		call	GETBUF
 10676                                  COMTIM:
 10677 000022B7 74E5                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10678 000022B9 724F                    		jc	short TIMEERR
 10679 000022BB 89D1                    		mov	cx,dx
 10680 000022BD 31D2                    		xor	dx,dx
 10681 000022BF AC                      		lodsb
 10682 000022C0 3C0D                    		cmp	al,0Dh
 10683 000022C2 743E                    		je	short SAVTIM
 10684 000022C4 3C20                    		cmp	al,' '
 10685 000022C6 742D                    		je	short GOTSEC2
 10686 000022C8 3C09                    		cmp	al,9
 10687 000022CA 7429                    		je	short GOTSEC2
 10688 000022CC 38D8                    		cmp	al,bl
 10689 000022CE 7404                    		je	short GOTSEC
 10690 000022D0 38F8                    		cmp	al,bh
 10691 000022D2 7536                    		jne	short TIMEERR
 10692                                  GOTSEC:
 10693 000022D4 E87400                  		call	GETNUM
 10694 000022D7 7231                    		jc	short TIMEERR
 10695 000022D9 88E6                    		mov	dh,ah		; Position seconds
 10696 000022DB AC                      		lodsb
 10697 000022DC 3C0D                    		cmp	al,0Dh
 10698 000022DE 7422                    		je	short SAVTIM
 10699 000022E0 3C20                    		cmp	al,' '
 10700 000022E2 7411                    		je	short GOTSEC2
 10701 000022E4 3C09                    		cmp	al,9
 10702 000022E6 740D                    		je	short GOTSEC2
 10703                                  		;cmp	al,'.'
 10704 000022E8 3A06[014D]              		cmp	al,[DECIMAL_SEP]
 10705 000022EC 751C                    		jne	short TIMEERR
 10706 000022EE E85A00                  		call	GETNUM
 10707 000022F1 7217                    		jc	short TIMEERR
 10708 000022F3 88E2                    		mov	dl,ah
 10709                                  GOTSEC2:
 10710 000022F5 AC                      		lodsb
 10711 000022F6 3C20                    		cmp	al,' '
 10712 000022F8 74FB                    		je	short GOTSEC2
 10713 000022FA 3C09                    		cmp	al,9
 10714 000022FC 74F7                    		je	short GOTSEC2
 10715 000022FE 3C0D                    		cmp	al,0Dh
 10716 00002300 7508                    		jne	short TIMEERR
 10717                                  SAVTIM:
 10718 00002302 B42D                    		mov	ah,SET_TIME ; 2Dh
 10719 00002304 CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10720                                  				; CH = hours,CL = minutes,DH = seconds,
 10721                                  				;		DL = hundredths of seconds
 10722                                  				; Return: AL = 00h if no error 
 10723                                  				;	     = FFh if bad value sent to routine
 10724 00002306 08C0                    		or	al,al
 10725                                  P_TSEP_JRETN:
 10726 00002308 7494                    		jz	short P_TSEP_RETN ; Error in time?
 10727                                  TIMEERR:
 10728 0000230A BA[AE3A]                		mov	dx,BADTIMPTR
 10729 0000230D E8C311                  		call	STD_PRINTF	; Print "Enter new time: "
 10730 00002310 EB96                    		jmp	short GETTIM
 10731                                  
 10732                                  ; =============== S U B	R O U T	I N E =======================================
 10733                                  
 10734                                  GETBUF:
 10735 00002312 B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10736 00002314 BA[D040]                		mov	dx,COMBUF
 10737 00002317 B90200                  		mov	cx,2
 10738 0000231A E85F00                  		call	SETINITFLAG
 10739 0000231D CD21                    		int	21h		; Get input line
 10740 0000231F 31C9                    		xor	cx,cx
 10741 00002321 E85800                  		call	SETINITFLAG
 10742 00002324 E845F6                  		call	CRLF2
 10743 00002327 BE[D240]                		mov	si,COMBUF+2
 10744 0000232A 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10745 0000232D 74D9                    		jz	short P_TSEP_JRETN
 10746                                  
 10747                                  ; =============== S U B	R O U T	I N E =======================================
 10748                                  
 10749                                  INLINE:
 10750 0000232F E81900                  		call	GETNUM		; Get one or two digit number
 10751 00002332 7301                    		jnb	short INLINE1
 10752 00002334 C3                      		retn
 10753                                  INLINE1:
 10754 00002335 88E6                    		mov	dh,ah		; Put in position
 10755 00002337 AC                      		lodsb
 10756 00002338 38D8                    		cmp	al,bl
 10757 0000233A 7409                    		jz	short NEXT
 10758 0000233C 38F8                    		cmp	al,bh
 10759 0000233E 7405                    		jz	short NEXT
 10760 00002340 4E                      		dec	si		; Clears zero flag
 10761 00002341 F8                      		clc
 10762 00002342 B200                    		mov	dl,0
 10763 00002344 C3                      		retn			; Time may have only an hour specified
 10764                                  NEXT:
 10765 00002345 E80300                  		call	GETNUM
 10766 00002348 88E2                    		mov	dl,ah		; Put in position
 10767                                  INLINE_RETN:
 10768 0000234A C3                      		retn
 10769                                  
 10770                                  ;============================================================================
 10771                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10772                                  ;============================================================================
 10773                                  ; 05/10/2018 - Retro DOS v3.0
 10774                                  
 10775                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10776                                  
 10777                                  ; =============== S U B	R O U T	I N E =======================================
 10778                                  
 10779                                  GETNUM:
 10780 0000234B E81000                  		call	INDIG
 10781 0000234E 72FA                    		jb	short INLINE_RETN
 10782 00002350 88C4                    		mov	ah,al		; Save first digit
 10783 00002352 E80900                  		call	INDIG		; Another digit?
 10784 00002355 7204                    		jb	short OKRET
 10785 00002357 D50A                    		aad			; Convert unpacked BCD to decimal
 10786 00002359 88C4                    		mov	ah,al
 10787                                  OKRET:
 10788 0000235B 0C01                    		or	al,1
 10789                                  GETNUM_RETN:
 10790 0000235D C3                      		retn
 10791                                  
 10792                                  ; =============== S U B	R O U T	I N E =======================================
 10793                                  
 10794                                  INDIG:
 10795 0000235E 8A04                    		mov	al,[si]
 10796 00002360 2C30                    		sub	al,'0'
 10797 00002362 72F9                    		jc	short GETNUM_RETN
 10798 00002364 3C0A                    		cmp	al,10
 10799 00002366 F5                      		cmc
 10800 00002367 72F4                    		jc	short GETNUM_RETN
 10801 00002369 46                      		inc	si
 10802 0000236A C3                      		retn
 10803                                  
 10804                                  ; =============== S U B	R O U T	I N E =======================================
 10805                                  
 10806                                  OUT2:					; Output binary number as two ASCII digits
 10807 0000236B D40A                    		aam			; Convert binary to unpacked BCD
 10808 0000236D 86C4                    		xchg	al,ah
 10809 0000236F 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10810 00002372 3C30                    		cmp	al,'0'		; Is MSD zero?
 10811 00002374 7502                    		jnz	short NOSUP
 10812 00002376 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10813                                  NOSUP:
 10814 00002378 B700                    		mov	bh,0		; Disable zero suppression
 10815 0000237A AB                      		stosw
 10816 0000237B C3                      		retn
 10817                                  
 10818                                  ; ---------------------------------------------------------------------------
 10819                                  		;stosb
 10820                                  		;retn
 10821                                  
 10822                                  ;============================================================================
 10823                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10824                                  ;============================================================================
 10825                                  ; 03/10/2018 - Retro DOS v3.0
 10826                                  
 10827                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10828                                  
 10829                                  ; =============== S U B	R O U T	I N E =======================================
 10830                                  
 10831                                  ; Set the special flag in the INIT flag to the value in CX.
 10832                                  
 10833                                  SETINITFLAG:
 10834 0000237C 8E1E[7142]              		mov	ds,[RESSEG]
 10835                                  		;and	byte [INITFLAG],0FDh
 10836 00002380 80265B0CFD              		and	byte [INITFLAG],~INITSPECIAL
 10837 00002385 080E5B0C                		or	byte [INITFLAG],cl
 10838 00002389 0E                      		push	cs
 10839 0000238A 1F                      		pop	ds
 10840 0000238B C3                      		retn
 10841                                  
 10842                                  ; =============== S U B	R O U T	I N E =======================================
 10843                                  
 10844                                  PIPEOFF:
 10845 0000238C 1E                      		push	ds
 10846 0000238D 50                      		push	ax
 10847 0000238E 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
 10848 00002393 30C0                    		xor	al,al
 10849 00002395 86065C0C                		xchg	al,byte [PIPEFLAG]
 10850 00002399 08C0                    		or	al,al
 10851 0000239B 7404                    		jz	short PIPEOFFDONE
 10852 0000239D D02EEF0B                		shr	byte [ECHOFLAG],1
 10853                                  PIPEOFFDONE:
 10854 000023A1 58                      		pop	ax
 10855 000023A2 1F                      		pop	ds
 10856 000023A3 C3                      		retn
 10857                                  
 10858                                  ; ---------------------------------------------------------------------------
 10859                                  		;db    0,0,0,0,0
 10860                                  		;times 5 db 0
 10861 000023A4 90<rep Ch>              align 16
 10862                                  
 10863                                  ;============================================================================
 10864                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 10865                                  ;============================================================================
 10866                                  ; 03/10/2018 - Retro DOS v3.0
 10867                                  
 10868                                  ;----------------------------------------------------------------------------
 10869                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 10870                                  ; argv[argvcnt] array. The most important difference between this array and
 10871                                  ; the tradition UNIX format is the extra cparse information included with
 10872                                  ; each argument element.
 10873                                  ;---------------
 10874                                  ; ENTRY:
 10875                                  ;	BL	     special delimiter for cparse -- not implemented)
 10876                                  ;---------------
 10877                                  ; EXIT:
 10878                                  ;	CF	    set if error
 10879                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 10880                                  ;	argv[]	    array of cparse flags and pointers to arguments
 10881                                  ;	argvcnt     argument count
 10882                                  ;---------------
 10883                                  ; NOTE(S):
 10884                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 10885                                  ;	*   Parseflags record contains cparse flags, as follows:
 10886                                  ;		sw_flag 	--	was this arg a switch?
 10887                                  ;		wildcard	--	whether or not it contained a * or ?
 10888                                  ;		path_sep	--	maybe it was a pathname
 10889                                  ;		unused		--	for future expansion
 10890                                  ;		special_delim	--	was there an initial special delimiter?
 10891                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 10892                                  ;	*   Relationship between input, cparse output, and comtail can be
 10893                                  ;	    found in the following chart.  Despite the claim of the cparse
 10894                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 10895                                  ;	    tokens", such is not the case (see column two, row two).
 10896                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 10897                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 10898                                  ;	    STARTEL addresses) will be null. This is clearly just a
 10899                                  ;	    documentation error.
 10900                                  ;	*   cparse also returns a switch code in BP for each switch it
 10901                                  ;	    recognizes on the command line.
 10902                                  ;	*   arglen for each token does NOT include the terminating null.
 10903                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 10904                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 10905                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 10906                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 10907                                  ;	    line parsing may result in slightly different behavior than
 10908                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 10909                                  ;
 10910                                  ;	    Input		    Cparse		Command Line (80H)
 10911                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 10912                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 10913                                  ;	foo.bat 		foo.bat 		foo.bat
 10914                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 10915                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 10916                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 10917                                  
 10918                                  ; =============== S U B	R O U T	I N E =======================================
 10919                                  
 10920                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 10921                                  
 10922                                  PARSELINE:
 10923 000023B0 50                      		push	ax			; most of these are clobbered
 10924 000023B1 53                      		push	bx			; by cparse...
 10925 000023B2 51                      		push	cx
 10926 000023B3 52                      		push	dx
 10927 000023B4 57                      		push	di
 10928 000023B5 56                      		push	si
 10929 000023B6 9C                      		pushf
 10930 000023B7 C606[5644]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 10931 000023BC C706[6F4B]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 10932 000023C2 31C0                    		xor	ax,ax
 10933                                  		;mov	cx,1348
 10934 000023C4 B94405                  		mov	cx,ARG_UNIT.SIZE
 10935 000023C7 BF[A945]                		mov	di,ARG
 10936 000023CA F3AA                    		rep stosb
 10937                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 10938 000023CC C706[ED4A][6D48]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 10939                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 10940 000023D2 C706[6B48]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 10941                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 10942 000023D8 C706[6948]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 10943 000023DE BE[D240]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 10944                                  
 10945                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 10946                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 10947                                  ; otherwise. This is done so that commands can get arg pointers into their
 10948                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 10949                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 10950                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 10951                                  ; the command to be repeated or the transient part of command has been
 10952                                  ; reloaded.
 10953                                  
 10954 000023E1 1E                      		push	ds
 10955 000023E2 8E1E[7142]              		mov	ds,[RESSEG]
 10956 000023E6 803EFB0B00              		cmp	byte [FORFLAG],0
 10957 000023EB 1F                      		pop	ds
 10958 000023EC 7510                    		jnz	short PCONT
 10959                                  		;mov	di,ARG_ARGFORCOMBUF
 10960 000023EE BF[6D4A]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 10961 000023F1 30ED                    		xor	ch,ch
 10962 000023F3 8A0E[D140]              		mov	cl,[COMBUF+1]
 10963 000023F7 FEC1                    		inc	cl
 10964 000023F9 F3A4                    		rep movsb
 10965                                  		;mov	si,ARG_ARGFORCOMBUF
 10966 000023FB BE[6D4A]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 10967                                  PCONT:
 10968 000023FE BF[EF4A]                		mov	di,TPBUF	; destination is temporary token buffer	
 10969 00002401 B320                    		mov	bl,' '		; no special delimiter, for now
 10970                                  PARSELOOP:
 10971 00002403 8936[714B]              		mov	[COMPTR],si	; save ptr into original command buffer
 10972 00002407 31ED                    		xor	bp,bp		; switch information put here by cparse
 10973 00002409 C606[A745]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 10974 0000240E E868F5                  		call	SCANOFF		; skip leading blanks...
 10975 00002411 E8000F                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 10976 00002414 7309                    		jnb	short MORE_PRSE
 10977 00002416 09ED                    		or	bp,bp		; Check for trailing switch character
 10978 00002418 7411                    		jz	short PARSEDONE
 10979 0000241A E81B00                  		call	NEWARG		; We hit CR but BP is non-zero. The
 10980                                  					;   typical cause of this is that a
 10981                                  					;   switch char IMMEDIATELY preceeds
 10982                                  					;   the CR. We have an argument, but it
 10983                                  					;   is sort of an error.
 10984 0000241D EB0C                    		jmp	short PARSEDONE	; We're done (found the CR).
 10985                                  
 10986                                  MORE_PRSE:
 10987 0000241F C606[5644]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 10988 00002424 E81100                  		call	NEWARG		; add to argv array (CX has char count)
 10989 00002427 73DA                    		jnb	short PARSELOOP	; was everything OK?
 10990 00002429 EB04                    		jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 10991                                  
 10992                                  PARSEDONE:
 10993 0000242B 9D                      		popf
 10994 0000242C F8                      		clc
 10995 0000242D EB02                    		jmp	short PARSE_EXIT
 10996                                  
 10997                                  PARSE_ERROR:				; error entry (er, exit) point
 10998 0000242F 9D                      		popf
 10999 00002430 F9                      		stc
 11000                                  PARSE_EXIT:				; depend on not changing CF
 11001 00002431 5E                      		pop	si
 11002 00002432 5F                      		pop	di
 11003 00002433 5A                      		pop	dx
 11004 00002434 59                      		pop	cx
 11005 00002435 5B                      		pop	bx
 11006 00002436 58                      		pop	ax
 11007 00002437 C3                      		retn
 11008                                  
 11009                                  ; =============== S U B	R O U T	I N E =======================================
 11010                                  
 11011                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11012                                  ;
 11013                                  ; ENTRY:
 11014                                  ;   BH			argflags
 11015                                  ;   CX			character count in argstring
 11016                                  ;   DI			pointer to argstring
 11017                                  ;   comptr		ptr to starting loc of current token in original command
 11018                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11019                                  ; EXIT:
 11020                                  ;   argbufptr		points to next free section of argbuffer
 11021                                  ;   arg.argbuf		contains null-terminated argument strings
 11022                                  ;   arg.argvcnt 	argument count
 11023                                  ;   arg.argv[]		array of flags and pointers
 11024                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11025                                  ;   CF			set if error
 11026                                  ;   AL			carry set:  error code; otherwise, zero
 11027                                  
 11028                                  NEWARG:
 11029 00002438 53                      		push	bx
 11030 00002439 51                      		push	cx
 11031 0000243A 52                      		push	dx
 11032 0000243B 57                      		push	di
 11033 0000243C 56                      		push	si
 11034 0000243D 9C                      		pushf
 11035 0000243E E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11036                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11037                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11038                                  
 11039                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11040 00002441 833E[6948]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11041 00002446 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11042 00002448 88FE                    		mov	dh,bh			
 11043                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11044 0000244A 8B1E[6948]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11045                                  		;inc	word [ARG_ARGVCNT]
 11046 0000244E FF06[6948]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11047                                  		;mov	ax,ARG_ARGV
 11048 00002452 B8[A945]                		mov	ax,ARG+ARG_UNIT.argv
 11049 00002455 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11050                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11051                                  		;mov	word [bx+7],0
 11052 00002458 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11053                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11054                                  		;mov	[bx+5],cx
 11055 0000245D 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11056                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11057                                  		;mov	[bx+2],dh
 11058 00002460 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11059 00002463 8B36[ED4A]              		mov	si,[ARGBUFPTR]
 11060                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11061                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11062 00002467 8937                    		mov	[bx],si			
 11063 00002469 0336[9745]              		add	si,[STARTEL]		; save startel from new location
 11064 0000246D 29FE                    		sub	si,di			; form pointer into argbuf
 11065                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11066                                  		;mov	[bx+3],si
 11067 0000246F 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11068 00002472 8B36[714B]              		mov	si,[COMPTR]
 11069                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11070                                  		;mov	[bx+9],si
 11071 00002476 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11072                                  
 11073 00002479 89FE                    		mov	si,di			; now save argstring in argbuffer
 11074 0000247B 8B3E[ED4A]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11075 0000247F 01CF                    		add	di,cx			; sure we're not about to run off
 11076                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11077                                  		;cmp	di,ARG_ARGBUF+255
 11078 00002481 81FF[6C49]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11079 00002485 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11080 00002487 29CF                    		sub	di,cx
 11081 00002489 FC                      		cld
 11082 0000248A F3A4                    		rep movsb
 11083 0000248C B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11084 0000248E AA                      		stosb
 11085 0000248F 893E[ED4A]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11086                                  
 11087                                  NEWARG_DONE:
 11088 00002493 9D                      		popf
 11089 00002494 F8                      		clc
 11090 00002495 EB0A                    		jmp	short NEWARG_EXIT
 11091                                  
 11092                                  TO_MANY_ARGS:
 11093 00002497 B80100                  		mov	ax,1
 11094 0000249A EB03                    		jmp	short NEWARG_ERROR
 11095                                  
 11096                                  BUF_OVFLOW:
 11097 0000249C B80200                  		mov	ax,2
 11098                                  NEWARG_ERROR:
 11099 0000249F 9D                      		popf
 11100 000024A0 F9                      		stc
 11101                                  NEWARG_EXIT:
 11102 000024A1 5E                      		pop	si
 11103 000024A2 5F                      		pop	di
 11104 000024A3 5A                      		pop	dx
 11105 000024A4 59                      		pop	cx
 11106 000024A5 5B                      		pop	bx
 11107 000024A6 C3                      		retn
 11108                                  
 11109                                  ; =============== S U B	R O U T	I N E =======================================
 11110                                  
 11111                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11112                                  ; event that it is, and we can recognize
 11113                                  ;
 11114                                  ; ENTRY:
 11115                                  ;   As in <newarg>.
 11116                                  ; EXIT:
 11117                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11118                                  ; NOTE(S):
 11119                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11120                                  ;	on the order of definition in the <switch_list> variable and the
 11121                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11122                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11123                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11124                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11125                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11126                                  ;   *	An ugly routine.
 11127                                  
 11128                                  ARG_SWITCH:
 11129 000024A7 50                      		push	ax
 11130 000024A8 53                      		push	bx
 11131 000024A9 51                      		push	cx
 11132 000024AA 57                      		push	di
 11133 000024AB 9C                      		pushf
 11134 000024AC F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11135 000024AF 741C                    		jz	short ARG_NO_SWITCH0
 11136 000024B1 833E[6F4B]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11137 000024B6 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11138 000024B8 8B1E[6F4B]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11139                                  		;mov	ax,offset TRANGROUP:arg.argv
 11140                                  		;mov	ax,ARG_ARGV
 11141 000024BC B8[A945]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11142 000024BF E81800                  		call	ARGV_CALC
 11143                                  		;or	[BX].argsw_word,BP
 11144                                  		;or	[bx+7],bp
 11145 000024C2 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11146                                  		;or	arg.argswinfo,BP
 11147                                  		;or	[ARG_ARGSWINFO],bp
 11148 000024C5 092E[6B48]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11149                                  ARG_YES_SWITCH:
 11150 000024C9 9D                      		popf
 11151 000024CA F9                      		stc
 11152 000024CB EB08                    		jmp	short ARG_SWITCH_EXIT
 11153                                  
 11154                                  ARG_NO_SWITCH0:
 11155                                  		;mov	ax,[ARG_ARGVCNT]
 11156 000024CD A1[6948]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11157 000024D0 A3[6F4B]                		mov	[LASTARG],ax
 11158                                  ARG_NO_SWITCH1:
 11159 000024D3 9D                      		popf
 11160 000024D4 F8                      		clc
 11161                                  ARG_SWITCH_EXIT:
 11162 000024D5 5F                      		pop	di
 11163 000024D6 59                      		pop	cx
 11164 000024D7 5B                      		pop	bx
 11165 000024D8 58                      		pop	ax
 11166 000024D9 C3                      		retn
 11167                                  
 11168                                  ; =============== S U B	R O U T	I N E =======================================
 11169                                  
 11170                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11171                                  ; the supplied array.  Method used for computing the address is:
 11172                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11173                                  ; ENTRY:
 11174                                  ;   AX	    --	    base of array
 11175                                  ;   BX	    --	    array index
 11176                                  ; EXIT:
 11177                                  ;   BX	    --	    byte offset
 11178                                  
 11179                                  ARGV_CALC:
 11180 000024DA 50                      		push	ax		; Save base
 11181 000024DB 88D8                    		mov	al,bl		; al = array index
 11182                                  		;mov	bl,11
 11183 000024DD B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11184 000024DF F6E3                    		mul	bl		; ax = base offset
 11185 000024E1 5B                      		pop	bx		; Get base
 11186 000024E2 01D8                    		add	ax,bx		; Add in base offset
 11187 000024E4 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11188 000024E5 C3                      		retn
 11189                                  
 11190                                  ; ---------------------------------------------------------------------------
 11191                                  	
 11192                                  		;db 0Ah dup(0)
 11193                                  		;times 10 db 0
 11194 000024E6 90<rep Ah>              align 16
 11195                                  
 11196                                  ;============================================================================
 11197                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11198                                  ;============================================================================
 11199                                  ; 03/10/2018 - Retro DOS v3.0
 11200                                  
 11201                                  ;----------------------------------------------------------------------------
 11202                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11203                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11204                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11205                                  ;    file on disk. Directories specified in the user's search path will be
 11206                                  ;    searched for a matching file, if a match is not found in the current
 11207                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11208                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11209                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11210                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11211                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11212                                  ;    (easily) modified to make no assumptions about where its input is found.
 11213                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11214                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11215                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11216                                  ;    else that wants to save the whole shebang and then process other command
 11217                                  ;    lines.
 11218                                  ;
 11219                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11220                                  ;
 11221                                  ; ENTRY:
 11222                                  ;   <Path_Search>:	    argv[0].
 11223                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11224                                  ; EXIT:
 11225                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11226                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11227                                  ; NOTE(S):
 11228                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11229                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11230                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11231                                  ;	does not function as specified; see <Parseline> for more details.
 11232                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11233                                  ;	need to know about. This extra information is stored in a switch_flag
 11234                                  ;	word with each command-line argument; the switches themselves will not
 11235                                  ;	appear in the resulting arg structure.
 11236                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11237                                  ;----------------------------------------------------------------------------
 11238                                  
 11239                                  ; =============== S U B	R O U T	I N E =======================================
 11240                                  
 11241                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11242                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11243                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11244                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11245                                  ; have a match, either in the current working directory if we were handed
 11246                                  ; a filename, or in the specified directory, given a pathname. If this call
 11247                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11248                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11249                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11250                                  ; either the first invocation of search or on one of the succeeding calls
 11251                                  ; sets up the appropriate information for copying the successful pathname
 11252                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11253                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11254                                  ;
 11255                                  ; ENTRY:
 11256                                  ;   argv[0]		--	command name and associated information
 11257                                  ; EXIT:
 11258                                  ;   AX			--	non-zero indicates type of file found
 11259                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11260                                  ; NOTE(S):
 11261                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11262                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11263                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11264                                  ;	if search returns an .exe or .bat.
 11265                                  ;   5)	Clobbers dma address.
 11266                                  
 11267                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11268                                  PATH_SEP_CHAR	EQU	';'
 11269                                  
 11270                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11271                                  
 11272                                  		;special_delim equ 128
 11273                                  		;path_sep equ 4
 11274                                  		;wildcard equ 2
 11275                                  		;sw_flag  equ 1
 11276                                  
 11277                                  ;----------------------------------------------------------------------------
 11278                                  
 11279                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11280                                  
 11281                                  PATH_SEARCH:
 11282 000024F0 53                      		push	bx
 11283 000024F1 51                      		push	cx
 11284 000024F2 52                      		push	dx		; could use a "stack 'em" instruction
 11285 000024F3 56                      		push	si
 11286 000024F4 57                      		push	di
 11287 000024F5 55                      		push	bp
 11288 000024F6 9C                      		pushf
 11289                                  
 11290                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11291                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11292 000024F7 F606[AB45]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11293 000024FC 7403                    		jz	short PATH_SEARCH_OK
 11294                                  
 11295                                  PATH_FAILURE_JMP:
 11296 000024FE E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11297                                  
 11298                                  PATH_SEARCH_OK:
 11299 00002501 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11300 00002504 BA[734B]                		mov	dx,FBUF		; clobber old dma value with
 11301 00002507 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11302 0000250A CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11303                                  				; DS:DX	-> disk	transfer buffer
 11304 0000250C 06                      		push	es
 11305 0000250D E87FF2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11306 00002510 8C06[9E4B]              		mov	[PATHINFO+0],es	; and squirrel it away
 11307 00002514 893E[A04B]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11308 00002518 893E[A24B]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11309 0000251C 07                      		pop	es
 11310                                  		
 11311 0000251D BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11312 00002520 BE[9941]                		mov	si,EXECPATH
 11313 00002523 E84B02                  		call	STRIP
 11314 00002526 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11315                                  		
 11316 00002528 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11317 0000252A C706[F34B][4939]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11318 00002530 E88301                  		call	PSEARCH		; must do at least one search
 11319 00002533 09C0                    		or	ax,ax		; find anything?
 11320 00002535 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11321                                  		
 11322 00002537 89C5                    		mov	bp,ax		; success... save filetype code	
 11323 00002539 BF[9941]                		mov	di,EXECPATH
 11324                                  		;mov	si,ds:arg.argv[0].argpointer
 11325                                  		;mov	si,[ARG_ARGV]
 11326 0000253C 8B36[A945]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11327                                  		;mov	cx,ds:arg.argv[0].argstartel
 11328                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11329 00002540 8B0E[AC45]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11330 00002544 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11331                                  
 11332                                  ; We have the number of bytes in the prefix (up to the final component).
 11333                                  ; We need to form the complete pathname including leading drive and current
 11334                                  ; directory.
 11335                                  ;
 11336                                  ; Is there a drive letter present?
 11337                                  
 11338 00002546 B43A                    		mov	ah,':'
 11339 00002548 83F902                  		cmp	cx,2		; room for drive letter?
 11340 0000254B 7205                    		jb	short ADDDRIVE	; no, stick it in
 11341 0000254D 386401                  		cmp	[si+1],	ah	; colon present?
 11342 00002550 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11343                                  ADDDRIVE:
 11344 00002552 A0[8542]                		mov	al,[CURDRV]	; get current drive
 11345 00002555 0441                    		add	al,'A'		; convert to uppercase letter
 11346 00002557 AB                      		stosw			; store d:
 11347 00002558 EB05                    		jmp	short CHECKPATH
 11348                                  
 11349                                  MOVEDRIVE:
 11350 0000255A AD                      		lodsw			; move d:
 11351 0000255B AB                      		stosw
 11352 0000255C 83E902                  		sub	cx,2		; 2 bytes less to move
 11353                                  CHECKPATH:
 11354 0000255F 0C20                    		or	al,20h
 11355 00002561 88C2                    		mov	dl,al		
 11356                                  		;sub	dl,60h
 11357 00002563 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11358                                  
 11359                                  ; Stick in beginning path char
 11360                                  
 11361 00002566 A0[A44B]                		mov	al,[PSEP_CHAR]
 11362 00002569 AA                      		stosb
 11363                                  
 11364                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11365                                  ; Otherwise, get current dir for DL.
 11366                                  
 11367 0000256A 83F901                  		cmp	cx,1		; is there room for path char?
 11368 0000256D 720A                    		jb	short ADDPATH	; no, go add path
 11369 0000256F AC                      		lodsb
 11370 00002570 49                      		dec	cx
 11371 00002571 3A06[A44B]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11372 00002575 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11373 00002577 41                      		inc	cx
 11374 00002578 4E                      		dec	si		; undo the lodsb
 11375                                  ADDPATH:
 11376 00002579 56                      		push	si
 11377 0000257A 89FE                    		mov	si,di		; remainder of buffer
 11378 0000257C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11379 0000257F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11380                                  				; DL = drive (0=default,1=A,etc.)
 11381                                  				; DS:SI	points to 64-byte buffer area
 11382                                  
 11383                                  ; The previous current dir will succeed a previous find_first already worked.
 11384                                  ;
 11385                                  ; Find end of string.
 11386                                  
 11387 00002581 89F7                    		mov	di,si
 11388 00002583 5E                      		pop	si
 11389 00002584 A0[A44B]                		mov	al,[PSEP_CHAR]
 11390 00002587 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11391 0000258A 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11392                                  SCANEND:
 11393 0000258C 803D00                  		cmp	byte [di],0	; end of string?
 11394 0000258F 7403                    		jz	short FOUNDEND
 11395 00002591 47                      		inc	di
 11396 00002592 EBF8                    		jmp	short SCANEND
 11397                                  
 11398                                  ; Stick in a trailing path char.
 11399                                  
 11400                                  FOUNDEND:
 11401 00002594 AA                      		stosb
 11402                                  
 11403                                  ; Move remaining part of path.	Skip leading path char if present.
 11404                                  
 11405                                  MOVEPATH:
 11406 00002595 3804                    		cmp	[si],al		; first char a path char?
 11407 00002597 7502                    		jnz	short COPYPATH
 11408 00002599 46                      		inc	si		; move past leading char
 11409 0000259A 49                      		dec	cx		; drop from count
 11410                                  COPYPATH:
 11411 0000259B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11412 0000259D F3A4                    		rep movsb
 11413                                  _COPYDONE:
 11414 0000259F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11415                                  
 11416                                  PATH_NOINIT:
 11417                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11418                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11419 000025A2 F606[AB45]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11420 000025A7 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11421                                  		;mov	bh,';'
 11422 000025A9 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11423                                  		;mov	dx,ds:arg.argv[0].argstartel
 11424                                  					; this is where the last element starts
 11425                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11426 000025AB 8B16[AC45]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11427                                  		;sub	dx,ds:arg.argv[0].argpointer
 11428                                  					; form pointer into EXECPATH,
 11429                                  		;sub	dx,[ARG_ARGV]
 11430 000025AF 2B16[A945]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11431 000025B3 81C2[9941]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11432                                  PATH_LOOP:
 11433 000025B7 E89A00                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11434 000025BA 89C5                    		mov	bp,ax		; save filetype code
 11435 000025BC 9F                      		lahf			; save flags, just in case
 11436 000025BD 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11437 000025BF 7507                    		jnz	short PATH_FOUND 
 11438 000025C1 9E                      		sahf			; see?	needed those flags, after all!
 11439 000025C2 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11440                                  PATH_FAILURE:
 11441 000025C4 31C0                    		xor	ax,ax
 11442 000025C6 EB70                    		jmp	short PATH_EXIT
 11443                                  
 11444                                  PATH_FOUND:				; pathinfo[] points to winner
 11445 000025C8 BF[9941]                		mov	di,EXECPATH
 11446                                  		;mov	cx,pathinfo[4] 
 11447 000025CB 8B0E[A24B]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11448                                  		;mov	SI,pathinfo[2]
 11449 000025CF 8B36[A04B]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11450                                  
 11451                                  ;	BAS Nov 20/84
 11452                                  ;   Look at the pathname and expand . and .. if they are the first element
 11453                                  ;   in the pathname (after the drive letter)
 11454                                  
 11455 000025D3 06                      		push	es
 11456                                  		;push	pathinfo[0]
 11457 000025D4 FF36[9E4B]              		push	word [PATHINFO+0]
 11458 000025D8 07                      		pop	es
 11459                                  ;SR;
 11460                                  ; Oops! Gets fooled if path= \;..
 11461                                  ; We should also check if a drive letter is really present
 11462                                  ;
 11463 000025D9 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11464 000025DE 7534                    		jnz	short PATH_CPY
 11465                                  
 11466                                  		; MSDOS 6.0
 11467                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11468                                  		;jnz	path_cpy	       ;no, copy the path string
 11469                                  
 11470 000025E0 51                      		push	cx		; Save pointer to end of string
 11471 000025E1 268A04                  		mov	al,[es:si]
 11472 000025E4 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11473 000025E6 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11474 000025EA 884501                  		mov	[di+1],al
 11475 000025ED A0[A44B]                		mov	al,[PSEP_CHAR]
 11476 000025F0 884502                  		mov	[di+2],	al
 11477 000025F3 56                      		push	si		; Save pointer to begining of string
 11478 000025F4 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11479 000025F7 80CA20                  		or	dl,20h
 11480                                  		;sub	dl,60h
 11481 000025FA 80EA60                  		sub	dl,'a'-1
 11482 000025FD 89FE                    		mov	si,di		; pointer to EXECPATH
 11483 000025FF 83C603                  		add	si,3		; Don't wipe out drive and root info
 11484 00002602 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11485 00002605 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11486                                  				; DL = drive (0=default,1=A,etc.)
 11487                                  				; DS:SI	points to 64-byte buffer area
 11488 00002607 E8B2F8                  		call	DSTRLEN		; Determine length of present info
 11489 0000260A 01CE                    		add	si,cx		; Don't copy over drive and root info
 11490 0000260C 4E                      		dec	si
 11491 0000260D 89F7                    		mov	di,si		; Point to end of target string
 11492 0000260F 5E                      		pop	si		; Restore pointer to begining of string
 11493 00002610 83C603                  		add	si,3		; Point past drive letter, :, .
 11494 00002613 59                      		pop	cx		; Restore pointer to end of string
 11495                                  PATH_CPY:
 11496 00002614 07                      		pop	es
 11497 00002615 29F1                    		sub	cx,si		; yields character count
 11498 00002617 1E                      		push	ds		; time to switch segments
 11499 00002618 FF36[9E4B]              		push	word [PATHINFO+0] ; string lives in this segment
 11500 0000261C 1F                      		pop	ds
 11501 0000261D FC                      		cld
 11502 0000261E F3A4                    		rep movsb
 11503 00002620 1F                      		pop	ds		; return to our segment
 11504 00002621 4F                      		dec	di		; overwrite terminator
 11505 00002622 A0[A44B]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11506 00002625 3A45FF                  		cmp	al,[di-1]
 11507 00002628 7401                    		jz	short PATH_SUCCESS
 11508 0000262A AA                      		stosb
 11509                                  PATH_SUCCESS:
 11510 0000262B BE[A64B]                		mov	si,SEARCH_BEST_BUF
 11511 0000262E 31C9                    		xor	cx,cx
 11512                                  PATH_SUCC_LOOP:
 11513 00002630 AC                      		lodsb			; append winning filename to path
 11514 00002631 AA                      		stosb			; (including terminating null)	
 11515 00002632 08C0                    		or	al,al
 11516 00002634 75FA                    		jnz	short PATH_SUCC_LOOP
 11517 00002636 89E8                    		mov	ax,bp		; retrieve filetype code
 11518                                  PATH_EXIT:
 11519 00002638 9D                      		popf
 11520 00002639 5D                      		pop	bp
 11521 0000263A 5F                      		pop	di
 11522 0000263B 5E                      		pop	si		; chill out...
 11523 0000263C 5A                      		pop	dx
 11524 0000263D 59                      		pop	cx
 11525 0000263E 5B                      		pop	bx
 11526 0000263F C3                      		retn
 11527                                  
 11528                                  
 11529                                  ; =============== S U B	R O U T	I N E =======================================
 11530                                  
 11531                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11532                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11533                                  ;
 11534                                  ; ENTRY:
 11535                                  ; EXIT:
 11536                                  ; NOTE(S):
 11537                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11538                                  
 11539                                  STORE_PCHAR:
 11540 00002640 50                      		push	ax
 11541 00002641 B02F                    		mov	al,'/'		; is the pathname-element separator
 11542 00002643 E8C6F3                  		call	PATHCHRCMP	; a regular slash?
 11543 00002646 7407                    		jz	short STORE_SLASH ; if yes, remember slash
 11544 00002648 B05C                    		mov	al,'\'
 11545 0000264A A2[A44B]                		mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11546 0000264D 58                      		pop	ax
 11547 0000264E C3                      		retn
 11548                                  STORE_SLASH:
 11549 0000264F A2[A44B]                		mov	[PSEP_CHAR],al
 11550 00002652 58                      		pop	ax
 11551 00002653 C3                      		retn
 11552                                  
 11553                                  ; =============== S U B	R O U T	I N E =======================================
 11554                                  
 11555                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11556                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11557                                  ; additional separator to use for breaking up the path-string. Null is the
 11558                                  ; default. Once the user-string has been formed, search is invoked to see
 11559                                  ; what's out there.
 11560                                  ;
 11561                                  ; ENTRY:
 11562                                  ;   BH			--	additional terminator character
 11563                                  ;   SI			--	pointer into pathstring to be dissected
 11564                                  ;   DX			--	pointer to stripped filename
 11565                                  ; EXIT:
 11566                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11567                                  ;   SI			--	moves along pathstring from call to call
 11568                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11569                                  ;   [tpbuf]		--	clobbered
 11570                                  ; NOTE(S):
 11571                                  ;   *	Implicit in this code is the ability to specify when to search
 11572                                  ;	the current directory (if at all) through the PATH defined by
 11573                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11574                                  ;	current directory before the bin and etc directories of drive c).
 11575                                  
 11576                                  PATH_CRUNCH:
 11577 00002654 53                      		push	bx
 11578 00002655 51                      		push	cx
 11579 00002656 52                      		push	dx
 11580 00002657 57                      		push	di
 11581 00002658 56                      		push	si
 11582 00002659 9C                      		pushf
 11583 0000265A E8E3FF                  		call	STORE_PCHAR	; figure out pathname separator
 11584 0000265D BF[EF4A]                		mov	di,TPBUF	; destination of concatenated string
 11585 00002660 8B36[A24B]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11586 00002664 8936[A04B]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11587 00002668 1E                      		push	ds		; save old segment pointer
 11588 00002669 FF36[9E4B]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11589 0000266D 1F                      		pop	ds		; segment		
 11590                                  PATH_CR_COPY:
 11591 0000266E AC                      		lodsb			; get a pathname byte
 11592 0000266F 08C0                    		or	al,al		; check for terminator(s)
 11593 00002671 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11594 00002673 38F8                    		cmp	al,bh
 11595 00002675 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11596 00002677 AA                      		stosb
 11597 00002678 EBF4                    		jmp	short PATH_CR_COPY
 11598                                  
 11599                                  PATH_SEG:
 11600 0000267A 1F                      		pop	ds		; restore old data segment
 11601 0000267B 8936[A24B]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11602 0000267F 88C3                    		mov	bl,al		; remember if we saw null or not...
 11603                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11604 00002681 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11605 00002683 81FF[EF4A]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11606 00002687 741D                    		jz	short PATH_CR_LEAVE 
 11607                                  					; if nothing was copied, pathstr empty
 11608                                  PATH_CR_LOOK:
 11609 00002689 A0[A44B]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11610 0000268C 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11611 0000268F 7401                    		jz	short PATH_CR_L1
 11612 00002691 AA                      		stosb
 11613                                  PATH_CR_L1:
 11614 00002692 89D6                    		mov	si,dx
 11615                                  PATH_CR_L2:
 11616 00002694 AC                      		lodsb			; tack the stripped filename onto
 11617 00002695 AA                      		stosb			; the end of the path, up to and
 11618 00002696 08C0                    		or	al,al		; including the terminating null
 11619 00002698 75FA                    		jnz	short PATH_CR_L2
 11620 0000269A BA[EF4A]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11621 0000269D C706[F34B][403C]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11622                                  		;invoke search
 11623 000026A3 E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11624                                  
 11625                                  PATH_CR_LEAVE:
 11626 000026A6 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11627 000026A8 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11628 000026AA 9D                      		popf			; otherwise, plenty left
 11629 000026AB F8                      		clc
 11630 000026AC EB02                    		jmp	short PATH_CR_EXIT
 11631                                  
 11632                                  PATH_CR_EMPTY:
 11633 000026AE 9D                      		popf
 11634 000026AF F9                      		stc
 11635                                  PATH_CR_EXIT:
 11636 000026B0 5E                      		pop	si
 11637 000026B1 5F                      		pop	di
 11638 000026B2 5A                      		pop	dx
 11639 000026B3 59                      		pop	cx
 11640 000026B4 5B                      		pop	bx
 11641 000026B5 C3                      		retn
 11642                                  
 11643                                  ;============================================================================
 11644                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11645                                  ;============================================================================
 11646                                  ; 02/10/2018 - Retro DOS v3.0
 11647                                  
 11648                                  ;----------------------------------------------------------------------------
 11649                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11650                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11651                                  ; lowest priority). Where conflicts arise, the extension with
 11652                                  ; the highest priority is favored.
 11653                                  ; ENTRY:
 11654                                  ;   DX		--	pointer to null-terminated pathname
 11655                                  ;   fbuf	--	dma buffer for findfirst/next
 11656                                  ; EXIT:
 11657                                  ;   AX		--	8)  file found with .com extension
 11658                                  ;			4)  file found with .exe extension
 11659                                  ;			2)  file found with .bat extension
 11660                                  ;			0)  no such file to be found
 11661                                  ;   (if AX is non-zero:)
 11662                                  ;   [search_best]	identical to AX
 11663                                  ;   [search_best_buf]	null-terminated filename
 11664                                  ; NOTES:
 11665                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11666                                  ;---------------
 11667                                  ; CONSTANTS:
 11668                                  ;---------------
 11669                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11670                                  SEARCH_COM		EQU	8
 11671                                  SEARCH_EXE		EQU	4
 11672                                  SEARCH_BAT		EQU	2
 11673                                  FNAME_LEN		EQU	8
 11674                                  FNAME_MAX_LEN		EQU	13
 11675                                  DOT			EQU	'.'
 11676                                  WILDCHAR		EQU	'?'
 11677                                  
 11678                                  
 11679                                  ; =============== S U B	R O U T	I N E =======================================
 11680                                  
 11681                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11682                                  
 11683                                  PSEARCH:
 11684 000026B6 51                      		push	cx
 11685 000026B7 52                      		push	dx
 11686 000026B8 57                      		push	di
 11687 000026B9 56                      		push	si
 11688 000026BA 9C                      		pushf
 11689 000026BB 52                      		push	dx		; check drivespec (save pname ptr)
 11690 000026BC 89D7                    		mov	di,dx		; working copy of pathname
 11691 000026BE BE[B34B]                		mov	si,SEARCH_CURDIR_BUF
 11692 000026C1 31D2                    		xor	dx,dx		; zero means current drive
 11693 000026C3 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11694 000026C7 7508                    		jne	short SEARCH_DIR_CHECK
 11695 000026C9 8A15                    		mov	dl,[di]		; get the drive byte
 11696 000026CB 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11697 000026CE 80EA40                  		sub	dl,'@'		; and convert to drive number
 11698                                  SEARCH_DIR_CHECK:
 11699 000026D1 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11700 000026D4 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11701                                  				; DL = drive (0=default,1=A,etc.)
 11702                                  				; DS:SI	points to 64-byte buffer area
 11703 000026D6 5A                      		pop	dx		; directory? If we can't we'll		
 11704 000026D7 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11705 000026D9 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11706 000026DC B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11707 000026DF CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11708                                  				; CX = search attributes
 11709                                  				; DS:DX	-> ASCIZ filespec
 11710                                  				; (drive,path,	and wildcards allowed)
 11711 000026E1 723C                    		jc	short SEARCH_NO_FILE
 11712 000026E3 C606[A54B]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11713 000026E8 C606[A64B]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11714                                  SEARCH_LOOP:
 11715 000026ED E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11716 000026F0 3A06[A54B]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11717 000026F4 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11718 000026F6 A2[A54B]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11719                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11720                                  		;mov	si,FBUF_PNAME
 11721 000026F9 BE[914B]                		mov	si,FBUF+FIND_BUF.PNAME
 11722 000026FC BF[A64B]                		mov	di,SEARCH_BEST_BUF
 11723 000026FF B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11724 00002702 FC                      		cld
 11725 00002703 F3A4                    		rep movsb		; save complete pathname representation
 11726 00002705 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11727 00002707 740A                    		je	short SEARCH_DONE
 11728                                  SEARCH_NEXT:				; keep on looking
 11729 00002709 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11730 0000270C B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11731 0000270F CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11732                                  				; [DTA]	= data block from
 11733                                  				; last AH = 4Eh/4Fh call
 11734 00002711 73DA                    		jnc	short SEARCH_LOOP
 11735                                  SEARCH_DONE:				; it's all over with...
 11736 00002713 A0[A54B]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11737                                  		; MSDOS 6.0
 11738                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11739                                  		;jz	search_exit	;AN005; no - exit
 11740                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11741                                  		;mov	search_best,al	;AN005; save the real file type
 11742                                  		;
 11743 00002716 EB0A                    		jmp	short SEARCH_EXIT
 11744                                  
 11745                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11746 00002718 8B16[F34B]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11747 0000271C E8B40D                  		call	STD_PRINTF	 ; and pretend no file found
 11748                                  
 11749                                  SEARCH_NO_FILE:				; couldn't find a match
 11750 0000271F B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11751                                  
 11752                                  SEARCH_EXIT:
 11753 00002722 9D                      		popf
 11754 00002723 5E                      		pop	si
 11755 00002724 5F                      		pop	di
 11756 00002725 5A                      		pop	dx
 11757 00002726 59                      		pop	cx
 11758 00002727 C3                      		retn
 11759                                  
 11760                                  ; =============== S U B	R O U T	I N E =======================================
 11761                                  
 11762                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11763                                  ;
 11764                                  ; ENTRY:
 11765                                  ;   fbuf    --	    dma buffer containing filename
 11766                                  ; EXIT:
 11767                                  ;   AX	    --	    file code, as given in search header
 11768                                  ; NOTE(S):
 11769                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11770                                  
 11771                                  SEARCH_FTYPE:
 11772 00002728 57                      		push	di
 11773 00002729 56                      		push	si
 11774 0000272A B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11775                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11776                                  		;mov	di,FBUF_PNAME
 11777 0000272D BF[914B]                		mov	di,FBUF+FIND_BUF.PNAME
 11778 00002730 B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11779 00002733 FC                      		cld
 11780 00002734 F2AE                    		repnz scasb		; search for the terminating null
 11781 00002736 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11782 00002738 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11783                                  
 11784                                  		; Compare .COM
 11785                                  
 11786 0000273B BE[113F]                		mov	si,COMEXT ; ".COM"
 11787 0000273E 89F8                    		mov	ax,di
 11788 00002740 A7                      		cmpsw
 11789 00002741 7508                    		jnz	short FTYPE_EXE
 11790 00002743 A7                      		cmpsw
 11791 00002744 7505                    		jnz	short FTYPE_EXE
 11792                                  		;mov	ax,8
 11793 00002746 B80800                  		mov	ax,SEARCH_COM	; success!
 11794 00002749 EB23                    		jmp	short FTYPE_EXIT
 11795                                  
 11796                                  		; Compare .EXE
 11797                                  FTYPE_EXE:				; still looking... now for '.exe'
 11798 0000274B 89C7                    		mov	di,ax
 11799 0000274D BE[153F]                		mov	si,EXEEXT ; ".EXE"
 11800 00002750 A7                      		cmpsw
 11801 00002751 7508                    		jnz	short FTYPE_BAT
 11802 00002753 A7                      		cmpsw
 11803 00002754 7505                    		jnz	short FTYPE_BAT
 11804                                  		;mov	ax,4
 11805 00002756 B80400                  		mov	ax,SEARCH_EXE	; success!
 11806 00002759 EB13                    		jmp	short FTYPE_EXIT
 11807                                  
 11808                                  		; Compare .BAT
 11809                                  FTYPE_BAT:				; still looking... now for '.bat'
 11810 0000275B 89C7                    		mov	di,ax
 11811 0000275D BE[193F]                		mov	si,BATEXT ; ".BAT"
 11812 00002760 A7                      		cmpsw
 11813 00002761 7508                    		jnz	short FTYPE_FAIL
 11814 00002763 A7                      		cmpsw
 11815 00002764 7505                    		jnz	short FTYPE_FAIL
 11816                                  		;mov	ax,2
 11817 00002766 B80200                  		mov	ax,SEARCH_BAT	; success!
 11818 00002769 EB03                    		jmp	short FTYPE_EXIT
 11819                                  
 11820                                  FTYPE_FAIL:				; file doesn't match what we need
 11821 0000276B B80000                  		mov	ax,ANULL ; 0
 11822                                  
 11823                                  FTYPE_EXIT:
 11824                                  		; MSDOS 6.0
 11825                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11826                                  		;jz	ftype_done	;AN005; no - exit
 11827                                  		;cmp	ax,ANULL	;AN005; was any match found
 11828                                  		;jz	ftype_done	;AN005; no - exit
 11829                                  		;mov	ext_entered,al	;AN005; save the match type found
 11830                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11831                                  ;ftype_done:
 11832 0000276E 5E                      		pop	si
 11833 0000276F 5F                      		pop	di
 11834 00002770 C3                      		retn
 11835                                  
 11836                                  ; =============== S U B	R O U T	I N E =======================================
 11837                                  
 11838                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 11839                                  ; replacing any extension with wildcards.
 11840                                  ;
 11841                                  ; ENTRY:
 11842                                  ;	BX		--		maximum length of destination buffer
 11843                                  ;	DS:SI		--		address of destination buffer
 11844                                  ;	argv[0] 	--		command name to be stripped
 11845                                  ; EXIT:
 11846                                  ;	CF		--		set if failure, clear if successful
 11847                                  ; NOTE(S):
 11848                                  
 11849                                  
 11850                                  STRIP:
 11851 00002771 50                      		push	ax
 11852 00002772 53                      		push	bx
 11853 00002773 51                      		push	cx
 11854 00002774 52                      		push	dx
 11855 00002775 57                      		push	di
 11856 00002776 56                      		push	si
 11857 00002777 9C                      		pushf
 11858                                  		
 11859                                  		; MSDOS 6.0
 11860                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 11861                                  
 11862                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11863                                  		;mov	dx,[ARG_ARGV]
 11864                                  		;mov	dx,ds:arg.argv[0].argpointer
 11865                                  					; save pointer to beginning of argstring
 11866                                  		;mov	dx,[ARGV0_ARGPOINTER]
 11867 00002778 8B16[A945]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 11868                                  		;mov	di,ds:arg.argv[0].argstartel
 11869                                  					; beginning of last pathname element
 11870                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 11871 0000277C 8B3E[AC45]              		mov	di,[ARG+ARGV_ELE.argstartel]
 11872 00002780 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 11873 00002783 742E                    		je	short STRIP_ERROR
 11874 00002785 89D1                    		mov	cx,dx		; compute where end of argstring lies
 11875                                  		;add	cx,ds:arg.argv[0].arglen
 11876                                  		;add	cx,[ARGV0_ARGLEN]
 11877 00002787 030E[AE45]              		add	cx,[ARG+ARGV_ELE.arglen]
 11878 0000278B 29F9                    		sub	cx,di		; and then find length of last element
 11879 0000278D 41                      		inc	cx		; include null as well
 11880                                  		;mov	al,'.'
 11881 0000278E B02E                    		mov	al,DOT		; let's find the filetype extension
 11882 00002790 FC                      		cld
 11883 00002791 F2AE                    		repnz scasb		; wind up pointing to either null or dot
 11884                                  
 11885                                  		; MSDOS 6.0
 11886                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 11887                                  		;mov	ext_entered,0	;AN005; we found an extension
 11888                                  		;mov	al,ANULL	;AN005; continue scanning until the
 11889                                  		;repnz	scasb		;AN005;    end of line is reached.
 11890                                  PROCESS_EXT:
 11891                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11892 00002793 89F9                    		mov	cx,di		; pointer to end of argstring yields
 11893 00002795 29D1                    		sub	cx,dx		; number of bytes to be copied
 11894 00002797 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 11895 0000279A 39D9                    		cmp	cx,bx
 11896 0000279C 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 11897 0000279E 89F7                    		mov	di,si		; destination buffer
 11898 000027A0 89D6                    		mov	si,dx		; source is beginning of pathname
 11899 000027A2 FC                      		cld
 11900 000027A3 F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 11901                                  
 11902                                  		; MSDOS 6.0
 11903                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 11904                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 11905                                  
 11906                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11907 000027A5 4F                      		dec	di		; overwrite null or dot
 11908 000027A6 AA                      		stosb			; with a dot
 11909                                  		;mov	al,'?'
 11910 000027A7 B03F                    		mov	al,WILDCHAR	; now add wildcards
 11911 000027A9 AA                      		stosb
 11912 000027AA AA                      		stosb
 11913 000027AB AA                      		stosb
 11914                                  		;mov	al,0
 11915 000027AC B000                    		mov	al,ANULL	; and a terminating null	
 11916 000027AE AA                      		stosb
 11917                                  SKIP_WILDS:
 11918 000027AF 9D                      		popf
 11919 000027B0 F8                      		clc
 11920 000027B1 EB02                    		jmp	short STRIP_EXIT ; chill out...
 11921                                  
 11922                                  STRIP_ERROR:
 11923 000027B3 9D                      		popf
 11924 000027B4 F9                      		stc
 11925                                  STRIP_EXIT:
 11926 000027B5 5E                      		pop	si
 11927 000027B6 5F                      		pop	di
 11928 000027B7 5A                      		pop	dx
 11929 000027B8 59                      		pop	cx
 11930 000027B9 5B                      		pop	bx
 11931 000027BA 58                      		pop	ax
 11932 000027BB C3                      		retn
 11933                                  
 11934                                  ; =============== S U B	R O U T	I N E =======================================
 11935                                  
 11936                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 11937                                  ;
 11938                                  ; structure in newly allocated memory. The argv[] structure is found at the
 11939                                  ; beginning of this area. The caller indicates how much extra space is
 11940                                  ; needed in the resulting structure; Save_Args returns a segment number and
 11941                                  ; an offset into that area, indicating where the caller may preserve its own
 11942                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 11943                                  ; ENTRY:
 11944                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 11945                                  ; EXIT:
 11946                                  ;   AX	    --	    segment of new area.
 11947                                  ;   CF	    --	    set if unable to save a copy.
 11948                                  ; NOTE(S):
 11949                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 11950                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 11951                                  ;	paragraphs.
 11952                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 11953                                  ;	as the caller of Save_Args requests.
 11954                                  ;   3)	AX is undefined if CF indicates an error.
 11955                                  
 11956                                  SAVE_ARGS:
 11957 000027BC 53                      		push	bx
 11958 000027BD 51                      		push	cx
 11959 000027BE 52                      		push	dx
 11960 000027BF 57                      		push	di
 11961 000027C0 56                      		push	si
 11962 000027C1 55                      		push	bp
 11963 000027C2 9C                      		pushf
 11964                                  		;add	bx,1363		; space for arg structure, round up
 11965 000027C3 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 11966 000027C7 B104                    		mov	cl,4		; to paragraph size and convert
 11967 000027C9 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 11968 000027CB B80048                  		mov	ax,ALLOC*256 ; 4800h
 11969 000027CE CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11970                                  				; BX = number of 16-byte paragraphs desired
 11971 000027D0 7244                    		jc	short SAVE_ERROR
 11972 000027D2 89C5                    		mov	bp,ax		; save segment id
 11973 000027D4 06                      		push	es		; save TRANGROUP address
 11974 000027D5 8EC0                    		mov	es,ax		; switch to new memory segment
 11975                                  		; assume es:nothing
 11976                                  		;mov	cx,1348		; get back structure size
 11977 000027D7 B94405                  		mov	cx,ARG_UNIT.SIZE
 11978 000027DA 31FF                    		xor	di,di		; destination is new memory area
 11979                                  		;mov	si,ARG_ARGV
 11980 000027DC BE[A945]                		mov	si,ARG		; source is arg structure
 11981 000027DF F3A4                    		rep movsb		; move that sucker!
 11982                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 11983                                  		;mov	cx,[ARG_ARGVCNT]
 11984 000027E1 8B0E[6948]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 11985 000027E5 31C0                    		xor	ax,ax		; base address for argv_calc
 11986                                  
 11987                                  	;	Bugbug:	What did they mean by this?
 11988                                  	;	Note that the replacement line produces exactly the same code.
 11989                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 11990                                  	;	mov	SI, OFFSET TRANGROUP:arg
 11991                                  
 11992                                  		;mov	si,ARG_ARGV
 11993 000027E7 BE[A945]                		mov	si,ARG	
 11994                                  SAVE_PTR_LOOP:
 11995 000027EA 49                      		dec	cx		; exhausted all args?
 11996 000027EB 7C24                    		jl	short SAVE_DONE
 11997 000027ED 89CB                    		mov	bx,cx		; get arg index and
 11998 000027EF E8E8FC                  		call	ARGV_CALC	; convert to a pointer
 11999                                  		;mov	dx,ds:arg.argv[bx].argpointer
 12000                                  		;mov	dx,[ARG_ARGV+bx]
 12001 000027F2 8B97[A945]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 12002 000027F6 29F2                    		sub	dx,si		; adjust argpointer
 12003                                  		;mov	es:argv[BX].argpointer,dx
 12004                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12005 000027F8 268917                  		mov	[es:bx],dx
 12006                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12007                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12008 000027FB 8B97[AC45]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12009 000027FF 29F2                    		sub	dx,si		; and adjust argstartel
 12010                                  		;mov	es:argv[bx].argstartel,dx
 12011                                  		;mov	[es:bx+3],dx
 12012 00002801 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12013                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12014                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12015 00002805 8B97[B245]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12016 00002809 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12017                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12018                                  		;mov	[es:bx+9],dx
 12019 0000280B 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12020 0000280F EBD9                    		jmp	short SAVE_PTR_LOOP
 12021                                  SAVE_DONE:
 12022 00002811 07                      		pop	es		; back we go to TRANGROUP
 12023                                  		; assume es:nothing
 12024 00002812 89E8                    		mov	ax,bp		; restore segment id
 12025 00002814 EB04                    		jmp	short SAVE_OK
 12026                                  
 12027                                  SAVE_ERROR:
 12028 00002816 9D                      		popf
 12029 00002817 F9                      		stc
 12030 00002818 EB02                    		jmp	short SAVE_EXIT
 12031                                  
 12032                                  SAVE_OK:
 12033 0000281A 9D                      		popf
 12034 0000281B F8                      		clc
 12035                                  SAVE_EXIT:
 12036 0000281C 5D                      		pop	bp
 12037 0000281D 5E                      		pop	si
 12038 0000281E 5F                      		pop	di
 12039 0000281F 5A                      		pop	dx
 12040 00002820 59                      		pop	cx
 12041 00002821 5B                      		pop	bx
 12042 00002822 C3                      		retn
 12043                                  
 12044                                  ;============================================================================
 12045                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12046                                  ;============================================================================
 12047                                  ; 02/10/2018 - Retro DOS v3.0
 12048                                  
 12049                                  ; Title	COMMAND Language midifiable Code Transient
 12050                                  
 12051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12052                                  
 12053                                  ; =============== S U B	R O U T	I N E =======================================
 12054                                  
 12055                                  ; ****************************************************************
 12056                                  ; *
 12057                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12058                                  ; *
 12059                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12060                                  ; *		 user for Y/N if necessary. If an error occurs,
 12061                                  ; *		 set up an error message and go to CERROR.
 12062                                  ; *
 12063                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12064                                  ; *		 Current directory set to entered directory
 12065                                  ; *
 12066                                  ; * OUTPUT:	 none
 12067                                  ; *
 12068                                  ; ****************************************************************
 12069                                  ;
 12070                                  ; ARE YOU SURE prompt when deleting *.*
 12071                                  
 12072                                  NOTEST2:
 12073 00002823 B90B00                  		mov	cx,11
 12074 00002826 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12075                                  AMBSPEC:
 12076 00002829 AC                      		lodsb
 12077 0000282A 3C3F                    		cmp	al,'?'
 12078 0000282C 7502                    		jnz	short ALLFIL
 12079 0000282E E2F9                    		loop	AMBSPEC
 12080                                  ALLFIL:
 12081 00002830 83F900                  		cmp	cx,0
 12082 00002833 7531                    		jnz	short NOPRMPT
 12083                                  ASKAGN:	
 12084 00002835 BA[EC3A]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12085 00002838 E8980C                  		call	STD_PRINTF
 12086 0000283B BE8000                  		mov	si,80h
 12087 0000283E 89F2                    		mov	dx,si
 12088 00002840 C7047800                		mov	word [si],120	; zero length
 12089                                  		;mov	ax,0C0Ah
 12090 00002844 B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12091 00002847 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12092                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12093 00002849 AD                      		lodsw
 12094 0000284A 08E4                    		or	ah,ah
 12095 0000284C 74E7                    		jz	short ASKAGN
 12096 0000284E E828F1                  		call	SCANOFF
 12097                                  		; MSDOS 6.0
 12098                                  		;call	char_in_xlat	; Convert to upper case
 12099                                  		;retc			; return if function not supported
 12100                                  		; MSDOS 3.3
 12101 00002851 E87E01                  		call	UPCONV
 12102                                  		
 12103                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12104 00002854 3A06[993D]              		cmp	al,[CAPITAL_N]
 12105 00002858 7501                    		jne	short CHECK_Y
 12106 0000285A C3                      		retn
 12107                                  CHECK_Y:
 12108 0000285B 3A06[983D]              		cmp	al,[CAPITAL_Y]
 12109 0000285F 9C                      		pushf
 12110 00002860 E809F1                  		call	CRLF2
 12111 00002863 9D                      		popf
 12112 00002864 75CF                    		jne	short ASKAGN
 12113                                  NOPRMPT:
 12114 00002866 B413                    		mov	ah,FCB_DELETE ; 13h
 12115 00002868 BA5C00                  		mov	dx,FCB ; 5Ch
 12116 0000286B CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12117                                  				; DS:DX	-> FCB with filename field filled with
 12118                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12119                                  				; Return: AL = 00h file	found,FFh file	not found
 12120 0000286D FEC0                    		inc	al
 12121 0000286F 7404                    		jz	short ERAERR
 12122 00002871 E827F0                  		call	RESTUDIR
 12123 00002874 C3                      		retn
 12124                                  
 12125                                  		; MSDOS 6.0
 12126                                  ;eraerr:
 12127                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12128                                  		;push	dx			;AN022; save message
 12129                                  		;invoke	RESTUDIR
 12130                                  		;pop	dx			;AN022; restore message
 12131                                  		;
 12132                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12133                                  		;				;AN022; convert no more files to
 12134                                  		;jnz	cerrorj2		;AN022; 	file not found
 12135                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12136                                  		;			;AN000; get message number in control block
 12137                                  ;cerrorj2:
 12138                                  		;jmp	cerror
 12139                                  	
 12140                                  		; MSDOS 3.3
 12141                                  ERAERR:	
 12142 00002875 B41A                    		mov	ah,SET_DMA ; 1Ah
 12143 00002877 BA5C00                  		mov	dx,FCB ; 5Ch
 12144 0000287A CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12145                                  					; DS:DX	-> disk	transfer buffer
 12146 0000287C B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12147 0000287E CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12148                                  					; DS:DX	-> FCB
 12149 00002880 50                      		push	ax
 12150 00002881 E817F0                  		call	RESTUDIR
 12151 00002884 58                      		pop	ax
 12152 00002885 BA[F837]                		mov	dx,FNOTFOUNDPTR
 12153 00002888 FEC0                    		inc	al
 12154 0000288A 743D                    		jz	short CERRORJ
 12155 0000288C BA[1D38]                		mov	dx,ACCDENPTR
 12156 0000288F E997F3                  		jmp	CERROR
 12157                                  
 12158                                  ; =============== S U B	R O U T	I N E =======================================
 12159                                  
 12160                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12161                                  
 12162                                  ECHO:
 12163 00002892 E89400                  		call	ON_OFF
 12164 00002895 7212                    		jb	short DOEMES
 12165 00002897 8E1E[7142]              		mov	ds,[RESSEG]
 12166 0000289B 7506                    		jnz	short ECH_OFF
 12167 0000289D 800EEF0B01              		or	byte [ECHOFLAG],1
 12168 000028A2 C3                      		retn
 12169                                  
 12170                                  ECH_OFF:
 12171 000028A3 8026EF0BFE              		and	byte [ECHOFLAG],0FEh
 12172 000028A8 C3                      		retn
 12173                                  
 12174                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12175                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12176                                  
 12177                                  DOEMES:
 12178                                  		; MSDOS 6.0
 12179                                  		;cmp	cl,0		;AC000; was anything on the line?
 12180                                  		;jz	PECHO		; just display current state.
 12181                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12182                                  		;invoke	CRPRINT
 12183                                  		;JMP	CRLF2
 12184                                  
 12185                                  		; MSDOS 3.3
 12186 000028A9 E82000                  		call	MOVE_TO_FIRST_ARG
 12187 000028AC 7409                    		jz	short PECHO
 12188 000028AE BA8200                  		mov	dx,82h
 12189 000028B1 E816F1                  		call	CRPRINT
 12190 000028B4 E9B5F0                  		jmp	CRLF2
 12191                                  
 12192                                  PECHO:
 12193                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12194 000028B7 8E1E[7142]              		mov	ds,[RESSEG]
 12195 000028BB 8A1EEF0B                		mov	bl,byte [ECHOFLAG]
 12196 000028BF 0E                      		push	cs
 12197 000028C0 1F                      		pop	ds
 12198 000028C1 80E301                  		and	bl,1
 12199 000028C4 BA[1F3D]                		mov	dx,ECHOMESPTR
 12200 000028C7 EB2E                    		jmp	short PYN
 12201                                  
 12202                                  ; ---------------------------------------------------------------------------
 12203                                  
 12204                                  		; MSDOS 3.3
 12205                                  CERRORJ:
 12206 000028C9 E95DF3                  		jmp	CERROR
 12207                                  
 12208                                  
 12209                                  ; =============== S U B	R O U T	I N E =======================================
 12210                                  
 12211                                  MOVE_TO_FIRST_ARG:
 12212 000028CC BE8100                  		mov	si,81h
 12213 000028CF E8A7F0                  		call	SCANOFF
 12214 000028D2 3C0D                    		cmp	al,0Dh
 12215 000028D4 C3                      		retn
 12216                                  
 12217                                  ; =============== S U B	R O U T	I N E =======================================
 12218                                  
 12219                                  CNTRLC:
 12220 000028D5 E85100                  		call	ON_OFF
 12221 000028D8 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12222 000028DB 720C                    		jc	short PCNTRLC
 12223 000028DD 7505                    		jnz	short CNTRLC_OFF
 12224 000028DF B201                    		mov	dl,1
 12225 000028E1 CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12226                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12227                                  				; DL = 00h for OFF or 01h for ON
 12228 000028E3 C3                      		retn
 12229                                  
 12230                                  ; ---------------------------------------------------------------------------
 12231                                  
 12232                                  CNTRLC_OFF:
 12233 000028E4 30D2                    		xor	dl,dl
 12234 000028E6 CD21                    		int	21h		; Turn off ^C check
 12235 000028E8 C3                      		retn
 12236                                  
 12237                                  ; ---------------------------------------------------------------------------
 12238                                  
 12239                                  PCNTRLC:
 12240                                  		; MSDOS 6.0
 12241                                  		;CMP	CL,0		;AC000; rest of line blank?
 12242                                  		;JNZ	CERRORJ 	; no, oops!
 12243                                  
 12244                                  		; MSDOS 3.3
 12245 000028E9 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12246 000028EC 75DB                    		jnz	short CERRORJ
 12247                                  ;pccont:
 12248                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12249 000028EE 30C0                    		xor	al,al
 12250 000028F0 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12251 000028F2 88D3                    		mov	bl,dl
 12252 000028F4 BA[073D]                		mov	dx,CTRLMESPTR
 12253                                  
 12254                                  ; ---------------------------------------------------------------------------
 12255                                  
 12256                                  PYN:		; write "ON" or "OFF" state 
 12257                                  
 12258 000028F7 E8D90B                  		call	STD_PRINTF
 12259 000028FA BA[2E3D]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12260 000028FD 08DB                    		or	bl,bl
 12261 000028FF 7503                    		jnz	short PRINTVAL
 12262 00002901 BA[273D]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12263                                  
 12264                                  PRINTVAL:
 12265                                  		; MSDOS 3.3
 12266 00002904 E9CC0B                  		jmp	STD_PRINTF
 12267                                  
 12268                                  		; MSDOS 6.0
 12269                                  		;push	dx		;AN000; save offset of message block
 12270                                  		;mov	bx,dx		;AN000; save offset value
 12271                                  		;lodsw			;AN000; get message number of on or off
 12272                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12273                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12274                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12275                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12276                                  		;pop	dx		;AN000; get message back
 12277                                  		;invoke	std_printf	;AC000; go print message
 12278                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12279                                  		;
 12280                                  		;ret			;AN000; exit
 12281                                  
 12282                                  ; =============== S U B	R O U T	I N E =======================================
 12283                                  
 12284                                  VERIFY:
 12285 00002907 E81F00                  		call	ON_OFF
 12286 0000290A B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12287 0000290D 720A                    		jc	short PVERIFY
 12288 0000290F 7503                    		jnz	short VER_OFF
 12289 00002911 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12290                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12291 00002913 C3                      		retn
 12292                                  
 12293                                  ; ---------------------------------------------------------------------------
 12294                                  
 12295                                  VER_OFF:
 12296 00002914 FEC8                    		dec	al
 12297 00002916 CD21                    		int	21h		; Turn off verify after write
 12298 00002918 C3                      		retn
 12299                                  
 12300                                  ; ---------------------------------------------------------------------------
 12301                                  
 12302                                  PVERIFY:
 12303                                  		; MSDOS 6.0
 12304                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12305                                  		;JNZ	CERRORJ 	; nope...
 12306                                  
 12307                                  		; MSDOS 3.3
 12308 00002919 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12309 0000291C 75AB                    		jnz	short CERRORJ
 12310                                  
 12311 0000291E B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12312 00002920 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12313                                  					; Return: AL = 00h if flag OFF
 12314                                  					; AL = 01h if flag ON
 12315 00002922 88C3                    		mov	bl,al
 12316 00002924 BA[143D]                		mov	dx,VERIMESPTR
 12317 00002927 EBCE                    		jmp	short PYN
 12318                                  
 12319                                  ; =============== S U B	R O U T	I N E =======================================
 12320                                  
 12321                                  ; ****************************************************************
 12322                                  ; *
 12323                                  ; * ROUTINE:	 ON_OFF
 12324                                  ; *
 12325                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12326                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12327                                  ; *		 routines.
 12328                                  ; *
 12329                                  ; * INPUT:	 command line at offset 81H
 12330                                  ; *		 PARSE_BREAK control block
 12331                                  ; *
 12332                                  ; * OUTPUT:	 If carry is clear
 12333                                  ; *		    If ON is found
 12334                                  ; *		       Zero flag set
 12335                                  ; *		    If OFF is found
 12336                                  ; *		       Zero flag clear
 12337                                  ; *		 If carry set
 12338                                  ; *		    If nothing on command line
 12339                                  ; *		       CL set to zero
 12340                                  ; *		    If error
 12341                                  ; *		       CL contains error value from parse
 12342                                  ; *
 12343                                  ; ****************************************************************
 12344                                  
 12345                                  ON_OFF:
 12346 00002929 BE8100                  		mov	si,81h
 12347                                  
 12348                                  		; MSDOS 3.3
 12349 0000292C E84AF0                  		call	SCANOFF		; scan off leading blanks & equal
 12350 0000292F 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12351 00002931 742A                    		je	short BAD_ONF	; yes, return error
 12352 00002933 AD                      		lodsw
 12353 00002934 0D2020                  		or	ax,2020h	; convert to lowercase
 12354 00002937 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12355 0000293A 7410                    		je	short ON_CHECK
 12356 0000293C 3D6F66                  		cmp	ax,666Fh ;'of'
 12357 0000293F 751C                    		jne	short BAD_ONF
 12358 00002941 AC                      		lodsb
 12359 00002942 0C20                    		or	al,20h		; convert to lowercase		
 12360 00002944 3C66                    		cmp	al,66h	 ; 'f'
 12361 00002946 7515                    		jne	short BAD_ONF	
 12362 00002948 0C66                    		or	al,66h ; or al,'f'
 12363 0000294A EB02                    		jmp	short OFF_CHECK
 12364                                  ON_CHECK:
 12365 0000294C 30C0                    		xor	al,al
 12366                                  OFF_CHECK:
 12367 0000294E 9F                      		lahf
 12368 0000294F 89C3                    		mov	bx,ax
 12369 00002951 E825F0                  		call	SCANOFF		; scan off leading blanks & equal
 12370 00002954 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12371 00002956 7505                    		jne	short BAD_ONF	; no, return error
 12372 00002958 89D8                    		mov	ax,bx
 12373 0000295A 9E                      		sahf
 12374 0000295B F8                      		clc
 12375 0000295C C3                      		retn
 12376                                  
 12377                                  		; MSDOS 6.0
 12378                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12379                                  ;		lodsb			;AN032; get a char
 12380                                  ;		cmp	al,blank	;AN032; if whitespace
 12381                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12382                                  ;		cmp	al,tab_chr	;AN032; if tab
 12383                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12384                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12385                                  ;		jz	parse_on_off	;AN032;    start parsing
 12386                                  ;		dec	si		;AN032; if none of above - back up
 12387                                  ;
 12388                                  ;parse_on_off:				;AN032;    and start parsing
 12389                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
 12390                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12391                                  ;		xor	dx,dx		;AN000;
 12392                                  ;		invoke	cmd_parse	;AC000; call parser
 12393                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12394                                  ;		jz	BADONF		;AC000; yes, return error
 12395                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12396                                  ;		jz	on_off_there	;AN000; no - continue
 12397                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12398                                  ;		jmp	short BADONF	;AN000; return error
 12399                                  ;
 12400                                  ;on_off_there:
 12401                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12402                                  ;		jnz	good_on_off	;AN014; yes - continue
 12403                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12404                                  ;		jmp	short BADONF	;AN014; return error
 12405                                  ;
 12406                                  ;good_on_off:				;AN014;
 12407                                  ;		xor	ax,ax		;AC000; set up return code for
 12408                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12409                                  ;		pushf			;AN000; save flags
 12410                                  ;		mov	di,offset trangroup:parse_break
 12411                                  ;					;AN000; Get adderss of PARSE_BREAK
 12412                                  ;		xor	dx,dx		;AN000;
 12413                                  ;		invoke	cmd_parse	;AN000; call parser
 12414                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12415                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12416                                  ;		popf			;AN000; restore flags
 12417                                  ;		clc			;AC000; no error
 12418                                  ;		jmp	short on_off_end ;AN000; return to caller
 12419                                  ;
 12420                                  ;BADONF_flags:
 12421                                  ;		mov	cx,ax
 12422                                  ;		popf
 12423                                  
 12424                                  ; ---------------------------------------------------------------------------
 12425                                  
 12426                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12427                                  ; and return the error
 12428                                  
 12429                                  BAD_ONF:
 12430 0000295D BA[E93B]                		mov	dx,BADONOFFPTR
 12431 00002960 F9                      		stc
 12432                                  ;on_off_end:
 12433 00002961 C3                      		retn
 12434                                  
 12435                                  ;============================================================================
 12436                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12437                                  ;============================================================================
 12438                                  ; 02/10/2018 - Retro DOS v3.0
 12439                                  
 12440                                  ; Print volume ID info
 12441                                  
 12442                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12443                                  
 12444                                  ; ---------------------------------------------------------------------------
 12445                                  
 12446                                  PRINTVOL:
 12447 00002962 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12448 00002963 A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12449 00002966 0440                    		add	al,'@'
 12450 00002968 3C40                    		cmp	al,'@'
 12451 0000296A 7507                    		jnz	short DRVOK
 12452 0000296C A0[8542]                		mov	al,[CURDRV]
 12453 0000296F 0206[F03E]              		add	al,[CAPITAL_A]
 12454                                  DRVOK:
 12455 00002973 A2[6444]                		mov	[VOL_DRV],al	; get drive letter into argument
 12456 00002976 58                      		pop	ax		; get return code back
 12457 00002977 BA[553B]                		mov	dx,NOVOL ; "has	no label" 
 12458 0000297A 08C0                    		or	al,al		; volume label found?
 12459 0000297C 7517                    		jnz	short PRINTVOL2	; print no volume message
 12460                                  GOODVOL:
 12461                                  		; MSDOS 3.3
 12462 0000297E BF[9B42]                		mov	di,CHARBUF
 12463 00002981 89FA                    		mov	dx,di
 12464 00002983 BE[513B]                		mov	si,IS	; "is "
 12465 00002986 E8FBDE                  		call	STRCPY
 12466 00002989 4F                      		dec	di
 12467 0000298A BE[7243]                		mov	si,DIRBUF+8
 12468 0000298D B90B00                  		mov	cx,11
 12469 00002990 F3A4                    		rep movsb
 12470 00002992 31C0                    		xor	ax,ax
 12471                                  		;xor	al,al  ; MSDOS 6.0
 12472 00002994 AA                      		stosb			; store a zero to terminate the string
 12473                                  PRINTVOL2:
 12474 00002995 8916[6244]              		mov	[VOLNAME_ADDR],dx
 12475 00002999 BA[4B3B]                		mov	dx,VOLMESPTR
 12476 0000299C E9240B                  		jmp	PRINTF_CRLF
 12477                                  
 12478                                  		; MSDOS 6.0
 12479                                  ;drvok:
 12480                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12481                                  ;		pop	ax		;AC000; get return code back
 12482                                  ;		or	al,al		;AC000; volume label found?
 12483                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12484                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12485                                  ;					;AC000; set up no volume message
 12486                                  ;		jmp	short print_serial	;AC000; go print it
 12487                                  ;
 12488                                  ;Get_vol_name:
 12489                                  ;		mov	di,offset trangroup:charbuf
 12490                                  ;		mov	dx,di
 12491                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12492                                  ;		mov	cx,11				;AN000;  3/3/KK
 12493                                  ;		rep	movsb				;AN000;  3/3/KK
 12494                                  ;
 12495                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12496                                  ;		stosb
 12497                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12498                                  ;
 12499                                  ;PRINT_SERIAL:
 12500                                  ;
 12501                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12502                                  ;; occurs, do not print volume serial number.
 12503                                  ;
 12504                                  ;		push	dx		;AN000; save message offset
 12505                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12506                                  ;					;AC036; Get the volume serial info
 12507                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12508                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12509                                  ;		int	21h		;AN000; do the call
 12510                                  ;		pop	dx		;AN000; get message offset back
 12511                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12512                                  ;		call	std_printf	;AC000; go print volume message
 12513                                  ;		mov	al,blank	;AN051; Print out a blank
 12514                                  ;		invoke	print_char	;AN051;   before volume message
 12515                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12516                                  ;					;AN000; get serial number message
 12517                                  ;printvol_end:
 12518                                  ;		jmp	std_printf	;AC000; go print and exit
 12519                                  
 12520                                  ;============================================================================
 12521                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12522                                  ;============================================================================
 12523                                  ; 02/10/2018 - Retro DOS v3.0
 12524                                  
 12525                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12526                                  
 12527                                  ; =============== S U B	R O U T	I N E =======================================
 12528                                  
 12529                                  PRINT_DATE:
 12530                                  		; MSDOS 3.3
 12531 0000299F 06                      		push	es
 12532 000029A0 57                      		push	di
 12533 000029A1 0E                      		push	cs
 12534 000029A2 07                      		pop	es
 12535 000029A3 BF[C843]                		mov	di,ARG_BUF
 12536 000029A6 B42A                    		mov	ah,GET_DATE ; 2Ah
 12537 000029A8 CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12538                                  				; Return: DL = day,DH = month,	CX = year
 12539                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12540 000029AA 98                      		cbw
 12541 000029AB E80F00                  		call	GETDATE
 12542 000029AE E8EDF6                  		call	P_DATE
 12543 000029B1 30C0                    		xor	al,al
 12544 000029B3 AA                      		stosb
 12545 000029B4 BA[2337]                		mov	dx,ARG_BUF_PTR
 12546 000029B7 E8190B                  		call	STD_PRINTF
 12547 000029BA 07                      		pop	es
 12548 000029BB 5F                      		pop	di
 12549 000029BC C3                      		retn
 12550                                  
 12551                                  		; MSDOS 6.0
 12552                                  		;PUSH	ES
 12553                                  		;PUSH	DI
 12554                                  		;PUSH	CS
 12555                                  		;POP	ES
 12556                                  		;CALL	GetDate 		; get date
 12557                                  		;xchg	dh,dl			;AN000; switch month & day
 12558                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12559                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12560                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12561                                  		;invoke	std_printf
 12562                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12563                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12564                                  		;POP	DI			;AC000; restore di,es
 12565                                  		;POP	ES			;AC000;
 12566                                  		;return
 12567                                  
 12568                                  ; ---------------------------------------------------------------------------
 12569                                  
 12570                                  GETDATE:
 12571                                  		; MSDOS 3.3
 12572 000029BD 89C6                    		mov	si,ax
 12573 000029BF D1E6                    		shl	si,1
 12574 000029C1 01C6                    		add	si,ax
 12575 000029C3 81C6[243A]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12576 000029C7 89CB                    		mov	bx,cx
 12577 000029C9 B90300                  		mov	cx,3
 12578 000029CC F3A4                    		rep movsb
 12579 000029CE B020                    		mov	al,' '
 12580 000029D0 AA                      		stosb
 12581 000029D1 C3                      		retn
 12582                                  
 12583                                  		; MSDOS 6.0
 12584                                  
 12585                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12586                                  ; for output.  Date will be returned in CX,DX.
 12587                                  
 12588                                  ;GetDate:
 12589                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12590                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12591                                  		;INT	21h			;AC000; Get date in CX:DX
 12592                                  		;CBW				;AC000;
 12593                                  		;
 12594                                  		;push	cx			;AN000; save date returned in
 12595                                  		;push	dx			;AN000;      CX:DX
 12596                                  		;MOV	SI,AX
 12597                                  		;
 12598                                  		;SHL	SI,1
 12599                                  		;ADD	SI,AX			; SI=AX*3
 12600                                  		;
 12601                                  		;mov	cx,si			;AN000; save si
 12602                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12603                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12604                                  		;push	di			;AN000; save argument buffer
 12605                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12606                                  		;pop	di			;AN000; retrieve argument buffer
 12607                                  		;add	si,cx			;AC000; get day of week
 12608                                  		;
 12609                                  		;MOV	CX,3
 12610                                    		;REP	MOVSB
 12611                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12612                                  		;stosb
 12613                                  		;pop	dx			;AN000; get back date
 12614                                  		;pop	cx			;AN000;
 12615                                  		;
 12616                                  		;return
 12617                                  
 12618                                  ; =============== S U B	R O U T	I N E =======================================
 12619                                  
 12620                                  		; MSDOS 6.0
 12621                                  
 12622                                  ; This routine determines whether the character in AL is a
 12623                                  ; Yes or No character. On return, if AL=0, the character is
 12624                                  ; No, if AL=1, the character is Yes.
 12625                                  
 12626                                  ;		assume	ds:trangroup
 12627                                  
 12628                                  ;char_in_xlat	proc	near
 12629                                  ;
 12630                                  ;		mov	dl,al			;AC000; get character into DX
 12631                                  ;		xor	dh,dh			;AC000;
 12632                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12633                                  ;		int	21h			;AC000;
 12634                                  ;
 12635                                  ;		ret
 12636                                  ;
 12637                                  ;char_in_xlat	endp
 12638                                  
 12639                                  ;============================================================================
 12640                                  ; TENV.ASM, MSDOS 6.0, 1991
 12641                                  ;============================================================================
 12642                                  ; 02/10/2018 - Retro DOS v3.0
 12643                                  
 12644                                  ;	Environment utilities and misc. routines
 12645                                  
 12646                                  ; MSDOS 6.0
 12647                                  ; ****************************************************************
 12648                                  ; *
 12649                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12650                                  ; *
 12651                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12652                                  ; *		 the character in AL from the file upper case table
 12653                                  ; *		 in DOS if character if above  ascii 128, else
 12654                                  ; *		 subtracts 20H if between "a" and "z".
 12655                                  ; *
 12656                                  ; * INPUT:	 AL	      char to be upper cased
 12657                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12658                                  ; *
 12659                                  ; * OUTPUT:	 AL	      upper cased character
 12660                                  ; *
 12661                                  ; ****************************************************************
 12662                                  ;
 12663                                  ;assume	ds:trangroup				;AN000;
 12664                                  ;
 12665                                  ;upconv	proc	near				;AN000;
 12666                                  ;
 12667                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12668                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12669                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12670                                  ;	push	ds				;AN000;
 12671                                  ;	push	bx				;AN000;
 12672                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12673                                  ;assume	ds:resgroup				;AN000;
 12674                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12675                                  ;	add	bx,2				;AN000;  skip over first word
 12676                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12677                                  ;	pop	bx				;AN000;
 12678                                  ;	pop	ds				;AN000;
 12679                                  ;assume	ds:trangroup				;AN000;
 12680                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12681                                  ;
 12682                                  ;oth_fucase:					;AN000;
 12683                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12684                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12685                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12686                                  ;	ja	upconv_end			;AC000;
 12687                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12688                                  ;
 12689                                  ;upconv_end:					;AN000;
 12690                                  ;	ret
 12691                                  ;
 12692                                  ;upconv	endp					;AN000;
 12693                                  
 12694                                  
 12695                                  ; =============== S U B	R O U T	I N E =======================================
 12696                                  
 12697                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12698                                  
 12699                                  UPCONV:
 12700 000029D2 3C80                    		cmp	al,80h
 12701 000029D4 7214                    		jb	short OTH_UCASE
 12702 000029D6 2C80                    		sub	al,80h
 12703 000029D8 1E                      		push	ds
 12704 000029D9 53                      		push	bx
 12705 000029DA 8E1E[7142]              		mov	ds,[RESSEG]
 12706 000029DE C51E060C                		lds	bx,[UPPERCASETBL]
 12707 000029E2 83C302                  		add	bx,2
 12708 000029E5 D7                      		xlat
 12709 000029E6 5B                      		pop	bx
 12710 000029E7 1F                      		pop	ds
 12711 000029E8 EB0A                    		jmp	short UPCONV_RETN
 12712                                  
 12713                                  OTH_UCASE:
 12714 000029EA 3C61                    		cmp	al,'a'
 12715 000029EC 7206                    		jb	short UPCONV_RETN
 12716 000029EE 3C7A                    		cmp	al,'z'
 12717 000029F0 7702                    		ja	short UPCONV_RETN
 12718 000029F2 2C20                    		sub	al,20h
 12719                                  
 12720                                  UPCONV_RETN:
 12721 000029F4 C3                      		retn
 12722                                  
 12723                                  ;============================================================================
 12724                                  ; COPY.ASM, MSDOS 6.0, 1991
 12725                                  ;============================================================================
 12726                                  ; 01/10/2018 - Retro DOS v3.0
 12727                                  
 12728                                  ;	title	COMMAND COPY routines.
 12729                                  
 12730                                  ;/*
 12731                                  ; *                      Microsoft Confidential
 12732                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12733                                  ; *                      All Rights Reserved.
 12734                                  ; */
 12735                                  
 12736                                  ;***	COPY.ASM
 12737                                  
 12738                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12739                                  
 12740                                  
 12741                                  ;***	MODIFICATION HISTORY
 12742                                  
 12743                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12744                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12745                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12746                                  ;	     to tokens which begin with path characters so that PARSELINE
 12747                                  ;	     will work correctly.
 12748                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12749                                  ;	     individual tokens.  That distinction is no longer needed for
 12750                                  ;	     FOR loop processing.
 12751                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12752                                  ;	     1 when Cparse is called from COPY.
 12753                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12754                                  ;	     mod.  It now is conditional on flag like previous mod.
 12755                                  ;11/21/83 NP  Added printf
 12756                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12757                                  ;	     be added to a token.
 12758                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12759                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12760                                  ;	     special values:  -1 meaning destination was never opened and
 12761                                  ;	     0 which means that the destination has been openned and
 12762                                  ;	     closed.
 12763                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12764                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12765                                  ;	     lost on large and multiple file (wildcard) copies.
 12766                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12767                                  ;	     destination are not equal.
 12768                                  ;
 12769                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12770                                  ;	     first source file AND we run out of disk space before
 12771                                  ;	     completing the concatenation, restore the first source
 12772                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12773                                  ;
 12774                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12775                                  ;		instead of compatibility mode. This gives lesser sharing
 12776                                  ;		violations when files are opened for read on a copy.
 12777                                  
 12778                                  ; ---------------------------------------------------------------------------
 12779                                  ;***	COPY CODE
 12780                                  ; ---------------------------------------------------------------------------
 12781                                  
 12782                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12783                                  
 12784                                  COPY:
 12785                                  	; 	Initialize internal variables.
 12786                                  
 12787 000029F5 31C0                    		xor	ax,ax		; AX = 0
 12788 000029F7 A3[5044]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12789 000029FA A3[8545]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12790 000029FD A3[D144]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12791 00002A00 A2[9042]                		mov	[CFLAG],al	; 'destination file created' = false
 12792 00002A03 A3[9442]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12793 00002A06 A3[8C42]                		mov	[DESTSWITCH],ax	; destination switches = none
 12794 00002A09 A3[9745]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12795 00002A0C A3[6E44]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12796 00002A0F A2[9142]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12797 00002A12 A2[6D44]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12798 00002A15 A2[D044]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12799 00002A18 A2[7044]                		mov	[DESTINFO],al	; destination pathname flags = none
 12800 00002A1B A2[D344]                		mov	[SRCINFO],al	; source pathname flags = none
 12801 00002A1E A2[8745]                		mov	[INEXACT],al	; 'inexact copy' = false
 12802 00002A21 A2[6C44]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12803 00002A24 A2[CF44]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12804 00002A27 A2[5341]                		mov	[USERDIR1],al	; saved working directory = null
 12805 00002A2A A2[8945]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12806 00002A2D A2[8442]                		mov	[RDEOF],al	; 'read end of file' = false
 12807 00002A30 A3[2B45]                		mov	[SRCHAND],ax	; source handle = 0
 12808 00002A33 A3[9145]                		mov	[CPDATE],ax	; copy date = 0
 12809 00002A36 A3[9345]                		mov	[CPTIME],ax	; copy time = 0
 12810 00002A39 A2[2D45]                		mov	[SRCISDEV],al	; 'source is device' = false
 12811                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12812                                  		;mov	[OFilePtr_Lo],ax
 12813                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12814 00002A3C A2[8D45]                		mov	[TERMREAD],al	; 'terminate read' = false
 12815 00002A3F A2[C643]                		mov	[COMMA],al	; '"+,," found' = false
 12816 00002A42 A2[C743]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12817 00002A45 A3[8E42]                		mov	[ALLSWITCH],ax	; all switches = none
 12818 00002A48 A2[8742]                		mov	[ARGC],al	; source/dest argument count = 0
 12819 00002A4B A2[8F45]                		mov	[PLUS],al	; '"+" in command line' = false
 12820 00002A4E A2[8A45]                		mov	[BINARY],al	; 'binary copy' = false
 12821 00002A51 A2[8E45]                		mov	[ASCII],al	; 'ascii copy' = false
 12822 00002A54 A3[9942]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12823 00002A57 A3[8B45]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12824 00002A5A A2[8642]                		mov	[CONCAT],al	; 'concatenating' = false
 12825 00002A5D A2[CC44]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12826 00002A60 A3[CD44]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12827                                  
 12828                                  	;	Initialize buffers with double-nulls.
 12829                                  
 12830 00002A63 A3[2E45]                		mov	[SCANBUF],ax
 12831 00002A66 A3[7144]                		mov	[DESTBUF],ax
 12832 00002A69 A3[D444]                		mov	[SRCBUF],ax
 12833 00002A6C A3[B043]                		mov	[SDIRBUF],ax
 12834 00002A6F A3[6A43]                		mov	[DIRBUF],ax
 12835 00002A72 A3[2743]                		mov	[DESTFCB],ax
 12836                                  
 12837 00002A75 A2[9045]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 12838                                  		
 12839 00002A78 48                      		dec	ax		; AX = 0FFFFh
 12840 00002A79 A3[C844]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 12841 00002A7C A2[9642]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 12842 00002A7F A2[CB44]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 12843 00002A82 A2[6C44]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 12844                                  		
 12845 00002A85 BE8100                  		mov	si,81h		; SI = ptr to command line
 12846 00002A88 8A1E[FF3E]              		mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 12847 00002A8C FE06[A745]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 12848 00002A90 C606[5644]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 12849                                  
 12850                                  	;*	Scan the command line for destination information.
 12851                                  
 12852                                  DESTSCAN:
 12853 00002A95 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 12854 00002A97 BF[2E45]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 12855                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 12856 00002A9A E87708                  		call	CPARSE			; parse next object
 12857 00002A9D 9C                      		pushf				; save CParse flags
 12858 00002A9E FE06[9045]              		inc	byte [OBJCNT]		; count object
 12859 00002AA2 F6C780                  		test	bh,80h
 12860 00002AA5 7405                    		jz	short NOCOPY		; no "+" delimiter
 12861 00002AA7 C606[8F45]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 12862                                  NOCOPY:
 12863 00002AAC F6C701                  		test	bh,1
 12864 00002AAF 740D                    		jz	short TESTP2		; not a switch
 12865                                  
 12866                                  	;	Found a switch.
 12867                                  
 12868                                  		; MSDOS 6.0
 12869                                  		;test	bp,SwitchV		;AN038; Verify requested?
 12870                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12871                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 12872                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12873                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 12874                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 12875                                  
 12876                                  NOT_SLASHV:
 12877 00002AB1 092E[8C42]              		or	[DESTSWITCH],bp		; assume destination
 12878 00002AB5 092E[8E42]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 12879                                  
 12880                                  		; MSDOS 6.0
 12881                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 12882                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 12883                                  		;popf				;AN018; fix up stack
 12884                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 12885                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 12886                                  		;jmp	CError			;AC018; exit
 12887                                  
 12888                                  NOT_BAD_SWITCH:
 12889 00002AB9 9D                      		popf				; restore CParse flags
 12890 00002ABA 7233                    		jc	short CHECKDONE		; found CR
 12891 00002ABC EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 12892                                  
 12893                                  TESTP2:
 12894 00002ABE 9D                      		popf				; restore CParse flags
 12895 00002ABF 722E                    		jc	short CHECKDONE		; found CR
 12896 00002AC1 F6C780                  		test	bh,80h
 12897 00002AC4 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 12898 00002AC6 FE06[8742]              		inc	byte [ARGC]		; count independent pathname args
 12899                                  GOTPLUS:
 12900 00002ACA 56                      		push	si			; save cmd line ptr
 12901 00002ACB A1[9745]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 12902 00002ACE BE[2E45]                		mov	si,SCANBUF		; SI = ptr to path string
 12903 00002AD1 29F0                    		sub	ax,si			; AX = offset of last element
 12904 00002AD3 BF[7144]                		mov	di,DESTBUF		; DI = ptr to destination buf
 12905 00002AD6 01F8                    		add	ax,di			; AX = ptr to last element in
 12906                                  						;  destination path buffer
 12907 00002AD8 A3[6E44]                		mov	[DESTTAIL],ax		; save ptr to last element
 12908 00002ADB 880E[6D44]              		mov	[DESTSIZ],cl		; save path string length
 12909 00002ADF 41                      		inc	cx			; CX = mov length (incl null)
 12910 00002AE0 F3A4                    		rep movsb			; DestBuf = possible destination path
 12911 00002AE2 883E[7044]              		mov	[DESTINFO],bh		; save CParse info flags
 12912 00002AE6 C706[8C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12913 00002AEC 5E                      		pop	si			; SI = ptr into cmd line again
 12914 00002AED EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 12915                                  
 12916                                  CHECKDONE:
 12917                                  
 12918                                  	;	We reached the CR. The destination scan is finished.
 12919                                  
 12920                                  	;	Disallow "copy file1+" as file overwriting itself.
 12921                                  	;
 12922                                  	;	(Note that "copy file1+file2+" will be accepted, and
 12923                                  	;	equivalent to "copy file1+file2".)
 12924                                  
 12925                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 12926                                  	;	through this check, since the switch would count
 12927                                  	;	as another object in ObjCnt.
 12928                                  
 12929 00002AEF 803E[8F45]01            		cmp	byte [PLUS],1		; "+" with
 12930 00002AF4 7514                    		jnz	short CDCONT
 12931 00002AF6 803E[8742]01            		cmp	byte [ARGC],1		; one arg,
 12932 00002AFB 750D                    		jnz	short CDCONT
 12933 00002AFD 803E[9045]02            		cmp	byte [OBJCNT],2		; two objects..
 12934 00002B02 7506                    		jnz	short CDCONT
 12935 00002B04 BA[9438]                		mov	dx,OVERWRPTR
 12936 00002B07 E9B605                  		jmp	COPYERR			; is file overwrite
 12937                                  
 12938                                  CDCONT:
 12939 00002B0A A0[8F45]                		mov	al,[PLUS]		; AL = '"+" occurred'
 12940 00002B0D A2[8642]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 12941 00002B10 D0E0                    		shl	al,1
 12942 00002B12 D0E0                    		shl	al,1
 12943 00002B14 A2[8745]                		mov	[INEXACT],al		; therefore making an inexact copy
 12944 00002B17 BA[6D3D]                		mov	dx,BADARGSPTR
 12945 00002B1A A0[8742]                		mov	al,[ARGC]		; AL = # independent arguments
 12946 00002B1D 08C0                    		or	al,al
 12947 00002B1F 7404                    		jz	short CERROR4J
 12948                                  
 12949                                  		; MSDOS 6.0
 12950                                  		;or	al,al
 12951                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 12952                                  		
 12953                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12954                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 12955                                  		;jmp	short CError_ParseJ		; take parse error exit		
 12956                                  
 12957                                  	; more than 0 args; check if too many
 12958                                  
 12959                                  TRY_TOO_MANY:
 12960 00002B21 3C02                    		cmp	al,2
 12961 00002B23 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 12962                                  
 12963                                  		; MSDOS 6.0
 12964                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12965                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 12966                                  ;CError_ParseJ:
 12967                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 12968                                  
 12969                                  CERROR4J:
 12970 00002B25 E901F1                  		jmp	CERROR
 12971                                  
 12972                                  ACOUNTOK:
 12973 00002B28 BD[6C44]                		mov	bp,DESTVARS		; BP = base of dest variables
 12974                                  
 12975 00002B2B 3C01                    		cmp	al,1
 12976 00002B2D 7522                    		jnz	short GOT2ARGS
 12977                                  
 12978                                  	;	Only one independent pathname argument on command line.
 12979                                  	;	Set destination to d:*.*, where d: is current drive.
 12980                                  
 12981                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 12982                                  	;	The two files would be appended as d:file1, rather than x:file1.
 12983                                  
 12984 00002B2F A0[8542]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 12985 00002B32 0206[F03E]              		add	al,[CAPITAL_A]		; AL = current drive letter
 12986 00002B36 B43A                    		mov	ah,':'			; AX = "d:"
 12987                                  		;mov	byte [bp+1],2
 12988 00002B38 C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 12989                                  
 12990 00002B3C BF[7144]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 12991 00002B3F AB                      		stosw				; store "d:"
 12992                                  		
 12993 00002B40 C706[8C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12994                                  		;mov	byte [bp+4],2		
 12995 00002B46 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 12996                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 12997                                  		;mov	byte [bp+0],0		
 12998 00002B4A C6460000                		mov	byte [bp],0
 12999 00002B4E E89307                  		call	SETSTARS		; add wildcards
 13000                                  GOT2ARGS:
 13001                                  
 13002                                  	;	If destination pathname is "d:", add full wildcard filename
 13003                                  
 13004                                  		;cmp	byte [bp+1],2
 13005 00002B51 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13006 00002B55 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13007 00002B57 B03A                    		mov	al,':'
 13008 00002B59 3806[7244]              		cmp	byte [DESTBUF+1],al
 13009 00002B5D 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13010                                  		;or	byte [bp+4],2
 13011 00002B5F 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13012 00002B63 BF[7344]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13013                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13014                                  		;mov	byte [bp+0],0		
 13015 00002B66 C6460000                		mov	byte [bp],0
 13016 00002B6A E87707                  		call	SETSTARS		; add wildcards
 13017                                  
 13018                                  NOTSHORTDEST:
 13019                                  
 13020                                  	;	If destination pathname ends with "\", try to make
 13021                                  	;	sure it's "d:\".
 13022                                  
 13023                                  		;mov	di,[bp+2]
 13024 00002B6D 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13025 00002B70 803D00                  		cmp	byte [di],0
 13026 00002B73 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13027                                  
 13028 00002B75 BA[763B]                		mov	dx,BADCDPTR
 13029 00002B78 B03A                    		mov	al,':'
 13030 00002B7A 3845FE                  		cmp	[di-2],al
 13031 00002B7D 75A6                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13032                                  		;mov	byte [bp+0],2
 13033                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13034 00002B7F C6460002                		mov	byte [bp],2
 13035                                  		;or	byte [bp+4],6
 13036 00002B83 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13037                                  						  ;  path character
 13038 00002B87 E85A07                  		call	SETSTARS		; add wildcards
 13039                                  
 13040                                  CHKSWTCHES:
 13041                                  
 13042                                  	;	We have enough information about the destination for now.
 13043                                  
 13044                                  	;	Turn on verify if requested. Save the current verify flag.
 13045                                  
 13046 00002B8A BA[223A]                		mov	dx,BADPARMPTR
 13047 00002B8D A1[8E42]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13048                                  
 13049                                  		; MSDOS 3.3
 13050                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13051 00002B90 A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13052 00002B93 7590                    		jnz	short CERROR4J
 13053                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13054 00002B95 A91000                  		test	ax,SWITCHV ; 10h
 13055 00002B98 7414                    		jz	short NOVERIF		; no /v, no verify
 13056                                  
 13057 00002B9A B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13058 00002B9C CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13059                                  					; Return: AL = 00h if flag OFF
 13060                                  					; AL = 01h if flag ON
 13061 00002B9E 1E                      		push	ds
 13062 00002B9F 8E1E[7142]              		mov	ds,[RESSEG]
 13063 00002BA3 30E4                    		xor	ah,ah
 13064 00002BA5 A3F70B                  		mov	word [VERVAL],ax	; save current verify flag
 13065 00002BA8 1F                      		pop	ds
 13066 00002BA9 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13067 00002BAC CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13068                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13069                                  NOVERIF:
 13070                                  		;*	Scan for first source.
 13071                                  
 13072 00002BAE 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13073 00002BB0 BE8100                  		mov	si,81h			; SI = ptr into command line
 13074 00002BB3 8A1E[FF3E]              		mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13075                                  SCANFSRC:
 13076 00002BB7 BF[2E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13077 00002BBA E85707                  		call	CPARSE			; parse first source pathname
 13078 00002BBD F6C701                  		test	bh,1			; switch?
 13079 00002BC0 75F5                    		jnz	short SCANFSRC		; yes, try again
 13080 00002BC2 092E[8C42]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13081                                  
 13082                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13083                                  
 13084                                  		;test	bp,8
 13085 00002BC6 F7C50800                		test	bp,SWITCHB
 13086 00002BCA 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13087 00002BCC 803E[8642]00            		cmp	byte [CONCAT],0
 13088 00002BD1 7405                    		je	short NOSETCASC		; we're not concatenating
 13089                                  		;mov	byte [ASCII],4
 13090 00002BD3 C606[8E45]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13091                                  NOSETCASC:
 13092 00002BD8 E89703                  		call	SOURCE_SET		; set source variables
 13093 00002BDB E83B00                  		call	FRSTSRC			; set up first source copy
 13094 00002BDE E99000                  		jmp	FIRSTENT		; jump into the copy loop
 13095                                  
 13096                                  ; ---------------------------------------------------------------------------
 13097                                  
 13098                                  ENDCOPY:
 13099                                  
 13100                                  	;*	End of the road. Close destination, display # files
 13101                                  	;	copied (meaning # destinations), and go back to main
 13102                                  	;	transient COMMAND code.
 13103                                  
 13104 00002BE1 E8A802                  		call	CLOSEDEST
 13105                                  ENDCOPY2:
 13106 00002BE4 BA[FE38]                		mov	dx,COPIEDPTR
 13107 00002BE7 8B36[9942]              		mov	si,[FILECNT]
 13108 00002BEB 8936[5044]              		mov	[COPY_NUM],si
 13109 00002BEF E8E108                  		call	STD_PRINTF
 13110 00002BF2 E90FD5                  		jmp	TCOMMAND		; stack could be messed up
 13111                                  
 13112                                  ; ---------------------------------------------------------------------------
 13113                                  
 13114                                  SRCNONEXIST:
 13115                                  
 13116                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13117                                  	;	Otherwise, say 'file not found' and quit.
 13118                                  
 13119 00002BF5 803E[8642]00            		cmp	byte [CONCAT],0
 13120 00002BFA 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13121                                  
 13122                                  		; MSDOS 3.3
 13123 00002BFC BA[D444]                		mov	dx,SRCBUF
 13124 00002BFF 8916[4844]              		mov	[STRING_PTR_1],dx
 13125 00002C03 BA[2D37]                		mov	dx,STRINGBUF1PTR
 13126 00002C06 E8CA08                  		call	STD_PRINTF
 13127 00002C09 BA[F837]                		mov	dx,FNOTFOUNDPTR
 13128 00002C0C E9B104                  		jmp	COPYERR
 13129                                  
 13130                                  		; MSDOS 6.0
 13131                                  	;	Set up error message.
 13132                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13133                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13134                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13135                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13136                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13137                                  		;
 13138                                  		;jmp	CopErr			; print msg and clean up
 13139                                  
 13140                                  ; ---------------------------------------------------------------------------
 13141                                  
 13142                                  SOURCEPROC:
 13143                                  
 13144                                  	;*	Preparatory processing for each source file.
 13145                                  	;	Called at FrstSrc for first source file.
 13146                                  
 13147 00002C0F E86003                  		call	SOURCE_SET		; set source variables & ascii/binary
 13148 00002C12 803E[8642]00            		cmp	byte [CONCAT],0
 13149 00002C17 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13150                                  
 13151                                  ; ---------------------------------------------------------------------------
 13152                                  
 13153                                  FRSTSRC:
 13154 00002C19 31C0                    		xor	ax,ax
 13155 00002C1B A2[9042]                		mov	[CFLAG],al		; 'destination not created'
 13156 00002C1E A3[9442]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13157 00002C21 A2[9142]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13158                                  
 13159                                  LEAVECFLAG:
 13160 00002C24 8936[8545]              		mov	[SRCPT],si		; save cmd-line ptr
 13161 00002C28 BF[5341]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13162                                  						;   current dir
 13163 00002C2B BD[CF44]                		mov	bp,SRCVARS		; BP = base of source variables
 13164 00002C2E E8D705                  		call	BUILDPATH		; cd to source dir, figure
 13165                                  						;   out stuff about source
 13166 00002C31 8B36[D144]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13167 00002C35 C3                      		retn
 13168                                  
 13169                                  ; ---------------------------------------------------------------------------
 13170                                  
 13171                                  NEXTSRC:
 13172                                  
 13173                                  	;*	Next source. Come here after handling each pathname.
 13174                                  	;	We're done unless there are additional source pathnames
 13175                                  	;	to be appended.
 13176                                  	;
 13177                                  	;	Note that all files matching an ambiguous pathname
 13178                                  	;	are processed before coming here.
 13179                                  
 13180 00002C36 803E[8F45]00            		cmp	byte [PLUS],0
 13181 00002C3B 7502                    		jne	short MORECP		; copying "+" sources - keep going
 13182                                  
 13183                                  ENDCOPYJ2:
 13184 00002C3D EBA2                    		jmp	short ENDCOPY
 13185                                  
 13186                                  MORECP:
 13187 00002C3F 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13188 00002C41 8B36[8545]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13189 00002C45 8A1E[FF3E]              		mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13190                                  
 13191                                  SCANSRC:
 13192 00002C49 BF[2E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13193 00002C4C E8C506                  		call	CPARSE			; parse first source name
 13194 00002C4F 72EC                    		jb	short ENDCOPYJ2		; CR found - we're done
 13195                                  
 13196 00002C51 F6C780                  		test	bh,80h
 13197 00002C54 74E7                    		jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13198                                  
 13199 00002C56 F6C701                  		test	bh,1
 13200 00002C59 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13201                                  
 13202                                  	;	ScanBuf contains the next source pathname.
 13203                                  
 13204 00002C5B E8B1FF                  		call	SOURCEPROC		; prepare this source
 13205 00002C5E 803E[C643]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13206 00002C63 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13207 00002C65 C606[C743]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13208 00002C6A EB89                    		jmp	short SRCNONEXIST	; we know we won't find it
 13209                                  
 13210                                  NOSTAMP:
 13211 00002C6C C606[C743]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13212                                  
 13213                                  ; ---------------------------------------------------------------------------
 13214                                  
 13215                                  FIRSTENT:
 13216                                  
 13217                                  ;M047
 13218                                  ; The only case we need to worry about is when the source is wildcarded and
 13219                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13220                                  ;concatenation. We check for this case.
 13221                                  ;
 13222                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13223                                  ;right place to do this check.
 13224                                  
 13225                                  	;	This is where we enter the loop with the first source.
 13226                                  
 13227 00002C71 BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13228 00002C74 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13229 00002C77 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13230                                  					; DS:SI	-> string to parse
 13231                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13232                                  					; AL = bit mask	to control parsing
 13233 00002C79 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13234 00002C7C 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13235 00002C7E A1[D444]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13236 00002C81 80FC3A                  		cmp	ah,':'
 13237 00002C84 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13238 00002C86 B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13239                                  DRVSPEC1:
 13240 00002C88 0C20                    		or	al,20h			; AL = lowercase drive letter
 13241 00002C8A 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13242                                  		;mov	[5Ch],al
 13243 00002C8C A25C00                  		mov	[FCB],al		; put drive id in FCB
 13244                                  
 13245                                  	;	FCB contains drive and filename to search.
 13246                                  		
 13247 00002C8F B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13248 00002C91 E80701                  		call	SEARCH
 13249                                  SRCHDONE:
 13250 00002C94 9C                      		pushf				; save flags from Search
 13251 00002C95 E8F6EB                  		call	RESTUDIR1		; restore users current directory
 13252 00002C98 9D                      		popf				; restore flags from search
 13253 00002C99 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13254 00002C9B E957FF                  		jmp	SRCNONEXIST		; didn't find the source
 13255                                  
 13256                                  NEXTAMBIG0:
 13257 00002C9E 30C0                    		xor	al,al
 13258 00002CA0 8606[9642]              		xchg	al,[FRSTSRCH]
 13259 00002CA4 08C0                    		or	al,al
 13260 00002CA6 740B                    		jz	short NEXTAMBIG
 13261                                  SETNMEL:
 13262 00002CA8 B90C00                  		mov	cx,12
 13263 00002CAB BF[B043]                		mov	di,SDIRBUF
 13264 00002CAE BE[6A43]                		mov	si,DIRBUF
 13265 00002CB1 F3A4                    		rep movsb			; save very first source name
 13266                                  NEXTAMBIG:
 13267 00002CB3 30C0                    		xor	al,al
 13268 00002CB5 A2[8945]                		mov	[NOWRITE],al		; turn off nowrite
 13269 00002CB8 8B3E[D144]              		mov	di,[SRCTAIL]
 13270 00002CBC BE[6B43]                		mov	si,DIRBUF+1
 13271 00002CBF E8D6EC                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13272                                  MELDO:
 13273 00002CC2 803E[8642]00            		cmp	byte [CONCAT],0
 13274 00002CC7 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13275 00002CC9 F606[D344]02            		test	byte [SRCINFO],2	; wildcard - show name
 13276 00002CCE 7410                    		jz	short DOREAD
 13277                                  SHOWCPNAM:
 13278 00002CD0 BA[D444]                		mov	dx,SRCBUF
 13279 00002CD3 8916[4E44]              		mov	[STRING_PTR_2],dx
 13280 00002CD7 BA[3F37]                		mov	dx,STRINGBUF2PTR
 13281 00002CDA E8F607                  		call	STD_PRINTF
 13282 00002CDD E88CEC                  		call	CRLF2
 13283                                  DOREAD:
 13284 00002CE0 E8C900                  		call	DOCOPY
 13285 00002CE3 803E[8642]00            		cmp	byte [CONCAT],0
 13286 00002CE8 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13287                                  
 13288 00002CEA E89F01                  		call	CLOSEDEST		; close current destination
 13289 00002CED 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13290                                  
 13291 00002CEF C606[9042]00            		mov	byte [CFLAG],0		; 'destination not created'
 13292                                  NODCLOSE:
 13293 00002CF4 803E[8642]00            		cmp	byte [CONCAT],0		
 13294 00002CF9 740C                    		jz	short NOFLUSH
 13295                                  
 13296                                  ;	Concatenating - flush output between source files so LostErr
 13297                                  ;	stuff works correctly.
 13298                                  
 13299                                  		;invoke	FlshFil  ; MSDOS 6.0
 13300                                  
 13301 00002CFB E8AA02                  		call	FLUSHFIL ; MSDOS 3.3
 13302 00002CFE F606[CC44]FF            		test	byte [MELCOPY],0FFh
 13303 00002D03 7402                    		jz	short NOFLUSH
 13304 00002D05 EB0C                    		jmp	short DOMELCOPY
 13305                                  NOFLUSH:
 13306 00002D07 E88500                  		call	SEARCHNEXT		; try next match
 13307 00002D0A 755F                    		jnz	short NEXTSRCJ		; not found - finished with 
 13308                                  						;   this source spec
 13309 00002D0C C606[9142]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13310                                  
 13311 00002D11 EBA0                    		jmp	short NEXTAMBIG		; do next ambig match
 13312                                  
 13313                                  DOMELCOPY:
 13314 00002D13 803E[CC44]FF            		cmp	byte [MELCOPY],0FFh
 13315 00002D18 740D                    		je	short CONTMEL
 13316 00002D1A 8B36[8545]              		mov	si,[SRCPT]
 13317 00002D1E 8936[CD44]              		mov	[MELSTART],si
 13318 00002D22 C606[CC44]FF            		mov	byte [MELCOPY],0FFh
 13319                                  
 13320                                  CONTMEL:
 13321 00002D27 31ED                    		xor	bp,bp
 13322 00002D29 8B36[8545]              		mov	si,[SRCPT]
 13323 00002D2D 8A1E[FF3E]              		mov	bl,[PLUS_CHR]
 13324                                  SCANSRC2:
 13325 00002D31 BF[2E45]                		mov	di,SCANBUF
 13326 00002D34 E8DD05                  		call	CPARSE
 13327 00002D37 F6C780                  		test	bh,80h
 13328 00002D3A 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13329 00002D3C F6C701                  		test	bh,1
 13330 00002D3F 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13331 00002D41 E8CBFE                  		call	SOURCEPROC
 13332 00002D44 E847EB                  		call	RESTUDIR1
 13333 00002D47 BF[EB42]                		mov	di,DESTFCB2
 13334 00002D4A B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13335 00002D4D CD21                    		int	21h		; DOS -	PARSE FILENAME
 13336                                  					; DS:SI	-> string to parse
 13337                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13338                                  					; AL = bit mask	to control parsing
 13339 00002D4F BB[B143]                		mov	bx,SDIRBUF+1
 13340 00002D52 BE[EC42]                		mov	si,DESTFCB2+1
 13341 00002D55 8B3E[D144]              		mov	di,[SRCTAIL]
 13342                                  
 13343 00002D59 E87B04                  		call	BUILDNAME
 13344                                  
 13345 00002D5C 803E[8642]00            		cmp	byte [CONCAT],0
 13346 00002D61 7405                    		je	short MELDOJ		; not concatenating - continue
 13347                                  
 13348                                  	;	Yes, turn off nowrite because this part of the code 
 13349                                  	;	is only reached after the first file has been dealt with.
 13350                                  
 13351 00002D63 C606[8945]00            		mov	byte [NOWRITE],0
 13352                                  MELDOJ:
 13353 00002D68 E957FF                  		jmp	MELDO
 13354                                  
 13355                                  NEXTSRCJ:
 13356 00002D6B E9C8FE                  		jmp	NEXTSRC
 13357                                  
 13358                                  NEXTMEL:
 13359 00002D6E E81B01                  		call	CLOSEDEST
 13360 00002D71 31C0                    		xor	ax,ax
 13361 00002D73 A2[9042]                		mov	[CFLAG],al
 13362 00002D76 A3[9442]                		mov	[NXTADD],ax
 13363 00002D79 A2[9142]                		mov	[SPECDRV],al
 13364 00002D7C 8B36[CD44]              		mov	si,[MELSTART]
 13365 00002D80 8936[8545]              		mov	[SRCPT],si
 13366 00002D84 E80800                  		call	SEARCHNEXT
 13367 00002D87 7403                    		jz	short SETNMELJ
 13368 00002D89 E958FE                  		jmp	ENDCOPY2
 13369                                  
 13370                                  SETNMELJ:
 13371 00002D8C E919FF                  		jmp	SETNMEL
 13372                                  
 13373                                  ; ---------------------------------------------------------------------------
 13374                                  
 13375                                  SEARCHNEXT:
 13376 00002D8F B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13377 00002D91 F606[D344]02            		test	byte [SRCINFO],2
 13378 00002D96 7503                    		jnz	short SEARCH		; do search-next if ambig
 13379 00002D98 08E4                    		or	ah,ah			; reset zero flag
 13380 00002D9A C3                      		retn
 13381                                  
 13382                                  ; ---------------------------------------------------------------------------
 13383                                  
 13384                                  SEARCH:
 13385 00002D9B 50                      		push	ax
 13386 00002D9C B41A                    		mov	ah,SET_DMA ; 1Ah
 13387 00002D9E BA[6A43]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13388 00002DA1 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13389                                  				; DS:DX	-> disk	transfer buffer
 13390 00002DA3 58                      		pop	ax		; restore search first/next command
 13391 00002DA4 BA5C00                  		mov	dx,FCB ; 5Ch
 13392 00002DA7 CD21                    		int	21h		; Do the search
 13393 00002DA9 08C0                    		or	al,al
 13394 00002DAB C3                      		retn
 13395                                  
 13396                                  ; ---------------------------------------------------------------------------
 13397                                  
 13398                                  DOCOPY:
 13399 00002DAC BE[D444]                		mov	si,SRCBUF	; do name translate of source
 13400 00002DAF BF[9F3F]                		mov	di,SRCXNAME	; save for name comparison
 13401 00002DB2 B460                    		mov	ah,XNAMETRANS ; 60h
 13402 00002DB4 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13403                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13404                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13405 00002DB6 C606[8442]00            		mov	byte [RDEOF],0	; no EOF yet
 13406                                  
 13407                                  		; MSDOS 6.0
 13408                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13409                                  ;M046
 13410                                  ; For reads, the sharing mode should be deny none so that any process can
 13411                                  ;open this file again in any other sharing mode. This is mainly to allow
 13412                                  ;multiple command.com's to access the same file without getting sharing
 13413                                  ;violations
 13414                                  ;
 13415                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
 13416                                  		;xor	cx,cx				; no special files
 13417                                  		;mov	dx,READ_OPEN_FLAG		; set up open flags
 13418                                  		;int	21h
 13419                                  		;
 13420                                  		;jnc	OpenOk
 13421                                  
 13422                                  	;	Bogosity:  IBM wants us to issue Access Denied in this case.
 13423                                  	;	They asked for it...
 13424                                  
 13425                                  		;jmp	short Error_On_Source 		;AC022; clean up and exit
 13426                                  
 13427                                  		; MSDOS 3.3
 13428 00002DBB BA[D444]                		mov	dx,SRCBUF
 13429 00002DBE B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13430 00002DC1 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13431                                  					; DS:DX	-> ASCIZ filename
 13432                                  					; AL = access mode
 13433                                  					; 0 - read
 13434 00002DC3 7311                    		jnc	short OPENOK
 13435 00002DC5 E802F1                  		call	GET_EXT_ERR_NUMBER
 13436 00002DC8 9C                      		pushf
 13437 00002DC9 83F841                  		cmp	ax,65
 13438 00002DCC 7506                    		jnz	short DOCOPY_ERR
 13439 00002DCE BA[1D38]                		mov	dx,ACCDENPTR
 13440 00002DD1 E8FF06                  		call	STD_PRINTF
 13441                                  DOCOPY_ERR:
 13442 00002DD4 9D                      		popf
 13443 00002DD5 C3                      		retn
 13444                                  
 13445                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13446                                  OPENOK:
 13447 00002DD6 89C3                    		mov	bx,ax
 13448 00002DD8 891E[2B45]              		mov	[SRCHAND],bx		; save handle
 13449 00002DDC B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13450 00002DDF CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13451                                  					; BX = file handle
 13452                                  
 13453                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13454                                  
 13455 00002DE1 8916[9145]              		mov	[CPDATE],dx		; save date
 13456 00002DE5 890E[9345]              		mov	[CPTIME],cx		; save time
 13457                                  
 13458                                  		; MSDOS 6.0
 13459                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13460                                  
 13461                                  ;Error_On_Source:				;AN022; we have a BAD error
 13462                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13463                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13464                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13465                                  		;invoke	Std_EprintF		;AN022; print it
 13466                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13467                                  		;je	No_Close_Src		;AN022; no - don't close
 13468                                  		;call	CloseSrc		;AN022; clean up
 13469                                  ;No_Close_Src:					;AN022;
 13470                                  		;cmp	CFlag,0			;AN022; was destination created?
 13471                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13472                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13473                                  ;EndCopyJ3:					;AN022;
 13474                                  		;jmp	EndCopy2		;AN022;
 13475                                  ;No_Copy_Xa:
 13476                                  		;mov	bx,SrcHand		;AN022; get handle back
 13477                                  
 13478                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13479 00002DE9 B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13480 00002DEC CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13481                                  					; BX = file or device handle
 13482 00002DEE 80E280                  		and	dl,devid_ISDEV ; 80h
 13483 00002DF1 8816[2D45]              		mov	[SRCISDEV],dl		; set source info
 13484 00002DF5 740D                    		jz	short COPYLP		; source not a device
 13485 00002DF7 803E[8A45]00            		cmp	byte [BINARY],0
 13486 00002DFC 7406                    		je	short COPYLP		; ascii device ok
 13487 00002DFE BA[FB3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13488 00002E01 E9BC02                  		jmp	COPYERR
 13489                                  
 13490                                  COPYLP:
 13491 00002E04 8B1E[2B45]              		mov	bx,[SRCHAND]
 13492 00002E08 8B0E[9242]              		mov	cx,[BYTCNT]
 13493 00002E0C 8B16[9442]              		mov	dx,[NXTADD]
 13494 00002E10 29D1                    		sub	cx,dx			; compute available space
 13495 00002E12 750E                    		jnz	short GOTROOM
 13496                                  		;invoke	FlshFil   ; MSDOS 6.0
 13497 00002E14 E89101                  		call	FLUSHFIL  ; MSDOS 3.3
 13498 00002E17 803E[8D45]00            		cmp	byte [TERMREAD],0
 13499 00002E1C 7565                    		jne	short CLOSESRC		; give up
 13500 00002E1E 8B0E[9242]              		mov	cx,[BYTCNT]
 13501                                  GOTROOM:
 13502 00002E22 1E                      		push	ds
 13503 00002E23 8E1E[7342]              		mov	ds,[TPA]
 13504 00002E27 B43F                    		mov	ah,READ ; 3Fh
 13505 00002E29 CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13506                                  					; BX = file handle,CX = number	of bytes to read
 13507                                  					; DS:DX	-> buffer
 13508 00002E2B 1F                      		pop	ds
 13509 00002E2C 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13510                                  		;jc	Error_On_Source ; MSDOS 6.0
 13511 00002E2E 89C1                    		mov	cx,ax			; get count
 13512 00002E30 E351                    		jcxz	CLOSESRC		; no more to read
 13513 00002E32 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13514 00002E37 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13515 00002E39 803E[8E45]00            		cmp	byte [ASCII],0
 13516 00002E3E 741B                    		je	short BINREAD
 13517                                  NOTESTA:
 13518 00002E40 89CA                    		mov	dx,cx
 13519 00002E42 8B3E[9442]              		mov	di,[NXTADD]
 13520 00002E46 B01A                    		mov	al,1Ah
 13521 00002E48 06                      		push	es
 13522 00002E49 8E06[7342]              		mov	es,[TPA]		; scan for EOF
 13523 00002E4D F2AE                    		repne scasb
 13524 00002E4F 07                      		pop	es
 13525 00002E50 7505                    		jnz	short USEALL
 13526 00002E52 FE06[8442]              		inc	byte [RDEOF]
 13527 00002E56 41                      		inc	cx
 13528                                  USEALL:
 13529 00002E57 29CA                    		sub	dx,cx
 13530 00002E59 89D1                    		mov	cx,dx
 13531                                  BINREAD:
 13532 00002E5B 030E[9442]              		add	cx,[NXTADD]
 13533 00002E5F 890E[9442]              		mov	[NXTADD],cx
 13534 00002E63 3B0E[9242]              		cmp	cx,[BYTCNT]		; is buffer full?
 13535 00002E67 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13536                                  		;invoke	FlshFil
 13537 00002E69 E83C01                  		call	FLUSHFIL
 13538 00002E6C 803E[8D45]00            		cmp	byte [TERMREAD],0
 13539 00002E71 7510                    		jne	short CLOSESRC		; give up
 13540 00002E73 EB8F                    		jmp	short COPYLP
 13541                                  TESTDEV:
 13542 00002E75 803E[2D45]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13543 00002E7A 7407                    		je	short CLOSESRC
 13544 00002E7C 803E[8442]00            		cmp	byte [RDEOF],0
 13545 00002E81 7481                    		je	short COPYLP		; on device, go till ^Z
 13546                                  CLOSESRC:
 13547 00002E83 8B1E[2B45]              		mov	bx,[SRCHAND]
 13548 00002E87 B43E                    		mov	ah,CLOSE ; 3Eh
 13549 00002E89 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13550                                  					; BX = file handle
 13551                                  CLOSESRCDEST_RETN:
 13552 00002E8B C3                      		retn
 13553                                  
 13554                                  ; ---------------------------------------------------------------------------
 13555                                  
 13556                                  CLOSEDEST:
 13557                                  
 13558                                  	;	We are called to close the destination.
 13559                                  	;	We need to note whether or not there is any internal data left
 13560                                  	;	to be flushed out.
 13561                                  
 13562 00002E8C 803E[9142]00            		cmp	byte [DESTCLOSED],0
 13563 00002E91 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13564 00002E93 A0[8C42]                		mov	al,byte [DESTSWITCH]
 13565 00002E96 E86602                  		call	SETASC			; check for b or a switch
 13566 00002E99 7434                    		jz	short BINCLOS		;   on destination
 13567 00002E9B 8B1E[9442]              		mov	bx,[NXTADD]
 13568                                  ;
 13569                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13570                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13571                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13572                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13573                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13574                                  ;performance overhead on single ASCII file copies which now always involve
 13575                                  ;2 writes instead of 1 before. Is this really that important?
 13576                                  ;
 13577                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13578                                  ;M048;	jne	PutZ
 13579                                  
 13580                                  		; MSDOS 3.3
 13581 00002E9F 3B1E[9242]              		cmp	bx,[BYTCNT]	; is memory full?
 13582 00002EA3 7509                    		jne	short PUTZ
 13583                                  
 13584 00002EA5 E8F300                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13585 00002EA8 7402                    		jz	short NOCONC
 13586                                  CONCHNG:
 13587 00002EAA F9                      		stc
 13588 00002EAB C3                      		retn
 13589                                  
 13590                                  NOCONC:	
 13591 00002EAC 31DB                    		xor	bx,bx
 13592                                  PUTZ:
 13593 00002EAE 1E                      		push	ds
 13594 00002EAF 8E1E[7342]              		mov	ds,[TPA]
 13595 00002EB3 C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13596 00002EB7 1F                      		pop	ds
 13597 00002EB8 FF06[9442]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13598 00002EBC C606[8945]00            		mov	byte [NOWRITE],0
 13599 00002EC1 A1[8B45]                		mov	ax,[WRITTEN]
 13600 00002EC4 0306[9442]              		add	ax,[NXTADD]
 13601 00002EC8 7205                    		jc	short BINCLOS	; > 1
 13602 00002ECA 83F801                  		cmp	ax,1
 13603 00002ECD 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13604                                  BINCLOS:
 13605 00002ECF E8C900                  		call	TRYFLUSH
 13606 00002ED2 75D6                    		jnz	short CONCHNG
 13607                                  
 13608 00002ED4 803E[8B45]00            		cmp	byte [WRITTEN],0
 13609                                  FORGETITJ:
 13610 00002ED9 747D                    		jz	short FORGETIT	; never wrote nothing
 13611                                  NO_FORGET:				; wrote something
 13612 00002EDB 8B1E[C844]              		mov	bx,[DESTHAND]
 13613 00002EDF 8B0E[9345]              		mov	cx,[CPTIME]
 13614 00002EE3 8B16[9145]              		mov	dx,[CPDATE]
 13615 00002EE7 803E[8745]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13616 00002EEC 7431                    		je	short DODCLOSE	; if no, copy date & time
 13617 00002EEE B42C                    		mov	ah,GET_TIME ; 2Ch
 13618 00002EF0 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13619                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13620                                  					; DL = hundredths of seconds
 13621 00002EF2 D0E1                    		shl	cl,1
 13622 00002EF4 D0E1                    		shl	cl,1		; left justify min in cl
 13623 00002EF6 D1E1                    		shl	cx,1
 13624 00002EF8 D1E1                    		shl	cx,1
 13625 00002EFA D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13626 00002EFC D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13627 00002EFE 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13628 00002F00 51                      		push	cx		; save packed time
 13629 00002F01 B42A                    		mov	ah,GET_DATE ; 2Ah
 13630 00002F03 CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13631                                  					; Return: DL = day,DH = month,	CX = year
 13632                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13633 00002F05 81E9BC07                		sub	cx,1980
 13634 00002F09 86E9                    		xchg	ch,cl
 13635 00002F0B D1E1                    		shl	cx,1		; year to high 7 bits
 13636 00002F0D D0E6                    		shl	dh,1		; month to high 3 bits
 13637 00002F0F D0E6                    		shl	dh,1
 13638 00002F11 D0E6                    		shl	dh,1
 13639 00002F13 D0E6                    		shl	dh,1
 13640 00002F15 D0E6                    		shl	dh,1		; most sig bit of month in carry
 13641 00002F17 80D500                  		adc	ch,0		; put that bit next to year
 13642 00002F1A 08F2                    		or	dl,dh		; or low three of month into day
 13643 00002F1C 88EE                    		mov	dh,ch		; get year and high bit of month
 13644 00002F1E 59                      		pop	cx
 13645                                  DODCLOSE:
 13646 00002F1F 83FB00                  		cmp	bx,0
 13647 00002F22 7E2A                    		jle	short CLOSEDONE
 13648 00002F24 B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13649 00002F27 CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13650                                  					; BX = file handle,CX = time to be set
 13651                                  					; DX = date to be set
 13652                                  		; MSDOS 6.0
 13653                                  		;jc	Cleanup_Err	;AN022; handle error
 13654                                  
 13655                                  	;	See if the destination has *anything* in it.
 13656                                  	;	If not, just close and delete it.
 13657                                  
 13658 00002F29 B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13659 00002F2C 31D2                    		xor	dx,dx
 13660 00002F2E 89D1                    		mov	cx,dx
 13661 00002F30 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13662                                  					; AL = method: offset from end of file
 13663                                  	;	DX:AX is file size
 13664                                  
 13665 00002F32 09C2                    		or	dx,ax
 13666 00002F34 9C                      		pushf
 13667 00002F35 B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13668 00002F38 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13669                                  					; BX = file or device handle
 13670 00002F3A 52                      		push	dx			; save them away
 13671 00002F3B B43E                    		mov	ah,CLOSE ; 3Eh
 13672 00002F3D CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13673                                  					; BX = file handle
 13674 00002F3F 5A                      		pop	dx
 13675                                  
 13676                                  		; MSDOS 6.0
 13677                                  		;jnc	Close_Cont	;AN022; handle error on close
 13678                                  		;popf			;AN022; get the flags back
 13679                                  ;Cleanup_Err: 				;AN022;
 13680                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13681                                  		;call	DestDelete	;AN022; attempt to delete the target
 13682                                  		;jmp	short FileClosed ;AN022; close the file
 13683                                  ;Close_Cont:				;AN022; no error - co
 13684                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13685 00002F40 9D                      		popf
 13686 00002F41 750B                    		jnz	short CLOSEDONE
 13687 00002F43 F7C28000                		test	dx,80h		; is the destination a device?
 13688 00002F47 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13689 00002F49 E81E00                  		call	DESTDELETE
 13690 00002F4C EB04                    		jmp	short FILECLOSED
 13691                                  CLOSEDONE:
 13692 00002F4E FF06[9942]              		inc	word [FILECNT]
 13693                                  FILECLOSED:
 13694 00002F52 FE06[9142]              		inc	byte [DESTCLOSED]
 13695                                  RET50:
 13696 00002F56 F8                      		clc
 13697 00002F57 C3                      		retn
 13698                                  
 13699                                  FORGETIT:
 13700 00002F58 8B1E[C844]              		mov	bx,[DESTHAND]
 13701 00002F5C E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13702 00002F5F E80800                  		call	DESTDELETE
 13703 00002F62 C706[9942]0000          		mov	word [FILECNT],0 ; no files transferred
 13704 00002F68 EBEC                    		jmp	short RET50
 13705                                  
 13706                                  ; ---------------------------------------------------------------------------
 13707                                  
 13708                                  DESTDELETE:
 13709 00002F6A BA[7144]                		mov	dx,DESTBUF
 13710 00002F6D B441                    		mov	ah,UNLINK ; 41h
 13711 00002F6F CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13712                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13713                                  				;		(no wildcards allowed)
 13714 00002F71 C3                      		retn
 13715                                  
 13716                                  ; ---------------------------------------------------------------------------
 13717                                  
 13718                                  SOURCE_SET:
 13719 00002F72 56                      		push	si
 13720 00002F73 A1[9745]                		mov	ax,[STARTEL]
 13721 00002F76 BE[2E45]                		mov	si,SCANBUF	; adjust to copy
 13722 00002F79 29F0                    		sub	ax,si
 13723 00002F7B BF[D444]                		mov	di,SRCBUF
 13724 00002F7E 01F8                    		add	ax,di
 13725 00002F80 A3[D144]                		mov	[SRCTAIL],ax
 13726 00002F83 880E[D044]              		mov	[SRCSIZ],cl	; save its size
 13727 00002F87 41                      		inc	cx		; include the nul
 13728 00002F88 F3A4                    		rep movsb		; save this source
 13729 00002F8A 883E[D344]              		mov	[SRCINFO],bh	; save info about it
 13730 00002F8E 5E                      		pop	si
 13731 00002F8F 89E8                    		mov	ax,bp		; switches so far
 13732 00002F91 E86B01                  		call	SETASC		; set a,b switches accordingly
 13733 00002F94 E813EB                  		call	SWITCH		; get any more switches on this arg
 13734 00002F97 E86501                  		call	SETASC		; set
 13735 00002F9A C3                      		retn
 13736                                  
 13737                                  ; =============== S U B	R O U T	I N E =======================================
 13738                                  
 13739                                  ; MSDOS 6.0
 13740                                  
 13741                                  ;****************************************************************
 13742                                  ;*
 13743                                  ;* ROUTINE:	CleanupErr
 13744                                  ;*
 13745                                  ;* FUNCTION:	Issues extended error message for destination
 13746                                  ;*		if not alreay issued
 13747                                  ;*
 13748                                  ;* INPUT:	return from INT 21
 13749                                  ;*
 13750                                  ;* OUTPUT:	none
 13751                                  ;*
 13752                                  ;****************************************************************
 13753                                  
 13754                                  ;CleanupErr	proc	near		;AN022;
 13755                                  ;
 13756                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13757                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13758                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13759                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13760                                  ;					;AN022; get address of failed string
 13761                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13762                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13763                                  ;
 13764                                  ;CleanupErr_Cont:			;AN022;
 13765                                  ;	ret				;AN022; return to caller
 13766                                  ;
 13767                                  ;CleanupErr	endp			;AN022;
 13768                                  
 13769                                  ;============================================================================
 13770                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13771                                  ;============================================================================
 13772                                  ; 01/10/2018 - Retro DOS v3.0
 13773                                  
 13774                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13775                                  
 13776                                  ; =============== S U B	R O U T	I N E =======================================
 13777                                  
 13778                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13779                                  ;
 13780                                  ;	EXIT	ZR set if concatenate flag unchanged
 13781                                  
 13782                                  TRYFLUSH:
 13783 00002F9B A0[8642]                		mov	al,[CONCAT]
 13784 00002F9E 50                      		push	ax
 13785 00002F9F E80600                  		call	FLUSHFIL
 13786 00002FA2 58                      		pop	ax
 13787 00002FA3 3A06[8642]              		cmp	al,[CONCAT]
 13788 00002FA7 C3                      		retn
 13789                                  
 13790                                  ; =============== S U B	R O U T	I N E =======================================
 13791                                  
 13792                                  FLUSHFIL:
 13793 00002FA8 A0[8A45]                		mov	al,[BINARY]
 13794 00002FAB 8A26[8E45]              		mov	ah,[ASCII]
 13795 00002FAF 50                      		push	ax
 13796 00002FB0 E80900                  		call	FLSHFIL
 13797 00002FB3 58                      		pop	ax
 13798 00002FB4 8826[8E45]              		mov	[ASCII],ah
 13799 00002FB8 A2[8A45]                		mov	[BINARY],al
 13800 00002FBB C3                      		retn
 13801                                  
 13802                                  ; =============== S U B	R O U T	I N E =======================================
 13803                                  
 13804                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13805                                  ;
 13806                                  ;	Inputs:
 13807                                  ;	  [NXTADD] = No. of bytes to write
 13808                                  ;	  [CFLAG] <> 0 if file has been created
 13809                                  ;	Outputs:
 13810                                  ;	  [NXTADD] = 0
 13811                                  
 13812                                  FLSHFIL:
 13813 00002FBC C606[8D45]00            		mov	byte [TERMREAD],0
 13814 00002FC1 803E[9042]00            		cmp	byte [CFLAG],0
 13815 00002FC6 7403                    		jz	short NOTEXISTS
 13816 00002FC8 E98300                  		jmp	EXISTS
 13817                                  
 13818                                  NOTEXISTS:
 13819 00002FCB E84B01                  		call	BUILDDEST	; find out all about the destination
 13820 00002FCE E82F03                  		call	COMPNAME	; source and dest. the same?
 13821 00002FD1 7516                    		jnz	short PROCDEST	; if not, go ahead
 13822 00002FD3 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13823 00002FD8 750F                    		jnz	short PROCDEST	; same name on device ok
 13824 00002FDA 803E[8642]00            		cmp	byte [CONCAT],0	; concatenation?
 13825 00002FDF BA[9438]                		mov	dx,OVERWRPTR
 13826 00002FE2 745E                    		je	short COPERR	; not concatenating - overwrite error
 13827                                  		
 13828                                  ;No_Concat_Err:	; concatenating
 13829 00002FE4 C606[8945]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 13830                                  PROCDEST:
 13831                                  		; MSDOS 6.0
 13832                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13833                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 13834                                  ;M046
 13835                                  ; For writes, we want to deny writes by anyone else at the same time that we
 13836                                  ;are writing to it. For instance, on a network, 2 workstations could try
 13837                                  ;writing to the same file. Also, because we opened the source file with
 13838                                  ;DENY NONE, it is fine if the source and destination files are the same as
 13839                                  ;would happen when we append to an existing file.
 13840                                  ;
 13841                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 13842                                  		;xor	cx,cx				; no special files
 13843                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 13844                                  		;
 13845                                  		;cmp	NoWrite,0
 13846                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 13847                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 13848                                  
 13849 00002FE9 B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 13850 00002FEC 803E[8945]00            		cmp	byte [NOWRITE],0
 13851 00002FF1 7504                    		jne	short DODESTOPEN
 13852 00002FF3 B43C                    		mov	ah,CREAT ; 3Ch
 13853 00002FF5 31C9                    		xor	cx,cx
 13854                                  DODESTOPEN:
 13855 00002FF7 BA[7144]                		mov	dx,DESTBUF
 13856 00002FFA CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 13857                                  				; CX = attributes for file
 13858                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 13859                                  		
 13860                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 13861                                  		;mov	dx,FULDIRPTR
 13862                                  		;call	GET_EXT_ERR_NUMBER
 13863                                  		;jc	short COPERR
 13864                                  
 13865                                  		; 01/10/2018
 13866                                  		;jnc	short DEST_OPEN_OKAY
 13867                                  		
 13868                                  		;mov	dx,FULDIRPTR
 13869                                  		;call	GET_EXT_ERR_NUMBER
 13870                                  		;jmp	short COPERR
 13871                                  
 13872 00002FFC 723E                    		jc	short DEST_OPEN_ERROR
 13873                                  
 13874                                  ;DEST_OPEN_OKAY:
 13875 00002FFE A3[C844]                		mov	[DESTHAND],ax	; save handle
 13876 00003001 C606[9042]01            		mov	byte [CFLAG],1	; destination now exists
 13877 00003006 89C3                    		mov	bx,ax
 13878 00003008 B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 13879 0000300B CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 13880                                  				   	; BX = file or device handle
 13881                                  
 13882 0000300D 8816[CA44]              		mov	[DESTISDEV],dl	; set dest info
 13883                                  		;test	dl,80h
 13884 00003011 F6C280                  		test	dl,devid_ISDEV
 13885 00003014 7438                    		jz	short EXISTS	; Dest not a device
 13886                                  
 13887                                  ;	Destination is device.
 13888                                  
 13889 00003016 A0[8C42]                		mov	al,byte [DESTSWITCH]
 13890                                  		;and	al,0Ch
 13891 00003019 240C                    		and	al,SWITCHA+SWITCHB
 13892 0000301B 7509                    		jnz	short TESTBOTH
 13893 0000301D A0[8E45]                		mov	al,[ASCII]	; neither set, use current setting
 13894 00003020 0A06[8A45]              		or	al,[BINARY]
 13895 00003024 741E                    		jz	short EXSETA	; neither set, default to ascii
 13896                                  TESTBOTH:
 13897 00003026 7A26                    		jpe	short EXISTS	; both are set, ignore
 13898                                  		;test	al,8
 13899 00003028 A808                    		test	al,SWITCHB
 13900 0000302A 7422                    		jz	short EXISTS
 13901                                  		;mov	ax,(IOCTL shl 8) or 1
 13902 0000302C B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 13903 0000302F 30F6                    		xor	dh,dh
 13904                                  		;or	dl,20h
 13905 00003031 80CA20                  		or	dl,devid_RAW
 13906 00003034 8816[CA44]              		mov	[DESTISDEV],dl
 13907 00003038 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 13908                                  				; BX = device handle,DH = 0
 13909                                  				; DL = device information to set (bits 0-7 from	function 0)
 13910 0000303A EB12                    		jmp	short EXISTS
 13911                                  
 13912                                  		; 01/10/2018 - Retro DOS v3.0 modification
 13913                                  DEST_OPEN_ERROR:
 13914 0000303C BA[6E38]                		mov	dx,FULDIRPTR
 13915 0000303F E888EE                  		call	GET_EXT_ERR_NUMBER
 13916                                  COPERR:
 13917 00003042 EB7C                    		jmp	short COPYERR
 13918                                  
 13919                                  EXSETA:
 13920                                  
 13921                                  ;	What we read in may have been in binary mode, flag zapped write OK
 13922                                  
 13923                                  		;mov	byte [ASCII],4
 13924 00003044 C606[8E45]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 13925                                  		;or	byte [INEXACT],4
 13926 00003049 800E[8745]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 13927                                  EXISTS:
 13928 0000304E 803E[8945]00            		cmp	byte [NOWRITE],0
 13929 00003053 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 13930 00003055 803E[C743]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 13931 0000305A 741D                    		jz	short NOCHECKING
 13932 0000305C E8A102                  		call	COMPNAME		; source and dest. the same?
 13933 0000305F 7518                    		jnz	short NOCHECKING	; if not, go ahead
 13934 00003061 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13935 00003066 7511                    		jne	short NOCHECKING	; same name on device ok
 13936                                  
 13937                                  ;	At this point we know in append (would have gotten overwrite error
 13938                                  ;	on first destination create otherwise), and user trying to specify
 13939                                  ;	destination which has been scribbled already (if dest had been named
 13940                                  ;	first, NoWrite would be set).
 13941                                  
 13942 00003068 BA[C038]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 13943                                  		;invoke	Std_EprintF		;ac022;
 13944 0000306B E86504                  		call	STD_PRINTF
 13945 0000306E C706[9442]0000          		mov	word [NXTADD],0		; set return
 13946 00003074 FE06[8D45]              		inc	byte [TERMREAD]		; tell read to give up
 13947                                  RET60:
 13948 00003078 C3                      		retn
 13949                                  
 13950                                  NOCHECKING:
 13951 00003079 8B1E[C844]              		mov	bx,[DESTHAND]		; get handle
 13952 0000307D 31C9                    		xor	cx,cx
 13953 0000307F 870E[9442]              		xchg	cx,[NXTADD]
 13954 00003083 E3F3                    		jcxz	RET60			; if nothing to write, forget it
 13955 00003085 FF06[8B45]              		inc	word [WRITTEN]		; flag that we wrote something
 13956 00003089 803E[8945]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 13957 0000308E 755A                    		jnz	short SEEKEND
 13958 00003090 31D2                    		xor	dx,dx
 13959 00003092 1E                      		push	ds
 13960 00003093 8E1E[7342]              		mov	ds,[TPA]
 13961 00003097 B440                    		mov	ah,WRITE ; 40h
 13962 00003099 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 13963                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 13964 0000309B 1F                      		pop	ds
 13965 0000309C BA[3938]                		mov	dx,NOSPACEPTR
 13966 0000309F 7222                    		jc	short COPERRP		; failure
 13967 000030A1 29C1                    		sub	cx,ax
 13968 000030A3 74D3                    		jz	short RET60		; wrote all supposed to
 13969 000030A5 F606[CA44]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 13970 000030AA 7414                    		jz	short COPYERR		; is a file, error
 13971 000030AC F606[CA44]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 13972 000030B1 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 13973 000030B3 803E[8745]00            		cmp	byte [INEXACT],0
 13974 000030B8 75BE                    		jnz	short RET60		; inexact so ok
 13975 000030BA 49                      		dec	cx
 13976                                  RETZ60:
 13977 000030BB 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 13978                                  
 13979                                  DEVWRTERR:
 13980 000030BD BA[893D]                		mov	dx,DEVWMESPTR
 13981                                  
 13982                                  COPYERR:
 13983                                  		;invoke	Std_EPrintF		;AC022;
 13984 000030C0 E81004                  		call	STD_PRINTF
 13985                                  COPERRP:
 13986 000030C3 FE06[9142]              		inc	byte [DESTCLOSED]
 13987 000030C7 803E[9042]00            		cmp	byte [CFLAG],0
 13988 000030CC 7419                    		jz	short ENDCOPYJ		; never actually got it open
 13989 000030CE 8B1E[C844]              		mov	bx,[DESTHAND]
 13990 000030D2 83FB00                  		cmp	bx,0
 13991 000030D5 7E04                    		jle	short NOCLOSE
 13992                                  
 13993                                  ;	Check to see if we should save part of the destination file.
 13994                                  
 13995                                  		; MSDOS 6.0
 13996                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 13997                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 13998                                  			
 13999                                  		;mov	ax,cx
 14000                                  		;or	ax,dx
 14001                                  		;jz	ceClose			; null file ptr means nothing to save
 14002                                  
 14003                                  ;	Destination was also the first source.  Do the best we can to
 14004                                  ;	restore it.  Truncate it back to the size we took from it (which
 14005                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14006                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14007                                  
 14008                                  		;mov	ax,LSEEK shl 8
 14009                                  		;int	21h
 14010                                  
 14011                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14012                                  		;mov	ah,WRITE
 14013                                  		;int	21h			; truncate file
 14014                                  
 14015                                  		;cmp	OCtrlZ,0
 14016                                  		;je	@f			; no ctrl-z removed from original
 14017                                  		;inc	cx			; CX = # bytes to write = 1
 14018                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14019                                  		;mov	ah,WRITE
 14020                                  		;int	21h			; write ctrl-z
 14021                                  ;@@:
 14022                                  		;mov	ah,CLOSE
 14023                                  		;int	21h			; close it
 14024                                  ;;		;mov	CFlag,0
 14025                                  		;jmp	EndCopy			; and go home
 14026                                  
 14027                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14028                                  CECLOSE:
 14029 000030D7 B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14030 000030D9 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14031                                  					; BX = file handle
 14032                                  NOCLOSE:
 14033 000030DB BA[7144]                		mov	dx,DESTBUF
 14034 000030DE B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14035 000030E0 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14036                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14037 000030E2 C606[9042]00            		mov	byte [CFLAG],0
 14038                                  ENDCOPYJ:
 14039 000030E7 E9F7FA                  		jmp	ENDCOPY
 14040                                  
 14041                                  SEEKEND:
 14042 000030EA 31D2                    		xor	dx,dx
 14043 000030EC 87D1                    		xchg	dx,cx
 14044                                  		;mov	ax,(LSEEK shl 8) or 1
 14045 000030EE B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14046 000030F1 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14047                                  					; AL = method: offset from present location
 14048 000030F3 803E[8442]00            		cmp	byte [RDEOF],0
 14049 000030F8 74C1                    		jz	short RETZ60
 14050                                  
 14051                                  ;	^Z has been read - we must set the file size to the current
 14052                                  ;	file pointer location
 14053                                  
 14054 000030FA B440                    		mov	ah,WRITE ; 40h
 14055 000030FC CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14056                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14057                                  
 14058                                  		; MSDOS 6.0
 14059                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14060                                  
 14061                                  ;	Make note that ^Z was removed, in case the
 14062                                  ;	copy should fail and we need to restore the file.
 14063                                  
 14064                                  		;mov	OCtrlZ,1Ah
 14065                                  
 14066 000030FE C3                      		retn
 14067                                  
 14068                                  ;============================================================================
 14069                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14070                                  ;============================================================================
 14071                                  ; 01/10/2018 - Retro DOS v3.0
 14072                                  
 14073                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14074                                  
 14075                                  ; =============== S U B	R O U T	I N E =======================================
 14076                                  
 14077                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14078                                  ;
 14079                                  ;	Given switch vector in AX,
 14080                                  ;	  Set Ascii flag if /a is set
 14081                                  ;	  Clear Ascii flag if /b is set
 14082                                  ;	  Binary set if /b specified
 14083                                  ;	  Leave Ascii unchanged if neither or both are set
 14084                                  ; 	Also sets Inexact if Ascii is ever set. 
 14085                                  ;	AL = Ascii on exit, flags set
 14086                                  
 14087                                  SETASC:
 14088 000030FF 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14089 00003101 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14090 00003103 50                      		push	ax
 14091 00003104 2408                    		and	al,SWITCHB  ; 8
 14092 00003106 A2[8A45]                		mov	[BINARY],al
 14093 00003109 58                      		pop	ax
 14094 0000310A 2404                    		and	al,4
 14095 0000310C A2[8E45]                		mov	[ASCII],al
 14096 0000310F 0806[8745]              		or	[INEXACT],al
 14097                                  LOADSW:
 14098 00003113 A0[8E45]                		mov	al,[ASCII]
 14099 00003116 08C0                    		or	al,al
 14100 00003118 C3                      		retn
 14101                                  
 14102                                  ; =============== S U B	R O U T	I N E =======================================
 14103                                  
 14104                                  BUILDDEST:
 14105 00003119 803E[6C44]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14106 0000311E 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14107 00003120 BF[5341]                		mov	di,USERDIR1
 14108 00003123 BD[6C44]                		mov	bp,DESTVARS
 14109 00003126 E8DF00                  		call	BUILDPATH
 14110 00003129 E862E7                  		call	RESTUDIR1
 14111                                  
 14112                                  ;	We now know all about the destination
 14113                                  
 14114                                  KNOWABOUTDEST:
 14115 0000312C 30C0                    		xor	al,al
 14116 0000312E 8606[CB44]              		xchg	al,[FIRSTDEST]
 14117 00003132 08C0                    		or	al,al
 14118 00003134 7503                    		jnz	short FIRSTDST
 14119 00003136 E98A00                  		jmp	NOFIRSTDEST
 14120                                  FIRSTDST:
 14121                                  
 14122                                  ;	Create an fcb of the original dest.
 14123                                  
 14124 00003139 8B36[6E44]              		mov	si,[DESTTAIL]
 14125 0000313D BF[2743]                		mov	di,DESTFCB
 14126 00003140 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14127 00003143 CD21                    		int	21h		; DOS -	PARSE FILENAME
 14128                                  					; DS:SI	-> string to parse
 14129                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14130                                  					; AL = bit mask	to control parsing
 14131 00003145 803C00                  		cmp	byte [si],0
 14132 00003148 7404                    		jz	short GOODPARSE
 14133 0000314A C645017C                		mov	byte [di+1],'|'
 14134                                  		; MSDOS 6.0
 14135                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14136                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14137                                  		;jmp	CopErr				;AN052;
 14138                                  GOODPARSE:
 14139 0000314E A1[7144]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14140 00003151 80FC3A                  		cmp	ah,':'
 14141 00003154 7402                    		jz	short DRVSPEC4
 14142 00003156 B040                    		mov	al,'@'
 14143                                  DRVSPEC4:
 14144                                  
 14145                                  ;	AX = "d:" for following FCB drive computation
 14146                                  
 14147 00003158 8A0E[8E45]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14148 0000315C 0C20                    		or	al,20h
 14149 0000315E 2C60                    		sub	al,60h
 14150 00003160 A2[2743]                		mov	byte [DESTFCB],al	; store drive # in FCB
 14151                                  
 14152                                  ;*	Figure out what copy mode we're in.
 14153                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14154                                  ;	+n stands for additional sources delimited by +'s.
 14155                                  ;
 14156                                  ;	copy a b	not concatenating
 14157                                  ;	copy a *	not concatenating
 14158                                  ;	copy * a	concatenating
 14159                                  ;	copy * *	not concatenating
 14160                                  ;	copy a+n b	concatenating
 14161                                  ;	copy *+n a	concatenating
 14162                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14163                                  
 14164                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14165                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14166                                  
 14167 00003163 A0[7044]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14168 00003166 8A26[D344]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14169 0000316A 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14170 0000316D 08C0                    		or	al,al
 14171 0000316F 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14172                                  
 14173                                  ;	Destination is wildcarded.
 14174                                  	
 14175 00003171 38E0                    		cmp	al,ah
 14176 00003173 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14177                                  
 14178                                  ;	Source and destination are both wildcarded.
 14179                                  
 14180 00003175 803E[8F45]00            		cmp	byte [PLUS],0
 14181 0000317A 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14182                                  
 14183                                  ;	Source and destination are wildcarded, and source includes +'s.
 14184                                  ;	It's Mel Hallorman copy time.
 14185                                  
 14186 0000317C FE06[CC44]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14187 00003180 30C0                    		xor	al,al
 14188 00003182 EB06                    		jmp	short SETCONC
 14189                                  
 14190                                  NOTMELCOPY:
 14191 00003184 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14192 00003186 20E0                    		and	al,ah
 14193 00003188 D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14194                                  				;   (implies concatenation)
 14195                                  SETCONC:
 14196 0000318A 0A06[8F45]              		or	al,[PLUS]	; "+" always infers concatenation
 14197                                  
 14198                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14199                                  
 14200 0000318E A2[8642]                		mov	[CONCAT],al
 14201 00003191 D0E0                    		shl	al,1
 14202 00003193 D0E0                    		shl	al,1
 14203 00003195 A2[8745]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14204 00003198 803E[8A45]00            		cmp	byte [BINARY],0
 14205 0000319D 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14206                                  
 14207 0000319F A2[8E45]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14208 000031A2 08C9                    		or	cl,cl
 14209 000031A4 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14210 000031A6 08C0                    		or	al,al
 14211 000031A8 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14212                                  
 14213                                  ;	At this point there may already be binary read data in the read
 14214                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14215                                  ;	amount of data in the buffer correctly.
 14216                                  
 14217 000031AA 8B0E[9442]              		mov	cx,[NXTADD]
 14218 000031AE E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14219 000031B0 B01A                    		mov	al,1Ah
 14220 000031B2 06                      		push	es
 14221 000031B3 31FF                    		xor	di,di
 14222 000031B5 8E06[7342]              		mov	es,[TPA]
 14223 000031B9 F2AE                    		repne scasb		; scan for EOF
 14224 000031BB 07                      		pop	es
 14225 000031BC 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14226 000031BE 4F                      		dec	di		; point at ^z
 14227 000031BF 893E[9442]              		mov	[NXTADD],di	; new buffer length
 14228                                  
 14229                                  NOFIRSTDEST:
 14230 000031C3 BB[6B43]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14231 000031C6 803E[8642]00            		cmp	byte [CONCAT],0
 14232 000031CB 7403                    		jz	short GOTCHRSRC	; Not a concat
 14233 000031CD BB[B143]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14234                                  GOTCHRSRC:
 14235 000031D0 BE[2843]                		mov	si,DESTFCB+1	; Original dest name
 14236 000031D3 8B3E[6E44]              		mov	di,[DESTTAIL]	; Where to put result
 14237                                  
 14238                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14239                                  
 14240                                  BUILDNAME:
 14241 000031D7 B90800                  		mov	cx,8
 14242                                  BUILDMAIN:
 14243 000031DA AC                      		lodsb
 14244 000031DB 3C3F                    		cmp	al,'?'
 14245 000031DD 7502                    		jnz	short NOTAMBIG
 14246 000031DF 8A07                    		mov	al,[bx]
 14247                                  NOTAMBIG:
 14248 000031E1 3C20                    		cmp	al,' '
 14249 000031E3 7401                    		jz	short NOSTORE
 14250 000031E5 AA                      		stosb
 14251                                  NOSTORE:
 14252 000031E6 43                      		inc	bx
 14253 000031E7 E2F1                    		loop	BUILDMAIN
 14254 000031E9 B103                    		mov	cl,3
 14255 000031EB B020                    		mov	al,' '
 14256 000031ED 3804                    		cmp	[si],al
 14257 000031EF 7413                    		jz	short ENDDEST	; No extension
 14258 000031F1 A0[083F]                		mov	al,[DOT_CHR]
 14259 000031F4 AA                      		stosb
 14260                                  BUILDEXT:
 14261 000031F5 AC                      		lodsb
 14262 000031F6 3C3F                    		cmp	al,'?'
 14263 000031F8 7502                    		jnz	short NOTAMBIGE
 14264 000031FA 8A07                    		mov	al,[bx]
 14265                                  NOTAMBIGE:
 14266 000031FC 3C20                    		cmp	al,' '
 14267 000031FE 7401                    		jz	short NOSTOREE
 14268 00003200 AA                      		stosb
 14269                                  NOSTOREE:
 14270 00003201 43                      		inc	bx
 14271 00003202 E2F1                    		loop	BUILDEXT
 14272                                  ENDDEST:
 14273 00003204 30C0                    		xor	al,al
 14274 00003206 AA                      		stosb			; NUL terminate
 14275 00003207 C3                      		retn
 14276                                  
 14277                                  ; =============== S U B	R O U T	I N E =======================================
 14278                                  
 14279                                  BUILDPATH:
 14280 00003208 F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14281 0000320C 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14282 0000320E 89EA                    		mov	dx,bp		; Set DX to spec
 14283 00003210 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14284                                  
 14285                                  		; MSDOS 6.0
 14286                                  		;push	di				;AN000;
 14287                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14288                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14289                                  		;xor	cx,cx				;AN000; no special files
 14290                                  		;mov	si,dx				;AN030; get file name offset
 14291                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14292                                  		;INT	21h
 14293                                  		;pop	di				;AN000;
 14294                                  		;jnc	pure_file			;AN022; is pure file
 14295                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14296                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14297                                  		;jz	notpfile			;AN022;
 14298                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14299                                  		;jz	notpfile			;AN022;
 14300                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14301                                  		;jz	notpfile			;AN022;
 14302                                  		;jmp	extend_setup			;AN022; exit with error
 14303                                  ;pure_file:
 14304                                  		; MSDOS 3.3
 14305 00003213 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14306 00003216 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14307                                  					; DS:DX	-> ASCIZ filename
 14308                                  					; AL = access mode
 14309                                  					; 0 - read
 14310 00003218 7216                    		jc	short NOTPFILE
 14311                                  ;PURE_FILE:
 14312 0000321A 89C3                    		mov	bx,ax
 14313 0000321C B80044                  		mov	ax,IOCTL*256 ; 4400h
 14314 0000321F CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14315                                  					; BX = file or device handle
 14316 00003221 B43E                    		mov	ah,CLOSE ;3Eh
 14317 00003223 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14318                                  					; BX = file handle
 14319 00003225 F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14320 00003228 7545                    		jnz	short ISADEV
 14321 0000322A F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14322 0000322E 743F                    		jz	short ISADEV
 14323                                  
 14324                                  NOTPFILE:
 14325 00003230 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14326                                  		
 14327                                  		;MSDOS 6.0
 14328                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14329                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14330                                  
 14331 00003233 80FE3A                  		cmp	dh,':'
 14332 00003236 7402                    		je	short DRVSPEC5
 14333                                  
 14334                                  SET_DRIVE_SPEC:
 14335 00003238 B240                    		mov	dl,'@'
 14336                                  
 14337                                  DRVSPEC5:
 14338 0000323A 80CA20                  		or	dl,20h
 14339 0000323D 80EA60                  		sub	dl,60h		; A = 1
 14340 00003240 E806E7                  		call	SAVUDIR1
 14341                                  	
 14342                                  		; MSDOS 6.0
 14343                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14344                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14345                                  		;jmp	extend_setup		;AN022; exit with error
 14346                                  
 14347                                  CURDIR_OK:
 14348 00003243 89EA                    		mov	dx,bp
 14349                                  		;add	dx,5
 14350 00003245 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14351                                  		;mov	bh,[bp+4]
 14352 00003248 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14353 0000324B 80E706                  		and	bh,6
 14354 0000324E 80FF06                  		cmp	bh,6			; Ambig and path ?
 14355 00003251 7517                    		jne	short CHECKAMB		; jmp if no
 14356                                  		;mov	si,[bp+2]
 14357 00003253 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14358 00003256 B33A                    		mov	bl,':'
 14359 00003258 385CFE                  		cmp	[si-2],bl
 14360 0000325B 7506                    		jne	short KNOWNOTSPEC
 14361                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14362                                  		;mov	byte [bp+0],2
 14363 0000325D C6460002                		mov	byte [bp],2
 14364 00003261 EB05                    		jmp	short DOPCDJ
 14365                                  
 14366                                  KNOWNOTSPEC:
 14367                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14368                                  		;mov	byte [bp+0],1		
 14369 00003263 C6460001                		mov	byte [bp],1
 14370 00003267 4E                      		dec	si
 14371                                  DOPCDJ:
 14372 00003268 EB62                    		jmp	short DOPCD
 14373                                  
 14374                                  CHECKAMB:
 14375 0000326A 80FF02                  		cmp	bh,2
 14376 0000326D 7505                    		jnz	short CHECKCD
 14377                                  ISSIMPFILE:
 14378                                  ISADEV:
 14379                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14380                                  		;mov	byte [bp+0],0		
 14381 0000326F C6460000                		mov	byte [bp],0
 14382 00003273 C3                      		retn
 14383                                  
 14384                                  CHECKCD:
 14385 00003274 E893EC                  		call	SETREST1
 14386 00003277 B43B                    		mov	ah,CHDIR ; 3Bh
 14387 00003279 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14388                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14389 0000327B 7223                    		jb	short NOTPDIR
 14390 0000327D 89D7                    		mov	di,dx
 14391 0000327F 31C0                    		xor	ax,ax
 14392 00003281 89C1                    		mov	cx,ax
 14393 00003283 49                      		dec	cx
 14394 00003284 F2AE                    		repne scasb
 14395                                  DONE:
 14396 00003286 4F                      		dec	di
 14397 00003287 A0[7642]                		mov	al,[DIRCHAR]
 14398                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14399                                  		;mov	byte [bp+0],2
 14400 0000328A C6460002                		mov	byte [bp],2
 14401 0000328E 3A45FF                  		cmp	al,[di-1]
 14402 00003291 7405                    		jz	short GOTSRCSLSH
 14403                                  _STORE_PCHAR:
 14404 00003293 AA                      		stosb
 14405                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14406                                  		;mov	byte [bp+0],1
 14407 00003294 C6460001                		mov	byte [bp],1
 14408                                  GOTSRCSLSH:
 14409                                  		;or	byte [bp+4],6
 14410 00003298 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14411 0000329C E84500                  		call	SETSTARS
 14412                                  NOTPDIR_RETN:
 14413 0000329F C3                      		retn
 14414                                  
 14415                                  NOTPDIR:
 14416                                  		; MSDOS 6.0
 14417                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14418                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14419                                  		;jz	notpdir_try		;AN022;
 14420                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14421                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14422                                  ;notpdir_try:
 14423                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14424                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14425                                  		;mov	byte [bp+0],0
 14426 000032A0 C6460000                		mov	byte [bp],0
 14427                                  		;mov	bh,[bp+4]
 14428 000032A4 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14429 000032A7 F6C704                  		test	bh,4
 14430 000032AA 74F3                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14431                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14432                                  		;mov	byte [bp+0],2		
 14433 000032AC C6460002                		mov	byte [bp],2
 14434                                  		;mov	si,[bp+2]
 14435 000032B0 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14436 000032B3 803C00                  		cmp	byte [si],0
 14437 000032B6 7428                    		je	short BADCDERRJ2	; Trailing '/'	
 14438 000032B8 8A1E[083F]              		mov	bl,[DOT_CHR]
 14439 000032BC 381C                    		cmp	[si],bl
 14440 000032BE 7420                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14441 000032C0 B33A                    		mov	bl,':'
 14442 000032C2 385CFE                  		cmp	[si-2],bl
 14443 000032C5 7405                    		je	short DOPCD		   ; Know d:/file
 14444                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14445                                  		;mov	byte [bp+0],1
 14446 000032C7 C6460001                		mov	byte [bp],1
 14447 000032CB 4E                      		dec	si			; Point at last '/'
 14448                                  DOPCD:
 14449 000032CC 30DB                    		xor	bl,bl
 14450 000032CE 861C                    		xchg	bl,[si]			; Stick in a NUL
 14451 000032D0 E837EC                  		call	SETREST1
 14452 000032D3 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14453 000032D6 7408                    		je	short BADCDERRJ2
 14454 000032D8 B43B                    		mov	ah,CHDIR ; 3Bh
 14455 000032DA CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14456                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14457 000032DC 861C                    		xchg	bl,[si]
 14458 000032DE 73BF                    		jnc	short NOTPDIR_RETN
 14459                                  		
 14460                                  		; MSDOS 3.3
 14461                                  BADCDERRJ2:
 14462 000032E0 F9                      		stc
 14463 000032E1 E9FADE                  		jmp	BADCDERR
 14464                                  
 14465                                  		; MSDOS 6.0
 14466                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14467                                  ;EXTEND_SETUPJ:					;AN022;
 14468                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14469                                  ;BADCDERRJ2:
 14470                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14471                                  
 14472                                  ; =============== S U B	R O U T	I N E =======================================
 14473                                  
 14474                                  SETSTARS:
 14475                                  		;mov	[bp+2],di
 14476 000032E4 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14477                                  		;add	byte [bp+1],12
 14478 000032E7 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14479 000032EB A1[093F]                		mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14480 000032EE B90800                  		mov	cx,8
 14481 000032F1 F3AA                    		rep stosb
 14482 000032F3 86C4                    		xchg	al,ah
 14483 000032F5 AA                      		stosb
 14484 000032F6 86C4                    		xchg	al,ah
 14485 000032F8 B103                    		mov	cl,3
 14486 000032FA F3AA                    		rep stosb
 14487 000032FC 30C0                    		xor	al,al
 14488 000032FE AA                      		stosb
 14489 000032FF C3                      		retn
 14490                                  
 14491                                  ; =============== S U B	R O U T	I N E =======================================
 14492                                  
 14493                                  COMPNAME:
 14494 00003300 BE[7144]                		mov	si,DESTBUF	; do name translate of target
 14495 00003303 BF[F63F]                		mov	di,TRGXNAME	; save for name comparison
 14496 00003306 B460                    		mov	ah,XNAMETRANS ; 60h
 14497 00003308 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14498                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14499                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14500 0000330A BE[9F3F]                		mov	si,SRCXNAME	; get name translate of source
 14501 0000330D BF[F63F]                		mov	di,TRGXNAME	; get name translate of target
 14502 00003310 E8ACE6                  		call	STRCOMP
 14503 00003313 C3                      		retn
 14504                                  
 14505                                  ;============================================================================
 14506                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14507                                  ;============================================================================
 14508                                  ; 30/09/2018 - Retro DOS v3.0
 14509                                  
 14510                                  ;-----------------------------------------------------------------------;
 14511                                  ; ENTRY:								;
 14512                                  ;	DS:SI	Points input buffer					;
 14513                                  ;	ES:DI	Points to the token buffer				;
 14514                                  ;	BL	Special delimiter for this call 			;
 14515                                  ;		    Always checked last 				;
 14516                                  ;		    set it to space if there is no special delimiter	;
 14517                                  ; EXIT: 								;
 14518                                  ;	DS:SI	Points to next char in the input buffer 		;
 14519                                  ;	ES:DI	Points to the token buffer				;
 14520                                  ;	[STARTEL] Points to start of last element of path in token	;
 14521                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14522                                  ;	CX	Character count 					;
 14523                                  ;	BH	Condition Code						;
 14524                                  ;			Bit 1H of BH set if switch character		;
 14525                                  ;				Token buffer contains char after	;
 14526                                  ;				switch character			;
 14527                                  ;				BP has switch bits set (ORing only)	;
 14528                                  ;			Bit 2H of BH set if ? or * in token		;
 14529                                  ;				if * found element ? filled		;
 14530                                  ;			Bit 4H of BH set if path sep in token		;
 14531                                  ;			Bit 80H of BH set if the special delimiter	;
 14532                                  ;			   was skipped at the start of this token	;
 14533                                  ;		Token buffer always starts d: for non switch tokens	;
 14534                                  ;	CARRY SET							;
 14535                                  ;	    if CR on input						;
 14536                                  ;		token buffer not altered				;
 14537                                  ;									;
 14538                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14539                                  ; MODIFIES:								;
 14540                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14541                                  ;									;
 14542                                  ;-----------------------------------------------------------------------;
 14543                                  
 14544                                  ; Modifications to cparse: recognition of right and left parentheses
 14545                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14546                                  ;
 14547                                  ; Both modifications were installed in the course of adding a coherent
 14548                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14549                                  ; structure for command-line arguments. This parser relies on cparse to
 14550                                  ; recognize individual tokens.
 14551                                  ;
 14552                                  ; To process for-loops correctly, parentheses must therefore be
 14553                                  ; recognized as tokens. The upper-case conversion code was removed so
 14554                                  ; that commands (such as for and echo) would be able to use the "original"
 14555                                  ; text of the command line.
 14556                                  ;
 14557                                  ; Note also the modification to prevent the automatic conversion of colons
 14558                                  ; into spaces WITHIN THE SOURCE TEXT!
 14559                                  ;
 14560                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14561                                  ; on the command line.
 14562                                  ;
 14563                                  ; Alan L, OS/MSDOS				    14 August 1983
 14564                                  
 14565                                  ; ---------------------------------------------------------------------------
 14566                                  
 14567                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14568                                  
 14569                                  ;FSWITCH	EQU	8000h
 14570                                  ;FBADSWITCH	EQU	4000h
 14571                                  
 14572                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14573                                  
 14574                                  ; =============== S U B	R O U T	I N E =======================================
 14575                                  
 14576                                  CPARSE:
 14577 00003314 31C0                    		xor	ax,ax
 14578 00003316 893E[9745]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14579 0000331A A2[9A45]                		mov	[ELPOS],al		; Start in 8 char prefix
 14580 0000331D A2[9B45]                		mov	[SOURCE],al		; No skip delimiter yet
 14581 00003320 88C7                    		mov	bh,al			; Init nothing
 14582 00003322 9C                      		pushf				; save flags
 14583 00003323 57                      		push	di			; save the token buffer addrss
 14584 00003324 31C9                    		xor	cx,cx			; no chars in token buffer
 14585 00003326 880E[C643]              		mov	[COMMA],cl		; reset comma flag
 14586                                  
 14587                                  MOREDELIM:
 14588 0000332A AC                      		lodsb
 14589 0000332B E853E6                  		call	DELIM
 14590 0000332E 751D                    		jnz	short SCANCDONE
 14591 00003330 3C20                    		cmp	al,' '
 14592 00003332 74F6                    		jz	short MOREDELIM
 14593 00003334 3C09                    		cmp	al,9
 14594 00003336 74F2                    		jz	short MOREDELIM
 14595 00003338 8606[9B45]              		xchg	al,[SOURCE]
 14596 0000333C 08C0                    		or	al,al
 14597 0000333E 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14598 00003340 F6C780                  		test	bh,80h			; has a special char been found?
 14599 00003343 7405                    		jz	short NO_COMMA		; no - just exit
 14600 00003345 C606[C643]01            		mov	byte [COMMA],1		; set comma flag
 14601                                  
 14602                                  NO_COMMA:
 14603 0000334A E92201                  		jmp	X_DONE			; Nul argument
 14604                                  
 14605                                  SCANCDONE:
 14606 0000334D 803E[5644]01            		cmp	byte [CPYFLAG],1
 14607 00003352 7503                    		jnz	short CPCONT1
 14608 00003354 E8C7E4                  		call	UPCONV_MAPCALL
 14609                                  CPCONT1:
 14610 00003357 38D8                    		cmp	al,bl			; Special delimiter?
 14611 00003359 7505                    		jnz	short NOSPEC
 14612 0000335B 80CF80                  		or	bh,80h
 14613 0000335E EBCA                    		jmp	short MOREDELIM
 14614                                  
 14615                                  NOSPEC:
 14616 00003360 3C0D                    		cmp	al,0Dh			; a CR?
 14617 00003362 7503                    		jnz	short NCPERROR
 14618 00003364 E90301                  		jmp	CPERROR
 14619                                  
 14620                                  NCPERROR:
 14621 00003367 3A06[7542]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14622 0000336B 7503                    		jnz	short NA_SWITCH		; yes, process...
 14623 0000336D E90201                  		jmp	A_SWITCH
 14624                                  
 14625                                  NA_SWITCH:
 14626 00003370 B23A                    		mov	dl,':'
 14627 00003372 3814                    		cmp	[si],dl
 14628 00003374 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14629 00003376 E83F01                  		call	MOVE_CHAR
 14630 00003379 AC                      		lodsb				; Get the ':'
 14631 0000337A E83B01                  		call	MOVE_CHAR
 14632 0000337D 893E[9745]              		mov	[STARTEL],di
 14633 00003381 C606[9945]00            		mov	byte [ELCNT],0
 14634 00003386 E9A400                  		jmp	ANUM_TEST
 14635                                  
 14636                                  ANUM_CHARD:
 14637 00003389 893E[9745]              		mov	[STARTEL],di
 14638 0000338D C606[9945]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14639 00003392 803E[5644]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14640 00003397 751F                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14641 00003399 E870E6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14642 0000339C 751A                    		jnz	short ANUM_CHAR		; no
 14643 0000339E 50                      		push	ax
 14644 0000339F A0[8542]                		mov	al,[CURDRV]		; Insert drive spec
 14645 000033A2 0206[F03E]              		add	al,[CAPITAL_A]
 14646 000033A6 E80F01                  		call	MOVE_CHAR
 14647 000033A9 B03A                    		mov	al,':'
 14648 000033AB E80A01                  		call	MOVE_CHAR
 14649 000033AE 58                      		pop	ax
 14650 000033AF 893E[9745]              		mov	[STARTEL],di
 14651 000033B3 C606[9945]00            		mov	byte [ELCNT],0
 14652                                  
 14653                                  ANUM_CHAR:
 14654 000033B8 3A06[083F]              		cmp	al,[DOT_CHR]
 14655 000033BC 7509                    		jnz	short TESTQUEST
 14656 000033BE FE06[9A45]              		inc	byte [ELPOS]		; flag in extension
 14657 000033C2 C606[9945]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14658                                  TESTQUEST:
 14659 000033C7 3C3F                    		cmp	al,'?'
 14660 000033C9 7503                    		jnz	short TESTSPLAT
 14661 000033CB 80CF02                  		or	bh,2
 14662                                  TESTSPLAT:
 14663 000033CE 3A06[FD3E]              		cmp	al,[STAR]
 14664 000033D2 7530                    		jnz	short TESTPATH
 14665 000033D4 80CF02                  		or	bh,2
 14666 000033D7 803E[A745]00            		cmp	byte [EXPAND_STAR],0
 14667 000033DC 7504                    		jnz	short EXPAND_FILENAME
 14668 000033DE EB24                    		jmp	short TESTPATH
 14669                                  
 14670                                  BADPERR2J:
 14671 000033E0 EB7F                    		jmp	BADPERR2
 14672                                  
 14673                                  		;db	0E9h
 14674                                  		;db	7Eh	
 14675                                  		;db	0
 14676                                  
 14677                                  EXPAND_FILENAME:
 14678 000033E2 B407                    		mov	ah,7
 14679 000033E4 803E[9A45]00            		cmp	byte [ELPOS],0
 14680 000033E9 7402                    		jz	short GOTELCNT
 14681 000033EB B402                    		mov	ah,2
 14682                                  GOTELCNT:
 14683 000033ED B03F                    		mov	al,'?'
 14684 000033EF 2A26[9945]              		sub	ah,[ELCNT]
 14685 000033F3 72EB                    		jb	short BADPERR2J
 14686 000033F5 86E1                    		xchg	ah,cl
 14687 000033F7 E309                    		jcxz	TESTPATHX
 14688                                  QMOVE:
 14689 000033F9 86E1                    		xchg	ah,cl
 14690 000033FB E8BA00                  		call	MOVE_CHAR
 14691 000033FE 86E1                    		xchg	ah,cl
 14692 00003400 E2F7                    		loop	QMOVE
 14693                                  TESTPATHX:
 14694 00003402 86E1                    		xchg	ah,cl
 14695                                  TESTPATH:
 14696 00003404 E805E6                  		call	PATHCHRCMP
 14697 00003407 7521                    		jnz	short NOTSPECIAL
 14698 00003409 80CF04                  		or	bh,4
 14699 0000340C 803E[A745]00            		cmp	byte [EXPAND_STAR],0
 14700 00003411 7405                    		jz	short NO_ERR_CHECK
 14701 00003413 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14702 00003416 754F                    		jnz	short BADPERR
 14703                                  NO_ERR_CHECK:
 14704 00003418 893E[9745]              		mov	[STARTEL],di	  ; New element
 14705 0000341C FF06[9745]              		inc	word [STARTEL]	  ; Point to char after /
 14706 00003420 C606[9945]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14707 00003425 C606[9A45]00            		mov	byte [ELPOS],0
 14708                                  NOTSPECIAL:
 14709 0000342A E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14710                                  ANUM_TEST:
 14711 0000342D AC                      		lodsb
 14712 0000342E 803E[5644]01            		cmp	byte [CPYFLAG],1
 14713 00003433 7503                    		jnz	short CPCONT3
 14714 00003435 E8E6E3                  		call	UPCONV_MAPCALL
 14715                                  CPCONT3:
 14716 00003438 E846E5                  		call	DELIM
 14717 0000343B 7432                    		jz	short X_DONE
 14718 0000343D 3C0D                    		cmp	al,0Dh
 14719 0000343F 742E                    		jz	short X_DONE
 14720 00003441 3A06[7542]              		cmp	al,[SWITCHAR]
 14721 00003445 7428                    		jz	short X_DONE
 14722 00003447 38D8                    		cmp	al,bl
 14723 00003449 7424                    		jz	short X_DONE
 14724 0000344B 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14725 0000344D 750F                    		jnz	short ANUM_CHARJ
 14726                                  
 14727                                  ; Modification made for parseline.
 14728                                  ; Why would it be necessary to change colons to spaces? In this
 14729                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14730                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14731                                  
 14732 0000344F 803E[5644]02            		cmp	byte [CPYFLAG],2
 14733 00003454 7505                    		jnz	short CPCONT4
 14734 00003456 E85F00                  		call	MOVE_CHAR
 14735 00003459 EBD2                    		jmp	short ANUM_TEST
 14736                                  
 14737                                  CPCONT4:
 14738 0000345B 46                      		inc	si		;Skip the ':'
 14739 0000345C EB11                    		jmp	short X_DONE
 14740                                  
 14741                                  ANUM_CHARJ:
 14742 0000345E E957FF                  		jmp	ANUM_CHAR
 14743                                  
 14744                                  BADPERR2:
 14745 00003461 BA[4C3D]                		mov	dx,BADCPMESPTR
 14746 00003464 E9C2E7                  		jmp	CERROR
 14747                                  
 14748                                  BADPERR:
 14749 00003467 E974DD                  		jmp	BADCDERR  ; MSDOS 3.3	
 14750                                  
 14751                                  CPERROR:
 14752 0000346A 4E                      		dec	si		; adjust the pointer
 14753 0000346B 5F                      		pop	di		; retrive token buffer address
 14754 0000346C 9D                      		popf			; restore flags
 14755 0000346D F9                      		stc			; set the carry bit
 14756 0000346E C3                      		retn
 14757                                  
 14758                                  X_DONE:
 14759 0000346F 4E                      		dec	si		; adjust for next round
 14760                                  
 14761                                  ; Mod to recognize right and left parens as integral tokens.
 14762                                  ;X_DONE2:
 14763 00003470 EB3F                    		jmp	short OUT_TOKEN
 14764                                  
 14765                                  A_SWITCH:
 14766 00003472 80CF01                  		or	bh,1		; Indicate switch
 14767 00003475 81CD0080                		or	bp,FSWITCH ; 8000h
 14768 00003479 E8FDE4                  		call	SCANOFF
 14769 0000347C 46                      		inc	si
 14770 0000347D 3C0D                    		cmp	al,0Dh
 14771 0000347F 7509                    		jnz	short STORE_SWT
 14772 00003481 B000                    		mov	al,0
 14773 00003483 AA                      		stosb
 14774 00003484 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14775 00003488 EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14776                                  					;   BP = fSwitch but no switch
 14777                                  					;   bit is set (unknown switch)
 14778                                  
 14779                                  STORE_SWT:
 14780 0000348A E82B00                  		call	MOVE_CHAR	; store the character
 14781                                  
 14782                                  ; This upconv call must stay.  It is used to identify copy-switches
 14783                                  ; on the command line, and won't store anything into the output buffer.
 14784                                  
 14785 0000348D E88EE3                  		call	UPCONV_MAPCALL
 14786 00003490 06                      		push	es
 14787 00003491 57                      		push	di
 14788 00003492 51                      		push	cx
 14789 00003493 0E                      		push	cs
 14790 00003494 07                      		pop	es
 14791 00003495 BF[1D3F]                		mov	di,SWITCH_LIST ; "VBAPW"
 14792 00003498 B90500                  		mov	cx,SWCOUNT ; 5
 14793 0000349B 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14794 0000349F F2AE                    		repne scasb
 14795 000034A1 750B                    		jnz	short OUT_TOKENP
 14796 000034A3 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14797 000034A7 B80100                  		mov	ax,1
 14798 000034AA D3E0                    		shl	ax,cl
 14799 000034AC 09C5                    		or	bp,ax
 14800                                  OUT_TOKENP:
 14801 000034AE 59                      		pop	cx
 14802 000034AF 5F                      		pop	di
 14803 000034B0 07                      		pop	es
 14804                                  OUT_TOKEN:
 14805 000034B1 B000                    		mov	al,0		; null at the end
 14806 000034B3 AA                      		stosb
 14807 000034B4 5F                      		pop	di		; restore token buffer pointer	
 14808 000034B5 9D                      		popf
 14809 000034B6 F8                      		clc			; clear carry flag
 14810 000034B7 C3                      		retn
 14811                                  
 14812                                  ; =============== S U B	R O U T	I N E =======================================
 14813                                  
 14814                                  MOVE_CHAR:
 14815 000034B8 AA                      		stosb			; store char in token buffer
 14816 000034B9 41                      		inc	cx		; increment char count
 14817 000034BA FE06[9945]              		inc	byte [ELCNT]	; increment element count for * substi
 14818 000034BE C3                      		retn
 14819                                  
 14820                                  ;============================================================================
 14821                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 14822                                  ;============================================================================
 14823                                  ; 30/09/2018 - Retro DOS v3.0
 14824                                  
 14825                                  ; BREAK	<Message Printing Routine>
 14826                                  
 14827                                  ;
 14828                                  ;	MSDOS V3.00 PRINT
 14829                                  ;
 14830                                  ;	Message Printing Routine
 14831                                  ;
 14832                                  
 14833                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 14834                                  ;
 14835                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 14836                                  ;
 14837                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 14838                                  ;
 14839                                  ; Characters are output to PFHandle according to the
 14840                                  ; specifications contained in the Control String.
 14841                                  ;
 14842                                  ; The conversion characters are as follow:
 14843                                  ;
 14844                                  ;               %c - output the next argument as a character
 14845                                  ;               %s - output the next argument as a string
 14846                                  ;               %x - output the next argument as a hexidecimal number
 14847                                  ;                    using abcedf
 14848                                  ;               %X - output the next argument as a hexidecimal number
 14849                                  ;                    using ABCDEF
 14850                                  ;               %d - output the next argument as a decimal number
 14851                                  ;
 14852                                  ;
 14853                                  ; Other format specifiers that may precede the conversion character are:
 14854                                  ;
 14855                                  ;               - (minus sign) - causes the field to be left-adjusted
 14856                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 14857                                  ;               n - digit specifing the minimum field width (default to 1)
 14858                                  ;               L - specifing a long integer
 14859                                  ;
 14860                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 14861                                  ;   to an argument list.
 14862                                  ;
 14863                                  ;   ____________________
 14864                                  ;   |   Ret Addr       |      <= SP
 14865                                  ;   --------------------
 14866                                  ;   |  Ptr to Arg List |
 14867                                  ;   --------------------
 14868                                  ;
 14869                                  ;   And the argument list contains the following:
 14870                                  ;
 14871                                  ;       String_ptr                  (a pointer to the control string)
 14872                                  ;       Arg 1
 14873                                  ;       Arg 2
 14874                                  ;         .
 14875                                  ;         .
 14876                                  ;         .
 14877                                  ;       Arg n-1
 14878                                  ;       Arg n
 14879                                  ;
 14880                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 14881                                  ;   or character.
 14882                                  ;
 14883                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 14884                                  
 14885                                  
 14886                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 14887                                  
 14888                                  ; =============== S U B	R O U T	I N E =======================================
 14889                                  
 14890                                  PRINTF_INIT:
 14891 000034BF E81100                  		call	STD_PRINTF
 14892 000034C2 CB                      		retf
 14893                                  
 14894                                  ; =============== S U B	R O U T	I N E =======================================
 14895                                  
 14896                                  PRINTF_CRLF:
 14897 000034C3 E80D00                  		call	STD_PRINTF
 14898 000034C6 E8A3E4                  		call	CRLF2
 14899 000034C9 C3                      		retn
 14900                                  
 14901                                  ; =============== S U B	R O U T	I N E =======================================
 14902                                  
 14903                                  STD_EPRINTF:
 14904 000034CA 2EC706[393F]0200        		mov	word [cs:PRINTF_HANDLE],2
 14905 000034D1 EB07                    		jmp	short NEW_PRINTF
 14906                                  
 14907                                  ; =============== S U B	R O U T	I N E =======================================
 14908                                  
 14909                                  STD_PRINTF:
 14910                                  
 14911                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 14912                                  
 14913 000034D3 2EC706[393F]0100        		mov	word [cs:PRINTF_HANDLE],1
 14914                                  
 14915                                  NEW_PRINTF:				;Save the callers' registers
 14916 000034DA FC                      		cld
 14917 000034DB 52                      		push	dx
 14918 000034DC 55                      		push	bp
 14919 000034DD 89E5                    		mov	bp,sp
 14920 000034DF 51                      		push	cx
 14921 000034E0 53                      		push	bx
 14922 000034E1 50                      		push	ax
 14923 000034E2 57                      		push	di
 14924 000034E3 56                      		push	si
 14925 000034E4 06                      		push	es
 14926 000034E5 1E                      		push	ds
 14927 000034E6 0E                      		push	cs
 14928 000034E7 07                      		pop	es		;ES points to Printf segment
 14929 000034E8 BF[3B3F]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 14930 000034EB 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 14931                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 14932 000034EE 3E8B7600                		mov	si,[ds:bp] ; bp
 14933 000034F2 83C502                  		add	bp,2
 14934 000034F5 31DB                    		xor	bx,bx
 14935 000034F7 E8F901                  		call	CLEAR_FLAGS	; initialize the world
 14936                                  
 14937                                  GET_CHAR:
 14938 000034FA AC                      		lodsb			;Get a character
 14939 000034FB 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 14940 000034FD 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 14941 000034FF 08C0                    		or	al,al		;Is it the end of the control string?
 14942 00003501 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 14943                                  PRINTF_PERCENT:				
 14944 00003503 E88801                  		call	OUTCHR		;Otherwise store the character
 14945 00003506 EBF2                    		jmp	short GET_CHAR	;And go get another
 14946                                  
 14947                                  PRINTF_DONE:
 14948 00003508 E88B01                  		call	FLUSH
 14949 0000350B 1F                      		pop	ds
 14950 0000350C 07                      		pop	es
 14951 0000350D 5E                      		pop	si
 14952 0000350E 5F                      		pop	di
 14953 0000350F 58                      		pop	ax
 14954 00003510 5B                      		pop	bx
 14955 00003511 59                      		pop	cx
 14956 00003512 5D                      		pop	bp
 14957 00003513 5A                      		pop	dx
 14958 00003514 C3                      		retn
 14959                                  
 14960                                  CONV_CHAR:
 14961 00003515 2EC606[303F]00          		mov	byte [cs:PRINTF_LEFT],0
 14962                                  
 14963                                  NXT_CONV_CHAR:	
 14964                                  		;Look for any format specifiers preceeding the conversion character
 14965 0000351B AC                      		lodsb
 14966 0000351C 3C25                    		cmp	al,'%'			;Just print the %
 14967 0000351E 74E3                    		jz	short PRINTF_PERCENT
 14968 00003520 2E3A06[FE3E]            		cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 14969 00003525 7448                    		jz	short LEFT_ADJ
 14970 00003527 2E3A06[FF3E]            		cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 14971 0000352C 74E7                    		jz	short CONV_CHAR
 14972 0000352E 2E3A06[003F]            		cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 14973 00003533 7442                    		jz	short LONG_INT
 14974 00003535 2E3A06[013F]            		cmp	al,[cs:char_l]	 ; "l"		
 14975 0000353A 743B                    		jz	short LONG_INT
 14976 0000353C 3C30                    		cmp	al,'0'			;Is it a precision specification
 14977 0000353E 723F                    		jb	short LOOK_CONV_CHAR
 14978 00003540 3C39                    		cmp	al,'9'
 14979 00003542 773B                    		ja	short LOOK_CONV_CHAR
 14980 00003544 3C30                    		cmp	al,'0'
 14981 00003546 750F                    		jnz	short NOT_PAD
 14982 00003548 2E833E[343F]00          		cmp	word [cs:PRINTF_WIDTH],0
 14983 0000354E 7507                    		jnz	short NOT_PAD
 14984 00003550 B430                    		mov	ah,'0'
 14985 00003552 2E8826[383F]            		mov	[cs:PAD_CHAR],ah
 14986                                  NOT_PAD:					;Adjust decimal place on precision
 14987 00003557 50                      		push	ax
 14988 00003558 2EA1[343F]              		mov	ax,[cs:PRINTF_WIDTH]
 14989 0000355C B90A00                  		mov	cx,10
 14990 0000355F F7E1                    		mul	cx
 14991 00003561 5A                      		pop	dx
 14992 00003562 30F6                    		xor	dh,dh
 14993 00003564 80EA30                  		sub	dl,'0'
 14994 00003567 01D0                    		add	ax,dx
 14995 00003569 2EA3[343F]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 14996 0000356D EBAC                    		jmp	short NXT_CONV_CHAR
 14997                                  
 14998                                  LEFT_ADJ:
 14999 0000356F 2EC606[303F]01          		mov	byte [cs:PRINTF_LEFT],1
 15000 00003575 EBA4                    		jmp	short NXT_CONV_CHAR
 15001                                  
 15002                                  LONG_INT:
 15003 00003577 2E800E[313F]01          		or	byte [cs:PRINTF_LONG],1
 15004 0000357D EB9C                    		jmp	short NXT_CONV_CHAR
 15005                                  
 15006                                  LOOK_CONV_CHAR:
 15007 0000357F 24DF                    		and	al,0DFh
 15008 00003581 2E3A06[073F]            		cmp	al,[cs:CHAR_X]	 ; "X"
 15009 00003586 741B                    		jz	short HEX_UP
 15010 00003588 2E3A06[043F]            		cmp	al,[cs:CHAR_D]	 ; "D"
 15011 0000358D 741D                    		jz	short DECIMAL
 15012 0000358F 2E3A06[053F]            		cmp	al,[cs:CHAR_C]	 ; "C"
 15013 00003594 741F                    		jz	short C_PUT_CHAR
 15014 00003596 2E3A06[063F]            		cmp	al,[cs:CHAR_S]	 ; "S"
 15015 0000359B 7426                    		jz	short S_PUT_STRG
 15016 0000359D E85301                  		call	CLEAR_FLAGS
 15017 000035A0 E957FF                  		jmp	GET_CHAR
 15018                                  
 15019                                  HEX_UP:
 15020 000035A3 2EC706[363F]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15021 000035AA EB6C                    		jmp	short CONV_TO_NUM
 15022                                  DECIMAL:
 15023 000035AC 2EC706[363F]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15024 000035B3 EB63                    		jmp	short CONV_TO_NUM
 15025                                  
 15026                                  C_PUT_CHAR:
 15027 000035B5 E82E01                  		call	NEXT_CHRS
 15028 000035B8 88D0                    		mov	al,dl
 15029 000035BA E8D100                  		call	OUTCHR
 15030 000035BD E83301                  		call	CLEAR_FLAGS
 15031 000035C0 E937FF                  		jmp	GET_CHAR
 15032                                  
 15033                                  S_PUT_STRG:
 15034 000035C3 56                      		push	si			;Save pointer to control string
 15035 000035C4 E81F01                  		call	NEXT_CHRS
 15036 000035C7 89D6                    		mov	si,dx
 15037                                  S_PUT_1:
 15038 000035C9 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15039 000035CE 09C9                    		or	cx,cx
 15040 000035D0 740B                    		jz	short S_PUT_2
 15041 000035D2 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15042 000035D8 7503                    		jnz	short S_PUT_2
 15043 000035DA E82700                  		call	PAD_STRING
 15044                                  S_PUT_2:
 15045 000035DD 56                      		push	si
 15046                                  S_PUT_3:
 15047 000035DE AC                      		lodsb
 15048 000035DF 08C0                    		or	al,al
 15049 000035E1 7405                    		jz	short S_PUT_4
 15050 000035E3 E8A800                  		call	OUTCHR			;Put it into our buffer
 15051 000035E6 EBF6                    		jmp	short S_PUT_3
 15052                                  S_PUT_4:
 15053 000035E8 5E                      		pop	si
 15054 000035E9 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15055 000035EF 740C                    		jz	short C_S_END
 15056 000035F1 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15057 000035F6 09C9                    		or	cx,cx
 15058 000035F8 7403                    		jz	short C_S_END
 15059 000035FA E80700                  		call	PAD_STRING
 15060                                  C_S_END:
 15061 000035FD 5E                      		pop	si			;Restore control string pointer
 15062 000035FE E8F200                  		call	CLEAR_FLAGS
 15063 00003601 E9F6FE                  		jmp	GET_CHAR		;Go get another character	
 15064                                  
 15065                                  
 15066                                  ; =============== S U B	R O U T	I N E =======================================
 15067                                  
 15068                                  PAD_STRING:
 15069 00003604 31D2                    		xor	dx,dx
 15070 00003606 56                      		push	si
 15071                                  
 15072                                  COUNT_LOOP:
 15073 00003607 AC                      		lodsb
 15074 00003608 08C0                    		or	al,al
 15075 0000360A 7403                    		jz	short COUNT_DONE
 15076 0000360C 42                      		inc	dx
 15077 0000360D EBF8                    		jmp	short COUNT_LOOP
 15078                                  
 15079                                  COUNT_DONE:
 15080 0000360F 5E                      		pop	si
 15081 00003610 29D1                    		sub	cx,dx
 15082 00003612 7603                    		jbe	short COUNT_RET
 15083 00003614 E86700                  		call	PAD
 15084                                  
 15085                                  COUNT_RET:
 15086 00003617 C3                      		retn
 15087                                  
 15088                                  ; ---------------------------------------------------------------------------
 15089                                  
 15090                                  CONV_TO_NUM:
 15091 00003618 E8CB00                  		call	NEXT_CHRS
 15092 0000361B 89D0                    		mov	ax,dx
 15093 0000361D 31D2                    		xor	dx,dx
 15094 0000361F 2E803E[313F]00          		cmp	byte [cs:PRINTF_LONG],0 
 15095                                  				;Is this is a short or long integer?
 15096 00003625 7403                    		jz	short NOT_LONG_INT
 15097 00003627 E8BC00                  		call	NEXT_CHRS
 15098                                  
 15099                                  NOT_LONG_INT:
 15100 0000362A 53                      		push	bx
 15101 0000362B 56                      		push	si
 15102 0000362C 2E8B36[363F]            		mov	si,[cs:PRINTF_BASE]
 15103 00003631 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15104 00003636 E80B00                  		call	PNUM
 15105 00003639 5E                      		pop	si
 15106 0000363A 5B                      		pop	bx
 15107 0000363B E84000                  		call	PAD
 15108 0000363E E8B200                  		call	CLEAR_FLAGS
 15109 00003641 E9B6FE                  		jmp	GET_CHAR
 15110                                  
 15111                                  
 15112                                  ; =============== S U B	R O U T	I N E =======================================
 15113                                  
 15114                                  PNUM:
 15115 00003644 49                      		dec	cx
 15116 00003645 50                      		push	ax
 15117 00003646 89D0                    		mov	ax,dx
 15118 00003648 31D2                    		xor	dx,dx
 15119 0000364A F7F6                    		div	si
 15120 0000364C 89C3                    		mov	bx,ax
 15121 0000364E 58                      		pop	ax
 15122 0000364F F7F6                    		div	si
 15123 00003651 87DA                    		xchg	bx,dx
 15124 00003653 50                      		push	ax
 15125 00003654 09D0                    		or	ax,dx
 15126 00003656 58                      		pop	ax
 15127 00003657 7407                    		jz	short DO_PAD
 15128 00003659 53                      		push	bx
 15129 0000365A E8E7FF                  		call	PNUM
 15130 0000365D 5B                      		pop	bx
 15131 0000365E EB0B                    		jmp	short REM
 15132                                  
 15133                                  DO_PAD:
 15134 00003660 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15135 00003666 7503                    		jnz	short REM
 15136 00003668 E81300                  		call	PAD
 15137                                  REM:
 15138 0000366B 80FB0A                  		cmp	bl,10
 15139 0000366E 7203                    		jb	short NOT_HEX
 15140 00003670 83C306                  		add	bx,6
 15141                                  NOT_HEX:
 15142 00003673 2E8A87[1037]            		mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 15143 00003678 51                      		push	cx
 15144 00003679 E81200                  		call	OUTCHR
 15145 0000367C 59                      		pop	cx
 15146 0000367D C3                      		retn
 15147                                  
 15148                                  ; =============== S U B	R O U T	I N E =======================================
 15149                                  
 15150                                  PAD:
 15151 0000367E 09C9                    		or	cx,cx
 15152 00003680 7E0B                    		jle	short PAD_DONE
 15153 00003682 2EA0[383F]              		mov	al,[cs:PAD_CHAR]
 15154                                  PAD_LOOP:
 15155 00003686 51                      		push	cx
 15156 00003687 E80400                  		call	OUTCHR
 15157 0000368A 59                      		pop	cx
 15158 0000368B E2F9                    		loop	PAD_LOOP
 15159                                  PAD_DONE:
 15160 0000368D C3                      		retn
 15161                                  
 15162                                  ; =============== S U B	R O U T	I N E =======================================
 15163                                  
 15164                                  OUTCHR:
 15165 0000368E AA                      		stosb
 15166 0000368F 81FF[9F3F]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15167 00003693 7401                    		je	short FLUSH
 15168                                  OUTCHR_RETN:
 15169 00003695 C3                      		retn
 15170                                  
 15171                                  ; =============== S U B	R O U T	I N E =======================================
 15172                                  
 15173                                  FLUSH:
 15174 00003696 B9[3B3F]                		mov	cx,PRINTF_BUF
 15175 00003699 87CF                    		xchg	cx,di
 15176 0000369B 29F9                    		sub	cx,di
 15177 0000369D 74F6                    		jz	short OUTCHR_RETN
 15178                                  WRITE_CHARS:
 15179 0000369F 53                      		push	bx
 15180 000036A0 2E8B1E[393F]            		mov	bx,[cs:PRINTF_HANDLE]
 15181 000036A5 1E                      		push	ds
 15182 000036A6 0E                      		push	cs
 15183 000036A7 1F                      		pop	ds
 15184 000036A8 BA[3B3F]                		mov	dx,PRINTF_BUF
 15185 000036AB B440                    		mov	ah,WRITE ; 40h
 15186 000036AD CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15187                                  					; BX = file handle, CX = number	of bytes to write,
 15188                                  					; DS:DX -> buffer
 15189 000036AF 730A                    		jnb	short FOOB2_1
 15190 000036B1 E816E8                  		call	GET_EXT_ERR_NUMBER
 15191 000036B4 83F806                  		cmp	ax,6
 15192 000036B7 742A                    		jz	short FOOB2_4
 15193 000036B9 EB04                    		jmp	short FOOB2_2
 15194                                  
 15195                                  FOOB2_1:
 15196 000036BB 39C1                    		cmp	cx,ax
 15197 000036BD 7424                    		jz	short FOOB2_4
 15198                                  FOOB2_2:
 15199 000036BF 89D3                    		mov	bx,dx
 15200 000036C1 01C3                    		add	bx,ax
 15201 000036C3 803F1A                  		cmp	byte [bx],1Ah
 15202 000036C6 741B                    		jz	short FOOB2_4
 15203 000036C8 1F                      		pop	ds
 15204 000036C9 5B                      		pop	bx
 15205 000036CA 2E8E06[7142]            		mov	es,[cs:RESSEG]
 15206 000036CF BA[3938]                		mov	dx,NOSPACEPTR
 15207 000036D2 26F6065C0CFF            		test	byte [es:PIPEFLAG],0FFh
 15208 000036D8 7406                    		jz	short PRINT_ERR_EXIT
 15209 000036DA E8AFEC                  		call	PIPEOFF
 15210 000036DD BA[D23C]                		mov	dx,PIPEEMESPTR
 15211                                  PRINT_ERR_EXIT:	
 15212 000036E0 E946E5                  		jmp	CERROR
 15213                                  
 15214                                  FOOB2_4:
 15215 000036E3 1F                      		pop	ds
 15216 000036E4 5B                      		pop	bx
 15217 000036E5 C3                      		retn
 15218                                  
 15219                                  ; =============== S U B	R O U T	I N E =======================================
 15220                                  
 15221                                  NEXT_CHRS:
 15222 000036E6 56                      		push	si		;Save pointer to control string
 15223 000036E7 89DE                    		mov	si,bx		;Get index into argument list
 15224 000036E9 83C302                  		add	bx,2		;Increment the index
 15225 000036EC 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15226 000036EF 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15227 000036F1 5E                      		pop	si
 15228 000036F2 C3                      		retn
 15229                                  
 15230                                  ; =============== S U B	R O U T	I N E =======================================
 15231                                  
 15232                                  CLEAR_FLAGS:
 15233 000036F3 31C0                    		xor	ax,ax
 15234 000036F5 2EA2[303F]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15235 000036F9 2EA2[313F]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15236 000036FD 2EA3[343F]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15237 00003701 B020                    		mov	al,' '			
 15238 00003703 2EA2[383F]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15239 00003707 C3                      		retn
 15240                                  
 15241                                  ; ---------------------------------------------------------------------------
 15242                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15243                                  
 15244                                  		; times 7 db 0
 15245                                  
 15246                                  ;============================================================================
 15247                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15248                                  ;============================================================================
 15249                                  ; 30/09/2018 - Retro DOS v3.0
 15250                                  
 15251                                  ; TITLE	COMMAND Transient Initialized DATA
 15252                                  
 15253                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15254                                  ;initial values at the beginning of each command cycle. It is
 15255                                  ;included in the transient checksum area. If values in TRANDATA
 15256                                  ;change, the transient will be reloaded for the next command cycle.
 15257                                  
 15258 00003708 90<rep 8h>              align 16
 15259                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15260                                  
 15261 00003710 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15261 00003719 39414243444546     
 15262 00003720 255300                  _3740h:		db '%S',0
 15263 00003723 [2037]                  ARG_BUF_PTR:	dw _3740h
 15264 00003725 [2737]                  		dw _3747h
 15265 00003727 [C843]                  _3747h:		dw ARG_BUF ; _43E8h
 15266 00003729 25532000                _3749h:		db '%S ',0
 15267 0000372D [2937]                  STRINGBUF1PTR:	dw _3749h
 15268 0000372F [4844]                  		dw STRING_PTR_1 ; _4468h
 15269 00003731 25396C6400              _3751h:		db '%9ld',0
 15270 00003736 [3137]                  FSIZEMESPTR:	dw _3751h
 15271 00003738 [4A44]                  		dw FILESIZE_L ; _446Ah
 15272 0000373A [4C44]                  		dw FILESIZE_H ; _446Ch
 15273 0000373C 255300                  _375Ch:		db '%S',0
 15274 0000373F [3C37]                  STRINGBUF2PTR:	dw _375Ch
 15275 00003741 [4E44]                  		dw STRING_PTR_2 ; _446Eh
 15276 00003743 0900                    _3763h:		db 9,0
 15277 00003745 [4337]                  TABPTR:		dw _3763h
 15278 00003747 0D0A                    _3767h:		db 0Dh,0Ah
 15279 00003749 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15279 00003752 65206D697373696E67-
 15279 0000375B 0D0A00             
 15280 0000375E [4737]                  BADPATHPTR:	dw _3767h
 15281 00003760 0D0A                    _3780h:		db 0Dh,0Ah
 15282 00003762 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15282 0000376B 736B20776974682062-
 15282 00003774 617463682066696C65-
 15282 0000377D 0D0A               
 15283 0000377F 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15283 00003788 20616E79206B657920-
 15283 00003791 7768656E2072656164-
 15283 0000379A 790D0A00           
 15284 0000379E [6037]                  INSERTDSKPTR:	dw _3780h
 15285 000037A0 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15285 000037A9 6E64206F722066696C-
 15285 000037B2 65206E616D650D0A00 
 15286 000037BB [A037]                  BADNAMPTR:	dw _37C0h
 15287 000037BD 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15287 000037C6 2066696C65206E616D-
 15287 000037CF 65206F722046696C65-
 15287 000037D8 206E6F7420666F756E-
 15287 000037E1 640D0A00           
 15288 000037E5 [BD37]                  RENERRPTR:	dw _37DDh
 15289 000037E7 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15289 000037F0 666F756E640D0A00   
 15290 000037F8 [E737]                  FNOTFOUNDPTR:	dw _3807h
 15291 000037FA 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15291 00003803 666F756E640D0A00   
 15292 0000380B [FA37]                  PNOTFOUNDPTR:	dw _381Ah
 15293 0000380D 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15293 00003816 6E6965640D0A00     
 15294 0000381D [0D38]                  ACCDENPTR:	dw _382Dh
 15295 0000381F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15295 00003828 656E74206469736B20-
 15295 00003831 73706163650D0A00   
 15296 00003839 [1F38]                  NOSPACEPTR:	dw _383Fh
 15297 0000383B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15297 00003844 7669726F6E6D656E74-
 15297 0000384D 2073706163650D0A00 
 15298 00003856 [3B38]                  ENVERRPTR:	dw _385Bh
 15299 00003858 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15299 00003861 74696F6E206572726F-
 15299 0000386A 720D0A00           
 15300 0000386E 7838                    FULDIRPTR:	dw 3878h
 15301 00003870 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15301 00003879 6F7420626520636F70-
 15301 00003882 696564206F6E746F20-
 15301 0000388B 697473656C660D0A00 
 15302 00003894 [7038]                  OVERWRPTR:	dw _3890h
 15303 00003896 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15303 0000389F 662064657374696E61-
 15303 000038A8 74696F6E206C6F7374-
 15303 000038B1 206265666F72652063-
 15303 000038BA 6F70790D0A00       
 15304 000038C0 [9638]                  LOSTERRPTR:	dw _38B6h
 15305 000038C2 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15305 000038CB 696C656E616D65206F-
 15305 000038D4 722066696C65206E6F-
 15305 000038DD 7420666F756E640D0A-
 15305 000038E6 00                 
 15306 000038E7 [C238]                  INORNOTPTR:	dw _38E2h
 15307 000038E9 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15307 000038F2 732920636F70696564-
 15307 000038FB 0D0A00             
 15308 000038FE [E938]                  COPIEDPTR:	dw _3909h
 15309 00003900 [5044]                  		dw COPY_NUM ; _4470h
 15310 00003902 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15310 0000390B 73292000           
 15311 0000390F [0239]                  DIRMESPTR:	dw _3922h
 15312 00003911 [5744]                  		dw DIR_NUM  ; _4477h
 15313 00003913 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15313 0000391C 7320667265650D0A00 
 15314 00003925 [1339]                  BYTEMESPTR:	dw _3933h
 15315 00003927 [5944]                  		dw BYTES_FREE   ; _4479h
 15316 00003929 [5B44]                  		dw BYTES_FREE+2 ; _447Bh
 15317 0000392B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15317 00003934 726976652073706563-
 15317 0000393D 696669636174696F6E-
 15317 00003946 0D0A00             
 15318 00003949 [2B39]                  BADDRVPTR:	dw _394Bh
 15319 0000394B 0D0A                    _396Bh:		db 0Dh,0Ah
 15320 0000394D 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15320 00003956 20253564206E6F7420-
 15320 0000395F 707265706172656420-
 15320 00003968 666F72207379737465-
 15320 00003971 6D0D0A00           
 15321 00003975 [4B39]                  CPNOTSETPTR:	dw _396Bh
 15322 00003977 [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15323 00003979 0D0A                    _3999h:		db 0Dh,0Ah
 15324 0000397B 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15324 00003984 20253564206E6F7420-
 15324 0000398D 707265706172656420-
 15324 00003996 666F7220616C6C2064-
 15324 0000399F 6576696365730D0A00 
 15325 000039A8 [7939]                  CPNOTALLPTR:	dw _3999h
 15326 000039AA [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15327 000039AC 0D0A                    _39CCh:		db 0Dh,0Ah
 15328 000039AE 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15328 000039B7 646520706167653A20-
 15328 000039C0 2535640D0A00       
 15329 000039C6 [AC39]                  CPACTIVEPTR:	dw _39CCh
 15330 000039C8 [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15331 000039CA 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15331 000039D3 72697665206973206E-
 15331 000039DC 6F206C6F6E67657220-
 15331 000039E5 76616C696400       
 15332 000039EB [CA39]                  BADCURDRVPTR:	dw _39EAh
 15333 000039ED 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15333 000039F6 6B6579207768656E20-
 15333 000039FF 7265616479202E202E-
 15333 00003A08 202E2000           
 15334 00003A0C [ED39]                  PAUSEMESPTR:	dw _3A0Dh
 15335 00003A0E 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15335 00003A17 6172616D657465720D-
 15335 00003A20 0A00               
 15336 00003A22 [0E3A]                  BADPARMPTR:	dw _3A2Eh
 15337 00003A24 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15337 00003A2D 576564546875467269-
 15337 00003A36 536174             
 15338 00003A39 0D0A                    _3A59h:		db 0Dh,0Ah
 15339 00003A3B 496E76616C69642064-     		db 'Invalid date',0
 15339 00003A44 61746500           
 15340 00003A48 [393A]                  BADDATPTR:	dw _3A59h
 15341 00003A4A 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15341 00003A53 6174652069732000   
 15342 00003A5B [4A3A]                  CURDATPTR:	dw _3A6Ah
 15343 00003A5D 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15344 00003A5F 456E746572206E6577-     		db 'Enter new date ',0
 15344 00003A68 20646174652000     
 15345 00003A6F [5D3A]                  NEWDATPTR:	dw _3A7Dh
 15346 00003A71 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15346 00003A7A 293A2000           
 15347 00003A7E [713A]                  USADATPTR:	dw _3A91h
 15348 00003A80 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15348 00003A89 293A2000           
 15349 00003A8D [803A]                  EURDATPTR:	dw _3AA0h
 15350 00003A8F 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15350 00003A98 293A2000           
 15351 00003A9C [8F3A]                  JAPDATPTR:	dw _3AAFh
 15352 00003A9E 0D0A                    _3ABEh:		db 0Dh,0Ah
 15353 00003AA0 496E76616C69642074-     		db 'Invalid time ',0
 15353 00003AA9 696D652000         
 15354 00003AAE [9E3A]                  BADTIMPTR:	dw _3ABEh
 15355 00003AB0 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15355 00003AB9 696D652069732000   
 15356 00003AC1 [B03A]                  CURTIMPTR:	dw _3AD0h
 15357 00003AC3 0D0A                    _3AE3h:		db 0Dh,0Ah
 15358 00003AC5 456E746572206E6577-     		db 'Enter new time: ',0
 15358 00003ACE 2074696D653A2000   
 15359 00003AD6 [C33A]                  NEWTIMPTR:	dw _3AE3h
 15360 00003AD8 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15360 00003AE1 7572652028592F4E29-
 15360 00003AEA 3F00               
 15361 00003AEC [D83A]                  SUREMESPTR:	dw _3AF8h
 15362 00003AEE 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15362 00003AF7 00                 
 15363 00003AF8 [EE3A]                  DMESPTR:	dw _3B0Eh
 15364 00003AFA 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15364 00003B03 7273696F6E20253164-
 15364 00003B0C 2E2530326420202020-
 15364 00003B15 202020202020202020-
 15364 00003B1E 202020202020202000 
 15365 00003B27 [FA3A]                  VERMESPTR:	dw _3B1Ah
 15366 00003B29 [5D44]                  		dw MAJOR_VER_NUM ; _447Dh
 15367 00003B2B [5F44]                  		dw MINOR_VER_NUM ; _447Fh
 15368 00003B2D 254300                  _3B4Dh:		db '%C',0
 15369 00003B30 [2D3B]                  ONECHRVALPTR:	dw _3B4Dh
 15370 00003B32 [6144]                  		dw ONE_CHAR_VAL	; _4481h
 15371 00003B34 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15371 00003B3D 6E2064726976652025-
 15371 00003B46 6320257300         
 15372 00003B4B [343B]                  VOLMESPTR:	dw _3B54h
 15373 00003B4D [6444]                  		dw VOL_DRV ; _4484h
 15374 00003B4F [6244]                  		dw VOLNAME_ADDR ; _4482h
 15375 00003B51 69732000                IS:		db 'is ',0
 15376 00003B55 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15376 00003B5E 62656C00           
 15377 00003B62 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15377 00003B6B 69726563746F72790D-
 15377 00003B74 0A00               
 15378 00003B76 [623B]                  BADCDPTR:	dw _3B82h
 15379 00003B78 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15379 00003B81 206372656174652064-
 15379 00003B8A 69726563746F72790D-
 15379 00003B93 0A00               
 15380 00003B95 [783B]                  BADMKDPTR:	dw _3B98h
 15381 00003B97 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15381 00003BA0 6174682C206E6F7420-
 15381 00003BA9 6469726563746F7279-
 15381 00003BB2 2C0D0A             
 15382 00003BB5 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15382 00003BBE 6F7279206E6F742065-
 15382 00003BC7 6D7074790D0A00     
 15383 00003BCE [973B]                  BADRMDPTR:	dw _3BB7h
 15384 00003BD0 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15384 00003BD9 696679204F4E206F72-
 15384 00003BE2 204F46460D0A00     
 15385 00003BE9 [D03B]                  BADONOFFPTR:	dw _3BF0h
 15386 00003BEB 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15386 00003BF4 79206F66202025530D-
 15386 00003BFD 0A00               
 15387 00003BFF [EB3B]                  DIRHEADPTR:	dw _3C0Bh
 15388 00003C01 [6544]                  		dw VOL_DIR ; _4485h
 15389 00003C03 4E6F205061746800        _3C23h:		db 'No Path',0
 15390 00003C0B [033C]                  NULLPATHPTR:	dw _3C23h
 15391 00003C0D 504154483D              PATH_TEXT:	db 'PATH='
 15392 00003C12 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15393 00003C19 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15394 00003C21 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15394 00003C2A 7269766520696E2073-
 15394 00003C33 656172636820706174-
 15394 00003C3C 680D0A00           
 15395 00003C40 [213C]                  BADPMESPTR:	dw _3C41h
 15396 00003C42 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15396 00003C4B 65766963650D0A00   
 15397 00003C53 [423C]                  BADDEVPTR:	dw _3C62h
 15398 00003C55 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15398 00003C5E 20666F756E640D0A00 
 15399 00003C67 [553C]                  BADLABPTR:	dw _3C75h
 15400 00003C69 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15400 00003C72 726F720D0A00       
 15401 00003C78 [693C]                  SYNTMESPTR:	dw _3C89h
 15402 00003C7A 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15402 00003C83 6F74206265206E6573-
 15402 00003C8C 7465640D0A00       
 15403 00003C92 [7A3C]                  FORNESTMESTR:	dw _3C9Ah
 15404 00003C94 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15404 00003C9D 656E74206D656D6F72-
 15404 00003CA6 790D0A00           
 15405 00003CAA [943C]                  INSFMEMMESPTR:	dw _3CB4h
 15406 00003CAC 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15406 00003CB5 6174652066696C6520-
 15406 00003CBE 6572726F7220647572-
 15406 00003CC7 696E6720706970650D-
 15406 00003CD0 0A00               
 15407 00003CD2 [AC3C]                  PIPEEMESPTR:	dw _3CCCh
 15408 00003CD4 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15408 00003CDD 2062696E6172792072-
 15408 00003CE6 656164732066726F6D-
 15408 00003CEF 206120646576696365-
 15408 00003CF8 0D0A00             
 15409 00003CFB [D43C]                  INBDEVPTR:	dw _3CF4h
 15410 00003CFD 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15410 00003D06 00                 
 15411 00003D07 [FD3C]                  CTRLMESPTR:	dw _3D1Dh
 15412 00003D09 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15412 00003D12 2000               
 15413 00003D14 [093D]                  VERIMESPTR:	dw _3D29h
 15414 00003D16 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15415 00003D1F [163D]                  ECHOMESPTR:	dw _3D36h
 15416 00003D21 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15417 00003D27 [213D]                  OFFMESPTR:	dw _3D41h
 15418 00003D29 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15419 00003D2E [293D]                  ONMESPTR:	dw _3D49h
 15420 00003D30 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15420 00003D39 617468206F72206669-
 15420 00003D42 6C65206E616D650D0A-
 15420 00003D4B 00                 
 15421 00003D4C [303D]                  BADCPMESPTR:	dw _3D50h
 15422 00003D4E 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15422 00003D57 756D626572206F6620-
 15422 00003D60 706172616D65746572-
 15422 00003D69 730D0A00           
 15423 00003D6D [4E3D]                  BADARGSPTR:	dw _3D6Eh
 15424 00003D6F 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15424 00003D78 74696E6720746F2064-
 15424 00003D81 65766963650D0A00   
 15425 00003D89 [6F3D]                  DEVWMESPTR:	dw _3D8Fh
 15426 00003D8B 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15427 00003D8E [8B3D]                  ACRLFPTR:	dw _3DABh
 15428 00003D90 08                      _3DB0h:		db 8
 15429 00003D91 20                      		db 20h
 15430 00003D92 08                      		db 8
 15431 00003D93 00                      		db 0
 15432 00003D94 [903D]                  DBACKPTR:	dw _3DB0h
 15433 00003D96 79                      small_y:	db 'y'
 15434 00003D97 6E                      small_n:	db 'n'
 15435 00003D98 59                      CAPITAL_Y:	db 'Y'
 15436 00003D99 4E                      CAPITAL_N:	db 'N'
 15437 00003D9A 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15438                                  PROMPT_TABLE:
 15439 00003D9F 42                      		db 'B' ; 42h
 15440 00003DA0 [F813]                  		dw PRINT_B
 15441 00003DA2 44                      		db 'D' ; 44h
 15442 00003DA3 [9F29]                  		dw PRINT_DATE
 15443 00003DA5 45                      		db 'E' ; 45h
 15444 00003DA6 [EA13]                  		dw PRINT_ESC
 15445 00003DA8 47                      		db 'G' ; 47h
 15446 00003DA9 [EE13]                  		dw PRINT_G
 15447 00003DAB 48                      		db 'H' ; 48h
 15448 00003DAC [E013]                  		dw PRINT_BACK
 15449 00003DAE 4C                      		db 'L' ; 4Ch
 15450 00003DAF [F313]                  		dw PRINT_L
 15451 00003DB1 4E                      		db 'N' ; 4Eh
 15452 00003DB2 [0E14]                  		dw PRINT_DRIVE
 15453 00003DB4 50                      		db 'P' ; 50h
 15454 00003DB5 [1A14]                  		dw BUILD_DIR_FOR_PROMPT
 15455 00003DB7 51                      		db 'Q' ; 51h
 15456 00003DB8 [E613]                  		dw PRINT_EQ
 15457 00003DBA 54                      		db 'T' ; 54h
 15458 00003DBB [2C22]                  		dw PRINT_TIME
 15459 00003DBD 56                      		db 'V' ; 56h
 15460 00003DBE [7213]                  		dw PRINT_VERSION
 15461 00003DC0 5F                      		db '_' ; 5Fh
 15462 00003DC1 [6C19]                  		dw CRLF2
 15463 00003DC3 24                      		db '$' ; 24h
 15464 00003DC4 [FB13]                  		dw PRINT_CHAR
 15465 00003DC6 00                      		db 0
 15466                                  
 15467                                  		; Table of IF conditionals
 15468                                  IFTAB:
 15469 00003DC7 03                      		db 3	; First byte is count
 15470 00003DC8 4E4F54                  		db 'NOT'
 15471 00003DCB [7F09]                  		dw IFNOT
 15472 00003DCD 0A                      		db 10
 15473 00003DCE 4552524F524C455645-     		db 'ERRORLEVEL'
 15473 00003DD7 4C                 
 15474 00003DD8 [420A]                  		dw IFERLEV
 15475 00003DDA 05                      		db 5
 15476 00003DDB 4558495354              		db 'EXIST'
 15477 00003DE0 [D609]                  		dw IFEXISTS
 15478 00003DE2 00                      		db 0
 15479                                  
 15480                                  		; Table for internal command names
 15481                                  
 15482 00003DE3 03                      COMTAB:		db 3
 15483 00003DE4 444952                  		db 'DIR'
 15484 00003DE7 03                      		db 3
 15485 00003DE8 [C20E]                  		dw CATALOG
 15486 00003DEA 04                      		db 4
 15487 00003DEB 43414C4C                		db 'CALL'
 15488 00003DEF 02                      		db 2
 15489 00003DF0 [B70A]                  		dw _$CALL
 15490 00003DF2 04                      		db 4
 15491 00003DF3 43484350                		db 'CHCP'
 15492 00003DF7 02                      		db 2
 15493 00003DF8 [C115]                  		dw CHCP
 15494 00003DFA 06                      		db 6
 15495 00003DFB 52454E414D45            		db 'RENAME'
 15496 00003E01 01                      		db 1
 15497 00003E02 [0212]                  		dw CRENAME
 15498 00003E04 03                      		db 3
 15499 00003E05 52454E                  		db 'REN'
 15500 00003E08 01                      		db 1
 15501 00003E09 [0212]                  		dw CRENAME
 15502 00003E0B 05                      		db 5
 15503 00003E0C 4552415345              		db 'ERASE'
 15504 00003E11 01                      		db 1
 15505 00003E12 [9911]                  		dw ERASE
 15506 00003E14 03                      		db 3
 15507 00003E15 44454C                  		db 'DEL'
 15508 00003E18 01                      		db 1
 15509 00003E19 [9911]                  		dw ERASE
 15510 00003E1B 04                      		db 4
 15511 00003E1C 54595045                		db 'TYPE'
 15512 00003E20 01                      		db 1
 15513 00003E21 [7612]                  		dw TYPEFIL
 15514 00003E23 03                      		db 3
 15515 00003E24 52454D                  		db 'REM'
 15516 00003E27 02                      		db 2
 15517 00003E28 [0401]                  		dw TCOMMAND
 15518 00003E2A 04                      		db 4
 15519 00003E2B 434F5059                		db 'COPY'
 15520 00003E2F 03                      		db 3
 15521 00003E30 [F529]                  		dw COPY
 15522 00003E32 05                      		db 5
 15523 00003E33 5041555345              		db 'PAUSE'
 15524 00003E38 02                      		db 2
 15525 00003E39 [8C11]                  		dw PAUSE
 15526 00003E3B 04                      		db 4
 15527 00003E3C 44415445                		db 'DATE'
 15528 00003E40 02                      		db 2
 15529 00003E41 [0221]                  		dw DATE
 15530 00003E43 04                      		db 4
 15531 00003E44 54494D45                		db 'TIME'
 15532 00003E48 00                      		db 0
 15533 00003E49 [1922]                  		dw CTIME
 15534 00003E4B 03                      		db 3
 15535 00003E4C 564552                  		db 'VER'
 15536 00003E4F 00                      		db 0
 15537 00003E50 [6913]                  		dw VERSION
 15538 00003E52 03                      		db 3
 15539 00003E53 564F4C                  		db 'VOL'
 15540 00003E56 01                      		db 1
 15541 00003E57 [1313]                  		dw VOLUME
 15542 00003E59 02                      		db 2
 15543 00003E5A 4344                    		db 'CD'
 15544 00003E5C 01                      		db 1
 15545 00003E5D [A818]                  		dw _$CHDIR
 15546 00003E5F 05                      		db 5
 15547 00003E60 4348444952              		db 'CHDIR'
 15548 00003E65 01                      		db 1
 15549 00003E66 [A818]                  		dw _$CHDIR
 15550 00003E68 02                      		db 2
 15551 00003E69 4D44                    		db 'MD'
 15552 00003E6B 01                      		db 1
 15553 00003E6C [EB18]                  		dw _$MKDIR
 15554 00003E6E 05                      		db 5
 15555 00003E6F 4D4B444952              		db 'MKDIR'
 15556 00003E74 01                      		db 1
 15557 00003E75 [EB18]                  		dw _$MKDIR
 15558 00003E77 02                      		db 2
 15559 00003E78 5244                    		db 'RD'
 15560 00003E7A 01                      		db 1
 15561 00003E7B [2F19]                  		dw _$RMDIR
 15562 00003E7D 05                      		db 5
 15563 00003E7E 524D444952              		db 'RMDIR'
 15564 00003E83 01                      		db 1
 15565 00003E84 [2F19]                  		dw _$RMDIR
 15566 00003E86 05                      		db 5
 15567 00003E87 425245414B              		db 'BREAK'
 15568 00003E8C 00                      		db 0
 15569 00003E8D [D528]                  		dw CNTRLC
 15570 00003E8F 06                      		db 6
 15571 00003E90 564552494659            		db 'VERIFY'
 15572 00003E96 00                      		db 0
 15573 00003E97 [0729]                  		dw VERIFY
 15574 00003E99 03                      		db 3
 15575 00003E9A 534554                  		db 'SET'
 15576 00003E9D 02                      		db 2
 15577 00003E9E [9816]                  		dw ADD_NAME_TO_ENVIRONMENT
 15578 00003EA0 06                      		db 6
 15579 00003EA1 50524F4D5054            		db 'PROMPT'
 15580 00003EA7 02                      		db 2
 15581 00003EA8 [7E16]                  		dw ADD_PROMPT
 15582 00003EAA 04                      		db 4
 15583 00003EAB 50415448                		db 'PATH'
 15584 00003EAF 02                      		db 2
 15585 00003EB0 [8314]                  		dw PATH
 15586 00003EB2 04                      		db 4
 15587 00003EB3 45584954                		db 'EXIT'
 15588 00003EB7 00                      		db 0
 15589 00003EB8 [5016]                  		dw _$EXIT
 15590 00003EBA 04                      		db 4
 15591 00003EBB 43545459                		db 'CTTY'
 15592 00003EBF 03                      		db 3
 15593 00003EC0 [5D15]                  		dw CTTY
 15594 00003EC2 04                      		db 4
 15595 00003EC3 4543484F                		db 'ECHO'
 15596 00003EC7 02                      		db 2
 15597 00003EC8 [9228]                  		dw ECHO
 15598 00003ECA 04                      		db 4
 15599 00003ECB 474F544F                		db 'GOTO'
 15600 00003ECF 02                      		db 2
 15601 00003ED0 [EB0A]                  		dw GOTO
 15602 00003ED2 05                      		db 5
 15603 00003ED3 5348494654              		db 'SHIFT'
 15604 00003ED8 02                      		db 2
 15605 00003ED9 [700A]                  		dw SHIFT
 15606 00003EDB 02                      		db 2
 15607 00003EDC 4946                    		db 'IF'
 15608 00003EDE 02                      		db 2
 15609 00003EDF [2F09]                  		dw _$IF
 15610 00003EE1 03                      		db 3
 15611 00003EE2 464F52                  		db 'FOR'
 15612 00003EE5 02                      		db 2
 15613 00003EE6 [460D]                  		dw _$FOR
 15614 00003EE8 03                      		db 3
 15615 00003EE9 434C53                  		db 'CLS'
 15616 00003EEC 00                      		db 0
 15617 00003EED [F214]                  		dw CLS
 15618 00003EEF 00                      		db 0
 15619                                  
 15620 00003EF0 41                      CAPITAL_A:	db 'A'
 15621 00003EF1 7C                      VBAR:		db '|'
 15622 00003EF2 3C                      LABRACKET:	db '<' ; 3Ch
 15623 00003EF3 3E                      RABRACKET:	db '>' ; 3Eh
 15624 00003EF4 24                      DOLLAR:		db '$'
 15625 00003EF5 28                      LPAREN:		db '('
 15626 00003EF6 29                      RPAREN:		db ')'
 15627 00003EF7 29                      NULLRPAREN:	db ')' ; 29h
 15628 00003EF8 00                      		db 0
 15629 00003EF9 494E                    IN_WORD:	db 'I','N'
 15630 00003EFB 444F                    DO_WORD	:	db 'D','O'
 15631 00003EFD 2A                      STAR:		db '*'
 15632 00003EFE 2D                      CHAR_SUB:	db '-' 
 15633 00003EFF 2B                      PLUS_CHR:	db '+'
 15634 00003F00 4C                      CHAR_L:		db 'L'
 15635 00003F01 6C                      char_l:		db 'l'
 15636 00003F02 61                      small_a:	db 'a'
 15637 00003F03 7A                      small_z:	db 'z'
 15638 00003F04 44                      CHAR_D:		db 'D'
 15639 00003F05 43                      CHAR_C:		db 'C'
 15640 00003F06 53                      CHAR_S:		db 'S'
 15641 00003F07 58                      CHAR_X:		db 'X'
 15642 00003F08 2E                      DOT_CHR:	db '.' 
 15643 00003F09 3F2E                    DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15644 00003F0B 2C                      		db ','
 15645 00003F0C 3A2E                    TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15646 00003F0E 70                      MNCHR:		db 'p'
 15647 00003F0F 00                      SYSTEM_CPAGE:	db 0
 15648 00003F10 00                      		db 0
 15649                                  
 15650 00003F11 2E434F4D                COMEXT:		db '.COM'
 15651 00003F15 2E455845                EXEEXT:		db '.EXE'
 15652 00003F19 2E424154                BATEXT:		db '.BAT'
 15653 00003F1D 5642415057              SWITCH_LIST:	db 'VBAPW'
 15654 00003F22 2000                    BATBUFLEN:	dw BATLEN ; 32
 15655                                  
 15656                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15657                                  
 15658                                  TRANDATAEND:
 15659                                  
 15660                                  ;============================================================================
 15661                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15662                                  ;============================================================================
 15663                                  ; 29/09/2018 - Retro DOS v3.0
 15664                                  
 15665                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15666                                  
 15667                                  ;The TRANSPACE segment contains variable data that is considered
 15668                                  ;volatile between command cycles, and therefore is not included in the
 15669                                  ;transient checksum area. Contents of these variables MUST be
 15670                                  ;initialized before use, and must not be relied upon from command
 15671                                  ;cycle to command cycle.
 15672                                  ;
 15673                                  ;No constant data values should be stored here.
 15674                                  
 15675                                  ; ---------------------------------------------------------------------------
 15676                                  ; START OF UNITIALIZED DATA
 15677                                  ; ---------------------------------------------------------------------------	
 15678                                  
 15679                                  ;	times 12 db 0
 15680                                  
 15681 00003F24 90<rep Ch>              align 16
 15682                                  
 15683                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15684                                  
 15685 00003F30 00                      PRINTF_LEFT:	db 0
 15686 00003F31 00                      PRINTF_LONG:	db 0
 15687 00003F32 00                      PRINTF_HEX:	db 0
 15688 00003F33 00                      TABLE_INDEX:	db 0
 15689 00003F34 0000                    PRINTF_WIDTH:	dw 0
 15690 00003F36 0000                    PRINTF_BASE:	dw 0
 15691 00003F38 00                      PAD_CHAR:	db 0
 15692 00003F39 0000                    PRINTF_HANDLE:	dw 0
 15693 00003F3B 00<rep 64h>             PRINTF_BUF: times 100 db 0
 15694                                  PRINTF_BUF_END: ; 30/09/2018
 15695                                  
 15696                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15697                                  
 15698 00003F9F 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15699 00003FF6 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15700 0000404D 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15701 000040D0 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15702 00004153 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15703 00004199 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15704 0000421C 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15705                                  
 15706                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15707 0000426F 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15708 00004271 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15709 00004273 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15710 00004275 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15711 00004276 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15712 00004277 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15713                                  					; MYSEG1    (dw 0)	
 15714 0000427B 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15715                                  					; MYSEG2    (dw 0)	
 15716 0000427F 0000                    		dw 0			; RESTEST   (dw 0)	
 15717 00004281 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15718                                  
 15719 00004283 00                      CHKDRV:		db 0
 15720                                  IFNOTFLAG:
 15721                                  FILTYP:
 15722 00004284 00                      RDEOF:		db 0			; Misc flags
 15723 00004285 00                      CURDRV:		db 0
 15724                                  PARM1:
 15725 00004286 00                      CONCAT:		db 0
 15726                                  PARM2:
 15727 00004287 00                      ARGC:		db 0
 15728 00004288 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15729 0000428A 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15730                                  ARG2S:					; Switches after 2nd arg		
 15731 0000428C 0000                    DESTSWITCH:	dw 0
 15732                                  ARGTS:
 15733 0000428E 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15734 00004290 00                      CFLAG:		db 0
 15735                                  DESTCLOSED:
 15736 00004291 00                      SPECDRV:	db 0
 15737 00004292 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15738 00004294 0000                    NXTADD:		dw 0
 15739 00004296 00                      FRSTSRCH:	db 0
 15740                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15741                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15742 00004297 00                      LINCNT:		db 0
 15743 00004298 00                      LINLEN:		db 0
 15744                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15745 00004299 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15746                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15747                                  
 15748                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15749                                  ;
 15750                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15751                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15752                                  
 15753                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15754                                  
 15755 0000429B 00<rep 50h>             CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15756                                  DESTFCB2:
 15757 000042EB 00                      IDLEN:		db 0
 15758 000042EC 00<rep 8h>              ID:	  times	8  db 0
 15759 000042F4 00<rep 3h>              COM:	  times	3  db 0 
 15760 000042F7 00<rep 25h>             DEST:	  times 37 db 0
 15761 0000431C 00<rep Bh>              DESTNAME: times 11 db 0
 15762                                  DESTDIR:
 15763 00004327 00<rep 43h>             DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15764                                  GOTOLEN:	; word
 15765                                  BWDBUF: 	; byte
 15766                                  EXEFCB: 	; word
 15767 0000436A 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15768                                  
 15769                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15770                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15771                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15772                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15773                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15774                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15775                                  
 15776 000043B0 00<rep Ch>              SDIRBUF:  times 12 db 0	
 15777 000043BC 0000                    _BITS:		dw 0
 15778 000043BE 0000                    PATHCNT:	dw 0
 15779 000043C0 0000                    PATHPOS:	dw 0
 15780 000043C2 0000                    PATHSW:		dw 0
 15781                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15782                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15783 000043C4 00                      LINPERPAG:	db 0
 15784 000043C5 00                      		db 0
 15785 000043C6 00                      COMMA:		db 0			; flag set if +,, occurs
 15786 000043C7 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 15787                                  
 15788                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 15789                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 15790                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 15791                                  
 15792 000043C8 00<rep 80h>             ARG_BUF:  times 128 db 0   ; _43E8h	
 15793 00004448 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 15794 0000444A 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 15795 0000444C 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 15796 0000444E 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 15797                                  
 15798 00004450 0000                    COPY_NUM:	dw 0
 15799 00004452 00<rep 4h>              	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 15800 00004456 00                      CPYFLAG:	db 0
 15801 00004457 0000                    DIR_NUM:	dw 0
 15802 00004459 0000                    BYTES_FREE:	dw 0
 15803 0000445B 0000                    		dw 0
 15804 0000445D 0000                    MAJOR_VER_NUM:	dw 0
 15805 0000445F 0000                    MINOR_VER_NUM:	dw 0
 15806 00004461 00                      ONE_CHAR_VAL:	db 0
 15807                                  		;db 0
 15808 00004462 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 15809 00004464 00                      VOL_DRV:	db 0
 15810 00004465 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 15811                                  
 15812 00004467 00                      ROM_CALL:	db 0			; flag for rom function
 15813 00004468 0000                    ROM_IP:		dw 0
 15814 0000446A 0000                    ROM_CS:		dw 0
 15815                                  
 15816                                  DESTVARS:
 15817 0000446C 00                      DESTISDIR:	db 0
 15818 0000446D 00                      DESTSIZ:	db 0
 15819 0000446E 0000                    DESTTAIL:	dw 0
 15820 00004470 00                      DESTINFO:	db 0
 15821 00004471 00<rep 57h>             DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 15822                                  ENDDESTBUF:
 15823                                  
 15824 000044C8 0000                    DESTHAND:	dw 0
 15825 000044CA 00                      DESTISDEV:	db 0
 15826 000044CB 00                      FIRSTDEST:	db 0
 15827 000044CC 00                      MELCOPY:	db 0
 15828 000044CD 0000                    MELSTART:	dw 0
 15829                                  
 15830                                  SRCVARS:
 15831 000044CF 00                      SRCISDIR:	db 0
 15832 000044D0 00                      SRCSIZ:		db 0
 15833 000044D1 0000                    SRCTAIL:	dw 0
 15834 000044D3 00                      SRCINFO:	db 0
 15835 000044D4 00<rep 57h>             SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 15836                                  
 15837 0000452B 0000                    SRCHAND:	dw 0
 15838 0000452D 00                      SRCISDEV:	db 0
 15839                                  
 15840 0000452E 00<rep 57h>             SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 15841                                  
 15842 00004585 0000                    SRCPT:		dw 0
 15843 00004587 00                      INEXACT:	db 0
 15844 00004588 00                      		db 0 ; MSDOS 3.3 
 15845 00004589 00                      NOWRITE:	db 0
 15846 0000458A 00                      BINARY:		db 0
 15847 0000458B 0000                    WRITTEN:	dw 0
 15848 0000458D 00                      TERMREAD:	db 0
 15849 0000458E 00                      ASCII:		db 0
 15850 0000458F 00                      PLUS:		db 0
 15851 00004590 00                      OBJCNT:		db 0			; Used in copy
 15852 00004591 0000                    CPDATE:		dw 0
 15853 00004593 0000                    CPTIME:		dw 0
 15854                                  
 15855                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 15856                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 15857                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 15858                                  
 15859 00004595 0000                    BATHAND:	dw 0			; Batch handle
 15860 00004597 0000                    STARTEL:	dw 0
 15861 00004599 00                      ELCNT:		db 0
 15862 0000459A 00                      ELPOS:		db 0
 15863 0000459B 00<rep Bh>              SOURCE:   times	11 db 0
 15864                                  
 15865 000045A6 00                      ext_entered:	db 0			;AN005;
 15866                                  
 15867                                  ;display_ioctl	db 0			;AN000; info level
 15868                                  ;		db 0			;AN000; reserved
 15869                                  ;		dw crt_ioctl_ln		;AN000; length of data
 15870                                  ;		dw 0			;AN000; control flags
 15871                                  ;display_mode:	db 0			;AN000; display mode, colors
 15872                                  ;		db 0			;AN000; reserved
 15873                                  ;		dw 0			;AN023; colors
 15874                                  ;		dw 0			;AN000; display width (PELS)
 15875                                  ;		dw 0			;AN000; display length (PELS)
 15876                                  ;display_width:	dw 0			;AN000; display width
 15877                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 15878                                  ;
 15879                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 15880                                  ;		dw 0			;AN000; info level
 15881                                  ;vol_serial:	dd 0			;AN000; volume serial number
 15882                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 15883                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 15884                                  
 15885 000045A7 00                      EXPAND_STAR:	db 0
 15886                                  
 15887                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 15888                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 15889                                  ;append_exec:	db 0			;AN041; set if internal append executed
 15890                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 15891                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 15892                                  
 15893 000045A8 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 15894                                  
 15895                                  ; Data declarations taken out of parse.asm
 15896                                  
 15897                                  ; MSDOS 6.0
 15898                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 15899                                  ;argbufptr	dw	?		; index for argv[].argpointer
 15900                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 15901                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 15902                                  ;comptr		dw	?		; ptr into combuf
 15903                                  
 15904                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 15905                                  ARG:
 15906                                  ARG_ARGV:
 15907 000045A9 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 15908 000045AB 00                      ARGV0_ARG_FLAGS:  db 0
 15909 000045AC 0000                    ARGV0_ARGSTARTEL: dw 0
 15910 000045AE 0000                    ARGV0_ARGLEN:	  dw 0
 15911 000045B0 0000                    ARGV0_ARGSW_WORD: dw 0
 15912 000045B2 0000                    ARGV0_OCOMPTR:	  dw 0
 15913                                  
 15914 000045B4 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 15915 000045B6 00<rep 5h>              	  times 5 db 0
 15916 000045BB 0000                    ARGV1_ARGSW_WORD: dw 0
 15917 000045BD 0000                    		  dw 0
 15918                                  
 15919 000045BF 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 15920 000045C1 00<rep 5h>              	  times 5 db 0
 15921 000045C6 0000                    ARGV2_ARGSW_WORD: dw 0
 15922 000045C8 0000                    		  dw 0
 15923                                  
 15924 000045CA 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 15925                                  	
 15926 00004869 0000                    ARG_ARGVCNT:	dw 0
 15927 0000486B 0000                    ARG_ARGSWINFO:	dw 0
 15928                                  
 15929 0000486D 0000<rep 100h>          ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 15930 00004A6D 00<rep 80h>             ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 15931                                  
 15932                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 15933                                  
 15934 00004AED 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 15935 00004AEF 00<rep 80h>             TPBUF:    times 128 db 0		; temporary buffer
 15936 00004B6F 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 15937 00004B71 0000                    COMPTR:		dw 0			; ptr into combuf
 15938                                  
 15939                                  ; Data declarations taken out of path.asm
 15940                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 15941                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 15942                                  ;psep_char	DB	?			; '/' or '\'
 15943                                  ;search_best	DB	(?)			; best code, best filename so far
 15944                                  ;fname_max_len	equ	13
 15945                                  ;search_best_buf DB	fname_max_len DUP (?)
 15946                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 15947                                  ;search_error	DW	(?)			; address of error message to be printed
 15948                                  
 15949                                  FINDBUFLEN equ FIND_BUF.size ; 43
 15950                                  
 15951                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 15952                                  
 15953 00004B73 00<rep 2Bh>             FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 15954                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 15955                                  PATHINFO:
 15956 00004B9E 0000                    PATHINFO_0:	dw 0
 15957 00004BA0 0000                    PATHINFO_2:	dw 0
 15958 00004BA2 0000                    PATHINFO_4:	dw 0
 15959 00004BA4 00                      PSEP_CHAR:	db 0
 15960 00004BA5 00                      SEARCH_BEST:	db 0
 15961                                  ;FNAME_MAX_LEN equ 13
 15962 00004BA6 00<rep Dh>              SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 15963 00004BB3 00<rep 40h>             SEARCH_CURDIR_BUF: times 64 db 0
 15964 00004BF3 0000                    SEARCH_ERROR:	dw 0
 15965                                  
 15966                                  ; Data declarations taken out of tbatch.asm
 15967                                  
 15968                                  ;if_not_count	DW	?
 15969                                  ;
 15970                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 15971                                  ;
 15972                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 15973                                  ;STACK		LABEL	WORD
 15974                                  
 15975                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 15976                                  
 15977 00004BF5 0000                    IF_NOT_COUNT:	dw 0
 15978 00004BF7 00                      ZFLAG:		db 0
 15979 00004BF8 00<rep 100h>            	  times 256 db 0 	
 15980                                  STACK:
 15981                                  
 15982                                  ;INTERNATVARS	internat_block <>
 15983                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 15984                                  ;
 15985                                  ;;		Buffer for DOS function 64h (Get extended country information)
 15986                                  ;;		subfunctions 2, 4, 6, or 7:
 15987                                  ;
 15988                                  ;CountryPtrInfo	label	byte
 15989                                  ;CountryPtrId	db	?
 15990                                  ;CountryPtr	dd	?
 15991                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 15992                                  
 15993                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 15994                                  
 15995                                  INTERNATVARS:	
 15996 00004CF8 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 15997 00004CFA 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 15998 00004CFF 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 15999 00004D01 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 16000 00004D03 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 16001 00004D05 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 16002 00004D07 00                      BIT_FIELD:	db 0			; Bit values
 16003                                  					;   Bit 0 = 0 if currency symbol first
 16004                                  					;	  = 1 if currency symbol last
 16005                                  					;   Bit 1 = 0 if No space after currency symbol
 16006                                  					;	  = 1 if space after currency symbol
 16007 00004D08 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16008 00004D09 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16009 00004D0A 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16010                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16011                                  					;  in pieces.
 16012 00004D0E 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16013                                  
 16014 00004D10 00<rep 8h>              		times 8 db 0
 16015                                  ;
 16016                                  ; Max size of the block returned by the INTERNATIONAL call
 16017                                  ;
 16018                                  INTERNAT_BLOCK_SIZE EQU	32
 16019                                  
 16020                                  BATLEN equ 32
 16021                                  	
 16022                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16023                                  
 16024 00004D18 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16025                                  
 16026 00004D1A 00<rep 20h>             BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16027                                  
 16028 00004D3A 0000                    BATBUFEND:	dw 0
 16029                                  
 16030                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16031                                  
 16032                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
