     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 25/02/2023 ((Prev: 20/10/2018))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   309 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   315 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   316 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 ??                      .ISDIR:		RESB	1
   623 00000001 ??                      .SIZ:		RESB	1
   624 00000002 ????                    .TTAIL:		RESW	1
   625 00000004 ??                      .INFO:		RESB	1
   626 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 ??                      .BatType:	RESB	1		; signature
   660 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   691 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   735 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   736 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   737 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   738 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   739 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   740 00000015 ??                      .ATTR:	    resb 1	; attribute found
   741 00000016 ????                    .TIMR:	    resw 1	; time
   742 00000018 ????                    .DATE:	    resw 1	; date
   743 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   744 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   745 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 ??                                      resb 1
   766 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   768 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   782 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 ????                    .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 ??????????              .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 ????                    .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 ????                    .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B ????                    .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D ????                    .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F ??                      .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 ??                      .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 ??                      .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 ????                    .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 ????                                      RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 ????                    .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 ????                      .owner:	resw 1		; owner of arena item
   917 00000003 ????                      .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  ;LODCOM1   equ	0318h	; 13/10/2018
   962                                  LODCOM1    equ	0319h	; 24/02/2023
   963                                  
   964                                  ; EXEC call adressses in resident portion for calling from transient portion
   965                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   966                                  
   967                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   968                                  ;PUTBACKDRV equ	0A21h	; 14/10/2018
   969                                  PUTBACKDRV equ	0A23h	; 24/02/2023
   970                                  
   971                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   972                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   973                                  
   974                                  ; Resident portion stack address  
   975                                  ;RSTACK	   equ	083Ch
   976                                  RSTACK	   equ	083Eh	; 24/02/2023 
   977                                  
   978                                  ;RETRABASE equ  0B86h	; 13/10/2018 (Base addr for following common params.)
   979                                  RETRABASE  equ  0B88h	; 24/02/2023	
   980                                  
   981                                  ; RESGROUP       [RESSEG]
   982                                  ; DATA		  offset
   983                                  ; --------     	------------
   984                                  PARENT	  equ	RETRABASE+6	; 0B8Ch
   985                                  OLDTERM	  equ	RETRABASE+8	; 0B9Eh
   986                                  BATCH	  equ	RETRABASE+17	; 0B97h
   987                                  COMSPEC	  equ	RETRABASE+19	; 0B99h
   988                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD9h
   989                                  COMSPEC_END equ	RETRABASE+85	; 0BDBh
   990                                  IN_BATCH  equ	RETRABASE+92	; 0BE2h
   991                                  BATCH_ABORT equ	RETRABASE+93	; 0BE3h
   992                                  COMDRV	  equ	RETRABASE+94	; 0BE4h
   993                                  EXTCOM	  equ	RETRABASE+99	; 0BE9h
   994                                  RETCODE	  equ	RETRABASE+100	; 0BEAh
   995                                  ECHOFLAG  equ	RETRABASE+103	; 0BEDh
   996                                  SUPPRESS  equ	RETRABASE+104	; 0BEEh
   997                                  IO_SAVE	  equ	RETRABASE+105	; 0BEFh
   998                                  RESTDIR	  equ	RETRABASE+107	; 0BF1h
   999                                  PERMCOM	  equ	RETRABASE+108	; 0BF2h
  1000                                  SINGLECOM equ	RETRABASE+109	; 0BF3h
  1001                                  VERVAL	  equ	RETRABASE+111	; 0BF5h
  1002                                  IFFLAG	  equ	RETRABASE+114	; 0BF8h	
  1003                                  FORFLAG	  equ	RETRABASE+115	; 0BF9h
  1004                                  FORPTR	  equ	RETRABASE+116	; 0BFAh 	
  1005                                  NEST	  equ	RETRABASE+118	; 0BFCh
  1006                                  CALL_FLAG equ	RETRABASE+120	; 0BFEh
  1007                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFFh
  1008                                  NEXT_BATCH equ	RETRABASE+122 	; 0C00h
  1009                                  NULLFLAG  equ	RETRABASE+124	; 0C02h
  1010                                  UPPERCASETBL equ RETRABASE+126	; 0C04h
  1011                                  RE_OUT_APP equ	RETRABASE+130	; 0C08h
  1012                                  RE_OUTSTR equ	RETRABASE+131	; 0C09h
  1013                                  INITFLAG  equ	RETRABASE+211	; 0C59h	
  1014                                  PIPEFLAG  equ	RETRABASE+212	; 0C5Ah
  1015                                  PIPEFILES equ	RETRABASE+213	; 0C5Bh
  1016                                  PIPE1	  equ	RETRABASE+214	; 0C5Ch	
  1017                                  PIPE2	  equ	RETRABASE+230	; 0C6Ch
  1018                                  PIPEPTR	  equ	RETRABASE+246	; 0C7Ch
  1019                                  PIPESTR	  equ	RETRABASE+248	; 0C7Eh
  1020                                  INPIPEPTR equ	RETRABASE+377	; 0CFFh
  1021                                  OUTPIPEPTR equ	RETRABASE+379	; 0D01h
  1022                                  ENVIRSEG  equ	RETRABASE+381	; 0D03h
  1023                                  EXEC_BLOCK equ	RETRABASE+381 	; 0D03h  ; ENVIRSEG
  1024                                  LTPA	  equ	RETRABASE+399	; 0D15h
  1025                                  RES_TPA	  equ	RETRABASE+413	; 0D23h
  1026                                  
  1027                                  ;=============================================================================
  1028                                  					
  1029                                  ; (command3.s -> offset TRANGOUP)
  1030                                  
  1031                                  TRANGROUP:
  1032                                  
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; START OF TRANSIENT PORTION
  1035                                  ; ----------------------------------------------------------------------------
  1036                                  ; SEGMENT - TRANSCODE
  1037                                  ; ----------------------------------------------------------------------------
  1038                                  ; 13/10/2018 - Retro DOS v3.0
  1039                                  
  1040                                  ;[BITS 16]
  1041                                  ;[ORG 0]
  1042 00000000 00<rep 100h>            		times 256 db 0
  1043                                  
  1044                                  ;============================================================================
  1045                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1046                                  ;============================================================================
  1047                                  ; 12/10/2018 - Retro DOS v3.0
  1048                                  
  1049                                  ;[ORG 100h]
  1050                                  
  1051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1052                                  
  1053                                  ; ---------------------------------------------------------------------------
  1054                                  
  1055                                  SETDRV:					; Allow for 100H parameter area
  1056 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1057 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1058                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1059                                  				; Return: AL = number of logical drives
  1060                                  
  1061                                  ; ---------------------------------------------------------------------------
  1062                                  
  1063                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1064                                  ; No registers (CS:IP) no flags, nothing.
  1065                                  
  1066                                  TCOMMAND:
  1067 00000104 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  1068 00000109 B8FFFF                  		mov	ax,-1
  1069 0000010C 8706F70B                		xchg	ax,word [VERVAL]
  1070 00000110 83F8FF                  		cmp	ax,-1
  1071 00000113 7404                    		jz	short NOSETVER2
  1072 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1073 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1074                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1075                                  NOSETVER2:
  1076 00000119 2EFF1E[5F42]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1077 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1078 00000120 833EF50BFF              		cmp	word [SINGLECOM],-1
  1079 00000125 7505                    		jnz	short COMMAND
  1080                                  _$EXITPREP:
  1081 00000127 0E                      		push	cs
  1082 00000128 1F                      		pop	ds
  1083 00000129 E92415                  		jmp	_$EXIT		; Have finished the single command
  1084                                  
  1085                                  ; ---------------------------------------------------------------------------
  1086                                  ;
  1087                                  ; Main entry point from resident portion.
  1088                                  ;
  1089                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1090                                  ;   just beginning the processing of another command.
  1091                                  ;
  1092                                  ; ---------------------------------------------------------------------------
  1093                                  
  1094                                  ; We are not always sure of the state of the world at this time. We presume
  1095                                  ; worst case and initialize the relevant registers: segments and stack.
  1096                                  
  1097                                  COMMAND:
  1098 0000012C FC                      		cld
  1099 0000012D 8CC8                    		mov	ax,cs
  1100 0000012F FA                      		cli
  1101 00000130 8ED0                    		mov	ss,ax
  1102                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1103 00000132 BC[E84C]                		mov	sp,STACK
  1104 00000135 FB                      		sti
  1105                                  		
  1106 00000136 8EC0                    		MOV	ES,AX
  1107                                  		
  1108                                  		; MSDOS 6.0
  1109                                  		;MOV	DS,AX		;AN000; set DS to transient
  1110                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1111                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1112                                  		;mov	append_exec,0	;AN041; set internal append state off
  1113                                  
  1114                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1115 00000138 368E1E[6142]            		mov	ds,[ss:RESSEG]
  1116 0000013D 36C606[3D40]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1117 00000143 36C606[C040]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1118                                  
  1119                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1120                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1121                                  ; I guess not:  the only circumstances in which we reload the command processor
  1122                                  ; is after a transient program execution. In this case, we let the current
  1123                                  ; directory lie where it may.
  1124                                  
  1125 00000149 09ED                    		or	bp,bp		; See if just read
  1126 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1127 0000014D 36C706[3E40]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1128 00000154 EB17                    		jmp	short NOSETBUF
  1129                                  TESTRDIR:
  1130 00000156 803EF30B00              		cmp	byte [RESTDIR],0
  1131 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1132 0000015D 1E                      		push	ds
  1133                                  
  1134                                  ; We have an unusual situation to handle. The user *may* have changed his
  1135                                  ; directory as a result of an internal command that got aborted. Restoring it
  1136                                  ; twice may not help us: the problem may never go away. We just attempt it
  1137                                  ; once and give up.
  1138                                  
  1139 0000015E C606F30B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1140                                  
  1141                                  		; Restore users directory
  1142 00000163 0E                      		push	cs
  1143 00000164 1F                      		pop	ds
  1144 00000165 BA[4341]                		mov	dx,USERDIR1
  1145 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1146 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1147                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1148 0000016C 1F                      		pop	ds
  1149                                  NOSETBUF:
  1150 0000016D 803E5D0C00              		cmp	byte [PIPEFILES],0
  1151 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1152 00000174 803E5C0C00              		cmp	byte [PIPEFLAG],0
  1153 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1154 0000017B E8921D                  		call	PIPEDEL
  1155                                  NOPCLOSE:
  1156                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1157 0000017E C606EB0B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1158 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1159 00000185 8ED8                    		mov	ds,ax
  1160 00000187 50                      		push	ax
  1161 00000188 BA[E84C]                		mov	dx,INTERNATVARS
  1162 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1163 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1164                                  				; get current-country info
  1165                                  				; DS:DX	-> buffer for returned info
  1166 00000190 58                      		pop	ax
  1167 00000191 2B06[6342]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1168 00000195 53                      		push	bx
  1169 00000196 BB1000                  		mov	bx,16
  1170 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1171 0000019B 5B                      		pop	bx
  1172 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1173 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1174 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1175                                  SAVSIZ:
  1176                                  
  1177                                  ; AX is the number of bytes free in the buffer between the resident and the
  1178                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1179                                  
  1180 000001A3 3D0002                  		cmp	ax,512
  1181 000001A6 7603                    		jbe	short GOTSIZE
  1182                                  		;and	ax,~1FFh
  1183 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1184                                  GOTSIZE:
  1185 000001AB A3[8242]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1186 000001AE 8E1E[6142]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1187                                  
  1188 000001B2 F606EF0B01              		test	byte [ECHOFLAG],1 
  1189 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1190 000001B9 E8331D                  		call	SINGLETEST
  1191 000001BC 7219                    		jb	short GETCOM
  1192 000001BE F6065C0CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1193 000001C3 7512                    		jnz	short GETCOM
  1194                                  					; G  Don't print prompt in FOR
  1195 000001C5 F606FB0BFF              		test	byte [FORFLAG],0FFh ; -1
  1196 000001CA 750B                    		jnz	short GETCOM
  1197                                  					; G  Don't print prompt if in batch
  1198 000001CC F706990BFFFF            		test	word [BATCH],0FFFFh ; -1
  1199 000001D2 7503                    		jnz	short GETCOM
  1200 000001D4 E89517                  		call	CRLF2
  1201                                  GETCOM:
  1202 000001D7 C606000C00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1203 000001DC C606010C00              		mov	byte [CALL_BATCH_FLAG],0
  1204 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1205 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1206 000001E5 36A2[7542]              		mov	[ss:CURDRV],al
  1207 000001E9 F6065C0CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1208 000001EE 7403                    		jz	short NOPIPE
  1209 000001F0 E9BF1D                  		jmp	PIPEPROC	; Continue the pipeline
  1210                                  NOPIPE:
  1211 000001F3 F606EF0B01              		test	byte [ECHOFLAG],1
  1212 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1213 000001FA E8F21C                  		call	SINGLETEST
  1214 000001FD 7212                    		jb	short NOPDRV
  1215 000001FF F606FB0BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1216 00000204 750B                    		jnz	short NOPDRV
  1217 00000206 F706990BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1218 0000020C 750D                    		jnz	short TESTFORBAT
  1219 0000020E E87911                  		call	PRINT_PROMPT	; Prompt the user
  1220                                  NOPDRV:
  1221 00000211 F606FB0BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1222 00000216 7403                    		jz	short TESTFORBAT
  1223 00000218 E9FE09                  		jmp	FORPROC		; Continue the FOR
  1224                                  
  1225                                  TESTFORBAT:
  1226 0000021B 36C606[0C42]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1227 00000221 C6060B0C00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1228 00000226 C6060A0C00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1229 0000022B C606FA0B00              		mov	byte [IFFLAG],0	; no more ifs...
  1230 00000230 F706990BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1231 00000236 7429                    		jz	short ISNOBAT
  1232                                  
  1233                                  		; MSDOS 6.0
  1234                                  
  1235                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1236                                  
  1237                                  		;push	es			;AN000; save ES
  1238                                  		;push	ds			;AN000; save DS
  1239                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1240                                  		;mov	es,[batch]		;AN000; get batch segment
  1241                                  		;mov	di,batfile		;AN000; get batch file name
  1242                                  		;push	cs			;AN000; get local segment to DS
  1243                                  		;pop	ds			;AN000;
  1244                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1245                                  		;int	2fh			;AN000; call the shell
  1246                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1247                                  		;pop	ds			;AN000; restore DS
  1248                                  		;pop	es			;AN000; restore ES
  1249                                  		;jz	jdocom1 		;AN000; yes - go process command
  1250                                  
  1251                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1252 00000238 1E                      		push	ds
  1253 00000239 E8BC02                  		call	READBAT			; Continue BATCH
  1254 0000023C 1F                      		pop	ds
  1255 0000023D C606040C00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1256 00000242 F706990BFFFF            		test	word [BATCH],0FFFFh
  1257 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1258 0000024A 8B1E020C                		mov	bx,word [NEXT_BATCH]
  1259 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1260 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1261 00000253 891E990B                		mov	word [BATCH],bx		;G get segment of next batch file
  1262 00000257 C706020C0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1263                                  JDOCOM1:
  1264 0000025D 0E                      		push	cs
  1265 0000025E 1F                      		pop	ds
  1266 0000025F EB4C                    		jmp	short DOCOM1
  1267                                  
  1268 00000261 833EF50B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1269 00000266 741C                    		jz	short REGCOM
  1270                                  		;MOV	SI,[SEMIPERMCOM] ;  MSDOS 6.0
  1271 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1272 0000026B 8736F50B                		xchg	si,word [SINGLECOM]
  1273 0000026F BF[C240]                		mov	di,COMBUF+2
  1274 00000272 31C9                    		xor	cx,cx
  1275                                  SINGLELOOP:
  1276 00000274 AC                      		lodsb
  1277 00000275 AA                      		stosb
  1278 00000276 41                      		inc	cx
  1279 00000277 3C0D                    		cmp	al,0Dh
  1280 00000279 75F9                    		jnz	short SINGLELOOP
  1281 0000027B 49                      		dec	cx
  1282 0000027C 0E                      		push	cs
  1283 0000027D 1F                      		pop	ds
  1284 0000027E 880E[C140]              		mov	[COMBUF+1],cl
  1285                                  
  1286                                  ; do NOT issue a trailing CRLF...
  1287                                  
  1288 00000282 EB29                    		jmp	short DOCOM1
  1289                                  
  1290                                  		;nop
  1291                                  
  1292                                  ; We have a normal command.  
  1293                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1294                                  ; sometimes they aren't. At this point, we automatically close all spool
  1295                                  ; files and turn on truncation mode.
  1296                                  
  1297                                  REGCOM:
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1299                                  		;mov	ax,5D09h
  1300 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1301 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1302                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1303                                  		;mov	ax,5D08h
  1304 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1305 0000028C B201                    		mov	dl,1
  1306 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1307                                  				; DL = 00h redirected output is	combined
  1308                                  				;      01h redirected output placed in separate	jobs
  1309                                  				; start	new print job now
  1310 00000290 0E                      		push	cs
  1311 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1312 00000292 BA[3D40]                		mov	dx,UCOMBUF
  1313                                  
  1314                                  		; MSDOS 6.0
  1315                                  ;	Try to read interactive command line via DOSKey.
  1316                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1317                                  
  1318                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1319                                  		;int	2fh
  1320                                  		;or	ax,ax
  1321                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1322                                  
  1323                                  		;mov	ah,0Ah
  1324 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1325 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1326                                  				; DS:DX	-> buffer
  1327                                  ;GOTCOM:
  1328 00000299 8A0E[3D40]              		mov	cl,[UCOMBUF]
  1329 0000029D 30ED                    		xor	ch,ch
  1330 0000029F 83C103                  		add	cx,3
  1331 000002A2 BE[3D40]                		mov	si,UCOMBUF
  1332 000002A5 BF[C040]                		mov	di,COMBUF
  1333 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1334                                  DOCOM:
  1335 000002AA E8BF16                  		call	CRLF2
  1336                                  DOCOM1:
  1337 000002AD E87919                  		call	PRESCAN		; Cook the input buffer
  1338 000002B0 7406                    		jz	short NOPIPEPROC
  1339 000002B2 E9A51C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1340                                  
  1341                                  NULLCOMJ:
  1342 000002B5 E9FA00                  		jmp	NULLCOM
  1343                                  
  1344                                  NOPIPEPROC:
  1345 000002B8 E8E520                  		call	PARSELINE
  1346 000002BB 730B                    		jnb	short OKPARSE	; user error?  or maybe we goofed?
  1347                                  BADPARSE:
  1348 000002BD 0E                      		push	cs
  1349 000002BE 1F                      		pop	ds
  1350 000002BF BA[AB37]                		mov	dx,BADNAMPTR
  1351 000002C2 E8F531                  		call	STD_EPRINTF
  1352 000002C5 E93CFE                  		jmp	TCOMMAND
  1353                                  
  1354                                  OKPARSE:
  1355                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1356 000002C8 F606[9B45]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1357 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1358                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1359 000002CF 833E[5948]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1360 000002D4 74DF                    		jz	short NULLCOMJ
  1361                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1362 000002D6 833E[9E45]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1363 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1364                                  
  1365 000002DD BE[C240]                		mov	si,COMBUF+2
  1366 000002E0 BF[DB42]                		mov	di,IDLEN
  1367                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1368                                  					; Make FCB with blank scan-off
  1369 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1370                                  		;mov	ax,2901h
  1371 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1372                                  				; DS:SI	-> string to parse
  1373                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1374                                  				; AL = bit mask	to control parsing
  1375                                  		;mov	bx,[ARG_ARGV]
  1376 000002E8 8B1E[9945]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1377 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1378 000002F0 751C                    		jne	short DRVGD	; no, use default of zero...
  1379 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1380                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1381                                  		;and	dl,~20h
  1382 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1383 000002F7 2A16[E03E]              		sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1384 000002FB 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1385 000002FD 740C                    		jz	short DRVBADJ	; It was invalid.
  1386                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1387 000002FF 8B3E[9C45]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1388 00000303 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1389 00000306 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1390 00000308 E9F5FD                  		jmp	SETDRV		; and set drive to new drive spec
  1391                                  DRVBADJ:
  1392 0000030B E9CA17                  		jmp	DRVBAD
  1393                                  DRVGD:
  1394 0000030E 8A05                    		mov	al,[di]
  1395 00000310 A2[8142]                		mov	[SPECDRV],al
  1396 00000313 B020                    		mov	al,' '
  1397 00000315 B90900                  		mov	cx,9
  1398 00000318 47                      		inc	di
  1399 00000319 F2AE                    		repne scasb		; Count number of letters in command name
  1400 0000031B B008                    		mov	al,8
  1401 0000031D 28C8                    		sub	al,cl
  1402 0000031F A2[DB42]                		mov	[IDLEN],al	; IDLEN is truly the length
  1403 00000322 BF8100                  		mov	di,81h
  1404 00000325 56                      		push	si
  1405 00000326 BE[C240]                		mov	si,COMBUF+2	; Skip over all leading delims
  1406 00000329 E84D16                  		call	SCANOFF
  1407                                  
  1408                                  		; MSDOS 6.0
  1409                                  ;SR;
  1410                                  ; We are going to skip over the first char always. The logic is that the
  1411                                  ;command tail can never start from the first character. The code below is 
  1412                                  ;trying to figure out the command tail and copy it to the command line 
  1413                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1414                                  ;character and the user given command line is a full 128 bytes, we try to
  1415                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1416                                  ;char overwrites the code and leads to a crash on future commands.
  1417                                  ;
  1418                                  		;inc	si ;  MSDOS 6.0
  1419                                  DO_SKIPCOM:
  1420 0000032C AC                      		lodsb			; move command line pointer over
  1421 0000032D E85116                  		call	DELIM		; pathname -- have to do it ourselves
  1422 00000330 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1423 00000332 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1424 00000334 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1425 00000336 3A06[6542]              		cmp	al,[SWITCHAR]	; specified command string
  1426 0000033A 75F0                    		jnz	short DO_SKIPCOM 
  1427                                  DO_SKIPPED:
  1428 0000033C 4E                      		dec	si
  1429 0000033D 31C9                    		xor	cx,cx
  1430                                  COMTAIL:
  1431 0000033F AC                      		lodsb
  1432 00000340 AA                      		stosb			; Move command tail to 80h
  1433 00000341 3C0D                    		cmp	al,0Dh
  1434 00000343 E0FA                    		loopne	COMTAIL
  1435 00000345 4F                      		dec	di
  1436 00000346 89FD                    		mov	bp,di
  1437 00000348 F6D1                    		not	cl
  1438 0000034A 880E8000                		mov	[80h],cl
  1439 0000034E 5E                      		pop	si
  1440                                  ;-----
  1441                                  ; Some of these comments are sadly at odds with this brave new code.
  1442                                  ;-----
  1443                                  ; If the command has 0 parameters must check here for
  1444                                  ; any switches that might be present.
  1445                                  ; SI -> first character after the command.
  1446                                  
  1447                                  		;mov	di, arg.argv[0].argsw_word
  1448                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1449 0000034F 8B3E[A045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1450 00000353 893E[7842]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1451                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1452                                  					; s = argv[1];
  1453                                  		;mov	si,[ARGV1_ARGPOINTER]
  1454 00000357 8B36[A445]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1455 0000035B 09F6                    		or	si,si		;   if (s == NULL)
  1456 0000035D 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1457 0000035F 89EE                    		mov	si,bp
  1458                                  DOPARSE:
  1459 00000361 BF5C00                  		mov	di,FCB ; 5Ch
  1460                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1461                                  		;mov	ax,2901h
  1462 00000364 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1463 00000367 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1464                                  				; DS:SI	-> string to parse
  1465                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1466                                  				; AL = bit mask	to control parsing
  1467 00000369 A2[7642]                		mov	[PARM1],al	; Save result of parse
  1468                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1469                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1470 0000036C 8B3E[AB45]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1471 00000370 893E[7A42]              		mov	[ARG1S],di
  1472                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1473                                  					; s = argv[2];
  1474                                  		;mov	si,[ARGV2_ARGPOINTER]
  1475 00000374 8B36[AF45]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1476 00000378 09F6                    		or	si,si		;   if (s == NULL)
  1477 0000037A 7502                    		jnz	short DOPARSE2
  1478 0000037C 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1479                                  DOPARSE2:			
  1480 0000037E BF6C00                  		mov	di,FCB+10H ; 6Ch
  1481                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1482                                  		;mov	ax,2901h
  1483 00000381 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1484 00000384 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1485                                  				; DS:SI	-> string to parse
  1486                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1487                                  				; AL = bit mask	to control parsing
  1488 00000386 A2[7742]                		mov	[PARM2],al	; Save result
  1489                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1490                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1491 00000389 8B3E[B645]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1492 0000038D 893E[7C42]              		mov	[ARG2S],di
  1493                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1494                                  		;mov	di,arg.argv[0].argsw_word
  1495 00000391 8B3E[A045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1496 00000395 F7D7                    		not	di		; ARGTS doesn't include the flags
  1497                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1498                                  		;and	di,arg.argswinfo	
  1499 00000397 233E[5B48]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1500 0000039B 893E[7E42]              		mov	[ARGTS],di
  1501                                  
  1502 0000039F A0[DB42]                		mov	al,[IDLEN]
  1503 000003A2 8A16[8142]              		mov	dl,[SPECDRV]
  1504 000003A6 08D2                    		or	dl,dl		; if a drive was specified...
  1505 000003A8 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1506 000003AA FEC8                    		dec	al		; (I don't know why -- old code did it)
  1507 000003AC E93217                  		jmp	FNDCOM		; otherwise, check internal com table
  1508                                  EXTERNALJ1:
  1509 000003AF E9E017                  		jmp	EXTERNAL
  1510                                  NULLCOM:
  1511 000003B2 8E1E[6142]              		mov	ds,[RESSEG]
  1512 000003B6 F706990BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1513 000003BC 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1514                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1515 000003BE C606040C01              		mov	byte [NULLFLAG],nullcommand ; 1
  1516                                  NOSETFLAG:
  1517 000003C3 833EF50BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1518 000003C8 7403                    		jz	short EXITJ
  1519 000003CA E90AFE                  		jmp	GETCOM
  1520                                  EXITJ:
  1521 000003CD E957FD                  		jmp	_$EXITPREP
  1522                                  
  1523                                  ;============================================================================
  1524                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1525                                  ;============================================================================
  1526                                  ; 12/10/2018 - Retro DOS v3.0
  1527                                  
  1528                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1529                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1530                                  ;   there is a header that describes a block of rom program.  This header
  1531                                  ;   contains information needed to initialize a module and to provide PCDOS
  1532                                  ;   with a set of reserved names for execution.
  1533                                  ;
  1534                                  ;   This header has the following format:
  1535                                  ;
  1536                                  ;   rom_header	STRUC
  1537                                  ;	Signature1  DB	55h
  1538                                  ;	Signature2  DB	AAh
  1539                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1540                                  ;	init_jmp    DB	3 dup (?)
  1541                                  ;	name_list   name_struc <>
  1542                                  ;   rom_header	ENDS
  1543                                  ;
  1544                                  ;   name_struc	STRUC
  1545                                  ;	name_len    DB	?
  1546                                  ;	name_text   DB	? DUP (?)
  1547                                  ;	name_jmp    DB	3 DUP (?)
  1548                                  ;   name_struc	ENDS
  1549                                  ;
  1550                                  ;   The name list is a list of names that are reserved by a particular section
  1551                                  ;   of a module.  This list of names is terminated by a null name (length
  1552                                  ;   is zero).
  1553                                  ;
  1554                                  ;   Consider now, the PCDOS action when a user enters a command:
  1555                                  ;
  1556                                  ;	COMMAND.COM has control.
  1557                                  ;	o   If location FFFFEh has FDh then
  1558                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1559                                  ;		    by AAh, stop scan if we get above or = F0000H
  1560                                  ;	o	When we've found one, compare the name entered by the user
  1561                                  ;		    with the one found in the rom.  If we have a match, then
  1562                                  ;		    set up the environment for execution and do a long jump
  1563                                  ;		    to the near jump after the found name.
  1564                                  ;	o	If no more names in the list, then continue scanning the module
  1565                                  ;		    for more 55h followed by AAh.
  1566                                  ;	o   We get to this point only if there is no matching name in the
  1567                                  ;		rom.  We now look on disk for the command.
  1568                                  ;
  1569                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1570                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1571                                  ;   want to be invisible to the DOS should not have any names in their lists
  1572                                  ;   (i.e. they have a single null name).
  1573                                  ;
  1574                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1575                                  ;   Clearly this version will be available on disk.  How does a user actually
  1576                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1577                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1578                                  ;   solution:
  1579                                  ;
  1580                                  ;   o	Keep things consistent and force the user to have his software named
  1581                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1582                                  
  1583                                  struc ROM_HEADER
  1584 00000000 ??                          .signature1: resb 1
  1585 00000001 ??                          .signature2: resb 1
  1586 00000002 ??                          .rom_length: resb 1
  1587 00000003 ??????                      .init_jmp:	 resb 3
  1588 00000006 ??                          .name_list:	 resb 1
  1589                                      .size:
  1590                                  endstruc
  1591                                  
  1592                                  struc NAME_STRUC
  1593 00000000 ??                          .name_len:	resb 1
  1594 00000001 ??                          .name_text:	resb 1
  1595 00000002 ??????                      .name_jmp:	resb 3
  1596                                      .size:	
  1597                                  endstruc
  1598                                  
  1599                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1600                                  
  1601                                  ; =============== S U B	R O U T	I N E =======================================
  1602                                  
  1603                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1604                                  
  1605                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1606                                  
  1607                                  ROM_SCAN:
  1608 000003D0 06                      		push	es
  1609 000003D1 56                      		push	si
  1610 000003D2 57                      		push	di
  1611 000003D3 51                      		push	cx
  1612 000003D4 50                      		push	ax
  1613 000003D5 53                      		push	bx
  1614                                  
  1615                                  		; check for PC Jr signature in rom
  1616                                  
  1617 000003D6 B800F0                  		mov	ax,0F000h
  1618 000003D9 8EC0                    		mov	es,ax
  1619 000003DB 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1620 000003E1 7408                    		je	short SCAN_IT
  1621                                  NO_ROM:
  1622 000003E3 F8                      		clc
  1623                                  ROM_RET:
  1624 000003E4 5B                      		pop	bx
  1625 000003E5 58                      		pop	ax
  1626 000003E6 59                      		pop	cx
  1627 000003E7 5F                      		pop	di
  1628 000003E8 5E                      		pop	si
  1629 000003E9 07                      		pop	es
  1630 000003EA C3                      		retn
  1631                                  
  1632                                  SCAN_IT:	; start scanning at C000h
  1633                                  
  1634 000003EB B800C0                  		mov	ax,0C000h
  1635                                  SCAN_ONE:
  1636 000003EE 8EC0                    		mov	es,ax
  1637 000003F0 31FF                    		xor	di,di
  1638                                  
  1639                                  SCAN_MODULE:	; check for a valid header
  1640                                  
  1641 000003F2 26813D55AA              		cmp	word [es:di],0AA55h
  1642 000003F7 740A                    		jz	short SCAN_LIST
  1643 000003F9 058000                  		add	ax,80h
  1644                                  SCAN_END:
  1645 000003FC 3D00F0                  		cmp	ax,0F000h
  1646 000003FF 72ED                    		jb	short SCAN_ONE
  1647 00000401 EBE0                    		jmp	short NO_ROM
  1648                                  
  1649                                  		; trundle down list of names
  1650                                  SCAN_LIST:
  1651                                  		;mov	bl,[es:di+2]
  1652                                  					; number of 512-byte jobbers
  1653 00000403 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1654 00000407 30FF                    		xor	bh,bh		; nothing in the high byte
  1655 00000409 D1E3                    		shl	bx,1
  1656 0000040B D1E3                    		shl	bx,1		; number of paragraphs
  1657 0000040D 83C37F                  		add	bx,7Fh
  1658 00000410 83E380                  		and	bx,0FF80h	; round to 2k	
  1659                                  		;mov	di,6
  1660 00000413 BF0200                  		mov	di,ROM_HEADER.rom_length
  1661                                  
  1662                                  		;nop
  1663                                  SCAN_NAME:
  1664 00000416 268A0D                  		mov	cl,[es:di]	; length of name
  1665 00000419 47                      		inc	di		; point to name
  1666 0000041A 30ED                    		xor	ch,ch
  1667 0000041C 09C9                    		or	cx,cx		; zero length name
  1668 0000041E 7504                    		jnz	short SCAN_TEST	; nope... compare
  1669 00000420 01D8                    		add	ax,bx		; yep, skip to next block
  1670 00000422 EBD8                    		jmp	short SCAN_END
  1671                                  
  1672                                  SCAN_TEST:	; compare a single name
  1673                                  
  1674 00000424 89D6                    		mov	si,dx
  1675 00000426 46                      		inc	si
  1676 00000427 F3A6                    		repe cmpsb		 ; compare name
  1677 00000429 7407                    		jz	short SCAN_FOUND ; success!
  1678                                  SCAN_NEXT:
  1679 0000042B 01CF                    		add	di,cx		; failure, next name piece
  1680 0000042D 83C703                  		add	di,3
  1681 00000430 EBE4                    		jmp	short SCAN_NAME
  1682                                  
  1683                                  SCAN_FOUND:	; found a name. save entry location
  1684                                  
  1685 00000432 803C3F                  		cmp	byte [si],'?'
  1686 00000435 7405                    		jz	short SCAN_SAVE
  1687 00000437 803C20                  		cmp	byte [si],' '
  1688 0000043A 75EF                    		jnz	short SCAN_NEXT
  1689                                  SCAN_SAVE:
  1690 0000043C 2E8C06[5A44]            		mov	[cs:ROM_CS],es
  1691 00000441 2E893E[5844]            		mov	[cs:ROM_IP],di
  1692 00000446 F9                      		stc
  1693 00000447 EB9B                    		jmp	short ROM_RET
  1694                                  
  1695                                  ; ---------------------------------------------------------------------------
  1696                                  
  1697                                  ; execute a rom-placed body of code. allocate largest block
  1698                                  
  1699                                  ROM_EXEC:
  1700 00000449 BBFFFF                  		mov	bx,0FFFFh
  1701 0000044C B448                    		mov	ah,ALLOC ; 48h
  1702 0000044E CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1703                                  				; BX = number of 16-byte paragraphs desired
  1704 00000450 B448                    		mov	ah,ALLOC ; 48h
  1705 00000452 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1706                                  				; BX = number of 16-byte paragraphs desired
  1707 00000454 53                      		push	bx
  1708 00000455 50                      		push	ax
  1709                                  
  1710                                  		; set terminate addresses
  1711                                  
  1712                                  		;mov	ax,2522h
  1713                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1714 00000456 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1715 00000459 1E                      		push	ds
  1716 0000045A 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  1717                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1718                                  		;mov	dx,131h ; MSDOS 3.3
  1719 0000045F BA3101                  		mov	dx,EXEC_WAIT
  1720 00000462 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1721                                  				; AL = interrupt number
  1722                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1723 00000464 8CDA                    		mov	dx,ds
  1724 00000466 8EC2                    		mov	es,dx
  1725 00000468 1F                      		pop	ds
  1726                                  		
  1727                                  		; and create program header and dup all jfn's
  1728                                  
  1729 00000469 5A                      		pop	dx
  1730 0000046A B455                    		mov	ah,DUP_PDB ; 55h
  1731 0000046C CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1732                                  				; DX = segment number at which to set up PSP
  1733                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1734                                  		
  1735                                  		; set up dma address
  1736                                  
  1737 0000046E 8EDA                    		mov	ds,dx
  1738 00000470 BA8000                  		mov	dx,80h
  1739 00000473 B41A                    		mov	ah,SET_DMA ; 1Ah
  1740 00000475 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1741                                  				; DS:DX	-> disk	transfer buffer
  1742                                  
  1743                                  		; copy in environment info
  1744                                  
  1745 00000477 26A1050D                		mov	ax,word [es:ENVIRSEG]
  1746 0000047B A32C00                  		mov	[PDB.ENVIRON],	ax
  1747                                  
  1748                                  		; set up correct size of block
  1749                                  
  1750 0000047E 5B                      		pop	bx		; BX has size, DS has segment
  1751 0000047F 8CDA                    		mov	dx,ds
  1752 00000481 01DA                    		add	dx,bx
  1753                                  		;mov	[2],dx
  1754 00000483 89160200                		mov	word [PDB.BLOCK_LEN],dx
  1755                                  
  1756                                  		; change ownership of block
  1757                                  
  1758 00000487 8CDA                    		mov	dx,ds
  1759 00000489 4A                      		dec	dx
  1760 0000048A 8EDA                    		mov	ds,dx
  1761 0000048C 42                      		inc	dx	
  1762                                  		;mov	[1],dx
  1763 0000048D 89160100                		mov	word [ARENA.owner],dx
  1764 00000491 8EDA                    		mov	ds,dx
  1765                                  
  1766                                  		; set up correct stack
  1767                                  
  1768 00000493 81FB0010                		cmp	bx,1000h
  1769 00000497 7202                    		jb	short GOT_STACK
  1770 00000499 31DB                    		xor	bx,bx
  1771                                  GOT_STACK:
  1772 0000049B B104                    		mov	cl,4
  1773 0000049D D3E3                    		shl	bx,cl
  1774 0000049F 8CDA                    		mov	dx,ds
  1775 000004A1 8ED2                    		mov	ss,dx
  1776 000004A3 89DC                    		mov	sp,bx
  1777 000004A5 31C0                    		xor	ax,ax
  1778 000004A7 50                      		push	ax
  1779                                  
  1780                                  		; set up initial registers and go to the guy
  1781                                  
  1782 000004A8 F7D0                    		not	ax
  1783 000004AA 2EFF36[5A44]            		push	word [cs:ROM_CS]
  1784 000004AF 2EFF36[5844]            		push	word [cs:ROM_IP]
  1785 000004B4 8EC2                    		mov	es,dx
  1786 000004B6 CB                      		retf	; far return
  1787                                  
  1788                                  ;============================================================================
  1789                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1790                                  ;============================================================================
  1791                                  ; 12/10/2018 - Retro DOS v3.0
  1792                                  
  1793                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1794                                  
  1795                                  ; =============== S U B	R O U T	I N E =======================================
  1796                                  
  1797                                  ;Break	<PromptBat - Open or wait for batch file>
  1798                                  
  1799                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1800                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1801                                  ; file. Leave segment registers alone.
  1802                                  
  1803                                  PROMPTBAT:
  1804 000004B7 E8EF06                  		call	BATOPEN
  1805 000004BA 7201                    		jc	short PROMPTBAT1
  1806 000004BC C3                      		retn
  1807                                  PROMPTBAT1:
  1808                                  		; MSDOS 6.0 COMMAND.COM
  1809                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1810                                  		;jz	Bat_Remcheck		;AN022;
  1811                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1812                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1813                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1814                                  		;jmp	short BatDie		;AN022;
  1815                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1816                                  		;call	[RCH_ADDR]		; DX has error number
  1817                                  		;jz	AskForBat		; Media is removable
  1818                                  
  1819                                  		; MSDOS 3.3 COMMAND.COM
  1820 000004BD 81FA[0D38]              		cmp	dx,ACCDENPTR
  1821 000004C1 7413                    		jz	short BATDIE
  1822                                  
  1823                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1824                                  BAT_REMCHECK:				; Go see if media is removable
  1825 000004C3 2EFF1E[6B42]            		call	far [cs:RCH_ADDR] ; DX has error number
  1826 000004C8 7417                    		jz	short ASKFORBAT	; Media is removable
  1827                                  
  1828                                  ; The media is not changeable. Turn everything off.
  1829                                  
  1830 000004CA E8CE09                  		call	FOROFF
  1831 000004CD E8B61E                  		call	PIPEOFF
  1832 000004D0 A2FA0B                  		mov	byte [IFFLAG],al ; No If in progress.	
  1833 000004D3 BA[4E37]                		mov	dx,BADPATHPTR
  1834                                  BATDIE:
  1835 000004D6 E84F03                  		call	BATCHOFF
  1836 000004D9 0E                      		push	cs
  1837 000004DA 1F                      		pop	ds
  1838                                  		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
  1839 000004DB E8E52F                  		call	STD_PRINTF	; MSDOS 3.3
  1840                                  
  1841                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1842                                  
  1843 000004DE E923FC                  		jmp	TCOMMAND
  1844                                  
  1845                                  ; Ask the user to reinsert the batch file
  1846                                  
  1847                                  ASKFORBAT:
  1848 000004E1 1E                      		push	ds
  1849 000004E2 0E                      		push	cs
  1850 000004E3 1F                      		pop	ds
  1851                                  
  1852                                  		; MSDOS 6.0
  1853                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1854                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1855                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1856                                  		;;invoke std_eprintf		;AN000; get second part of message
  1857                                  						;AN000; print it to stderr
  1858                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1859 000004E4 E8D32F                  		call	STD_EPRINTF
  1860 000004E7 E80300                  		call	GETKEYSTROKE
  1861 000004EA 1F                      		pop	ds
  1862 000004EB EBCA                    		jmp	short PROMPTBAT
  1863                                  
  1864                                  
  1865                                  ; MSDOS 6.0
  1866                                  ;****************************************************************
  1867                                  ;*
  1868                                  ;* ROUTINE:	Output_batch_name
  1869                                  ;*
  1870                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1871                                  ;*
  1872                                  ;* INPUT:	DX - extended error number
  1873                                  ;*
  1874                                  ;* OUTPUT:	Ready to call print routine
  1875                                  ;*
  1876                                  ;****************************************************************
  1877                                  ;
  1878                                  ;public	output_batch_name			;AN022;
  1879                                  ;
  1880                                  ;Output_batch_name    proc near			;AN022;
  1881                                  ;
  1882                                  ;		push	ds			;AN022; save resident segment
  1883                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1884                                  ;	assume	DS:nothing			;AN022;
  1885                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1886                                  ;		invoke	dstrlen 		;AN022; get length of string
  1887                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1888                                  ;		rep	movsb			;AN022; move the name
  1889                                  ;
  1890                                  ;		push	cs			;AN022; get local segment
  1891                                  ;		pop	ds			;AN022;
  1892                                  ;	assume	DS:trangroup			;AN022;
  1893                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1894                                  ;		mov	msg_disp_class,ext_msg_class
  1895                                  ;						;AN022; set up extended error msg class
  1896                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1897                                  ;						;AN022; get extended message pointer
  1898                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1899                                  ;						;AN022; point to substitution
  1900                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1901                                  ;		pop	ds			;AN022; restore data segment
  1902                                  ;
  1903                                  ;		ret				;AN022; return
  1904                                  ;
  1905                                  ;Output_batch_name    endp			;AN022;
  1906                                  
  1907                                  
  1908                                  ; =============== S U B	R O U T	I N E =======================================
  1909                                  
  1910                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1911                                  
  1912                                  ; Read the next keystroke. Since there may be several characters in the queue
  1913                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1914                                  ; AFTER waiting.
  1915                                  
  1916                                  GETKEYSTROKE:
  1917                                  		; MSDOS 3.3
  1918                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1919                                  		;mov	ax,0C08h
  1920 000004ED B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1921 000004F0 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1922                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1923                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1924                                  		;mov	ax,0C00h
  1925 000004F2 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1926 000004F5 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1927                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1928 000004F7 C3                      		retn
  1929                                  
  1930                                  		; MSDOS 6.0
  1931                                  		;PUSH	DX				;AN000;  3/3/KK
  1932                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1933                                  		;INT	21h				;AN000;  3/3/KK
  1934                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1935                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1936                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1937                                  		;INT	21h				;AN000;  3/3/KK
  1938                                  		;
  1939                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1940                                  		;INT	21h		; Get character with KB buffer flush
  1941                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1942                                  		;INT	21h
  1943                                  		;
  1944                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1945                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1946                                  		;INT	21h				;AN000;  3/3/KK
  1947                                  		;POP	DX				;AN000;  3/3/KK
  1948                                  		;
  1949                                  		;return
  1950                                  
  1951                                  ; =============== S U B	R O U T	I N E =======================================
  1952                                  
  1953                                  ; Break	<ReadBat - read 1 line from batch file>
  1954                                  
  1955                                  ; ReadBat - read a single line from the batch file. 
  1956                                  ; Perform all substitutions as appropriate.
  1957                                  
  1958                                  READBAT:
  1959                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1960                                  		
  1961                                  		;mov	byte [SUPPRESS],1
  1962                                  					; initialize line suppress status
  1963 000004F8 C606F00B01              		mov	byte [SUPPRESS],YES_ECHO 
  1964 000004FD F606E50BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1965 00000502 7508                    		jnz	short TRYING_TO_ABORT
  1966 00000504 C606E40B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1967                                  
  1968                                  		; MSDOS 6.0
  1969                                  ;
  1970                                  ;M037; Start of changes
  1971                                  ; We check here if we have set the flag indicating that the batchfile is at
  1972                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1973                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1974                                  ;batch file gets closed etc. and then return as if everything is done.
  1975                                  ;
  1976                                  		;push	ds
  1977                                  		;mov	ds,Batch
  1978                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1979                                  		;pop	ds
  1980                                  		;jz	contbat		; no, continue normal processing
  1981                                  		;invoke	GetBatByt	; frees up batchseg
  1982                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1983                                  		;			; as a dummy command
  1984                                  		;invoke CrLf2		; print a CR-LF
  1985                                  		;return			; done batch processing
  1986                                  
  1987                                  ;M037; End of changes
  1988                                  		
  1989                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1990                                  CONTBAT:
  1991 00000509 E8ABFF                  		call	PROMPTBAT
  1992                                  
  1993                                  TRYING_TO_ABORT:
  1994 0000050C BF[C240]                		mov	di,COMBUF+2
  1995                                  
  1996                                  ; Save position and try to scan for first non delimiter.
  1997                                  
  1998                                  TESTNOP:
  1999 0000050F 8CD8                    		mov	ax,ds
  2000 00000511 8E1E990B                		mov	ds,word [BATCH]
  2001 00000515 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  2002 00000519 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  2003 0000051D 8ED8                    		mov	ds,ax
  2004 0000051F E88105                  		call	SKIPDELIM	; skip to first non-delim
  2005                                  
  2006                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2007                                  ; beginning and read the line.
  2008                                  
  2009 00000522 3C3A                    		cmp	al,':'		; is it a label?
  2010 00000524 59                      		pop	cx
  2011 00000525 5A                      		pop	dx		; restore position in bat file
  2012 00000526 7431                    		jz	short NOPLINE	; yes, resync everything.
  2013 00000528 F706990BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2014 0000052E 7438                    		jz	short RDBAT	; no, go read batch file
  2015                                  
  2016                                  		;cmp	al,'@'
  2017 00000530 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2018 00000532 7507                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2019                                  		;mov	byte [SUPPRESS],0
  2020 00000534 C606F00B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2021 00000539 EB2D                    		jmp	short RDBAT	; go read batch file
  2022                                  
  2023                                  		;nop
  2024                                  SET_BAT_POS:
  2025 0000053B 1E                      		push	ds
  2026 0000053C 8E1E990B                		mov	ds,word [BATCH]
  2027 00000540 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2028 00000544 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2029 00000548 1F                      		pop	ds
  2030                                  		;MOV	AX,(LSEEK SHL 8) + 0
  2031 00000549 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2032 0000054C CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2033                                  				; AL = method: offset from beginning of	file
  2034                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2035 0000054E 2EC706[084D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2036 00000555 31C9                    		xor	cx,cx		; Initialize line length to zero
  2037 00000557 EB0F                    		jmp	short RDBAT
  2038                                  
  2039                                  		;nop
  2040                                  
  2041                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2042                                  ; We eat characters until a CR is seen.
  2043                                  
  2044                                  NOPLINE:
  2045 00000559 E8F400                  		call	SKIPTOEOL
  2046 0000055C E82E03                  		call	GETBATBYT	; eat trailing LF
  2047                                  		;test	word [BATCH],0FFFFh
  2048 0000055F F706990BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2049 00000565 75A8                    		jnz	short TESTNOP	; no, go get another line
  2050                                  READBAT_RETN:				; Hit EOF			
  2051 00000567 C3                      		retn
  2052                                  
  2053                                  ; ---------------------------------------------------------------------------
  2054                                  
  2055                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2056                                  ; input, we are to consider two special cases:
  2057                                  ;
  2058                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2059                                  ;   %sym%	This is a symbol from the environment
  2060                                  
  2061                                  RDBAT:
  2062 00000568 E82203                  		call	GETBATBYT
  2063 0000056B 41                      		inc	cx		; Inc the line length
  2064                                  RDBAT1:
  2065 0000056C 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2066 00000570 7344                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2067                                  
  2068                                  ; See if we have a parameter character.
  2069                                  
  2070 00000572 3C25                    		cmp	al,'%'		; Check for parameter
  2071 00000574 744A                    		jz	short NEEDPARM
  2072                                  
  2073                                  ; no parameter character. Store it as usual and see if we are done.
  2074                                  
  2075                                  SAVBATBYT:
  2076 00000576 AA                      		stosb			; End of line found?
  2077 00000577 3C0D                    		cmp	al,0Dh
  2078 00000579 75ED                    		jnz	short RDBAT	; no, go for more
  2079                                  
  2080                                  ; We have read in an entire line. 
  2081                                  ; Decide whether we should echo the command line or not.
  2082                                  
  2083                                  FOUND_EOL:
  2084 0000057B 81EF[C340]              		sub	di,COMBUF+3
  2085 0000057F 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2086 00000581 26A2[C140]              		mov	[es:COMBUF+1],al ; Set length of line
  2087 00000585 E80503                  		call	GETBATBYT	; Eat linefeed
  2088 00000588 E80A06                  		call	BATCLOSE
  2089 0000058B 803EF00B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2090 00000590 7407                    		jz	short RESET
  2091 00000592 F606EF0B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2092 00000597 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2093                                  RESET:
  2094 00000599 0E                      		push	cs
  2095 0000059A 1F                      		pop	ds		; Go back to local segment
  2096 0000059B 74CA                    		jz	short READBAT_RETN ; no echoing here...
  2097                                  TRY_NEXTFLAG:
  2098 0000059D 803E040C01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2099                                  					;G was there a command last time?
  2100 000005A2 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2101 000005A4 E8C513                  		call	CRLF2		;G  Print out prompt
  2102                                  NO_CRLF_PRINT:
  2103 000005A7 E8E00D                  		call	PRINT_PROMPT
  2104 000005AA 0E                      		push	cs		;G change data segment
  2105 000005AB 1F                      		pop	ds
  2106 000005AC BA[C240]                		mov	dx,COMBUF+2	; get command line for echoing
  2107 000005AF E81814                  		call	CRPRINT
  2108 000005B2 E8B713                  		call	CRLF2
  2109 000005B5 C3                      		retn
  2110                                  
  2111                                  ; The line was too long. Eat remainder of input text up until the CR
  2112                                  
  2113                                  TOOLONG:
  2114 000005B6 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2115 000005B8 7403                    		jz	short LTLCONT	; Yes, continue
  2116 000005BA E89300                  		call	SKIPTOEOL	; Eat remainder of line	
  2117                                  LTLCONT:
  2118 000005BD AA                      		stosb			; Terminate the command
  2119 000005BE EBBB                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2120                                  
  2121                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2122                                  
  2123                                  NEEDPARM:
  2124 000005C0 E8CA02                  		call	GETBATBYT	; get next character
  2125 000005C3 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2126 000005C5 74AF                    		jz	short SAVBATBYT	; if so, replace with a single %
  2127 000005C7 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2128 000005C9 74AB                    		jz	short SAVBATBYT	; yes, treat it normally
  2129                                  
  2130                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2131                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2132                                  ; see if the <something> has a terminating % and then look up the contents
  2133                                  ; in the environment.
  2134                                  
  2135                                  PAROK:
  2136 000005CB 2C30                    		sub	al,'0'
  2137 000005CD 7239                    		jb	short NEEDENV	; look for parameter in the environment
  2138 000005CF 3C09                    		cmp	al,9
  2139 000005D1 7735                    		ja	short NEEDENV
  2140                                  
  2141                                  ; We have found %<number>. This is taken from the parameters in the
  2142                                  ; allocated batch area.
  2143                                  
  2144 000005D3 98                      		cbw
  2145 000005D4 89C3                    		mov	bx,ax		; move index into AX
  2146 000005D6 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2147 000005D8 06                      		push	es
  2148 000005D9 8E06990B                		mov	es,word [BATCH]
  2149                                  ;
  2150                                  ; The structure of the batch area is:
  2151                                  ;
  2152                                  ;   BYTE    type of segment
  2153                                  ;   DWORD   offset for next line
  2154                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2155                                  ;   ASCIZ   file name (with . and ..)
  2156                                  ;   BYTES   CR-terminated parameters
  2157                                  ;   BYTE    0 flag to indicate end of parameters
  2158                                  ;
  2159                                  ; Get pointer to BX'th argument
  2160                                  ;
  2161                                  		;mov	si,[es:bx+0Bh]
  2162 000005DD 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2163 000005E1 07                      		pop	es
  2164                                  
  2165                                  ; Is there a parameter here?
  2166                                  
  2167 000005E2 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2168 000005E5 7503                    		jnz	short YES_THERE_IS ; Yes go get it
  2169 000005E7 E97EFF                  		jmp	RDBAT		; Ignore if it doesn't
  2170                                  
  2171                                  ; Copy in the found parameter from batch segment
  2172                                  
  2173                                  YES_THERE_IS:
  2174 000005EA 1E                      		push	ds
  2175 000005EB 8E1E990B                		mov	ds,word [BATCH]
  2176 000005EF 49                      		dec	cx		; Don't count '%' in line length
  2177                                  COPYPARM:
  2178 000005F0 AC                      		lodsb			; From resident segment
  2179 000005F1 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2180 000005F3 740F                    		jz	short ENDPARAM
  2181 000005F5 41                      		inc	cx		; Inc the line length
  2182 000005F6 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2183 000005FA 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2184 000005FC AA                      		stosb
  2185 000005FD EBF1                    		jmp	short COPYPARM
  2186                                  
  2187                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2188                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2189                                  ; believing that we are at EOL. Clobber AL too.
  2190                                  
  2191                                  LINETOOL:
  2192 000005FF 30C0                    		xor	al,al
  2193 00000601 1F                      		pop	ds
  2194 00000602 EBB2                    		jmp	short TOOLONG
  2195                                  
  2196                                  ; We have copied in an entire parameter. Go back for more
  2197                                  
  2198                                  ENDPARAM:
  2199 00000604 1F                      		pop	ds
  2200 00000605 E960FF                  		jmp	RDBAT
  2201                                  
  2202                                  ; We have found % followed by something other than 0-9. We presume that there
  2203                                  ; will be a following % character. In between is an environment variable that
  2204                                  ; we will fetch and replace in the batch line with its value.
  2205                                  
  2206                                  NEEDENV:
  2207                                  		; MSDOS 6.0 COMMAND.COM 
  2208                                  		;dec     cx 		;AN070; Don't count "%"
  2209                                  
  2210                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2211 00000608 1E                      		push	ds
  2212 00000609 57                      		push	di
  2213                                  					; temp spot for name
  2214 0000060A BF[DC42]                		mov	di,ID
  2215 0000060D 0430                    		add	al,'0'		; reconvert character
  2216 0000060F AA                      		stosb			; store it in appropriate place
  2217                                  
  2218                                  ; loop getting characters until the next % is found or until EOL
  2219                                  
  2220                                  GETENV1:
  2221 00000610 E87A02                  		call	GETBATBYT	; get the byte
  2222 00000613 AA                      		stosb			; store it
  2223 00000614 3C0D                    		cmp	al,0Dh		; EOL?
  2224 00000616 7513                    		jnz	short GETENV15	; no, see if it the term char
  2225                                  
  2226                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2227                                  
  2228 00000618 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2229 0000061D BE[DC42]                		mov	si,ID 		; point to buffer
  2230 00000620 5F                      		pop	di		; point to line buffer
  2231 00000621 0E                      		push	cs
  2232 00000622 1F                      		pop	ds
  2233 00000623 E85E02                  		call	STRCPY
  2234                                  		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
  2235 00000626 4F                      		dec	di  		;  MSDOS 3.3 COMMAND.COM	
  2236 00000627 1F                      		pop	ds
  2237 00000628 E94BFF                  		jmp	SAVBATBYT
  2238                                  GETENV15:
  2239 0000062B 3C25                    		cmp	al,'%'		; terminating %?
  2240 0000062D 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2241                                  
  2242                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2243                                  ; This was the source of bug #1.
  2244                                  ;		dec	cx		;AN070; Don't count "%"
  2245                                  
  2246 0000062F B03D                    		mov	al,'='		; terminate  with =
  2247 00000631 268845FF                		mov	[es:di-1],al
  2248                                  
  2249                                  ; ID now either has a =-terminated string which we are to find in the
  2250                                  ; environment or a non =-terminated string which will not be found in the
  2251                                  ; environment.
  2252                                  
  2253                                  GETENV2:
  2254 00000635 BE[DC42]                		mov	si,ID
  2255 00000638 0E                      		push	cs
  2256 00000639 1F                      		pop	ds		; DS:SI points to name
  2257 0000063A 51                      		push	cx
  2258 0000063B E85911                  		call	FIND_NAME_IN_ENVIRONMENT
  2259 0000063E 59                      		pop	cx
  2260 0000063F 06                      		push	es
  2261 00000640 1F                      		pop	ds
  2262 00000641 0E                      		push	cs
  2263 00000642 07                      		pop	es
  2264 00000643 89FE                    		mov	si,di
  2265 00000645 5F                      		pop	di		; get back pointer to command line
  2266                                  
  2267                                  ; If the parameter was not found, there is no need to perform any replacement.
  2268                                  ; We merely pretend that we've copied the parameter.
  2269                                  
  2270 00000646 7204                    		jc	short GETENV6
  2271                                  
  2272                                  ; ES:DI points to command line being built
  2273                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2274                                  
  2275 00000648 E83902                  		call	STRCPY		; (let RdBat handle overflow)
  2276 0000064B 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2277                                  GETENV6:
  2278 0000064C 1F                      		pop	ds
  2279 0000064D E918FF                  		jmp	RDBAT		; go back to batch file
  2280                                  
  2281                                  ; =============== S U B	R O U T	I N E =======================================
  2282                                  
  2283                                  ;   SkipToEOL - read from batch file until end of line
  2284                                  
  2285                                  SKIPTOEOL:
  2286 00000650 F706990BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2287                                  		
  2288                                  		;jnz	short SKIPTOEOL1  	
  2289                                  		;retn			; no batch file in effect
  2290                                  		
  2291 00000656 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2292                                  SKIPTOEOL1:
  2293 00000658 E83202                  		call	GETBATBYT
  2294 0000065B 3C0D                    		cmp	al,0Dh		; eol character?
  2295 0000065D 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2296                                  SKIPTOEOL2:
  2297 0000065F C3                      		retn
  2298                                  
  2299                                  ; =============== S U B	R O U T	I N E =======================================
  2300                                  
  2301                                  ;Break	<Allocate and deallocate the transient portion>
  2302                                  
  2303                                  ; Free Transient. Modify ES,AX,flags
  2304                                  
  2305                                  FREE_TPA:
  2306 00000660 06                      		push	es
  2307 00000661 8E06[6142]              		mov	es,[RESSEG]
  2308 00000665 268E06250D              		mov	es,word [es:RES_TPA]
  2309 0000066A B449                    		mov	ah,DEALLOC ; 49h
  2310 0000066C CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2311                                  				; ES = segment address of area to be freed
  2312 0000066E 07                      		pop	es
  2313 0000066F C3                      		retn
  2314                                  
  2315                                  ; =============== S U B	R O U T	I N E =======================================
  2316                                  
  2317                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2318                                  
  2319                                  ALLOC_TPA:
  2320 00000670 06                      		push	es
  2321 00000671 8E06[6142]              		mov	es,[RESSEG]
  2322 00000675 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2323 00000678 B448                    		mov	ah,ALLOC ; 48h
  2324 0000067A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2325                                  				; BX = number of 16-byte paragraphs desired
  2326 0000067C 53                      		push	bx	  	; Save size of block
  2327 0000067D B448                    		mov	ah,ALLOC ; 48h
  2328 0000067F CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2329                                  				; BX = number of 16-byte paragraphs desired
  2330                                  
  2331                                  ; Attempt to align TPA on 64K boundary
  2332                                  
  2333 00000681 5B                      		pop	bx		; Restore size of block
  2334 00000682 26A3250D                		mov	word [es:RES_TPA],ax ; Save segment to beginning of block
  2335 00000686 A3[7142]                		mov	[TRAN_TPA],ax
  2336                                  
  2337                                  ; Is the segment already aligned on a 64K boundary
  2338                                  
  2339 00000689 89C2                    		mov	dx,ax		; Save segment
  2340 0000068B 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2341 0000068E 7507                    		jnz	short CALC_TPA
  2342 00000690 89D0                    		mov	ax,dx
  2343 00000692 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2344 00000695 7523                    		jnz	short NOROUND
  2345                                  CALC_TPA:
  2346 00000697 89D0                    		mov	ax,dx
  2347 00000699 2500F0                  		and	ax,0F000h
  2348 0000069C 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2349 0000069F 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2350                                  
  2351                                  ; Make sure that new boundary is within allocated range
  2352                                  
  2353 000006A1 268B16250D              		mov	dx,word [es:RES_TPA]
  2354 000006A6 01DA                    		add	dx,bx		; Compute maximum address
  2355 000006A8 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2356 000006AA 720E                    		jb	short NOROUND
  2357                                  
  2358                                  ; Make sure that we won't overwrite the transient
  2359                                  
  2360 000006AC 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2361 000006AE 39C3                    		cmp	bx,ax
  2362 000006B0 7208                    		jb	short NOROUND
  2363                                  
  2364                                  ; The area from the 64K boundary to the beginning of the transient must
  2365                                  ; be at least 64K.
  2366                                  
  2367 000006B2 29C3                    		sub	bx,ax
  2368                                  		;cmp	bx,4096
  2369 000006B4 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2370 000006B8 7304                    		jnb	short ROUNDDONE
  2371                                  NOROUND:
  2372 000006BA 26A1250D                		mov	ax,word [es:RES_TPA]
  2373                                  ROUNDDONE:
  2374 000006BE 26A3170D                		mov	word [es:LTPA],ax ; Re-compute everything
  2375 000006C2 A3[6342]                		mov	[TPA],ax
  2376 000006C5 89C3                    		mov	bx,ax
  2377 000006C7 8CC8                    		mov	ax,cs
  2378 000006C9 29D8                    		sub	ax,bx
  2379 000006CB 53                      		push	bx
  2380 000006CC BB1000                  		mov	bx,16
  2381 000006CF F7E3                    		mul	bx
  2382 000006D1 5B                      		pop	bx
  2383 000006D2 09D2                    		or	dx,dx
  2384 000006D4 7403                    		jz	short SAVSIZ2
  2385 000006D6 B8FFFF                  		mov	ax,-1
  2386                                  SAVSIZ2:
  2387                                  
  2388                                  ; AX is the number of bytes free in the buffer between the resident and the
  2389                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2390                                  
  2391 000006D9 3D0002                  		cmp	ax,512
  2392 000006DC 7603                    		jbe	short GOTSIZE2
  2393                                  		;and	ax,~1FFh
  2394 000006DE 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2395                                  GOTSIZE2:
  2396 000006E1 A3[8242]                		mov	[BYTCNT],ax
  2397 000006E4 07                      		pop	es
  2398 000006E5 C3                      		retn
  2399                                  
  2400                                  ; =============== S U B	R O U T	I N E =======================================
  2401                                  
  2402                                  ;Break	<BatCom - enter a batch file>
  2403                                  
  2404                                  ; The exec search has determined that the user has requested a batch file for
  2405                                  ; execution. We parse the arguments, create the batch segment, and signal
  2406                                  ; batch processing.
  2407                                  
  2408                                  BATCOM:	
  2409                                  
  2410                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2411                                  
  2412                                  ; Batch parameters are read with ES set to segment of resident part
  2413                                  
  2414                                  		; MSDOS 6.0
  2415                                  		;mov	es,[RESSEG]
  2416                                  		;ASSUME	ES:RESGROUP
  2417                                  		;cmp	es:[call_batch_flag],call_in_progress
  2418                                  		;				;AN043; If in CALL,
  2419                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2420                                  		;invoke	IOSET			; Set up any redirection
  2421                                  ;skip_ioset:					;AN043;
  2422                                  		;call	FREE_TPA		; G
  2423                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2424                                  		;jz	getecho 		; G if we're in a call, don't execute
  2425                                  
  2426                                  		; MSDOS 3.3
  2427 000006E6 E81617                  		call	IOSET
  2428 000006E9 8E06[6142]              		mov	es,[RESSEG]
  2429 000006ED E870FF                  		call	FREE_TPA
  2430                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2431 000006F0 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2432 000006F6 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2433                                  
  2434                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2435                                  
  2436                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2437                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2438                                  ; Don't execute if in call
  2439                                  
  2440 000006F8 E8A007                  		call	FOROFF
  2441                                  GETECHO:
  2442 000006FB E8881C                  		call	PIPEOFF
  2443 000006FE 26A0EF0B                		mov	al,byte [es:ECHOFLAG] ; preserve echo state for chaining
  2444 00000702 2401                    		and	al,1		; Save current echo state
  2445                                  
  2446 00000704 50                      		push	ax
  2447 00000705 31C0                    		xor	ax,ax
  2448 00000707 26F706990BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2449 0000070E 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2450 00000710 26A1990B                		mov	ax,word [es:BATCH] ; Get current batch segment
  2451                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2452 00000714 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2453 0000071A 7408                    		jz	short LEAVEBAT
  2454                                  
  2455                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2456                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2457                                  
  2458 0000071C 06                      		push	es
  2459 0000071D 8EC0                    		mov	es,ax		; Get current batch segment
  2460                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2461                                  					; Get previous batch segment
  2462 0000071F 26A10200                		mov	ax,word [es:BATCHSEGMENT.BatLast]
  2463 00000723 07                      		pop	es
  2464                                  LEAVEBAT:
  2465 00000724 50                      		push	ax		; Keep segment until new one created
  2466 00000725 26803E010C01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2467 0000072B 7403                    		jz	short STARTBAT
  2468 0000072D E8F800                  		call	BATCHOFF
  2469                                  
  2470                                  ; Find length of batch file
  2471                                  
  2472                                  STARTBAT:
  2473 00000730 26C606010C00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2474 00000736 BE[8941]                		mov	si,EXECPATH
  2475                                  
  2476                                  		; MSDOS 6.0
  2477                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2478                                  		;int	2fh		;AN042;    was found with APPEND
  2479                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2480                                  		;mov	dx,si		;AN042; Get the string
  2481                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2482                                  		;int	21h		;AN042;
  2483                                  
  2484                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2485 00000739 E87A17                  		call	DSTRLEN
  2486                                  ;
  2487                                  ; Allocate batch area:
  2488                                  ;   BYTE    type of segment
  2489                                  ;   WORD    segment of last batch file
  2490                                  ;   WORD    segment for FOR command
  2491                                  ;   BYTE    FOR flag state on entry to batch file
  2492                                  ;   DWORD   offset for next line
  2493                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2494                                  ;   ASCIZ   file name (with . and ..)
  2495                                  ;   BYTES   CR-terminated parameters
  2496                                  ;   BYTE    0 flag to indicate end of parameters
  2497                                  ;
  2498                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2499                                  ; later when we've squeezed out the extra
  2500                                  ;
  2501 0000073C 89CB                    		mov	bx,cx		; length of file name.
  2502                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2503 0000073E 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2504                                  					; structure + max len + round up
  2505 00000742 51                      		push	cx
  2506 00000743 B104                    		mov	cl,4
  2507 00000745 D3EB                    		shr	bx,cl		; convert to paragraphs
  2508 00000747 53                      		push	bx		; Save size of batch segment
  2509 00000748 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2510 0000074A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2511                                  				; BX = number of 16-byte paragraphs desired
  2512 0000074C 5B                      		pop	bx		; Get size of batch segment
  2513                                  
  2514                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2515                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2516                                  ; G This error will occur with nesting of batch files. We also need to
  2517                                  ; G make sure that we don't overlay the transient.
  2518                                  
  2519 0000074D 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2520                                  
  2521 0000074F 50                      		push	ax		;G save batch segment
  2522 00000750 01D8                    		add	ax,bx		;G get end of batch segment
  2523 00000752 83C020                  		add	ax,20h		;G add some tpa work area
  2524 00000755 8CCB                    		mov	bx,cs		;G get the transient segment
  2525                                  
  2526                                  		; MSDOS 6.0
  2527                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2528                                  ; M006; batchseg is always above the transient. We need to change this code
  2529                                  ; M006; to only check for an overlap
  2530                                  ;
  2531                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2532                                  		;add	dx,15		;round up para; M006
  2533                                  		;shr	dx,cl		;para size of transient; M006
  2534                                  		;add	dx,bx		;dx = top of transient; M006
  2535                                  
  2536                                  		;cmp	ax,bx		; M006
  2537                                  		;jb	enough_mem	; Batchseg below transient
  2538                                  					; enough memory ; M006
  2539                                  		;cmp	ax,dx		; M006
  2540                                  		;ja	enough_mem	; Batchseg above transient
  2541                                  					; enough memory ; M006
  2542                                  ;
  2543                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2544                                  ;
  2545                                  		;pop	ax		; restore ax; M006
  2546                                  
  2547                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2548                                  ;M006;		pop	ax		;G get batch segment back
  2549                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2550                                  
  2551                                  		; MSDOS 3.3
  2552 00000757 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2553 00000759 58                      		pop	ax		; get batch segment back
  2554 0000075A 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2555                                  
  2556                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2557 0000075C 06                      		push	es		;G no we're hitting the transient
  2558 0000075D 8EC0                    		mov	es,ax
  2559 0000075F B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2560 00000762 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2561                                  				; ES = segment address of area to be freed
  2562 00000764 07                      		pop	es
  2563                                  MEM_ERROR:
  2564 00000765 E9B400                  		jmp	NO_MEMORY	;G Set up for message and exit
  2565                                  
  2566                                  ENOUGH_MEM:
  2567                                  		; MSDOS 6.0
  2568                                  		;pop	ax		; restore ax; M006
  2569                                  
  2570                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2571 00000768 26A3990B                		mov	word [es:BATCH],ax
  2572 0000076C E801FF                  		call	ALLOC_TPA
  2573                                  
  2574                                  ; Initialize batch segment
  2575                                  
  2576 0000076F 5A                      		pop	dx		; length of name
  2577 00000770 58                      		pop	ax		;G get saved batch segment back
  2578 00000771 26FF06FE0B              		inc	word [es:NEST]	;G increment # batch files in progress
  2579 00000776 06                      		push	es
  2580 00000777 268E06990B              		mov	es,word [es:BATCH]
  2581                                  		;mov	byte [ES:0],0
  2582                                  					; signal batch file type
  2583 0000077C 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2584                                  		;mov	byte [ES:2],ax ; MSDOS 3.3
  2585                                  					;G save segment of last batch file
  2586 00000782 26A30200                		mov	word [es:BATCHSEGMENT.BatLast],ax
  2587 00000786 1E                      		push	ds
  2588 00000787 8E1E[6142]              		mov	ds,[RESSEG]	;G set to resident data
  2589                                  
  2590 0000078B 31C0                    		xor	ax,ax
  2591 0000078D 8A1EFB0B                		mov	bl,byte [FORFLAG] ;G get the current FOR state
  2592                                  		;mov	[es:6],bl ;  MSDOS 3.3
  2593                                  					;G save it in the batch segment
  2594 00000791 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2595 00000796 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2596 00000799 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2597 0000079B A1FC0B                  		mov	ax,word [FORPTR] ;G yes, get current FOR segment	
  2598 0000079E C606FB0B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2599                                  FOR_NOT_ON:
  2600                                  		;mov	[es:4],ax ; MSDOS 3.3
  2601                                  					;G save FOR segment in batch segment
  2602 000007A3 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2603 000007A7 31C0                    		xor	ax,ax
  2604 000007A9 A3FC0B                  		mov	word [FORPTR],ax ;G make sure for segment is not active
  2605 000007AC 8A1EEF0B                		mov	bl,byte [ECHOFLAG]
  2606 000007B0 1F                      		pop	ds
  2607                                  		;mov	[es:1],bl 
  2608                                  					 ;G save echo state of parent
  2609 000007B1 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2610                                  ;SR;
  2611                                  ; Initialize the new BatchEOF flag we have added to 0
  2612                                  ;
  2613                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2614                                  
  2615 000007B6 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2616 000007BA 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2617                                  
  2618                                  ; Initialize pointers
  2619                                  
  2620 000007BE 48                      		dec	ax		; put -1 into AX
  2621                                  		;mov	di,0Bh  ; MSDOS 3.3
  2622                                  					; point to parm area
  2623 000007BF BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2624 000007C2 89FB                    		mov	bx,di
  2625 000007C4 B90A00                  		mov	cx,10
  2626 000007C7 F3AB                    		rep stosw		; Init to no parms
  2627                                  
  2628                                  ; Move in batch file name
  2629                                  
  2630 000007C9 89D1                    		mov	cx,dx
  2631 000007CB F3A4                    		rep movsb
  2632                                  
  2633                                  ; Now copy the command line into batch segment, parsing the arguments along
  2634                                  ; the way. Segment will look like this:
  2635                                  ;
  2636                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2637                                  ;
  2638                                  ; or, in the case of fewer arguments:
  2639                                  ;
  2640                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2641                                  ;
  2642 000007CD BE[C240]                		mov	si,COMBUF+2
  2643 000007D0 B90A00                  		mov	cx,10		; at most 10 arguments
  2644                                  EACHPARM:
  2645 000007D3 E8A311                  		call	SCANOFF		; skip to argument
  2646                                  
  2647                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2648                                  
  2649 000007D6 3C0D                    		cmp	al,0Dh		; end of road?
  2650 000007D8 741D                    		jz	short HAVPARM	; yes, no more arguments
  2651                                  
  2652                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2653                                  
  2654 000007DA E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2655                                  
  2656                                  ; Go into allocated piece and stick in new argument pointer.
  2657                                  
  2658 000007DC 26893F                  		mov	[es:bx],di	; store batch pointer
  2659 000007DF 83C302                  		add	bx,2		; advance arg counter
  2660                                  
  2661                                  ; Move the parameter into batch segment
  2662                                  
  2663                                  MOVPARM:
  2664 000007E2 AC                      		lodsb			; get byte
  2665 000007E3 E89B11                  		call	DELIM		; if delimiter
  2666 000007E6 7407                    		jz	short ENDPARM	; then done with parm
  2667 000007E8 AA                      		stosb			; store byte
  2668 000007E9 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2669 000007EB 740A                    		jz	short HAVPARM	; but end of parm list, finish
  2670 000007ED EBF3                    		jmp	short MOVPARM
  2671                                  
  2672                                  ; We have copied a parameter up until the first separator.
  2673                                  ; Terminate it with CR.
  2674                                  
  2675                                  ENDPARM:
  2676 000007EF B00D                    		mov	al,0Dh
  2677 000007F1 AA                      		stosb
  2678 000007F2 E3DF                    		jcxz	EACHPARM	; if no parameters, don't dec
  2679 000007F4 49                      		dec	cx		; remember that we've seen one.	
  2680 000007F5 EBDC                    		jmp	short EACHPARM
  2681                                  
  2682                                  ; We have parsed the entire line. Terminate the arg list
  2683                                  
  2684                                  HAVPARM:
  2685 000007F7 30C0                    		xor	al,al		; Nul terminate the parms
  2686 000007F9 AA                      		stosb
  2687                                  
  2688                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2689                                  ; into paragraphs and setblock to the appropriate size
  2690                                  
  2691 000007FA 8D5D0F                  		lea	bx,[di+15]
  2692 000007FD B104                    		mov	cl,4
  2693 000007FF D3EB                    		shr	bx,cl
  2694 00000801 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2695 00000803 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2696                                  				; ES = segment address of block	to change
  2697                                  				; BX = new size	in paragraphs
  2698 00000805 07                      		pop	es
  2699 00000806 06                      		push	es
  2700 00000807 1F                      		pop	ds		; Simply batch FCB setup
  2701 00000808 833EF50BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2702 0000080D 7506                    		jnz	short NOBATSING
  2703 0000080F C706F50BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2704                                  NOBATSING:
  2705                                  
  2706                                  ; Enter the batch file with the current echo state
  2707                                  
  2708 00000815 58                      		pop	ax		; Get original echo state
  2709 00000816 A2EF0B                  		mov	byte [ECHOFLAG],al ; restore it
  2710 00000819 E9E8F8                  		jmp	TCOMMAND
  2711                                  
  2712                                  ; The following is executed if there isn't enough memory for batch segment
  2713                                  
  2714                                  NO_MEMORY:
  2715 0000081C 5A                      		pop	dx		; even up our stack 
  2716 0000081D 58                      		pop	ax
  2717 0000081E 58                      		pop	ax
  2718 0000081F E84EFE                  		call	ALLOC_TPA	; reallocate memory
  2719                                  
  2720                                  		; MSDOS 3.3
  2721 00000822 BA[9A3C]                		mov	dx,INSFMEMMESPTR
  2722 00000825 E9FB13                  		jmp	CERROR
  2723                                  
  2724                                  		; MSDOS 6.0
  2725                                  		;mov	msg_disp_class,ext_msg_class
  2726                                  		;			;AN000; set up extended error msg class
  2727                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2728                                  		;			;AC000; get extended message pointer
  2729                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2730                                  		;			;AN000; get message number in control block
  2731                                  		;jmp	cerror		;g print error message and go...
  2732                                  
  2733                                  ; =============== S U B	R O U T	I N E =======================================
  2734                                  
  2735                                  BATCHOFF:
  2736 00000828 50                      		push	ax
  2737 00000829 06                      		push	es
  2738 0000082A 1E                      		push	ds
  2739 0000082B 53                      		push	bx
  2740                                  
  2741 0000082C 2E8E06[6142]            		mov	es,[cs:RESSEG]
  2742 00000831 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  2743 00000836 A1990B                  		mov	ax,word [BATCH]	; Free the batch segment
  2744 00000839 09C0                    		or	ax,ax
  2745 0000083B 7442                    		jz	short NOTFREE
  2746                                  
  2747 0000083D 06                      		push	es
  2748 0000083E 8EC0                    		mov	es,ax
  2749 00000840 F606EF0B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2750 00000845 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2751                                  		;mov	byte [SUPPRESS],0
  2752 00000847 C606F00B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2753                                  ECHO_LAST_LINE:
  2754                                  		;mov	bl,[es:1]
  2755 0000084C 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2756 00000851 881EEF0B                		mov	byte [ECHOFLAG],bl		 ; G and restore it
  2757                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2758 00000855 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2759 0000085A 891EFC0B                		mov	word [FORPTR],bx		;G  and restore it
  2760                                  		;mov	bl,[es:6]
  2761 0000085E 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2762 00000863 881EFB0B                		mov	byte [FORFLAG],bl		;G  and restore it
  2763                                  		;mov	bx,word [es:2] ; MSDOS 3.3
  2764 00000867 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment
  2765                                  
  2766 0000086C B449                    		mov	ah,DEALLOC ; 49h
  2767 0000086E CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2768                                  				; ES = segment address of area to be freed
  2769 00000870 07                      		pop	es
  2770 00000871 891E020C                		mov	word [NEXT_BATCH],bx ;G  reset batch segment	
  2771 00000875 26FF0EFE0B              		dec	word [es:NEST]
  2772 0000087A 31C0                    		xor	ax,ax
  2773 0000087C A3990B                  		mov	word [BATCH],ax	; No batch in progress
  2774                                  NOTFREE:
  2775 0000087F 5B                      		pop	bx
  2776 00000880 1F                      		pop	ds
  2777 00000881 07                      		pop	es
  2778 00000882 58                      		pop	ax
  2779 00000883 C3                      		retn
  2780                                  
  2781                                  ; =============== S U B	R O U T	I N E =======================================
  2782                                  
  2783                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2784                                  ;	Entry : DS:SI ==> source string
  2785                                  ;		ES:DI ==> destination string
  2786                                  ;		CX = current length of destination string
  2787                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2788                                  
  2789                                  		; MSDOS 3.3
  2790                                  STRCPY:
  2791 00000884 50                      		push	ax
  2792                                  CCYCLE:
  2793 00000885 AC                      		lodsb
  2794 00000886 AA                      		stosb
  2795 00000887 08C0                    		or	al,al
  2796 00000889 75FA                    		jnz	short CCYCLE
  2797 0000088B 58                      		pop	ax
  2798 0000088C C3                      		retn
  2799                                  
  2800                                  		; MSDOS 6.0
  2801                                  ;Procedure StrCpy,NEAR
  2802                                  		;push	ax
  2803                                  ;ccycle:
  2804                                  		;lodsb
  2805                                  		;inc	cx
  2806                                  		;cmp	cx,COMBUFLEN
  2807                                  		;jb	ccopy
  2808                                  		;stc			; set carry to signal error
  2809                                  		;jmp	short ccend
  2810                                  ;ccopy:
  2811                                  		;stosb
  2812                                  		;or	al,al
  2813                                  		;jnz	ccycle
  2814                                  ;ccend:
  2815                                  		;dec	cx		; discount extra byte
  2816                                  		;dec	di		; back up pointer
  2817                                  		;pop	ax
  2818                                  		;return			; return carry clear
  2819                                  ;EndProc StrCpy
  2820                                  
  2821                                  ;============================================================================
  2822                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2823                                  ;============================================================================
  2824                                  ; 12/10/2018 - Retro DOS v3.0
  2825                                  
  2826                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2827                                  
  2828                                  ; =============== S U B	R O U T	I N E =======================================
  2829                                  
  2830                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2831                                  
  2832                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2833                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2834                                  ; AH, DX destroyed.
  2835                                  
  2836                                  GETBATBYT:
  2837 0000088D 53                      		push	bx
  2838 0000088E 51                      		push	cx
  2839 0000088F 1E                      		push	ds
  2840 00000890 F606E50BFF              		test	byte [BATCH_ABORT],-1
  2841 00000895 755E                    		jnz	short BATEOF
  2842 00000897 F706990BFFFF            		test	word [BATCH],-1
  2843 0000089D 7456                    		jz	short BATEOF
  2844 0000089F 06                      		push	es
  2845 000008A0 8E06990B                		mov	es,word [BATCH]
  2846                                  
  2847                                  		; MSDOS 6.0
  2848                                  ;M020;
  2849                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2850                                  ;try to read from the batchfile again.
  2851                                  ;
  2852                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2853                                  		;jz	not_eof		;no, read batch file	;M020
  2854                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2855                                  ;not_eof:							;M020
  2856                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2857 000008A4 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2858 000008AA 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2859 000008B0 07                      		pop	es
  2860                                  
  2861                                  ; See if we have bytes buffered...
  2862                                  
  2863 000008B1 8CC8                    		mov	ax,cs
  2864 000008B3 8ED8                    		mov	ds,ax
  2865 000008B5 8B1E[084D]              		mov	bx,[BATBUFPOS]
  2866 000008B9 83FBFF                  		cmp	bx,-1
  2867 000008BC 751D                    		jnz	short UNBUF
  2868                                  
  2869                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2870                                  
  2871 000008BE BA[0A4D]                		mov	dx,BATBUF
  2872 000008C1 8B0E[123F]              		mov	cx,[BATBUFLEN] ; max to read.
  2873 000008C5 8B1E[8545]              		mov	bx,[BATHAND]
  2874 000008C9 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2875 000008CB CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2876                                  				; BX = file handle,CX = number	of bytes to read
  2877                                  				; DS:DX	-> buffer
  2878                                  		; MSDOS 6.0
  2879                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2880                                  		;invoke	get_ext_error_number	;AN022; get the error
  2881                                  		;push	ds			;AN022; save local segment
  2882                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2883                                  		;assume ds:resgroup		;AN022;
  2884                                  		;mov	dx,ax			;AN022; put error in DX
  2885                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2886                                  		;pop	ds			;AN022;
  2887                                  		;assume	ds:trangroup		;AN022;
  2888                                  		;invoke	std_eprintf		;AN022; print out the error
  2889                                  		;mov	byte ptr combuf+2,end_of_line_in
  2890                                  		;				;AN022; terminate the batch line for parsing
  2891                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2892                                  		;				;AN022; terminate the batch line for output
  2893                                  ;M020;
  2894                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2895                                  ;error is never hit (and it shouldn't be)
  2896                                  ;
  2897                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2898                                  		;
  2899                                  		;jmp	short bateof		;AN022; terminate the batch file
  2900                                  ;bat_read_ok:					;AN022;
  2901                                  
  2902                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2903 000008CD 89C1                    		mov	cx,ax
  2904 000008CF E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2905                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2906 000008D1 890E[2A4D]              		mov	[BATBUFEND],cx
  2907 000008D5 31DB                    		xor	bx,bx
  2908 000008D7 891E[084D]              		mov	[BATBUFPOS],bx
  2909                                  
  2910                                  ; Buffered bytes!
  2911                                  
  2912                                  UNBUF:
  2913 000008DB 8A87[0A4D]              		mov	al,[BATBUF+bx]		; get next byte
  2914 000008DF 43                      		inc	bx
  2915 000008E0 3B1E[2A4D]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2916 000008E4 7203                    		jb	short SETBUFPOS
  2917 000008E6 BBFFFF                  		mov	bx,-1
  2918                                  SETBUFPOS:
  2919 000008E9 891E[084D]              		mov	[BATBUFPOS],bx
  2920 000008ED 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2921 000008EF 7533                    		jnz	short GETBYTEDONE
  2922                                  
  2923                                  ;We get here only when we hit an EOF
  2924                                  		
  2925                                  		; MSDOS 6.0
  2926                                  ;BatEOFDS:
  2927                                  ;SR;
  2928                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2929                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2930                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2931                                  ;batch processing is turned off before the last line is processed and so 
  2932                                  ;this line would never be executed. 
  2933                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2934                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2935                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2936                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2937                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2938                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2939                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2940                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2941                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2942                                  ;another redundant CR-LF. There is no work-around I can think of.
  2943                                  ; 	I would love to restructure this entire routine and its caller to
  2944                                  ;make the flow really easy to understand but I guess this will have to wait.
  2945                                  ;
  2946                                  		;push	es
  2947                                  		;mov	es,ResSeg
  2948                                  ;SR;
  2949                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2950                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2951                                  ;
  2952                                  		;mov	es,es:Batch
  2953                                  		;cmp	es:BatchEOF,0
  2954                                  		;jnz	crpresent
  2955                                  
  2956                                  		;inc	es:BatchEOF		;match the dec following
  2957                                  		;mov	bx,BatBufEnd
  2958                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2959                                  		;je	crpresent		;yes, no need to fake it
  2960                                  
  2961                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2962                                  
  2963                                  ;crpresent:
  2964                                  ;;;		;pop	es
  2965                                  
  2966                                  		;ASSUME	DS:TranGroup
  2967                                  		;MOV	DS,ResSeg
  2968                                  		;ASSUME	DS:ResGroup
  2969                                  
  2970                                  ;SR;
  2971                                  ; The shift operation is done here to replace the decrement. This is because
  2972                                  ;we can jump to this label directly from above when bogus calls are made to
  2973                                  ;this routine even after batch processing is turned off. The shift ensures
  2974                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  2975                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  2976                                  ;calls.
  2977                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  2978                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  2979                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  2980                                  ;turning batch processing off.
  2981                                  
  2982                                  ;At_EOF:						;new label added ;M020
  2983                                  		;shr	es:BatchEOF,1		;decrement the flag
  2984                                  		;jz	turn_off		;zero,turn batch off
  2985                                  		;cmp	es:BatchEOF,1				
  2986                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  2987                                  ;
  2988                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  2989                                  ;
  2990                                  		;mov	al,0dh			;return fake CR.
  2991                                  		;pop	es
  2992                                  		;jmp	short GetByteDone
  2993                                  ;ret_lf:
  2994                                  		;mov	al,0ah			;return fake LF
  2995                                  		;pop	es
  2996                                  		;jmp	short	GetByteDone			
  2997                                  ;turn_off:
  2998                                  		;pop	es
  2999                                  
  3000                                  ;BATEOF:
  3001                                  
  3002                                  		; MSDOS 3.3
  3003                                  TURN_OFF:
  3004 000008F1 8E1E[6142]              		mov	ds,[RESSEG]
  3005                                  
  3006                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3007                                  BATEOF:
  3008 000008F5 E830FF                  		call	BATCHOFF
  3009 000008F8 E89A02                  		call	BATCLOSE
  3010                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3011                                  
  3012                                  ;SR; BugBug
  3013                                  ; There is a good reason why this carriage return is being returned here. 
  3014                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3015                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3016                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3017                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3018                                  ;the batchfile already had a CR-LF. 
  3019                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3020                                  ;the end-of-line. This CR is to mark the end-of-file.
  3021                                  
  3022 000008FB B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3023 000008FD F606E50BFF              		test	byte [BATCH_ABORT],-1
  3024 00000902 C606E50B00              		mov	byte [BATCH_ABORT],0
  3025 00000907 7407                    		jz	short CONT_GET_BYT
  3026 00000909 BF[C240]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3027 0000090C 31C9                    		xor	cx,cx		; zero line length
  3028 0000090E EB14                    		jmp	short GETBYTEDONE
  3029                                  CONT_GET_BYT:
  3030 00000910 833EF50BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3031 00000915 750D                    		jnz	short GETBYTEDONE
  3032 00000917 833EFE0B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3033 0000091C 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3034 0000091E C706F50BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3035                                  GETBYTEDONE:
  3036 00000924 1F                      		pop	ds
  3037 00000925 59                      		pop	cx
  3038 00000926 5B                      		pop	bx
  3039 00000927 C3                      		retn
  3040                                  
  3041                                  ; ---------------------------------------------------------------------------
  3042                                  
  3043                                  ;break	<$If - conditional execution>
  3044                                  
  3045                                  IFERRORP:
  3046 00000928 58                      		pop	ax
  3047                                  IFERROR:
  3048                                  FORERROR:
  3049 00000929 BA[683C]                		mov	dx,SYNTMESPTR
  3050 0000092C E9F412                  		jmp	CERROR
  3051                                  
  3052                                  ; ---------------------------------------------------------------------------
  3053                                  
  3054                                  _$IF:
  3055                                  		; MSDOS 6.0
  3056                                  ; Turn off any pipes in progress.
  3057                                  		;push	ds			;AN004; save local DS
  3058                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3059                                  		;assume	ds:resgroup		;AN004;
  3060                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3061                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3062                                  		;invoke	PipeDel 		;AN004; turn off piping
  3063                                  ;IFNoPipe:					;AN004;
  3064                                  		;pop	ds			;AN004; get local DS back
  3065                                  		;assume	ds:trangroup		;AN004;
  3066                                  
  3067                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3068 0000092F C606[7442]00            		mov	byte [IFNOTFLAG],0
  3069 00000934 C706[E54B]0000          		mov	word [IF_NOT_COUNT],0
  3070 0000093A BE8100                  		mov	si,81h
  3071                                  IFREENT:
  3072 0000093D E83910                  		call	SCANOFF
  3073 00000940 3C0D                    		cmp	al,0Dh
  3074 00000942 74E5                    		jz	short IFERROR
  3075 00000944 89F5                    		mov	bp,si
  3076 00000946 BF[B73D]                		mov	di,IFTAB	; Prepare to search if table	
  3077 00000949 B500                    		mov	ch,0
  3078                                  IFINDCOM:
  3079 0000094B 89EE                    		mov	si,bp
  3080 0000094D 8A0D                    		mov	cl,[di]
  3081 0000094F 47                      		inc	di
  3082 00000950 E337                    		jcxz	IFSTRING
  3083 00000952 EB02                    		jmp	short FIRSTCOMP
  3084                                  
  3085                                  IFCOMP:
  3086 00000954 7510                    		jnz	short IF_DIF
  3087                                  FIRSTCOMP:
  3088 00000956 AC                      		lodsb
  3089 00000957 268A25                  		mov	ah,[es:di]
  3090 0000095A 47                      		inc	di
  3091 0000095B 38E0                    		cmp	al,ah
  3092 0000095D 7405                    		jz	short IFLP
  3093 0000095F 80CC20                  		or	ah,20h		; Try lower case
  3094 00000962 38E0                    		cmp	al,ah
  3095                                  IFLP:
  3096 00000964 E2EE                    		loop	IFCOMP
  3097                                  IF_DIF:
  3098 00000966 9F                      		lahf
  3099 00000967 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3100 00000969 8B1D                    		mov	bx,[di]		; Get handler address
  3101 0000096B 47                      		inc	di
  3102 0000096C 47                      		inc	di
  3103 0000096D 9E                      		sahf
  3104 0000096E 75DB                    		jnz	short IFINDCOM
  3105 00000970 AC                      		lodsb
  3106 00000971 3C0D                    		cmp	al,0Dh
  3107                                  IFERRJ:
  3108 00000973 74B4                    		jz	short IFERROR
  3109 00000975 E80910                  		call	DELIM
  3110 00000978 75D1                    		jnz	short IFINDCOM
  3111 0000097A E8FC0F                  		call	SCANOFF
  3112 0000097D FFE3                    		jmp	bx
  3113                                  
  3114                                  IFNOT:
  3115 0000097F F616[7442]              		not	byte [IFNOTFLAG]
  3116 00000983 FF06[E54B]              		inc	word [IF_NOT_COUNT]
  3117 00000987 EBB4                    		jmp	short IFREENT
  3118                                  
  3119                                  ; We are comparing two strings for equality. First, find the end of the
  3120                                  ; first string.
  3121                                  
  3122                                  IFSTRING:
  3123 00000989 56                      		push	si		; save away pointer for later compare
  3124 0000098A 31C9                    		xor	cx,cx		; count of chars in first string
  3125                                  FIRST_STRING:
  3126 0000098C AC                      		lodsb			; get character
  3127 0000098D 3C0D                    		cmp	al,0Dh		; end of line?
  3128 0000098F 7497                    		jz	short IFERRORP	; yes => error
  3129 00000991 E8ED0F                  		call	DELIM		; is it a delimiter?
  3130 00000994 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3131 00000996 41                      		inc	cx		; remember 1 byte for the length
  3132 00000997 EBF3                    		jmp	short FIRST_STRING ; go back for more
  3133                                  EQUAL_CHECK:
  3134 00000999 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3135 0000099B 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3136 0000099D 3C0D                    		cmp	al,0Dh		; end of line?
  3137 0000099F 7487                    		jz	short IFERRORP	; yes, syntax error
  3138 000009A1 AC                      		lodsb			; get next char
  3139 000009A2 EBF5                    		jmp	short EQUAL_CHECK
  3140                                  
  3141                                  ; The first = has been found. The next char had better be an = too.
  3142                                  
  3143                                  EQUAL_CHECK2:
  3144 000009A4 AC                      		lodsb			; get potential = char
  3145 000009A5 3C3D                    		cmp	al,'='		; is it good?	
  3146 000009A7 7520                    		jnz	short IFERRPJ	; no, error
  3147                                  
  3148                                  ; Find beginning of second string.
  3149                                  
  3150 000009A9 E8CD0F                  		call	SCANOFF
  3151 000009AC 3C0D                    		cmp	al,0Dh
  3152 000009AE 7419                    		jz	short IFERRPJ
  3153 000009B0 5F                      		pop	di
  3154                                  
  3155                                  ; DS:SI points to second string
  3156                                  ; CX has number of chars in first string
  3157                                  ; ES:DI points to first string
  3158                                  
  3159 000009B1 F3A6                    		repe cmpsb
  3160 000009B3 7417                    		jz	short MATCH	; match found!
  3161                                  
  3162                                  ; No match.  Let's find out what was wrong. The character that did not match
  3163                                  ; has been advanced over. Let's back up to it.
  3164                                  
  3165 000009B5 4E                      		dec	si
  3166                                  
  3167                                  ; If it is EOL, then syntax error
  3168                                  
  3169 000009B6 803C0D                  		cmp	byte [si],0Dh
  3170 000009B9 74B8                    		jz	short IFERRJ
  3171                                  
  3172                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3173                                  
  3174                                  SKIPSTRINGEND:
  3175 000009BB AC                      		lodsb
  3176                                  NOTMATCH:
  3177 000009BC 3C0D                    		cmp	al,0Dh
  3178                                  IFERRORJ2:
  3179 000009BE 74B3                    		jz	short IFERRJ
  3180 000009C0 E8BE0F                  		call	DELIM
  3181 000009C3 75F6                    		jnz	short SKIPSTRINGEND
  3182                                  
  3183                                  ; Signal that we did NOT have a match
  3184                                  
  3185 000009C5 B0FF                    		mov	al,-1
  3186 000009C7 EB3A                    		jmp	short IFRET
  3187                                  IFERRPJ:
  3188 000009C9 E95CFF                  		jmp	IFERRORP
  3189                                  
  3190                                  ; The compare succeeded. Was the second string longer than the first?
  3191                                  ; We do this by seeing if the next char is a delimiter.
  3192                                  
  3193                                  MATCH:
  3194 000009CC AC                      		lodsb
  3195 000009CD E8B10F                  		call	DELIM
  3196 000009D0 75EA                    		jnz	short NOTMATCH ; not same.
  3197 000009D2 30C0                    		xor	al,al
  3198 000009D4 EB2D                    		jmp	short IFRET
  3199                                  
  3200                                  ; ---------------------------------------------------------------------------
  3201                                  
  3202                                  IFEXISTS:
  3203                                  
  3204                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3205                                  
  3206                                  ;MOREDELIM:
  3207 000009D6 AC                      		lodsb
  3208 000009D7 E8A70F                  		call	DELIM
  3209 000009DA 75FA                    		jnz	short IFEXISTS
  3210                                  		;jnz	short MOREDELIM
  3211                                  
  3212 000009DC BA[5A43]                		mov	dx,DIRBUF
  3213 000009DF B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3214 000009E2 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3215                                  				; DS:DX	-> disk	transfer buffer
  3216 000009E4 BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3217 000009E7 031E[E54B]              		add	bx,[IF_NOT_COUNT]
  3218                                  		;mov	ax,ARG_ARGV
  3219                                  		;mov	ax,ARG+ARG_UNIT.argv
  3220 000009EB B8[9945]                		mov	ax,ARG
  3221 000009EE E8D91A                  		call	ARGV_CALC	; convert arg index to pointer
  3222 000009F1 8B17                    		mov	dx,[bx]
  3223                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3224                                  		;mov	cx,6
  3225 000009F3 B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3226 000009F6 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3227 000009F9 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3228                                  				; CX = search attributes
  3229                                  				; DS:DX	-> ASCIZ filespec
  3230                                  				; (drive,path, and wildcards allowed)
  3231 000009FB 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3232 000009FD 30C0                    		xor	al,al
  3233 000009FF EB02                    		jmp	short IFRET
  3234                                  
  3235                                  		;nop
  3236                                  IF_EX_C:
  3237 00000A01 B0FF                    		mov	al,-1		; false 'n' fall through...
  3238                                  IFRET:
  3239 00000A03 F606[7442]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3240 00000A08 7402                    		jz	short REALTEST
  3241 00000A0A F6D0                    		not	al
  3242                                  REALTEST:
  3243 00000A0C 08C0                    		or	al,al
  3244 00000A0E 7403                    		jz	short IFTRUE
  3245 00000A10 E9F1F6                  		jmp	TCOMMAND
  3246                                  
  3247                                  IFTRUE:
  3248 00000A13 E8630F                  		call	SCANOFF
  3249 00000A16 89F1                    		mov	cx,si
  3250 00000A18 81E98100                		sub	cx,81h
  3251 00000A1C 280E8000                		sub	[80h],cl
  3252 00000A20 8A0E8000                		mov	cl,[80h]
  3253 00000A24 880E[C140]              		mov	[COMBUF+1],cl
  3254 00000A28 BF[C240]                		mov	di,COMBUF+2
  3255 00000A2B FC                      		cld
  3256 00000A2C F3A4                    		rep movsb
  3257 00000A2E B00D                    		mov	al,0Dh
  3258 00000A30 AA                      		stosb
  3259                                  
  3260                                  ; Signal that an IF was done. 
  3261                                  ; This prevents the redirections from getting lost.
  3262                                  
  3263 00000A31 1E                      		push	ds
  3264 00000A32 8E1E[6142]              		mov	ds,[RESSEG]
  3265 00000A36 C606FA0BFF              		mov	byte [IFFLAG],-1
  3266 00000A3B 1F                      		pop	ds
  3267                                  
  3268                                  ; Go do the command
  3269                                  
  3270 00000A3C E96EF8                  		jmp	DOCOM1
  3271                                  
  3272                                  ; ---------------------------------------------------------------------------
  3273                                  
  3274                                  IFERRORJ3:
  3275 00000A3F E97CFF                  		jmp	IFERRORJ2
  3276                                  
  3277                                  IFERLEV:
  3278 00000A42 B70A                    		mov	bh,10
  3279 00000A44 30DB                    		xor	bl,bl
  3280                                  GETNUMLP:
  3281 00000A46 AC                      		lodsb
  3282 00000A47 3C0D                    		cmp	al,0Dh
  3283 00000A49 74F4                    		jz	short IFERRORJ3
  3284 00000A4B E8330F                  		call	DELIM
  3285 00000A4E 740C                    		jz	short GOTNUM
  3286 00000A50 2C30                    		sub	al,'0'
  3287 00000A52 86C3                    		xchg	al,bl
  3288 00000A54 F6E7                    		mul	bh
  3289 00000A56 00D8                    		add	al,bl
  3290 00000A58 86C3                    		xchg	al,bl
  3291 00000A5A EBEA                    		jmp	short GETNUMLP
  3292                                  GOTNUM:
  3293 00000A5C 1E                      		push	ds
  3294 00000A5D 8E1E[6142]              		mov	ds,[RESSEG]
  3295 00000A61 8A26EC0B                		mov	ah,byte [RETCODE]  ; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3296 00000A65 1F                      		pop	ds
  3297 00000A66 30C0                    		xor	al,al
  3298 00000A68 38DC                    		cmp	ah,bl
  3299 00000A6A 7397                    		jnb	short IFRET
  3300 00000A6C FEC8                    		dec	al
  3301 00000A6E EB93                    		jmp	short IFRET
  3302                                  
  3303                                  ; ---------------------------------------------------------------------------
  3304                                  
  3305                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3306                                  ; This is a NOP if no batch in progress.
  3307                                  
  3308                                  SHIFT:
  3309 00000A70 8E1E[6142]              		mov	ds,[RESSEG]
  3310 00000A74 A1990B                  		mov	ax,word [BATCH]	; get batch pointer
  3311 00000A77 09C0                    		or	ax,ax		; in batch mode?
  3312 00000A79 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3313                                  SHIFT_RETN:				; no, done.
  3314 00000A7B C3                      		retn
  3315                                  SHIFT1:
  3316 00000A7C 8EC0                    		mov	es,ax
  3317 00000A7E 8ED8                    		mov	ds,ax
  3318                                  
  3319                                  ; Now move the batch args down by 1 word
  3320                                  
  3321                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3322 00000A80 BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3323 00000A83 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3324 00000A86 B90900                  		mov	cx,9		; move 9 parameters
  3325 00000A89 F3A5                    		rep movsw		; SHIFT down
  3326                                  
  3327                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3328                                  ; We have copied it into the previous position.
  3329                                  
  3330 00000A8B 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3331 00000A8E 74EB                    		jz	short SHIFT_RETN ; No new parm
  3332                                  
  3333                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3334                                  ; Assume, first, that there is no next argument.
  3335                                   
  3336 00000A90 8B35                    		mov	si,[di]
  3337 00000A92 C705FFFF                		mov	word [di],-1	; Assume no parm
  3338                                  
  3339                                  ; The parameters are CR separated. Scan for end of this parm.
  3340                                  
  3341                                  SKIPCRLP:
  3342 00000A96 AC                      		lodsb
  3343 00000A97 3C0D                    		cmp	al,0Dh
  3344 00000A99 75FB                    		jnz	short SKIPCRLP
  3345                                  
  3346                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3347                                  ; are finished. There are no more parms and the pointer has been previously
  3348                                  ; initialized to indicate it.
  3349                                  
  3350 00000A9B 803C00                  		cmp	byte [si],0
  3351 00000A9E 74DB                    		jz	short SHIFT_RETN ; End of parms
  3352 00000AA0 8935                    		mov	[di],si		; Pointer to next parm as %9
  3353 00000AA2 C3                      		retn
  3354                                  
  3355                                  ; =============== S U B	R O U T	I N E =======================================
  3356                                  
  3357                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3358                                  ; returns char in AL, carry set -> eof
  3359                                  
  3360                                  SKIPDELIM:
  3361 00000AA3 F706990BFFFF            		test	word [BATCH],-1	; batch file empty.  OOPS!
  3362 00000AA9 740A                    		jz	short SKIPERR
  3363 00000AAB E8DFFD                  		call	GETBATBYT	; get a char
  3364 00000AAE E8D00E                  		call	DELIM		; check for ignoreable chars
  3365 00000AB1 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3366 00000AB3 F8                      		clc
  3367 00000AB4 C3                      		retn
  3368                                  SKIPERR:
  3369 00000AB5 F9                      		stc
  3370                                  GOTO_RETN:
  3371 00000AB6 C3                      		retn
  3372                                  
  3373                                  ; ---------------------------------------------------------------------------
  3374                                  
  3375                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3376                                  ;  .com file. This routine strips the CALL off the command line, sets
  3377                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3378                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3379                                  ;  being CALLed.
  3380                                  
  3381                                  _$CALL:
  3382                                  
  3383                                  ;  strip off CALL from command line
  3384                                  
  3385                                  		;ASSUME DS:trangroup,ES:trangroup
  3386                                  
  3387 00000AB7 56                      		push	si
  3388 00000AB8 57                      		push	di
  3389 00000AB9 50                      		push	ax
  3390 00000ABA 51                      		push	cx
  3391 00000ABB BE[C240]                		mov	si,COMBUF+2
  3392 00000ABE E8B80E                  		call	SCANOFF		;get to first non-delimeter
  3393                                  		;add	si,4
  3394 00000AC1 83C604                  		add	si,length_call	;point to char past CALL
  3395 00000AC4 BF[C240]                		mov	di,COMBUF+2
  3396                                  		;mov	cx,124		
  3397 00000AC7 B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3398 00000ACA F3A4                    		rep movsb		;move it
  3399 00000ACC 59                      		pop	cx
  3400 00000ACD 58                      		pop	ax
  3401 00000ACE 5F                      		pop	di
  3402 00000ACF 5E                      		pop	si
  3403                                  
  3404                                  ;  set call flag to indicate call in progress
  3405                                  
  3406 00000AD0 1E                      		push	ds
  3407 00000AD1 8E1E[6142]              		mov	ds,[RESSEG]
  3408 00000AD5 C606000C01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3409 00000ADA C606010C01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3410                                  
  3411                                  ; Turn off any pipes in progress.
  3412                                  
  3413 00000ADF 803E5D0C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3414 00000AE4 7403                    		jz	short _NOPIPE
  3415 00000AE6 E82714                  		call	PIPEDEL
  3416                                  _NOPIPE:
  3417 00000AE9 1F                      		pop	ds
  3418 00000AEA C3                      		retn
  3419                                  
  3420                                  ; ---------------------------------------------------------------------------
  3421                                  
  3422                                  GOTO:
  3423 00000AEB 8E1E[6142]              		mov	ds,[RESSEG]
  3424 00000AEF F706990BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3425 00000AF5 74BF                    		jz	short GOTO_RETN
  3426 00000AF7 31D2                    		xor	dx,dx
  3427 00000AF9 1E                      		push	ds
  3428 00000AFA 8E1E990B                		mov	ds,word [BATCH]
  3429 00000AFE 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3430 00000B02 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3431                                  
  3432                                  		; MSDOS 6.0
  3433                                  ;M037
  3434                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3435                                  ;
  3436                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3437                                  
  3438                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3439                                  
  3440 00000B06 1F                      		pop	ds
  3441                                  GOTOOPEN:
  3442 00000B07 E8ADF9                  		call	PROMPTBAT
  3443                                  		;mov	di,5Dh
  3444 00000B0A BF5D00                  		mov	di,FCB+1	; Get the label
  3445 00000B0D B90B00                  		mov	cx,11
  3446 00000B10 B020                    		mov	al,' '
  3447 00000B12 F2AE                    		repne scasb
  3448 00000B14 7501                    		jnz	short NOINC
  3449 00000B16 41                      		inc	cx
  3450                                  NOINC:
  3451 00000B17 83E90B                  		sub	cx,11
  3452 00000B1A F7D9                    		neg	cx
  3453 00000B1C 2E890E[5A43]            		mov	[cs:GOTOLEN],cx
  3454                                  
  3455                                  ; At beginning of file. Skip to first non-delimiter char
  3456                                  
  3457 00000B21 E87FFF                  		call	SKIPDELIM
  3458 00000B24 721C                    		jb	short BADGOTO
  3459 00000B26 3C3A                    		cmp	al,':'
  3460 00000B28 7423                    		jz	short CHKLABEL
  3461                                  LABLKLP:				; Look for the label
  3462 00000B2A E860FD                  		call	GETBATBYT
  3463 00000B2D 3C0A                    		cmp	al,0Ah
  3464 00000B2F 7509                    		jnz	short LABLKTST
  3465                                  
  3466                                  ; At beginning of line.  Skip to first non-delimiter char
  3467                                  
  3468 00000B31 E86FFF                  		call	SKIPDELIM
  3469 00000B34 720C                    		jb	short BADGOTO
  3470 00000B36 3C3A                    		cmp	al,':'
  3471 00000B38 7413                    		jz	short CHKLABEL
  3472                                  LABLKTST:
  3473 00000B3A F706990BFFFF            		test	word [BATCH],0FFFFh ; -1
  3474 00000B40 75E8                    		jnz	short LABLKLP
  3475                                  BADGOTO:
  3476 00000B42 E85000                  		call	BATCLOSE
  3477                                  
  3478                                  		; MSDOS 6.0
  3479                                  ;SR;
  3480                                  ; At this point we are terminating without freeing up any nested batch 
  3481                                  ;segments i.e if the error occurred within a called batch file. This routine
  3482                                  ;will traverse the linked list of batch segments and free all of them.
  3483                                  ;
  3484                                  		;call	free_batch	;free up nested batch segments
  3485                                  
  3486                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3487 00000B45 0E                      		push	cs
  3488 00000B46 1F                      		pop	ds
  3489 00000B47 BA[573C]                		mov	dx,BADLABPTR
  3490 00000B4A E9D610                  		jmp	CERROR
  3491                                  
  3492                                  ; Found the :.	Skip to first non-delimiter char
  3493                                  
  3494                                  CHKLABEL:
  3495 00000B4D E853FF                  		call	SKIPDELIM
  3496 00000B50 72F0                    		jb	short BADGOTO
  3497 00000B52 BF5D00                  		mov	di,FCB+1 ; 5Dh
  3498 00000B55 2E8B0E[5A43]            		mov	cx,[cs:GOTOLEN]
  3499 00000B5A EB05                    		jmp	short GOTBYTE
  3500                                  
  3501                                  NEXTCHRLP:
  3502 00000B5C 51                      		push	cx
  3503 00000B5D E82DFD                  		call	GETBATBYT
  3504 00000B60 59                      		pop	cx
  3505                                  GOTBYTE:
  3506 00000B61 0C20                    		or	al,20h
  3507 00000B63 263A05                  		cmp	al,[es:di]
  3508 00000B66 7502                    		jnz	short TRYUPPER
  3509 00000B68 EB07                    		jmp	short NEXTLABCHR
  3510                                  TRYUPPER:
  3511 00000B6A 2C20                    		sub	al,20h
  3512 00000B6C 263A05                  		cmp	al,[es:di]
  3513 00000B6F 75C9                    		jnz	short LABLKTST
  3514                                  NEXTLABCHR:
  3515 00000B71 47                      		inc	di
  3516 00000B72 E2E8                    		loop	NEXTCHRLP
  3517 00000B74 E816FD                  		call	GETBATBYT
  3518 00000B77 2E833E[5A43]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3519 00000B7D 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3520 00000B7F 3C20                    		cmp	al,' '
  3521 00000B81 77B7                    		ja	short LABLKTST
  3522                                  GOTOCONT:
  3523 00000B83 3C0D                    		cmp	al,0Dh
  3524 00000B85 7407                    		jz	short SKIPLFEED
  3525                                  TONEXTBATLIN:
  3526 00000B87 E803FD                  		call	GETBATBYT
  3527 00000B8A 3C0D                    		cmp	al,0Dh
  3528 00000B8C 75F9                    		jnz	short TONEXTBATLIN
  3529                                  SKIPLFEED:
  3530 00000B8E E8FCFC                  		call	GETBATBYT
  3531                                  
  3532                                  		; MSDOS 6.0
  3533                                  ;SR;
  3534                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3535                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3536                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3537                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3538                                  ;all other cases, EOF will be hit while trying to read the next line and
  3539                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3540                                  ;
  3541                                  		;push	es
  3542                                  		;mov	es,Batch
  3543                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3544                                  		;pop	es
  3545                                  
  3546                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3547 00000B91 E80100                  		call	BATCLOSE
  3548 00000B94 C3                      		retn
  3549                                  
  3550                                  ; =============== S U B	R O U T	I N E =======================================
  3551                                  
  3552                                  BATCLOSE:
  3553 00000B95 2E8B1E[8545]            		mov	bx,[cs:BATHAND]
  3554 00000B9A 83FB05                  		cmp	bx,5
  3555 00000B9D 7204                    		jb	short CLOSERETURN
  3556 00000B9F B43E                    		mov	ah,CLOSE ; 3Eh
  3557 00000BA1 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3558                                  				; BX = file handle
  3559                                  CLOSERETURN:
  3560 00000BA3 C606E40B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3561 00000BA8 C3                      		retn
  3562                                  
  3563                                  ; =============== S U B	R O U T	I N E =======================================
  3564                                  
  3565                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3566                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3567                                  
  3568                                  BATOPEN:
  3569 00000BA9 1E                      		push	ds
  3570 00000BAA 8E1E990B                		mov	ds,word [BATCH]
  3571                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3572 00000BAE BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3573 00000BB1 B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3574 00000BB4 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3575                                  				; DS:DX	-> ASCIZ filename
  3576                                  				; AL = access mode
  3577                                  				; 0 - read
  3578 00000BB6 721C                    		jb	short SETERRDL
  3579 00000BB8 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3580 00000BBC 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3581 00000BC0 1F                      		pop	ds
  3582 00000BC1 2EA3[8545]              		mov	[cs:BATHAND],ax
  3583 00000BC5 89C3                    		mov	bx,ax
  3584 00000BC7 B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3585 00000BCA CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3586                                  				; AL = method: offset from beginning of	file
  3587                                  
  3588 00000BCC 2EC706[084D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3589                                  BATOPEN_RETN:
  3590 00000BD3 C3                      		retn
  3591                                  
  3592                                  SETERRDL:
  3593 00000BD4 89D3                    		mov	bx,dx
  3594                                  		; MSDOS 6.0
  3595                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3596                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3597                                  
  3598                                  		; MSDOS 3.3
  3599 00000BD6 BA[8E37]                		mov	dx,INSERTDSKPTR
  3600 00000BD9 E8E812                  		call	GET_EXT_ERR_NUMBER
  3601                                  
  3602                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3603 00000BDC 8A07                    		mov	al,[bx]		; Get drive spec
  3604 00000BDE 2C40                    		sub	al,'@'		; A = 1
  3605 00000BE0 1F                      		pop	ds
  3606 00000BE1 F9                      		stc			; SUB mucked over carry
  3607 00000BE2 C3                      		retn
  3608                                  
  3609                                  ;============================================================================
  3610                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3611                                  ;============================================================================
  3612                                  ; 10/10/2018 - Retro DOS v3.0
  3613                                  
  3614                                  ; All batch proccessing has DS set to segment of resident portion
  3615                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3616                                  
  3617                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3618                                  
  3619                                  ; ---------------------------------------------------------------------------
  3620                                  
  3621                                  FORTERM:
  3622                                  		; MSDOS 6.0
  3623                                  		;push	cs		;AN037; Get local segment into
  3624                                  		;pop	ds		;AN037;    DS, ES
  3625                                  		;push	cs		;AN037;
  3626                                  		;pop	es		;AN037;
  3627                                  
  3628                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3629 00000BE3 E8B502                  		call	FOROFF
  3630 00000BE6 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  3631 00000BEB 813EF50B00FF            		cmp	word [SINGLECOM],0FF00h
  3632 00000BF1 750F                    		jne	short BAT_CRLF
  3633 00000BF3 833EFE0B00              		cmp	word [NEST],0	;See if we have nested batch files
  3634 00000BF8 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3635 00000BFA C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3636 00000C00 EB12                    		jmp	short NOFORP2
  3637                                  BAT_CRLF:
  3638 00000C02 F606EF0B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3639 00000C07 740B                    		jz	short NOFORP2	; no - exit
  3640 00000C09 F706990BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3641 00000C0F 7403                    		jz	short NOFORP2
  3642 00000C11 E8580D                  		call	CRLF2
  3643                                  NOFORP2:
  3644 00000C14 E9EDF4                  		jmp	TCOMMAND
  3645                                  
  3646                                  ; ---------------------------------------------------------------------------
  3647                                  
  3648                                  ;------
  3649                                  ;   For-loop processing.  For loops are of the form:
  3650                                  ;	    for %<loop-variable> in (<list>) do <command>
  3651                                  ; where <command> may contain references of the form %<variable>, which are
  3652                                  ; later substituted with the items in <list>. The for-loop structure is
  3653                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3654                                  ; <command> once for each item in <list>. All of the information needed for
  3655                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3656                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3657                                  ; a complete copy of the original command-line structure as parsed by
  3658                                  ; 'parseline', loop control variables, and a dma buffer for the
  3659                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3660                                  ; processing has completed, this chunk of memory is returned to the system.
  3661                                  ;
  3662                                  ;   All of the previously defined variables, in 'datares', used for loop
  3663                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3664                                  ;
  3665                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3666                                  ; containing all of the other error messages.
  3667                                  ;
  3668                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3669                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3670                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3671                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3672                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3673                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3674                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3675                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3676                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3677                                  ; instead of
  3678                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3679                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3680                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3681                                  ; doesn't matter whether we put brackets around the location or not -- the
  3682                                  ; assembler is "smart" enough to know that we want an address instead of the
  3683                                  ; contents of that location.
  3684                                  ;
  3685                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3686                                  ; One method would be to have a link field in each for-structure pointing to
  3687                                  ; its parent.  Variable references that couldn't be resolved in the local
  3688                                  ; frame would cause a search of prior frames. For-structures would still be
  3689                                  ; allocated and released in exactly the same fashion. The only limit on the
  3690                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3691                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3692                                  ; maintained in the resident data area. This structure would be an array of
  3693                                  ; control-variable names and pointers to for-structure blocks. This would
  3694                                  ; greatly speed up the resolution of non-local variable references. However,
  3695                                  ; since space in the resident is precious, we would have to compromise on a
  3696                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3697                                  ; allocation and de-allocation would have to be modified slightly to take this
  3698                                  ; new structure into account.
  3699                                  ;
  3700                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3701                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3702                                  ; it may be easier to allocate it as part of 'for_segment'.
  3703                                  ;------
  3704                                  
  3705                                  		; include fordata.asm
  3706                                  
  3707                                  ; Data structure definitions included by tfor.asm
  3708                                  
  3709                                  struc FOR_INFO
  3710 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3711 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
  3712 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3713 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
  3714 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
  3715 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
  3716 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
  3717 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
  3718                                    .size:
  3719                                  endstruc
  3720                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3721                                  
  3722                                  _$FOR_EXIT:
  3723 00000C17 EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3724                                  
  3725                                  ; ---------------------------------------------------------------------------
  3726                                  
  3727                                  FORPROC:
  3728 00000C19 A1FC0B                  		mov	ax,word [FORPTR]
  3729 00000C1C 8ED8                    		mov	ds,ax
  3730 00000C1E 8EC0                    		mov	es,ax		; operate in for-info area
  3731 00000C20 BACB05                  		mov	dx,FOR_INFO.FORDMA
  3732 00000C23 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3733 00000C26 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3734                                  				; DS:DX	-> disk	transfer buffer
  3735                                  FOR_BEGIN:
  3736 00000C28 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3737 00000C2D 7404                    		jz	short FOR_BEGIN1
  3738                                  					; non-zero for_expand equals FALSE
  3739 00000C2F FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3740                                  
  3741                                  FOR_BEGIN1:
  3742 00000C33 8B1E4705                		mov	bx,word [FOR_INFO.FOR_MINARG]
  3743                                  					; current item in <list> to examine
  3744 00000C37 3B1E4905                		cmp	bx,word [FOR_INFO.FOR_MAXARG]	; [549h]
  3745 00000C3B 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3746                                  		;mov	ax,0
  3747 00000C3D B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3748 00000C40 E88718                  		call	ARGV_CALC	; compute argv[x] address
  3749                                  		;mov	cx,[bx+3]
  3750 00000C43 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3751 00000C46 8B17                    		mov	dx,[bx]
  3752                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3753                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3754 00000C48 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3755 00000C4C 7516                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3756 00000C4E 8B37                    		mov	si,[bx]
  3757                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3758                                  
  3759 00000C50 2EA0[E53E]              		mov	al,[cs:LPAREN]
  3760 00000C54 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3761 00000C57 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3762 00000C59 41                      		inc	cx		;  the opening paren as its first char,
  3763                                  					;  the argstartel ptr needs to be
  3764                                  					;  advanced passed it before the prefix
  3765                                  					;  length is computed.
  3766 00000C5A B03A                    		mov	al,':'
  3767 00000C5C 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3768 00000C5F 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3769 00000C61 83C102                  		add	cx,2		;  rest of the prefix as well.
  3770                                  FORSUB:
  3771 00000C64 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3772 00000C66 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3773 00000C6B 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3774                                  		;test	byte [bx+2],2
  3775 00000C6D F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3776 00000C71 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3777                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3778 00000C73 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3779 00000C76 EB1F                    		jmp	short FOR_SMOOSH
  3780                                  
  3781                                  		;nop
  3782                                  FOR_FIND_FIRST:
  3783 00000C78 51                      		push	cx
  3784 00000C79 31C9                    		xor	cx,cx
  3785 00000C7B B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3786 00000C7E CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3787                                  				; CX = search attributes
  3788                                  				; DS:DX	-> ASCIZ filespec
  3789                                  				; (drive,path, and wildcards allowed)
  3790 00000C80 59                      		pop	cx
  3791 00000C81 EB05                    		jmp	short FOR_RESULT
  3792                                  
  3793                                  		;nop
  3794                                  FOR_FIND_NEXT:
  3795 00000C83 B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3796 00000C86 CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3797                                  				; [DTA]	= data block from
  3798                                  				; last AH = 4Eh/4Fh call
  3799                                  FOR_RESULT:
  3800 00000C88 B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3801 00000C8B 7203                    		jc	short FOR_CHECK
  3802 00000C8D B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3803                                  FOR_CHECK:				; record success of findfirst/next
  3804 00000C90 A34505                  		mov	word [FOR_INFO.FOR_EXPAND],ax
  3805 00000C93 09C0                    		or	ax,ax	; anything out there?
  3806 00000C95 7591                    		jnz	short FOR_BEGIN	; if not, try next arg
  3807                                  FOR_SMOOSH:
  3808                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3809 00000C97 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3810 00000C99 BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3811 00000C9C F3A4                    		rep movsb		; arg, some days just the path prefix
  3812                                  					
  3813 00000C9E 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3814                                  					; if we're not expanding, we can
  3815 00000CA3 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3816                                  
  3817                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3818 00000CA5 BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3819                                  FOR_MORE:
  3820 00000CA8 803C00                  		cmp	byte [si],0	; tack on matching filename
  3821 00000CAB 7403                    		jz	short FOR_MAKE_COM
  3822 00000CAD A4                      		movsb
  3823 00000CAE 75F8                    		jnz	short FOR_MORE
  3824                                  FOR_MAKE_COM:
  3825 00000CB0 30C0                    		xor	al,al		; tack a null byte onto the end
  3826 00000CB2 AA                      		stosb			; of the substitute string
  3827 00000CB3 31C9                    		xor	cx,cx		; character count for command line
  3828 00000CB5 F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3829 00000CB7 31DB                    		xor	bx,bx		; argpointer
  3830 00000CB9 BF[C240]                		mov	di,COMBUF+2
  3831 00000CBC 8A1E4405                		mov	bl,byte [FOR_INFO.FOR_COM_START] ; argindex
  3832 00000CC0 8A364B06                		mov	dh,byte [FOR_INFO.FOR_VAR] 
  3833                                  					; %<for-var> is replaced by [forbuf]
  3834 00000CC4 0E                      		push	cs		; time to form the <command> string
  3835 00000CC5 07                      		pop	es
  3836                                  		;assume ES:trangroup
  3837                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3838 00000CC6 B80000                  		mov	ax,0		; translate offset to pointer
  3839 00000CC9 E8FE17                  		call	ARGV_CALC
  3840                                  		;mov	si,[bx+9]
  3841 00000CCC 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3842                                  					; mov ptr passed beginning space
  3843 00000CCF 46                      		inc	si
  3844                                  FOR_MAKE_LOOP:
  3845 00000CD0 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3846 00000CD2 46                      		inc	si
  3847 00000CD3 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3848 00000CD5 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3849 00000CD7 3834                    		cmp	[si],dh		; got the right <variable>?
  3850 00000CD9 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3851 00000CDB 46                      		inc	si		; skip over <for-variable>
  3852                                  
  3853 00000CDC 56                      		push	si
  3854 00000CDD BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3855                                  					; to make a final <command> to execute
  3856                                  SLOOP:					
  3857 00000CE0 AC                      		lodsb			; grab all those <item> bytes, and
  3858 00000CE1 AA                      		stosb			; add 'em to the <command> string,
  3859 00000CE2 08C0                    		or	al,al		; until we run into a null
  3860 00000CE4 E0FA                    		loopne	SLOOP
  3861 00000CE6 4F                      		dec	di		; adjust length and <command> pointer
  3862 00000CE7 41                      		inc	cx		; so we can overwrite the null
  3863 00000CE8 5E                      		pop	si
  3864 00000CE9 EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3865                                  
  3866                                  FOR_STOSB:
  3867 00000CEB AA                      		stosb			; take a byte from the <command> arg
  3868 00000CEC 49                      		dec	cx		; and put it into the <command> to be
  3869                                  					; executed (and note length, too)
  3870 00000CED 3C0D                    		cmp	al,0Dh		
  3871 00000CEF 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3872                                  FOR_MADE_COM:
  3873 00000CF1 F6D1                    		not	cl
  3874 00000CF3 2E880E[C140]            		mov	[cs:COMBUF+1],cl
  3875                                  
  3876 00000CF8 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  3877                                  		;assume DS:resgroup
  3878 00000CFD F606EF0B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3879 00000D02 742F                    		jz	short NOECHO3
  3880                                  		;cmp	byte [NULLFLAG],nullcommand
  3881 00000D04 803E040C01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3882 00000D09 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3883                                  
  3884 00000D0B E85E0C                  		call	CRLF2		  ;G  Print out prompt
  3885                                  NO_CRLF_PR:
  3886 00000D0E C606040C00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3887 00000D13 0E                      		push	cs
  3888 00000D14 1F                      		pop	ds
  3889 00000D15 57                      		push	di
  3890 00000D16 E87106                  		call	PRINT_PROMPT	  ;G Prompt the user
  3891 00000D19 5F                      		pop	di
  3892                                  
  3893 00000D1A 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3894 00000D1F C706[3E44][C240]        		mov	word [STRING_PTR_2],COMBUF+2
  3895 00000D25 BA[2F37]                		mov	dx,STRINGBUF2PTR
  3896 00000D28 E89827                  		call	STD_PRINTF
  3897 00000D2B 26C645FF0D              		mov	byte [es:di-1],0Dh
  3898 00000D30 E977F5                  		jmp	DOCOM		  ; run silent, run deep...
  3899                                  NOECHO3:
  3900 00000D33 C606040C00              		mov	byte [NULLFLAG],0
  3901 00000D38 0E                      		push	cs
  3902 00000D39 1F                      		pop	ds
  3903 00000D3A E970F5                  		jmp	DOCOM1
  3904                                  
  3905                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3906 00000D3D E85B01                  		call	FOROFF
  3907 00000D40 E93E01                  		jmp	FORNESTERR
  3908                                  
  3909                                  ; ---------------------------------------------------------------------------
  3910                                  
  3911                                  FORERRORJ:
  3912 00000D43 E9E3FB                  		jmp	FORERROR
  3913                                  
  3914                                  ; ---------------------------------------------------------------------------
  3915                                  
  3916                                  _$FOR:
  3917 00000D46 8E06[6142]              		mov	es,[RESSEG]
  3918 00000D4A 26803EFB0B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3919 00000D50 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3920                                  
  3921                                  ; Turn off any pipes in progress.
  3922                                  
  3923 00000D52 26803E5D0C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3924 00000D58 7403                    		jz	short NO_PIPE
  3925 00000D5A E8B311                  		call	PIPEDEL
  3926                                  NO_PIPE:
  3927 00000D5D 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3928 00000D5F E80901                  		call	NEXTARG		; move to next argv[n]
  3929 00000D62 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3930 00000D64 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3931 00000D66 75DB                    		jnz	short FORERRORJ
  3932 00000D68 89C5                    		mov	bp,ax		; save forloop variable
  3933 00000D6A AC                      		lodsb
  3934 00000D6B 08C0                    		or	al,al		; and MUST end immediately...
  3935 00000D6D 75D4                    		jnz	short FORERRORJ
  3936 00000D6F E8F900                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3937 00000D72 72CF                    		jb	short FORERRORJ
  3938                                  		;and	ax,0DFDFh
  3939 00000D74 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3940 00000D77 3B06[E93E]              		cmp	ax,word [IN_WORD]
  3941 00000D7B 75C6                    		jnz	short FORERRORJ
  3942 00000D7D AC                      		lodsb
  3943                                  
  3944                                  		; MSDOS 3.3
  3945 00000D7E 08C0                    		or	al,al		; it, too, must end right away
  3946 00000D80 7416                    		jz	short CHECKLPAREN
  3947 00000D82 3A06[E53E]              		cmp	al,[LPAREN]
  3948 00000D86 75BB                    		jnz	short FORERRORJ
  3949                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3950 00000D88 830702                  		add	word [bx],2
  3951                                  		;add	word [bx+9],2
  3952 00000D8B 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3953                                  		;sub	word [bx+5],2
  3954 00000D8F 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3955 00000D93 8B44FF                  		mov	ax,[si-1]
  3956 00000D96 EB05                    		jmp	short LPCHECK
  3957                                  
  3958                                  		; MSDOS 6.0
  3959                                  ;; Compaq bug fix -- exit from this loop on error
  3960                                  ;
  3961                                  ;		or	al,al
  3962                                  ;		jne	forerrorj	; jump on error
  3963                                  ;
  3964                                  ;;;		je	CheckLParen
  3965                                  ;;
  3966                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  3967                                  ;;   FOR %i in(foo bar...
  3968                                  ;; Check for the Lparen here
  3969                                  ;;
  3970                                  ;;;		CMP	AL,lparen
  3971                                  ;;;		JNZ	forerrorj
  3972                                  ;;
  3973                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  3974                                  ;; being there in the first place.
  3975                                  ;;
  3976                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  3977                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  3978                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  3979                                  ;;
  3980                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  3981                                  ;; current value.
  3982                                  ;;
  3983                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  3984                                  ;;;		jmp	short lpcheck
  3985                                  ;;
  3986                                  ;; end of Compaq bug fix
  3987                                  
  3988                                  ; ---------------------------------------------------------------------------
  3989                                  
  3990                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3991                                  CHECKLPAREN:
  3992 00000D98 E8D000                  		call	NEXTARG		; lparen delimits beginning of <list>
  3993 00000D9B 72A6                    		jc	short FORERRORJ
  3994                                  LPCHECK:
  3995 00000D9D 3A06[E53E]              		cmp	al,[LPAREN]
  3996 00000DA1 75A0                    		jne	short FORERRORJ
  3997 00000DA3 80FC00                  		cmp	ah,0
  3998 00000DA6 7411                    		je	short FOR_PAREN_TOKEN
  3999 00000DA8 3A26[E63E]              		cmp	ah,byte [RPAREN] ; special case:  null list	
  4000 00000DAC 7503                    		jne	short FOR_LIST_NOT_EMPTY
  4001 00000DAE E932FE                  		jmp	FORTERM
  4002                                  FOR_LIST_NOT_EMPTY:
  4003                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4004 00000DB1 FF07                    		inc	word [bx]	; Advance ptr past "("
  4005                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4006 00000DB3 FF4F05                  		dec	word [bx+ARGV_ELE.arglen] 	;  to agree.
  4007 00000DB6 46                      		inc	si		; Inc si so check for ")" works
  4008 00000DB7 EB11                    		jmp	short FOR_LIST
  4009                                  
  4010                                  		;nop
  4011                                  FOR_PAREN_TOKEN:
  4012 00000DB9 E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4013 00000DBC 7285                    		jc	short FORERRORJ
  4014                                  		;cmp	ax,[RPAREN+1]	
  4015 00000DBE 3B06[E73E]              		cmp	ax,[NULLRPAREN]	; special case:  null list
  4016 00000DC2 7506                    		jne	short FOR_LIST
  4017 00000DC4 E91CFE                  		jmp	FORTERM
  4018                                  
  4019                                  FORERORJJ:
  4020 00000DC7 E95FFB                  		jmp	FORERROR
  4021                                  
  4022                                  FOR_LIST:				; skip over rest of <list>
  4023 00000DCA 89D1                    		mov	cx,dx		; first arg of <list>
  4024                                  
  4025                                  SKIP_LIST:
  4026                                  		;add	si,[bx+5]
  4027 00000DCC 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4028 00000DCF 83EE03                  		sub	si,3		; si = ptr to last char of token
  4029 00000DD2 A0[E63E]                		mov	al,byte [RPAREN]
  4030 00000DD5 3804                    		cmp	[si],al		; Is this the last element in <list>
  4031 00000DD7 7407                    		je	short FOR_END_LIST ; Yes, exit loop.
  4032 00000DD9 E88F00                  		call	NEXTARG		; No, get next arg <list>
  4033 00000DDC 72E9                    		jc	short FORERORJJ	; If no more and no rparen, error.
  4034 00000DDE EBEC                    		jmp	short SKIP_LIST
  4035                                  
  4036                                  FOR_END_LIST:
  4037 00000DE0 89D7                    		mov	di,dx		; record position of last arg in <list>
  4038 00000DE2 C60400                  		mov	byte [si],0	; Zap the rparen
  4039                                  		;cmp	ax,[RPAREN+1]	
  4040 00000DE5 3B06[E73E]              		cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4041 00000DE9 7401                    		je	short FOR_DO	; Yes, continue
  4042 00000DEB 47                      		inc	di		; No, inc position of last arg
  4043                                  FOR_DO:
  4044 00000DEC E87C00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4045 00000DEF 72D6                    		jc	short FORERORJJ
  4046                                  		;and	ax,0DFDFh	
  4047 00000DF1 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4048 00000DF4 3B06[EB3E]              		cmp	ax,word [DO_WORD]
  4049 00000DF8 75CD                    		jne	short FORERORJJ
  4050 00000DFA AC                      		lodsb
  4051 00000DFB 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4052 00000DFD 75C8                    		jnz	short FORERORJJ
  4053                                  		
  4054 00000DFF E86900                  		call	NEXTARG		; on to the beginning of <command>
  4055 00000E02 72C3                    		jc	short FORERORJJ	; null <command> not legal
  4056                                  
  4057 00000E04 50                      		push	ax
  4058 00000E05 53                      		push	bx
  4059 00000E06 51                      		push	cx
  4060 00000E07 52                      		push	dx		; preserve registers against disaster
  4061 00000E08 57                      		push	di
  4062 00000E09 56                      		push	si
  4063 00000E0A 55                      		push	bp
  4064 00000E0B E852F8                  		call	FREE_TPA	; need to make free memory, first
  4065 00000E0E E88A00                  		call	FOROFF
  4066                                  		;mov	bx,264
  4067 00000E11 BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4068 00000E14 E89519                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4069 00000E17 9C                      		pushf
  4070 00000E18 26A3FC0B                		mov	word [es:FORPTR],ax
  4071 00000E1C E851F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4072 00000E1F 9D                      		popf
  4073 00000E20 5D                      		pop	bp
  4074 00000E21 5E                      		pop	si
  4075 00000E22 5F                      		pop	di
  4076 00000E23 5A                      		pop	dx
  4077 00000E24 59                      		pop	cx
  4078 00000E25 5B                      		pop	bx
  4079 00000E26 58                      		pop	ax
  4080 00000E27 723C                    		jc	short FOR_ALLOC_ERR
  4081                                  
  4082 00000E29 06                      		push	es		; save resgroup seg...
  4083 00000E2A 26FF36FC0B              		push	word [es:FORPTR]
  4084 00000E2F 07                      		pop	es
  4085                                  		;assume ES:for_segment	
  4086 00000E30 49                      		dec	cx		; forproc wants min pointing before
  4087 00000E31 4F                      		dec	di		; first arg, max right at last one
  4088 00000E32 26890E4705              		mov	word [es:FOR_INFO.FOR_MINARG],cx
  4089 00000E37 26893E4905              		mov	word [es:FOR_INFO.FOR_MAXARG],di
  4090 00000E3C 2688164405              		mov	byte [es:FOR_INFO.FOR_COM_START],dl
  4091 00000E41 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4092 00000E48 89E8                    		mov	ax,bp
  4093 00000E4A 2688264B06              		mov	byte [es:FOR_INFO.FOR_VAR],ah
  4094 00000E4F 07                      		pop	es
  4095                                  		;assume ES:resgroup	
  4096 00000E50 26FE06FB0B              		inc	byte [es:FORFLAG]
  4097 00000E55 26833EF50BFF            		cmp	word [es:SINGLECOM],-1
  4098 00000E5B 7507                    		jne	short FOR_RET
  4099 00000E5D 26C706F50B00FF          		mov	word [es:SINGLECOM],0FF00h
  4100                                  FOR_RET:
  4101 00000E64 C3                      		retn
  4102                                  
  4103                                  FOR_ALLOC_ERR:
  4104                                  		; MSDOS 3.0
  4105 00000E65 BA[9A3C]                		mov	dx,INSFMEMMESPTR
  4106 00000E68 E9B80D                  		jmp	CERROR
  4107                                  
  4108                                  		; MSDOS 6.0
  4109                                  		;mov	msg_disp_class,ext_msg_class	
  4110                                  		;			;AN000; set up extended error msg class
  4111                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4112                                  		;			;AC000; get extended message pointer
  4113                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4114                                  		;			;AN000; get message number in control block
  4115                                  		;jmp	cerror
  4116                                  
  4117                                  
  4118                                  ; =============== S U B	R O U T	I N E =======================================
  4119                                  
  4120                                  NEXTARG:
  4121 00000E6B 42                      		inc	dx		; next argv[n]
  4122                                  		;cmp	dx,[ARG_ARGVCNT]
  4123 00000E6C 3B16[5948]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4124 00000E70 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4125 00000E72 89D3                    		mov	bx,dx
  4126                                  		;mov	ax,ARG_ARGV
  4127                                  		;mov	ax,ARG+ARG_UNIT.argv
  4128 00000E74 B8[9945]                		mov	ax,ARG
  4129 00000E77 E85016                  		call	ARGV_CALC	; convert array index to pointer
  4130 00000E7A 8B37                    		mov	si,[bx]		; load pointer to argstring
  4131                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4132 00000E7C AD                      		lodsw			; and load first two chars
  4133 00000E7D F8                      		clc
  4134 00000E7E C3                      		retn
  4135                                  NEXTARG_ERR:
  4136 00000E7F F9                      		stc
  4137 00000E80 C3                      		retn
  4138                                  
  4139                                  ; ---------------------------------------------------------------------------
  4140                                  
  4141                                  FORNESTERR:
  4142 00000E81 1E                      		push	ds
  4143 00000E82 8E1E[6142]              		mov	ds,[RESSEG]
  4144                                  		;ASSUME DS:RESGROUP
  4145 00000E86 BA[823C]                		mov	dx,FORNESTMESTR
  4146 00000E89 813EF50B00FF            		cmp	word [SINGLECOM],0FF00h
  4147 00000E8F 7506                    		jnz	short NOFORP3
  4148 00000E91 C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4149                                  NOFORP3:
  4150 00000E97 1F                      		pop	ds
  4151 00000E98 E9880D                  		jmp	CERROR
  4152                                  
  4153                                  ; =============== S U B	R O U T	I N E =======================================
  4154                                  
  4155                                  ; General routine called to free the for segment. We also clear the forflag
  4156                                  ; too. Change no registers.
  4157                                  
  4158                                  FOROFF:
  4159 00000E9B 50                      		push	ax
  4160 00000E9C 06                      		push	es
  4161 00000E9D 2E8E06[6142]            		mov	es,[cs:RESSEG]
  4162 00000EA2 26A1FC0B                		mov	ax,word [es:FORPTR]
  4163 00000EA6 09C0                    		or	ax,ax
  4164 00000EA8 7408                    		jz	short FREEDONE
  4165 00000EAA 06                      		push	es
  4166 00000EAB 8EC0                    		mov	es,ax
  4167 00000EAD B449                    		mov	ah,DEALLOC ; 49h
  4168 00000EAF CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4169                                  				; ES = segment address of area to be freed
  4170 00000EB1 07                      		pop	es
  4171                                  FREEDONE:
  4172 00000EB2 26C706FC0B0000          		mov	word [es:FORPTR],0
  4173 00000EB9 26C606FB0B00            		mov	byte [es:FORFLAG],0
  4174 00000EBF 07                      		pop	es
  4175 00000EC0 58                      		pop	ax
  4176 00000EC1 C3                      		retn
  4177                                  
  4178                                  ;============================================================================
  4179                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4180                                  ;============================================================================
  4181                                  ; 09/10/2018 - Retro DOS v3.0
  4182                                  
  4183                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4184                                  
  4185                                  ; ---------------------------------------------------------------------------
  4186                                  
  4187                                  ; The DIR command displays the contents of a directory.
  4188                                  ;
  4189                                  ; ****************************************************************
  4190                                  ; *
  4191                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4192                                  ; *
  4193                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4194                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4195                                  ; *		 If an error occurs issue and error message and
  4196                                  ; *		 transfer control to CERROR.
  4197                                  ; *
  4198                                  ; * INPUT:	 command line at offset 81H
  4199                                  ; *
  4200                                  ; * OUTPUT:	 none
  4201                                  ; *
  4202                                  ; ****************************************************************
  4203                                  
  4204                                  CATALOG:
  4205                                  		; MSDOS 3.3
  4206                                  
  4207                                  		;mov	ax,ARG_ARGV
  4208                                  		;mov	ax,ARG+ARG_UNIT.argv
  4209 00000EC2 B8[9945]                		mov	ax,ARG
  4210 00000EC5 BAFFFF                  		mov	dx,0FFFFh
  4211 00000EC8 31C9                    		xor	cx,cx
  4212 00000ECA 31F6                    		xor	si,si
  4213                                  
  4214                                  DIR1:
  4215                                  		;cmp	cx,[ARG_ARGVCNT]
  4216 00000ECC 3B0E[5948]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4217 00000ED0 733F                    		jnb	short DIR6 ; No more arguments
  4218 00000ED2 89CB                    		mov	bx,cx
  4219 00000ED4 E8F315                  		call	ARGV_CALC
  4220                                  		;or	si,[bx+7]
  4221 00000ED7 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4222 00000EDA F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4223 00000EDE 7508                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4224                                  		;test	byte [bx+2],1
  4225 00000EE0 F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4226 00000EE4 7408                    		jz	short DIR3
  4227 00000EE6 EB26                    		jmp	short DIR5
  4228                                  DIR2:
  4229 00000EE8 BA[123A]                		mov	dx,BADPARMPTR
  4230 00000EEB E9350D                  		jmp	CERROR
  4231                                  DIR3:
  4232 00000EEE 09C9                    		or	cx,cx
  4233 00000EF0 7515                    		jnz	short DIR4	
  4234                                  		;cmp	word [bx+5],3
  4235 00000EF2 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4236 00000EF6 7416                    		jz	short DIR5
  4237                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4238 00000EF8 830703                  		add	word [bx],3
  4239                                  		;add	word [bx+9],3
  4240 00000EFB 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4241                                  		;add	word [bx+3],3
  4242 00000EFF 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4243                                  		;sub	word [bx+5],3
  4244 00000F03 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4245                                  DIR4:
  4246 00000F07 83FAFF                  		cmp	dx,0FFFFh
  4247 00000F0A 75DC                    		jnz	short DIR2
  4248 00000F0C 89DA                    		mov	dx,bx
  4249                                  
  4250 00000F0E 41                      DIR5:		inc	cx
  4251 00000F0F EBBB                    		jmp	short DIR1
  4252                                  DIR6:
  4253 00000F11 8936[7842]              		mov	[COMSW],si
  4254 00000F15 52                      		push	dx
  4255 00000F16 30C0                    		xor	al,al
  4256 00000F18 83FAFF                  		cmp	dx,0FFFFh
  4257 00000F1B 7410                    		jz	short DIR7
  4258 00000F1D 89D3                    		mov	bx,dx
  4259                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4260 00000F1F 8B3F                    		mov	di,[bx]
  4261 00000F21 807D013A                		cmp	byte [di+1],':'
  4262 00000F25 7506                    		jnz	short DIR7
  4263 00000F27 8A05                    		mov	al,[di]
  4264 00000F29 0C20                    		or	al,20h		; Lowercase drive name	
  4265 00000F2B 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4266                                  DIR7:
  4267                                  		;mov	[5CH],al
  4268 00000F2D A25C00                  		mov	[FCB],al
  4269 00000F30 E80A04                  		call	OKVOLARG
  4270 00000F33 B03F                    		mov	al,'?'		; *.* is default file spec.
  4271                                  		;mov	di,5Dh
  4272 00000F35 BF5D00                  		mov	di,FCB+1
  4273 00000F38 B90B00                  		mov	cx,11
  4274 00000F3B F3AA                    		rep stosb
  4275                                  
  4276                                  ; Begin by processing any switches that may have been specified.
  4277                                  ; BITS will contain any information about switches that was
  4278                                  ; found when the command line was parsed.
  4279                                  
  4280 00000F3D A1[7842]                		mov	ax,[COMSW]	; Get switches from command
  4281 00000F40 A3[AC43]                		mov	word [_BITS],ax	; initialize switches
  4282 00000F43 C706[7842]0000          		mov	word [COMSW],0	; initialize flags
  4283 00000F49 C606[B443]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4284                                  		;test	al,1
  4285 00000F4E A801                    		test	al,SWITCHW	; /W ?
  4286                                  		;mov	al,1
  4287 00000F50 B001                    		mov	al,NORMPERLIN
  4288 00000F52 7402                    		jz	short DIR8
  4289                                  		;mov	al,5
  4290 00000F54 B005                    		mov	al,WIDEPERLIN
  4291                                  DIR8:
  4292 00000F56 A2[8842]                		mov	[LINLEN],al	; Set number of entries per line
  4293 00000F59 A2[8742]                		mov	[LINCNT],al
  4294 00000F5C C706[8942]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4295 00000F62 BA[5A43]                		mov	dx,DIRBUF
  4296 00000F65 B41A                    		mov	ah,SET_DMA ; 1Ah
  4297 00000F67 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4298                                  				; DS:DX	-> disk	transfer buffer
  4299                                  		;mov	dl,[5Ch]
  4300 00000F69 8A165C00                		mov	dl,[FCB]
  4301 00000F6D E8D609                  		call	SAVUDIR
  4302 00000F70 5B                      		pop	bx
  4303 00000F71 83FBFF                  		cmp	bx,0FFFFh
  4304 00000F74 7415                    		jz	short DIR9
  4305                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4306 00000F76 8B17                    		mov	dx,[bx]
  4307                                  
  4308                                  ; The user may have specified a device. Search for the path and see if the
  4309                                  ; attributes indicate a device.
  4310                                  
  4311 00000F78 B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4312 00000F7A CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4313                                  				; CX = search attributes
  4314                                  				; DS:DX	-> ASCIZ filespec
  4315                                  				; (drive,path, and wildcards allowed)
  4316 00000F7C 720F                    		jc	short DIR10
  4317                                  				; Check device atrribute..
  4318                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4319                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4320                                  		; 14/10/2018
  4321                                  		;test	byte [DIRBUF+21],40h
  4322 00000F7E F606[6F43]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4323 00000F83 7408                    		jz	short DIR10	; no, go do normal operation
  4324 00000F85 C706[7842]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4325                                  DIR9:
  4326 00000F8B EB7B                    		jmp	short DOHEADER
  4327                                  DIR10:
  4328                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4329 00000F8D 8B17                    		mov	dx,[bx]
  4330 00000F8F B43B                    		mov	ah,CHDIR ; 3Bh
  4331 00000F91 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4332                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4333 00000F93 7373                    		jnc	short DOHEADER
  4334                                  		;mov	si,[bx+3]
  4335 00000F95 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4336 00000F98 39F2                    		cmp	dx,si
  4337 00000F9A 7449                    		jz	short DIR_NO_DRIVE
  4338 00000F9C 30C9                    		xor	cl,cl
  4339 00000F9E 860C                    		xchg	cl,[si]
  4340 00000FA0 B43B                    		mov	ah,CHDIR ; 3Bh
  4341 00000FA2 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4342                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4343 00000FA4 860C                    		xchg	cl,[si]
  4344 00000FA6 733D                    		jnc	short DIR_NO_DRIVE
  4345 00000FA8 8A44FF                  		mov	al,[si-1]
  4346 00000FAB E85E0A                  		call	PATHCHRCMP
  4347 00000FAE 7514                    		jnz	short DIR11
  4348 00000FB0 8A44FE                  		mov	al,[si-2]
  4349 00000FB3 E8560A                  		call	PATHCHRCMP
  4350 00000FB6 741E                    		jz	short DIR12
  4351 00000FB8 864CFF                  		xchg	cl,[si-1]
  4352 00000FBB B43B                    		mov	ah,CHDIR ; 3Bh
  4353 00000FBD CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4354                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4355 00000FBF 864CFF                  		xchg	cl,[si-1]
  4356 00000FC2 7321                    		jnc	short DIR_NO_DRIVE
  4357                                  DIR11:
  4358 00000FC4 B53A                    		mov	ch,':'
  4359 00000FC6 3A6CFF                  		cmp	ch,[si-1]
  4360 00000FC9 750B                    		jnz	short DIR12
  4361                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4362 00000FCB 8B0F                    		mov	cx,[bx]
  4363 00000FCD 87CE                    		xchg	cx,si
  4364 00000FCF 29F1                    		sub	cx,si
  4365 00000FD1 83F902                  		cmp	cx,2
  4366 00000FD4 740F                    		jz	short DIR_NO_DRIVE
  4367                                  DIR12:
  4368 00000FD6 BA[663B]                		mov	dx,BADCDPTR
  4369                                  		;test	byte [bx+2],4
  4370 00000FD9 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4371 00000FDD 7503                    		jnz	short DIRERROR
  4372                                  DIRNF:
  4373 00000FDF BA[E837]                		mov	dx,FNOTFOUNDPTR
  4374                                  DIRERROR:
  4375 00000FE2 E93E0C                  		jmp	CERROR
  4376                                  DIR_NO_DRIVE:
  4377 00000FE5 813C2E2E                		cmp	word [si],'..'
  4378 00000FE9 750C                    		jnz	short DOREALPARSE
  4379 00000FEB 807C0200                		cmp	byte [si+2],0
  4380 00000FEF 7506                    		jnz	short DOREALPARSE
  4381 00000FF1 FF06[7842]              		inc	word [COMSW]
  4382 00000FF5 EB11                    		jmp	short DOHEADER
  4383                                  DOREALPARSE:
  4384 00000FF7 BF5C00                  		mov	di,FCB ; 5Ch	
  4385                                  		;mov	ax,290Eh
  4386 00000FFA B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4387 00000FFD CD21                    		int	21h	; DOS -	PARSE FILENAME
  4388                                  				; DS:SI	-> string to parse
  4389                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4390                                  				; AL = bit mask	to control parsing
  4391 00000FFF 803C00                  		cmp	byte [si],0
  4392 00001002 7404                    		jz	short DOHEADER
  4393 00001004 FF0E[7842]              		dec	word [COMSW]
  4394                                  DOHEADER:
  4395                                  
  4396                                  ; Display the header
  4397                                  
  4398 00001008 53                      		push	bx
  4399 00001009 E84804                  		call	BUILD_DIR_STRING
  4400 0000100C BA[5A43]                		mov	dx,DIRBUF
  4401 0000100F 8916[5544]              		mov	[VOL_DIR],dx
  4402 00001013 BA[EF3B]                		mov	dx,DIRHEADPTR
  4403 00001016 E89A24                  		call	PRINTF_CRLF
  4404 00001019 5B                      		pop	bx
  4405 0000101A 83FBFF                  		cmp	bx,0FFFFh
  4406 0000101D 7417                    		jz	short DOSEARCH
  4407                                  
  4408                                  ; If there were chars left after parse or device, then invalid file name
  4409                                  
  4410 0000101F 833E[7842]00            		cmp	word [COMSW],0
  4411 00001024 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4412 00001026 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4413 00001028 E87008                  		call	RESTUDIR
  4414 0000102B BA[663B]                		mov	dx,BADCDPTR
  4415 0000102E E9F20B                  		jmp	CERROR		; was .. => error directory not found
  4416                                  DIRNFFIX:
  4417 00001031 E86708                  		call	RESTUDIR
  4418 00001034 EBA9                    		jmp	short DIRNF
  4419                                  
  4420                                  ; We are assured that everything is correct. Let's go and search. Use
  4421                                  ; attributes that will include finding directories. Perform the first search
  4422                                  ; and reset our directory afterward.
  4423                                  
  4424                                  DOSEARCH:
  4425                                  		;mov	byte [55h],0FFh
  4426 00001036 C6065500FF              		mov	byte [FCB-7],0FFh
  4427                                  		;mov	byte [5Bh],10h
  4428 0000103B C6065B0010              		mov	byte [FCB-1],10h
  4429                                  
  4430                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4431                                  ; the directory information as an extended FCB. We must bias all fetches into
  4432                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4433                                  
  4434 00001040 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4435 00001042 BA5500                  		mov	dx,FCB-7 ; 55h
  4436 00001045 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4437                                  				; DS:DX	-> FCB
  4438                                  
  4439                                  ; Restore the user's directory. We preserve, though, the return from the
  4440                                  ; previous system call for later checking.
  4441                                  
  4442                                  FOUND_FIRST_FILE:
  4443 00001047 50                      		push	ax		; save return state
  4444 00001048 E85008                  		call	RESTUDIR	; restore user's dir	
  4445 0000104B 58                      		pop	ax		; get return state back
  4446                                  
  4447                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4448                                  ; no more.
  4449                                  
  4450                                  DIRSTART:
  4451 0000104C FEC0                    		inc	al		; 0FFh = file not found
  4452 0000104E 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4453 00001050 E9D200                  		jmp	CHKCNT
  4454                                  DISPLAY:
  4455 00001053 FF06[8942]              		inc	word [FILECNT]	; Keep track of how many we find
  4456 00001057 BE[6243]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4457                                  		;call	SHONAME
  4458 0000105A E80C01                  		call	DISPLAYNAME
  4459                                  		;test	byte [_BITS],1
  4460 0000105D F606[AC43]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4461 00001062 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4462 00001064 E98800                  		jmp	NEXENT
  4463                                  DIRTEST:
  4464                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4465                                  		; 14/10/2018
  4466                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4467                                  		;test	byte [DIRBUF+19],10h
  4468 00001067 F606[6D43]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4469 0000106C 7408                    		jz	short FILEENT
  4470 0000106E BA[E83A]                		mov	dx,DMESPTR
  4471 00001071 E84F24                  		call	STD_PRINTF
  4472 00001074 EB16                    		jmp	short NOFSIZ
  4473                                  FILEENT:
  4474                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4475                                  		;mov	dx,[DIRBUF+36]
  4476 00001076 8B16[7E43]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4477 0000107A 8916[3A44]              		mov	[FILESIZE_L],dx
  4478                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4479                                  		;mov	dx,[DIRBUF+38]
  4480 0000107E 8B16[8043]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4481 00001082 8916[3C44]              		mov	[FILESIZE_H],dx
  4482 00001086 BA[2637]                		mov	dx,FSIZEMESPTR
  4483 00001089 E83724                  		call	STD_PRINTF	; Print size of file
  4484                                  NOFSIZ:
  4485                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4486                                  		;mov	ax,[DIRBUF+32]
  4487 0000108C A1[7A43]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4488 0000108F 09C0                    		or	ax,ax
  4489 00001091 745C                    		jz	short NEXENT	; Skip if no date
  4490 00001093 BF[8B42]                		mov	di,CHARBUF
  4491 00001096 50                      		push	ax
  4492 00001097 B82020                  		mov	ax,'  '
  4493 0000109A AB                      		stosw
  4494 0000109B 58                      		pop	ax
  4495 0000109C 89C3                    		mov	bx,ax
  4496 0000109E 83E01F                  		and	ax,1Fh		; Get day
  4497 000010A1 88C2                    		mov	dl,al
  4498 000010A3 89D8                    		mov	ax,bx
  4499 000010A5 B105                    		mov	cl,5
  4500 000010A7 D3E8                    		shr	ax,cl		; Align month
  4501 000010A9 240F                    		and	al,0Fh		; Get month
  4502 000010AB 88C6                    		mov	dh,al
  4503 000010AD 88F9                    		mov	cl,bh
  4504 000010AF D0E9                    		shr	cl,1		; Align year
  4505 000010B1 30ED                    		xor	ch,ch
  4506 000010B3 83C150                  		add	cx,80		; Relative 1980
  4507 000010B6 80F964                  		cmp	cl,100
  4508 000010B9 7203                    		jb	short MILLENIUM
  4509 000010BB 80E964                  		sub	cl,100
  4510                                  MILLENIUM:
  4511 000010BE E8D50F                  		call	DATE_CXDX
  4512                                  		;mov	cx,[DIRBUF_FTIME]
  4513                                  		;mov	cx,[DIRBUF+30]
  4514 000010C1 8B0E[7843]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4515 000010C5 E318                    		jcxz	PRBUF		; Time field present?
  4516 000010C7 B82020                  		mov	ax,2020h
  4517 000010CA AB                      		stosw
  4518 000010CB D1E9                    		shr	cx,1
  4519 000010CD D1E9                    		shr	cx,1
  4520 000010CF D1E9                    		shr	cx,1
  4521 000010D1 D0E9                    		shr	cl,1
  4522 000010D3 D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4523 000010D5 8A1E[F94C]              		mov	bl,[TIME_24]
  4524 000010D9 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4525 000010DC E86A11                  		call	P_TIME		; Don't care about DX, never used with DIR
  4526                                  PRBUF:
  4527 000010DF 31C0                    		xor	ax,ax
  4528 000010E1 AA                      		stosb
  4529 000010E2 BA[8B42]                		mov	dx,CHARBUF
  4530 000010E5 8916[3E44]              		mov	[STRING_PTR_2],dx
  4531 000010E9 BA[2F37]                		mov	dx,STRINGBUF2PTR
  4532 000010EC E8D423                  		call	STD_PRINTF
  4533                                  NEXENT:
  4534 000010EF FE0E[8742]              		dec	byte [LINCNT]
  4535 000010F3 7520                    		jnz	short SAMLIN
  4536                                  NEXLIN:
  4537 000010F5 A0[8842]                		mov	al,[LINLEN]
  4538 000010F8 A2[8742]                		mov	[LINCNT],al
  4539 000010FB E86E08                  		call	CRLF2
  4540 000010FE FE0E[B443]              		dec	byte [LINPERPAG]
  4541 00001102 7517                    		jnz	short SCROLL
  4542                                  		;test	byte [_BITS],2
  4543 00001104 F606[AC43]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4544 00001109 7410                    		jz	short SCROLL	; If not, just continue
  4545 0000110B C606[B443]17            		mov	byte [LINPERPAG],23
  4546 00001110 E87900                  		call	PAUSE
  4547 00001113 EB06                    		jmp	short SCROLL
  4548                                  SAMLIN:
  4549 00001115 BA[3537]                		mov	dx,TABPTR	; Output a tab
  4550 00001118 E8A823                  		call	STD_PRINTF
  4551                                  SCROLL:
  4552 0000111B B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4553                                  		;mov	dx,55h
  4554 0000111D BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4555 00001120 CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4556                                  				; DS:DX	-> FCB
  4557                                  				; Return: AL = status
  4558 00001122 E927FF                  		jmp	DIRSTART
  4559                                  CHKCNT:
  4560 00001125 F706[8942]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4561 0000112B 7503                    		jnz	short TRAILER
  4562 0000112D E9AFFE                  		jmp	DIRNF
  4563                                  TRAILER:
  4564 00001130 A0[8842]                		mov	al,[LINLEN]
  4565 00001133 3A06[8742]              		cmp	al,[LINCNT]
  4566 00001137 7403                    		jz	short MMESSAGE
  4567 00001139 E83008                  		call	CRLF2
  4568                                  MMESSAGE:
  4569 0000113C BA[FF38]                		mov	dx,DIRMESPTR
  4570 0000113F 8B36[8942]              		mov	si,[FILECNT]
  4571 00001143 8936[4744]              		mov	[DIR_NUM],si
  4572 00001147 E87923                  		call	STD_PRINTF
  4573                                  DTFREE:
  4574 0000114A B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4575                                  		;mov	dl,[5Ch]
  4576 0000114C 8A165C00                		mov	dl,[FCB]
  4577 00001150 CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4578                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4579 00001152 83F8FF                  		cmp	ax,-1
  4580 00001155 7501                    		jnz	short DTFREE1
  4581                                  DTRET:
  4582 00001157 C3                      		retn
  4583                                  DTFREE1:
  4584 00001158 F7E1                    		mul	cx
  4585 0000115A F7E3                    		mul	bx
  4586 0000115C A3[4944]                		mov	[BYTES_FREE],ax
  4587 0000115F 8916[4B44]              		mov	[BYTES_FREE+2],dx
  4588 00001163 BA[1539]                		mov	dx,BYTEMESPTR
  4589 00001166 E95A23                  		jmp	STD_PRINTF
  4590                                  
  4591                                  
  4592                                  	; MSDOS 6.0
  4593                                  ;CATALOG:
  4594                                  
  4595                                  ;;
  4596                                  ;; Set up DTA for dir search firsts
  4597                                  ;;
  4598                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4599                                  ;	mov	ah,Set_DMA			;AC000;
  4600                                  ;	int	int_command			;AC000;
  4601                                  ;;
  4602                                  ;; Set up defaults for switches and parse the command line.
  4603                                  ;;
  4604                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4605                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4606                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4607                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4608                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4609                                  ;	stosb					;AN000;
  4610                                  ;	mov	al,end_of_line_in		;AN000;
  4611                                  ;	stosb					;AN000;
  4612                                  ;	mov	si,81H				;AN000; Get command line
  4613                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
  4614                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4615                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4616                                  ;	mov	bits,cx 			;AC000; initialize switches
  4617                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4618                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4619                                  ;	mov	lincnt,normperlin		;AC000;
  4620                                  ;
  4621                                  ;dirscan:
  4622                                  ;	xor	dx,dx				;AN000;
  4623                                  ;	invoke	parse_with_msg			;AC018; call parser
  4624                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4625                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4626                                  ;	jmp	scandone			;AN000; yes - go process
  4627                                  ;
  4628                                  ;dirscan_cont:
  4629                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4630                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4631                                  ;	jmp	badparm 			;AN000; yes - exit
  4632                                  ;
  4633                                  ;dirscan_cont2:
  4634                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4635                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4636                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4637                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4638                                  ;;
  4639                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4640                                  ;;
  4641                                  ;	push	si				;AC000; save position in line
  4642                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4643                                  ;	push	si				;AN000; save address
  4644                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4645                                  ;	pop	dx				;AC000; get address in DX
  4646                                  ;
  4647                                  ;;
  4648                                  ;; The user may have specified a device. Search for the path and see if the
  4649                                  ;; attributes indicate a device.
  4650                                  ;;
  4651                                  ;	mov	ah,Find_First			;AC000; find the file
  4652                                  ;	int	int_command			;AC000;
  4653                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4654                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4655                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4656                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4657                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4658                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4659                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4660                                  ;
  4661                                  ;dir_check_device:				;AN022;
  4662                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4663                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4664                                  ;	mov	ComSw,-2			;AC000; signal device
  4665                                  ;
  4666                                  ;dir_fspec_end:
  4667                                  ;	pop	si				;AC000; restore position in line
  4668                                  ;	jmp	short dirscan			;AC000; keep parsing
  4669                                  ;
  4670                                  ;set_dir_width:
  4671                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4672                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4673                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4674                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4675                                  ;	jmp	badparm 			;AN018; exit
  4676                                  ;
  4677                                  ;ok_set_width:
  4678                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4679                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4680                                  ;	mov	lincnt,wideperlin		;AC000;
  4681                                  ;	jmp	short dirscan			;AC000; keep parsing
  4682                                  ;
  4683                                  ;set_dir_pause:
  4684                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4685                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4686                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4687                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4688                                  ;	jmp	badparm 			;AN018; exit
  4689                                  ;
  4690                                  ;ok_set_pause:
  4691                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4692                                  ;	push	cx				;AN000; save necessary registers
  4693                                  ;	push	si				;AN000;
  4694                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4695                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4696                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4697                                  ;	mov	cl,get_generic			;AN000; get information
  4698                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4699                                  ;	int	int_command			;AN000;
  4700                                  ;
  4701                                  ;lines_set:
  4702                                  ;	dec	linperpag			;AN000; lines per actual page should
  4703                                  ;	dec	linperpag			;AN000;     two less than the max
  4704                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4705                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4706                                  ;	pop	si				;AN000; restore registers
  4707                                  ;	pop	cx				;AN000;
  4708                                  ;	jmp	dirscan 			;AC000; keep parsing
  4709                                  ;
  4710                                  ;;
  4711                                  ;; The syntax is incorrect. Report only message we can.
  4712                                  ;;
  4713                                  ;BadParm:
  4714                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4715                                  ;
  4716                                  ;ScanDone:
  4717                                  ;
  4718                                  ;;
  4719                                  ;; Find and display the volume ID on the drive.
  4720                                  ;;
  4721                                  ;
  4722                                  ;	invoke	okvolarg			;AC000;
  4723                                  ;;
  4724                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4725                                  ;; in the HeadFix routine, after we're done.
  4726                                  ;;
  4727                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4728                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4729                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4730                                  ;
  4731                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4732                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4733                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4734                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4735                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4736                                  ;	mov	si,[desttail]			;AN015; get filename back
  4737                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4738                                  ;
  4739                                  ;DirCheckPath:
  4740                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4741                                  ;	cmp	ax,0				;AN022; Is there a message?
  4742                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4743                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4744                                  ;	jz	doparse 			;AC000; no - no problem
  4745                                  ;	inc	comsw				;AC000; indicate error
  4746                                  ;	jmp	short doheader			;AC000; go print header
  4747                                  ;
  4748                                  ;DirNF:
  4749                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4750                                  ;
  4751                                  ;dir_err_setup:
  4752                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4753                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4754                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4755                                  ;
  4756                                  ;DirError:
  4757                                  ;	jmp	Cerror
  4758                                  ;
  4759                                  ;;
  4760                                  ;; We have changed to something. We also have a file. Parse it into a
  4761                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4762                                  ;; filename alone. We need to special case ... If we are at the root, the
  4763                                  ;; parse will fail and it will give us a file not found instead of file not
  4764                                  ;; found.
  4765                                  ;;
  4766                                  ;DoParse:
  4767                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4768                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4769                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4770                                  ;	lodsw					;AN000; bypass drive
  4771                                  ;
  4772                                  ;dir_no_drive:
  4773                                  ;	cmp	[si],".."
  4774                                  ;	jnz	DoRealParse
  4775                                  ;	cmp	byte ptr [si+2],0
  4776                                  ;	jnz	DoRealParse
  4777                                  ;	inc	ComSw
  4778                                  ;	jmp	short DoHeader
  4779                                  ;
  4780                                  ;DoRealParse:
  4781                                  ;	mov	di,FCB			; where to put the file name
  4782                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4783                                  ;	int	int_command
  4784                                  ;
  4785                                  ;;
  4786                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4787                                  ;; off.	This will be reset in the HEADFIX routine
  4788                                  ;;
  4789                                  ;
  4790                                  ;DoHeader:
  4791                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4792                                  ;
  4793                                  ;;
  4794                                  ;; Display the header
  4795                                  ;;
  4796                                  ;
  4797                                  ;DoHeaderCont:
  4798                                  ;	mov	al,blank			;AN051; Print out a blank
  4799                                  ;	invoke	print_char			;AN051;   before DIR header
  4800                                  ;	invoke	build_dir_string		; get current dir string
  4801                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4802                                  ;	invoke	printf_crlf			; bang!
  4803                                  ;
  4804                                  ;;
  4805                                  ;; If there were chars left after parse or device, then invalid file name
  4806                                  ;;
  4807                                  ;	cmp	ComSw,0
  4808                                  ;	jz	DoSearch			; nothing left; good parse
  4809                                  ;	jl	DirNFFix			; not .. => error file not found
  4810                                  ;	invoke	RestUDir
  4811                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4812                                  ;	jmp	Cerror				; was .. => error directory not found
  4813                                  ;DirNFFix:
  4814                                  ;	invoke	RestUDir
  4815                                  ;	jmp	DirNF
  4816                                  ;;
  4817                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4818                                  ;; attributes that will include finding directories.  perform the first search
  4819                                  ;; and reset our directory afterward.
  4820                                  ;;
  4821                                  ;DoSearch:
  4822                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4823                                  ;	mov	byte ptr DS:[FCB-1],010H
  4824                                  ;;
  4825                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4826                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4827                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4828                                  ;;
  4829                                  ;	mov	ah,Dir_Search_First
  4830                                  ;	mov	dx,FCB-7
  4831                                  ;	int	int_command
  4832                                  ;
  4833                                  ;	push	ax				;AN022; save return state
  4834                                  ;	inc	al				;AN022; did an error occur?
  4835                                  ;	pop	ax				;AN022; get return state back
  4836                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4837                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4838                                  ;	push	dx				;AN022; save message
  4839                                  ;	invoke	restudir			;AN022; restore user's dir
  4840                                  ;	pop	dx				;AN022; restore message
  4841                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4842                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4843                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4844                                  ;
  4845                                  ;DirCerrorJ:					;AN022;
  4846                                  ;	jmp	Cerror				;AN022; exit
  4847                                  ;
  4848                                  ;;
  4849                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4850                                  ;; previous system call for later checking.
  4851                                  ;;
  4852                                  ;
  4853                                  ;found_first_file:
  4854                                  ;	push	ax
  4855                                  ;	invoke	restudir
  4856                                  ;	pop	ax
  4857                                  ;;
  4858                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4859                                  ;; no more.
  4860                                  ;;
  4861                                  ;DIRSTART:
  4862                                  ;	inc	al				; FF = file not found
  4863                                  ;	jnz	Display
  4864                                  ;	jmp	DirDone 			; Either an error or we are finished
  4865                                  ;;
  4866                                  ;; Note that we've seen a file and display the found file.
  4867                                  ;;
  4868                                  ;
  4869                                  ;Display:
  4870                                  ;	inc	[filecnt]			; Keep track of how many we find
  4871                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4872                                  ;	call	shoname
  4873                                  ;;
  4874                                  ;; If we are displaying in wide mode, do not output the file info
  4875                                  ;;
  4876                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4877                                  ;	jz	DirTest
  4878                                  ;	jmp	nexent				; If so, no size, date, or time
  4879                                  ;
  4880                                  ;;
  4881                                  ;; Test for directory.
  4882                                  ;;
  4883                                  ;DirTest:
  4884                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4885                                  ;	jz	fileent
  4886                                  ;;
  4887                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4888                                  ;;
  4889                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4890                                  ;	call	std_printf
  4891                                  ;	jmp	short nofsiz
  4892                                  ;;
  4893                                  ;; We have a file.  Display the file size
  4894                                  ;;
  4895                                  ;fileent:
  4896                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4897                                  ;	mov	file_size_low,dx
  4898                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4899                                  ;	mov	file_size_high,dx
  4900                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4901                                  ;	call	std_printf
  4902                                  ;;
  4903                                  ;; Display time and date of last modification
  4904                                  ;;
  4905                                  ;nofsiz:
  4906                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4907                                  ;;
  4908                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4909                                  ;; date/time fields as 1.x did not have them.
  4910                                  ;;
  4911                                  ;	or	ax,ax
  4912                                  ;	jz	nexent				; Skip if no date
  4913                                  ;	mov	bx,ax
  4914                                  ;	and	ax,1FH				; get day
  4915                                  ;	mov	dl,al
  4916                                  ;	mov	ax,bx
  4917                                  ;	mov	cl,5
  4918                                  ;	shr	ax,cl				; Align month
  4919                                  ;	and	al,0FH				; Get month
  4920                                  ;	mov	dh,al
  4921                                  ;	mov	cl,bh
  4922                                  ;	shr	cl,1				; Align year
  4923                                  ;	xor	ch,ch
  4924                                  ;	add	cx,80				; Relative 1980
  4925                                  ;	cmp	cl,100
  4926                                  ;	jb	millenium
  4927                                  ;	sub	cl,100
  4928                                  ;
  4929                                  ;millenium:
  4930                                  ;	xchg	dh,dl				;AN000; switch month & day
  4931                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  4932                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  4933                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  4934                                  ;	jcxz	prbuf				; Time field present?
  4935                                  ;	shr	cx,1
  4936                                  ;	shr	cx,1
  4937                                  ;	shr	cx,1
  4938                                  ;	shr	cl,1
  4939                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  4940                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  4941                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  4942                                  ;
  4943                                  ;prbuf:
  4944                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  4945                                  ;	call	std_printf
  4946                                  ;	invoke	crlf2				;AC066;end the line
  4947                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  4948                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  4949                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  4950                                  ;	endif04:				;AN066;
  4951                                  ;	jmp	scroll				; If not, just continue
  4952                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  4953                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  4954                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  4955                                  ;;
  4956                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  4957                                  ;; is only for /W case.
  4958                                  ;;
  4959                                  ;nexent:
  4960                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  4961                                  ;	dec	[lincnt]			      ;count this entry on the line
  4962                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  4963                                  ;	   mov	   al,[linlen]
  4964                                  ;	   mov	   [lincnt],al
  4965                                  ;	   invoke  crlf2
  4966                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  4967                                  ;	   jnz	   endif02			;AN066;
  4968                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  4969                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  4970                                  ;	   jmp	   short endif01		;AN066;
  4971                                  ;	else01: 				;AN066;ELSE since screen not full
  4972                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  4973                                  ;	   jne	   endif03			;	     count the line
  4974                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  4975                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  4976                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  4977                                  ;	   call    std_printf
  4978                                  ;	endif01:				;AX066;
  4979                                  ;;
  4980                                  ;; All we need to do now is to get the next directory entry.
  4981                                  ;;
  4982                                  ;scroll:
  4983                                  ;	mov	ah,Dir_Search_Next
  4984                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  4985                                  ;	int	int_command			; Search for a file to match FCB
  4986                                  ;	jmp	DirStart
  4987                                  ;;
  4988                                  ;; If no files have been found, display a not-found message
  4989                                  ;;
  4990                                  ;DirDone:
  4991                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  4992                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  4993                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  4994                                  ;	test	[filecnt],-1
  4995                                  ;	jnz	Trailer
  4996                                  ;	mov	ax,error_file_not_found 	;AN022;
  4997                                  ;
  4998                                  ;dir_err_setup_jmp:				;AN022;
  4999                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  5000                                  ;;
  5001                                  ;; If we have printed the maximum number of files per line, terminate it with
  5002                                  ;; CRLF.
  5003                                  ;;
  5004                                  ;Trailer:
  5005                                  ;	mov	al,[linlen]
  5006                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5007                                  ;	jz	mmessage
  5008                                  ;	invoke	crlf2
  5009                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5010                                  ;	jnz	endif06 			;AN066;   pause before going on
  5011                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5012                                  ;	endif06:				;AN066;   displays
  5013                                  ;
  5014                                  ;mmessage:
  5015                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5016                                  ;	mov	si,[filecnt]
  5017                                  ;	mov	dir_num,si
  5018                                  ;	call	std_printf
  5019                                  ;	mov	ah,Get_Drive_Freespace
  5020                                  ;	mov	dl,byte ptr DS:[FCB]
  5021                                  ;	int	int_command
  5022                                  ;	cmp	ax,-1
  5023                                  ;	retz
  5024                                  ;	mul	cx				; AX is bytes per cluster
  5025                                  ;	mul	bx
  5026                                  ;	mov	bytes_free,ax			;AC000;
  5027                                  ;	mov	bytes_free+2,dx 		;AC000;
  5028                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5029                                  ;	jmp	std_printf
  5030                                  ;
  5031                                  ;shoname:
  5032                                  ;	mov	di,offset trangroup:charbuf
  5033                                  ;	mov	cx,8
  5034                                  ;	rep	movsb
  5035                                  ;	mov	al,' '
  5036                                  ;	stosb
  5037                                  ;	mov	cx,3
  5038                                  ;	rep	movsb
  5039                                  ;	xor	ax,ax
  5040                                  ;	stosb
  5041                                  ;	push	dx
  5042                                  ;	mov	dx,offset trangroup:charbuf
  5043                                  ;	mov	string_ptr_2,dx
  5044                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5045                                  ;	call	std_printf
  5046                                  ;	pop	DX
  5047                                  ;	return
  5048                                  ;
  5049                                  ;check_for_P    PROC  NEAR		;AN066;
  5050                                  ;
  5051                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5052                                  ;	jz	endif05 		;AN066;
  5053                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5054                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5055                                  ;   	invoke  Pause
  5056                                  ;endif05:
  5057                                  ;	ret				;AN066;
  5058                                  ;
  5059                                  ;check_for_P    ENDP			;AN066;
  5060                                  
  5061                                  ; =============== S U B	R O U T	I N E =======================================
  5062                                  
  5063                                  SHONAME:
  5064                                  DISPLAYNAME:
  5065                                  		; MSDOS 3.3
  5066 00001169 BF[8B42]                		mov	di,CHARBUF
  5067 0000116C B90800                  		mov	cx,8
  5068 0000116F F3A4                    		rep movsb
  5069 00001171 B020                    		mov	al,' '
  5070 00001173 AA                      		stosb
  5071 00001174 B90300                  		mov	cx,3
  5072 00001177 F3A4                    		rep movsb
  5073 00001179 31C0                    		xor	ax,ax
  5074 0000117B AA                      		stosb
  5075 0000117C 52                      		push	dx
  5076 0000117D BA[8B42]                		mov	dx,CHARBUF
  5077 00001180 8916[3E44]              		mov	[STRING_PTR_2],dx
  5078 00001184 BA[2F37]                		mov	dx,STRINGBUF2PTR
  5079 00001187 E83923                  		call	STD_PRINTF
  5080 0000118A 5A                      		pop	dx
  5081 0000118B C3                      		retn
  5082                                  
  5083                                  ;============================================================================
  5084                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5085                                  ;============================================================================
  5086                                  ; 09/10/2018 - Retro DOS v3.0
  5087                                  
  5088                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5089                                  
  5090                                  
  5091                                  ; =============== S U B	R O U T	I N E =======================================
  5092                                  
  5093                                  PAUSE:
  5094 0000118C BA[FC39]                		mov	dx,PAUSEMESPTR
  5095 0000118F E83123                  		call	STD_PRINTF
  5096 00001192 E858F3                  		call	GETKEYSTROKE
  5097 00001195 E8D407                  		call	CRLF2
  5098 00001198 C3                      		retn
  5099                                  
  5100                                  ; ---------------------------------------------------------------------------
  5101                                  
  5102                                  ;****************************************************************
  5103                                  ;*
  5104                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5105                                  ;*
  5106                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5107                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5108                                  ;*		up an error message and transfer control to CERROR.
  5109                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5110                                  ;*		entered or SLASHP_ERASE if /P entered.
  5111                                  ;*
  5112                                  ;* INPUT:	command line at offset 81H
  5113                                  ;*
  5114                                  ;* OUTPUT:	if no error:
  5115                                  ;*		FCB at 5ch set up with filename(s) entered
  5116                                  ;*		Current directory set to entered directory
  5117                                  ;*
  5118                                  ;****************************************************************
  5119                                  
  5120                                  ERASE:
  5121                                  		; MSDOS 6.0
  5122                                  
  5123                                  ;assume	ds:trangroup,es:trangroup
  5124                                  
  5125                                  ;		mov	si,81H		;AC000; get command line
  5126                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5127                                  ;		mov	di,offset trangroup:parse_erase
  5128                                  ;					;AN000; Get adderss of PARSE_erase
  5129                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5130                                  ;
  5131                                  ;erase_scan:
  5132                                  ;		xor	dx,dx		;AN000;
  5133                                  ;		invoke	parse_with_msg	;AC018; call parser
  5134                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5135                                  ;		jz	good_line	;AN000; yes - done parsing
  5136                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5137                                  ;		jnz	errj2		;AC000; yes exit
  5138                                  ;
  5139                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5140                                  ;					;AN000; was /P entered?
  5141                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5142                                  ;
  5143                                  ;;
  5144                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5145                                  ;;
  5146                                  ;		push	si		;AC000; save position in line
  5147                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5148                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5149                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5150                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5151                                  ;					;AC000; was only drive entered?
  5152                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5153                                  ;		mov	ax,error_file_not_found 
  5154                                  ;					;AN022; get message number in control block
  5155                                  ;		jmp	short extend_setup ;AC000; exit
  5156                                  ;
  5157                                  ;erase_drive_ok:
  5158                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5159                                  ;		pop	si		;AC000; get position back
  5160                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5161                                  ;
  5162                                  ;set_erase_prompt:
  5163                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5164                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5165                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5166                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5167                                  ;		jmp	short errj2	;AN018; exit
  5168                                  ;
  5169                                  ;ok_to_set_erase_prompt: 		;AN018;
  5170                                  ;		inc	comsw		;AN000; indicate /p specified
  5171                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5172                                  ;
  5173                                  ;good_line:				;G  We know line is good
  5174                                  ;		invoke	pathcrunch
  5175                                  ;		jnc	checkdr
  5176                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5177                                  ;		cmp	ax,0		;AN022; was message flag set?
  5178                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5179                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5180                                  ;		jnz	badpath_err	;AC022; see if they should have
  5181                                  ;
  5182                                  ;checkdr:
  5183                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5184                                  ;		jz	notest2j	;AN000; no - go to notest2
  5185                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5186                                  ;
  5187                                  ;notest2j:
  5188                                  ;		jmp	notest2
  5189                                  ;
  5190                                  ;badpath_err:				;AN022; "Path not found" message
  5191                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5192                                  ;
  5193                                  ;extend_setup:				;AN022;
  5194                                  ;		mov	msg_disp_class,ext_msg_class
  5195                                  ;					;AN022; set up extended error msg class
  5196                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5197                                  ;					;AC022; get extended message pointer
  5198                                  ;		mov	Extend_Buf_ptr,ax
  5199                                  ;					;AN022; get message number in control block
  5200                                  ;errj2:					;AC022; exit jump
  5201                                  ;		jmp	Cerror		;AN022;
  5202                                  
  5203                                  		; MSDOS 3.3
  5204 00001199 BA[5D3D]                		mov	dx,BADARGSPTR
  5205 0000119C BE8000                  		mov	si,80h
  5206 0000119F AC                      		lodsb
  5207 000011A0 08C0                    		or	al,al
  5208 000011A2 743E                    		jz	short ERRJ2
  5209 000011A4 E8D207                  		call	SCANOFF
  5210 000011A7 3C0D                    		cmp	al,0Dh		; Return key
  5211 000011A9 7437                    		jz	short ERRJ2	; If so no parameters specified
  5212 000011AB 52                      		push	dx
  5213 000011AC 56                      		push	si
  5214 000011AD BA[E837]                		mov	dx,FNOTFOUNDPTR
  5215                                  ERASE_SCAN:
  5216 000011B0 AC                      		lodsb
  5217 000011B1 E8CD07                  		call	DELIM
  5218 000011B4 7406                    		jz	short ERASE_CHKDELIMCHR
  5219 000011B6 3C0D                    		cmp	al,0Dh
  5220 000011B8 7415                    		jz	short GOOD_LINE
  5221 000011BA EBF4                    		jmp	short ERASE_SCAN
  5222                                  ERASE_CHKDELIMCHR:
  5223 000011BC 3C20                    		cmp	al,20h
  5224 000011BE 7F22                    		jg	short ERRJ2
  5225 000011C0 AC                      		lodsb
  5226 000011C1 E8BD07                  		call	DELIM
  5227 000011C4 74F6                    		jz	short ERASE_CHKDELIMCHR
  5228 000011C6 3C0D                    		cmp	al,0Dh
  5229 000011C8 7405                    		jz	short GOOD_LINE
  5230 000011CA BA[5D3D]                		mov	dx,BADARGSPTR
  5231 000011CD EB13                    		jmp	short ERRJ2
  5232                                  GOOD_LINE:
  5233 000011CF 5E                      		pop	si
  5234 000011D0 5A                      		pop	dx
  5235 000011D1 56                      		push	si
  5236 000011D2 E84808                  		call	PATHCRUNCH
  5237 000011D5 730E                    		jnc	short CHECKDR
  5238 000011D7 803E[5C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5239 000011DC 7407                    		jz	short CHECKDR	   ; see if they should have
  5240                                  BADCDERR:
  5241 000011DE 5E                      		pop	si
  5242 000011DF BA[663B]                		mov	dx,BADCDPTR
  5243                                  ERRJ2:
  5244 000011E2 E93E0A                  		jmp	CERROR
  5245                                  CHECKDR:
  5246 000011E5 BA[E837]                		mov	dx,FNOTFOUNDPTR
  5247 000011E8 59                      		pop	cx
  5248 000011E9 B020                    		mov	al,' '
  5249                                  		;cmp	[5Dh],al
  5250 000011EB 38065D00                		cmp	[FCB+1],al
  5251 000011EF 74F1                    		jz	short ERRJ2
  5252 000011F1 83C103                  		add	cx,3
  5253 000011F4 39CE                    		cmp	si,cx
  5254 000011F6 7507                    		jnz	short NOTEST2J
  5255 000011F8 B03A                    		mov	al,':'
  5256 000011FA 3844FE                  		cmp	[si-2],al
  5257 000011FD 74E3                    		jz	short ERRJ2
  5258                                  NOTEST2J:
  5259 000011FF E91116                  		jmp	NOTEST2
  5260                                  
  5261                                  ; ---------------------------------------------------------------------------
  5262                                  
  5263                                  ; ****************************************************************
  5264                                  ; *
  5265                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5266                                  ; *
  5267                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5268                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5269                                  ; *		 Make sure the second filespec only contains a
  5270                                  ; *		 filename.  If both openands are valid, attempt
  5271                                  ; *		 to rename the file.
  5272                                  ; *
  5273                                  ; * INPUT:	 command line at offset 81H
  5274                                  ; *
  5275                                  ; * OUTPUT:	 none
  5276                                  ; *
  5277                                  ; ****************************************************************
  5278                                  
  5279                                  CRENAME:
  5280                                  		; MSDOS 6.0
  5281                                  		;assume	ds:trangroup,es:trangroup
  5282                                  ;
  5283                                  ;		mov	si,81H		;AC000; Point to command line
  5284                                  ;		mov	di,offset trangroup:parse_rename
  5285                                  ;					;AN000; Get adderss of PARSE_RENAME
  5286                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5287                                  ;		xor	dx,dx		;AN000;
  5288                                  ;		invoke	parse_with_msg	;AC018; call parser
  5289                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5290                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5291                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5292                                  ;;
  5293                                  ;;  Get first file name returned from parse into our buffer
  5294                                  ;;
  5295                                  ;crename_no_parse_error:
  5296                                  ;		push	si		;AN000; save position in line
  5297                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5298                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5299                                  ;		pop	si		;AN000; restore position in line
  5300                                  ;
  5301                                  ;		xor	dx,dx		;AN000; clear dx
  5302                                  ;		invoke	parse_with_msg	;AC018; call parser
  5303                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5304                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5305                                  ;;
  5306                                  ;;  Check the second file name for drive letter colon
  5307                                  ;;
  5308                                  ;		push	si		;AN000; save position in line
  5309                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5310                                  ;
  5311                                  ;		mov	al,':'		;AC000;
  5312                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5313                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5314                                  ;		mov	msg_disp_class,parse_msg_class
  5315                                  ;					;AN000; set up parse error msg class
  5316                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5317                                  ;					;AC000; get extended message pointer
  5318                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5319                                  ;					;AN000; get "Invalid parameter" message number
  5320                                  ;		pop	si		;AN000;
  5321                                  ;crename_parse_error:			;AC022;
  5322                                  ;		jmp	short errj	;AC000;
  5323                                  ;
  5324                                  ;;  Get second file name returned from parse into the fCB. Save
  5325                                  ;;  character after file name so we can later check to make sure it
  5326                                  ;;  isn't a path character.
  5327                                  ;
  5328                                  ;
  5329                                  ;ren_no_drive:
  5330                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5331                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5332                                  ;		int	21h		;AC000; do the function
  5333                                  ;		lodsb			;AC000; Load char after filename
  5334                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5335                                  ;		pop	si		;AN000; get line position back
  5336                                  ;
  5337                                  ;;
  5338                                  ;; We have source and target.  See if any args beyond.
  5339                                  ;;
  5340                                  ;
  5341                                  ;		mov	di,offset trangroup:parse_rename
  5342                                  ;					;AC000; get address of parse_rename
  5343                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5344                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5345                                  ;
  5346                                  ;		invoke	pathcrunch
  5347                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5348                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5349                                  ;		jnc	notest3
  5350                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5351                                  ;		cmp	ax,0		;AN022; was message flag set?
  5352                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5353                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5354                                  ;		jz	notest3 	; see if they should have
  5355                                  ;		Jmp	badpath_err	;AC022; set up error
  5356                                  ;
  5357                                  ;notest3:
  5358                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5359                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5360                                  ;					; Load invalid fname error ptr
  5361                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5362                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5363                                  ;					;  filename only.
  5364                                  ;		mov	ah,FCB_Rename
  5365                                  ;		mov	dx,FCB
  5366                                  ;		int	21h
  5367                                  ;		cmp	al, 0FFH	; Did an error occur??
  5368                                  ;		jnz	renameok
  5369                                  ;
  5370                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5371                                  ;		SaveReg <AX>		;AC022; Save results
  5372                                  ;		mov	al, 0FFH	; Restore original error state
  5373                                  ;
  5374                                  ;renameok:
  5375                                  ;		push	ax
  5376                                  ;		invoke	restudir
  5377                                  ;		pop	ax
  5378                                  ;		inc	al
  5379                                  ;		retnz
  5380                                  ;
  5381                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5382                                  ;		cmp	ax,error_file_not_found 
  5383                                  ;					;AN022; error file not found?
  5384                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5385                                  ;		cmp	ax,error_access_denied
  5386                                  ;					;AN022; error file not found?
  5387                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5388                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5389                                  ;
  5390                                  ;use_renerr:
  5391                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5392                                  ;ERRJ:
  5393                                  ;		jmp	Cerror
  5394                                  ;
  5395                                  ;ret56:		ret
  5396                                  
  5397                                  		; MSDOS 3.3
  5398 00001202 BA[5D3D]                		mov	dx,BADARGSPTR
  5399 00001205 E87107                  		call	SCANOFF
  5400 00001208 3C0D                    		cmp	al,0Dh
  5401 0000120A 74D6                    		jz	short ERRJ2
  5402 0000120C E80E08                  		call	PATHCRUNCH
  5403 0000120F BA[3C3D]                		mov	dx,BADCPMESPTR
  5404 00001212 74CE                    		jz	short ERRJ2
  5405 00001214 7309                    		jnb	short CRENAME_NO_PARSE_ERROR
  5406 00001216 803E[5C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5407 0000121B 7402                    		jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5408 0000121D EBBF                    		jmp	short BADCDERR
  5409                                  
  5410                                  ;  Get first file name returned from parse into our buffer
  5411                                  
  5412                                  CRENAME_NO_PARSE_ERROR:
  5413 0000121F 8B36[B043]              		mov	si,[PATHPOS]
  5414 00001223 E85307                  		call	SCANOFF
  5415 00001226 3C0D                    		cmp	al,0Dh
  5416 00001228 BA[5D3D]                		mov	dx,BADARGSPTR
  5417 0000122B 7443                    		jz	short ERRJ
  5418 0000122D B03A                    		mov	al,':'
  5419 0000122F BA[123A]                		mov	dx,BADPARMPTR
  5420 00001232 384401                  		cmp	[si+1],al
  5421 00001235 7439                    		jz	short ERRJ
  5422                                  
  5423                                  ;  Get second file name returned from parse into the FCB. Save
  5424                                  ;  character after file name so we can later check to make sure it
  5425                                  ;  isn't a path character.
  5426                                  
  5427                                  REN_NO_DRIVE:
  5428                                  		;mov	di,6Ch
  5429 00001237 BF6C00                  		mov	di,FCB+10h
  5430 0000123A B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5431 0000123D CD21                    		int	21h	; DOS -	PARSE FILENAME
  5432                                  				; DS:SI	-> string to parse
  5433                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5434                                  				; AL = bit mask	to control parsing
  5435 0000123F B020                    		mov	al,' '
  5436                                  		;cmp	[6Dh],al
  5437 00001241 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5438 00001245 7429                    		jz	short ERRJ	; Error if missing parameter
  5439 00001247 AC                      		lodsb
  5440 00001248 BA[D738]                		mov	dx,INORNOTPTR
  5441 0000124B E8BE07                  		call	PATHCHRCMP
  5442 0000124E 7420                    		jz	short ERRJ
  5443 00001250 B417                    		mov	ah,FCB_RENAME ; 17h
  5444 00001252 BA5C00                  		mov	dx,FCB ; 5Ch
  5445 00001255 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5446                                  				; DS:DX	-> FCB
  5447                                  				; FCB contains new name	starting at byte 17h.
  5448 00001257 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5449 00001259 750A                    		jnz	short RENAMEOK
  5450 0000125B F9                      		stc
  5451 0000125C BA[D537]                		mov	dx,RENERRPTR
  5452 0000125F E8620C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5453 00001262 52                      		push	dx
  5454 00001263 B0FF                    		mov	al,0FFh		; Restore original error state
  5455                                  RENAMEOK:
  5456 00001265 50                      		push	ax
  5457 00001266 E83206                  		call	RESTUDIR
  5458 00001269 58                      		pop	ax
  5459 0000126A FEC0                    		inc	al
  5460 0000126C 7401                    		jz	short RENAME_ERR
  5461                                  RENAME_RETN:
  5462                                  TYPELP_RET:
  5463 0000126E C3                      		retn
  5464                                  RENAME_ERR:
  5465 0000126F 5A                      		pop	dx
  5466                                  ERRJ:					; Retro DOS v3.0
  5467 00001270 E84722                  		call	STD_EPRINTF
  5468 00001273 E98EEE                  		jmp	TCOMMAND
  5469                                  
  5470                                  ; ---------------------------------------------------------------------------
  5471                                  
  5472                                  ;ERRJ:
  5473                                  ;		jmp	CERROR
  5474                                  
  5475                                  ; ---------------------------------------------------------------------------
  5476                                  
  5477                                  ;TYPELP_RET:
  5478                                  ;		retn
  5479                                  
  5480                                  ; ---------------------------------------------------------------------------
  5481                                  
  5482                                  ;****************************************************************
  5483                                  ;*
  5484                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5485                                  ;*		standard output device
  5486                                  ;*
  5487                                  ;* SYNTAX:	TYPE filespec
  5488                                  ;*
  5489                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5490                                  ;*		1Ah and display the contents to STDOUT.
  5491                                  ;*
  5492                                  ;* INPUT:	command line at offset 81H
  5493                                  ;*
  5494                                  ;* OUTPUT:	none
  5495                                  ;*
  5496                                  ;****************************************************************
  5497                                  
  5498                                  TYPEFIL:
  5499                                  		; MSDOS 6.0	
  5500                                  		;assume	ds:trangroup,es:trangroup
  5501                                  
  5502                                  ;		mov	si,81H
  5503                                  ;		mov	di,offset trangroup:parse_mrdir 
  5504                                  ;					;AN000; Get adderss of PARSE_MRDIR
  5505                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5506                                  ;		xor	dx,dx		;AN000;
  5507                                  ;		invoke	parse_with_msg	;AC018; call parser
  5508                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5509                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5510                                  ;
  5511                                  ;		push	si		;AC000; save position in line
  5512                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5513                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5514                                  ;		pop	si		;AC000; get position back
  5515                                  ;		mov	di,offset trangroup:parse_mrdir 
  5516                                  ;					;AC000; get address of parse_mrdir
  5517                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5518                                  ;		jz	gottarg 	;AC000; yes - continue
  5519                                  ;
  5520                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5521                                  ;		jmp	Cerror
  5522                                  ;
  5523                                  ;gottarg:
  5524                                  ;		invoke	setpath
  5525                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5526                                  ;		jz	nowilds 	; No, continue processing
  5527                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5528                                  ;		jmp	Cerror
  5529                                  ;nowilds:
  5530                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5531                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5532                                  ;		xor	cx,cx		;AN000; no special files
  5533                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5534                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5535                                  ;		int	21h
  5536                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5537                                  ;
  5538                                  ;Typerr: 				;AN022;
  5539                                  ;		push	cs		;AN022; make sure we have local segment
  5540                                  ;		pop	ds		;AN022;
  5541                                  ;		invoke	set_ext_error_msg ;AN022;
  5542                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5543                                  ;					;AC022; get address of failed string
  5544                                  ;		mov	Extend_buf_sub,one_subst
  5545                                  ;					;AC022; put number of subst in control block
  5546                                  ;		jmp	cerror		;AC022; exit
  5547                                  ;
  5548                                  ;typecont:
  5549                                  ;		mov	bx,ax		;AC000; get  Handle
  5550                                  ;;M043
  5551                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5552                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5553                                  ;;indicate it is a device.
  5554                                  ;;
  5555                                  ;		mov	ax,(IOCTL shl 8) or 0
  5556                                  ;		int	21h
  5557                                  ;
  5558                                  ;		test	dl,80h		;is it a device?
  5559                                  ;		jz	not_device	;no, a file
  5560                                  ;
  5561                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5562                                  ;		jmp	short dotype
  5563                                  ;not_device:
  5564                                  ;
  5565                                  ;;SR;
  5566                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5567                                  ;;start of file
  5568                                  ;;
  5569                                  ;		mov	ax,(LSEEK shl 8) or 2
  5570                                  ;		xor	dx,dx
  5571                                  ;		mov	cx,dx		;seek  to end of file
  5572                                  ;		int	21h
  5573                                  ;
  5574                                  ;		mov	word ptr TypeFilSiz,ax
  5575                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5576                                  ;
  5577                                  ;		mov	ax,(LSEEK shl 8) or 0
  5578                                  ;		xor	dx,dx
  5579                                  ;		int	21h	        ;reset file pointer to start
  5580                                  ;dotype:					;M043
  5581                                  ;		mov	zflag,0 	; Reset ^Z flag
  5582                                  ;		mov	ds,[TPA]
  5583                                  ;		xor	dx,dx
  5584                                  ;		;ASSUME	DS:NOTHING
  5585                                  ;
  5586                                  ;typelp:
  5587                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5588                                  ;		retnz			; Yes, return
  5589                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5590                                  ;;
  5591                                  ;;Update the filesize left to read
  5592                                  ;;
  5593                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5594                                  ;		je	typ_read	;yes, just read from it; M043
  5595                                  ;
  5596                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5597                                  ;		jz	lt64k		;no, do word subtraction
  5598                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5599                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5600                                  ;      		jmp	short typ_read	;do the read
  5601                                  ;lt64k:
  5602                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5603                                  ;		jbe	gtbuf		; yes, just update readsize
  5604                                  ;;
  5605                                  ;;Buffer size is larger than bytes to read
  5606                                  ;;
  5607                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5608                                  ;		jcxz	typelp_ret
  5609                                  ;		mov	word ptr cs:TypeFilSiz,0
  5610                                  ;		jmp	short typ_read
  5611                                  ;gtbuf:
  5612                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5613                                  ;typ_read:
  5614                                  ;		mov	ah,read
  5615                                  ;		int	21h		
  5616                                  ;		jnc	@f		;M043
  5617                                  ;		jmp	typerr		;M043
  5618                                  ;@@:					;M043
  5619                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5620                                  ;
  5621                                  ;		mov	cx,ax
  5622                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5623                                  ;		push	ds
  5624                                  ;		pop	es		; Check to see if a ^Z was read.
  5625                                  ;		;assume es:nothing
  5626                                  ;		xor	di,di
  5627                                  ;		push	ax
  5628                                  ;		mov	al,1ah
  5629                                  ;		repnz	scasb
  5630                                  ;		pop	ax
  5631                                  ;		xchg	ax,cx
  5632                                  ;		cmp	ax,0
  5633                                  ;		jnz	foundz		; Yes, handle it
  5634                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5635                                  ;		jnz	typecont2	; No ^Z, continue
  5636                                  ;
  5637                                  ;foundz:
  5638                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5639                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5640                                  ;		push	cs		;  will be typed.
  5641                                  ;		pop	es
  5642                                  ;		;assume es:trangroup
  5643                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5644                                  ;typecont2:				;  will quit after this write.
  5645                                  ;		push	bx
  5646                                  ;		mov	bx,1
  5647                                  ;		mov	ah,write
  5648                                  ;		int	21h
  5649                                  ;		pop	bx
  5650                                  ;		jc	Error_outputj
  5651                                  ;		cmp	ax,cx
  5652                                  ;		jnz	@f		;M043
  5653                                  ;		jmp	typelp		;M043
  5654                                  ;@@:					;M043
  5655                                  ;;M043;		jz	typelp
  5656                                  ;		dec	cx
  5657                                  ;		cmp	ax,cx
  5658                                  ;		retz			; One less byte OK (^Z)
  5659                                  ;Error_outputj:
  5660                                  ;		mov	bx,1
  5661                                  ;		mov	ax,IOCTL SHL 8
  5662                                  ;		int	21h
  5663                                  ;		test	dl,devid_ISDEV
  5664                                  ;		retnz			; If device, no error message
  5665                                  ;		jmp	error_output
  5666                                  ;typelp_ret:
  5667                                  ;		ret
  5668                                  
  5669                                  		; MSDOS 3.3
  5670 00001276 BE8100                  		mov	si,81h
  5671 00001279 E8FD06                  		call	SCANOFF		; Skip to first non-delim
  5672 0000127C 3C0D                    		cmp	al,0Dh
  5673 0000127E 7505                    		jnz	short GOTTARG
  5674 00001280 BA[5D3D]                		mov	dx,BADARGSPTR
  5675                                  
  5676                                  		;jmp	CERROR
  5677 00001283 EBEB                    		jmp	short ERRJ	; No args
  5678                                  GOTTARG:
  5679 00001285 E8E90A                  		call	SETPATH
  5680 00001288 F606[6044]02            		test	byte [DESTINFO],2
  5681 0000128D 7405                    		jz	short NOWILDS
  5682 0000128F BA[D738]                		mov	dx,INORNOTPTR
  5683                                  
  5684                                  		;jmp	CERROR
  5685 00001292 EBDC                    		jmp	short ERRJ
  5686                                  NOWILDS:
  5687 00001294 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5688 00001297 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5689                                  				; DS:DX	-> ASCIZ filename
  5690                                  				; AL = access mode
  5691                                  				; 0 - read
  5692 00001299 7311                    		jnc	short TYPECONT
  5693 0000129B BA[E837]                		mov	dx,FNOTFOUNDPTR
  5694 0000129E 83F802                  		cmp	ax,2
  5695 000012A1 74CD                    		jz	short ERRJ
  5696 000012A3 BA[3C3D]                		mov	dx,BADCPMESPTR
  5697 000012A6 F9                      		stc
  5698 000012A7 E81A0C                  		call	GET_EXT_ERR_NUMBER
  5699                                  
  5700                                  		;jmp	CERROR
  5701 000012AA EBC4                    		jmp	short ERRJ
  5702                                  TYPECONT:
  5703 000012AC C606[E74B]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5704 000012B1 89C3                    		mov	bx,ax		; Handle
  5705 000012B3 8E1E[6342]              		mov	ds,[TPA]
  5706 000012B7 31D2                    		xor	dx,dx
  5707                                  TYPELP:
  5708 000012B9 2E803E[E74B]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5709 000012BF 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5710 000012C1 2E8B0E[8242]            		mov	cx,[cs:BYTCNT]	; No, continue
  5711 000012C6 B43F                    		mov	ah,READ ; 3Fh
  5712 000012C8 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5713                                  				; BX = file handle,CX = number	of bytes to read
  5714                                  				; DS:DX	-> buffer
  5715 000012CA 89C1                    		mov	cx,ax
  5716 000012CC E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5717                                  					; Check to see if a ^Z was read.
  5718 000012CE 1E                      		push	ds
  5719 000012CF 07                      		pop	es		
  5720 000012D0 31FF                    		xor	di,di
  5721 000012D2 50                      		push	ax
  5722 000012D3 B01A                    		mov	al,1Ah
  5723 000012D5 F2AE                    		repne scasb
  5724 000012D7 58                      		pop	ax
  5725 000012D8 91                      		xchg	ax,cx
  5726 000012D9 83F800                  		cmp	ax,0
  5727 000012DC 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5728 000012DE 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5729 000012E2 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5730                                  FOUNDZ:
  5731 000012E4 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5732 000012E6 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5733 000012E7 0E                      		push	cs		;  will be typed.
  5734 000012E8 07                      		pop	es
  5735 000012E9 2EF616[E74B]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5736                                  					;  will quit after this write.
  5737                                  TYPECONT2:
  5738 000012EE 53                      		push	bx
  5739 000012EF BB0100                  		mov	bx,1
  5740 000012F2 B440                    		mov	ah,WRITE ; 40h
  5741 000012F4 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5742                                  				; BX = file handle, CX = number of bytes to write,
  5743                                  				; DS:DX -> buffer
  5744 000012F6 5B                      		pop	bx
  5745 000012F7 720A                    		jc	short ERROR_OUTPUTJ
  5746 000012F9 39C8                    		cmp	ax,cx
  5747 000012FB 74BC                    		jz	short TYPELP
  5748 000012FD 49                      		dec	cx
  5749 000012FE 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5750 00001300 7501                    		jnz	short ERROR_OUTPUTJ
  5751                                  TYPEFIL_RETN:
  5752 00001302 C3                      		retn
  5753                                  ERROR_OUTPUTJ:
  5754 00001303 BB0100                  		mov	bx,1
  5755 00001306 B80044                  		mov	ax,IOCTL*256 ; 4400h
  5756 00001309 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5757                                  				; BX = file or device handle
  5758                                  		;test	dl,devid_ISDEV
  5759 0000130B F6C280                  		test	dl,80h
  5760 0000130E 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5761 00001310 E9DF06                  		jmp	ERROR_OUTPUT
  5762                                  
  5763                                  ; ---------------------------------------------------------------------------
  5764                                  
  5765                                  ; VOLUME command displays the volume ID on the specified drive
  5766                                  
  5767                                  VOLUME:
  5768                                  		; MSDOS 6.0
  5769                                  		;mov	si,81H
  5770                                  		;mov	di,offset trangroup:parse_vol
  5771                                  		;			;AN000; Get adderss of PARSE_VOL
  5772                                  		;xor	cx,cx		;AN000; clear cx,dx
  5773                                  		;xor	dx,dx		;AN000;
  5774                                  		;invoke	parse_with_msg	;AC018; call parser
  5775                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5776                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5777                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5778                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5779                                  
  5780                                  ; We have parsed off the drive. See if there are any more chars left
  5781                                  
  5782                                  		;mov	di,offset trangroup:parse_vol	
  5783                                  					;AC000; get address of parse_vol
  5784                                  		;xor	dx,dx		;AC000;
  5785                                  		;invoke	parse_check_eol ;AC000; call parser
  5786                                  		;jz	OkVolArg	;AC000; yes, end of road
  5787                                  
  5788                                  ; The line was not interpretable. Report an error.
  5789                                  
  5790                                  ;badvolarg:
  5791                                  		;jmp	Cerror
  5792                                  
  5793                                  		; MSDOS 3.3
  5794 00001313 BE8100                  		mov	si,81h
  5795 00001316 E86006                  		call	SCANOFF		; Skip to first non-delim
  5796                                  		;mov	ah,[5Ch]
  5797 00001319 8A265C00                		mov	ah,[FCB]
  5798                                  		;mov	byte [5Ch],0
  5799 0000131D C6065C0000              		mov	byte [FCB],0
  5800 00001322 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5801 00001324 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5802                                  		;mov	[5Ch],ah
  5803 00001326 88265C00                		mov	[FCB],ah
  5804 0000132A AC                      		lodsb
  5805 0000132B AC                      		lodsb
  5806 0000132C 3C3A                    		cmp	al,':'
  5807 0000132E 7507                    		jnz	short VOLUME_ERR
  5808 00001330 E84606                  		call	SCANOFF
  5809 00001333 3C0D                    		cmp	al,0Dh
  5810 00001335 7406                    		jz	short OKVOLARG
  5811                                  VOLUME_ERR:
  5812 00001337 BA[3939]                		mov	dx,BADDRVPTR
  5813 0000133A E9E608                  		jmp	CERROR
  5814                                  
  5815                                  ; ---------------------------------------------------------------------------
  5816                                  
  5817                                  OKVOLARG:
  5818 0000133D E82C06                  		call	CRLF2
  5819 00001340 1E                      		push	ds
  5820 00001341 07                      		pop	es
  5821                                  		;mov	di,55h
  5822 00001342 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5823 00001345 B0FF                    		mov	al,-1
  5824 00001347 AA                      		stosb
  5825 00001348 31C0                    		xor	ax,ax
  5826 0000134A AB                      		stosw
  5827 0000134B AB                      		stosw
  5828 0000134C AA                      		stosb
  5829 0000134D B008                    		mov	al,8		; Look for volume label
  5830 0000134F AA                      		stosb
  5831 00001350 47                      		inc	di		; Skip drive byte
  5832 00001351 B90B00                  		mov	cx,11
  5833 00001354 B03F                    		mov	al,'?'
  5834 00001356 F3AA                    		rep stosb
  5835 00001358 BA[5A43]                		mov	dx,DIRBUF
  5836 0000135B B41A                    		mov	ah,SET_DMA ; 1Ah
  5837 0000135D CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5838                                  				; DS:DX	-> disk	transfer buffer
  5839                                  		;mov	dx,55h
  5840 0000135F BA5500                  		mov	dx,FCB-7
  5841 00001362 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5842 00001364 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5843                                  				; DS:DX	-> FCB
  5844 00001366 E9E915                  		jmp	PRINTVOL
  5845                                  
  5846                                  ;============================================================================
  5847                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5848                                  ;============================================================================
  5849                                  ; 08/10/2018 - Retro DOS v3.0
  5850                                  
  5851                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5852                                  
  5853                                  ; ---------------------------------------------------------------------------
  5854                                  
  5855                                  ; MSDOS 6.0
  5856                                  ;***	Version - display DOS version
  5857                                  ;
  5858                                  ;	SYNTAX	ver [/debug]
  5859                                  ;
  5860                                  ;		/debug - display additional DOS configuration info
  5861                                  ;
  5862                                  ;	ENTRY	command-line tail is in PSP
  5863                                  ;
  5864                                  ;	EXIT	if successful, nothing
  5865                                  ;		if parse fails,
  5866                                  ;		  parse error message is set up (for Std_EPrintf)
  5867                                  ;		    AX = system parser error code
  5868                                  ;		    DX = ptr to message block
  5869                                  ;		  we jump to CError
  5870                                  ;
  5871                                  ;	EFFECTS
  5872                                  ;	  If parse fails, a parse error message is displayed.
  5873                                  ;	  Otherwise, version message is displayed.
  5874                                  ;	  If /debug is specified, additional DOS info is displayed.
  5875                                  
  5876                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5877                                  ;
  5878                                  ;;	Parse command line for /debug switch.
  5879                                  ;
  5880                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5881                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5882                                  ;	xor	cx,cx				; CX = # positional param's found
  5883                                  ;	invoke	Parse_With_Msg
  5884                                  ;
  5885                                  ;	mov	bl,1			; BL = flag = /debug present
  5886                                  ;	cmp	ax,RESULT_NO_ERROR
  5887                                  ;	je	verPrintVer		; something parsed - must be /debug
  5888                                  ;	dec	bl			; BL = flag = no /debug present
  5889                                  ;	cmp	ax,END_OF_LINE
  5890                                  ;	je	verPrintVer		; reached end of line - ok
  5891                                  ;
  5892                                  ;;	The parse failed.  Error message has been set up.
  5893                                  ;
  5894                                  ;	jmp	CError
  5895                                  ;
  5896                                  ;verPrintVer:
  5897                                  ;	push	bx			; save /debug flag
  5898                                  ;	call	Crlf2
  5899                                  ;	call	Print_Version
  5900                                  ;	call	Crlf2
  5901                                  ;	pop	bx   			; BL = /debug flag
  5902                                  ;	or	bl,bl
  5903                                  ;	jz	verDone			; /debug is false - we're done
  5904                                  ;
  5905                                  ;;*	For /debug, display DOS internal revision and DOS location
  5906                                  ;;	(low memory, HMA, or ROM).
  5907                                  ;
  5908                                  ;;	Bugbug:	use symbols for bitmasks below.
  5909                                  ;
  5910                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5911                                  ;	int	21h
  5912                                  ;	mov	al,dl			;revision number in dl; M013
  5913                                  ;	mov	bh,dh			;flags in dh now; M013
  5914                                  ;;M032	and	al,7			; AL = DOS internal revision
  5915                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5916                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5917                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5918                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5919                                  ;	mov	One_Char_Val,al
  5920                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5921                                  ;	invoke	Std_Printf		; print DOS internal revision
  5922                                  ;
  5923                                  ;	mov	cl,4
  5924                                  ;	shr	bh,cl			; CY = DOS in ROM
  5925                                  ;	jc	verRom
  5926                                  ;	shr	bh,1			; CY = DOS in HMA
  5927                                  ;	jc	verHma
  5928                                  ;
  5929                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  5930                                  ;
  5931                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  5932                                  ;	jmp	short verPrintLoc
  5933                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  5934                                  ;	jmp	short verPrintLoc
  5935                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  5936                                  ;verPrintLoc:
  5937                                  ;	invoke	Std_Printf
  5938                                  ;verDone:
  5939                                  ;	jmp	Crlf2
  5940                                  
  5941                                  		; MSDOS 3.3
  5942                                  VERSION:
  5943 00001369 E80006                  		call	CRLF2
  5944 0000136C E80300                  		call	PRINT_VERSION
  5945 0000136F E9FA05                  		jmp	CRLF2
  5946                                  
  5947                                  ; =============== S U B	R O U T	I N E =======================================
  5948                                  
  5949                                  PRINT_VERSION:
  5950 00001372 B430                    		mov	ah,GET_VERSION ; 30h
  5951 00001374 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  5952                                  				; Return: AL = major version number (00h for DOS 1.x)
  5953 00001376 50                      		push	ax
  5954 00001377 30E4                    		xor	ah,ah
  5955 00001379 A3[4D44]                		mov	[MAJOR_VER_NUM],ax
  5956 0000137C 58                      		pop	ax
  5957 0000137D 86E0                    		xchg	ah,al
  5958 0000137F 30E4                    		xor	ah,ah
  5959 00001381 A3[4F44]                		mov	[MINOR_VER_NUM],ax
  5960 00001384 BA[173B]                		mov	dx,VERMESPTR
  5961 00001387 E93921                  		jmp	STD_PRINTF
  5962                                  
  5963                                  ; =============== S U B	R O U T	I N E =======================================
  5964                                  
  5965                                  PRINT_PROMPT:
  5966 0000138A 1E                      		push	ds
  5967 0000138B 0E                      		push	cs
  5968 0000138C 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  5969 0000138D 06                      		push	es
  5970 0000138E E80304                  		call	FIND_PROMPT	; Look for prompt string
  5971 00001391 7206                    		jc	short PP0	; Can't find one	
  5972 00001393 26803D00                		cmp	byte [es:di],0
  5973 00001397 750A                    		jnz	short PP1
  5974                                  PP0:					; Use default prompt
  5975 00001399 E87200                  		call	PRINT_DRIVE
  5976                                  		;mov	al,'>'
  5977 0000139C B03E                    		mov	al,SYM
  5978 0000139E E85A00                  		call	PRINT_CHAR
  5979 000013A1 EB3A                    		jmp	short PP5
  5980                                  PP1:
  5981 000013A3 268A05                  		mov	al,[es:di]	; Get a char
  5982 000013A6 47                      		inc	di
  5983 000013A7 08C0                    		or	al,al
  5984 000013A9 7432                    		jz	short PP5	; Nul terminated
  5985 000013AB 3A06[E43E]              		cmp	al,[DOLLAR]	; Meta character
  5986 000013AF 7405                    		jz	short PP2	; Nope
  5987 000013B1 E84700                  		call	PRINT_CHAR
  5988 000013B4 EBED                    		jmp	short PP1
  5989                                  PP2:
  5990 000013B6 268A05                  		mov	al,[es:di]
  5991 000013B9 47                      		inc	di
  5992                                  		;mov	bx,CLSSTRING+2	; "[2J"
  5993 000013BA BB[8C3D]                		mov	bx,PROMPT_TABLE-3
  5994 000013BD 08C0                    		or	al,al
  5995 000013BF 741C                    		jz	short PP5
  5996                                  PP3:
  5997 000013C1 83C303                  		add	bx,3
  5998                                  		;call	UPCONV
  5999 000013C4 E85704                  		call	UPCONV_MAPCALL
  6000 000013C7 3A07                    		cmp	al,[bx]
  6001 000013C9 7407                    		jz	short PP4
  6002 000013CB 803F00                  		cmp	byte [bx],0
  6003 000013CE 75F1                    		jnz	short PP3
  6004 000013D0 EBD1                    		jmp	short PP1
  6005                                  PP4:
  6006 000013D2 06                      		push	es
  6007 000013D3 57                      		push	di
  6008 000013D4 0E                      		push	cs
  6009 000013D5 07                      		pop	es
  6010 000013D6 FF5701                  		call	word [bx+1]
  6011 000013D9 5F                      		pop	di
  6012 000013DA 07                      		pop	es
  6013 000013DB EBC6                    		jmp	short PP1
  6014                                  PP5:
  6015 000013DD 07                      		pop	es		; Restore segments
  6016 000013DE 1F                      		pop	ds
  6017 000013DF C3                      		retn
  6018                                  
  6019                                  ; ---------------------------------------------------------------------------
  6020                                  
  6021                                  PRINT_BACK:
  6022 000013E0 BA[843D]                		mov	dx,DBACKPTR
  6023 000013E3 E9DD20                  		jmp	STD_PRINTF
  6024                                  
  6025                                  ; ---------------------------------------------------------------------------
  6026                                  
  6027                                  PRINT_EQ:
  6028 000013E6 B03D                    		mov	al,'='
  6029 000013E8 EB11                    		jmp	short PRINT_CHAR
  6030                                  
  6031                                  ; ---------------------------------------------------------------------------
  6032                                  
  6033                                  PRINT_ESC:
  6034 000013EA B01B                    		mov	al,1Bh
  6035 000013EC EB0D                    		jmp	short PRINT_CHAR
  6036                                  
  6037                                  ; ---------------------------------------------------------------------------
  6038                                  
  6039                                  PRINT_G:
  6040 000013EE A0[E33E]                		mov	al,[RABRACKET]
  6041 000013F1 EB08                    		jmp	short PRINT_CHAR
  6042                                  
  6043                                  ; ---------------------------------------------------------------------------
  6044                                  
  6045                                  PRINT_L:
  6046 000013F3 A0[E23E]                		mov	al,[LABRACKET]
  6047 000013F6 EB03                    		jmp	short PRINT_CHAR
  6048                                  
  6049                                  ; ---------------------------------------------------------------------------
  6050                                  
  6051                                  PRINT_B:
  6052 000013F8 A0[E13E]                		mov	al,[VBAR]
  6053                                  
  6054                                  ; =============== S U B	R O U T	I N E =======================================
  6055                                  
  6056                                  PRINT_CHAR:
  6057                                  		; MSDOS 6.0
  6058                                  
  6059                                  ;	Bugbug:	Why bother with ds,es here?
  6060                                  		
  6061                                  		;push	es
  6062                                  		;push	ds
  6063                                  		;pop	es
  6064                                  		;push	di
  6065                                  		;push	dx
  6066                                  		;mov	dl,al		;AC000; Get char into al
  6067                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6068                                  		;int	21h		;AC000;
  6069                                  		;pop	dx
  6070                                  		;pop	di
  6071                                  		;pop	es
  6072                                  		;retn
  6073                                  
  6074                                  		; MSDOS 3.3
  6075 000013FB 06                      		push	es
  6076 000013FC 1E                      		push	ds
  6077 000013FD 07                      		pop	es
  6078 000013FE 57                      		push	di
  6079 000013FF 52                      		push	dx
  6080 00001400 BF[5144]                		mov	di,ONE_CHAR_VAL	
  6081 00001403 AA                      		stosb
  6082 00001404 BA[203B]                		mov	dx,ONECHRVALPTR
  6083 00001407 E8B920                  		call	STD_PRINTF
  6084 0000140A 5A                      		pop	dx
  6085 0000140B 5F                      		pop	di
  6086 0000140C 07                      		pop	es
  6087 0000140D C3                      		retn
  6088                                  
  6089                                  ; ---------------------------------------------------------------------------
  6090                                  
  6091                                  PRINT_DRIVE:
  6092 0000140E B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6093 00001410 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6094                                  		;add	al,'A'
  6095 00001412 0206[E03E]              		add	al,[CAPITAL_A]
  6096 00001416 E8E2FF                  		call	PRINT_CHAR
  6097 00001419 C3                      		retn
  6098                                  
  6099                                  ; ---------------------------------------------------------------------------
  6100                                  
  6101                                  BUILD_DIR_FOR_PROMPT:
  6102 0000141A 30D2                    		xor	dl,dl
  6103 0000141C BE[5A43]                		mov	si,BWDBUF
  6104 0000141F 89F7                    		mov	di,si
  6105 00001421 A0[7542]                		mov	al,[CURDRV]
  6106 00001424 0441                    		add	al,'A'
  6107 00001426 B43A                    		mov	ah,':'
  6108 00001428 AB                      		stosw
  6109 00001429 A0[6642]                		mov	al,[DIRCHAR]
  6110 0000142C AA                      		stosb
  6111 0000142D 87F7                    		xchg	si,di
  6112 0000142F 893E[3E44]              		mov	[STRING_PTR_2],di
  6113 00001433 B447                    		mov	ah,CURRENT_DIR ; 47h
  6114 00001435 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6115                                  				; DL = drive (0=default,1=A,etc.)
  6116                                  				; DS:SI	points to 64-byte buffer area
  6117 00001437 BA[2F37]                		mov	dx,STRINGBUF2PTR
  6118 0000143A 7303                    		jnc	short DOPRINT
  6119 0000143C BA[DB39]                		mov	dx,BADCURDRVPTR
  6120                                  DOPRINT:
  6121 0000143F E88120                  		call	STD_PRINTF
  6122 00001442 C3                      		retn
  6123                                  
  6124                                  ; =============== S U B	R O U T	I N E =======================================
  6125                                  
  6126                                  BUILD_DIR_FOR_CHDIR:
  6127 00001443 E80E00                  		call	BUILD_DIR_STRING
  6128 00001446 BA[5A43]                		mov	dx,DIRBUF
  6129 00001449 8916[3E44]              		mov	[STRING_PTR_2],dx
  6130                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6131 0000144D BA[2F37]                		mov	dx,STRINGBUF2PTR
  6132 00001450 E87020                  		call	STD_PRINTF
  6133 00001453 C3                      		retn
  6134                                  
  6135                                  
  6136                                  ; =============== S U B	R O U T	I N E =======================================
  6137                                  
  6138                                  BUILD_DIR_STRING:
  6139 00001454 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6140 00001458 88D0                    		mov	al,dl
  6141 0000145A 0440                    		add	al,'@'
  6142 0000145C 3C40                    		cmp	al,'@'
  6143 0000145E 7506                    		jnz	short GOTDRIVE
  6144 00001460 0206[7542]              		add	al,[CURDRV]
  6145 00001464 FEC0                    		inc	al
  6146                                  GOTDRIVE:
  6147 00001466 50                      		push	ax
  6148 00001467 BE[5D43]                		mov	si,BWDBUF+3
  6149 0000146A B447                    		mov	ah,CURRENT_DIR ; 47h
  6150 0000146C CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6151                                  				; DL = drive (0=default,1=A,etc.)
  6152                                  				; DS:SI	points to 64-byte buffer area
  6153 0000146E 7305                    		jnc	short DPBISOK
  6154 00001470 0E                      		push	cs
  6155 00001471 1F                      		pop	ds
  6156 00001472 E96306                  		jmp	DRVBAD
  6157                                  DPBISOK:
  6158 00001475 BF[5A43]                		mov	di,BWDBUF
  6159 00001478 89FA                    		mov	dx,di
  6160 0000147A 58                      		pop	ax
  6161 0000147B B43A                    		mov	ah,':'
  6162 0000147D AB                      		stosw
  6163 0000147E A0[6642]                		mov	al,[DIRCHAR]
  6164 00001481 AA                      		stosb
  6165 00001482 C3                      		retn
  6166                                  
  6167                                  ; ---------------------------------------------------------------------------
  6168                                  
  6169                                  PATH:
  6170                                  		; MSDOS 6.0
  6171                                  		;xor	al,al		;AN049; Set up holding buffer
  6172                                  		;mov	di,offset Trangroup:srcxname
  6173                                  					;AN049;   for PATH while parsing
  6174                                  		;stosb				;AN049; Initialize PATH to null
  6175                                  		;dec	di			;AN049; point to the start of buffer
  6176                                  		;invoke	PGetarg 		; Pre scan for arguments
  6177                                  		;jz	disppath		; Print the current path
  6178                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6179                                  		;jnz	pathslp 		;AC049;
  6180                                  		;inc	si			;AN049; point past semicolon
  6181                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6182                                  ;pathslp:					; Get the user specified path
  6183                                  		;lodsb				; Get a character
  6184                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6185                                  		;jz	path_eol		;AC049; yes - end of command
  6186                                  		;invoke	testkanj		;See if DBCS
  6187                                  		;jz	notkanj2		;No - continue
  6188                                  		;stosb				;AC049; Yes - store the first byte
  6189                                  		;lodsb				;skip second byte of DBCS
  6190                                  ;path_hold:					;AN049;
  6191                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6192                                  		;jmp	short pathslp		;continue parsing
  6193                                  ;notkanj2:
  6194                                  		;invoke	upconv			;upper case the character
  6195                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6196                                  		;jz	path_hold		;AC049; go store it
  6197                                  		;invoke	delim			;delimiter?
  6198                                  		;jnz	path_hold		;AC049; no - go store character
  6199                                  ;scan_white:					;AN049; make sure were at EOL
  6200                                  		;lodsb				;AN049; get a character
  6201                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6202                                  		;jz	path_eol		;AN049; yes - go set path
  6203                                  		;cmp	al,blank		;AN049; whitespace?
  6204                                  		;jz	scan_white		;AN049; yes - continue scanning
  6205                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6206                                  		;jz	scan_white		;AN049; yes - continue scanning
  6207                                  
  6208                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6209                                  						;AN049; no - set up error message
  6210                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6211                                  						;AN049; get "Too many parameters" message number
  6212                                  		;mov	msg_disp_class,parse_msg_class
  6213                                  						;AN049; set up parse error msg class
  6214                                  		;jmp	cerror			;AN049;
  6215                                  ;path_eol:					;AN049; Parsing was clean
  6216                                  		;xor	al,al			;AN049; null terminate the PATH
  6217                                  		;stosb				;AN049;    buffer
  6218                                  		;invoke	find_path		;AN049; Find PATH in environment
  6219                                  		;invoke	delete_path		;AC049; Delete any offending name
  6220                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6221                                  		;invoke	move_name		;AC049; move in PATH=
  6222                                  		;mov	si,offset Trangroup:srcxname	
  6223                                  						;AN049; Set up source as PATH buffer
  6224                                  ;store_path:					;AN049; Store the PATH in the environment
  6225                                  		;lodsb				;AN049; Get a character
  6226                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6227                                  		;jz	got_paths		;AN049; yes - exit
  6228                                  		;invoke	store_char		;AN049; no - store character
  6229                                  		;jmp	short store_path	;AN049; continue
  6230                                  ;got_paths:					;AN049; we're finished
  6231                                  		;xor	ax,ax			;	null terminate the PATH in
  6232                                  		;stosw				;    	the environment
  6233                                  		;return
  6234                                  ;disppath:
  6235                                  		;invoke	find_path		;AN049;
  6236                                  		;call	print_path
  6237                                  		;call	crlf2
  6238                                  		;retn
  6239                                  
  6240                                  		; MSDOS 3.3
  6241 00001483 E80903                  		call	FIND_PATH		; Find PATH in environment
  6242 00001486 E85C09                  		call	PGETARG			; Pre scan for arguments
  6243 00001489 742A                    		jz	short DISPPATH		; Print the current path
  6244 0000148B E8DF02                  		call	DELETE_PATH		; Delete any offending name
  6245 0000148E E86B03                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6246 00001491 E84903                  		call	MOVE_NAME		; Move in PATH=
  6247 00001494 E84E09                  		call	PGETARG
  6248 00001497 3C3B                    		cmp	al,';'
  6249 00001499 7416                    		jz	short GOTPATHS
  6250                                  PATHSLP:
  6251 0000149B AC                      		lodsb
  6252 0000149C 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6253 0000149E 7411                    		jz	short GOTPATHS		; yes - exit
  6254                                  		;call	UPCONV
  6255 000014A0 E87B03                  		call	UPCONV_MAPCALL		; convert to uppercase
  6256 000014A3 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6257 000014A5 7405                    		jz	short NOTDELIM		; go set path
  6258 000014A7 E8D704                  		call	DELIM			; is it delim/null char ?
  6259 000014AA 7405                    		jz	short GOTPATHS		; yes - exit
  6260                                  NOTDELIM:
  6261 000014AC E88303                  		call	STORE_CHAR		; no - store character
  6262 000014AF EBEA                    		jmp	short PATHSLP
  6263                                  GOTPATHS:
  6264 000014B1 31C0                    		xor	ax,ax			; null terminate the PATH
  6265 000014B3 AB                      		stosw				; in the environment
  6266 000014B4 C3                      		retn
  6267                                  DISPPATH:
  6268 000014B5 E80400                  		call	PRINT_PATH
  6269 000014B8 E8B104                  		call	CRLF2
  6270 000014BB C3                      		retn
  6271                                  
  6272                                  ; =============== S U B	R O U T	I N E =======================================
  6273                                  
  6274                                  PRINT_PATH:
  6275 000014BC 26803D00                		cmp	byte [es:di],0
  6276 000014C0 750A                    		jnz	short PATH1
  6277                                  PATH0:
  6278 000014C2 BA[FB3B]                		mov	dx,NULLPATHPTR
  6279 000014C5 0E                      		push	cs
  6280 000014C6 07                      		pop	es
  6281 000014C7 0E                      		push	cs
  6282 000014C8 1F                      		pop	ds
  6283 000014C9 E9F71F                  		jmp	STD_PRINTF
  6284                                  PATH1:
  6285 000014CC 06                      		push	es
  6286 000014CD 1F                      		pop	ds
  6287 000014CE 83EF05                  		sub	di,5
  6288 000014D1 89FE                    		mov	si,di
  6289 000014D3 E84003                  		call	SCASB2		; Look for null
  6290 000014D6 81F9FF00                		cmp	cx,0FFh
  6291 000014DA 74E6                    		jz	short PATH0
  6292 000014DC 0E                      		push	cs
  6293 000014DD 07                      		pop	es
  6294 000014DE BF[B843]                		mov	di,ARG_BUF
  6295 000014E1 BA0001                  		mov	dx,100h
  6296 000014E4 29CA                    		sub	dx,cx
  6297 000014E6 87D1                    		xchg	dx,cx
  6298 000014E8 F3A4                    		rep movsb
  6299 000014EA BA[1337]                		mov	dx,ARG_BUF_PTR
  6300 000014ED 0E                      		push	cs
  6301 000014EE 1F                      		pop	ds
  6302 000014EF E9D11F                  		jmp	STD_PRINTF
  6303                                  
  6304                                  ; ---------------------------------------------------------------------------
  6305                                  
  6306                                  ; ****************************************************************
  6307                                  ; *
  6308                                  ; * ROUTINE:	 CLS
  6309                                  ; *
  6310                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6311                                  ; *		 installed, send a control string to clear the
  6312                                  ; *		 screen.
  6313                                  ; *
  6314                                  ; * INPUT:	 command line at offset 81H
  6315                                  ; *
  6316                                  ; * OUTPUT:	 none
  6317                                  ; *
  6318                                  ; ****************************************************************
  6319                                  
  6320                                  ; MSDOS 3.3
  6321                                  
  6322                                  CLS:
  6323 000014F2 BB0100                  		mov	bx,STDOUT ; 1
  6324 000014F5 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6325 000014F8 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6326                                  				; BX = file or device handle
  6327 000014FA F6C280                  		test	dl,80h	; devid_ISDEV
  6328 000014FD 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6329 000014FF F6C210                  		test	dl,10h  ; devid_SPECIAL
  6330 00001502 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6331                                  
  6332 00001504 B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6333 00001507 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6334                                  				; AL = interrupt number
  6335                                  				; Return: ES:BX	= value	of interrupt vector
  6336 00001509 8CC2                    		mov	dx,es
  6337 0000150B B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6338 0000150E CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6339                                  				; AL = interrupt number
  6340                                  				; Return: ES:BX	= value	of interrupt vector
  6341 00001510 8CC0                    		mov	ax,es
  6342 00001512 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6343 00001514 7735                    		ja	short ANSICLS
  6344                                  
  6345 00001516 B40F                    		mov	ah,0Fh
  6346 00001518 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6347                                  				; Return: AH = number of columns on screen
  6348                                  				; AL = current video mode
  6349                                  				; BH = current active display page
  6350 0000151A 3C03                    		cmp	al,3
  6351 0000151C 7609                    		jbe	short DOALPHA
  6352 0000151E 3C07                    		cmp	al,7
  6353 00001520 7405                    		jz	short DOALPHA
  6354 00001522 B400                    		mov	ah,0
  6355 00001524 CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6356                                  				; AL = mode
  6357 00001526 C3                      		retn
  6358                                  
  6359                                  DOALPHA:
  6360 00001527 B40B                    		mov	ah,0Bh	; Set overscan to black
  6361 00001529 31DB                    		xor	bx,bx
  6362 0000152B CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6363                                  				; BH = 00h, BL = border color
  6364                                  				; BH = 01h, BL = palette (0-3)
  6365 0000152D B40F                    		mov	ah,0Fh
  6366 0000152F CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6367                                  				; Return: AH = number of columns on screen
  6368                                  				; AL = current video mode
  6369                                  				; BH = current active display page
  6370 00001531 88E2                    		mov	dl,ah
  6371 00001533 FECA                    		dec	dl
  6372 00001535 B618                    		mov	dh,24
  6373 00001537 31C0                    		xor	ax,ax
  6374 00001539 89C1                    		mov	cx,ax
  6375 0000153B BB0007                  		mov	bx,700h
  6376 0000153E B406                    		mov	ah,6
  6377 00001540 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6378                                  				; AL = number of lines to scroll window	
  6379                                  				;	(0 = blank whole window)
  6380                                  				; BH = attributes to be	used on	blanked	lines
  6381                                  				; CH,CL	= row,column of	upper left corner of window 
  6382                                  				;	  to scroll
  6383                                  				; DH,DL	= row,column of	lower right corner of window
  6384 00001542 31D2                    		xor	dx,dx
  6385 00001544 B700                    		mov	bh,0
  6386 00001546 B402                    		mov	ah,2
  6387 00001548 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6388                                  				; DH,DL	= row,column (0,0 = upper left)
  6389                                  				; BH = page number
  6390 0000154A C3                      		retn
  6391                                  
  6392                                  ANSICLS:
  6393 0000154B BE[8A3D]                		mov	si,CLSSTRING
  6394 0000154E AC                      		lodsb
  6395 0000154F 88C1                    		mov	cl,al
  6396 00001551 30ED                    		xor	ch,ch
  6397 00001553 B406                    		mov	ah,RAW_CON_IO ; 6
  6398                                  CLRLOOP:
  6399 00001555 AC                      		lodsb
  6400 00001556 88C2                    		mov	dl,al
  6401 00001558 CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6402                                  				; DL = character <> FFh
  6403                                  				;  Return: ZF set = no character
  6404                                  				;   ZF clear = character recieved, AL = character
  6405 0000155A E2F9                    		loop	CLRLOOP
  6406 0000155C C3                      		retn
  6407                                  
  6408                                  ; ---------------------------------------------------------------------------
  6409                                  
  6410                                  ; MSDOS 6.0
  6411                                  
  6412                                  ;ANSI_installed		equ    0ffh
  6413                                  ;
  6414                                  ;CLS:
  6415                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6416                                  ;	mov	al,0			;AN000;
  6417                                  ;	int	2fh			;AN000;
  6418                                  ;	cmp	al,ANSI_installed	;AN000;
  6419                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6420                                  ;
  6421                                  ;check_lines:
  6422                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6423                                  ;					;AN000; get lines per page on display
  6424                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6425                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6426                                  ;	mov	cl,get_generic		;AN000; get information
  6427                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6428                                  ;	int	21h			;AN000;
  6429                                  ;	jc	no_variable		;AN000; function had error, use default
  6430                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6431                                  ;	mov	dh,al			;AN000; set number of rows
  6432                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6433                                  ;	mov	dl,al			;AN000; set number of columns
  6434                                  ;	jmp	short regcls		;AN000; go do cls
  6435                                  ;
  6436                                  ;no_variable:
  6437                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6438                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6439                                  ;	int	21h			;AC000;
  6440                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6441                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6442                                  ;	test	dl,devid_SPECIAL	;AC000;
  6443                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6444                                  ;
  6445                                  ;ansicls:
  6446                                  ;	call	ansi_cls		;AN000; clear the screen
  6447                                  ;	jmp	short cls_ret		;AN000; exit
  6448                                  ;
  6449                                  ;;
  6450                                  ;; Get video mode
  6451                                  ;;
  6452                                  ;
  6453                                  ;cls_normal:				;AC000;
  6454                                  ;
  6455                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6456                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6457                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6458                                  ;	jbe	DoAlpha
  6459                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6460                                  ;	jz	DoAlpha
  6461                                  ;;
  6462                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6463                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6464                                  ;; screen too.
  6465                                  ;;
  6466                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6467                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6468                                  ;	jmp	short cls_ret		;AC000; exit
  6469                                  ;
  6470                                  ;DoAlpha:
  6471                                  ;;
  6472                                  ;; Get video mode and number of columns to scroll
  6473                                  ;;
  6474                                  ;
  6475                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6476                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6477                                  ;;M01   area
  6478                                  ;;M01   Commented out code here is the original
  6479                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6480                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6481                                  ;;M01	mov	dl,ah
  6482                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6483                                  ;
  6484                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6485                                  ;
  6486                                  ;	push	ds
  6487                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6488                                  ;	MOV	DS,AX			;  *			M01
  6489                                  ;	Assume	DS:ROMBIOS_DATA
  6490                                  ;
  6491                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6492                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6493                                  ;	pop	ds			;			M01
  6494                                  ;	Assume	DS:Trangroup
  6495                                  ;
  6496                                  ;	or	dh,dh			; Q:ZERO		M01
  6497                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6498                                  ;
  6499                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6500                                  ;
  6501                                  ;regcls:
  6502                                  ;	inc	dh			; height+1		M018
  6503                                  ;	call	reg_cls 		; go clear the screen
  6504                                  ;
  6505                                  ;cls_ret:
  6506                                  ;	ret				; exit
  6507                                  
  6508                                  ; ---------------------------------------------------------------------------
  6509                                  
  6510                                  ; MSDOS 6.0
  6511                                  
  6512                                  ; ****************************************************************
  6513                                  ; *
  6514                                  ; * ROUTINE:	 REG_CLS
  6515                                  ; *
  6516                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6517                                  ; *
  6518                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6519                                  ; *		 DH = NUMBER OF ROWS
  6520                                  ; *
  6521                                  ; * OUTPUT:	 none
  6522                                  ; *
  6523                                  ; ****************************************************************
  6524                                  
  6525                                  ;reg_cls proc	near
  6526                                  ;
  6527                                  ;;
  6528                                  ;; Set overscan to black.
  6529                                  ;;
  6530                                  ;	dec	dh			;  decrement rows and columns
  6531                                  ;	dec	dl			;     to zero base
  6532                                  ;	push	dx			;  save rows,columns
  6533                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6534                                  ;	xor	bx,bx
  6535                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6536                                  ;	pop	dx			;  retore rows,colums
  6537                                  ;
  6538                                  ;	xor	ax,ax			;  zero out ax
  6539                                  ;	mov	CX,ax			;     an cx
  6540                                  ;;
  6541                                  ;; Scroll active page
  6542                                  ;;
  6543                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6544                                  ;	mov	bh,video_attribute	; attribute for blank line
  6545                                  ;	xor	bl,bl			; set BL to 0
  6546                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6547                                  ;;
  6548                                  ;; Seek to cursor to 0,0
  6549                                  ;;
  6550                                  ;;M022 following two lines added
  6551                                  ;	mov	ah,get_video_state	; get current video page in BH
  6552                                  ;	int	video_io_int
  6553                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6554                                  ;	xor	dx,dx			; row and column 0
  6555                                  ;;M022	mov	bh.0
  6556                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6557                                  ;
  6558                                  ;	ret
  6559                                  ;
  6560                                  ;reg_cls endp
  6561                                  
  6562                                  ; ---------------------------------------------------------------------------
  6563                                  
  6564                                  ; MSDOS 6.0
  6565                                  
  6566                                  ; ****************************************************************
  6567                                  ; *
  6568                                  ; * ROUTINE:	 ANSI_CLS
  6569                                  ; *
  6570                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6571                                  ; *		 to STDOUT.
  6572                                  ; *
  6573                                  ; * INPUT:	 none
  6574                                  ; *
  6575                                  ; * OUTPUT:	 none
  6576                                  ; *
  6577                                  ; ****************************************************************
  6578                                  
  6579                                  ;ansi_cls proc	near			;AC000;
  6580                                  ;
  6581                                  ;	mov	si,offset trangroup:clsstring
  6582                                  ;	lodsb
  6583                                  ;	mov	cl,al
  6584                                  ;	xor	ch,ch
  6585                                  ;	mov	ah,Raw_CON_IO
  6586                                  ;clrloop:
  6587                                  ;	lodsb
  6588                                  ;	mov	DL,al
  6589                                  ;	int	21h
  6590                                  ;	loop	clrloop
  6591                                  ;	return
  6592                                  ;
  6593                                  ;ansi_cls	endp			;AC000;
  6594                                  
  6595                                  ;============================================================================
  6596                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6597                                  ;============================================================================
  6598                                  ; 08/10/2018 - Retro DOS v3.0
  6599                                  
  6600                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6601                                  
  6602                                  ; ---------------------------------------------------------------------------
  6603                                  
  6604                                  ; ****************************************************************
  6605                                  ; *
  6606                                  ; * ROUTINE:	 CTTY - Change console
  6607                                  ; *
  6608                                  ; * SYNTAX:	 CTTY device
  6609                                  ; *
  6610                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6611                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6612                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6613                                  ; *
  6614                                  ; * INPUT:	 command line at offset 81H
  6615                                  ; *
  6616                                  ; * OUTPUT:	 none
  6617                                  ; *
  6618                                  ; ****************************************************************
  6619                                  
  6620                                  CTTY:
  6621                                  		; MSDOS 6.0
  6622                                  		;push	ds			;AN000; Get local ES
  6623                                  		;pop	es			;AN000;
  6624                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6625                                  
  6626                                  		;mov	di,offset trangroup:parse_ctty	
  6627                                  						;AC000; Get adderss of PARSE_CTTY
  6628                                  		;xor	cx,cx			;AC000; clear cx,dx
  6629                                  		;xor	dx,dx			;AC000;
  6630                                  		;invoke	cmd_parse		;AC000; call parser
  6631                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6632                                  		;jz	ctty_error		;AN000; yes - error
  6633                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6634                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6635                                  
  6636                                  		;push	si			;AN000; save position in line
  6637                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6638                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6639                                  
  6640                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6641                                  		;lodsb				;AN000; get a char from buffer
  6642                                  		;stosb				;AN000; store in srcbuf
  6643                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6644                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6645                                  		;pop	si			;AN000; get line position back
  6646                                  		;mov	di,offset trangroup:parse_ctty	
  6647                                  						;AC000; Get adderss of PARSE_CTTY
  6648                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6649                                  		;jz	nocolon 		;AN000; yes - continue
  6650                                  
  6651                                  ;ctty_error:
  6652                                  		;jmp	short isbaddev		;AC000; yes - exit
  6653                                  
  6654                                  		; MSDOS 3.3
  6655 0000155D E81108                  		call	SETPATH
  6656 00001560 4E                      		dec	si
  6657 00001561 4E                      		dec	si
  6658 00001562 803C3A                  		cmp	byte [si],':'
  6659 00001565 7503                    		jnz	short NOCOLON
  6660 00001567 C60400                  		mov	byte [si],0
  6661                                  NOCOLON:
  6662                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6663                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6664 0000156A B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6665 0000156D CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6666                                  				; DS:DX	-> ASCIZ filename
  6667                                  				; AL = access mode
  6668                                  				; 2 - read & write
  6669 0000156F 7210                    		jc	short ISBADDEV
  6670 00001571 89C3                    			mov	bx,ax
  6671 00001573 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6672 00001576 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6673                                  				; BX = file or device handle
  6674 00001578 F6C280                  		test	dl,80h
  6675 0000157B 750C                    		jnz	short DEVISOK
  6676                                  CLOSEDEV:
  6677 0000157D B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6678 0000157F CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6679                                  				; BX = file handle
  6680                                  ISBADDEV:
  6681 00001581 BA[433C]                		mov	dx,BADDEVPTR
  6682 00001584 E83C1F                  		call	STD_PRINTF
  6683 00001587 EB28                    		jmp	short RESRET
  6684                                  
  6685                                  		;nop
  6686                                  DEVISOK:
  6687                                  		; MSDOS 6.0
  6688                                  		;push	dx		;AN007; save device info
  6689                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6690                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6691                                  		;push	bx		;AN021; save handle
  6692                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6693                                  		;mov	dx,si		;AN021; get address into dx
  6694                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6695                                  		;mov	cx,2		;AN007; write two bytes
  6696                                  		;int	21h		;AN007;
  6697                                  		;pop	bx		;AN021; get back handle
  6698                                  		;pop	dx		;AN007; get back device info
  6699                                  		;jc	closedev	;AN007; if error, quit
  6700                                  
  6701                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6702 00001589 30F6                    		xor	dh,dh
  6703 0000158B 80CA03                  		or	dl,3
  6704                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6705 0000158E B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6706 00001591 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6707                                  				; BX = device handle,DH = 0
  6708                                  				; DL = device information to set 
  6709                                  				;		(bits 0-7 from	function 0)
  6710 00001593 53                      		push	bx
  6711 00001594 B90300                  		mov	cx,3
  6712 00001597 31DB                    		xor	bx,bx
  6713                                  
  6714                                  ICLLOOP:				; Close basic handles
  6715 00001599 B43E                    		mov	ah,CLOSE ; 3Eh
  6716 0000159B CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6717                                  				; BX = file handle
  6718 0000159D 43                      		inc	bx
  6719 0000159E E2F9                    		loop	ICLLOOP
  6720 000015A0 5B                      		pop	bx		; Get handle
  6721 000015A1 B445                    		mov	ah,XDUP ; 45h
  6722 000015A3 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6723                                  				; BX = file handle to duplicate
  6724 000015A5 B445                    		mov	ah,XDUP ; 45h
  6725 000015A7 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6726                                  				; BX = file handle to duplicate
  6727 000015A9 B445                    		mov	ah,XDUP ;45h
  6728 000015AB CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6729                                  				; BX = file handle to duplicate
  6730 000015AD B43E                    		mov	ah,CLOSE ; 3Eh
  6731 000015AF CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6732                                  				; BX = file handle
  6733                                  RESRET:
  6734 000015B1 8E1E[6142]              		mov	ds,[RESSEG]
  6735 000015B5 1E                      		push	ds
  6736 000015B6 A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6737 000015B9 A3F10B                  		mov	word [IO_SAVE],ax
  6738                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6739                                  		;mov	ax,31Eh ;  MSDOS 3.3
  6740 000015BC B81903                  		mov	ax,LODCOM1
  6741 000015BF 50                      		push	ax
  6742                                  
  6743 000015C0 CB                      		retf		; Far return
  6744                                  
  6745                                  ; ---------------------------------------------------------------------------
  6746                                  
  6747                                  ;****************************************************************
  6748                                  ;*
  6749                                  ;* ROUTINE:	CHCP - Change code page internal command
  6750                                  ;*		(added DOS 3.30 07/21/86)
  6751                                  ;*
  6752                                  ;* SYNTAX:	CHCP [xxx]
  6753                                  ;*		where xxx is a valid code page
  6754                                  ;*
  6755                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6756                                  ;*		6402H to set the code page to xxxx. If no parameters
  6757                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6758                                  ;*		to get global code page and display it to the user.
  6759                                  ;*
  6760                                  ;* INPUT:	command line at offset 81H
  6761                                  ;*
  6762                                  ;* OUTPUT:	none
  6763                                  ;*
  6764                                  ;****************************************************************
  6765                                  
  6766                                  ;NLSFUNC_installed equ  0FFh
  6767                                  set_global_cp	  equ   2
  6768                                  get_global_cp	  equ   1
  6769                                  
  6770                                  CHCP:
  6771                                  		; MSDOS 6.0
  6772                                  		;push	ds		;AN000; Get local ES
  6773                                  		;pop	es		;AN000;
  6774                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6775                                  
  6776                                  		;mov	di,offset trangroup:parse_chcp	
  6777                                  					;AN000; Get adderss of PARSE_CHCP
  6778                                  		;xor	cx,cx		;AC000; clear cx,dx
  6779                                  		;xor	dx,dx		;AC000;
  6780                                  		;call	parse_with_msg	;AC018; call parser
  6781                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6782                                  
  6783                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6784                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6785                                  ;setcp:
  6786                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6787                                  		;jne	cp_error	;AC018; yes - go issue message
  6788                                  
  6789                                  		;push	cx		;AN000; save positional count
  6790                                  		;mov	bx,offset trangroup:parse1_addr 
  6791                                  					;AN000; get number returned
  6792                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6793                                  		;mov	system_cpage,cx ;AN000; save user input number
  6794                                  		;pop	cx		;AC000; restore positional count
  6795                                  		;mov	di,offset trangroup:parse_chcp	
  6796                                  					;AN000; Get adderss of PARSE_CHCP
  6797                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6798                                  		;jnz	cp_error	;AC000; no - exit
  6799                                  ;okset:
  6800                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6801                                  		;mov	al,0		;AN000;
  6802                                  		;int	2fh		;AN000;
  6803                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6804                                  		;jz	got_NLS 	;AN000; Yes - continue
  6805                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6806                                  					;AN000; no - set up error message
  6807                                  		;jmp	short cp_error	;AN000; error exit
  6808                                  ;got_NLS:
  6809                                  
  6810                                  		; MSDOS 3.3
  6811 000015C1 BE8100                  		mov	si,81h
  6812 000015C4 E8B203                  		call	SCANOFF
  6813 000015C7 3C0D                    		cmp	al,0Dh ; CR
  6814 000015C9 7502                    		jnz	short SETCP
  6815 000015CB EB72                    		jmp	short GETCP
  6816                                  
  6817                                  		;nop
  6818                                  SETCP:
  6819 000015CD 31DB                    		xor	bx,bx
  6820 000015CF 89D9                    		mov	cx,bx
  6821 000015D1 89D8                    		mov	ax,bx
  6822                                  GET_CP_DIGIT:
  6823 000015D3 AC                      		lodsb
  6824 000015D4 3C30                    		cmp	al,'0'
  6825 000015D6 721C                    		jb	short CHRNOTNUMBER
  6826 000015D8 3C39                    		cmp	al,'9'
  6827 000015DA 7718                    		ja	short CHRNOTNUMBER
  6828 000015DC 2C30                    		sub	al,'0'
  6829 000015DE FEC1                    		inc	cl
  6830 000015E0 80F904                  		cmp	cl,4
  6831 000015E3 771B                    		ja	short CHCP_BADPARM
  6832 000015E5 89DA                    		mov	dx,bx
  6833 000015E7 D1E2                    		shl	dx,1
  6834 000015E9 D1E2                    		shl	dx,1
  6835 000015EB 01D3                    		add	bx,dx
  6836 000015ED D1E3                    		shl	bx,1
  6837 000015EF 01C3                    		add	bx,ax
  6838 000015F1 EBE0                    		jmp	short GET_CP_DIGIT
  6839                                  CP_NEXTCHR:
  6840 000015F3 AC                      		lodsb
  6841                                  CHRNOTNUMBER:
  6842 000015F4 3C20                    		cmp	al,' '		; SPACE
  6843 000015F6 74FB                    		jz	short CP_NEXTCHR
  6844 000015F8 3C09                    		cmp	al,9		; TAB
  6845 000015FA 74F7                    		jz	short CP_NEXTCHR
  6846 000015FC 3C0D                    		cmp	al,0Dh		; CR
  6847 000015FE 7406                    		jz	short SET_CP_TBL_NUM
  6848                                  CHCP_BADPARM:
  6849 00001600 BA[123A]                		mov	dx,BADPARMPTR
  6850 00001603 E91D06                  		jmp	CERROR
  6851                                  ;GOT_NLS:
  6852                                  SET_CP_TBL_NUM:
  6853                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6854 00001606 891E[FF3E]              		mov	word [SYSTEM_CPAGE],bx
  6855 0000160A B466                    		mov	ah,GETSETCDPG  ; 66h
  6856 0000160C B002                    		mov	al,set_global_cp ; 2
  6857 0000160E CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6858                                  				; BX = active code page
  6859                                  				; DX = system code page	(active	page at	boot time)
  6860 00001610 733D                    		jnc	short CHCP_RETURN
  6861                                  
  6862 00001612 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6863 00001615 7511                    		jnz	short CHCP_OTHER_ERROR
  6864                                  
  6865 00001617 B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6866 00001619 31DB                    		xor	bx,bx
  6867 0000161B CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6868                                  				; BX = version code (0000h for DOS 3.x)
  6869 0000161D 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6870 00001620 7417                    		jz	short NONE_SET
  6871 00001622 BA[E837]                		mov	dx,FNOTFOUNDPTR
  6872 00001625 E9FB05                  		jmp	CERROR
  6873                                  CHCP_OTHER_ERROR:			; end of p716
  6874 00001628 B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6875 0000162A 31DB                    		xor	bx,bx
  6876 0000162C CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6877                                  				; BX = version code (0000h for DOS 3.x)
  6878 0000162E 83F841                  		cmp	ax,65		;was it access denied?
  6879 00001631 7506                    		jnz	short NONE_SET	;no - assume all failed
  6880 00001633 BA[9839]                		mov	dx,CPNOTALLPTR	;set up message
  6881 00001636 E9EA05                  		jmp	CERROR		;AC000; error exit
  6882                                  NONE_SET:
  6883 00001639 BA[6539]                		mov	dx,CPNOTSETPTR	;set up message
  6884                                  CP_ERROR:
  6885 0000163C E9E405                  		jmp	CERROR		;exit
  6886                                  GETCP:
  6887 0000163F B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6888 00001641 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6889 00001643 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6890 00001645 891E[FF3E]              		mov	word [SYSTEM_CPAGE],bx ;get active cp for output
  6891 00001649 BA[B639]                		mov	dx,CPACTIVEPTR
  6892 0000164C E8741E                  		call	STD_PRINTF	;print it out
  6893                                  CHCP_RETURN:
  6894 0000164F C3                      		retn
  6895                                  
  6896                                  ; ---------------------------------------------------------------------------
  6897                                  
  6898                                  ; ****************************************************************
  6899                                  ; *
  6900                                  ; * ROUTINE:	 TRUENAME
  6901                                  ; *
  6902                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  6903                                  ; *		 Parses the command line. If a path is found, set
  6904                                  ; *		 SRCXNAME to path.  If only a drive letter is
  6905                                  ; *		 found, set SRCXNAME to the drive letter.  If
  6906                                  ; *		 no path is found, set the path of SRCXNAME to
  6907                                  ; *		 dot (.) for current directory.  Use the NAME
  6908                                  ; *		 TRANSLATE system call to get the real name and
  6909                                  ; *		 then display the real name.  If an error occurs
  6910                                  ; *		 issue an error message and transfer control to
  6911                                  ; *		 CERROR.
  6912                                  ; *
  6913                                  ; * INPUT:	 command line at offset 81H
  6914                                  ; *
  6915                                  ; * OUTPUT:	 none
  6916                                  ; *
  6917                                  ; ****************************************************************
  6918                                  
  6919                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  6920                                  ;
  6921                                  ;TRUENAME:					;AN000; TRUENAME entry point
  6922                                  ;	push	ds				;AN000; Get local ES
  6923                                  ;	pop	es				;AN000;
  6924                                  ;	mov	si,81H				;AN000; Get command line
  6925                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
  6926                                  ;	xor	cx,cx				;AN000; clear cx,dx
  6927                                  ;	xor	dx,dx				;AN000;
  6928                                  ;	call	parse_with_msg			;AC018; call parser
  6929                                  ;
  6930                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  6931                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  6932                                  ;	je	tn_eol				;AN000; yes - go process
  6933                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  6934                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  6935                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  6936                                  ;	je	tn_drive			;AN000; yes - go process
  6937                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  6938                                  ;
  6939                                  ;tn_eol: 					;AN000; no parameters on line
  6940                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  6941                                  ;	mov	al,dot_chr			;AN000;     for current dir
  6942                                  ;	stosw					;AN000; store in srcxname
  6943                                  ;	jmp	short tn_doit			;AN000; go do command
  6944                                  ;
  6945                                  ;tn_drive:					;AN000; a drive was entered
  6946                                  ;	push	si				;AN000; save position in line
  6947                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  6948                                  ;	lodsb					;AN000; get the drive number
  6949                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  6950                                  ;	stosb					;AN000; store it in srcxname
  6951                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  6952                                  ;	stosw					;AN000;    store in srcxname
  6953                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  6954                                  ;	stosb					;AN000;
  6955                                  ;	pop	si				;AN000; get line position back
  6956                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  6957                                  ;
  6958                                  ;tn_filespec:					;AN000; a filespec was entered
  6959                                  ;	push	si				;AN000; save position in line
  6960                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  6961                                  ;
  6962                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  6963                                  ;	lodsb					;AN000; get a char from buffer
  6964                                  ;	stosb					;AN000; store in srcxname
  6965                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  6966                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  6967                                  ;	pop	si				;AN000; get line position back
  6968                                  ;
  6969                                  ;tn_check_eol:					;AN000; make sure no extra parms
  6970                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  6971                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  6972                                  ;	je	tn_doit 			;AN000; Yes - do the command
  6973                                  ;
  6974                                  ;tn_parse_error: 				;AN000; A parse error occurred
  6975                                  ;	jmp	cerror				;AN000; Go to error routine
  6976                                  ;
  6977                                  ;tn_doit:					;AN000;
  6978                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  6979                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  6980                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  6981                                  ;	int	21h			;AN000;
  6982                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  6983                                  ;
  6984                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  6985                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  6986                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  6987                                  ;	jmp	cerror				;AN000; Go to error routine
  6988                                  ;
  6989                                  ;tn_print_xname: 				;AN000;
  6990                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  6991                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  6992                                  ;	invoke	crlf2				;AN000; print a crlf
  6993                                  ;	invoke	printf_crlf			;AN000; print it out
  6994                                  ;
  6995                                  ;	ret					;AN000;
  6996                                  ;
  6997                                  
  6998                                  ; ---------------------------------------------------------------------------
  6999                                  
  7000                                  _$EXIT:
  7001                                  		; MSDOS 3.3
  7002 00001650 8E06[6142]              		mov	es,[RESSEG]
  7003 00001654 26A18E0B                		mov	ax,word [es:PARENT]
  7004                                  		;mov	[es:16h],ax
  7005 00001658 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7006 0000165C 26A1900B                		mov	ax,word [es:OLDTERM]
  7007                                  		;mov	[es:0Ah],ax
  7008 00001660 26A30A00                		mov	[es:PDB.EXIT],ax
  7009 00001664 26A1920B                		mov	ax,word [es:OLDTERM+2]
  7010                                  		;mov	[es:0Ch],ax
  7011 00001668 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7012 0000166C 06                      		push	es
  7013 0000166D 8E06[7142]              		mov	es,[TRAN_TPA]
  7014 00001671 B449                    		mov	ah,DEALLOC ; 49h
  7015 00001673 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7016                                  				; ES = segment address of area to be freed
  7017 00001675 07                      		pop	es
  7018 00001676 B44C                    		mov	ah,EXIT ; 4Ch
  7019                                  		;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
  7020 00001678 26A0EC0B                		mov	al,byte [es:RETCODE]
  7021 0000167C CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7022                                  
  7023                                  ;;here:
  7024                                  ;;		jmp	short here
  7025                                  
  7026                                  		; MSDOS 6.0
  7027                                  		;push	ds			;AN000; save data segment
  7028                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7029                                  
  7030                                  		;assume	ds:resgroup		;AN000;
  7031                                  
  7032                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7033                                  		;jz	free_com		;AN045; no - free everything
  7034                                  
  7035                                  ;	We're a permanent command.
  7036                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7037                                  
  7038                                  		;cmp	[singlecom],-1		;M034
  7039                                  		;je	no_reset		;M034	;exit singlecom
  7040                                  
  7041                                  		;jmp	TCommand		;permanent command, recycle
  7042                                  
  7043                                  ;free_com:
  7044                                  		;mov	ax,(multdos shl 8 or message_2f)
  7045                                  						;AN060; reset parse message pointers
  7046                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7047                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7048                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7049                                  		;int	2fh			;AN000; go set it
  7050                                  ;no_reset:					;AN045;
  7051                                  		;pop	ds			;AN000; restore local data segment
  7052                                  
  7053                                  		;assume	ds:trangroup		;AN000;
  7054                                  ;
  7055                                  ;M040
  7056                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7057                                  ;this, restores user dir if flag is set and resets the flag.
  7058                                  ;
  7059                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7060                                  		;MOV	ES,[RESSEG]
  7061                                  
  7062                                  		;assume	es:resgroup
  7063                                  
  7064                                  		;MOV	AX,[PARENT]
  7065                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7066                                  		;MOV	AX,WORD PTR OldTerm
  7067                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7068                                  		;MOV	AX,WORD PTR OldTerm+2
  7069                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7070                                  
  7071                                  		;PUSH	ES
  7072                                  		;MOV	ES,[TRAN_TPA]
  7073                                  		;MOV	AH,DEALLOC
  7074                                  		;INT	21h			; Now running in "free" space
  7075                                  		;POP	ES
  7076                                  
  7077                                  		;MOV	AH,Exit
  7078                                  		;MOV	AL,BYTE PTR RetCode
  7079                                  		;INT	21h
  7080                                  
  7081                                  ; ---------------------------------------------------------------------------
  7082                                  
  7083                                  ; MSDOS 6.0
  7084                                  ; ****************************************************************
  7085                                  ; *
  7086                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7087                                  ; *
  7088                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7089                                  ; *		 If not end of line, set up to print parse
  7090                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7091                                  ; *		 EXPECTED!
  7092                                  ; *
  7093                                  ; * INPUT:	 DS:SI	  last output from parser
  7094                                  ; *		 ES:DI	  points to parse block
  7095                                  ; *		 CX	  last output from parser
  7096                                  ; *
  7097                                  ; * OUTPUT:	 AX	  parser return code
  7098                                  ; *
  7099                                  ; *		 if end of line found
  7100                                  ; *		     zero flag set
  7101                                  ; *		 else
  7102                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7103                                  ; *
  7104                                  ; ****************************************************************
  7105                                  
  7106                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7107                                  ;
  7108                                  ;parse_check_eol Proc near			;AN000;
  7109                                  ;
  7110                                  ;	xor	dx,dx				;AN000;
  7111                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7112                                  ;	invoke	cmd_parse			;AN000; call parser
  7113                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7114                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7115                                  ;
  7116                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7117                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7118                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7119                                  ;
  7120                                  ;ok_to_setup_pmsg:
  7121                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7122                                  ;
  7123                                  ;parse_good_eol:
  7124                                  ;	ret					;AN000;
  7125                                  ;
  7126                                  ;parse_check_eol endp				;AN000;
  7127                                  
  7128                                  ; ---------------------------------------------------------------------------
  7129                                  
  7130                                  ; MSDOS 6.0
  7131                                  ; ****************************************************************
  7132                                  ; *
  7133                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7134                                  ; *
  7135                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7136                                  ; *		 message is set up.
  7137                                  ; *
  7138                                  ; * INPUT:	 DS:SI	  last output from parser
  7139                                  ; *		 ES:DI	  points to parse block
  7140                                  ; *		 CX	  last output from parser
  7141                                  ; *
  7142                                  ; * OUTPUT:	 AX	  parser return code
  7143                                  ; *
  7144                                  ; *		 if no error
  7145                                  ; *		     outputs from parser
  7146                                  ; *		 else
  7147                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7148                                  ; *		     error message set up for STD_PRINTF
  7149                                  ; *
  7150                                  ; ****************************************************************
  7151                                  
  7152                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7153                                  ;
  7154                                  ;parse_with_msg	Proc near			;AN018;
  7155                                  ;
  7156                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7157                                  ;	invoke	cmd_parse			;AN018; call parser
  7158                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7159                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7160                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7161                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7162                                  ;
  7163                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7164                                  ;
  7165                                  ;parse_msg_good:
  7166                                  ;	ret					;AN018;
  7167                                  ;
  7168                                  ;parse_with_msg endp				;AN018;
  7169                                  
  7170                                  ; ---------------------------------------------------------------------------
  7171                                  
  7172                                  ; MSDOS 6.0
  7173                                  ; ****************************************************************
  7174                                  ; *
  7175                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7176                                  ; *
  7177                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7178                                  ; *		 message is set up.
  7179                                  ; *
  7180                                  ; * INPUT:	 AX	     Parse error number
  7181                                  ; *		 SI	     Set to past last parameter
  7182                                  ; *		 Parse_last  Set to start of last parameter
  7183                                  ; *
  7184                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7185                                  ; *		 error message set up for STD_PRINTF
  7186                                  ; *
  7187                                  ; ****************************************************************
  7188                                  
  7189                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7190                                  ;
  7191                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7192                                  ;
  7193                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7194                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7195                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7196                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7197                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7198                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7199                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7200                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7201                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7202                                  ;
  7203                                  ;setup_parse_msg_ret:
  7204                                  ;	inc	si				;AN018; make sure zero flag not set
  7205                                  ;
  7206                                  ;	ret					;AC018;
  7207                                  ;
  7208                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7209                                  
  7210                                  ;============================================================================
  7211                                  ; TENV.ASM, MSDOS 6.0, 1991
  7212                                  ;============================================================================
  7213                                  ; 08/10/2018 - Retro DOS v3.0
  7214                                  
  7215                                  ; TITLE	Part6 COMMAND Transient routines.
  7216                                  
  7217                                  ;	Environment utilities and misc. routines
  7218                                  
  7219                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7220                                  
  7221                                  ; ---------------------------------------------------------------------------
  7222                                  
  7223                                  ADD_PROMPT:
  7224 0000167E E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7225 00001681 E87801                  		call	SCAN_DOUBLE_NULL
  7226                                  
  7227                                  ADD_PROMPT2:
  7228 00001684 56                      		push	si
  7229 00001685 E86601                  		call	GETARG
  7230 00001688 5E                      		pop	si
  7231 00001689 7501                    		jnz	short ADD_PROMPT3
  7232                                  ADD_PROMPT_RETN:
  7233 0000168B C3                      		retn
  7234                                  ADD_PROMPT3:				; Pre scan for arguments
  7235 0000168C E84E01                  		call	MOVE_NAME	 ;Move in name
  7236 0000168F E85C01                  		call	GETARG
  7237 00001692 56                      		push	si
  7238 00001693 EB4F                    		jmp	short ADD_NAME
  7239                                  
  7240                                  ;break	The SET command
  7241                                  
  7242                                  ; Input: DS:SI points to a CR terminated string
  7243                                  ; Output: carry flag is set if no room
  7244                                  ;	  otherwise name is added to environment
  7245                                  
  7246                                  DISP_ENVJ:
  7247 00001695 E9B100                  		jmp	DISP_ENV
  7248                                  
  7249                                  ADD_NAME_TO_ENVIRONMENT:
  7250 00001698 E85301                  		call	GETARG
  7251 0000169B 74F8                    		jz	short DISP_ENVJ
  7252                                  
  7253                                  ; check if line contains exactly one equals sign
  7254                                  
  7255 0000169D 31DB                    		xor	bx,bx		; = count is 0
  7256 0000169F 56                      		push	si		; Save pointer to beginning of line
  7257                                  EQLP:
  7258 000016A0 AC                      		lodsb			; Get a char
  7259 000016A1 3C0D                    		cmp	al,13		; IF CR we're all done
  7260 000016A3 740F                    		jz	short QUEQ	
  7261 000016A5 3C3D                    		cmp	al,'='		; Look for = sign	
  7262 000016A7 75F7                    		jnz	short EQLP	; not there, get next char
  7263 000016A9 FEC3                    		inc	bl		; Otherwise increment EQ count
  7264 000016AB 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7265 000016AE 75F0                    		jnz	short EQLP
  7266 000016B0 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7267 000016B2 EBEC                    		jmp	short EQLP	; And look for more
  7268                                  QUEQ:
  7269 000016B4 5E                      		pop	si		; Restore beginning of line
  7270 000016B5 FECB                    		dec	bl		; Zero flag means only one EQ
  7271 000016B7 7406                    		jz	short ONEQ	; Good line
  7272 000016B9 BA[683C]                		mov	dx,SYNTMESPTR
  7273 000016BC E96405                  		jmp	CERROR
  7274                                  ONEQ:
  7275 000016BF 53                      		push	bx
  7276 000016C0 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7277 000016C3 5B                      		pop	bx
  7278 000016C4 FECF                    		dec	bh
  7279 000016C6 74C3                    		jz	short ADD_PROMPT_RETN
  7280 000016C8 E83101                  		call	SCAN_DOUBLE_NULL
  7281 000016CB 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7282 000016CD E80D01                  		call	MOVE_NAME
  7283 000016D0 56                      		push	si
  7284 000016D1 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7285                                  					;  env var name
  7286                                  		
  7287                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7288                                  ; necessary in the resident for re-reading the transient. Let's look for
  7289                                  ; COMSPEC=
  7290                                  
  7291                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7292 000016D3 BE[093C]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7293 000016D6 B90400                  		mov	cx,4
  7294 000016D9 F3A7                    		repe cmpsw
  7295 000016DB 7505                    		jnz	short NOT_COMSPEC
  7296                                  					; Zero set => exact match
  7297                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7298 000016DD C606[9845]01            		mov	byte [COMSPEC_FLAG],1
  7299                                  NOT_COMSPEC:
  7300 000016E2 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7301                                  ADD_NAME:
  7302 000016E4 5E                      		pop	si		; Add the value of the new env var
  7303 000016E5 56                      		push	si		;  to the environment.
  7304                                  ADD_NAME1:
  7305 000016E6 AC                      		lodsb
  7306 000016E7 3C0D                    		cmp	al,13
  7307 000016E9 7405                    		jz	short ADD_NAME_RET
  7308 000016EB E84401                  		call	STORE_CHAR
  7309 000016EE EBF6                    		jmp	short ADD_NAME1
  7310                                  ADD_NAME_RET:
  7311 000016F0 5E                      		pop	si
  7312 000016F1 803E[9845]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7313                                  ADD_NAME_JZ_RET:
  7314 000016F6 7493                    		jz	short ADD_PROMPT_RETN 
  7315                                  					;  copy the value into the
  7316                                  					;  comspec var in the resident
  7317                                  
  7318                                  ; We have changed the COMSPEC variable. We need to update the resident
  7319                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7320                                  
  7321 000016F8 E87E02                  		call	SCANOFF
  7322 000016FB 8E06[6142]              		mov	es,[RESSEG]	;  comspec var in the resident
  7323                                  
  7324                                  ; Make sure that the printer knows where the beginning of the string is
  7325                                  
  7326 000016FF BF9B0B                  		mov	di,COMSPEC
  7327 00001702 89FB                    		mov	bx,di
  7328                                  
  7329                                  ; Generate drive letter for display
  7330                                  
  7331 00001704 31C0                    		xor	ax,ax		;g assume no drive first
  7332 00001706 26A2E60B                		mov	byte [es:COMDRV],al ;g
  7333 0000170A 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7334 0000170E 7512                    		jnz	short _GOTDRIVE
  7335 00001710 8A04                    		mov	al,[si]		; get his specified drive
  7336                                  		;call	UPCONV
  7337 00001712 E80901                  		call	UPCONV_MAPCALL	; convert to uppercase
  7338 00001715 2C41                    		sub	al,'A'		; convert to 0-based
  7339 00001717 83C702                  		add	di,2
  7340 0000171A FEC0                    		inc	al		; convert to 1-based number
  7341 0000171C 26A2E60B                		mov	byte [es:COMDRV],al
  7342                                  
  7343                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7344                                  ; done here..
  7345                                  		;add	al,40h
  7346 00001720 0440                    		add	al,'A'-1
  7347                                  _GOTDRIVE:
  7348                                  		;mov	word [es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7349 00001722 26893EDB0B              		mov	word [es:PUTBACKSUBSTPTR],di
  7350                                  					;g point to beginning of name after drive
  7351                                  		;mov	byte [es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7352 00001727 26A2230A                		mov	byte [es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7353                                  
  7354                                  ; Copy chars until delim      	
  7355                                  
  7356 0000172B 89DF                    		mov	di,bx
  7357                                  COPY_COMSPEC:
  7358 0000172D AC                      		lodsb
  7359 0000172E E85002                  		call	DELIM
  7360 00001731 7407                    		jz	short COPYDONE
  7361 00001733 3C0D                    		cmp	al,13
  7362 00001735 7403                    		jz	short COPYDONE
  7363 00001737 AA                      		stosb
  7364 00001738 EBF3                    		jmp	short COPY_COMSPEC
  7365                                  COPYDONE:
  7366 0000173A 30C0                    		xor	al,al		; Null terminate the string and quit
  7367 0000173C AA                      		stosb
  7368 0000173D C606[9845]00            		mov	byte [COMSPEC_FLAG],0
  7369 00001742 4F                      		dec	di
  7370 00001743 26893EDD0B              		mov	word [es:COMSPEC_END],di
  7371 00001748 C3                      		retn
  7372                                  DISP_ENV:
  7373 00001749 8E1E[6142]              		mov	ds,[RESSEG]
  7374 0000174D 8E1E050D                		mov	ds,word [ENVIRSEG]
  7375                                  		; assume ds:nothing
  7376 00001751 31F6                    		xor	si,si
  7377                                  PENVLP:
  7378 00001753 803C00                  		cmp	byte [si],0
  7379 00001756 749E                    		jz	short ADD_NAME_JZ_RET
  7380 00001758 BF[B843]                		mov	di,ARG_BUF
  7381                                  PENVLP2:
  7382 0000175B AC                      		lodsb
  7383 0000175C AA                      		stosb
  7384 0000175D 08C0                    		or	al,al
  7385 0000175F 75FA                    		jnz	short PENVLP2
  7386 00001761 BA[1337]                		mov	dx,ARG_BUF_PTR
  7387 00001764 1E                      		push	ds
  7388 00001765 06                      		push	es
  7389 00001766 1F                      		pop	ds
  7390                                  		; assume ds:nothing
  7391 00001767 E8491D                  		call	PRINTF_CRLF
  7392 0000176A 1F                      		pop	ds
  7393 0000176B EBE6                    		jmp	short PENVLP
  7394                                  
  7395                                  ; =============== S U B	R O U T	I N E =======================================
  7396                                  
  7397                                  DELETE_PATH:
  7398 0000176D BE[FD3B]                		mov	si,PATH_TEXT ; "PATH="
  7399 00001770 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7400                                  
  7401                                  ; =============== S U B	R O U T	I N E =======================================
  7402                                  
  7403                                  DELETE_PROMPT:
  7404 00001772 BE[023C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7405                                  
  7406                                  ; ---------------------------------------------------------------------------
  7407                                  
  7408                                  DELETE_NAME_IN_ENVIRONMENT:
  7409                                  
  7410                                  ; Input: DS:SI points to a "=" terminated string
  7411                                  ; Output: carry flag is set if name not found
  7412                                  ;	  otherwise name is deleted
  7413                                  
  7414 00001775 56                      		push	si
  7415 00001776 1E                      		push	ds
  7416 00001777 E82400                  		call	FIND		; ES:DI points to name
  7417 0000177A 7210                    		jc	short DEL1
  7418 0000177C 89FE                    		mov	si,di		; Save it
  7419 0000177E E89500                  		call	SCASB2		; Scan for the nul
  7420 00001781 87F7                    		xchg	si,di
  7421                                  ;SR;
  7422                                  ; If we have only one env string, then the double null is lost when the last
  7423                                  ;string is deleted and we have an invalid empty environment with only a 
  7424                                  ;single null. To avoid this, we will look for the double null case and then
  7425                                  ;move an extra null char.
  7426                                  ; Bugbug: The only possible problem is that the last pathstring 
  7427                                  ;will be followed by a triple null. Is this really a problem?
  7428                                  
  7429                                  		; MSDOS 6.0
  7430                                  		;cmp	byte ptr es:[si],0 ;null char?
  7431                                  		;jnz	not_dnull	   ;no, we are at a double null
  7432                                  		;dec	si		   ;point at the double null
  7433                                  ;not_dnull:
  7434                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7435 00001783 E8F400                  		call	GETENVSIZ
  7436 00001786 29F1                    		sub	cx,si
  7437 00001788 06                      		push	es
  7438 00001789 1F                      		pop	ds		; ES:DI points to name
  7439                                  					; DS:SI points to next name
  7440 0000178A F3A4                    		rep movsb
  7441                                  DEL1:
  7442 0000178C 1F                      		pop	ds
  7443 0000178D 5E                      		pop	si
  7444                                  FIND_RETN:
  7445 0000178E C3                      		retn
  7446                                  
  7447                                  ; =============== S U B	R O U T	I N E =======================================
  7448                                  
  7449                                  FIND_PATH:
  7450 0000178F BE[FD3B]                		mov	si,PATH_TEXT ; "PATH="
  7451 00001792 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7452                                  
  7453                                  
  7454                                  ; =============== S U B	R O U T	I N E =======================================
  7455                                  
  7456                                  FIND_PROMPT:
  7457 00001794 BE[023C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7458                                  
  7459                                  ; ---------------------------------------------------------------------------
  7460                                  
  7461                                  FIND_NAME_IN_ENVIRONMENT:
  7462                                  
  7463                                  ; Input: DS:SI points to a "=" terminated string
  7464                                  ; Output: ES:DI points to the arguments in the environment
  7465                                  ;	  zero is set if name not found
  7466                                  ;	  carry flag is set if name not valid format
  7467                                  
  7468 00001797 E80400                  		call	FIND		; Find the name
  7469 0000179A 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7470 0000179C EB74                    		jmp	short SCASB1	; Scan for = sign
  7471                                  
  7472                                  ; ---------------------------------------------------------------------------
  7473                                  		;nop
  7474                                  
  7475                                  ; =============== S U B	R O U T	I N E =======================================
  7476                                  
  7477                                  ; On return of FIND1, ES:DI points to beginning of name
  7478                                  
  7479                                  FIND:
  7480 0000179E FC                      		cld
  7481 0000179F E82D00                  		call	COUNT0		; CX = Length of name
  7482 000017A2 8E06[6142]              		mov	es,[RESSEG]
  7483                                  		; assume es:RESGROUP
  7484 000017A6 268E06050D              		mov	es,word [es:ENVIRSEG]
  7485                                  		; assume es:NOTHING
  7486 000017AB 31FF                    		xor	di,di
  7487                                  FIND1:	
  7488 000017AD 51                      		push	cx
  7489 000017AE 56                      		push	si
  7490 000017AF 57                      		push	di
  7491                                  FIND11:
  7492 000017B0 AC                      		lodsb
  7493                                  		;call	UPCONV
  7494 000017B1 E86A00                  		call	UPCONV_MAPCALL
  7495 000017B4 47                      		inc	di
  7496 000017B5 263A45FF                		cmp	al,[es:di-1]
  7497 000017B9 7502                    		jnz	short FIND12
  7498 000017BB E2F3                    		loop	FIND11
  7499                                  FIND12:
  7500 000017BD 5F                      		pop	di
  7501 000017BE 5E                      		pop	si
  7502 000017BF 59                      		pop	cx
  7503 000017C0 74CC                    		jz	short FIND_RETN
  7504 000017C2 51                      		push	cx
  7505 000017C3 E85000                  		call	SCASB2		; Scan for a nul
  7506 000017C6 59                      		pop	cx
  7507 000017C7 26803D00                		cmp	byte [es:di],0
  7508 000017CB 75E0                    		jnz	short FIND1
  7509 000017CD F9                      		stc			; Indicate not found
  7510 000017CE C3                      		retn
  7511                                  
  7512                                  ; =============== S U B	R O U T	I N E =======================================
  7513                                  
  7514                                  COUNT0:
  7515 000017CF 1E                      		push	ds
  7516 000017D0 07                      		pop	es
  7517                                  		; assume es:nothing
  7518 000017D1 89F7                    		mov	di,si
  7519                                  ;COUNT1:
  7520 000017D3 57                      		push	di		; Count number of chars until "="
  7521 000017D4 E83B00                  		call	SCASB1
  7522                                  		; 24/02/2023
  7523                                  		;jmp	short COUNTX
  7524                                  ;COUNT2:
  7525                                  ;		push	di		; Count number of chars until nul
  7526                                  ;		call	SCASB2
  7527                                  ;COUNTX:
  7528 000017D7 59                      		pop	cx
  7529 000017D8 29CF                    		sub	di,cx
  7530 000017DA 87F9                    		xchg	di,cx
  7531                                  MOVE_NAME_RETN:
  7532 000017DC C3                      		retn
  7533                                  
  7534                                  ; =============== S U B	R O U T	I N E =======================================
  7535                                  
  7536                                  MOVE_NAME:
  7537 000017DD 803C0D                  		cmp	byte [si],13
  7538 000017E0 74FA                    		jz	short MOVE_NAME_RETN
  7539 000017E2 AC                      		lodsb
  7540                                  		;call	UPCONV
  7541 000017E3 E83800                  		call	UPCONV_MAPCALL
  7542 000017E6 E84900                  		call	STORE_CHAR
  7543 000017E9 3C3D                    		cmp	al,'='
  7544 000017EB 75F0                    		jnz	short MOVE_NAME
  7545                                  GETARG_RETN:
  7546 000017ED C3                      		retn
  7547                                  
  7548                                  ; =============== S U B	R O U T	I N E =======================================
  7549                                  
  7550                                  GETARG:
  7551 000017EE BE8000                  		mov	si,80h
  7552 000017F1 AC                      		lodsb
  7553 000017F2 08C0                    		or	al,al
  7554 000017F4 74F7                    		jz	short GETARG_RETN
  7555 000017F6 E88001                  		call	SCANOFF
  7556 000017F9 3C0D                    		cmp	al,13
  7557                                  SDN_RETN:
  7558 000017FB C3                      		retn
  7559                                  
  7560                                  ; =============== S U B	R O U T	I N E =======================================
  7561                                  
  7562                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7563                                  ; there is NO double NULL, merely a string that is empty.
  7564                                  
  7565                                  SCAN_DOUBLE_NULL:
  7566 000017FC 8E06[6142]              		mov	es,[RESSEG]
  7567                                  		; ASSUME ES:RESGROUP
  7568 00001800 268E06050D              		mov	es,word [es:ENVIRSEG]
  7569                                  		; ASSUME ES:NOTHING
  7570 00001805 31FF                    		xor	di,di
  7571                                  
  7572                                  ; Top cycle-point. If the string here is empty, then we are done
  7573                                  
  7574                                  SDN1:
  7575 00001807 26803D00                		cmp	byte [es:di],0	; nul string?
  7576 0000180B 74EE                    		jz	short SDN_RETN	; yep, all done
  7577 0000180D E80600                  		call	SCASB2
  7578 00001810 EBF5                    		jmp	short SDN1
  7579                                  
  7580                                  ; =============== S U B	R O U T	I N E =======================================
  7581                                  
  7582                                  SCASB1:
  7583 00001812 B03D                    		mov	al,'='		; Scan for an =
  7584 00001814 EB02                    		jmp	short SCASBX
  7585                                  
  7586                                  ; =============== S U B	R O U T	I N E =======================================
  7587                                  
  7588                                  SCASB2:
  7589 00001816 30C0                    		xor	al,al		; Scan for a nul
  7590                                  
  7591                                  ; ---------------------------------------------------------------------------
  7592                                  
  7593                                  SCASBX:
  7594 00001818 B90001                  		mov	cx,256
  7595 0000181B F2AE                    		repne scasb
  7596 0000181D C3                      		retn
  7597                                  
  7598                                  ; =============== S U B	R O U T	I N E =======================================
  7599                                  
  7600                                  ; MSDOS 6.0
  7601                                  
  7602                                  ; ****************************************************************
  7603                                  ; *
  7604                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7605                                  ; *
  7606                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7607                                  ; *		 the character in AL from the file upper case table
  7608                                  ; *		 in DOS if character if above  ascii 128, else
  7609                                  ; *		 subtracts 20H if between "a" and "z".
  7610                                  ; *
  7611                                  ; * INPUT:	 AL	      char to be upper cased
  7612                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7613                                  ; *
  7614                                  ; * OUTPUT:	 AL	      upper cased character
  7615                                  ; *
  7616                                  ; ****************************************************************
  7617                                  
  7618                                  ;assume	ds:trangroup			;AN000;
  7619                                  ;
  7620                                  ;upconv	proc	near			;AN000;
  7621                                  ;
  7622                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7623                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7624                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7625                                  ;	push	ds			;AN000;
  7626                                  ;	push	bx			;AN000;
  7627                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7628                                  ;assume	ds:resgroup			;AN000;
  7629                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7630                                  ;	add	bx,2			;AN000;  skip over first word
  7631                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7632                                  ;	pop	bx			;AN000;
  7633                                  ;	pop	ds			;AN000;
  7634                                  ;assume	ds:trangroup			;AN000;
  7635                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7636                                  ;
  7637                                  ;oth_fucase:				;AN000;
  7638                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7639                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7640                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7641                                  ;	ja	upconv_end		;AC000;
  7642                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7643                                  ;
  7644                                  ;upconv_end:				;AN000;
  7645                                  ;	ret
  7646                                  ;
  7647                                  ;upconv	endp				;AN000;
  7648                                  
  7649                                  ; ---------------------------------------------------------------------------
  7650                                  
  7651                                  ; MSDOS 3.3
  7652                                  
  7653                                  UPCONV_MAPCALL:
  7654                                  					; If between "a" and "z"
  7655 0000181E 3A06[F23E]              		cmp	al,[small_a]
  7656 00001822 7208                    		jb	short UPCONV_END
  7657 00001824 3A06[F33E]              		cmp	al,[small_z]
  7658 00001828 7702                    		ja	short UPCONV_END
  7659 0000182A 2C20                    		sub	al,20h		; Change lower-case to upper
  7660                                  UPCONV_END:
  7661 0000182C 2EFF1E[FA4C]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7662                                  					  ; 	  for (current) country
  7663 00001831 C3                      		retn
  7664                                  
  7665                                  ; =============== S U B	R O U T	I N E =======================================
  7666                                  
  7667                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7668                                  
  7669                                  STORE_CHAR:
  7670 00001832 51                      		push	cx
  7671 00001833 53                      		push	bx
  7672                                  
  7673                                  		; 16/10/2018
  7674                                  		; MSDOS 6.0
  7675                                  		;PUSH	ES		;AN056;*
  7676                                  		;PUSH	DS		;AN056; Save local DS
  7677                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7678                                  		;;ASSUME DS:RESGROUP	;AN056;
  7679                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7680                                  		;; ASSUME ES:NOTHING	;AN056;
  7681                                  		;POP	DS		;AN056; Get local segment back
  7682                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7683                                  
  7684                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7685 00001834 E84300                  		call	GETENVSIZ
  7686 00001837 89CB                    		mov	bx,cx		; Save room for double nul	
  7687 00001839 83EB02                  		sub	bx,2
  7688 0000183C 39DF                    		cmp	di,bx
  7689 0000183E 7231                    		jb	short STORE1
  7690                                  
  7691 00001840 50                      		push	ax
  7692 00001841 51                      		push	cx
  7693 00001842 53                      		push	bx		; Save Size of environment
  7694 00001843 E81AEE                  		call	FREE_TPA
  7695 00001846 5B                      		pop	bx
  7696 00001847 83C302                  		add	bx,2		; Recover true environment size
  7697                                  
  7698 0000184A 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7699 0000184E 7203                    		jb	short ENVSIZ_OK
  7700                                  BAD_ENV_SIZE:				;AN056;
  7701 00001850 F9                      		stc
  7702 00001851 EB09                    		jmp	short ENVNOSET
  7703                                  
  7704                                  		;nop
  7705                                  ENVSIZ_OK:
  7706 00001853 B104                    		mov	cl,4
  7707 00001855 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7708 00001857 43                      		inc	bx
  7709                                  
  7710                                  		; MSDOS 6.0
  7711                                  		;MOV	CX,ES		;AN056; Get environment segment
  7712                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7713                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7714                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7715                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7716                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7717                                  
  7718                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7719 00001858 B44A                    		mov	ah,SETBLOCK ; 4Ah
  7720 0000185A CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7721                                  				; ES = segment address of block	to change
  7722                                  				; BX = new size	in paragraphs
  7723                                  ENVNOSET:
  7724 0000185C 9C                      		pushf
  7725 0000185D 06                      		push	es
  7726 0000185E 8E06[6142]              		mov	es,[RESSEG]
  7727                                  		;ASSUME ES:RESGROUP
  7728 00001862 E80BEE                  		call	ALLOC_TPA
  7729 00001865 07                      		pop	es
  7730 00001866 9D                      		popf
  7731 00001867 59                      		pop	cx
  7732 00001868 58                      		pop	ax
  7733                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7734 00001869 7306                    		jnc	short STORE1
  7735 0000186B BA[4638]                		mov	dx,ENVERRPTR
  7736 0000186E E9B203                  		jmp	CERROR
  7737                                  
  7738                                  STORE1:	
  7739 00001871 AA                      		stosb
  7740 00001872 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7741                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7742 00001877 5B                      		pop	bx
  7743 00001878 59                      		pop	cx
  7744 00001879 C3                      		retn
  7745                                  
  7746                                  ; =============== S U B	R O U T	I N E =======================================
  7747                                  
  7748                                  GETENVSIZ:
  7749                                  
  7750                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7751                                  ;ES has environment segment
  7752                                  ;Size returned in CX, all other registers preserved
  7753                                  
  7754 0000187A 06                      		push	es
  7755 0000187B 50                      		push	ax
  7756 0000187C 8CC0                    		mov	ax,es
  7757 0000187E 48                      		dec	ax	;Point at arena	
  7758 0000187F 8EC0                    		mov	es,ax
  7759 00001881 26A10300                		mov	ax,word [es:ARENA.size]
  7760 00001885 B104                    		mov	cl,4
  7761 00001887 D3E0                    		shl	ax,cl	;Convert to bytes
  7762 00001889 89C1                    		mov	cx,ax
  7763 0000188B 58                      		pop	ax
  7764 0000188C 07                      		pop	es
  7765                                  GETENVSIZ_RETN:
  7766 0000188D C3                      		retn
  7767                                  
  7768                                  ; =============== S U B	R O U T	I N E =======================================
  7769                                  
  7770                                  RESTUDIR1:
  7771 0000188E 1E                      		push	ds
  7772 0000188F 8E1E[6142]              		mov	ds,[RESSEG]
  7773                                  		;ASSUME	DS:RESGROUP
  7774 00001893 803EF30B00              		cmp	byte [RESTDIR],0
  7775 00001898 1F                      		pop	ds
  7776                                  		;ASSUME	DS:TRANGROUP
  7777 00001899 74F2                    		jz	short GETENVSIZ_RETN
  7778                                  
  7779                                  ; =============== S U B	R O U T	I N E =======================================
  7780                                  
  7781                                  RESTUDIR:
  7782 0000189B BA[4341]                		mov	dx,USERDIR1
  7783 0000189E B43B                    		mov	ah,CHDIR ; 3Bh
  7784 000018A0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7785                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7786 000018A2 30C0                    		xor	al,al
  7787 000018A4 E85F06                  		call	SETREST
  7788 000018A7 C3                      		retn
  7789                                  
  7790                                  ;============================================================================
  7791                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7792                                  ;============================================================================
  7793                                  ; 07/10/2018 - Retro DOS v3.0
  7794                                  
  7795                                  ; TITLE	Part6 COMMAND Transient routines.
  7796                                  
  7797                                  ;	Environment utilities and misc. routines
  7798                                  
  7799                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7800                                  
  7801                                  ; ---------------------------------------------------------------------------
  7802                                  
  7803                                  ; ****************************************************************
  7804                                  ; *
  7805                                  ; * ROUTINE:	 $CHDIR
  7806                                  ; *
  7807                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7808                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7809                                  ; *		 letter is found, get and display the current dir
  7810                                  ; *		 of the specified drive. If nothing is found, get
  7811                                  ; *		 and display the current dir of the default drive.
  7812                                  ; *
  7813                                  ; * INPUT:	 command line at offset 81H
  7814                                  ; *
  7815                                  ; * OUTPUT:	 none
  7816                                  ; *
  7817                                  ; ****************************************************************
  7818                                  
  7819                                  _$CHDIR:
  7820                                  		; MSDOS 6.0
  7821                                  		;mov	si,81H
  7822                                  		;mov	di,offset trangroup:parse_chdir 
  7823                                  		;			;AN000; Get address of PARSE_CHDIR
  7824                                  		;xor	cx,cx		;AN000; clear cx,dx
  7825                                  		;xor	dx,dx		;AN000;
  7826                                  		;invoke	parse_with_msg	;AC018; call parser
  7827                                  
  7828                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7829                                  		;jz	bwdJ		; No args
  7830                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7831                                  		;jnz	ChDirErr	;AC018; yes - exit
  7832                                  
  7833                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7834                                  		;jnz	REALCD		; no
  7835                                  ;;
  7836                                  ;; D: was found. See if there is anything more.
  7837                                  ;;
  7838                                  		;mov	di,offset trangroup:parse_chdir 
  7839                                  					;AC000; get address of parse_chdir
  7840                                  		;xor	dx,dx		;AC000;
  7841                                  		;invoke	parse_check_eol ;AC000; call parser
  7842                                  		;jnz	ChDirErr	;AC000;
  7843                                  	;bwdJ:
  7844                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7845                                  		;call	crlf2
  7846                                  		;return
  7847                                  
  7848                                  		; MSDOS 3.3
  7849 000018A8 A1[7842]                		mov	ax,[COMSW]
  7850 000018AB 0B06[7E42]              		or	ax,[ALLSWITCH]
  7851 000018AF BA[123A]                		mov	dx,BADPARMPTR
  7852 000018B2 7533                    		jnz	short CHDIR_ERR
  7853 000018B4 BE8100                  		mov	si,81h
  7854 000018B7 E8BF00                  		call	SCANOFF
  7855 000018BA 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7856 000018BC 740F                    		je	short BWDJ	; No args
  7857 000018BE 46                      		inc	si
  7858 000018BF AC                      		lodsb
  7859 000018C0 3C3A                    		cmp	al,':'
  7860 000018C2 7510                    		jne	short REALCD
  7861 000018C4 56                      		push	si
  7862 000018C5 E8B100                  		call	SCANOFF
  7863 000018C8 5E                      		pop	si
  7864 000018C9 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7865 000018CB 7507                    		jne	short REALCD	; no
  7866                                  BWDJ:
  7867 000018CD E873FB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7868 000018D0 E89900                  		call	CRLF2
  7869                                  CHDIR_RETN:
  7870 000018D3 C3                      		retn
  7871                                  
  7872                                  		; MSDOS 6.0
  7873                                  ;REALCD:
  7874                                  		;push	si		;AN000; save position in line
  7875                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7876                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7877                                  		;pop	si		;AN000; restore position in line
  7878                                  		;mov	di,offset trangroup:parse_chdir 
  7879                                  		;			;AC000; get address of parse_chdir
  7880                                  		;xor	dx,dx		;AC000;
  7881                                  		;invoke	parse_check_eol ;AC000; call parser
  7882                                  		;jnz	ChDirErr	;AC000;
  7883                                  		;
  7884                                  		;invoke	SETPATH
  7885                                  		;TEST	[DESTINFO],2
  7886                                  		;JNZ	BadChdir
  7887                                  		;MOV	AH,CHDIR
  7888                                  		;INT	21h
  7889                                  		;retnc
  7890                                  		;
  7891                                  		;invoke	get_ext_error_number
  7892                                  		;			;AN022; get the extended error
  7893                                  		;cmp	ax,error_path_not_found
  7894                                  		;			;AN022; see if path not found
  7895                                  		;jz	BadChDir	;AN022; yes - issue old message
  7896                                  ;;SR;
  7897                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  7898                                  ;;but is not a directory. The extended error returns "Access denied" which
  7899                                  ;;is kind of confusing. Issue the old message if access denied error is 
  7900                                  ;;returned
  7901                                  ;;
  7902                                  		;cmp	ax,error_access_denied
  7903                                  		;jz	BadChDir
  7904                                  		;
  7905                                  		;call	Set_Ext_Error_Subst ;AN022;
  7906                                  		;jmp	short  chdirerr ;AN022;
  7907                                  ;BadChDir:
  7908                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  7909                                  ;ChDirErr:
  7910                                  		;invoke	Std_Eprintf
  7911                                  		;return
  7912                                  
  7913                                  		; MSDOS 3.3
  7914                                  REALCD:
  7915 000018D4 E89A04                  		call	SETPATH
  7916 000018D7 F606[6044]02            		test	byte [DESTINFO],2
  7917 000018DC 7506                    		jnz	short BADCHDIR
  7918 000018DE B43B                    		mov	ah,CHDIR ; 3Bh
  7919 000018E0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7920                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7921 000018E2 73EF                    		jnc	short CHDIR_RETN
  7922                                  BADCHDIR:
  7923 000018E4 BA[663B]                		mov	dx,BADCDPTR
  7924                                  CHDIR_ERR:
  7925 000018E7 E8D01B                  		call	STD_EPRINTF
  7926                                  MKDIR_RETN:
  7927 000018EA C3                      		retn
  7928                                  
  7929                                  ; ---------------------------------------------------------------------------
  7930                                  
  7931                                  _$MKDIR:
  7932                                  		; MSDOS 6.0
  7933                                  		;CALL	SETRMMK
  7934                                  		;JC	MkDirErr
  7935                                  		;MOV	AH,MKDIR
  7936                                  		;INT	21h
  7937                                  		;retnc
  7938                                  
  7939                                  		;invoke	get_ext_error_number	
  7940                                  		;			;AN022; get the extended error
  7941                                  		;cmp	ax,error_path_not_found 
  7942                                  		;			;AN022; see if path not found
  7943                                  		;jz	MD_other_err	;AN022; yes - issue old message
  7944                                  		;cmp	ax,error_access_denied
  7945                                  		;			;AN022; access denied?
  7946                                  		;jz	badmderr	;AN022; yes - see if file exists
  7947                                  		
  7948                                  		;call	Set_Ext_Error_Subst ;AN022;
  7949                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  7950                                  ;BADMDERR:
  7951                                  		;mov	dx,offset trangroup:srcxname	
  7952                                  		;			;AN006; Set Disk transfer address
  7953                                  		;mov	ah,Set_DMA	;AN006;
  7954                                  		;int	21h		;AN006;
  7955                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  7956                                  		;mov	cx,attr_directory ;AN006;   search for directory
  7957                                  		;INT	21h		;AN006;
  7958                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  7959                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  7960                                  		;test	dl,attr_directory ;AN006; was it a directory?
  7961                                  		;jz	MD_other_err	;AN006; no - must have been a file
  7962                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  7963                                  		;			;AN006; set up already exists error
  7964                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  7965                                  ;MD_other_err:				;AN006;
  7966                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  7967                                  ;MkDirErr:
  7968                                  		;invoke	Std_Eprintf
  7969                                  		;return
  7970                                  
  7971                                  		; MSDOS 3.3
  7972 000018EB E81200                  		call	SETRMMK
  7973 000018EE 720C                    		jb	short MKDIRERR
  7974 000018F0 B439                    		mov	ah,MKDIR ; 39h
  7975 000018F2 CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  7976                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  7977 000018F4 73F4                    		jnc	short MKDIR_RETN
  7978 000018F6 BA[853B]                		mov	dx,BADMKDPTR
  7979 000018F9 E8C805                  		call	GET_EXT_ERR_NUMBER
  7980                                  MKDIRERR:
  7981 000018FC E8BB1B                  		call	STD_EPRINTF
  7982 000018FF C3                      		retn
  7983                                  
  7984                                  ; =============== S U B	R O U T	I N E =======================================
  7985                                  
  7986                                  ; 	<Common MkDir/RmDir set up code>
  7987                                  ;****************************************************************
  7988                                  ;*
  7989                                  ;* ROUTINE:	SETRMMK
  7990                                  ;*
  7991                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  7992                                  ;*		commands. Parses the command line for a required
  7993                                  ;*		filespec.
  7994                                  ;*
  7995                                  ;* INPUT:	command line at offset 81H
  7996                                  ;*
  7997                                  ;* OUTPUT:	carry clear
  7998                                  ;*		    DS:DX points to ASCIIZ argument
  7999                                  ;*		carry set
  8000                                  ;*		    DS:DX has error message pointer
  8001                                  ;*
  8002                                  ;****************************************************************
  8003                                  
  8004                                  		; MSDOS 6.0
  8005                                  		;mov	si,81H
  8006                                  		;mov	di,offset trangroup:parse_mrdir 
  8007                                  					;AN000; Get adderss of PARSE_MRDIR
  8008                                  		;xor	cx,cx		;AN000; clear cx,dx
  8009                                  		;xor	dx,dx		;AN000;
  8010                                  		;invoke	parse_with_msg	;AC000; call parser
  8011                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8012                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8013                                  
  8014                                  		;mov	di,offset trangroup:srcxname
  8015                                  		;			;AN000; get address of srcxname
  8016                                  		;push	di		;AN000; save address
  8017                                  		;push	si		;AN000; save position in line
  8018                                  		;lds	si,parse1_addr	;AN000; get address of path
  8019                                  
  8020                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8021                                  		;lodsb			;get a char from buffer
  8022                                  		;stosb			;AN000; store in srcxname
  8023                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8024                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8025                                  		;pop	si		;AN000; get line position back
  8026                                  ;;
  8027                                  ;; we have scanned an argument.	See if any args beyond.
  8028                                  ;;
  8029                                  		;mov	di,offset trangroup:parse_mrdir 
  8030                                  		;			;AC000; get address of parse_mrdir
  8031                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8032                                  		;pop	dx		;AC000; get address of SRCXNAME
  8033                                  		;retz			;yes - return no error
  8034                                  ;NOARGERR:
  8035                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8036                                  		;			;AC000; get extended message pointer
  8037                                  		;XOR	AX,AX
  8038                                  		;STC
  8039                                  		;return
  8040                                  
  8041                                  		; MSDOS 3.3
  8042                                  SETRMMK:
  8043 00001900 BE8100                  		mov	si,81h
  8044 00001903 E87300                  		call	SCANOFF
  8045 00001906 3C0D                    		cmp	al,0Dh
  8046 00001908 741E                    		je	short NOARGERR
  8047 0000190A 89F2                    		mov	dx,si
  8048                                  SETRMMK1:
  8049 0000190C AC                      		lodsb
  8050 0000190D E87100                  		call	DELIM
  8051 00001910 7409                    		jz	short SETRMMK3
  8052 00001912 3C0D                    		cmp	al,0Dh
  8053 00001914 75F6                    		jne	short SETRMMK1
  8054 00001916 C644FF00                		mov	byte [si-1],0
  8055                                  SETRMMK2:
  8056 0000191A C3                      		retn
  8057                                  SETRMMK3:
  8058 0000191B C644FF00                		mov	byte [si-1],0
  8059 0000191F 56                      		push	si
  8060 00001920 E85600                  		call	SCANOFF
  8061 00001923 5E                      		pop	si
  8062 00001924 3C0D                    		cmp	al,0Dh
  8063 00001926 74F2                    		je	short SETRMMK2
  8064                                  NOARGERR:
  8065 00001928 BA[5D3D]                		mov	dx,BADARGSPTR
  8066 0000192B 31C0                    		xor	ax,ax
  8067 0000192D F9                      		stc
  8068                                  SETRMMK_RETN:
  8069 0000192E C3                      		retn
  8070                                  
  8071                                  ; ---------------------------------------------------------------------------
  8072                                  
  8073                                  _$RMDIR:
  8074 0000192F E8CEFF                  		call	SETRMMK
  8075 00001932 720E                    		jb	short RMDIRERR
  8076 00001934 7506                    		jnz	short BADRDERR
  8077 00001936 B43A                    		mov	ah,RMDIR ; 3Ah
  8078 00001938 CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8079                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8080 0000193A 73F2                    		jnc	short SETRMMK_RETN
  8081                                  
  8082                                  		; MSDOS 6.0
  8083                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8084                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8085                                  		;jz	badrderr	;AN022; yes - issue old message
  8086                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8087                                  		;jz	badrderr	;AN022; yes - issue old message
  8088                                  
  8089                                  		;call	Set_Ext_Error_Subst ;AN022;
  8090                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8091                                  
  8092                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8093                                  BADRDERR:
  8094 0000193C BA[BE3B]                		mov	dx,BADRMDPTR
  8095 0000193F E88205                  		call	GET_EXT_ERR_NUMBER
  8096                                  RMDIRERR:
  8097 00001942 E8751B                  		call	STD_EPRINTF
  8098                                  RMDIR_RETN:
  8099 00001945 C3                      		retn
  8100                                  
  8101                                  ; =============== S U B	R O U T	I N E =======================================
  8102                                  
  8103                                  ; MSDOS 6.0
  8104                                  
  8105                                  ;****************************************************************
  8106                                  ;*
  8107                                  ;* ROUTINE:	Set_ext_error_subst
  8108                                  ;*
  8109                                  ;* FUNCTION:	Sets up substitution for extended error
  8110                                  ;*
  8111                                  ;* INPUT:	AX - extended error number
  8112                                  ;*		DX - offset of string
  8113                                  ;*
  8114                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8115                                  ;*
  8116                                  ;****************************************************************
  8117                                  
  8118                                  ;Set_ext_error_subst  proc near		;AN022;
  8119                                  ;
  8120                                  ;	mov	msg_disp_class,ext_msg_class
  8121                                  ;					;AN022; set up extended error msg class
  8122                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8123                                  ;	mov	Extend_buf_sub,one_subst 
  8124                                  ;					;AN022; put number of subst in control block
  8125                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8126                                  ;					;AN022; get extended message pointer
  8127                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8128                                  ;
  8129                                  ;	ret				;AN022; return
  8130                                  ;
  8131                                  ;Set_ext_error_subst  endp		;AN022;
  8132                                  
  8133                                  ; =============== S U B	R O U T	I N E =======================================
  8134                                  
  8135                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8136                                  
  8137                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8138                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8139                                  ;   buffer
  8140                                  ;
  8141                                  ;   Inputs:	DL has 1-based drive number
  8142                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8143                                  ;   Outputs:	Carry Clear
  8144                                  ;		    DS = TranGroup
  8145                                  ;		Carry Set
  8146                                  ;		    AX has error code
  8147                                  ;   Registers Modified: AX, SI
  8148                                  
  8149                                  SAVUDIR:
  8150 00001946 BF[4341]                		mov	di,USERDIR1
  8151                                  
  8152                                  ; ---------------------------------------------------------------------------
  8153                                  
  8154                                  SAVUDIR1:
  8155 00001949 88D0                    		mov	al,dl
  8156 0000194B 0440                    		add	al,'@'
  8157 0000194D 3C40                    		cmp	al,'@'
  8158 0000194F 7506                    		jnz	short GOTUDRV
  8159 00001951 0206[7542]              		add	al,[CURDRV]
  8160 00001955 FEC0                    		inc	al		; A = 1
  8161                                  GOTUDRV:
  8162 00001957 AA                      		stosb
  8163 00001958 8A26[6642]              		mov	ah,[DIRCHAR]
  8164 0000195C B03A                    		mov	al,':'
  8165 0000195E AB                      		stosw
  8166 0000195F 06                      		push	es
  8167 00001960 1F                      		pop	ds
  8168 00001961 89FE                    		mov	si,di
  8169 00001963 B447                    		mov	ah,CURRENT_DIR	; 47h
  8170 00001965 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8171                                  				; DL = drive (0=default,1=A,etc.)
  8172                                  				; DS:SI	points to 64-byte buffer area
  8173 00001967 72DC                    		jc	short RMDIR_RETN
  8174 00001969 0E                      		push	cs
  8175 0000196A 1F                      		pop	ds
  8176 0000196B C3                      		retn
  8177                                  
  8178                                  ; =============== S U B	R O U T	I N E =======================================
  8179                                  
  8180                                  CRLF2:
  8181 0000196C 52                      		push	dx
  8182 0000196D BA[7E3D]                		mov	dx,ACRLFPTR
  8183 00001970 1E                      		push	ds
  8184 00001971 0E                      		push	cs
  8185 00001972 1F                      		pop	ds
  8186 00001973 E84D1B                  		call	STD_PRINTF
  8187 00001976 1F                      		pop	ds
  8188 00001977 5A                      		pop	dx
  8189 00001978 C3                      		retn
  8190                                  
  8191                                  ; =============== S U B	R O U T	I N E =======================================
  8192                                  
  8193                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8194                                  ; may NOT be TRANGROUP
  8195                                  
  8196                                  SCANOFF:
  8197 00001979 AC                      		lodsb
  8198 0000197A E80400                  		call	DELIM
  8199 0000197D 74FA                    		jz	short SCANOFF
  8200 0000197F 4E                      		dec	si		; Point to first non-delimiter
  8201                                  SCANOFF_RETN:
  8202 00001980 C3                      		retn
  8203                                  
  8204                                  ; ---------------------------------------------------------------------------
  8205                                  
  8206                                  ; Input:    AL is character to classify
  8207                                  ; Output:   Z set if delimiter
  8208                                  ;	    NZ set otherwise
  8209                                  ; Registers modified: none
  8210                                  
  8211                                  DELIM:
  8212 00001981 3C20                    		cmp	al,' '
  8213 00001983 74FB                    		jz	short SCANOFF_RETN
  8214 00001985 3C3D                    		cmp	al,'='
  8215 00001987 74F7                    		jz	short SCANOFF_RETN
  8216 00001989 3C2C                    		cmp	al,','
  8217 0000198B 74F3                    		jz	short SCANOFF_RETN
  8218 0000198D 3C3B                    		cmp	al,';'
  8219 0000198F 74EF                    		jz	short SCANOFF_RETN
  8220 00001991 3C09                    		cmp	al,9		; Check for TAB character
  8221 00001993 74EB                    		jz	short SCANOFF_RETN
  8222 00001995 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8223 00001997 C3                      		retn
  8224                                  
  8225                                  
  8226                                  ; =============== S U B	R O U T	I N E =======================================
  8227                                  
  8228                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8229 00001998 B90800                  		mov	cx,8
  8230                                  MAINNAME:
  8231 0000199B AC                      		lodsb
  8232 0000199C 3C20                    		cmp	al,' '
  8233 0000199E 7401                    		jz	short SKIPSPC
  8234 000019A0 AA                      		stosb
  8235                                  SKIPSPC:
  8236 000019A1 E2F8                    		loop	MAINNAME
  8237 000019A3 AC                      		lodsb
  8238 000019A4 3C20                    		cmp	al,' '
  8239 000019A6 7413                    		jz	short GOTNAME
  8240 000019A8 88C4                    		mov	ah,al
  8241                                  		;mov	al,'.'
  8242 000019AA A0[F83E]                		mov	al,[DOT_CHR]
  8243 000019AD AA                      		stosb
  8244 000019AE 86C4                    		xchg	al,ah
  8245 000019B0 AA                      		stosb
  8246 000019B1 B102                    		mov	cl,2
  8247                                  EXTNAME:
  8248 000019B3 AC                      		lodsb
  8249 000019B4 3C20                    		cmp	al,' '
  8250 000019B6 7403                    		jz	short GOTNAME
  8251 000019B8 AA                      		stosb
  8252 000019B9 E2F8                    		loop	EXTNAME
  8253                                  GOTNAME:
  8254 000019BB 30C0                    		xor	al,al
  8255 000019BD AA                      		stosb
  8256                                  STRCOMP_RETN:
  8257 000019BE C3                      		retn
  8258                                  
  8259                                  ; =============== S U B	R O U T	I N E =======================================
  8260                                  
  8261                                  ; Compare ASCIZ DS:SI with ES:DI.
  8262                                  ; SI,DI destroyed.
  8263                                  
  8264                                  STRCOMP:	
  8265 000019BF A6                      		cmpsb
  8266 000019C0 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8267 000019C2 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8268 000019C6 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8269 000019C8 EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8270                                  
  8271                                  ; =============== S U B	R O U T	I N E =======================================
  8272                                  
  8273                                  CRPRINT:
  8274 000019CA 50                      		push	ax
  8275                                  		;mov	al,13
  8276 000019CB B00D                    		mov	al,0Dh
  8277 000019CD 51                      		push	cx
  8278 000019CE 57                      		push	di
  8279 000019CF 89D7                    		mov	di,dx
  8280 000019D1 B9FFFF                  		mov	cx,65535
  8281 000019D4 06                      		push	es
  8282 000019D5 1E                      		push	ds
  8283 000019D6 07                      		pop	es
  8284 000019D7 F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8285 000019D9 C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8286 000019DD 07                      		pop	es
  8287 000019DE 8916[3E44]              		mov	[STRING_PTR_2],dx
  8288 000019E2 BA[2F37]                		mov	dx,STRINGBUF2PTR
  8289 000019E5 E8DB1A                  		call	STD_PRINTF
  8290                                  		;mov	byte [di-1],13
  8291 000019E8 C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8292 000019EC 7204                    		jb	short ERROR_OUTPUT
  8293 000019EE 5F                      		pop	di
  8294 000019EF 59                      		pop	cx
  8295 000019F0 58                      		pop	ax
  8296 000019F1 C3                      		retn
  8297                                  
  8298                                  ; ---------------------------------------------------------------------------
  8299                                  
  8300                                  ERROR_OUTPUT:
  8301 000019F2 0E                      		push	cs
  8302 000019F3 1F                      		pop	ds
  8303 000019F4 8E06[6142]              		mov	es,[RESSEG]
  8304 000019F8 BA[2938]                		mov	dx,NOSPACEPTR
  8305 000019FB 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  8306 00001A01 7406                    		jz	short GO_TO_ERROR
  8307 00001A03 E88009                  		call	PIPEOFF
  8308 00001A06 BA[C23C]                		mov	dx,PIPEEMESPTR
  8309                                  GO_TO_ERROR:
  8310 00001A09 E91702                  		jmp	CERROR
  8311                                  
  8312                                  ; =============== S U B	R O U T	I N E =======================================
  8313                                  
  8314                                  ;---- Mod for path invocation ----
  8315                                  
  8316                                  PATHCHRCMP:
  8317 00001A0C 50                      		push	ax
  8318 00001A0D B42F                    		mov	ah,'/'
  8319 00001A0F 3826[6542]              		cmp	[SWITCHAR],ah
  8320 00001A13 7404                    		jz	short NOSLASHT
  8321 00001A15 3C2F                    		cmp	al,'/'
  8322 00001A17 7402                    		jz	short PCCONT
  8323                                  NOSLASHT:
  8324 00001A19 3C5C                    		cmp	al,'\'
  8325                                  PCCONT:	
  8326 00001A1B 58                      		pop	ax
  8327 00001A1C C3                      		retn
  8328                                  
  8329                                  ; =============== S U B	R O U T	I N E =======================================
  8330                                  
  8331                                  ; PATHCRUNCH -
  8332                                  ;
  8333                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8334                                  ;       PathPos = ptr to string with pathname in it
  8335                                  ;       PathCnt = length of string
  8336                                  ;
  8337                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8338                                  ;       PathCnt = length left in string
  8339                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8340                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8341                                  ;       If path crunched successfully,
  8342                                  ;         CY = clear
  8343                                  ;         Current directory is changed to directory in pathname
  8344                                  ;         UserDir1 contains previous directory for use by RestUDir
  8345                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8346                                  ;         DestTail = ptr to beginning of filename
  8347                                  ;         If filename found in pathname,
  8348                                  ;           ZR = clear
  8349                                  ;           FCB filename fields contain filename
  8350                                  ;         If filename not found (pure directory path),
  8351                                  ;           ZR = set
  8352                                  ;           FCB filename fields are wildcarded with ?'s
  8353                                  ;       If pathcrunch failed (no ChDir's worked),
  8354                                  ;         CY = set
  8355                                  ;         Msg_Numb = extended error code
  8356                                  ;
  8357                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8358                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8359                                  ;       with the filename wildcarded.
  8360                                  
  8361                                  PATHCRUNCH:
  8362                                  		; MSDOS 6.0
  8363                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8364                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8365                                  		;mov	dl,[5CH]
  8366 00001A1D 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8367 00001A21 E822FF                  		call	SAVUDIR		; save current directory in UserDir1
  8368 00001A24 E84A03                  		call	SETPATH
  8369                                  		; MSDOS 6.0
  8370                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8371                                  
  8372                                  ;       DX = ptr to pathname, NULL-terminated
  8373                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8374                                  
  8375                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8376 00001A27 F606[6044]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8377 00001A2C 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8378                                  
  8379 00001A2E B43B                    		mov	ah,CHDIR ; 3Bh
  8380 00001A30 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8381                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8382                                  		; MSDOS 6.0
  8383                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8384                                  		;
  8385                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8386                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8387                                  		;jz	trypeel                 ;AC022;     keep trying
  8388                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8389                                  		;jz	trypeel                 ;AC022;     keep trying
  8390                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8391                                  		;jmp	peelfail                ;AN022; exit with other error
  8392                                  
  8393                                  		; MSDOS 3.3
  8394 00001A32 7210                    		jc	short TRYPEEL
  8395                                  ;chdir_worked:
  8396                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8397 00001A34 E8CD04                  		call	SETREST1	; set 'Restore Directory' flag true
  8398 00001A37 B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8399 00001A39 BF5D00                  		mov	di,5Dh
  8400 00001A3C B90B00                  		mov	cx,11
  8401 00001A3F F3AA                    		rep stosb
  8402 00001A41 30C0                    		xor	al,al		; return carry clear, zero set
  8403 00001A43 C3                      		retn
  8404                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8405                                  		;jmp	pcrunch_cderr	;AN022;
  8406                                  TRYPEEL:
  8407 00001A44 8B36[B043]              		mov	si,[PATHPOS]
  8408 00001A48 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8409 00001A49 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8410 00001A4C E8BDFF                  		call	PATHCHRCMP
  8411 00001A4F 7424                    		jz	short PEELFAIL
  8412                                  DELLOOP:
  8413 00001A51 39D6                    		cmp	si,dx
  8414 00001A53 742C                    		jz	short BADRET
  8415 00001A55 8A04                    		mov	al,[si]
  8416 00001A57 E8B2FF                  		call	PATHCHRCMP
  8417 00001A5A 7403                    		jz	short TRYCD
  8418 00001A5C 4E                      		dec	si
  8419 00001A5D EBF2                    		jmp	short DELLOOP
  8420                                  TRYCD:
  8421 00001A5F 50                      		push	ax
  8422                                  		;mov	al,'.'
  8423 00001A60 A0[F83E]                		mov	al,[DOT_CHR]	; AL = '.'
  8424                                  		; MSDOS 6.0
  8425                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8426                                  					;M019; allow continuation if '. ' or 
  8427                                  					;M019; '..' is not found.
  8428                                  		;jnz	@f		;M019; '.' not found
  8429                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8430                                  		;jz	@f		;M019; found '..'
  8431                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8432                                  ;@@:		;pop     ax
  8433                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8434                                  
  8435                                  		; MSDOS 3.3
  8436 00001A63 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8437 00001A66 58                      		pop	ax
  8438 00001A67 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8439                                  
  8440                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8441 00001A69 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8442 00001A6C 3C3A                    		cmp	al,':'
  8443 00001A6E 7411                    		jz	short BADRET
  8444 00001A70 E899FF                  		call	PATHCHRCMP
  8445 00001A73 7502                    		jnz	short NODOUBLESL
  8446                                  PEELFAIL:
  8447 00001A75 F9                      		stc
  8448 00001A76 C3                      		retn
  8449                                  NODOUBLESL:
  8450 00001A77 C60400                  		mov	byte [si],0
  8451 00001A7A B43B                    		mov	ah,CHDIR ; 3Bh
  8452 00001A7C CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8453                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8454 00001A7E 7317                    		jnc	short CDSUCC
  8455                                  
  8456                                  		; MSDOS 6.0
  8457                                  ;pcrunch_cderr:
  8458                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8459                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8460                                  		;or	si,si		;AN022; set up zero flag to not zero
  8461                                  		;stc			;AN022; set up carry flag
  8462                                  		;return
  8463                                  		
  8464                                  		; MSDOS 3.3
  8465                                  PATHCRUNCH_RETN:
  8466 00001A80 C3                      		retn
  8467                                  
  8468                                  BADRET:
  8469 00001A81 8A04                    		mov	al,[si]
  8470 00001A83 E886FF                  		call	PATHCHRCMP
  8471 00001A86 F9                      		stc
  8472 00001A87 75F7                    		jnz	short PATHCRUNCH_RETN
  8473 00001A89 30DB                    		xor	bl,bl
  8474 00001A8B 865C01                  		xchg	bl,[si+1]
  8475 00001A8E B43B                    		mov	ah,CHDIR ; 3Bh
  8476 00001A90 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8477                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8478 00001A92 72EC                    		jb	short PATHCRUNCH_RETN
  8479 00001A94 885C01                  		mov	[si+1],	bl
  8480                                  CDSUCC:
  8481 00001A97 E86A04                  		call	SETREST1
  8482 00001A9A 46                      		inc	si
  8483 00001A9B 8936[5E44]              		mov	[DESTTAIL],si
  8484                                  		; MSDOS 6.0
  8485                                  		;pushf			;AN015; save flags
  8486                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8487                                  		;jz	pcrunch_end	;AN015;
  8488                                  		;MOV	DI,FCB
  8489                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8490                                  					; Parse with default drive
  8491                                  		;INT	21h
  8492                                  ;pcrunch_end:
  8493                                  		;popf			;AN015; get flags back
  8494                                  		;return
  8495                                  
  8496                                  		; MSDOS 3.3
  8497 00001A9F BF5C00                  		mov	di,FCB ; 5Ch
  8498 00001AA2 B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8499 00001AA5 CD21                    		int	21h	; DOS -	PARSE FILENAME
  8500                                  				; DS:SI	-> string to parse
  8501                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8502                                  				; AL = bit mask	to control parsing
  8503 00001AA7 C3                      		retn
  8504                                  
  8505                                  ;============================================================================
  8506                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8507                                  ;============================================================================
  8508                                  ; 05/10/2018 - Retro DOS v3.0
  8509                                  
  8510                                  ;TITLE	Part7 COMMAND Transient Routines
  8511                                  
  8512                                  ;	More misc routines
  8513                                  
  8514                                  ;---------------------------
  8515                                  ; We can get rid of this switch processing code if we can take
  8516                                  ; care of the remaining two calls to switch, later in the file.
  8517                                  ; However, I have not checked whether or not any other files use
  8518                                  ; switch -- after all, it IS public!
  8519                                  ;---------------------------
  8520                                  
  8521                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8522                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8523                                  
  8524                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8525                                  
  8526                                  ; ---------------------------------------------------------------------------
  8527                                  
  8528 00001AA8 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8529 00001AA9 C3                      		retn
  8530                                  
  8531                                  ; =============== S U B	R O U T	I N E =======================================
  8532                                  
  8533                                  SWITCH:
  8534 00001AAA 31DB                    		xor	bx,bx		; Initialize - no switches set
  8535                                  SWLOOP:
  8536 00001AAC E8CAFE                  		call	SCANOFF		; Skip any delimiters
  8537 00001AAF 3A06[6542]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8538 00001AB3 75F3                    		jnz	short RETSW	; No -- we're finished
  8539                                  		;or	bx,8000h
  8540 00001AB5 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8541 00001AB9 46                      		inc	si		; Skip over the switch character
  8542 00001ABA E8BCFE                  		call	SCANOFF
  8543 00001ABD 3C0D                    		cmp	al,0Dh
  8544 00001ABF 74E7                    		je	short RETSW	; Oops
  8545 00001AC1 46                      		inc	si
  8546                                  
  8547                                  		; Convert lower case input to upper case
  8548                                  
  8549                                  		;call	UPCONV
  8550 00001AC2 E859FD                  		call	UPCONV_MAPCALL
  8551                                  
  8552 00001AC5 BF[0D3F]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8553                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8554                                  		;mov	cx,5  ; MSDOS 3.3
  8555 00001AC8 B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8556                                  		
  8557                                  		;nop
  8558                                  		
  8559 00001ACB F2AE                    		repne scasb		; Look for matching switch
  8560 00001ACD 7507                    		jnz	short BADSW
  8561 00001ACF B80100                  		mov	ax,1
  8562 00001AD2 D3E0                    		shl	ax,cl		; Set a bit for the switch
  8563 00001AD4 09C3                    		or	bx,ax
  8564                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8565 00001AD6 EBD4                    		jmp	short SWLOOP
  8566                                  
  8567                                  ;BADSW:
  8568                                  		;jmp	short SWLOOP
  8569                                  
  8570                                  DRVBAD:
  8571 00001AD8 BA[3939]                		mov	dx,BADDRVPTR
  8572 00001ADB E94501                  		jmp	CERROR
  8573                                  
  8574                                  EXTERNALJ:
  8575 00001ADE E9B100                  		jmp	EXTERNAL
  8576                                  
  8577                                  FNDCOM:					; search the internal command table
  8578 00001AE1 08C0                    		or	al,al		; Get real length of first arg
  8579 00001AE3 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8580                                  					;  to be external.
  8581                                  ; barryf code starts here
  8582                                  
  8583 00001AE5 E87802                  		call	TEST_APPEND	; see if APPEND installed
  8584 00001AE8 7421                    		jz	short CONTCOM	; not loaded
  8585                                  
  8586                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8587 00001AEA 8A0E[DB42]              		mov	cl,[IDLEN]
  8588 00001AEE B500                    		mov	ch,0
  8589 00001AF0 890E[B043]              		mov	[PATHPOS],cx
  8590                                  		
  8591                                  		; MSDOS 6.0
  8592                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8593                                  
  8594 00001AF4 E80803                  		call	IOSET		; re-direct the o'l io
  8595                                  
  8596 00001AF7 BE[DB42]                		mov	si,IDLEN	; address command name, DS already set	
  8597 00001AFA BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8598                                  		
  8599                                  		; MSDOS 6.0
  8600                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8601                                  					;AN010; Get the entry point for PARSE for APPEND
  8602                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8603 00001AFD B801AE                  		mov	ax,0AE01h
  8604 00001B00 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8605                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8606                                  				; DX = FFFFh,[SI -> buffer
  8607                                  				; Return: buffer at DS:SI filled with a	length byte
  8608                                  				;		 followed by the uppercase
  8609                                  				; internal command to execute (if length not 0)
  8610 00001B02 803E[DB42]00            		cmp	byte [IDLEN],0 ; execute requested
  8611 00001B07 7502                    		jne	short CONTCOM
  8612 00001B09 EB57                    		jmp	short CMD_DONE
  8613                                  
  8614                                  		;nop
  8615                                  CONTCOM:				; continue with internal scan
  8616 00001B0B BF[D33D]                		mov	di,COMTAB
  8617 00001B0E 31C9                    		xor	cx,cx
  8618                                  FINDCOM:
  8619 00001B10 BE[DC42]                		mov	si,ID		; pointer to command argument
  8620 00001B13 8A0D                    		mov	cl,[di]		; load length of internal command
  8621 00001B15 47                      		inc	di		; advance past length
  8622 00001B16 E3C6                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8623 00001B18 3A0E[DB42]              		cmp	cl,[IDLEN]	; that of the command argument
  8624 00001B1C 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8625 00001B1E 890E[B043]              		mov	[PATHPOS],cx	; store length of command
  8626 00001B22 F3A6                    		repe cmpsb
  8627                                  ABCD:					
  8628 00001B24 9F                      		lahf			; save the good ol' flags
  8629 00001B25 01CF                    		add	di,cx		; skip over remaining internal, if any
  8630 00001B27 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8631 00001B29 A2[7342]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8632 00001B2C 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8633 00001B2D 8B1D                    		mov	bx,[di]		; load internal command address
  8634 00001B2F 47                      		inc	di		; skip over the puppy
  8635 00001B30 47                      		inc	di
  8636                                  		
  8637                                  		; MSDOS 6.0
  8638                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8639                                  		;inc     DI
  8640                                  		;inc     DI
  8641                                  		;sahf			; remember those flags?
  8642                                  		;jnz     findcom	; well, if all the cmps worked...
  8643                                  ;;
  8644                                  ;; All messages get redirected.
  8645                                  ;;
  8646                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8647                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8648                                  		;invoke  ioset		; re-direct the ol' i/o
  8649                                  
  8650                                  ;dont_set_io:					;AN041;
  8651                                  ;;
  8652                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8653                                  ;; respond to /? only if it is the only command-line argument.
  8654                                  ;;
  8655                                  		;mov     ax,[COMSW]	; AX = switches after command
  8656                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8657                                  		;and     ax,SwitchQues	
  8658                                  		;jz      drive_check	; /? not in command line
  8659                                  		;	
  8660                                  		;test    [CHKDRV],fLimitHelp
  8661                                  		;jz      do_help	; /? allowed in combination
  8662                                  ;;
  8663                                  ;; Make sure /? is the only argument on the command line.
  8664                                  ;;
  8665                                  		;cmp     [arg.argvcnt],2
  8666                                  		;jne     drive_check	; /? not only arg - ignore
  8667                                  ;;
  8668                                  ;; Note:  this is all the check we need, even against things like /??.
  8669                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8670                                  ;;
  8671                                  
  8672                                  ;do_help:
  8673                                  ;
  8674                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8675                                  
  8676                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8677                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8678                                  		;push    ax		; build subst block on stack
  8679                                  
  8680                                  ;next_help_msg:
  8681                                  		;lodsw			; AX = help msg # or zero
  8682                                  		;or      ax,ax
  8683                                  		;jz      help_done
  8684                                  		;push    ax		; SS:SP = ptr to subst block
  8685                                  					;  (msg # and no_subst byte)
  8686                                  ;; We assume DS = SS.
  8687                                  
  8688                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8689                                      		;invoke  Std_PrintF	; display help message
  8690                                      		;pop     ax		; remove msg # from stack
  8691                                     		;jmp     next_help_msg
  8692                                  
  8693                                  ;help_done:
  8694                                  		;pop     ax		; clean up stack
  8695                                  		;jmp     TCommand	
  8696                                  
  8697                                  		; MSDOS 3.3
  8698 00001B31 9E                      		sahf			; remember those flags?
  8699 00001B32 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8700 00001B34 E8C802                  		call	IOSET		; re-direct the ol' i/o
  8701                                  
  8702                                  DRIVE_CHECK:
  8703                                  		;test	byte [CHKDRV],1
  8704 00001B37 F606[7342]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8705                                  					; did we wanna check those drives?
  8706 00001B3C 740D                    		jz	short NOCHECK
  8707 00001B3E A0[7642]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8708 00001B41 0A06[7742]              		or	al,[PARM2]	; us whether those drives were OK
  8709 00001B45 3CFF                    		cmp	al,-1
  8710 00001B47 7502                    		jnz	short NOCHECK
  8711 00001B49 EB8D                    		jmp	short DRVBAD
  8712                                  
  8713                                  ; The user may have omitted the space between the command and its arguments.
  8714                                  ; We need to copy the remainder of the user's command line into the buffer.
  8715                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8716                                  ; into the command line at 80.
  8717                                  
  8718                                  NOCHECK:
  8719 00001B4B E8F501                  		call	CMD_COPY
  8720                                  SWITCHECK:
  8721                                  		;test	byte [CHKDRV],2
  8722 00001B4E F606[7342]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8723                                  					; Does the command take switches
  8724 00001B53 750B                    		jnz	short REALWORK	; Yes, process the command
  8725 00001B55 E82400                  		call	NOSWIT		; No, check to see if any switches
  8726 00001B58 7506                    		jnz	short REALWORK	; None, process the command
  8727                                  
  8728                                  		; MSDOS 6.0
  8729                                  		;mov	msg_disp_class,parse_msg_class	
  8730                                  		;			;AN000; set up parse error msg class
  8731                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8732                                  		;			;AC000; get extended message pointer
  8733                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8734                                  		;			;AN000; get "Invalid switch" message number
  8735                                  		;jmp	CERROR		; Print error and chill out...
  8736                                  
  8737                                  		; MSDOS 3.0
  8738 00001B5A BA[123A]                		mov	dx,BADPARMPTR
  8739 00001B5D E9C300                  		jmp	CERROR
  8740                                  
  8741                                  REALWORK:
  8742 00001B60 FFD3                    		call	bx		; do some real work, at last
  8743                                  
  8744                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8745                                  ; otherwise, go get another command.
  8746                                  
  8747                                  CMD_DONE:
  8748 00001B62 0E                      		push	cs		; g  restore data segment
  8749 00001B63 1F                      		pop	ds		; g
  8750 00001B64 1E                      		push	ds
  8751 00001B65 8E1E[6142]              		mov	ds,[RESSEG]	; g  save data segment
  8752                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8753 00001B69 803E000C01              		cmp	byte [CALL_FLAG],call_in_progress
  8754 00001B6E C606000C00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8755 00001B73 1F                      		pop	ds		; g  get data segment back
  8756 00001B74 7403                    		jz	short INCALL	; G
  8757 00001B76 E98BE5                  		jmp	TCOMMAND	; chill out...
  8758                                  INCALL:
  8759 00001B79 E931E7                  		jmp	DOCOM1
  8760                                  
  8761                                  ; =============== S U B	R O U T	I N E =======================================
  8762                                  
  8763                                  NOSWIT:
  8764 00001B7C 57                      		push	di		; Save di
  8765 00001B7D BF8100                  		mov	di,81h		; di = ptr to command args
  8766 00001B80 BE8000                  		mov	si,80h		; Get address of length of command args
  8767 00001B83 AC                      		lodsb			; Load length
  8768 00001B84 88C1                    		mov	cl,al		; Move length to cl
  8769 00001B86 30ED                    		xor	ch,ch		; Zero ch
  8770 00001B88 2EA0[6542]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8771 00001B8C 3C00                    		cmp	al,0		; Turn off ZF
  8772 00001B8E F2AE                    		repne scasb		; Scan for a switch character and return
  8773 00001B90 5F                      		pop	di		;  with ZF set if one was found
  8774 00001B91 C3                      		retn
  8775                                  
  8776                                  ; ---------------------------------------------------------------------------
  8777                                  
  8778                                  EXTERNAL:
  8779 00001B92 E8CB01                  		call	TEST_APPEND	; check to see if append installed
  8780 00001B95 7406                    		jz	short NOT_BARRYF ; no - truly external command
  8781 00001B97 E950FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8782                                  
  8783                                  		; 25/02/2023
  8784                                  BATCOMJ:
  8785 00001B9A E949EB                  		jmp	BATCOM
  8786                                  
  8787                                  NOT_BARRYF:
  8788 00001B9D 2EC606[7442]00          		mov	byte [cs:FILTYP],0
  8789 00001BA3 2E8A16[8142]            		mov	dl,[cs:SPECDRV]
  8790 00001BA8 2E8816[DB42]            		mov	[cs:IDLEN],dl
  8791 00001BAD 2EC606[5744]00          		mov	byte [cs:ROM_CALL],0
  8792 00001BB3 52                      		push	dx
  8793 00001BB4 BA[DB42]                		mov	dx,IDLEN
  8794 00001BB7 E816E8                  		call	ROM_SCAN
  8795 00001BBA 5A                      		pop	dx
  8796                                  		;jnc	short POSTSAVE
  8797 00001BBB 7305                    		jnc	short DO_SCAN
  8798 00001BBD 2EFE06[5744]            		inc	byte [cs:ROM_CALL]
  8799                                  		;jmp	short POSTSAVE
  8800                                  
  8801                                  		;nop
  8802                                  DO_SCAN:
  8803                                  POSTSAVE:
  8804 00001BC2 BF[8941]                		mov	di,EXECPATH
  8805 00001BC5 C60500                  		mov	byte [di],0	; Initialize to current directory
  8806                                  	
  8807 00001BC8 2E803E[5744]00          		cmp	byte [cs:ROM_CALL],0
  8808                                  		;jz	short RESEARCH
  8809                                  		;jmp	short NEOEXECUTE
  8810                                  		; 25/02/2023
  8811 00001BCE 750C                    		jnz	short NEOEXECUTE		
  8812                                  
  8813                                  		;nop
  8814                                  RESEARCH:
  8815 00001BD0 E80D09                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8816 00001BD3 09C0                    		or	ax,ax		; did we find anything?
  8817                                  		;jz	short BADCOMJ45	; null means no (sob)
  8818                                  		; 25/02/2023
  8819 00001BD5 7447                    		jz	short BADCOM
  8820 00001BD7 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8821                                  					; fuckin' sixteen-bit machine ought
  8822 00001BDA 7CBE                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8823                                  					; DISPLACEMENT!!
  8824                                  		; 25/02/2023
  8825                                  		;;jmp	short NEOEXECUTE
  8826                                  		;jmp	short EXECUTE	
  8827                                  
  8828                                  
  8829                                  		; 02H is .bat
  8830                                  
  8831                                  		;nop
  8832                                  
  8833                                  		; 25/02/2023
  8834                                  ;BATCOMJ:
  8835                                  ;		jmp	BATCOM
  8836                                  ;
  8837                                  ;BADCOMJ45:
  8838                                  ;		jmp	short BADCOM
  8839                                  
  8840                                  		;nop
  8841                                  EXECUTE:
  8842                                  NEOEXECUTE:
  8843 00001BDC E82002                  		call	IOSET
  8844                                  
  8845                                  ; MSDOS 6.0
  8846                                  ;M051
  8847                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8848                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8849                                  ;After a close, this would still leave one open active resulting in sharing
  8850                                  ;errors on subsequent opens of the redirected file.
  8851                                  ;
  8852                                  ;LH_EXECUTE:				;M051	
  8853 00001BDF 8E06[7142]              		mov	es,[TRAN_TPA]
  8854 00001BE3 B449                    		mov	ah,DEALLOC ; 49h
  8855 00001BE5 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8856                                  				; ES = segment address of area to be freed
  8857                                  					; Now running in "free" space
  8858 00001BE7 8E06[6142]              		mov	es,[RESSEG]
  8859 00001BEB 26FE06EB0B              		inc	byte [es:EXTCOM] ; Indicate external command
  8860 00001BF0 26C606F30B00            		mov	byte [es:RESTDIR],0 
  8861                                  					; Since USERDIR1 is in transient, insure
  8862                                  					; this flag value for re-entry to COMMAND
  8863                                  		; MSDOS 6.0
  8864                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8865                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8866                                  		;MOV	CX,LenMsgOrPathBuf
  8867                                  		;CLD
  8868                                  		;REP	MOVSB		; copy program pathname to resident
  8869                                  
  8870                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8871 00001BF6 BF5C00                  		mov	di,FCB ; 5Ch
  8872 00001BF9 89FE                    		mov	si,di
  8873 00001BFB B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8874 00001BFE F3A5                    		rep movsw		; Transfer parameters to resident header
  8875 00001C00 BA[8941]                		mov	dx,EXECPATH
  8876                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8877 00001C03 BB050D                  		mov	bx,EXEC_BLOCK
  8878 00001C06 B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8879 00001C09 F606[5744]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8880 00001C0E 7403                    		jz	short OK_EXEC
  8881 00001C10 E936E8                  		jmp	ROM_EXEC
  8882                                  OK_EXEC:
  8883                                  ;
  8884                                  ; we are now running in free space. Anything we do from here on may get
  8885                                  ; trashed. Move the stack (also in free space) to allocated space because
  8886                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  8887                                  ;
  8888 00001C13 8CC1                    		mov	cx,es
  8889 00001C15 8ED1                    		mov	ss,cx
  8890 00001C17 BC3E08                  		mov	sp,RSTACK
  8891 00001C1A FF2E[6742]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  8892                                  
  8893                                  ; ---------------------------------------------------------------------------
  8894                                  
  8895                                  BADCOM:
  8896 00001C1E 0E                      		push	cs
  8897 00001C1F 1F                      		pop	ds
  8898 00001C20 BA[AB37]                		mov	dx,BADNAMPTR
  8899                                  CERROR:		
  8900 00001C23 E89418                  		call	STD_EPRINTF
  8901 00001C26 E9DBE4                  		jmp	TCOMMAND
  8902                                  
  8903                                  
  8904                                  ; =============== S U B	R O U T	I N E =======================================
  8905                                  
  8906                                  ; Prescan converts the input buffer into a canonicalized form.
  8907                                  ; All redirections and pipes are removed.
  8908                                  
  8909                                  PRESCAN:
  8910 00001C29 31C9                    		xor	cx,cx
  8911 00001C2B 8E06[6142]              		mov	es,[RESSEG]
  8912 00001C2F BE[C240]                		mov	si,COMBUF+2
  8913 00001C32 89F7                    		mov	di,si
  8914                                  COUNTQUOTES:
  8915 00001C34 AC                      		lodsb			; get a byte
  8916 00001C35 3C22                    		cmp	al,22h		; is it a quote?
  8917 00001C37 7504                    		jne	short COUNTEND	; no, try for end of road
  8918 00001C39 FEC5                    		inc	ch		; bump count
  8919 00001C3B EBF7                    		jmp	short COUNTQUOTES ; go get next char
  8920                                  COUNTEND:
  8921 00001C3D 3C0D                    		cmp	al,0Dh		; end of road?
  8922 00001C3F 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  8923 00001C41 89FE                    		mov	si,di		; restore pointer to begining
  8924                                  PRESCANLP:
  8925 00001C43 AC                      		lodsb
  8926 00001C44 3C22                    		cmp	al,'"'		; " character
  8927 00001C46 7510                    		jne	short TRYGREATER
  8928 00001C48 FECD                    		dec	ch
  8929 00001C4A 740C                    		jz	short TRYGREATER
  8930                                  QLOOP:
  8931 00001C4C 8805                    		mov	[di],al
  8932 00001C4E 47                      		inc	di
  8933 00001C4F FEC1                    		inc	cl
  8934 00001C51 AC                      		lodsb
  8935 00001C52 3C22                    		cmp	al,'"'		; " character
  8936 00001C54 75F6                    		jne	short QLOOP
  8937 00001C56 FECD                    		dec	ch
  8938                                  TRYGREATER:
  8939 00001C58 3A06[E33E]              		cmp	al,[RABRACKET]
  8940 00001C5C 753E                    		jne	short NOOUT
  8941                                  
  8942                                  ; We have found a ">" char. We need to see if there is another ">"
  8943                                  ; following it.
  8944                                  
  8945 00001C5E 3804                    		cmp	[si],al
  8946 00001C60 7506                    		jnz	short NOAPPND
  8947 00001C62 AC                      		lodsb
  8948 00001C63 26FE060A0C              		inc	byte [es:RE_OUT_APP] ; Flag >>
  8949                                  NOAPPND:
  8950                                  ; Now we attempt to find the file name. First, scan off all whitespace
  8951                                  
  8952 00001C68 E80EFD                  		call	SCANOFF
  8953                                  
  8954                                  		; MSDOS 6.0
  8955                                  		;CMP	AL,[LABRACKET]	   ;AN040; was there no filename?
  8956                                  		;Je	short REOUT_ERRSET ;AN040; yes - set up error
  8957                                  
  8958                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8959 00001C6B 3C0D                    		cmp	al,0Dh
  8960 00001C6D 750D                    		jnz	short GOTREOFIL
  8961                                  
  8962                                  ; There was no file present.  Set us up at end-of-line.
  8963                                  
  8964                                  REOUT_ERRSET:				;AN040; set up for an error
  8965 00001C6F C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  8966 00001C72 26C7060B0C0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  8967 00001C79 E99E00                  		jmp	PRESCANEND
  8968                                  
  8969                                  GOTREOFIL:
  8970 00001C7C 57                      		push	di
  8971                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  8972 00001C7D BF0B0C                  		mov	di,RE_OUTSTR
  8973 00001C80 89FB                    		mov	bx,di
  8974 00001C82 06                      		push	es
  8975                                  
  8976                                  		; MSDOS 6.0
  8977                                  SETREOUTSTR:				; Get the output redirection name
  8978                                  					; MSKK06 07/14/89
  8979                                  		;push	cx		; save cx
  8980                                  		;mov	cx,64+13	; CX = max string length
  8981                                  ;SETREOUTSTR_LOOP:
  8982                                  		;LODSB
  8983                                  		;CMP	AL,0DH
  8984                                  		;JZ	GOTRESTR_J
  8985                                  		;INVOKE	DELIM
  8986                                  		;JZ	GOTRESTR_J
  8987                                  		;CMP	AL,[SWITCHAR]
  8988                                  		;JZ	GOTRESTR_J
  8989                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  8990                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  8991                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  8992                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  8993                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  8994                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  8995                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  8996                                  		;DEC	SI		;AN002; back up over symbol
  8997                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  8998                                  ;GOTRESTR_J:
  8999                                  		;pop	cx		; MSKK06 07/14/89
  9000                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  9001                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  9002                                  		;STOSB			; store it into resgroup
  9003                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  9004                                  		;jmp	GOTRESTR_j
  9005                                  ;PIPEERRSYNJ5_J:
  9006                                  		;pop	cx		; recover CX
  9007                                  		;jmp	short PIPEERRSYNJ5
  9008                                  
  9009                                  		; MSDOS 3.3
  9010                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  9011 00001C83 AC                      		lodsb
  9012 00001C84 3C0D                    		cmp	al,0Dh
  9013 00001C86 746E                    		jz	short GOTRESTR
  9014 00001C88 E8F6FC                  		call	DELIM
  9015 00001C8B 7469                    		jz	short GOTRESTR
  9016 00001C8D 3A06[6542]              		cmp	al,[SWITCHAR]
  9017 00001C91 7463                    		je	short GOTRESTR
  9018 00001C93 3C22                    		cmp	al,'"'
  9019 00001C95 7502                    		jne	short NO_ABRACKET
  9020 00001C97 FECD                    		dec	ch
  9021                                  NO_ABRACKET:
  9022 00001C99 AA                      		stosb
  9023 00001C9A EBE7                    		jmp	short SETREOUTSTR_LOOP
  9024                                  NOOUT:
  9025                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9026 00001C9C 3A06[E23E]              		cmp	al,[LABRACKET]
  9027 00001CA0 751F                    		jnz	short CHKPIPE
  9028 00001CA2 89F3                    		mov	bx,si		; Save loc of "<"
  9029 00001CA4 E8D2FC                  		call	SCANOFF
  9030                                  		; MSDOS 6.0
  9031                                  		;CMP	AL,[RABRACKET]	;AN040; was there no filename?
  9032                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9033                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9034 00001CA7 3C0D                    		cmp	al,0Dh
  9035 00001CA9 750B                    		jnz	short GOTREIFIL
  9036                                  REIN_ERRSET:				;AN040; set up for error
  9037 00001CAB C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9038 00001CAE C706[0C42]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9039 00001CB4 EB64                    		jmp	short PRESCANEND
  9040                                  GOTREIFIL:
  9041 00001CB6 57                      		push	di
  9042 00001CB7 BF[0C42]                		mov	di,RE_INSTR
  9043 00001CBA 89FB                    		mov	bx,di
  9044 00001CBC 06                      		push	es
  9045 00001CBD 0E                      		push	cs
  9046 00001CBE 07                      		pop	es		; store in TRANGROUP
  9047 00001CBF EBC2                    		jmp	short SETREOUTSTR_LOOP 
  9048                                  					; Get the input redirection name
  9049                                  CHKPIPE:
  9050 00001CC1 88C4                    		mov	ah,al
  9051                                  		;cmp	ah,'|'
  9052 00001CC3 80FC7C                  		cmp	ah,ALTPIPECHR
  9053 00001CC6 7406                    		je	short ISPIPE3
  9054 00001CC8 3A26[E13E]              		cmp	ah,[VBAR]
  9055 00001CCC 753F                    		jne	short CONTPRESCAN
  9056                                  ISPIPE3:
  9057                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9058                                  
  9059 00001CCE 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9060 00001CD4 7505                    		jne	short NOECHOPUSH
  9061 00001CD6 26D026EF0B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9062                                  NOECHOPUSH:
  9063 00001CDB 26FE065C0C              		inc	byte [es:PIPEFLAG]
  9064 00001CE0 E896FC                  		call	SCANOFF
  9065 00001CE3 3C0D                    		cmp	al,0Dh
  9066 00001CE5 740A                    		jz	short PIPEERRSYNJ5
  9067                                  		;cmp	al,'|'
  9068 00001CE7 3C7C                    		cmp	al,ALTPIPECHR
  9069 00001CE9 7406                    		jz	short PIPEERRSYNJ5
  9070 00001CEB 3A06[E13E]              		cmp	al,[VBAR]	; Double '|'?	
  9071 00001CEF 751C                    		jnz	short CONTPRESCAN
  9072                                  
  9073                                  PIPEERRSYNJ5:
  9074 00001CF1 06                      		push	es
  9075 00001CF2 1F                      		pop	ds
  9076 00001CF3 E93A02                  		jmp	PIPEERRSYN
  9077                                  
  9078                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9079                                  ; than just a : in the redir string.
  9080                                  
  9081                                  GOTRESTR:
  9082 00001CF6 86E0                    		xchg	ah,al
  9083 00001CF8 B03A                    		mov	al,':'
  9084 00001CFA 29FB                    		sub	bx,di		; compute negative of number of chars
  9085 00001CFC 83FBFF                  		cmp	bx,-1		; is there just a :?
  9086 00001CFF 7407                    		je	short NOTRAILCOL ; yep, don't change
  9087 00001D01 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9088 00001D05 7501                    		jne	short NOTRAILCOL
  9089 00001D07 4F                      		dec	di		; Back up over trailing ':'
  9090                                  NOTRAILCOL:
  9091 00001D08 30C0                    		xor	al,al
  9092 00001D0A AA                      		stosb			; NUL terminate the string
  9093 00001D0B 07                      		pop	es
  9094 00001D0C 5F                      		pop	di		; Remember the start
  9095                                  CONTPRESCAN:
  9096 00001D0D 8825                    		mov	[di],ah		; "delete" the redirection string
  9097 00001D0F 47                      		inc	di
  9098 00001D10 80FC0D                  		cmp	ah,0Dh
  9099 00001D13 7405                    		je	short PRESCANEND
  9100 00001D15 FEC1                    		inc	cl
  9101 00001D17 E929FF                  		jmp	PRESCANLP
  9102                                  PRESCANEND:
  9103 00001D1A 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9104 00001D20 7414                    		je	short ISNOPIPE
  9105                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9106 00001D22 BF800C                  		mov	di,PIPESTR
  9107 00001D25 26893E7E0C              		mov	word [es:PIPEPTR],di
  9108 00001D2A BE[C240]                		mov	si,COMBUF+2
  9109 00001D2D E849FC                  		call	SCANOFF
  9110                                  PIPESETLP:				; Transfer the pipe into the resident
  9111 00001D30 AC                      		lodsb			; pipe buffer
  9112 00001D31 AA                      		stosb
  9113 00001D32 3C0D                    		cmp	al,0Dh
  9114 00001D34 75FA                    		jnz	short PIPESETLP
  9115                                  ISNOPIPE:
  9116 00001D36 880E[C140]              		mov	[COMBUF+1],cl
  9117 00001D3A 26803E5C0C00            		cmp	byte [es:PIPEFLAG],0
  9118 00001D40 0E                      		push	cs
  9119 00001D41 07                      		pop	es
  9120 00001D42 C3                      		retn
  9121                                  
  9122                                  ; =============== S U B	R O U T	I N E =======================================
  9123                                  
  9124                                  CMD_COPY:
  9125 00001D43 BE[C240]                		mov	si,COMBUF+2
  9126 00001D46 E830FC                  		call	SCANOFF		; advance past separators...
  9127 00001D49 0336[B043]              		add	si,[PATHPOS]
  9128 00001D4D BF8100                  		mov	di,81h
  9129 00001D50 31C9                    		xor	cx,cx
  9130                                  CMDCOPY:
  9131 00001D52 AC                      		lodsb
  9132 00001D53 AA                      		stosb
  9133 00001D54 3C0D                    		cmp	al,0Dh
  9134 00001D56 7403                    		je	short COPY_DONE
  9135 00001D58 41                      		inc	cx
  9136 00001D59 EBF7                    		jmp	short CMDCOPY
  9137                                  COPY_DONE:
  9138 00001D5B 880E8000                		mov	[80h],cl
  9139 00001D5F C3                      		retn
  9140                                  
  9141                                  ; =============== S U B	R O U T	I N E =======================================
  9142                                  
  9143                                  TEST_APPEND:
  9144 00001D60 BB[C040]                		mov	bx,COMBUF	; barry can address
  9145 00001D63 BE[DB42]                		mov	si,IDLEN	; address command name, DS already set 	
  9146 00001D66 BAFFFF                  		mov	dx,-1
  9147 00001D69 B800AE                  		mov	ax,0AE00h
  9148 00001D6C CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9149                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9150                                  				; DX = FFFFh,[BX -> command line
  9151                                  				; Return: AL = FFh if this command is a TSR extension 
  9152                                  				;		   to COMMAND.COM
  9153                                  				; AL = 00h if the command should be executed as	usual
  9154 00001D6E 3C00                    		cmp	al,0
  9155 00001D70 C3                      		retn
  9156                                  
  9157                                  ;============================================================================
  9158                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9159                                  ;============================================================================
  9160                                  ; 05/10/2018 - Retro DOS v3.0
  9161                                  
  9162                                  ;	More misc routines
  9163                                  
  9164                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9165                                  
  9166                                  ; =============== S U B	R O U T	I N E =======================================
  9167                                  
  9168                                  SETPATH:
  9169                                  
  9170                                  ; ENTRY PathPos = ptr to string
  9171                                  ;       PathCnt = length of string
  9172                                  ;
  9173                                  ; EXIT  PathPos = ptr to string after pathname
  9174                                  ;       PathCnt = length of rest of string
  9175                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9176                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9177                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9178                                  ;
  9179                                  ;       A null character is dropped at the end of the pathname. If the
  9180                                  ;       character in that spot previously was CR, it is copied into the
  9181                                  ;       following byte. So there must be at least two two character 
  9182                                  ;       positions in the buffer following the pathname.
  9183                                  
  9184                                  		; MSDOS 6.0
  9185                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9186                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9187                                  
  9188                                  		; MSDOS 3.3
  9189 00001D71 BE8000                  		mov	si,80h
  9190 00001D74 AC                      		lodsb
  9191 00001D75 30E4                    		xor	ah,ah
  9192 00001D77 A3[AE43]                		mov	[PATHCNT],ax
  9193 00001D7A 8936[B043]              		mov	[PATHPOS],si
  9194                                  GETPATH:
  9195                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9196 00001D7E C606[6044]00            		mov	byte [DESTINFO],0
  9197 00001D83 C606[5C44]00            		mov	byte [DESTVARS],0
  9198 00001D88 8B36[B043]              		mov	si,[PATHPOS]	; SI = ptr to string
  9199 00001D8C 8B0E[AE43]              		mov	cx,[PATHCNT]	; CX = string length
  9200 00001D90 89F2                    		mov	dx,si		; DX = ptr to string
  9201 00001D92 E33D                    		jcxz	PATHDONE	; string length is zero, we're done
  9202 00001D94 51                      		push	cx		; save string length
  9203 00001D95 56                      		push	si		; save ptr to string
  9204 00001D96 E811FD                  		call	SWITCH
  9205                                  
  9206                                  ;       After Switch, SI has been scanned past any switches, and
  9207                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9208                                  
  9209 00001D99 A3[B243]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9210 00001D9C 5B                      		pop	bx		; BX = ptr to original string
  9211 00001D9D 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9212 00001D9F 59                      		pop	cx		; CX = string length
  9213 00001DA0 01D9                    		add	cx,bx		; CX = string length from current SI
  9214 00001DA2 89F2                    		mov	dx,si		; DX = ptr to current string
  9215                                  SKIPPATH:
  9216 00001DA4 E32B                    		jcxz	PATHDONE	; string length is zero, we're done
  9217 00001DA6 49                      		dec	cx		; CX = length left after next char
  9218 00001DA7 AC                      		lodsb			; AL = next char of string
  9219                                  					; SI = ptr to char after this one
  9220 00001DA8 E861FC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9221 00001DAB 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9222 00001DAD FE06[5C44]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9223                                  TESTPMETA:
  9224 00001DB1 3C3F                    		cmp	al,'?'
  9225 00001DB3 7505                    		jne	short TESTPSTAR	; char is not '?'
  9226 00001DB5 800E[6044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9227                                  TESTPSTAR:
  9228                                  		;cmp	al,'*'
  9229 00001DBA 3A06[ED3E]              		cmp	al,[STAR]
  9230 00001DBE 7505                    		jne	short TESTPDELIM ; char is not '*'
  9231 00001DC0 800E[6044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9232                                  TESTPDELIM:
  9233 00001DC5 E8B9FB                  		call	DELIM		; compare AL to all delimiters
  9234 00001DC8 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9235 00001DCA 3A06[6542]              		cmp	al,[SWITCHAR]
  9236 00001DCE 75D4                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9237                                  PATHDONEDEC:
  9238 00001DD0 4E                      		dec	si		; SI = ptr to char after pathname
  9239                                  PATHDONE:
  9240 00001DD1 30C0                    		xor	al,al		; AL = NULL
  9241 00001DD3 8604                    		xchg	al,[si]		; place NULL after pathname
  9242 00001DD5 46                      		inc	si		; SI = ptr to byte after NULL
  9243 00001DD6 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9244 00001DD8 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9245 00001DDA 8804                    		mov	[si],al		; save EOL after NULL
  9246                                  NOPSTORE:
  9247 00001DDC 8936[B043]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9248 00001DE0 890E[AE43]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9249                                  SETPATH_RETN:
  9250 00001DE4 C3                      		retn
  9251                                  
  9252                                  ; ---------------------------------------------------------------------------
  9253                                  
  9254                                  PGETARG:
  9255 00001DE5 BE8000                  		mov	si,80h
  9256 00001DE8 AC                      		lodsb
  9257 00001DE9 08C0                    		or	al,al
  9258 00001DEB 74F7                    		jz	short SETPATH_RETN
  9259 00001DED E80300                  		call	PSCANOFF
  9260 00001DF0 3C0D                    		cmp	al,0Dh
  9261 00001DF2 C3                      		retn
  9262                                  
  9263                                  ; ---------------------------------------------------------------------------
  9264                                  
  9265                                  PSCANOFF:
  9266 00001DF3 AC                      		lodsb
  9267 00001DF4 E88AFB                  		call	DELIM
  9268 00001DF7 7504                    		jnz	short PSCANOFFD
  9269 00001DF9 3C3B                    		cmp	al,';'
  9270 00001DFB 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9271                                  PSCANOFFD:
  9272 00001DFD 4E                      		dec	si		; Point to first non-delimiter
  9273 00001DFE C3                      		retn
  9274                                  
  9275                                  ; =============== S U B	R O U T	I N E =======================================
  9276                                  
  9277                                  IOSET:
  9278                                  		; ALL REGISTERS PRESERVED
  9279 00001DFF 1E                      		push	ds
  9280 00001E00 52                      		push	dx
  9281 00001E01 50                      		push	ax
  9282 00001E02 53                      		push	bx
  9283 00001E03 51                      		push	cx
  9284 00001E04 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  9285 00001E09 803E5C0C00              		cmp	byte [PIPEFLAG],0
  9286 00001E0E 750D                    		jne	short NOREDIR
  9287 00001E10 F606FA0BFF              		test	byte [IFFLAG],0FFh
  9288 00001E15 7506                    		jnz	short NOREDIR
  9289 00001E17 E80900                  		call	TESTDOREIN
  9290 00001E1A E85400                  		call	TESTDOREOUT
  9291                                  NOREDIR:
  9292 00001E1D 59                      		pop	cx
  9293 00001E1E 5B                      		pop	bx
  9294 00001E1F 58                      		pop	ax
  9295 00001E20 5A                      		pop	dx
  9296 00001E21 1F                      		pop	ds
  9297                                  IOSET_RETN:
  9298 00001E22 C3                      		retn
  9299                                  
  9300                                  ; =============== S U B	R O U T	I N E =======================================
  9301                                  
  9302                                  TESTDOREIN:
  9303 00001E23 2E803E[0C42]00          		cmp	byte [cs:RE_INSTR],0
  9304 00001E29 74F7                    		jz	short IOSET_RETN
  9305 00001E2B 1E                      		push	ds
  9306 00001E2C 0E                      		push	cs
  9307 00001E2D 1F                      		pop	ds
  9308 00001E2E BA[0C42]                		mov	dx,RE_INSTR
  9309 00001E31 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9310 00001E34 89C3                    		mov	bx,ax
  9311 00001E36 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9312                                  				; DS:DX	-> ASCIZ filename
  9313                                  				; AL = access mode
  9314                                  				; 0 - read
  9315 00001E38 1F                      		pop	ds
  9316 00001E39 720B                    		jb	short REDIRERR
  9317 00001E3B 89C3                    		mov	bx,ax
  9318 00001E3D B0FF                    		mov	al,0FFh
  9319                                  
  9320                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9321                                  ; spot. We invalidate the new JFN we got.
  9322                                  
  9323                                  		;xchg	al,[bx+18h]
  9324 00001E3F 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9325 00001E42 A21800                  		mov	byte [PDB.JFN_TABLE],al
  9326 00001E45 C3                      		retn
  9327                                  
  9328                                  ; ---------------------------------------------------------------------------
  9329                                  
  9330                                  ; We had some kind of error on the redirection. Figure out what the
  9331                                  ; appropriate message should be; BX has the system call that failed
  9332                                  
  9333                                  REDIRERR:
  9334 00001E46 0E                      		push	cs
  9335 00001E47 1F                      		pop	ds
  9336                                  		;call	TriageError
  9337 00001E48 E87900                  		call	GET_EXT_ERR_NUMBER
  9338                                  
  9339                                  ; At this point, we have recognized the network-generated access denied error.
  9340                                  ; The correct message is in DX
  9341                                  
  9342 00001E4B 83F841                  		cmp	ax,65
  9343 00001E4E 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9344 00001E50 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9345 00001E53 7406                    		jz	short OPENERR
  9346 00001E55 BA[5E38]                		mov	dx,FULDIRPTR
  9347                                  _CERRORJ:
  9348 00001E58 E9C8FD                  		jmp	CERROR
  9349                                  
  9350                                  OPENERR:
  9351                                  ; The system call was an OPEN. Report either file not found or path not found.
  9352                                  
  9353                                  		; MSDOS 6.0
  9354                                  		;mov	msg_disp_class,ext_msg_class 
  9355                                  		;			;AN000; set up extended error msg class
  9356                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9357                                  		;			;AC000; get extended message pointer
  9358                                  		;mov	Extend_Buf_ptr,ax	
  9359                                  		;			;AN000; get message number in control block
  9360                                  		;JMP	CERROR
  9361                                  
  9362                                  		; MSDOS 3.3
  9363 00001E5B BA[E837]                		mov	dx,FNOTFOUNDPTR
  9364                                  		;cmp	ax,2
  9365 00001E5E 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9366 00001E61 74F5                    		je	short _CERRORJ
  9367 00001E63 BA[0D38]                		mov	dx,ACCDENPTR
  9368                                  		;cmp	ax,5 ; Access denied error
  9369 00001E66 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9370 00001E69 74ED                    		je	short _CERRORJ
  9371                                  			; ERROR_PATH_NOT_FOUND
  9372 00001E6B BA[FB37]                		mov	dx,PNOTFOUNDPTR
  9373 00001E6E E9B2FD                  		jmp	CERROR
  9374                                  
  9375                                  ; =============== S U B	R O U T	I N E =======================================
  9376                                  
  9377                                  TESTDOREOUT:
  9378 00001E71 803E0B0C00              		cmp	byte [RE_OUTSTR],0
  9379 00001E76 743D                    		je	short NOREOUT
  9380                                  
  9381                                  REOUTEXISTS:
  9382 00001E78 803E0A0C00              		cmp	byte [RE_OUT_APP],0
  9383 00001E7D 741F                    		je	short REOUTCRT
  9384                                  
  9385 00001E7F BA0B0C                  		mov	dx,RE_OUTSTR
  9386                                  
  9387                                  		; MSDOS 6.0
  9388                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9389                                  		;mov	ax,3D02h
  9390                                  
  9391                                  		; MSDOS 3.3
  9392 00001E82 B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9393                                  	
  9394                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9395 00001E85 50                      		push	ax
  9396 00001E86 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9397                                  				; DS:DX	-> ASCIZ filename
  9398                                  				; AL = access mode
  9399                                  				; 1 - write
  9400 00001E88 5B                      		pop	bx
  9401 00001E89 720D                    		jc	short OPENWRITEERROR
  9402                                  
  9403                                  		; MSDOS 6.0
  9404                                  		;MOV	BX,AX
  9405                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9406                                  		;INT	21h			;AN035;
  9407                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9408                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9409                                  		;
  9410                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9411                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9412                                  		;MOV	DX,CX			;AC011;
  9413                                  		;INT	21h
  9414                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9415                                  		;POP	DS			;AN011;
  9416                                  		;assume	DS:Trangroup		;AN011;
  9417                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9418                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9419                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9420                                  		;INT	21h			;AN011;
  9421                                  		;JC	OpenWriteError		;AN011; If error, exit
  9422                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9423                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9424                                  		;
  9425                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9426                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9427                                  		;assume	DS:Resgroup		;AN011;
  9428                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9429                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9430                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9431                                  		;MOV	DX,CX			;AN011;
  9432                                  		;INT	21h			;AN011;
  9433                                  		;JMP	SHORT SET_REOUT
  9434                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9435                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9436                                  		;assume	DS:Resgroup		;AN017;
  9437                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9438                                  		;XOR	CX,CX			;AN017; Offset is 0
  9439                                  		;MOV	DX,CX			;AN017;
  9440                                  		;INT	21h			;AN017;
  9441                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9442                                  
  9443                                  		; MSDOS 3.3
  9444 00001E8B 31D2                    		xor	dx,dx
  9445 00001E8D 31C9                    		xor	cx,cx
  9446 00001E8F 89C3                    		mov	bx,ax
  9447 00001E91 B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9448 00001E94 CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9449                                  				; AL = method: offset from end of file
  9450 00001E96 EB15                    		jmp	short SET_REOUT
  9451                                  		
  9452                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9453                                  OPENWRITEERROR:	
  9454                                  		;cmp	ax,5
  9455 00001E98 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9456 00001E9B F9                      		stc
  9457 00001E9C 74A8                    		je	short REDIRERR
  9458                                  REOUTCRT:	
  9459 00001E9E BA0B0C                  		mov	dx,RE_OUTSTR
  9460 00001EA1 31C9                    		xor	cx,cx
  9461 00001EA3 B43C                    		mov	ah,CREAT ; 3Ch
  9462 00001EA5 50                      		push	ax
  9463 00001EA6 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9464                                  				; CX = attributes for file
  9465                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9466 00001EA8 5B                      		pop	bx
  9467 00001EA9 729B                    		jc	short REDIRERR
  9468                                  NOREDIRERR:
  9469 00001EAB 89C3                    		mov	bx,ax
  9470                                  SET_REOUT:
  9471                                  
  9472                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9473                                  ; spot. We invalidate the new JFN we got.
  9474                                  
  9475 00001EAD B0FF                    		mov	al,0FFh
  9476                                  		;xchg	al,[bx+18h]
  9477 00001EAF 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9478 00001EB2 A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9479                                  NOREOUT:
  9480 00001EB5 C3                      		retn
  9481                                  
  9482                                  ; =============== S U B	R O U T	I N E =======================================
  9483                                  
  9484                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9485                                  ; registers
  9486                                  
  9487                                  DSTRLEN:
  9488 00001EB6 50                      		push	ax
  9489 00001EB7 31C9                    		xor	cx,cx
  9490 00001EB9 FC                      		cld
  9491                                  DLOOP:
  9492 00001EBA AC                      		lodsb
  9493 00001EBB 41                      		inc	cx
  9494 00001EBC 08C0                    		or	al,al
  9495 00001EBE 75FA                    		jnz	short DLOOP
  9496 00001EC0 29CE                    		sub	si,cx
  9497 00001EC2 58                      		pop	ax
  9498                                  TRIAGEERR_RETN:
  9499 00001EC3 C3                      		retn
  9500                                  
  9501                                  ; =============== S U B	R O U T	I N E =======================================
  9502                                  
  9503                                  ;Break	<Extended error support>
  9504                                  
  9505                                  TriageError:  ; MSDOS 6.0
  9506                                  
  9507                                  ;
  9508                                  ; TriageError will examine the return from a carry-set system call and
  9509                                  ; return the correct error if applicable.
  9510                                  ;
  9511                                  ;   Inputs:	outputs from a carry-settable system call
  9512                                  ;		No system calls may be done in the interrim
  9513                                  ;   Outputs:	If carry was set on input
  9514                                  ;		    carry set on output
  9515                                  ;		    DX contains trangroup offset to printf message
  9516                                  ;		else
  9517                                  ;		    No registers changed
  9518                                  ;
  9519                                  
  9520                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9521                                  
  9522                                  GET_EXT_ERR_NUMBER:
  9523 00001EC4 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9524 00001EC6 9C                      		pushf
  9525 00001EC7 53                      		push	bx
  9526 00001EC8 51                      		push	cx
  9527 00001EC9 56                      		push	si
  9528 00001ECA 57                      		push	di
  9529 00001ECB 55                      		push	bp
  9530 00001ECC 06                      		push	es
  9531 00001ECD 1E                      		push	ds
  9532 00001ECE 50                      		push	ax
  9533 00001ECF 52                      		push	dx
  9534                                  		;mov	ah,59h
  9535 00001ED0 B459                    		mov	ah,GETEXTENDEDERROR
  9536 00001ED2 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9537                                  				; BX = version code (0000h for DOS 3.x)
  9538 00001ED4 59                      		pop	cx
  9539 00001ED5 5B                      		pop	bx		; restore original AX
  9540 00001ED6 BA[0D38]                		mov	dx,ACCDENPTR
  9541 00001ED9 83F841                  		cmp	ax,65		; network access denied?
  9542 00001EDC 7404                    		je	short NOMOVE	; Yes, return it.
  9543 00001EDE 89D8                    		mov	ax,bx
  9544 00001EE0 89CA                    		mov	dx,cx
  9545                                  NOMOVE:
  9546 00001EE2 1F                      		pop	ds
  9547 00001EE3 07                      		pop	es
  9548 00001EE4 5D                      		pop	bp
  9549 00001EE5 5F                      		pop	di
  9550 00001EE6 5E                      		pop	si
  9551 00001EE7 59                      		pop	cx
  9552 00001EE8 5B                      		pop	bx
  9553 00001EE9 9D                      		popf
  9554 00001EEA C3                      		retn
  9555                                  
  9556                                  ; =============== S U B	R O U T	I N E =======================================
  9557                                  
  9558                                  		; Far call from resident portion/segment of COMMAND.COM
  9559                                  
  9560                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9561                                  
  9562                                  TRIAGE_INIT:
  9563                                  		;call	TriageError
  9564 00001EEB E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9565 00001EEE CB                      		retf
  9566                                  
  9567                                  ;============================================================================
  9568                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9569                                  ;============================================================================
  9570                                  ; 03/10/2018 - Retro DOS v3.0
  9571                                  
  9572                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9573                                  
  9574                                  ; =============== S U B	R O U T	I N E =======================================
  9575                                  
  9576                                  SINGLETEST:
  9577 00001EEF 1E                      		push	ds
  9578 00001EF0 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  9579 00001EF5 833EF50B00              		cmp	word [SINGLECOM],0
  9580 00001EFA 7406                    		jz	short TESTDONE
  9581 00001EFC 813EF50BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9582                                  TESTDONE:
  9583 00001F02 1F                      		pop	ds
  9584 00001F03 C3                      		retn
  9585                                  
  9586                                  ; =============== S U B	R O U T	I N E =======================================
  9587                                  
  9588                                  SETREST1:
  9589 00001F04 B001                    		mov	al,1
  9590                                  
  9591                                  ; ---------------------------------------------------------------------------
  9592                                  
  9593                                  SETREST:
  9594 00001F06 1E                      		push	ds
  9595 00001F07 8E1E[6142]              		mov	ds,[RESSEG]
  9596 00001F0B A2F30B                  		mov	byte [RESTDIR],al
  9597 00001F0E 1F                      		pop	ds
  9598 00001F0F C3                      		retn
  9599                                  
  9600                                  ; =============== S U B	R O U T	I N E =======================================
  9601                                  
  9602                                  ; Note that we need to handle the same thing that RestDir handles: the
  9603                                  ; requirement that we try only once to restore the user's environment after
  9604                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9605                                  ; disappear, we just give up.
  9606                                  
  9607                                  PIPEDEL:
  9608 00001F10 1E                      		push	ds
  9609 00001F11 52                      		push	dx
  9610 00001F12 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
  9611 00001F17 BA5E0C                  		mov	dx,PIPE1	; Clean up in case ^C
  9612 00001F1A B441                    		mov	ah,UNLINK ; 41h 
  9613 00001F1C CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9614                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9615                                  				;		(no wildcards allowed)
  9616 00001F1E BA6E0C                  		mov	dx,PIPE2
  9617 00001F21 B441                    		mov	ah,UNLINK ; 41h
  9618 00001F23 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9619                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9620                                  				;		(no wildcards allowed)
  9621 00001F25 5A                      		pop	dx
  9622 00001F26 E85D04                  		call	PIPEOFF
  9623 00001F29 C6065D0C00              		mov	byte [PIPEFILES],0
  9624 00001F2E 1F                      		pop	ds
  9625 00001F2F C3                      		retn
  9626                                  
  9627                                  ; ---------------------------------------------------------------------------
  9628                                  
  9629                                  PIPEERRSYN:
  9630 00001F30 BA[683C]                		mov	dx,SYNTMESPTR
  9631 00001F33 E8DAFF                  		call	PIPEDEL
  9632 00001F36 0E                      		push	cs
  9633 00001F37 1F                      		pop	ds
  9634 00001F38 E9E8FC                  		jmp	CERROR
  9635                                  
  9636                                  ; ---------------------------------------------------------------------------
  9637                                  
  9638                                  PIPERR:
  9639 00001F3B 9C                      		pushf
  9640                                  		;invoke	TRIAGEERROR
  9641 00001F3C E885FF                  		call	GET_EXT_ERR_NUMBER
  9642 00001F3F 50                      		push	ax		; Save results from TriageError
  9643 00001F40 52                      		push	dx
  9644 00001F41 BA[C23C]                		mov	dx,PIPEEMESPTR
  9645 00001F44 E8C9FF                  		call	PIPEDEL
  9646 00001F47 0E                      		push	cs
  9647 00001F48 1F                      		pop	ds
  9648 00001F49 E86E15                  		call	STD_EPRINTF
  9649 00001F4C 5A                      		pop	dx		; Restore results from TriageError
  9650 00001F4D 58                      		pop	ax
  9651 00001F4E 9D                      		popf
  9652 00001F4F 83F841                  		cmp	ax,65
  9653 00001F52 7503                    		jnz	short TCOMMANDJ
  9654 00001F54 E9CCFC                  		jmp	CERROR
  9655                                  
  9656                                  TCOMMANDJ:
  9657 00001F57 E9AAE1                  		jmp	TCOMMAND
  9658                                  
  9659                                  PIPEPROCSTRT:
  9660 00001F5A 8E1E[6142]              		mov	ds,[RESSEG]
  9661 00001F5E FE065D0C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9662                                  
  9663                                  		; MSDOS 6.0
  9664                                  		;push	es
  9665                                  		;push	di
  9666                                  		;push	ds
  9667                                  		;push	si
  9668                                  		;
  9669                                  		;push	ds
  9670                                  		;push	es
  9671                                  		;pop	ds				;ds = TRANGROUP
  9672                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9673                                  ;
  9674                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9675                                  ;so the routine is not really general
  9676                                  ;
  9677                                  		;call	Find_Name_In_Environment	;es:di points at path
  9678                                  		;pop	ds				;ds = DATARES again
  9679                                  		;jc	no_temp_path
  9680                                  		;
  9681                                  		;push	ds
  9682                                  		;push	es
  9683                                  		;pop	ds
  9684                                  		;pop	es				;swap ds and es
  9685                                  		;mov	si,di				;ds:si points at path
  9686                                  		;
  9687                                  		;call	skip_white			;skip white space chars
  9688                                  ;
  9689                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9690                                  ;
  9691                                  		;call	copy_pipe_path			;copy the pipe path
  9692                                  		;
  9693                                  ;
  9694                                  ;Check if the TEMP path is valid
  9695                                  ;
  9696                                  		;push	es
  9697                                  		;pop	ds				;ds = DATARES
  9698                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9699                                  		;mov	ax, (CHMOD shl 8) or 0
  9700                                  		;int	21h
  9701                                  		;jc	no_temp_path
  9702                                  		;
  9703                                  		;test	cx,10h				;is it a directory?
  9704                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9705                                  		;
  9706                                  		;stc					;no, indicate fail
  9707                                  no_temp_path:
  9708                                  		;pop	si
  9709                                  		;pop	ds
  9710                                  		;pop	di
  9711                                  		;pop	es
  9712                                  		;jnc	crt_temp			;path found, create tempfiles
  9713                                  
  9714                                  		; MSDOS 3.3
  9715 00001F62 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9716 00001F64 CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9717 00001F66 2E0206[E03E]            		add	al,[cs:CAPITAL_A]
  9718 00001F6B A26E0C                  		mov	byte [PIPE2],al		; Make pipe files in root of def drv
  9719 00001F6E BB5E0C                  		mov	bx,PIPE1
  9720 00001F71 8807                    		mov	[bx],al
  9721 00001F73 30E4                    		xor	ah,ah			; nul terminate path names
  9722 00001F75 8826610C                		mov	byte [PIPE1+3],ah
  9723 00001F79 8826710C                		mov	byte [PIPE2+3],ah
  9724                                  
  9725                                  		; MSDOS 6.0
  9726                                  ;SR;
  9727                                  ; We want to create temp files in the current directory rather than in the 
  9728                                  ;root of the drive. This is because the number of files that can be present
  9729                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9730                                  ;
  9731                                  		;mov	ah,'.'
  9732                                  		;mov	Pipe1,ah
  9733                                  		;mov	Pipe2,ah
  9734                                  		;xor	ah,ah
  9735                                  		;mov	Pipe1+1,ah
  9736                                  		;mov	Pipe2+1,ah		;create files in current dir
  9737                                  
  9738                                  ;crt_temp:
  9739                                  		; MSDOS 6.0
  9740                                  		;mov	dx,offset DATARES:Pipe1
  9741                                  		;mov	dx,PIPE1
  9742                                  	
  9743                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9744 00001F7D 89DA                    		mov	dx,bx
  9745 00001F7F 31C9                    		xor	cx,cx
  9746 00001F81 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9747 00001F83 CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9748                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9749                                  			; receive generated filename
  9750                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9751 00001F85 72B4                    		jc	short PIPERR	; Couldn't create
  9752 00001F87 89C3                    		mov	bx,ax
  9753 00001F89 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9754 00001F8B CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9755                                  				; BX = file handle
  9756 00001F8D BA6E0C                  		mov	dx,PIPE2
  9757 00001F90 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9758 00001F92 CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9759                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9760                                  			; receive generated filename
  9761                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9762 00001F94 72A5                    		jc	short PIPERR
  9763 00001F96 89C3                    		mov	bx,ax
  9764 00001F98 B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9765 00001F9A CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9766                                  					; BX = file handle
  9767                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9768 00001F9C E884FE                  		call	TESTDOREIN
  9769 00001F9F 8B367E0C                		mov	si,word [PIPEPTR]
  9770 00001FA3 833EF50BFF              		cmp	word [SINGLECOM],-1
  9771 00001FA8 7506                    		jne	short NOSINGP
  9772 00001FAA C706F50B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9773                                  NOSINGP:
  9774 00001FB0 EB30                    		jmp	short FIRSTPIPE
  9775                                  
  9776                                  ; ---------------------------------------------------------------------------
  9777                                  
  9778                                  PIPEPROC:
  9779 00001FB2 8026EF0BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9780 00001FB7 8B367E0C                		mov	si,word [PIPEPTR]
  9781 00001FBB AC                      		lodsb
  9782                                  		;cmp	al,'|'		
  9783 00001FBC 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9784 00001FBE 740A                    		je	short ISPIPE1	; Yes
  9785 00001FC0 2E3A06[E13E]            		cmp	al,[cs:VBAR]
  9786 00001FC5 7403                    		je	short ISPIPE1
  9787 00001FC7 E98900                  		jmp	PIPEEND		; Pipe done
  9788                                  ISPIPE1:
  9789 00001FCA 8B16010D                		mov	dx,word [INPIPEPTR] ; Get the input file name
  9790 00001FCE B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9791 00001FD1 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9792                                  				; DS:DX	-> ASCIZ filename
  9793                                  				; AL = access mode
  9794                                  				; 0 - read
  9795                                  PIPEERRJ:
  9796 00001FD3 7303                    		jnc	short NO_PIPEERR
  9797 00001FD5 E963FF                  		jmp	PIPERR		; Lost the pipe file
  9798                                  NO_PIPEERR:
  9799 00001FD8 89C3                    		mov	bx,ax
  9800 00001FDA B0FF                    		mov	al,0FFh
  9801                                  		;xchg	al,[bx+18h]
  9802 00001FDC 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9803 00001FDF A21800                  		mov	byte [PDB.JFN_TABLE],al	; Redirect
  9804                                  FIRSTPIPE:
  9805 00001FE2 BF[C240]                		mov	di,COMBUF+2
  9806 00001FE5 31C9                    		xor	cx,cx
  9807 00001FE7 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9808 00001FEA 7503                    		jne	short PIPEOK1
  9809                                  PIPEERRSYNJ:
  9810 00001FEC E941FF                  		jmp	PIPEERRSYN
  9811                                  PIPEOK1:
  9812 00001FEF 2EA0[E13E]              		mov	al,[cs:VBAR]
  9813 00001FF3 3804                    		cmp	[si],al		; '||'
  9814 00001FF5 74F5                    		je	short PIPEERRSYNJ
  9815                                  		;cmp	byte [si],'|'
  9816 00001FF7 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9817 00001FFA 74F0                    		je	short PIPEERRSYNJ
  9818                                  PIPECOMLP:
  9819 00001FFC AC                      		lodsb
  9820 00001FFD AA                      		stosb
  9821 00001FFE 3C0D                    		cmp	al,0Dh
  9822 00002000 743F                    		je	short LASTPIPE
  9823 00002002 41                      		inc	cx
  9824                                  		;cmp	al,'|'
  9825 00002003 3C7C                    		cmp	al,ALTPIPECHR
  9826 00002005 7407                    		je	short ISPIPE2
  9827 00002007 2E3A06[E13E]            		cmp	al,[cs:VBAR]
  9828 0000200C 75EE                    		jne	short PIPECOMLP
  9829                                  ISPIPE2:
  9830 0000200E 26C645FF0D              		mov	byte [es:di-1],0Dh
  9831 00002013 49                      		dec	cx
  9832 00002014 2E880E[C140]            		mov	[cs:COMBUF+1],cl
  9833 00002019 4E                      		dec	si
  9834 0000201A 89367E0C                		mov	word [PIPEPTR],si	; On to next pipe element
  9835 0000201E 8B16030D                		mov	dx,word [OUTPIPEPTR]
  9836 00002022 51                      		push	cx
  9837 00002023 31C9                    		xor	cx,cx
  9838 00002025 B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9839 00002028 CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9840                                  				; CX = attributes for file
  9841                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9842 0000202A 59                      		pop	cx
  9843 0000202B 72A6                    		jc	short PIPEERRJ		; Lost the file
  9844 0000202D 89C3                    		mov	bx,ax
  9845 0000202F B0FF                    		mov	al,0FFh
  9846                                  		;xchg	al,[bx+18h]
  9847 00002031 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9848 00002034 A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9849 00002037 8716010D                		xchg	dx,word [INPIPEPTR]	; Swap for next element of pipe
  9850 0000203B 8916030D                		mov	word [OUTPIPEPTR],dx
  9851 0000203F EB0D                    		jmp	short PIPECOM
  9852                                  LASTPIPE:
  9853 00002041 2E880E[C140]            		mov	[cs:COMBUF+1],cl 
  9854 00002046 4E                      		dec	si
  9855 00002047 89367E0C                		mov	word [PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9856 0000204B E823FE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9857                                  PIPECOM:
  9858 0000204E 0E                      		push	cs
  9859 0000204F 1F                      		pop	ds
  9860 00002050 E965E2                  		jmp	NOPIPEPROC	; Process the pipe element
  9861                                  PIPEEND:
  9862 00002053 E8BAFE                  		call	PIPEDEL
  9863 00002056 813EF50B00F0            		cmp	word [SINGLECOM],0F000h
  9864 0000205C 7506                    		jnz	short NOSINGP2
  9865 0000205E C706F50BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
  9866                                  NOSINGP2:
  9867 00002064 E99DE0                  		jmp	TCOMMAND
  9868                                  
  9869                                  ; =============== S U B	R O U T	I N E =======================================
  9870                                  
  9871                                  ; Date and time are set during initialization and use
  9872                                  ; this routines since they need to do a long return
  9873                                  
  9874                                  DATINIT:
  9875 00002067 2E8C1E[6142]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
  9876 0000206C 06                      		push	es
  9877 0000206D 1E                      		push	ds		; Going to use the previous stack
  9878 0000206E 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
  9879 00002070 8EC0                    		mov	es,ax
  9880 00002072 8ED8                    		mov	ds,ax
  9881                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
  9882 00002074 BA[E84C]                		mov	dx,INTERNATVARS
  9883 00002077 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  9884 0000207A CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9885                                  				; get current-country info
  9886                                  				; DS:DX	-> buffer for returned info
  9887                                  		; 20/10/2018
  9888 0000207C C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
  9889 00002082 C606[C040]80            		mov	byte [COMBUF],128 ; Init COMBUF
  9890 00002087 C706[C140]010D          		mov	word [COMBUF+1],0D01h
  9891 0000208D E86C00                  		call	DATE
  9892 00002090 E88001                  		call	CTIME
  9893 00002093 1F                      		pop	ds
  9894 00002094 07                      		pop	es
  9895 00002095 CB                      		retf
  9896                                  
  9897                                  ; =============== S U B	R O U T	I N E =======================================
  9898                                  
  9899                                  ; MSDOS 6.0
  9900                                  
  9901                                  ; ****************************************************************
  9902                                  ; *
  9903                                  ; * ROUTINE:	 DATE - Set system date
  9904                                  ; *
  9905                                  ; * FUNCTION:	 If a date is specified, set the system date,
  9906                                  ; *		 otherwise display the current system date and
  9907                                  ; *		 prompt the user for a new date.  If an invalid
  9908                                  ; *		 date is specified, issue an error message and
  9909                                  ; *		 prompt for a new date.  If the user enters
  9910                                  ; *		 nothing when prompted for a date, terminate.
  9911                                  ; *
  9912                                  ; * INPUT:	 command line at offset 81H
  9913                                  ; *
  9914                                  ; * OUTPUT:	 none
  9915                                  ; *
  9916                                  ; ****************************************************************
  9917                                  
  9918                                  ;assume	ds:trangroup,es:trangroup
  9919                                  ;
  9920                                  ;DATE:
  9921                                  ;	MOV	SI,81H				; Accepting argument for date inline
  9922                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
  9923                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9924                                  ;	xor	dx,dx				;AN000;
  9925                                  ;	invoke	cmd_parse			;AC000; call parser
  9926                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9927                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
  9928                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9929                                  ;	jne	daterr				;AN000; yes - go issue message
  9930                                  ;	JMP	short COMDAT			;AC000; we have a date
  9931                                  ;
  9932                                  ;PRMTDAT:
  9933                                  ;	; Print "Current date is
  9934                                  ;
  9935                                  ;	invoke	GetDate 			;AN000; get date  for output
  9936                                  ;	xchg	dh,dl				;AN000; switch month & day
  9937                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
  9938                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
  9939                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
  9940                                  ;	invoke	std_printf
  9941                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
  9942                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
  9943                                  ;
  9944                                  ;GET_NEW_DATE:					;AN000;
  9945                                  ;	call	getdat				;AC000; prompt user for date
  9946                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9947                                  ;	jz	date_end			;AC000; yes - exit
  9948                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9949                                  ;	jne	daterr				;AN000; yes - go issue message
  9950                                  ;COMDAT:
  9951                                  ;	mov	cx,date_year			;AC000; get parts of date in
  9952                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
  9953                                  ;	mov	dl,date_day			;AC000;    date function call.
  9954                                  ;	push	cx				;AC000; save date
  9955                                  ;	push	dx				;AC000;
  9956                                  ;	mov	cx,1				;AC000; set 1 positional entered
  9957                                  ;	xor	dx,dx				;AN029;
  9958                                  ;	invoke	cmd_parse			;AN029; call parser
  9959                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
  9960                                  ;	pop	dx				;AC000; retrieve date
  9961                                  ;	pop	cx				;AC000;
  9962                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
  9963                                  ;	MOV	AH,SET_DATE			;yes - set date
  9964                                  ;	INT	21h
  9965                                  ;	OR	AL,AL
  9966                                  ;	JNZ	DATERR
  9967                                  ;date_end:
  9968                                  ;	ret
  9969                                  ;
  9970                                  ;DATERR:
  9971                                  ;	invoke	crlf2				;AN028; print out a blank line
  9972                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
  9973                                  ;	invoke	std_printf
  9974                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
  9975                                  
  9976                                  ; =============== S U B	R O U T	I N E =======================================
  9977                                  
  9978                                  ; MSDOS 6.0
  9979                                  
  9980                                  ; TIME gets and sets the time
  9981                                  
  9982                                  ; ****************************************************************
  9983                                  ; *
  9984                                  ; * ROUTINE:	 TIME - Set system time
  9985                                  ; *
  9986                                  ; * FUNCTION:	 If a time is specified, set the system time,
  9987                                  ; *		 otherwise display the current system time and
  9988                                  ; *		 prompt the user for a new time.  If an invalid
  9989                                  ; *		 time is specified, issue an error message and
  9990                                  ; *		 prompt for a new time.  If the user enters
  9991                                  ; *		 nothing when prompted for a time, terminate.
  9992                                  ; *
  9993                                  ; * INPUT:	 command line at offset 81H
  9994                                  ; *
  9995                                  ; * OUTPUT:	 none
  9996                                  ; *
  9997                                  ; ****************************************************************
  9998                                  
  9999                                  ;assume	ds:trangroup,es:trangroup
 10000                                  ;
 10001                                  ;CTIME:
 10002                                  ;	MOV	SI,81H				; Accepting argument for time inline
 10003                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
 10004                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10005                                  ;	xor	dx,dx				;AN000;
 10006                                  ;	invoke	cmd_parse			;AC000; call parser
 10007                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10008                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
 10009                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10010                                  ;	jne	timerr				;AN000; yes - go issue message
 10011                                  ;	JMP	short COMTIM			;AC000; we have a time
 10012                                  ;
 10013                                  ;PRMTTIM:
 10014                                  ;	;Printf "Current time is ... "
 10015                                  ;
 10016                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10017                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10018                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10019                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10020                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10021                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10022                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10023                                  ;	invoke	std_printf
 10024                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10025                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10026                                  ;
 10027                                  ;GET_NEW_TIME:
 10028                                  ;	call	gettim				;AC000;
 10029                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10030                                  ;	jz	time_end			;AC000;
 10031                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10032                                  ;	jne	timerr				;AN000; yes - go issue message
 10033                                  ;
 10034                                  ;COMTIM:
 10035                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10036                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10037                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10038                                  ;	mov	dl,time_fraction		;AC000;
 10039                                  ;	push	cx				;AC000; save time
 10040                                  ;	push	dx				;AC000;
 10041                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10042                                  ;	xor	dx,dx				;AN029;
 10043                                  ;	invoke	cmd_parse			;AN029; call parser
 10044                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10045                                  ;	pop	dx				;AC000; retieve time
 10046                                  ;	pop	cx				;AC000;
 10047                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10048                                  ;
 10049                                  ;SAVTIM:
 10050                                  ;	MOV	AH,SET_TIME
 10051                                  ;	INT	21h
 10052                                  ;	OR	AL,AL
 10053                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10054                                  ;
 10055                                  ;TIME_END:
 10056                                  ;
 10057                                  ;	ret
 10058                                  ;
 10059                                  ;TIMERR:
 10060                                  ;	invoke	crlf2				;AN028; print out a blank line
 10061                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10062                                  ;	invoke	std_printf			; Print error message
 10063                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10064                                  
 10065                                  ; =============== S U B	R O U T	I N E =======================================
 10066                                  
 10067                                  ; MSDOS 6.0
 10068                                  
 10069                                  ;
 10070                                  ; Set the special flag in the INIT flag to the value in CX.
 10071                                  ;
 10072                                  
 10073                                  ;SetInitFlag:
 10074                                  ;	mov	ds,[RESSEG]
 10075                                  ;assume ds:resgroup
 10076                                  ;	and	InitFlag,NOT initSpecial
 10077                                  ;	or	InitFlag,cL
 10078                                  ;	push	cs
 10079                                  ;	pop	ds
 10080                                  ;	return
 10081                                  ;
 10082                                  ;Public	PipeOff
 10083                                  ;PipeOff:
 10084                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10085                                  ;	SaveReg <DS,AX>
 10086                                  ;	MOV	DS,ResSeg
 10087                                  ;	ASSUME	DS:RESGroup
 10088                                  ;	XOR	AL,AL
 10089                                  ;	XCHG	PipeFlag,AL
 10090                                  ;	OR	AL,AL
 10091                                  ;	JZ	PipeOffDone
 10092                                  ;	SHR	EchoFlag,1
 10093                                  ;PipeOffDone:
 10094                                  ;	RestoreReg  <AX,DS>
 10095                                  ;	return
 10096                                  
 10097                                  ; =============== S U B	R O U T	I N E =======================================
 10098                                  
 10099                                  ; MSDOS 6.0
 10100                                  
 10101                                  ;PRINT_TIME:
 10102                                  ;
 10103                                  ;	MOV	AH,GET_TIME
 10104                                  ;	INT	21h			; Get time in CX:DX
 10105                                  ;
 10106                                  ;	PUSH	ES
 10107                                  ;	PUSH	CS
 10108                                  ;	POP	ES
 10109                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10110                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10111                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10112                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10113                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10114                                  ;	invoke	std_printf
 10115                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10116                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10117                                  ;
 10118                                  ;	POP	ES
 10119                                  ;	return
 10120                                  
 10121                                  ; =============== S U B	R O U T	I N E =======================================
 10122                                  
 10123                                  ; MSDOS 6.0
 10124                                  
 10125                                  ; ****************************************************************
 10126                                  ; *
 10127                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10128                                  ; *
 10129                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10130                                  ; *		 INFORMATION and issues the "Enter new date"
 10131                                  ; *		 message with the proper date format.  COMBUF
 10132                                  ; *		 is reset to get a date from the command line.
 10133                                  ; *		 The PARSE_DATE blocks are then reset and the
 10134                                  ; *		 PARSE function call is issued.
 10135                                  ; *
 10136                                  ; * INPUT:	 NONE
 10137                                  ; *
 10138                                  ; * OUTPUT:	 COMBUF
 10139                                  ; *		 PARSER RETURN CODES
 10140                                  ; *
 10141                                  ; ****************************************************************
 10142                                  
 10143                                  ;GETDAT	proc	near				;AC000;
 10144                                  ;
 10145                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10146                                  ;	mov	dx,5ch				;  should be entered in and
 10147                                  ;	int	21h			;  print a message describing it
 10148                                  ;	mov	si,dx
 10149                                  ;	lodsw
 10150                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10151                                  ;	dec	ax
 10152                                  ;	js	printformat
 10153                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10154                                  ;	jz	printformat
 10155                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10156                                  ;printformat:
 10157                                  ;	mov	ax,dx				;AN000; get message number of format
 10158                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10159                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10160                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10161                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10162                                  ;	invoke	std_printf
 10163                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10164                                  ;
 10165                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10166                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10167                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10168                                  ;	call	SetInitFlag			;  prompting for date.
 10169                                  ;	INT	21h			; Get input line
 10170                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10171                                  ;	call	SetInitFlag			;  prompting for date.
 10172                                  ;	invoke	CRLF2
 10173                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10174                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
 10175                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10176                                  ;	xor	dx,dx				;AN000;
 10177                                  ;	invoke	cmd_parse			;AC000; call parser
 10178                                  ;
 10179                                  ;	ret
 10180                                  ;
 10181                                  ;GETDAT	endp					;AC000;
 10182                                  
 10183                                  ; =============== S U B	R O U T	I N E =======================================
 10184                                  
 10185                                  ; MSDOS 6.0
 10186                                  
 10187                                  ; ****************************************************************
 10188                                  ; *
 10189                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10190                                  ; *
 10191                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10192                                  ; *		 INFORMATION and issues the "Enter new time"
 10193                                  ; *		 message. COMBUF is reset to get a time from the
 10194                                  ; *		 command line.	The PARSE_TIME blocks are then
 10195                                  ; *		 reset and the PARSE function call is issued.
 10196                                  ; *
 10197                                  ; * INPUT:	 NONE
 10198                                  ; *
 10199                                  ; * OUTPUT:	 COMBUF
 10200                                  ; *		 PARSER RETURN CODES
 10201                                  ; *
 10202                                  ; ****************************************************************
 10203                                  
 10204                                  ;GETTIM	proc	near				;AC000;
 10205                                  ;
 10206                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10207                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10208                                  ;	invoke	std_printf
 10209                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10210                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10211                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10212                                  ;	call	SetInitFlag			;  prompting for time.
 10213                                  ;	INT	21h			; Get input line
 10214                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10215                                  ;	call	SetInitFlag			;  prompting for time.
 10216                                  ;	invoke	CRLF2
 10217                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10218                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
 10219                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10220                                  ;	xor	dx,dx				;AN000;
 10221                                  ;	invoke	cmd_parse			;AC000; call parser
 10222                                  ;
 10223                                  ;	ret
 10224                                  ;
 10225                                  ;GETTIM	endp					;AC000;
 10226                                  
 10227                                  ; =============== S U B	R O U T	I N E =======================================
 10228                                  
 10229                                  ; MSDOS 6.0
 10230                                  
 10231                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10232                                  ;the '=' sign in the environment variable before the actual path.
 10233                                  ;
 10234                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10235                                  ;
 10236                                  ;	EXIT:	ds:si = start of the path
 10237                                  ;
 10238                                  ;	REGISTERS AFFECTED: ax
 10239                                  ;
 10240                                  
 10241                                  ;Skip_white	proc	near
 10242                                  ;
 10243                                  ;	cld
 10244                                  ;skw_lp:
 10245                                  ;	lodsb
 10246                                  ;	cmp	al,' '				;blank char?
 10247                                  ;	jz	skw_lp				;yes, skip it
 10248                                  ;	cmp	al,09				;tab char?
 10249                                  ;	jz	skw_lp				;yes, skip it
 10250                                  ;
 10251                                  ;	dec	si				;point at first non-white
 10252                                  ;
 10253                                  ;	ret
 10254                                  ;
 10255                                  ;Skip_white	endp
 10256                                  
 10257                                  ; =============== S U B	R O U T	I N E =======================================
 10258                                  
 10259                                  ; MSDOS 6.0
 10260                                  
 10261                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10262                                  ;variable into the path buffers Pipe1 & Pipe2.
 10263                                  ;
 10264                                  ;	ENTRY:	ds:si = path to be copied
 10265                                  ;		es = RESGROUP
 10266                                  ;
 10267                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10268                                  ;
 10269                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10270                                  ;
 10271                                  
 10272                                  ;Copy_pipe_path	proc	near
 10273                                  ;
 10274                                  ;	mov	cx,0ffffh
 10275                                  ;	xor	al,al
 10276                                  ;
 10277                                  ;	mov	di,si
 10278                                  ;	push	es			;save es
 10279                                  ;	push	ds
 10280                                  ;	pop	es			;es:di = path to be copied
 10281                                  ;	
 10282                                  ;	cld
 10283                                  ;	push	di
 10284                                  ;	repnz	scasb			;look for the null char
 10285                                  ;	pop	di
 10286                                  ;
 10287                                  ;	pop	es			;es = RESGROUP again
 10288                                  ;
 10289                                  ;	not	cx			;length including the null
 10290                                  ;
 10291                                  ;	mov	di,offset DATARES:Pipe1	
 10292                                  ;	push	di
 10293                                  ;	push	cx			
 10294                                  ;	rep	movsb			;copy path into Pipe1
 10295                                  ;	pop	cx
 10296                                  ;	pop	di
 10297                                  ;
 10298                                  ;	push	ds
 10299                                  ;	push	es
 10300                                  ;	pop	ds			;ds:si = Pipe1
 10301                                  ;	mov	si,di
 10302                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10303                                  ;	rep	movsb			;copy path into Pipe2
 10304                                  ;	pop	ds
 10305                                  ;
 10306                                  ;	ret				;
 10307                                  ;
 10308                                  ;Copy_pipe_path	endp
 10309                                  
 10310                                  ;============================================================================
 10311                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10312                                  ;============================================================================
 10313                                  ; 05/10/2018 - Retro DOS v3.0
 10314                                  
 10315                                  ; DATE - Gets and sets the time
 10316                                  
 10317                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10318                                  
 10319                                  ; =============== S U B	R O U T	I N E =======================================
 10320                                  
 10321                                  DATE_CXDX:
 10322 00002096 89CB                    		mov	bx,cx
 10323                                  
 10324                                  ; =============== S U B	R O U T	I N E =======================================
 10325                                  
 10326                                  P_DATE:
 10327 00002098 89D8                    		mov	ax,bx
 10328 0000209A 89D1                    		mov	cx,dx
 10329 0000209C B264                    		mov	dl,100
 10330 0000209E F6F2                    		div	dl
 10331 000020A0 86C4                    		xchg	al,ah
 10332 000020A2 92                      		xchg	ax,dx
 10333 000020A3 B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10334                                  		;mov	ax,[INTERNATVARS]
 10335 000020A5 A1[E84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10336 000020A8 09C0                    		or	ax,ax
 10337 000020AA 7415                    		jz	short USPDAT
 10338 000020AC 48                      		dec	ax
 10339 000020AD 7422                    		jz	short EUPDAT
 10340 000020AF B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10341 000020B1 E83900                  		call	P_YR
 10342 000020B4 E82B00                  		call	P_DSEP
 10343 000020B7 E82200                  		call	P_MON
 10344 000020BA E82500                  		call	P_DSEP
 10345 000020BD E82700                  		call	P_DAY
 10346 000020C0 C3                      		retn
 10347                                  
 10348                                  USPDAT:
 10349 000020C1 E81800                  		call	P_MON
 10350 000020C4 E81B00                  		call	P_DSEP
 10351 000020C7 E81D00                  		call	P_DAY
 10352                                  PLST:
 10353 000020CA E81500                  		call	P_DSEP
 10354 000020CD E81D00                  		call	P_YR
 10355 000020D0 C3                      		retn
 10356                                  
 10357                                  EUPDAT:
 10358 000020D1 E81300                  		call	P_DAY
 10359 000020D4 E80B00                  		call	P_DSEP
 10360 000020D7 E80200                  		call	P_MON
 10361 000020DA EBEE                    		jmp	short PLST
 10362                                  
 10363                                  ; ---------------------------------------------------------------------------
 10364                                  
 10365                                  P_MON:
 10366 000020DC 88E8                    		mov	al,ch
 10367 000020DE E88402                  		call	OUT2
 10368 000020E1 C3                      		retn
 10369                                  
 10370                                  ; ---------------------------------------------------------------------------
 10371                                  
 10372                                  P_DSEP:
 10373                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10374 000020E2 A0[F34C]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10375 000020E5 AA                      		stosb
 10376 000020E6 C3                      		retn
 10377                                  
 10378                                  ; ---------------------------------------------------------------------------
 10379                                  
 10380                                  P_DAY:
 10381 000020E7 88C8                    		mov	al,cl
 10382 000020E9 E87902                  		call	OUT2
 10383 000020EC C3                      		retn
 10384                                  
 10385                                  ; ---------------------------------------------------------------------------
 10386                                  
 10387                                  P_YR:
 10388 000020ED 88F0                    		mov	al,dh
 10389 000020EF 08C0                    		or	al,al
 10390 000020F1 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10391 000020F3 E86F02                  		call	OUT2
 10392                                  TWODIGYR:
 10393 000020F6 88D0                    		mov	al,dl
 10394 000020F8 E86A02                  		call	OUT2
 10395                                  DATE_RETN:
 10396 000020FB C3                      		retn
 10397                                  
 10398                                  ; =============== S U B	R O U T	I N E =======================================
 10399                                  
 10400                                  DATE:				 	; Accepting argument for date inline
 10401 000020FC BE8100                  		mov	si,81h
 10402 000020FF E877F8                  		call	SCANOFF
 10403 00002102 3C0D                    		cmp	al,0Dh
 10404 00002104 7402                    		jz	short PRMTDAT
 10405 00002106 EB48                    		jmp	short COMDAT
 10406                                  
 10407                                  		;nop
 10408                                  
 10409                                  PRMTDAT:
 10410                                  		; MSDOS 3.3
 10411 00002108 BA[4B3A]                		mov	dx,CURDATPTR
 10412 0000210B E8B513                  		call	STD_PRINTF	; Print "Current date is "	
 10413 0000210E E87E08                  		call	PRINT_DATE
 10414                                  
 10415                                  GETDAT:	
 10416 00002111 BA[5F3A]                		mov	dx,NEWDATPTR
 10417 00002114 E8AC13                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10418                                  
 10419 00002117 B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10420                                  					; Determine what format the date
 10421 0000211A BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10422 0000211D CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10423                                  				; get current-country info
 10424                                  				; DS:DX	-> buffer for returned info
 10425 0000211F 89D6                    		mov	si,dx		;  print a message describing it
 10426 00002121 AD                      		lodsw
 10427 00002122 BA[6E3A]                		mov	dx,USADATPTR	; get mm-dd-yy
 10428 00002125 48                      		dec	ax
 10429 00002126 7808                    		js	short PRINTFORMAT
 10430 00002128 BA[7D3A]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10431 0000212B 7403                    		jz	short PRINTFORMAT
 10432 0000212D BA[8C3A]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10433                                  PRINTFORMAT:
 10434 00002130 E89013                  		call	STD_PRINTF
 10435 00002133 B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10436 00002135 BA[C040]                		mov	dx,COMBUF
 10437 00002138 B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10438 0000213B E83802                  		call	SETINITFLAG	;  prompting for date.
 10439 0000213E CD21                    		int	21h		; Get input line
 10440 00002140 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10441 00002142 E83102                  		call	SETINITFLAG	;  prompting for date.
 10442 00002145 E824F8                  		call	CRLF2
 10443 00002148 BE[C240]                		mov	si,COMBUF+2
 10444 0000214B 803C0D                  		cmp	byte [si],0Dh
 10445 0000214E 74AB                    		jz	short DATE_RETN
 10446                                  COMDAT:
 10447                                  		;mov	ax,[INTERNATVARS]
 10448 00002150 A1[E84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10449 00002153 09C0                    		or	ax,ax
 10450 00002155 7435                    		jz	short USSDAT
 10451 00002157 48                      		dec	ax
 10452 00002158 744B                    		jz	short EUSDAT
 10453 0000215A E86500                  		call	GET_YR
 10454 0000215D 7235                    		jc	short DATERRJ
 10455 0000215F E89E00                  		call	GET_DSEP
 10456 00002162 7230                    		jc	short DATERRJ
 10457 00002164 E84D00                  		call	GET_MON
 10458 00002167 722B                    		jc	short DATERRJ
 10459 00002169 E89400                  		call	GET_DSEP
 10460 0000216C 7226                    		jc	short DATERRJ
 10461 0000216E E84B00                  		call	GET_DAY
 10462                                  DAT_SET:
 10463 00002171 7303                    		jnc	short DATSET
 10464 00002173 E98100                  		jmp	DATERR
 10465                                  
 10466                                  ; ---------------------------------------------------------------------------
 10467                                  
 10468                                  DATSET:
 10469 00002176 AC                      		lodsb
 10470 00002177 3C20                    		cmp	al,' '
 10471 00002179 74FB                    		jz	short DATSET
 10472 0000217B 3C09                    		cmp	al,9
 10473 0000217D 74F7                    		jz	short DATSET
 10474 0000217F 3C0D                    		cmp	al,0Dh
 10475 00002181 7574                    		jnz	short DATERR
 10476 00002183 B42B                    		mov	ah,SET_DATE ; 2Bh
 10477 00002185 CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10478                                  				; DL = day,DH = month,	CX = year
 10479                                  				; Return: AL = 00h if no error 
 10480                                  				; 	     = FFh if bad value sent to routine
 10481 00002187 08C0                    		or	al,al
 10482 00002189 756C                    		jnz	short DATERR
 10483                                  DAT_SET_RETN:
 10484 0000218B C3                      		retn
 10485                                  
 10486                                  ; ---------------------------------------------------------------------------
 10487                                  
 10488                                  USSDAT:
 10489 0000218C E82500                  		call	GET_MON
 10490 0000218F 7266                    		jb	short DATERR
 10491 00002191 E86C00                  		call	GET_DSEP
 10492                                  DATERRJ:
 10493 00002194 7261                    		jc	short DATERR
 10494 00002196 E82300                  		call	GET_DAY
 10495                                  TGET:
 10496 00002199 725C                    		jc	short DATERR
 10497 0000219B E86200                  		call	GET_DSEP
 10498 0000219E 7257                    		jc	short DATERR
 10499 000021A0 E81F00                  		call	GET_YR
 10500 000021A3 EBCC                    		jmp	short DAT_SET
 10501                                  
 10502                                  ; ---------------------------------------------------------------------------
 10503                                  
 10504                                  EUSDAT:
 10505 000021A5 E81400                  		call	GET_DAY
 10506 000021A8 724D                    		jc	short DATERR
 10507 000021AA E85300                  		call	GET_DSEP
 10508 000021AD 7248                    		jc	short DATERR
 10509 000021AF E80200                  		call	GET_MON
 10510 000021B2 EBE5                    		jmp	short TGET
 10511                                  
 10512                                  
 10513                                  ; =============== S U B	R O U T	I N E =======================================
 10514                                  
 10515                                  GET_MON:
 10516 000021B4 E88E01                  		call	GETNUM		; Get one or two digit number
 10517 000021B7 72D2                    		jc	short DAT_SET_RETN
 10518 000021B9 88E6                    		mov	dh,ah		; Put in position
 10519 000021BB C3                      		retn
 10520                                  
 10521                                  
 10522                                  ; =============== S U B	R O U T	I N E =======================================
 10523                                  
 10524                                  GET_DAY:
 10525 000021BC E88601                  		call	GETNUM
 10526 000021BF 88E2                    		mov	dl,ah		; Put in position
 10527                                  GET_DAY_RETN:
 10528 000021C1 C3                      		retn
 10529                                  
 10530                                  ; =============== S U B	R O U T	I N E =======================================
 10531                                  
 10532                                  GET_YR:
 10533 000021C2 E88001                  		call	GETNUM
 10534 000021C5 72FA                    		jc	short GET_DAY_RETN
 10535 000021C7 B96C07                  		mov	cx,1900
 10536 000021CA E83300                  		call	GET_DSEP
 10537 000021CD 9C                      		pushf
 10538 000021CE 4E                      		dec	si
 10539 000021CF 9D                      		popf
 10540 000021D0 741E                    		jz	short BIAS
 10541 000021D2 803C0D                  		cmp	byte [si],0Dh
 10542 000021D5 7419                    		je	short BIAS
 10543 000021D7 803C20                  		cmp	byte [si],' '
 10544 000021DA 7414                    		je	short BIAS
 10545 000021DC 803C09                  		cmp	byte [si],9
 10546 000021DF 740F                    		je	short BIAS
 10547 000021E1 53                      		push	bx
 10548 000021E2 B364                    		mov	bl,100
 10549 000021E4 88E0                    		mov	al,ah
 10550 000021E6 F6E3                    		mul	bl
 10551 000021E8 5B                      		pop	bx
 10552 000021E9 89C1                    		mov	cx,ax
 10553 000021EB E85701                  		call	GETNUM
 10554 000021EE 72D1                    		jc	short GET_DAY_RETN
 10555                                  BIAS:
 10556 000021F0 88E0                    		mov	al,ah
 10557 000021F2 B400                    		mov	ah,0
 10558 000021F4 01C1                    		add	cx,ax
 10559                                  BIAS_RETN:
 10560 000021F6 C3                      		retn
 10561                                  
 10562                                  ; ---------------------------------------------------------------------------
 10563                                  
 10564                                  DATERR:
 10565 000021F7 BA[383A]                		mov	dx,BADDATPTR
 10566 000021FA E8C612                  		call	STD_PRINTF
 10567 000021FD E911FF                  		jmp	GETDAT
 10568                                  
 10569                                  ; =============== S U B	R O U T	I N E =======================================
 10570                                  
 10571                                  GET_DSEP:
 10572 00002200 AC                      		lodsb
 10573 00002201 3C2F                    		cmp	al,'/'
 10574 00002203 74F1                    		je	short BIAS_RETN
 10575                                  		;cmp	al,'.'
 10576 00002205 3A06[F83E]              		cmp	al,[DOT_CHR]
 10577 00002209 74EB                    		je	short BIAS_RETN
 10578                                  		;cmp	al,'-'
 10579 0000220B 3A06[EE3E]              		cmp	al,[CHAR_SUB]
 10580 0000220F 74E5                    		je	short BIAS_RETN
 10581 00002211 F9                      		stc
 10582 00002212 C3                      		retn
 10583                                  
 10584                                  ; =============== S U B	R O U T	I N E =======================================
 10585                                  
 10586                                  ; TIME gets and sets the time
 10587                                  
 10588                                  CTIME:
 10589 00002213 BE8100                  		mov	si,81h		; Accepting argument for time inline
 10590 00002216 E860F7                  		call	SCANOFF
 10591 00002219 3C0D                    		cmp	al,0Dh
 10592 0000221B 747C                    		je	short PRMTTIM
 10593 0000221D BB3A2E                  		mov	bx,2E3Ah ; ":."
 10594 00002220 E80601                  		call	INLINE
 10595 00002223 E98B00                  		jmp	COMTIM
 10596                                  
 10597                                  ; =============== S U B	R O U T	I N E =======================================
 10598                                  
 10599                                  PRINT_TIME:
 10600 00002226 B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10601 00002228 CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10602                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10603                                  				; DL = hundredths of seconds
 10604 0000222A 57                      		push	di
 10605 0000222B 06                      		push	es
 10606 0000222C 0E                      		push	cs
 10607 0000222D 07                      		pop	es
 10608 0000222E BF[8B42]                		mov	di,CHARBUF
 10609 00002231 B301                    		mov	bl,1	; Always 24 hour time
 10610 00002233 E81300                  		call	P_TIME
 10611 00002236 31C0                    		xor	ax,ax
 10612 00002238 AA                      		stosb
 10613 00002239 BA[8B42]                		mov	dx,CHARBUF
 10614 0000223C 8916[3E44]              		mov	[STRING_PTR_2],dx
 10615 00002240 BA[2F37]                		mov	dx,STRINGBUF2PTR
 10616 00002243 E87D12                  		call	STD_PRINTF
 10617 00002246 07                      		pop	es
 10618 00002247 5F                      		pop	di
 10619                                  P_TIME_RETN:
 10620 00002248 C3                      		retn
 10621                                  
 10622                                  ; =============== S U B	R O U T	I N E =======================================
 10623                                  
 10624                                  P_TIME:
 10625 00002249 88E8                    		mov	al,ch	
 10626 0000224B F6C37F                  		test	bl,7Fh		; Ignore high bit
 10627 0000224E 7512                    		jnz	short T24	; 24 hr time?
 10628 00002250 B761                    		mov	bh,'a'		; Assume A.M.
 10629 00002252 3C0C                    		cmp	al,12		; In the afternoon?
 10630 00002254 7206                    		jb	short MORN
 10631 00002256 B770                    		mov	bh,'p'
 10632 00002258 7402                    		jz	short MORN
 10633 0000225A 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10634                                  MORN:
 10635 0000225C 08C0                    		or	al,al		; Before 1 am?
 10636 0000225E 7502                    		jnz	short T24
 10637 00002260 B00C                    		mov	al,12
 10638                                  T24:
 10639 00002262 53                      		push	bx
 10640 00002263 B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10641 00002265 E8FD00                  		call	OUT2
 10642 00002268 E82900                  		call	P_TSEP
 10643 0000226B 88C8                    		mov	al,cl
 10644 0000226D E8F500                  		call	OUT2
 10645 00002270 5B                      		pop	bx
 10646 00002271 53                      		push	bx
 10647 00002272 F6C380                  		test	bl,80h
 10648 00002275 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10649 00002277 B700                    		mov	bh,0		; Disable leading zero suppression
 10650 00002279 E81800                  		call	P_TSEP
 10651 0000227C 88F0                    		mov	al,dh
 10652 0000227E E8E400                  		call	OUT2
 10653                                  		;mov	al,'.'
 10654 00002281 A0[F14C]                		mov	al,[DECIMAL_SEP]
 10655 00002284 AA                      		stosb
 10656 00002285 88D0                    		mov	al,dl
 10657 00002287 E8DB00                  		call	OUT2
 10658                                  PAP:
 10659 0000228A 5B                      		pop	bx
 10660 0000228B F6C37F                  		test	bl,7Fh		; Ignore high bit
 10661 0000228E 75B8                    		jnz	short P_TIME_RETN
 10662 00002290 88F8                    		mov	al,bh
 10663 00002292 AA                      		stosb
 10664 00002293 C3                      		retn
 10665                                  
 10666                                  ; =============== S U B	R O U T	I N E =======================================
 10667                                  
 10668                                  P_TSEP:
 10669                                  		;mov	al,[TIME_SEP]
 10670 00002294 A0[F54C]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10671 00002297 AA                      		stosb
 10672                                  P_TSEP_RETN:
 10673 00002298 C3                      		retn
 10674                                  
 10675                                  ; ---------------------------------------------------------------------------
 10676                                  
 10677                                  PRMTTIM:
 10678 00002299 BA[B13A]                		mov	dx,CURTIMPTR
 10679 0000229C E82412                  		call	STD_PRINTF	; Print "Current time is "
 10680 0000229F E884FF                  		call	PRINT_TIME
 10681                                  GETTIM:
 10682 000022A2 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10683 000022A4 BA[C63A]                		mov	dx,NEWTIMPTR
 10684 000022A7 E81912                  		call	STD_PRINTF
 10685                                  		;mov	bx,':.'
 10686 000022AA 8B1E[FC3E]              		mov	bx,[TIMECHARS] 
 10687 000022AE E85B00                  		call	GETBUF
 10688                                  COMTIM:
 10689 000022B1 74E5                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10690 000022B3 724F                    		jc	short TIMEERR
 10691 000022B5 89D1                    		mov	cx,dx
 10692 000022B7 31D2                    		xor	dx,dx
 10693 000022B9 AC                      		lodsb
 10694 000022BA 3C0D                    		cmp	al,0Dh
 10695 000022BC 743E                    		je	short SAVTIM
 10696 000022BE 3C20                    		cmp	al,' '
 10697 000022C0 742D                    		je	short GOTSEC2
 10698 000022C2 3C09                    		cmp	al,9
 10699 000022C4 7429                    		je	short GOTSEC2
 10700 000022C6 38D8                    		cmp	al,bl
 10701 000022C8 7404                    		je	short GOTSEC
 10702 000022CA 38F8                    		cmp	al,bh
 10703 000022CC 7536                    		jne	short TIMEERR
 10704                                  GOTSEC:
 10705 000022CE E87400                  		call	GETNUM
 10706 000022D1 7231                    		jc	short TIMEERR
 10707 000022D3 88E6                    		mov	dh,ah		; Position seconds
 10708 000022D5 AC                      		lodsb
 10709 000022D6 3C0D                    		cmp	al,0Dh
 10710 000022D8 7422                    		je	short SAVTIM
 10711 000022DA 3C20                    		cmp	al,' '
 10712 000022DC 7411                    		je	short GOTSEC2
 10713 000022DE 3C09                    		cmp	al,9
 10714 000022E0 740D                    		je	short GOTSEC2
 10715                                  		;cmp	al,'.'
 10716 000022E2 3A06[F14C]              		cmp	al,[DECIMAL_SEP]
 10717 000022E6 751C                    		jne	short TIMEERR
 10718 000022E8 E85A00                  		call	GETNUM
 10719 000022EB 7217                    		jc	short TIMEERR
 10720 000022ED 88E2                    		mov	dl,ah
 10721                                  GOTSEC2:
 10722 000022EF AC                      		lodsb
 10723 000022F0 3C20                    		cmp	al,' '
 10724 000022F2 74FB                    		je	short GOTSEC2
 10725 000022F4 3C09                    		cmp	al,9
 10726 000022F6 74F7                    		je	short GOTSEC2
 10727 000022F8 3C0D                    		cmp	al,0Dh
 10728 000022FA 7508                    		jne	short TIMEERR
 10729                                  SAVTIM:
 10730 000022FC B42D                    		mov	ah,SET_TIME ; 2Dh
 10731 000022FE CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10732                                  				; CH = hours,CL = minutes,DH = seconds,
 10733                                  				;		DL = hundredths of seconds
 10734                                  				; Return: AL = 00h if no error 
 10735                                  				;	     = FFh if bad value sent to routine
 10736 00002300 08C0                    		or	al,al
 10737                                  P_TSEP_JRETN:
 10738 00002302 7494                    		jz	short P_TSEP_RETN ; Error in time?
 10739                                  TIMEERR:
 10740 00002304 BA[9E3A]                		mov	dx,BADTIMPTR
 10741 00002307 E8B911                  		call	STD_PRINTF	; Print "Enter new time: "
 10742 0000230A EB96                    		jmp	short GETTIM
 10743                                  
 10744                                  ; =============== S U B	R O U T	I N E =======================================
 10745                                  
 10746                                  GETBUF:
 10747 0000230C B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10748 0000230E BA[C040]                		mov	dx,COMBUF
 10749 00002311 B90200                  		mov	cx,2
 10750 00002314 E85F00                  		call	SETINITFLAG
 10751 00002317 CD21                    		int	21h		; Get input line
 10752 00002319 31C9                    		xor	cx,cx
 10753 0000231B E85800                  		call	SETINITFLAG
 10754 0000231E E84BF6                  		call	CRLF2
 10755 00002321 BE[C240]                		mov	si,COMBUF+2
 10756 00002324 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10757 00002327 74D9                    		jz	short P_TSEP_JRETN
 10758                                  
 10759                                  ; =============== S U B	R O U T	I N E =======================================
 10760                                  
 10761                                  INLINE:
 10762 00002329 E81900                  		call	GETNUM		; Get one or two digit number
 10763 0000232C 7301                    		jnb	short INLINE1
 10764 0000232E C3                      		retn
 10765                                  INLINE1:
 10766 0000232F 88E6                    		mov	dh,ah		; Put in position
 10767 00002331 AC                      		lodsb
 10768 00002332 38D8                    		cmp	al,bl
 10769 00002334 7409                    		jz	short NEXT
 10770 00002336 38F8                    		cmp	al,bh
 10771 00002338 7405                    		jz	short NEXT
 10772 0000233A 4E                      		dec	si		; Clears zero flag
 10773 0000233B F8                      		clc
 10774 0000233C B200                    		mov	dl,0
 10775 0000233E C3                      		retn			; Time may have only an hour specified
 10776                                  NEXT:
 10777 0000233F E80300                  		call	GETNUM
 10778 00002342 88E2                    		mov	dl,ah		; Put in position
 10779                                  INLINE_RETN:
 10780 00002344 C3                      		retn
 10781                                  
 10782                                  ;============================================================================
 10783                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10784                                  ;============================================================================
 10785                                  ; 05/10/2018 - Retro DOS v3.0
 10786                                  
 10787                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10788                                  
 10789                                  ; =============== S U B	R O U T	I N E =======================================
 10790                                  
 10791                                  GETNUM:
 10792 00002345 E81000                  		call	INDIG
 10793 00002348 72FA                    		jb	short INLINE_RETN
 10794 0000234A 88C4                    		mov	ah,al		; Save first digit
 10795 0000234C E80900                  		call	INDIG		; Another digit?
 10796 0000234F 7204                    		jb	short OKRET
 10797 00002351 D50A                    		aad			; Convert unpacked BCD to decimal
 10798 00002353 88C4                    		mov	ah,al
 10799                                  OKRET:
 10800 00002355 0C01                    		or	al,1
 10801                                  GETNUM_RETN:
 10802 00002357 C3                      		retn
 10803                                  
 10804                                  ; =============== S U B	R O U T	I N E =======================================
 10805                                  
 10806                                  INDIG:
 10807 00002358 8A04                    		mov	al,[si]
 10808 0000235A 2C30                    		sub	al,'0'
 10809 0000235C 72F9                    		jc	short GETNUM_RETN
 10810 0000235E 3C0A                    		cmp	al,10
 10811 00002360 F5                      		cmc
 10812 00002361 72F4                    		jc	short GETNUM_RETN
 10813 00002363 46                      		inc	si
 10814 00002364 C3                      		retn
 10815                                  
 10816                                  ; =============== S U B	R O U T	I N E =======================================
 10817                                  
 10818                                  OUT2:					; Output binary number as two ASCII digits
 10819 00002365 D40A                    		aam			; Convert binary to unpacked BCD
 10820 00002367 86C4                    		xchg	al,ah
 10821 00002369 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10822 0000236C 3C30                    		cmp	al,'0'		; Is MSD zero?
 10823 0000236E 7502                    		jnz	short NOSUP
 10824 00002370 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10825                                  NOSUP:
 10826 00002372 B700                    		mov	bh,0		; Disable zero suppression
 10827 00002374 AB                      		stosw
 10828 00002375 C3                      		retn
 10829                                  
 10830                                  ; ---------------------------------------------------------------------------
 10831                                  		;stosb
 10832                                  		;retn
 10833                                  
 10834                                  ;============================================================================
 10835                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10836                                  ;============================================================================
 10837                                  ; 03/10/2018 - Retro DOS v3.0
 10838                                  
 10839                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10840                                  
 10841                                  ; =============== S U B	R O U T	I N E =======================================
 10842                                  
 10843                                  ; Set the special flag in the INIT flag to the value in CX.
 10844                                  
 10845                                  SETINITFLAG:
 10846 00002376 8E1E[6142]              		mov	ds,[RESSEG]
 10847                                  		;and	byte [INITFLAG],0FDh
 10848 0000237A 80265B0CFD              		and	byte [INITFLAG],~INITSPECIAL
 10849 0000237F 080E5B0C                		or	byte [INITFLAG],cl
 10850 00002383 0E                      		push	cs
 10851 00002384 1F                      		pop	ds
 10852 00002385 C3                      		retn
 10853                                  
 10854                                  ; =============== S U B	R O U T	I N E =======================================
 10855                                  
 10856                                  PIPEOFF:
 10857 00002386 1E                      		push	ds
 10858 00002387 50                      		push	ax
 10859 00002388 2E8E1E[6142]            		mov	ds,[cs:RESSEG]
 10860 0000238D 30C0                    		xor	al,al
 10861 0000238F 86065C0C                		xchg	al,byte [PIPEFLAG]
 10862 00002393 08C0                    		or	al,al
 10863 00002395 7404                    		jz	short PIPEOFFDONE
 10864 00002397 D02EEF0B                		shr	byte [ECHOFLAG],1
 10865                                  PIPEOFFDONE:
 10866 0000239B 58                      		pop	ax
 10867 0000239C 1F                      		pop	ds
 10868 0000239D C3                      		retn
 10869                                  
 10870                                  ; ---------------------------------------------------------------------------
 10871                                  		;db    0,0,0,0,0
 10872                                  		;times 5 db 0
 10873 0000239E 90<rep 2h>              align 16
 10874                                  
 10875                                  ;============================================================================
 10876                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 10877                                  ;============================================================================
 10878                                  ; 03/10/2018 - Retro DOS v3.0
 10879                                  
 10880                                  ;----------------------------------------------------------------------------
 10881                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 10882                                  ; argv[argvcnt] array. The most important difference between this array and
 10883                                  ; the tradition UNIX format is the extra cparse information included with
 10884                                  ; each argument element.
 10885                                  ;---------------
 10886                                  ; ENTRY:
 10887                                  ;	BL	     special delimiter for cparse -- not implemented)
 10888                                  ;---------------
 10889                                  ; EXIT:
 10890                                  ;	CF	    set if error
 10891                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 10892                                  ;	argv[]	    array of cparse flags and pointers to arguments
 10893                                  ;	argvcnt     argument count
 10894                                  ;---------------
 10895                                  ; NOTE(S):
 10896                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 10897                                  ;	*   Parseflags record contains cparse flags, as follows:
 10898                                  ;		sw_flag 	--	was this arg a switch?
 10899                                  ;		wildcard	--	whether or not it contained a * or ?
 10900                                  ;		path_sep	--	maybe it was a pathname
 10901                                  ;		unused		--	for future expansion
 10902                                  ;		special_delim	--	was there an initial special delimiter?
 10903                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 10904                                  ;	*   Relationship between input, cparse output, and comtail can be
 10905                                  ;	    found in the following chart.  Despite the claim of the cparse
 10906                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 10907                                  ;	    tokens", such is not the case (see column two, row two).
 10908                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 10909                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 10910                                  ;	    STARTEL addresses) will be null. This is clearly just a
 10911                                  ;	    documentation error.
 10912                                  ;	*   cparse also returns a switch code in BP for each switch it
 10913                                  ;	    recognizes on the command line.
 10914                                  ;	*   arglen for each token does NOT include the terminating null.
 10915                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 10916                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 10917                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 10918                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 10919                                  ;	    line parsing may result in slightly different behavior than
 10920                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 10921                                  ;
 10922                                  ;	    Input		    Cparse		Command Line (80H)
 10923                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 10924                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 10925                                  ;	foo.bat 		foo.bat 		foo.bat
 10926                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 10927                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 10928                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 10929                                  
 10930                                  ; =============== S U B	R O U T	I N E =======================================
 10931                                  
 10932                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 10933                                  
 10934                                  PARSELINE:
 10935 000023A0 50                      		push	ax			; most of these are clobbered
 10936 000023A1 53                      		push	bx			; by cparse...
 10937 000023A2 51                      		push	cx
 10938 000023A3 52                      		push	dx
 10939 000023A4 57                      		push	di
 10940 000023A5 56                      		push	si
 10941 000023A6 9C                      		pushf
 10942 000023A7 C606[4644]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 10943 000023AC C706[5F4B]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 10944 000023B2 31C0                    		xor	ax,ax
 10945                                  		;mov	cx,1348
 10946 000023B4 B94405                  		mov	cx,ARG_UNIT.SIZE
 10947 000023B7 BF[9945]                		mov	di,ARG
 10948 000023BA F3AA                    		rep stosb
 10949                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 10950 000023BC C706[DD4A][5D48]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 10951                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 10952 000023C2 C706[5B48]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 10953                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 10954 000023C8 C706[5948]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 10955 000023CE BE[C240]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 10956                                  
 10957                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 10958                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 10959                                  ; otherwise. This is done so that commands can get arg pointers into their
 10960                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 10961                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 10962                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 10963                                  ; the command to be repeated or the transient part of command has been
 10964                                  ; reloaded.
 10965                                  
 10966 000023D1 1E                      		push	ds
 10967 000023D2 8E1E[6142]              		mov	ds,[RESSEG]
 10968 000023D6 803EFB0B00              		cmp	byte [FORFLAG],0
 10969 000023DB 1F                      		pop	ds
 10970 000023DC 7510                    		jnz	short PCONT
 10971                                  		;mov	di,ARG_ARGFORCOMBUF
 10972 000023DE BF[5D4A]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 10973 000023E1 30ED                    		xor	ch,ch
 10974 000023E3 8A0E[C140]              		mov	cl,[COMBUF+1]
 10975 000023E7 FEC1                    		inc	cl
 10976 000023E9 F3A4                    		rep movsb
 10977                                  		;mov	si,ARG_ARGFORCOMBUF
 10978 000023EB BE[5D4A]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 10979                                  PCONT:
 10980 000023EE BF[DF4A]                		mov	di,TPBUF	; destination is temporary token buffer	
 10981 000023F1 B320                    		mov	bl,' '		; no special delimiter, for now
 10982                                  PARSELOOP:
 10983 000023F3 8936[614B]              		mov	[COMPTR],si	; save ptr into original command buffer
 10984 000023F7 31ED                    		xor	bp,bp		; switch information put here by cparse
 10985 000023F9 C606[9745]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 10986 000023FE E878F5                  		call	SCANOFF		; skip leading blanks...
 10987 00002401 E8000F                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 10988 00002404 7309                    		jnb	short MORE_PRSE
 10989 00002406 09ED                    		or	bp,bp		; Check for trailing switch character
 10990 00002408 7411                    		jz	short PARSEDONE
 10991 0000240A E81B00                  		call	NEWARG		; We hit CR but BP is non-zero. The
 10992                                  					;   typical cause of this is that a
 10993                                  					;   switch char IMMEDIATELY preceeds
 10994                                  					;   the CR. We have an argument, but it
 10995                                  					;   is sort of an error.
 10996 0000240D EB0C                    		jmp	short PARSEDONE	; We're done (found the CR).
 10997                                  
 10998                                  MORE_PRSE:
 10999 0000240F C606[4644]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 11000 00002414 E81100                  		call	NEWARG		; add to argv array (CX has char count)
 11001 00002417 73DA                    		jnb	short PARSELOOP	; was everything OK?
 11002 00002419 EB04                    		jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 11003                                  
 11004                                  PARSEDONE:
 11005 0000241B 9D                      		popf
 11006 0000241C F8                      		clc
 11007 0000241D EB02                    		jmp	short PARSE_EXIT
 11008                                  
 11009                                  PARSE_ERROR:				; error entry (er, exit) point
 11010 0000241F 9D                      		popf
 11011 00002420 F9                      		stc
 11012                                  PARSE_EXIT:				; depend on not changing CF
 11013 00002421 5E                      		pop	si
 11014 00002422 5F                      		pop	di
 11015 00002423 5A                      		pop	dx
 11016 00002424 59                      		pop	cx
 11017 00002425 5B                      		pop	bx
 11018 00002426 58                      		pop	ax
 11019 00002427 C3                      		retn
 11020                                  
 11021                                  ; =============== S U B	R O U T	I N E =======================================
 11022                                  
 11023                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11024                                  ;
 11025                                  ; ENTRY:
 11026                                  ;   BH			argflags
 11027                                  ;   CX			character count in argstring
 11028                                  ;   DI			pointer to argstring
 11029                                  ;   comptr		ptr to starting loc of current token in original command
 11030                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11031                                  ; EXIT:
 11032                                  ;   argbufptr		points to next free section of argbuffer
 11033                                  ;   arg.argbuf		contains null-terminated argument strings
 11034                                  ;   arg.argvcnt 	argument count
 11035                                  ;   arg.argv[]		array of flags and pointers
 11036                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11037                                  ;   CF			set if error
 11038                                  ;   AL			carry set:  error code; otherwise, zero
 11039                                  
 11040                                  NEWARG:
 11041 00002428 53                      		push	bx
 11042 00002429 51                      		push	cx
 11043 0000242A 52                      		push	dx
 11044 0000242B 57                      		push	di
 11045 0000242C 56                      		push	si
 11046 0000242D 9C                      		pushf
 11047 0000242E E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11048                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11049                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11050                                  
 11051                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11052 00002431 833E[5948]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11053 00002436 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11054 00002438 88FE                    		mov	dh,bh			
 11055                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11056 0000243A 8B1E[5948]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11057                                  		;inc	word [ARG_ARGVCNT]
 11058 0000243E FF06[5948]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11059                                  		;mov	ax,ARG_ARGV
 11060 00002442 B8[9945]                		mov	ax,ARG+ARG_UNIT.argv
 11061 00002445 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11062                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11063                                  		;mov	word [bx+7],0
 11064 00002448 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11065                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11066                                  		;mov	[bx+5],cx
 11067 0000244D 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11068                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11069                                  		;mov	[bx+2],dh
 11070 00002450 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11071 00002453 8B36[DD4A]              		mov	si,[ARGBUFPTR]
 11072                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11073                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11074 00002457 8937                    		mov	[bx],si			
 11075 00002459 0336[8745]              		add	si,[STARTEL]		; save startel from new location
 11076 0000245D 29FE                    		sub	si,di			; form pointer into argbuf
 11077                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11078                                  		;mov	[bx+3],si
 11079 0000245F 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11080 00002462 8B36[614B]              		mov	si,[COMPTR]
 11081                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11082                                  		;mov	[bx+9],si
 11083 00002466 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11084                                  
 11085 00002469 89FE                    		mov	si,di			; now save argstring in argbuffer
 11086 0000246B 8B3E[DD4A]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11087 0000246F 01CF                    		add	di,cx			; sure we're not about to run off
 11088                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11089                                  		;cmp	di,ARG_ARGBUF+255
 11090 00002471 81FF[5C49]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11091 00002475 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11092 00002477 29CF                    		sub	di,cx
 11093 00002479 FC                      		cld
 11094 0000247A F3A4                    		rep movsb
 11095 0000247C B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11096 0000247E AA                      		stosb
 11097 0000247F 893E[DD4A]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11098                                  
 11099                                  NEWARG_DONE:
 11100 00002483 9D                      		popf
 11101 00002484 F8                      		clc
 11102 00002485 EB0A                    		jmp	short NEWARG_EXIT
 11103                                  
 11104                                  TO_MANY_ARGS:
 11105 00002487 B80100                  		mov	ax,1
 11106 0000248A EB03                    		jmp	short NEWARG_ERROR
 11107                                  
 11108                                  BUF_OVFLOW:
 11109 0000248C B80200                  		mov	ax,2
 11110                                  NEWARG_ERROR:
 11111 0000248F 9D                      		popf
 11112 00002490 F9                      		stc
 11113                                  NEWARG_EXIT:
 11114 00002491 5E                      		pop	si
 11115 00002492 5F                      		pop	di
 11116 00002493 5A                      		pop	dx
 11117 00002494 59                      		pop	cx
 11118 00002495 5B                      		pop	bx
 11119 00002496 C3                      		retn
 11120                                  
 11121                                  ; =============== S U B	R O U T	I N E =======================================
 11122                                  
 11123                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11124                                  ; event that it is, and we can recognize
 11125                                  ;
 11126                                  ; ENTRY:
 11127                                  ;   As in <newarg>.
 11128                                  ; EXIT:
 11129                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11130                                  ; NOTE(S):
 11131                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11132                                  ;	on the order of definition in the <switch_list> variable and the
 11133                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11134                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11135                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11136                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11137                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11138                                  ;   *	An ugly routine.
 11139                                  
 11140                                  ARG_SWITCH:
 11141 00002497 50                      		push	ax
 11142 00002498 53                      		push	bx
 11143 00002499 51                      		push	cx
 11144 0000249A 57                      		push	di
 11145 0000249B 9C                      		pushf
 11146 0000249C F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11147 0000249F 741C                    		jz	short ARG_NO_SWITCH0
 11148 000024A1 833E[5F4B]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11149 000024A6 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11150 000024A8 8B1E[5F4B]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11151                                  		;mov	ax,offset TRANGROUP:arg.argv
 11152                                  		;mov	ax,ARG_ARGV
 11153 000024AC B8[9945]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11154 000024AF E81800                  		call	ARGV_CALC
 11155                                  		;or	[BX].argsw_word,BP
 11156                                  		;or	[bx+7],bp
 11157 000024B2 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11158                                  		;or	arg.argswinfo,BP
 11159                                  		;or	[ARG_ARGSWINFO],bp
 11160 000024B5 092E[5B48]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11161                                  ARG_YES_SWITCH:
 11162 000024B9 9D                      		popf
 11163 000024BA F9                      		stc
 11164 000024BB EB08                    		jmp	short ARG_SWITCH_EXIT
 11165                                  
 11166                                  ARG_NO_SWITCH0:
 11167                                  		;mov	ax,[ARG_ARGVCNT]
 11168 000024BD A1[5948]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11169 000024C0 A3[5F4B]                		mov	[LASTARG],ax
 11170                                  ARG_NO_SWITCH1:
 11171 000024C3 9D                      		popf
 11172 000024C4 F8                      		clc
 11173                                  ARG_SWITCH_EXIT:
 11174 000024C5 5F                      		pop	di
 11175 000024C6 59                      		pop	cx
 11176 000024C7 5B                      		pop	bx
 11177 000024C8 58                      		pop	ax
 11178 000024C9 C3                      		retn
 11179                                  
 11180                                  ; =============== S U B	R O U T	I N E =======================================
 11181                                  
 11182                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11183                                  ; the supplied array.  Method used for computing the address is:
 11184                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11185                                  ; ENTRY:
 11186                                  ;   AX	    --	    base of array
 11187                                  ;   BX	    --	    array index
 11188                                  ; EXIT:
 11189                                  ;   BX	    --	    byte offset
 11190                                  
 11191                                  ARGV_CALC:
 11192 000024CA 50                      		push	ax		; Save base
 11193 000024CB 88D8                    		mov	al,bl		; al = array index
 11194                                  		;mov	bl,11
 11195 000024CD B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11196 000024CF F6E3                    		mul	bl		; ax = base offset
 11197 000024D1 5B                      		pop	bx		; Get base
 11198 000024D2 01D8                    		add	ax,bx		; Add in base offset
 11199 000024D4 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11200 000024D5 C3                      		retn
 11201                                  
 11202                                  ; ---------------------------------------------------------------------------
 11203                                  	
 11204                                  		;db 0Ah dup(0)
 11205                                  		;times 10 db 0
 11206 000024D6 90<rep Ah>              align 16
 11207                                  
 11208                                  ;============================================================================
 11209                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11210                                  ;============================================================================
 11211                                  ; 03/10/2018 - Retro DOS v3.0
 11212                                  
 11213                                  ;----------------------------------------------------------------------------
 11214                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11215                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11216                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11217                                  ;    file on disk. Directories specified in the user's search path will be
 11218                                  ;    searched for a matching file, if a match is not found in the current
 11219                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11220                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11221                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11222                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11223                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11224                                  ;    (easily) modified to make no assumptions about where its input is found.
 11225                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11226                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11227                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11228                                  ;    else that wants to save the whole shebang and then process other command
 11229                                  ;    lines.
 11230                                  ;
 11231                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11232                                  ;
 11233                                  ; ENTRY:
 11234                                  ;   <Path_Search>:	    argv[0].
 11235                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11236                                  ; EXIT:
 11237                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11238                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11239                                  ; NOTE(S):
 11240                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11241                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11242                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11243                                  ;	does not function as specified; see <Parseline> for more details.
 11244                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11245                                  ;	need to know about. This extra information is stored in a switch_flag
 11246                                  ;	word with each command-line argument; the switches themselves will not
 11247                                  ;	appear in the resulting arg structure.
 11248                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11249                                  ;----------------------------------------------------------------------------
 11250                                  
 11251                                  ; =============== S U B	R O U T	I N E =======================================
 11252                                  
 11253                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11254                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11255                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11256                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11257                                  ; have a match, either in the current working directory if we were handed
 11258                                  ; a filename, or in the specified directory, given a pathname. If this call
 11259                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11260                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11261                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11262                                  ; either the first invocation of search or on one of the succeeding calls
 11263                                  ; sets up the appropriate information for copying the successful pathname
 11264                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11265                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11266                                  ;
 11267                                  ; ENTRY:
 11268                                  ;   argv[0]		--	command name and associated information
 11269                                  ; EXIT:
 11270                                  ;   AX			--	non-zero indicates type of file found
 11271                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11272                                  ; NOTE(S):
 11273                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11274                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11275                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11276                                  ;	if search returns an .exe or .bat.
 11277                                  ;   5)	Clobbers dma address.
 11278                                  
 11279                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11280                                  PATH_SEP_CHAR	EQU	';'
 11281                                  
 11282                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11283                                  
 11284                                  		;special_delim equ 128
 11285                                  		;path_sep equ 4
 11286                                  		;wildcard equ 2
 11287                                  		;sw_flag  equ 1
 11288                                  
 11289                                  ;----------------------------------------------------------------------------
 11290                                  
 11291                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11292                                  
 11293                                  PATH_SEARCH:
 11294 000024E0 53                      		push	bx
 11295 000024E1 51                      		push	cx
 11296 000024E2 52                      		push	dx		; could use a "stack 'em" instruction
 11297 000024E3 56                      		push	si
 11298 000024E4 57                      		push	di
 11299 000024E5 55                      		push	bp
 11300 000024E6 9C                      		pushf
 11301                                  
 11302                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11303                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11304 000024E7 F606[9B45]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11305 000024EC 7403                    		jz	short PATH_SEARCH_OK
 11306                                  
 11307                                  PATH_FAILURE_JMP:
 11308 000024EE E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11309                                  
 11310                                  PATH_SEARCH_OK:
 11311 000024F1 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11312 000024F4 BA[634B]                		mov	dx,FBUF		; clobber old dma value with
 11313 000024F7 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11314 000024FA CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11315                                  				; DS:DX	-> disk	transfer buffer
 11316 000024FC 06                      		push	es
 11317 000024FD E88FF2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11318 00002500 8C06[8E4B]              		mov	[PATHINFO+0],es	; and squirrel it away
 11319 00002504 893E[904B]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11320 00002508 893E[924B]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11321 0000250C 07                      		pop	es
 11322                                  		
 11323 0000250D BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11324 00002510 BE[8941]                		mov	si,EXECPATH
 11325 00002513 E84B02                  		call	STRIP
 11326 00002516 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11327                                  		
 11328 00002518 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11329 0000251A C706[E34B][3939]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11330 00002520 E88301                  		call	PSEARCH		; must do at least one search
 11331 00002523 09C0                    		or	ax,ax		; find anything?
 11332 00002525 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11333                                  		
 11334 00002527 89C5                    		mov	bp,ax		; success... save filetype code	
 11335 00002529 BF[8941]                		mov	di,EXECPATH
 11336                                  		;mov	si,ds:arg.argv[0].argpointer
 11337                                  		;mov	si,[ARG_ARGV]
 11338 0000252C 8B36[9945]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11339                                  		;mov	cx,ds:arg.argv[0].argstartel
 11340                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11341 00002530 8B0E[9C45]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11342 00002534 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11343                                  
 11344                                  ; We have the number of bytes in the prefix (up to the final component).
 11345                                  ; We need to form the complete pathname including leading drive and current
 11346                                  ; directory.
 11347                                  ;
 11348                                  ; Is there a drive letter present?
 11349                                  
 11350 00002536 B43A                    		mov	ah,':'
 11351 00002538 83F902                  		cmp	cx,2		; room for drive letter?
 11352 0000253B 7205                    		jb	short ADDDRIVE	; no, stick it in
 11353 0000253D 386401                  		cmp	[si+1],	ah	; colon present?
 11354 00002540 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11355                                  ADDDRIVE:
 11356 00002542 A0[7542]                		mov	al,[CURDRV]	; get current drive
 11357 00002545 0441                    		add	al,'A'		; convert to uppercase letter
 11358 00002547 AB                      		stosw			; store d:
 11359 00002548 EB05                    		jmp	short CHECKPATH
 11360                                  
 11361                                  MOVEDRIVE:
 11362 0000254A AD                      		lodsw			; move d:
 11363 0000254B AB                      		stosw
 11364 0000254C 83E902                  		sub	cx,2		; 2 bytes less to move
 11365                                  CHECKPATH:
 11366 0000254F 0C20                    		or	al,20h
 11367 00002551 88C2                    		mov	dl,al		
 11368                                  		;sub	dl,60h
 11369 00002553 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11370                                  
 11371                                  ; Stick in beginning path char
 11372                                  
 11373 00002556 A0[944B]                		mov	al,[PSEP_CHAR]
 11374 00002559 AA                      		stosb
 11375                                  
 11376                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11377                                  ; Otherwise, get current dir for DL.
 11378                                  
 11379 0000255A 83F901                  		cmp	cx,1		; is there room for path char?
 11380 0000255D 720A                    		jb	short ADDPATH	; no, go add path
 11381 0000255F AC                      		lodsb
 11382 00002560 49                      		dec	cx
 11383 00002561 3A06[944B]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11384 00002565 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11385 00002567 41                      		inc	cx
 11386 00002568 4E                      		dec	si		; undo the lodsb
 11387                                  ADDPATH:
 11388 00002569 56                      		push	si
 11389 0000256A 89FE                    		mov	si,di		; remainder of buffer
 11390 0000256C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11391 0000256F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11392                                  				; DL = drive (0=default,1=A,etc.)
 11393                                  				; DS:SI	points to 64-byte buffer area
 11394                                  
 11395                                  ; The previous current dir will succeed a previous find_first already worked.
 11396                                  ;
 11397                                  ; Find end of string.
 11398                                  
 11399 00002571 89F7                    		mov	di,si
 11400 00002573 5E                      		pop	si
 11401 00002574 A0[944B]                		mov	al,[PSEP_CHAR]
 11402 00002577 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11403 0000257A 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11404                                  SCANEND:
 11405 0000257C 803D00                  		cmp	byte [di],0	; end of string?
 11406 0000257F 7403                    		jz	short FOUNDEND
 11407 00002581 47                      		inc	di
 11408 00002582 EBF8                    		jmp	short SCANEND
 11409                                  
 11410                                  ; Stick in a trailing path char.
 11411                                  
 11412                                  FOUNDEND:
 11413 00002584 AA                      		stosb
 11414                                  
 11415                                  ; Move remaining part of path.	Skip leading path char if present.
 11416                                  
 11417                                  MOVEPATH:
 11418 00002585 3804                    		cmp	[si],al		; first char a path char?
 11419 00002587 7502                    		jnz	short COPYPATH
 11420 00002589 46                      		inc	si		; move past leading char
 11421 0000258A 49                      		dec	cx		; drop from count
 11422                                  COPYPATH:
 11423 0000258B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11424 0000258D F3A4                    		rep movsb
 11425                                  _COPYDONE:
 11426 0000258F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11427                                  
 11428                                  PATH_NOINIT:
 11429                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11430                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11431 00002592 F606[9B45]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11432 00002597 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11433                                  		;mov	bh,';'
 11434 00002599 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11435                                  		;mov	dx,ds:arg.argv[0].argstartel
 11436                                  					; this is where the last element starts
 11437                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11438 0000259B 8B16[9C45]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11439                                  		;sub	dx,ds:arg.argv[0].argpointer
 11440                                  					; form pointer into EXECPATH,
 11441                                  		;sub	dx,[ARG_ARGV]
 11442 0000259F 2B16[9945]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11443 000025A3 81C2[8941]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11444                                  PATH_LOOP:
 11445 000025A7 E89A00                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11446 000025AA 89C5                    		mov	bp,ax		; save filetype code
 11447 000025AC 9F                      		lahf			; save flags, just in case
 11448 000025AD 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11449 000025AF 7507                    		jnz	short PATH_FOUND 
 11450 000025B1 9E                      		sahf			; see?	needed those flags, after all!
 11451 000025B2 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11452                                  PATH_FAILURE:
 11453 000025B4 31C0                    		xor	ax,ax
 11454 000025B6 EB70                    		jmp	short PATH_EXIT
 11455                                  
 11456                                  PATH_FOUND:				; pathinfo[] points to winner
 11457 000025B8 BF[8941]                		mov	di,EXECPATH
 11458                                  		;mov	cx,pathinfo[4] 
 11459 000025BB 8B0E[924B]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11460                                  		;mov	SI,pathinfo[2]
 11461 000025BF 8B36[904B]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11462                                  
 11463                                  ;	BAS Nov 20/84
 11464                                  ;   Look at the pathname and expand . and .. if they are the first element
 11465                                  ;   in the pathname (after the drive letter)
 11466                                  
 11467 000025C3 06                      		push	es
 11468                                  		;push	pathinfo[0]
 11469 000025C4 FF36[8E4B]              		push	word [PATHINFO+0]
 11470 000025C8 07                      		pop	es
 11471                                  ;SR;
 11472                                  ; Oops! Gets fooled if path= \;..
 11473                                  ; We should also check if a drive letter is really present
 11474                                  ;
 11475 000025C9 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11476 000025CE 7534                    		jnz	short PATH_CPY
 11477                                  
 11478                                  		; MSDOS 6.0
 11479                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11480                                  		;jnz	path_cpy	       ;no, copy the path string
 11481                                  
 11482 000025D0 51                      		push	cx		; Save pointer to end of string
 11483 000025D1 268A04                  		mov	al,[es:si]
 11484 000025D4 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11485 000025D6 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11486 000025DA 884501                  		mov	[di+1],al
 11487 000025DD A0[944B]                		mov	al,[PSEP_CHAR]
 11488 000025E0 884502                  		mov	[di+2],	al
 11489 000025E3 56                      		push	si		; Save pointer to begining of string
 11490 000025E4 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11491 000025E7 80CA20                  		or	dl,20h
 11492                                  		;sub	dl,60h
 11493 000025EA 80EA60                  		sub	dl,'a'-1
 11494 000025ED 89FE                    		mov	si,di		; pointer to EXECPATH
 11495 000025EF 83C603                  		add	si,3		; Don't wipe out drive and root info
 11496 000025F2 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11497 000025F5 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11498                                  				; DL = drive (0=default,1=A,etc.)
 11499                                  				; DS:SI	points to 64-byte buffer area
 11500 000025F7 E8BCF8                  		call	DSTRLEN		; Determine length of present info
 11501 000025FA 01CE                    		add	si,cx		; Don't copy over drive and root info
 11502 000025FC 4E                      		dec	si
 11503 000025FD 89F7                    		mov	di,si		; Point to end of target string
 11504 000025FF 5E                      		pop	si		; Restore pointer to begining of string
 11505 00002600 83C603                  		add	si,3		; Point past drive letter, :, .
 11506 00002603 59                      		pop	cx		; Restore pointer to end of string
 11507                                  PATH_CPY:
 11508 00002604 07                      		pop	es
 11509 00002605 29F1                    		sub	cx,si		; yields character count
 11510 00002607 1E                      		push	ds		; time to switch segments
 11511 00002608 FF36[8E4B]              		push	word [PATHINFO+0] ; string lives in this segment
 11512 0000260C 1F                      		pop	ds
 11513 0000260D FC                      		cld
 11514 0000260E F3A4                    		rep movsb
 11515 00002610 1F                      		pop	ds		; return to our segment
 11516 00002611 4F                      		dec	di		; overwrite terminator
 11517 00002612 A0[944B]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11518 00002615 3A45FF                  		cmp	al,[di-1]
 11519 00002618 7401                    		jz	short PATH_SUCCESS
 11520 0000261A AA                      		stosb
 11521                                  PATH_SUCCESS:
 11522 0000261B BE[964B]                		mov	si,SEARCH_BEST_BUF
 11523 0000261E 31C9                    		xor	cx,cx
 11524                                  PATH_SUCC_LOOP:
 11525 00002620 AC                      		lodsb			; append winning filename to path
 11526 00002621 AA                      		stosb			; (including terminating null)	
 11527 00002622 08C0                    		or	al,al
 11528 00002624 75FA                    		jnz	short PATH_SUCC_LOOP
 11529 00002626 89E8                    		mov	ax,bp		; retrieve filetype code
 11530                                  PATH_EXIT:
 11531 00002628 9D                      		popf
 11532 00002629 5D                      		pop	bp
 11533 0000262A 5F                      		pop	di
 11534 0000262B 5E                      		pop	si		; chill out...
 11535 0000262C 5A                      		pop	dx
 11536 0000262D 59                      		pop	cx
 11537 0000262E 5B                      		pop	bx
 11538 0000262F C3                      		retn
 11539                                  
 11540                                  
 11541                                  ; =============== S U B	R O U T	I N E =======================================
 11542                                  
 11543                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11544                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11545                                  ;
 11546                                  ; ENTRY:
 11547                                  ; EXIT:
 11548                                  ; NOTE(S):
 11549                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11550                                  
 11551                                  STORE_PCHAR:
 11552 00002630 50                      		push	ax
 11553 00002631 B02F                    		mov	al,'/'		; is the pathname-element separator
 11554 00002633 E8D6F3                  		call	PATHCHRCMP	; a regular slash?
 11555 00002636 7407                    		jz	short STORE_SLASH ; if yes, remember slash
 11556 00002638 B05C                    		mov	al,'\'
 11557 0000263A A2[944B]                		mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11558 0000263D 58                      		pop	ax
 11559 0000263E C3                      		retn
 11560                                  STORE_SLASH:
 11561 0000263F A2[944B]                		mov	[PSEP_CHAR],al
 11562 00002642 58                      		pop	ax
 11563 00002643 C3                      		retn
 11564                                  
 11565                                  ; =============== S U B	R O U T	I N E =======================================
 11566                                  
 11567                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11568                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11569                                  ; additional separator to use for breaking up the path-string. Null is the
 11570                                  ; default. Once the user-string has been formed, search is invoked to see
 11571                                  ; what's out there.
 11572                                  ;
 11573                                  ; ENTRY:
 11574                                  ;   BH			--	additional terminator character
 11575                                  ;   SI			--	pointer into pathstring to be dissected
 11576                                  ;   DX			--	pointer to stripped filename
 11577                                  ; EXIT:
 11578                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11579                                  ;   SI			--	moves along pathstring from call to call
 11580                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11581                                  ;   [tpbuf]		--	clobbered
 11582                                  ; NOTE(S):
 11583                                  ;   *	Implicit in this code is the ability to specify when to search
 11584                                  ;	the current directory (if at all) through the PATH defined by
 11585                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11586                                  ;	current directory before the bin and etc directories of drive c).
 11587                                  
 11588                                  PATH_CRUNCH:
 11589 00002644 53                      		push	bx
 11590 00002645 51                      		push	cx
 11591 00002646 52                      		push	dx
 11592 00002647 57                      		push	di
 11593 00002648 56                      		push	si
 11594 00002649 9C                      		pushf
 11595 0000264A E8E3FF                  		call	STORE_PCHAR	; figure out pathname separator
 11596 0000264D BF[DF4A]                		mov	di,TPBUF	; destination of concatenated string
 11597 00002650 8B36[924B]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11598 00002654 8936[904B]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11599 00002658 1E                      		push	ds		; save old segment pointer
 11600 00002659 FF36[8E4B]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11601 0000265D 1F                      		pop	ds		; segment		
 11602                                  PATH_CR_COPY:
 11603 0000265E AC                      		lodsb			; get a pathname byte
 11604 0000265F 08C0                    		or	al,al		; check for terminator(s)
 11605 00002661 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11606 00002663 38F8                    		cmp	al,bh
 11607 00002665 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11608 00002667 AA                      		stosb
 11609 00002668 EBF4                    		jmp	short PATH_CR_COPY
 11610                                  
 11611                                  PATH_SEG:
 11612 0000266A 1F                      		pop	ds		; restore old data segment
 11613 0000266B 8936[924B]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11614 0000266F 88C3                    		mov	bl,al		; remember if we saw null or not...
 11615                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11616 00002671 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11617 00002673 81FF[DF4A]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11618 00002677 741D                    		jz	short PATH_CR_LEAVE 
 11619                                  					; if nothing was copied, pathstr empty
 11620                                  PATH_CR_LOOK:
 11621 00002679 A0[944B]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11622 0000267C 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11623 0000267F 7401                    		jz	short PATH_CR_L1
 11624 00002681 AA                      		stosb
 11625                                  PATH_CR_L1:
 11626 00002682 89D6                    		mov	si,dx
 11627                                  PATH_CR_L2:
 11628 00002684 AC                      		lodsb			; tack the stripped filename onto
 11629 00002685 AA                      		stosb			; the end of the path, up to and
 11630 00002686 08C0                    		or	al,al		; including the terminating null
 11631 00002688 75FA                    		jnz	short PATH_CR_L2
 11632 0000268A BA[DF4A]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11633 0000268D C706[E34B][303C]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11634                                  		;invoke search
 11635 00002693 E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11636                                  
 11637                                  PATH_CR_LEAVE:
 11638 00002696 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11639 00002698 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11640 0000269A 9D                      		popf			; otherwise, plenty left
 11641 0000269B F8                      		clc
 11642 0000269C EB02                    		jmp	short PATH_CR_EXIT
 11643                                  
 11644                                  PATH_CR_EMPTY:
 11645 0000269E 9D                      		popf
 11646 0000269F F9                      		stc
 11647                                  PATH_CR_EXIT:
 11648 000026A0 5E                      		pop	si
 11649 000026A1 5F                      		pop	di
 11650 000026A2 5A                      		pop	dx
 11651 000026A3 59                      		pop	cx
 11652 000026A4 5B                      		pop	bx
 11653 000026A5 C3                      		retn
 11654                                  
 11655                                  ;============================================================================
 11656                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11657                                  ;============================================================================
 11658                                  ; 02/10/2018 - Retro DOS v3.0
 11659                                  
 11660                                  ;----------------------------------------------------------------------------
 11661                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11662                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11663                                  ; lowest priority). Where conflicts arise, the extension with
 11664                                  ; the highest priority is favored.
 11665                                  ; ENTRY:
 11666                                  ;   DX		--	pointer to null-terminated pathname
 11667                                  ;   fbuf	--	dma buffer for findfirst/next
 11668                                  ; EXIT:
 11669                                  ;   AX		--	8)  file found with .com extension
 11670                                  ;			4)  file found with .exe extension
 11671                                  ;			2)  file found with .bat extension
 11672                                  ;			0)  no such file to be found
 11673                                  ;   (if AX is non-zero:)
 11674                                  ;   [search_best]	identical to AX
 11675                                  ;   [search_best_buf]	null-terminated filename
 11676                                  ; NOTES:
 11677                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11678                                  ;---------------
 11679                                  ; CONSTANTS:
 11680                                  ;---------------
 11681                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11682                                  SEARCH_COM		EQU	8
 11683                                  SEARCH_EXE		EQU	4
 11684                                  SEARCH_BAT		EQU	2
 11685                                  FNAME_LEN		EQU	8
 11686                                  FNAME_MAX_LEN		EQU	13
 11687                                  DOT			EQU	'.'
 11688                                  WILDCHAR		EQU	'?'
 11689                                  
 11690                                  
 11691                                  ; =============== S U B	R O U T	I N E =======================================
 11692                                  
 11693                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11694                                  
 11695                                  PSEARCH:
 11696 000026A6 51                      		push	cx
 11697 000026A7 52                      		push	dx
 11698 000026A8 57                      		push	di
 11699 000026A9 56                      		push	si
 11700 000026AA 9C                      		pushf
 11701 000026AB 52                      		push	dx		; check drivespec (save pname ptr)
 11702 000026AC 89D7                    		mov	di,dx		; working copy of pathname
 11703 000026AE BE[A34B]                		mov	si,SEARCH_CURDIR_BUF
 11704 000026B1 31D2                    		xor	dx,dx		; zero means current drive
 11705 000026B3 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11706 000026B7 7508                    		jne	short SEARCH_DIR_CHECK
 11707 000026B9 8A15                    		mov	dl,[di]		; get the drive byte
 11708 000026BB 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11709 000026BE 80EA40                  		sub	dl,'@'		; and convert to drive number
 11710                                  SEARCH_DIR_CHECK:
 11711 000026C1 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11712 000026C4 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11713                                  				; DL = drive (0=default,1=A,etc.)
 11714                                  				; DS:SI	points to 64-byte buffer area
 11715 000026C6 5A                      		pop	dx		; directory? If we can't we'll		
 11716 000026C7 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11717 000026C9 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11718 000026CC B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11719 000026CF CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11720                                  				; CX = search attributes
 11721                                  				; DS:DX	-> ASCIZ filespec
 11722                                  				; (drive,path,	and wildcards allowed)
 11723 000026D1 723C                    		jc	short SEARCH_NO_FILE
 11724 000026D3 C606[954B]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11725 000026D8 C606[964B]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11726                                  SEARCH_LOOP:
 11727 000026DD E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11728 000026E0 3A06[954B]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11729 000026E4 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11730 000026E6 A2[954B]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11731                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11732                                  		;mov	si,FBUF_PNAME
 11733 000026E9 BE[814B]                		mov	si,FBUF+FIND_BUF.PNAME
 11734 000026EC BF[964B]                		mov	di,SEARCH_BEST_BUF
 11735 000026EF B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11736 000026F2 FC                      		cld
 11737 000026F3 F3A4                    		rep movsb		; save complete pathname representation
 11738 000026F5 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11739 000026F7 740A                    		je	short SEARCH_DONE
 11740                                  SEARCH_NEXT:				; keep on looking
 11741 000026F9 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11742 000026FC B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11743 000026FF CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11744                                  				; [DTA]	= data block from
 11745                                  				; last AH = 4Eh/4Fh call
 11746 00002701 73DA                    		jnc	short SEARCH_LOOP
 11747                                  SEARCH_DONE:				; it's all over with...
 11748 00002703 A0[954B]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11749                                  		; MSDOS 6.0
 11750                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11751                                  		;jz	search_exit	;AN005; no - exit
 11752                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11753                                  		;mov	search_best,al	;AN005; save the real file type
 11754                                  		;
 11755 00002706 EB0A                    		jmp	short SEARCH_EXIT
 11756                                  
 11757                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11758 00002708 8B16[E34B]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11759 0000270C E8B40D                  		call	STD_PRINTF	 ; and pretend no file found
 11760                                  
 11761                                  SEARCH_NO_FILE:				; couldn't find a match
 11762 0000270F B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11763                                  
 11764                                  SEARCH_EXIT:
 11765 00002712 9D                      		popf
 11766 00002713 5E                      		pop	si
 11767 00002714 5F                      		pop	di
 11768 00002715 5A                      		pop	dx
 11769 00002716 59                      		pop	cx
 11770 00002717 C3                      		retn
 11771                                  
 11772                                  ; =============== S U B	R O U T	I N E =======================================
 11773                                  
 11774                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11775                                  ;
 11776                                  ; ENTRY:
 11777                                  ;   fbuf    --	    dma buffer containing filename
 11778                                  ; EXIT:
 11779                                  ;   AX	    --	    file code, as given in search header
 11780                                  ; NOTE(S):
 11781                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11782                                  
 11783                                  SEARCH_FTYPE:
 11784 00002718 57                      		push	di
 11785 00002719 56                      		push	si
 11786 0000271A B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11787                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11788                                  		;mov	di,FBUF_PNAME
 11789 0000271D BF[814B]                		mov	di,FBUF+FIND_BUF.PNAME
 11790 00002720 B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11791 00002723 FC                      		cld
 11792 00002724 F2AE                    		repnz scasb		; search for the terminating null
 11793 00002726 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11794 00002728 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11795                                  
 11796                                  		; Compare .COM
 11797                                  
 11798 0000272B BE[013F]                		mov	si,COMEXT ; ".COM"
 11799 0000272E 89F8                    		mov	ax,di
 11800 00002730 A7                      		cmpsw
 11801 00002731 7508                    		jnz	short FTYPE_EXE
 11802 00002733 A7                      		cmpsw
 11803 00002734 7505                    		jnz	short FTYPE_EXE
 11804                                  		;mov	ax,8
 11805 00002736 B80800                  		mov	ax,SEARCH_COM	; success!
 11806 00002739 EB23                    		jmp	short FTYPE_EXIT
 11807                                  
 11808                                  		; Compare .EXE
 11809                                  FTYPE_EXE:				; still looking... now for '.exe'
 11810 0000273B 89C7                    		mov	di,ax
 11811 0000273D BE[053F]                		mov	si,EXEEXT ; ".EXE"
 11812 00002740 A7                      		cmpsw
 11813 00002741 7508                    		jnz	short FTYPE_BAT
 11814 00002743 A7                      		cmpsw
 11815 00002744 7505                    		jnz	short FTYPE_BAT
 11816                                  		;mov	ax,4
 11817 00002746 B80400                  		mov	ax,SEARCH_EXE	; success!
 11818 00002749 EB13                    		jmp	short FTYPE_EXIT
 11819                                  
 11820                                  		; Compare .BAT
 11821                                  FTYPE_BAT:				; still looking... now for '.bat'
 11822 0000274B 89C7                    		mov	di,ax
 11823 0000274D BE[093F]                		mov	si,BATEXT ; ".BAT"
 11824 00002750 A7                      		cmpsw
 11825 00002751 7508                    		jnz	short FTYPE_FAIL
 11826 00002753 A7                      		cmpsw
 11827 00002754 7505                    		jnz	short FTYPE_FAIL
 11828                                  		;mov	ax,2
 11829 00002756 B80200                  		mov	ax,SEARCH_BAT	; success!
 11830 00002759 EB03                    		jmp	short FTYPE_EXIT
 11831                                  
 11832                                  FTYPE_FAIL:				; file doesn't match what we need
 11833 0000275B B80000                  		mov	ax,ANULL ; 0
 11834                                  
 11835                                  FTYPE_EXIT:
 11836                                  		; MSDOS 6.0
 11837                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11838                                  		;jz	ftype_done	;AN005; no - exit
 11839                                  		;cmp	ax,ANULL	;AN005; was any match found
 11840                                  		;jz	ftype_done	;AN005; no - exit
 11841                                  		;mov	ext_entered,al	;AN005; save the match type found
 11842                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11843                                  ;ftype_done:
 11844 0000275E 5E                      		pop	si
 11845 0000275F 5F                      		pop	di
 11846 00002760 C3                      		retn
 11847                                  
 11848                                  ; =============== S U B	R O U T	I N E =======================================
 11849                                  
 11850                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 11851                                  ; replacing any extension with wildcards.
 11852                                  ;
 11853                                  ; ENTRY:
 11854                                  ;	BX		--		maximum length of destination buffer
 11855                                  ;	DS:SI		--		address of destination buffer
 11856                                  ;	argv[0] 	--		command name to be stripped
 11857                                  ; EXIT:
 11858                                  ;	CF		--		set if failure, clear if successful
 11859                                  ; NOTE(S):
 11860                                  
 11861                                  
 11862                                  STRIP:
 11863 00002761 50                      		push	ax
 11864 00002762 53                      		push	bx
 11865 00002763 51                      		push	cx
 11866 00002764 52                      		push	dx
 11867 00002765 57                      		push	di
 11868 00002766 56                      		push	si
 11869 00002767 9C                      		pushf
 11870                                  		
 11871                                  		; MSDOS 6.0
 11872                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 11873                                  
 11874                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11875                                  		;mov	dx,[ARG_ARGV]
 11876                                  		;mov	dx,ds:arg.argv[0].argpointer
 11877                                  					; save pointer to beginning of argstring
 11878                                  		;mov	dx,[ARGV0_ARGPOINTER]
 11879 00002768 8B16[9945]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 11880                                  		;mov	di,ds:arg.argv[0].argstartel
 11881                                  					; beginning of last pathname element
 11882                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 11883 0000276C 8B3E[9C45]              		mov	di,[ARG+ARGV_ELE.argstartel]
 11884 00002770 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 11885 00002773 742E                    		je	short STRIP_ERROR
 11886 00002775 89D1                    		mov	cx,dx		; compute where end of argstring lies
 11887                                  		;add	cx,ds:arg.argv[0].arglen
 11888                                  		;add	cx,[ARGV0_ARGLEN]
 11889 00002777 030E[9E45]              		add	cx,[ARG+ARGV_ELE.arglen]
 11890 0000277B 29F9                    		sub	cx,di		; and then find length of last element
 11891 0000277D 41                      		inc	cx		; include null as well
 11892                                  		;mov	al,'.'
 11893 0000277E B02E                    		mov	al,DOT		; let's find the filetype extension
 11894 00002780 FC                      		cld
 11895 00002781 F2AE                    		repnz scasb		; wind up pointing to either null or dot
 11896                                  
 11897                                  		; MSDOS 6.0
 11898                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 11899                                  		;mov	ext_entered,0	;AN005; we found an extension
 11900                                  		;mov	al,ANULL	;AN005; continue scanning until the
 11901                                  		;repnz	scasb		;AN005;    end of line is reached.
 11902                                  PROCESS_EXT:
 11903                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11904 00002783 89F9                    		mov	cx,di		; pointer to end of argstring yields
 11905 00002785 29D1                    		sub	cx,dx		; number of bytes to be copied
 11906 00002787 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 11907 0000278A 39D9                    		cmp	cx,bx
 11908 0000278C 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 11909 0000278E 89F7                    		mov	di,si		; destination buffer
 11910 00002790 89D6                    		mov	si,dx		; source is beginning of pathname
 11911 00002792 FC                      		cld
 11912 00002793 F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 11913                                  
 11914                                  		; MSDOS 6.0
 11915                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 11916                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 11917                                  
 11918                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11919 00002795 4F                      		dec	di		; overwrite null or dot
 11920 00002796 AA                      		stosb			; with a dot
 11921                                  		;mov	al,'?'
 11922 00002797 B03F                    		mov	al,WILDCHAR	; now add wildcards
 11923 00002799 AA                      		stosb
 11924 0000279A AA                      		stosb
 11925 0000279B AA                      		stosb
 11926                                  		;mov	al,0
 11927 0000279C B000                    		mov	al,ANULL	; and a terminating null	
 11928 0000279E AA                      		stosb
 11929                                  SKIP_WILDS:
 11930 0000279F 9D                      		popf
 11931 000027A0 F8                      		clc
 11932 000027A1 EB02                    		jmp	short STRIP_EXIT ; chill out...
 11933                                  
 11934                                  STRIP_ERROR:
 11935 000027A3 9D                      		popf
 11936 000027A4 F9                      		stc
 11937                                  STRIP_EXIT:
 11938 000027A5 5E                      		pop	si
 11939 000027A6 5F                      		pop	di
 11940 000027A7 5A                      		pop	dx
 11941 000027A8 59                      		pop	cx
 11942 000027A9 5B                      		pop	bx
 11943 000027AA 58                      		pop	ax
 11944 000027AB C3                      		retn
 11945                                  
 11946                                  ; =============== S U B	R O U T	I N E =======================================
 11947                                  
 11948                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 11949                                  ;
 11950                                  ; structure in newly allocated memory. The argv[] structure is found at the
 11951                                  ; beginning of this area. The caller indicates how much extra space is
 11952                                  ; needed in the resulting structure; Save_Args returns a segment number and
 11953                                  ; an offset into that area, indicating where the caller may preserve its own
 11954                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 11955                                  ; ENTRY:
 11956                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 11957                                  ; EXIT:
 11958                                  ;   AX	    --	    segment of new area.
 11959                                  ;   CF	    --	    set if unable to save a copy.
 11960                                  ; NOTE(S):
 11961                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 11962                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 11963                                  ;	paragraphs.
 11964                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 11965                                  ;	as the caller of Save_Args requests.
 11966                                  ;   3)	AX is undefined if CF indicates an error.
 11967                                  
 11968                                  SAVE_ARGS:
 11969 000027AC 53                      		push	bx
 11970 000027AD 51                      		push	cx
 11971 000027AE 52                      		push	dx
 11972 000027AF 57                      		push	di
 11973 000027B0 56                      		push	si
 11974 000027B1 55                      		push	bp
 11975 000027B2 9C                      		pushf
 11976                                  		;add	bx,1363		; space for arg structure, round up
 11977 000027B3 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 11978 000027B7 B104                    		mov	cl,4		; to paragraph size and convert
 11979 000027B9 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 11980 000027BB B80048                  		mov	ax,ALLOC*256 ; 4800h
 11981 000027BE CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11982                                  				; BX = number of 16-byte paragraphs desired
 11983 000027C0 7244                    		jc	short SAVE_ERROR
 11984 000027C2 89C5                    		mov	bp,ax		; save segment id
 11985 000027C4 06                      		push	es		; save TRANGROUP address
 11986 000027C5 8EC0                    		mov	es,ax		; switch to new memory segment
 11987                                  		; assume es:nothing
 11988                                  		;mov	cx,1348		; get back structure size
 11989 000027C7 B94405                  		mov	cx,ARG_UNIT.SIZE
 11990 000027CA 31FF                    		xor	di,di		; destination is new memory area
 11991                                  		;mov	si,ARG_ARGV
 11992 000027CC BE[9945]                		mov	si,ARG		; source is arg structure
 11993 000027CF F3A4                    		rep movsb		; move that sucker!
 11994                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 11995                                  		;mov	cx,[ARG_ARGVCNT]
 11996 000027D1 8B0E[5948]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 11997 000027D5 31C0                    		xor	ax,ax		; base address for argv_calc
 11998                                  
 11999                                  	;	Bugbug:	What did they mean by this?
 12000                                  	;	Note that the replacement line produces exactly the same code.
 12001                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 12002                                  	;	mov	SI, OFFSET TRANGROUP:arg
 12003                                  
 12004                                  		;mov	si,ARG_ARGV
 12005 000027D7 BE[9945]                		mov	si,ARG	
 12006                                  SAVE_PTR_LOOP:
 12007 000027DA 49                      		dec	cx		; exhausted all args?
 12008 000027DB 7C24                    		jl	short SAVE_DONE
 12009 000027DD 89CB                    		mov	bx,cx		; get arg index and
 12010 000027DF E8E8FC                  		call	ARGV_CALC	; convert to a pointer
 12011                                  		;mov	dx,ds:arg.argv[bx].argpointer
 12012                                  		;mov	dx,[ARG_ARGV+bx]
 12013 000027E2 8B97[9945]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 12014 000027E6 29F2                    		sub	dx,si		; adjust argpointer
 12015                                  		;mov	es:argv[BX].argpointer,dx
 12016                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12017 000027E8 268917                  		mov	[es:bx],dx
 12018                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12019                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12020 000027EB 8B97[9C45]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12021 000027EF 29F2                    		sub	dx,si		; and adjust argstartel
 12022                                  		;mov	es:argv[bx].argstartel,dx
 12023                                  		;mov	[es:bx+3],dx
 12024 000027F1 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12025                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12026                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12027 000027F5 8B97[A245]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12028 000027F9 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12029                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12030                                  		;mov	[es:bx+9],dx
 12031 000027FB 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12032 000027FF EBD9                    		jmp	short SAVE_PTR_LOOP
 12033                                  SAVE_DONE:
 12034 00002801 07                      		pop	es		; back we go to TRANGROUP
 12035                                  		; assume es:nothing
 12036 00002802 89E8                    		mov	ax,bp		; restore segment id
 12037 00002804 EB04                    		jmp	short SAVE_OK
 12038                                  
 12039                                  SAVE_ERROR:
 12040 00002806 9D                      		popf
 12041 00002807 F9                      		stc
 12042 00002808 EB02                    		jmp	short SAVE_EXIT
 12043                                  
 12044                                  SAVE_OK:
 12045 0000280A 9D                      		popf
 12046 0000280B F8                      		clc
 12047                                  SAVE_EXIT:
 12048 0000280C 5D                      		pop	bp
 12049 0000280D 5E                      		pop	si
 12050 0000280E 5F                      		pop	di
 12051 0000280F 5A                      		pop	dx
 12052 00002810 59                      		pop	cx
 12053 00002811 5B                      		pop	bx
 12054 00002812 C3                      		retn
 12055                                  
 12056                                  ;============================================================================
 12057                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12058                                  ;============================================================================
 12059                                  ; 02/10/2018 - Retro DOS v3.0
 12060                                  
 12061                                  ; Title	COMMAND Language midifiable Code Transient
 12062                                  
 12063                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12064                                  
 12065                                  ; =============== S U B	R O U T	I N E =======================================
 12066                                  
 12067                                  ; ****************************************************************
 12068                                  ; *
 12069                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12070                                  ; *
 12071                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12072                                  ; *		 user for Y/N if necessary. If an error occurs,
 12073                                  ; *		 set up an error message and go to CERROR.
 12074                                  ; *
 12075                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12076                                  ; *		 Current directory set to entered directory
 12077                                  ; *
 12078                                  ; * OUTPUT:	 none
 12079                                  ; *
 12080                                  ; ****************************************************************
 12081                                  ;
 12082                                  ; ARE YOU SURE prompt when deleting *.*
 12083                                  
 12084                                  NOTEST2:
 12085 00002813 B90B00                  		mov	cx,11
 12086 00002816 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12087                                  AMBSPEC:
 12088 00002819 AC                      		lodsb
 12089 0000281A 3C3F                    		cmp	al,'?'
 12090 0000281C 7502                    		jnz	short ALLFIL
 12091 0000281E E2F9                    		loop	AMBSPEC
 12092                                  ALLFIL:
 12093 00002820 83F900                  		cmp	cx,0
 12094 00002823 7531                    		jnz	short NOPRMPT
 12095                                  ASKAGN:	
 12096 00002825 BA[DC3A]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12097 00002828 E8980C                  		call	STD_PRINTF
 12098 0000282B BE8000                  		mov	si,80h
 12099 0000282E 89F2                    		mov	dx,si
 12100 00002830 C7047800                		mov	word [si],120	; zero length
 12101                                  		;mov	ax,0C0Ah
 12102 00002834 B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12103 00002837 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12104                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12105 00002839 AD                      		lodsw
 12106 0000283A 08E4                    		or	ah,ah
 12107 0000283C 74E7                    		jz	short ASKAGN
 12108 0000283E E838F1                  		call	SCANOFF
 12109                                  		; MSDOS 6.0
 12110                                  		;call	char_in_xlat	; Convert to upper case
 12111                                  		;retc			; return if function not supported
 12112                                  		; MSDOS 3.3
 12113 00002841 E87E01                  		call	UPCONV
 12114                                  		
 12115                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12116 00002844 3A06[893D]              		cmp	al,[CAPITAL_N]
 12117 00002848 7501                    		jne	short CHECK_Y
 12118 0000284A C3                      		retn
 12119                                  CHECK_Y:
 12120 0000284B 3A06[883D]              		cmp	al,[CAPITAL_Y]
 12121 0000284F 9C                      		pushf
 12122 00002850 E819F1                  		call	CRLF2
 12123 00002853 9D                      		popf
 12124 00002854 75CF                    		jne	short ASKAGN
 12125                                  NOPRMPT:
 12126 00002856 B413                    		mov	ah,FCB_DELETE ; 13h
 12127 00002858 BA5C00                  		mov	dx,FCB ; 5Ch
 12128 0000285B CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12129                                  				; DS:DX	-> FCB with filename field filled with
 12130                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12131                                  				; Return: AL = 00h file	found,FFh file	not found
 12132 0000285D FEC0                    		inc	al
 12133 0000285F 7404                    		jz	short ERAERR
 12134 00002861 E837F0                  		call	RESTUDIR
 12135 00002864 C3                      		retn
 12136                                  
 12137                                  		; MSDOS 6.0
 12138                                  ;eraerr:
 12139                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12140                                  		;push	dx			;AN022; save message
 12141                                  		;invoke	RESTUDIR
 12142                                  		;pop	dx			;AN022; restore message
 12143                                  		;
 12144                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12145                                  		;				;AN022; convert no more files to
 12146                                  		;jnz	cerrorj2		;AN022; 	file not found
 12147                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12148                                  		;			;AN000; get message number in control block
 12149                                  ;cerrorj2:
 12150                                  		;jmp	cerror
 12151                                  	
 12152                                  		; MSDOS 3.3
 12153                                  ERAERR:	
 12154 00002865 B41A                    		mov	ah,SET_DMA ; 1Ah
 12155 00002867 BA5C00                  		mov	dx,FCB ; 5Ch
 12156 0000286A CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12157                                  					; DS:DX	-> disk	transfer buffer
 12158 0000286C B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12159 0000286E CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12160                                  					; DS:DX	-> FCB
 12161 00002870 50                      		push	ax
 12162 00002871 E827F0                  		call	RESTUDIR
 12163 00002874 58                      		pop	ax
 12164 00002875 BA[E837]                		mov	dx,FNOTFOUNDPTR
 12165 00002878 FEC0                    		inc	al
 12166 0000287A 743D                    		jz	short CERRORJ
 12167 0000287C BA[0D38]                		mov	dx,ACCDENPTR
 12168 0000287F E9A1F3                  		jmp	CERROR
 12169                                  
 12170                                  ; =============== S U B	R O U T	I N E =======================================
 12171                                  
 12172                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12173                                  
 12174                                  ECHO:
 12175 00002882 E89400                  		call	ON_OFF
 12176 00002885 7212                    		jb	short DOEMES
 12177 00002887 8E1E[6142]              		mov	ds,[RESSEG]
 12178 0000288B 7506                    		jnz	short ECH_OFF
 12179 0000288D 800EEF0B01              		or	byte [ECHOFLAG],1
 12180 00002892 C3                      		retn
 12181                                  
 12182                                  ECH_OFF:
 12183 00002893 8026EF0BFE              		and	byte [ECHOFLAG],0FEh
 12184 00002898 C3                      		retn
 12185                                  
 12186                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12187                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12188                                  
 12189                                  DOEMES:
 12190                                  		; MSDOS 6.0
 12191                                  		;cmp	cl,0		;AC000; was anything on the line?
 12192                                  		;jz	PECHO		; just display current state.
 12193                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12194                                  		;invoke	CRPRINT
 12195                                  		;JMP	CRLF2
 12196                                  
 12197                                  		; MSDOS 3.3
 12198 00002899 E82000                  		call	MOVE_TO_FIRST_ARG
 12199 0000289C 7409                    		jz	short PECHO
 12200 0000289E BA8200                  		mov	dx,82h
 12201 000028A1 E826F1                  		call	CRPRINT
 12202 000028A4 E9C5F0                  		jmp	CRLF2
 12203                                  
 12204                                  PECHO:
 12205                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12206 000028A7 8E1E[6142]              		mov	ds,[RESSEG]
 12207 000028AB 8A1EEF0B                		mov	bl,byte [ECHOFLAG]
 12208 000028AF 0E                      		push	cs
 12209 000028B0 1F                      		pop	ds
 12210 000028B1 80E301                  		and	bl,1
 12211 000028B4 BA[0F3D]                		mov	dx,ECHOMESPTR
 12212 000028B7 EB2E                    		jmp	short PYN
 12213                                  
 12214                                  ; ---------------------------------------------------------------------------
 12215                                  
 12216                                  		; MSDOS 3.3
 12217                                  CERRORJ:
 12218 000028B9 E967F3                  		jmp	CERROR
 12219                                  
 12220                                  
 12221                                  ; =============== S U B	R O U T	I N E =======================================
 12222                                  
 12223                                  MOVE_TO_FIRST_ARG:
 12224 000028BC BE8100                  		mov	si,81h
 12225 000028BF E8B7F0                  		call	SCANOFF
 12226 000028C2 3C0D                    		cmp	al,0Dh
 12227 000028C4 C3                      		retn
 12228                                  
 12229                                  ; =============== S U B	R O U T	I N E =======================================
 12230                                  
 12231                                  CNTRLC:
 12232 000028C5 E85100                  		call	ON_OFF
 12233 000028C8 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12234 000028CB 720C                    		jc	short PCNTRLC
 12235 000028CD 7505                    		jnz	short CNTRLC_OFF
 12236 000028CF B201                    		mov	dl,1
 12237 000028D1 CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12238                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12239                                  				; DL = 00h for OFF or 01h for ON
 12240 000028D3 C3                      		retn
 12241                                  
 12242                                  ; ---------------------------------------------------------------------------
 12243                                  
 12244                                  CNTRLC_OFF:
 12245 000028D4 30D2                    		xor	dl,dl
 12246 000028D6 CD21                    		int	21h		; Turn off ^C check
 12247 000028D8 C3                      		retn
 12248                                  
 12249                                  ; ---------------------------------------------------------------------------
 12250                                  
 12251                                  PCNTRLC:
 12252                                  		; MSDOS 6.0
 12253                                  		;CMP	CL,0		;AC000; rest of line blank?
 12254                                  		;JNZ	CERRORJ 	; no, oops!
 12255                                  
 12256                                  		; MSDOS 3.3
 12257 000028D9 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12258 000028DC 75DB                    		jnz	short CERRORJ
 12259                                  ;pccont:
 12260                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12261 000028DE 30C0                    		xor	al,al
 12262 000028E0 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12263 000028E2 88D3                    		mov	bl,dl
 12264 000028E4 BA[F73C]                		mov	dx,CTRLMESPTR
 12265                                  
 12266                                  ; ---------------------------------------------------------------------------
 12267                                  
 12268                                  PYN:		; write "ON" or "OFF" state 
 12269                                  
 12270 000028E7 E8D90B                  		call	STD_PRINTF
 12271 000028EA BA[1E3D]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12272 000028ED 08DB                    		or	bl,bl
 12273 000028EF 7503                    		jnz	short PRINTVAL
 12274 000028F1 BA[173D]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12275                                  
 12276                                  PRINTVAL:
 12277                                  		; MSDOS 3.3
 12278 000028F4 E9CC0B                  		jmp	STD_PRINTF
 12279                                  
 12280                                  		; MSDOS 6.0
 12281                                  		;push	dx		;AN000; save offset of message block
 12282                                  		;mov	bx,dx		;AN000; save offset value
 12283                                  		;lodsw			;AN000; get message number of on or off
 12284                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12285                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12286                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12287                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12288                                  		;pop	dx		;AN000; get message back
 12289                                  		;invoke	std_printf	;AC000; go print message
 12290                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12291                                  		;
 12292                                  		;ret			;AN000; exit
 12293                                  
 12294                                  ; =============== S U B	R O U T	I N E =======================================
 12295                                  
 12296                                  VERIFY:
 12297 000028F7 E81F00                  		call	ON_OFF
 12298 000028FA B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12299 000028FD 720A                    		jc	short PVERIFY
 12300 000028FF 7503                    		jnz	short VER_OFF
 12301 00002901 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12302                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12303 00002903 C3                      		retn
 12304                                  
 12305                                  ; ---------------------------------------------------------------------------
 12306                                  
 12307                                  VER_OFF:
 12308 00002904 FEC8                    		dec	al
 12309 00002906 CD21                    		int	21h		; Turn off verify after write
 12310 00002908 C3                      		retn
 12311                                  
 12312                                  ; ---------------------------------------------------------------------------
 12313                                  
 12314                                  PVERIFY:
 12315                                  		; MSDOS 6.0
 12316                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12317                                  		;JNZ	CERRORJ 	; nope...
 12318                                  
 12319                                  		; MSDOS 3.3
 12320 00002909 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12321 0000290C 75AB                    		jnz	short CERRORJ
 12322                                  
 12323 0000290E B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12324 00002910 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12325                                  					; Return: AL = 00h if flag OFF
 12326                                  					; AL = 01h if flag ON
 12327 00002912 88C3                    		mov	bl,al
 12328 00002914 BA[043D]                		mov	dx,VERIMESPTR
 12329 00002917 EBCE                    		jmp	short PYN
 12330                                  
 12331                                  ; =============== S U B	R O U T	I N E =======================================
 12332                                  
 12333                                  ; ****************************************************************
 12334                                  ; *
 12335                                  ; * ROUTINE:	 ON_OFF
 12336                                  ; *
 12337                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12338                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12339                                  ; *		 routines.
 12340                                  ; *
 12341                                  ; * INPUT:	 command line at offset 81H
 12342                                  ; *		 PARSE_BREAK control block
 12343                                  ; *
 12344                                  ; * OUTPUT:	 If carry is clear
 12345                                  ; *		    If ON is found
 12346                                  ; *		       Zero flag set
 12347                                  ; *		    If OFF is found
 12348                                  ; *		       Zero flag clear
 12349                                  ; *		 If carry set
 12350                                  ; *		    If nothing on command line
 12351                                  ; *		       CL set to zero
 12352                                  ; *		    If error
 12353                                  ; *		       CL contains error value from parse
 12354                                  ; *
 12355                                  ; ****************************************************************
 12356                                  
 12357                                  ON_OFF:
 12358 00002919 BE8100                  		mov	si,81h
 12359                                  
 12360                                  		; MSDOS 3.3
 12361 0000291C E85AF0                  		call	SCANOFF		; scan off leading blanks & equal
 12362 0000291F 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12363 00002921 742A                    		je	short BAD_ONF	; yes, return error
 12364 00002923 AD                      		lodsw
 12365 00002924 0D2020                  		or	ax,2020h	; convert to lowercase
 12366 00002927 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12367 0000292A 7410                    		je	short ON_CHECK
 12368 0000292C 3D6F66                  		cmp	ax,666Fh ;'of'
 12369 0000292F 751C                    		jne	short BAD_ONF
 12370 00002931 AC                      		lodsb
 12371 00002932 0C20                    		or	al,20h		; convert to lowercase		
 12372 00002934 3C66                    		cmp	al,66h	 ; 'f'
 12373 00002936 7515                    		jne	short BAD_ONF	
 12374 00002938 0C66                    		or	al,66h ; or al,'f'
 12375 0000293A EB02                    		jmp	short OFF_CHECK
 12376                                  ON_CHECK:
 12377 0000293C 30C0                    		xor	al,al
 12378                                  OFF_CHECK:
 12379 0000293E 9F                      		lahf
 12380 0000293F 89C3                    		mov	bx,ax
 12381 00002941 E835F0                  		call	SCANOFF		; scan off leading blanks & equal
 12382 00002944 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12383 00002946 7505                    		jne	short BAD_ONF	; no, return error
 12384 00002948 89D8                    		mov	ax,bx
 12385 0000294A 9E                      		sahf
 12386 0000294B F8                      		clc
 12387 0000294C C3                      		retn
 12388                                  
 12389                                  		; MSDOS 6.0
 12390                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12391                                  ;		lodsb			;AN032; get a char
 12392                                  ;		cmp	al,blank	;AN032; if whitespace
 12393                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12394                                  ;		cmp	al,tab_chr	;AN032; if tab
 12395                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12396                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12397                                  ;		jz	parse_on_off	;AN032;    start parsing
 12398                                  ;		dec	si		;AN032; if none of above - back up
 12399                                  ;
 12400                                  ;parse_on_off:				;AN032;    and start parsing
 12401                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
 12402                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12403                                  ;		xor	dx,dx		;AN000;
 12404                                  ;		invoke	cmd_parse	;AC000; call parser
 12405                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12406                                  ;		jz	BADONF		;AC000; yes, return error
 12407                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12408                                  ;		jz	on_off_there	;AN000; no - continue
 12409                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12410                                  ;		jmp	short BADONF	;AN000; return error
 12411                                  ;
 12412                                  ;on_off_there:
 12413                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12414                                  ;		jnz	good_on_off	;AN014; yes - continue
 12415                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12416                                  ;		jmp	short BADONF	;AN014; return error
 12417                                  ;
 12418                                  ;good_on_off:				;AN014;
 12419                                  ;		xor	ax,ax		;AC000; set up return code for
 12420                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12421                                  ;		pushf			;AN000; save flags
 12422                                  ;		mov	di,offset trangroup:parse_break
 12423                                  ;					;AN000; Get adderss of PARSE_BREAK
 12424                                  ;		xor	dx,dx		;AN000;
 12425                                  ;		invoke	cmd_parse	;AN000; call parser
 12426                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12427                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12428                                  ;		popf			;AN000; restore flags
 12429                                  ;		clc			;AC000; no error
 12430                                  ;		jmp	short on_off_end ;AN000; return to caller
 12431                                  ;
 12432                                  ;BADONF_flags:
 12433                                  ;		mov	cx,ax
 12434                                  ;		popf
 12435                                  
 12436                                  ; ---------------------------------------------------------------------------
 12437                                  
 12438                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12439                                  ; and return the error
 12440                                  
 12441                                  BAD_ONF:
 12442 0000294D BA[D93B]                		mov	dx,BADONOFFPTR
 12443 00002950 F9                      		stc
 12444                                  ;on_off_end:
 12445 00002951 C3                      		retn
 12446                                  
 12447                                  ;============================================================================
 12448                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12449                                  ;============================================================================
 12450                                  ; 02/10/2018 - Retro DOS v3.0
 12451                                  
 12452                                  ; Print volume ID info
 12453                                  
 12454                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12455                                  
 12456                                  ; ---------------------------------------------------------------------------
 12457                                  
 12458                                  PRINTVOL:
 12459 00002952 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12460 00002953 A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12461 00002956 0440                    		add	al,'@'
 12462 00002958 3C40                    		cmp	al,'@'
 12463 0000295A 7507                    		jnz	short DRVOK
 12464 0000295C A0[7542]                		mov	al,[CURDRV]
 12465 0000295F 0206[E03E]              		add	al,[CAPITAL_A]
 12466                                  DRVOK:
 12467 00002963 A2[5444]                		mov	[VOL_DRV],al	; get drive letter into argument
 12468 00002966 58                      		pop	ax		; get return code back
 12469 00002967 BA[453B]                		mov	dx,NOVOL ; "has	no label" 
 12470 0000296A 08C0                    		or	al,al		; volume label found?
 12471 0000296C 7517                    		jnz	short PRINTVOL2	; print no volume message
 12472                                  GOODVOL:
 12473                                  		; MSDOS 3.3
 12474 0000296E BF[8B42]                		mov	di,CHARBUF
 12475 00002971 89FA                    		mov	dx,di
 12476 00002973 BE[413B]                		mov	si,IS	; "is "
 12477 00002976 E80BDF                  		call	STRCPY
 12478 00002979 4F                      		dec	di
 12479 0000297A BE[6243]                		mov	si,DIRBUF+8
 12480 0000297D B90B00                  		mov	cx,11
 12481 00002980 F3A4                    		rep movsb
 12482 00002982 31C0                    		xor	ax,ax
 12483                                  		;xor	al,al  ; MSDOS 6.0
 12484 00002984 AA                      		stosb			; store a zero to terminate the string
 12485                                  PRINTVOL2:
 12486 00002985 8916[5244]              		mov	[VOLNAME_ADDR],dx
 12487 00002989 BA[3B3B]                		mov	dx,VOLMESPTR
 12488 0000298C E9240B                  		jmp	PRINTF_CRLF
 12489                                  
 12490                                  		; MSDOS 6.0
 12491                                  ;drvok:
 12492                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12493                                  ;		pop	ax		;AC000; get return code back
 12494                                  ;		or	al,al		;AC000; volume label found?
 12495                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12496                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12497                                  ;					;AC000; set up no volume message
 12498                                  ;		jmp	short print_serial	;AC000; go print it
 12499                                  ;
 12500                                  ;Get_vol_name:
 12501                                  ;		mov	di,offset trangroup:charbuf
 12502                                  ;		mov	dx,di
 12503                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12504                                  ;		mov	cx,11				;AN000;  3/3/KK
 12505                                  ;		rep	movsb				;AN000;  3/3/KK
 12506                                  ;
 12507                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12508                                  ;		stosb
 12509                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12510                                  ;
 12511                                  ;PRINT_SERIAL:
 12512                                  ;
 12513                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12514                                  ;; occurs, do not print volume serial number.
 12515                                  ;
 12516                                  ;		push	dx		;AN000; save message offset
 12517                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12518                                  ;					;AC036; Get the volume serial info
 12519                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12520                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12521                                  ;		int	21h		;AN000; do the call
 12522                                  ;		pop	dx		;AN000; get message offset back
 12523                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12524                                  ;		call	std_printf	;AC000; go print volume message
 12525                                  ;		mov	al,blank	;AN051; Print out a blank
 12526                                  ;		invoke	print_char	;AN051;   before volume message
 12527                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12528                                  ;					;AN000; get serial number message
 12529                                  ;printvol_end:
 12530                                  ;		jmp	std_printf	;AC000; go print and exit
 12531                                  
 12532                                  ;============================================================================
 12533                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12534                                  ;============================================================================
 12535                                  ; 02/10/2018 - Retro DOS v3.0
 12536                                  
 12537                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12538                                  
 12539                                  ; =============== S U B	R O U T	I N E =======================================
 12540                                  
 12541                                  PRINT_DATE:
 12542                                  		; MSDOS 3.3
 12543 0000298F 06                      		push	es
 12544 00002990 57                      		push	di
 12545 00002991 0E                      		push	cs
 12546 00002992 07                      		pop	es
 12547 00002993 BF[B843]                		mov	di,ARG_BUF
 12548 00002996 B42A                    		mov	ah,GET_DATE ; 2Ah
 12549 00002998 CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12550                                  				; Return: DL = day,DH = month,	CX = year
 12551                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12552 0000299A 98                      		cbw
 12553 0000299B E80F00                  		call	GETDATE
 12554 0000299E E8F7F6                  		call	P_DATE
 12555 000029A1 30C0                    		xor	al,al
 12556 000029A3 AA                      		stosb
 12557 000029A4 BA[1337]                		mov	dx,ARG_BUF_PTR
 12558 000029A7 E8190B                  		call	STD_PRINTF
 12559 000029AA 07                      		pop	es
 12560 000029AB 5F                      		pop	di
 12561 000029AC C3                      		retn
 12562                                  
 12563                                  		; MSDOS 6.0
 12564                                  		;PUSH	ES
 12565                                  		;PUSH	DI
 12566                                  		;PUSH	CS
 12567                                  		;POP	ES
 12568                                  		;CALL	GetDate 		; get date
 12569                                  		;xchg	dh,dl			;AN000; switch month & day
 12570                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12571                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12572                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12573                                  		;invoke	std_printf
 12574                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12575                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12576                                  		;POP	DI			;AC000; restore di,es
 12577                                  		;POP	ES			;AC000;
 12578                                  		;return
 12579                                  
 12580                                  ; ---------------------------------------------------------------------------
 12581                                  
 12582                                  GETDATE:
 12583                                  		; MSDOS 3.3
 12584 000029AD 89C6                    		mov	si,ax
 12585 000029AF D1E6                    		shl	si,1
 12586 000029B1 01C6                    		add	si,ax
 12587 000029B3 81C6[143A]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12588 000029B7 89CB                    		mov	bx,cx
 12589 000029B9 B90300                  		mov	cx,3
 12590 000029BC F3A4                    		rep movsb
 12591 000029BE B020                    		mov	al,' '
 12592 000029C0 AA                      		stosb
 12593 000029C1 C3                      		retn
 12594                                  
 12595                                  		; MSDOS 6.0
 12596                                  
 12597                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12598                                  ; for output.  Date will be returned in CX,DX.
 12599                                  
 12600                                  ;GetDate:
 12601                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12602                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12603                                  		;INT	21h			;AC000; Get date in CX:DX
 12604                                  		;CBW				;AC000;
 12605                                  		;
 12606                                  		;push	cx			;AN000; save date returned in
 12607                                  		;push	dx			;AN000;      CX:DX
 12608                                  		;MOV	SI,AX
 12609                                  		;
 12610                                  		;SHL	SI,1
 12611                                  		;ADD	SI,AX			; SI=AX*3
 12612                                  		;
 12613                                  		;mov	cx,si			;AN000; save si
 12614                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12615                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12616                                  		;push	di			;AN000; save argument buffer
 12617                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12618                                  		;pop	di			;AN000; retrieve argument buffer
 12619                                  		;add	si,cx			;AC000; get day of week
 12620                                  		;
 12621                                  		;MOV	CX,3
 12622                                    		;REP	MOVSB
 12623                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12624                                  		;stosb
 12625                                  		;pop	dx			;AN000; get back date
 12626                                  		;pop	cx			;AN000;
 12627                                  		;
 12628                                  		;return
 12629                                  
 12630                                  ; =============== S U B	R O U T	I N E =======================================
 12631                                  
 12632                                  		; MSDOS 6.0
 12633                                  
 12634                                  ; This routine determines whether the character in AL is a
 12635                                  ; Yes or No character. On return, if AL=0, the character is
 12636                                  ; No, if AL=1, the character is Yes.
 12637                                  
 12638                                  ;		assume	ds:trangroup
 12639                                  
 12640                                  ;char_in_xlat	proc	near
 12641                                  ;
 12642                                  ;		mov	dl,al			;AC000; get character into DX
 12643                                  ;		xor	dh,dh			;AC000;
 12644                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12645                                  ;		int	21h			;AC000;
 12646                                  ;
 12647                                  ;		ret
 12648                                  ;
 12649                                  ;char_in_xlat	endp
 12650                                  
 12651                                  ;============================================================================
 12652                                  ; TENV.ASM, MSDOS 6.0, 1991
 12653                                  ;============================================================================
 12654                                  ; 02/10/2018 - Retro DOS v3.0
 12655                                  
 12656                                  ;	Environment utilities and misc. routines
 12657                                  
 12658                                  ; MSDOS 6.0
 12659                                  ; ****************************************************************
 12660                                  ; *
 12661                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12662                                  ; *
 12663                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12664                                  ; *		 the character in AL from the file upper case table
 12665                                  ; *		 in DOS if character if above  ascii 128, else
 12666                                  ; *		 subtracts 20H if between "a" and "z".
 12667                                  ; *
 12668                                  ; * INPUT:	 AL	      char to be upper cased
 12669                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12670                                  ; *
 12671                                  ; * OUTPUT:	 AL	      upper cased character
 12672                                  ; *
 12673                                  ; ****************************************************************
 12674                                  ;
 12675                                  ;assume	ds:trangroup				;AN000;
 12676                                  ;
 12677                                  ;upconv	proc	near				;AN000;
 12678                                  ;
 12679                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12680                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12681                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12682                                  ;	push	ds				;AN000;
 12683                                  ;	push	bx				;AN000;
 12684                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12685                                  ;assume	ds:resgroup				;AN000;
 12686                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12687                                  ;	add	bx,2				;AN000;  skip over first word
 12688                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12689                                  ;	pop	bx				;AN000;
 12690                                  ;	pop	ds				;AN000;
 12691                                  ;assume	ds:trangroup				;AN000;
 12692                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12693                                  ;
 12694                                  ;oth_fucase:					;AN000;
 12695                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12696                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12697                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12698                                  ;	ja	upconv_end			;AC000;
 12699                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12700                                  ;
 12701                                  ;upconv_end:					;AN000;
 12702                                  ;	ret
 12703                                  ;
 12704                                  ;upconv	endp					;AN000;
 12705                                  
 12706                                  
 12707                                  ; =============== S U B	R O U T	I N E =======================================
 12708                                  
 12709                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12710                                  
 12711                                  UPCONV:
 12712 000029C2 3C80                    		cmp	al,80h
 12713 000029C4 7214                    		jb	short OTH_UCASE
 12714 000029C6 2C80                    		sub	al,80h
 12715 000029C8 1E                      		push	ds
 12716 000029C9 53                      		push	bx
 12717 000029CA 8E1E[6142]              		mov	ds,[RESSEG]
 12718 000029CE C51E060C                		lds	bx,[UPPERCASETBL]
 12719 000029D2 83C302                  		add	bx,2
 12720 000029D5 D7                      		xlat
 12721 000029D6 5B                      		pop	bx
 12722 000029D7 1F                      		pop	ds
 12723 000029D8 EB0A                    		jmp	short UPCONV_RETN
 12724                                  
 12725                                  OTH_UCASE:
 12726 000029DA 3C61                    		cmp	al,'a'
 12727 000029DC 7206                    		jb	short UPCONV_RETN
 12728 000029DE 3C7A                    		cmp	al,'z'
 12729 000029E0 7702                    		ja	short UPCONV_RETN
 12730 000029E2 2C20                    		sub	al,20h
 12731                                  
 12732                                  UPCONV_RETN:
 12733 000029E4 C3                      		retn
 12734                                  
 12735                                  ;============================================================================
 12736                                  ; COPY.ASM, MSDOS 6.0, 1991
 12737                                  ;============================================================================
 12738                                  ; 01/10/2018 - Retro DOS v3.0
 12739                                  
 12740                                  ;	title	COMMAND COPY routines.
 12741                                  
 12742                                  ;/*
 12743                                  ; *                      Microsoft Confidential
 12744                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12745                                  ; *                      All Rights Reserved.
 12746                                  ; */
 12747                                  
 12748                                  ;***	COPY.ASM
 12749                                  
 12750                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12751                                  
 12752                                  
 12753                                  ;***	MODIFICATION HISTORY
 12754                                  
 12755                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12756                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12757                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12758                                  ;	     to tokens which begin with path characters so that PARSELINE
 12759                                  ;	     will work correctly.
 12760                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12761                                  ;	     individual tokens.  That distinction is no longer needed for
 12762                                  ;	     FOR loop processing.
 12763                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12764                                  ;	     1 when Cparse is called from COPY.
 12765                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12766                                  ;	     mod.  It now is conditional on flag like previous mod.
 12767                                  ;11/21/83 NP  Added printf
 12768                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12769                                  ;	     be added to a token.
 12770                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12771                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12772                                  ;	     special values:  -1 meaning destination was never opened and
 12773                                  ;	     0 which means that the destination has been openned and
 12774                                  ;	     closed.
 12775                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12776                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12777                                  ;	     lost on large and multiple file (wildcard) copies.
 12778                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12779                                  ;	     destination are not equal.
 12780                                  ;
 12781                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12782                                  ;	     first source file AND we run out of disk space before
 12783                                  ;	     completing the concatenation, restore the first source
 12784                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12785                                  ;
 12786                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12787                                  ;		instead of compatibility mode. This gives lesser sharing
 12788                                  ;		violations when files are opened for read on a copy.
 12789                                  
 12790                                  ; ---------------------------------------------------------------------------
 12791                                  ;***	COPY CODE
 12792                                  ; ---------------------------------------------------------------------------
 12793                                  
 12794                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12795                                  
 12796                                  COPY:
 12797                                  	; 	Initialize internal variables.
 12798                                  
 12799 000029E5 31C0                    		xor	ax,ax		; AX = 0
 12800 000029E7 A3[4044]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12801 000029EA A3[7545]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12802 000029ED A3[C144]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12803 000029F0 A2[8042]                		mov	[CFLAG],al	; 'destination file created' = false
 12804 000029F3 A3[8442]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12805 000029F6 A3[7C42]                		mov	[DESTSWITCH],ax	; destination switches = none
 12806 000029F9 A3[8745]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12807 000029FC A3[5E44]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12808 000029FF A2[8142]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12809 00002A02 A2[5D44]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12810 00002A05 A2[C044]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12811 00002A08 A2[6044]                		mov	[DESTINFO],al	; destination pathname flags = none
 12812 00002A0B A2[C344]                		mov	[SRCINFO],al	; source pathname flags = none
 12813 00002A0E A2[7745]                		mov	[INEXACT],al	; 'inexact copy' = false
 12814 00002A11 A2[5C44]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12815 00002A14 A2[BF44]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12816 00002A17 A2[4341]                		mov	[USERDIR1],al	; saved working directory = null
 12817 00002A1A A2[7945]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12818 00002A1D A2[7442]                		mov	[RDEOF],al	; 'read end of file' = false
 12819 00002A20 A3[1B45]                		mov	[SRCHAND],ax	; source handle = 0
 12820 00002A23 A3[8145]                		mov	[CPDATE],ax	; copy date = 0
 12821 00002A26 A3[8345]                		mov	[CPTIME],ax	; copy time = 0
 12822 00002A29 A2[1D45]                		mov	[SRCISDEV],al	; 'source is device' = false
 12823                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12824                                  		;mov	[OFilePtr_Lo],ax
 12825                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12826 00002A2C A2[7D45]                		mov	[TERMREAD],al	; 'terminate read' = false
 12827 00002A2F A2[B643]                		mov	[COMMA],al	; '"+,," found' = false
 12828 00002A32 A2[B743]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12829 00002A35 A3[7E42]                		mov	[ALLSWITCH],ax	; all switches = none
 12830 00002A38 A2[7742]                		mov	[ARGC],al	; source/dest argument count = 0
 12831 00002A3B A2[7F45]                		mov	[PLUS],al	; '"+" in command line' = false
 12832 00002A3E A2[7A45]                		mov	[BINARY],al	; 'binary copy' = false
 12833 00002A41 A2[7E45]                		mov	[ASCII],al	; 'ascii copy' = false
 12834 00002A44 A3[8942]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12835 00002A47 A3[7B45]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12836 00002A4A A2[7642]                		mov	[CONCAT],al	; 'concatenating' = false
 12837 00002A4D A2[BC44]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12838 00002A50 A3[BD44]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12839                                  
 12840                                  	;	Initialize buffers with double-nulls.
 12841                                  
 12842 00002A53 A3[1E45]                		mov	[SCANBUF],ax
 12843 00002A56 A3[6144]                		mov	[DESTBUF],ax
 12844 00002A59 A3[C444]                		mov	[SRCBUF],ax
 12845 00002A5C A3[A043]                		mov	[SDIRBUF],ax
 12846 00002A5F A3[5A43]                		mov	[DIRBUF],ax
 12847 00002A62 A3[1743]                		mov	[DESTFCB],ax
 12848                                  
 12849 00002A65 A2[8045]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 12850                                  		
 12851 00002A68 48                      		dec	ax		; AX = 0FFFFh
 12852 00002A69 A3[B844]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 12853 00002A6C A2[8642]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 12854 00002A6F A2[BB44]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 12855 00002A72 A2[5C44]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 12856                                  		
 12857 00002A75 BE8100                  		mov	si,81h		; SI = ptr to command line
 12858 00002A78 8A1E[EF3E]              		mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 12859 00002A7C FE06[9745]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 12860 00002A80 C606[4644]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 12861                                  
 12862                                  	;*	Scan the command line for destination information.
 12863                                  
 12864                                  DESTSCAN:
 12865 00002A85 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 12866 00002A87 BF[1E45]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 12867                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 12868 00002A8A E87708                  		call	CPARSE			; parse next object
 12869 00002A8D 9C                      		pushf				; save CParse flags
 12870 00002A8E FE06[8045]              		inc	byte [OBJCNT]		; count object
 12871 00002A92 F6C780                  		test	bh,80h
 12872 00002A95 7405                    		jz	short NOCOPY		; no "+" delimiter
 12873 00002A97 C606[7F45]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 12874                                  NOCOPY:
 12875 00002A9C F6C701                  		test	bh,1
 12876 00002A9F 740D                    		jz	short TESTP2		; not a switch
 12877                                  
 12878                                  	;	Found a switch.
 12879                                  
 12880                                  		; MSDOS 6.0
 12881                                  		;test	bp,SwitchV		;AN038; Verify requested?
 12882                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12883                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 12884                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12885                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 12886                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 12887                                  
 12888                                  NOT_SLASHV:
 12889 00002AA1 092E[7C42]              		or	[DESTSWITCH],bp		; assume destination
 12890 00002AA5 092E[7E42]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 12891                                  
 12892                                  		; MSDOS 6.0
 12893                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 12894                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 12895                                  		;popf				;AN018; fix up stack
 12896                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 12897                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 12898                                  		;jmp	CError			;AC018; exit
 12899                                  
 12900                                  NOT_BAD_SWITCH:
 12901 00002AA9 9D                      		popf				; restore CParse flags
 12902 00002AAA 7233                    		jc	short CHECKDONE		; found CR
 12903 00002AAC EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 12904                                  
 12905                                  TESTP2:
 12906 00002AAE 9D                      		popf				; restore CParse flags
 12907 00002AAF 722E                    		jc	short CHECKDONE		; found CR
 12908 00002AB1 F6C780                  		test	bh,80h
 12909 00002AB4 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 12910 00002AB6 FE06[7742]              		inc	byte [ARGC]		; count independent pathname args
 12911                                  GOTPLUS:
 12912 00002ABA 56                      		push	si			; save cmd line ptr
 12913 00002ABB A1[8745]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 12914 00002ABE BE[1E45]                		mov	si,SCANBUF		; SI = ptr to path string
 12915 00002AC1 29F0                    		sub	ax,si			; AX = offset of last element
 12916 00002AC3 BF[6144]                		mov	di,DESTBUF		; DI = ptr to destination buf
 12917 00002AC6 01F8                    		add	ax,di			; AX = ptr to last element in
 12918                                  						;  destination path buffer
 12919 00002AC8 A3[5E44]                		mov	[DESTTAIL],ax		; save ptr to last element
 12920 00002ACB 880E[5D44]              		mov	[DESTSIZ],cl		; save path string length
 12921 00002ACF 41                      		inc	cx			; CX = mov length (incl null)
 12922 00002AD0 F3A4                    		rep movsb			; DestBuf = possible destination path
 12923 00002AD2 883E[6044]              		mov	[DESTINFO],bh		; save CParse info flags
 12924 00002AD6 C706[7C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12925 00002ADC 5E                      		pop	si			; SI = ptr into cmd line again
 12926 00002ADD EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 12927                                  
 12928                                  CHECKDONE:
 12929                                  
 12930                                  	;	We reached the CR. The destination scan is finished.
 12931                                  
 12932                                  	;	Disallow "copy file1+" as file overwriting itself.
 12933                                  	;
 12934                                  	;	(Note that "copy file1+file2+" will be accepted, and
 12935                                  	;	equivalent to "copy file1+file2".)
 12936                                  
 12937                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 12938                                  	;	through this check, since the switch would count
 12939                                  	;	as another object in ObjCnt.
 12940                                  
 12941 00002ADF 803E[7F45]01            		cmp	byte [PLUS],1		; "+" with
 12942 00002AE4 7514                    		jnz	short CDCONT
 12943 00002AE6 803E[7742]01            		cmp	byte [ARGC],1		; one arg,
 12944 00002AEB 750D                    		jnz	short CDCONT
 12945 00002AED 803E[8045]02            		cmp	byte [OBJCNT],2		; two objects..
 12946 00002AF2 7506                    		jnz	short CDCONT
 12947 00002AF4 BA[8438]                		mov	dx,OVERWRPTR
 12948 00002AF7 E9B605                  		jmp	COPYERR			; is file overwrite
 12949                                  
 12950                                  CDCONT:
 12951 00002AFA A0[7F45]                		mov	al,[PLUS]		; AL = '"+" occurred'
 12952 00002AFD A2[7642]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 12953 00002B00 D0E0                    		shl	al,1
 12954 00002B02 D0E0                    		shl	al,1
 12955 00002B04 A2[7745]                		mov	[INEXACT],al		; therefore making an inexact copy
 12956 00002B07 BA[5D3D]                		mov	dx,BADARGSPTR
 12957 00002B0A A0[7742]                		mov	al,[ARGC]		; AL = # independent arguments
 12958 00002B0D 08C0                    		or	al,al
 12959 00002B0F 7404                    		jz	short CERROR4J
 12960                                  
 12961                                  		; MSDOS 6.0
 12962                                  		;or	al,al
 12963                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 12964                                  		
 12965                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12966                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 12967                                  		;jmp	short CError_ParseJ		; take parse error exit		
 12968                                  
 12969                                  	; more than 0 args; check if too many
 12970                                  
 12971                                  TRY_TOO_MANY:
 12972 00002B11 3C02                    		cmp	al,2
 12973 00002B13 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 12974                                  
 12975                                  		; MSDOS 6.0
 12976                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12977                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 12978                                  ;CError_ParseJ:
 12979                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 12980                                  
 12981                                  CERROR4J:
 12982 00002B15 E90BF1                  		jmp	CERROR
 12983                                  
 12984                                  ACOUNTOK:
 12985 00002B18 BD[5C44]                		mov	bp,DESTVARS		; BP = base of dest variables
 12986                                  
 12987 00002B1B 3C01                    		cmp	al,1
 12988 00002B1D 7522                    		jnz	short GOT2ARGS
 12989                                  
 12990                                  	;	Only one independent pathname argument on command line.
 12991                                  	;	Set destination to d:*.*, where d: is current drive.
 12992                                  
 12993                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 12994                                  	;	The two files would be appended as d:file1, rather than x:file1.
 12995                                  
 12996 00002B1F A0[7542]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 12997 00002B22 0206[E03E]              		add	al,[CAPITAL_A]		; AL = current drive letter
 12998 00002B26 B43A                    		mov	ah,':'			; AX = "d:"
 12999                                  		;mov	byte [bp+1],2
 13000 00002B28 C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 13001                                  
 13002 00002B2C BF[6144]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 13003 00002B2F AB                      		stosw				; store "d:"
 13004                                  		
 13005 00002B30 C706[7C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 13006                                  		;mov	byte [bp+4],2		
 13007 00002B36 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13008                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13009                                  		;mov	byte [bp+0],0		
 13010 00002B3A C6460000                		mov	byte [bp],0
 13011 00002B3E E89307                  		call	SETSTARS		; add wildcards
 13012                                  GOT2ARGS:
 13013                                  
 13014                                  	;	If destination pathname is "d:", add full wildcard filename
 13015                                  
 13016                                  		;cmp	byte [bp+1],2
 13017 00002B41 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13018 00002B45 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13019 00002B47 B03A                    		mov	al,':'
 13020 00002B49 3806[6244]              		cmp	byte [DESTBUF+1],al
 13021 00002B4D 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13022                                  		;or	byte [bp+4],2
 13023 00002B4F 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13024 00002B53 BF[6344]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13025                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13026                                  		;mov	byte [bp+0],0		
 13027 00002B56 C6460000                		mov	byte [bp],0
 13028 00002B5A E87707                  		call	SETSTARS		; add wildcards
 13029                                  
 13030                                  NOTSHORTDEST:
 13031                                  
 13032                                  	;	If destination pathname ends with "\", try to make
 13033                                  	;	sure it's "d:\".
 13034                                  
 13035                                  		;mov	di,[bp+2]
 13036 00002B5D 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13037 00002B60 803D00                  		cmp	byte [di],0
 13038 00002B63 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13039                                  
 13040 00002B65 BA[663B]                		mov	dx,BADCDPTR
 13041 00002B68 B03A                    		mov	al,':'
 13042 00002B6A 3845FE                  		cmp	[di-2],al
 13043 00002B6D 75A6                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13044                                  		;mov	byte [bp+0],2
 13045                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13046 00002B6F C6460002                		mov	byte [bp],2
 13047                                  		;or	byte [bp+4],6
 13048 00002B73 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13049                                  						  ;  path character
 13050 00002B77 E85A07                  		call	SETSTARS		; add wildcards
 13051                                  
 13052                                  CHKSWTCHES:
 13053                                  
 13054                                  	;	We have enough information about the destination for now.
 13055                                  
 13056                                  	;	Turn on verify if requested. Save the current verify flag.
 13057                                  
 13058 00002B7A BA[123A]                		mov	dx,BADPARMPTR
 13059 00002B7D A1[7E42]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13060                                  
 13061                                  		; MSDOS 3.3
 13062                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13063 00002B80 A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13064 00002B83 7590                    		jnz	short CERROR4J
 13065                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13066 00002B85 A91000                  		test	ax,SWITCHV ; 10h
 13067 00002B88 7414                    		jz	short NOVERIF		; no /v, no verify
 13068                                  
 13069 00002B8A B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13070 00002B8C CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13071                                  					; Return: AL = 00h if flag OFF
 13072                                  					; AL = 01h if flag ON
 13073 00002B8E 1E                      		push	ds
 13074 00002B8F 8E1E[6142]              		mov	ds,[RESSEG]
 13075 00002B93 30E4                    		xor	ah,ah
 13076 00002B95 A3F70B                  		mov	word [VERVAL],ax	; save current verify flag
 13077 00002B98 1F                      		pop	ds
 13078 00002B99 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13079 00002B9C CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13080                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13081                                  NOVERIF:
 13082                                  		;*	Scan for first source.
 13083                                  
 13084 00002B9E 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13085 00002BA0 BE8100                  		mov	si,81h			; SI = ptr into command line
 13086 00002BA3 8A1E[EF3E]              		mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13087                                  SCANFSRC:
 13088 00002BA7 BF[1E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13089 00002BAA E85707                  		call	CPARSE			; parse first source pathname
 13090 00002BAD F6C701                  		test	bh,1			; switch?
 13091 00002BB0 75F5                    		jnz	short SCANFSRC		; yes, try again
 13092 00002BB2 092E[7C42]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13093                                  
 13094                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13095                                  
 13096                                  		;test	bp,8
 13097 00002BB6 F7C50800                		test	bp,SWITCHB
 13098 00002BBA 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13099 00002BBC 803E[7642]00            		cmp	byte [CONCAT],0
 13100 00002BC1 7405                    		je	short NOSETCASC		; we're not concatenating
 13101                                  		;mov	byte [ASCII],4
 13102 00002BC3 C606[7E45]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13103                                  NOSETCASC:
 13104 00002BC8 E89703                  		call	SOURCE_SET		; set source variables
 13105 00002BCB E83B00                  		call	FRSTSRC			; set up first source copy
 13106 00002BCE E99000                  		jmp	FIRSTENT		; jump into the copy loop
 13107                                  
 13108                                  ; ---------------------------------------------------------------------------
 13109                                  
 13110                                  ENDCOPY:
 13111                                  
 13112                                  	;*	End of the road. Close destination, display # files
 13113                                  	;	copied (meaning # destinations), and go back to main
 13114                                  	;	transient COMMAND code.
 13115                                  
 13116 00002BD1 E8A802                  		call	CLOSEDEST
 13117                                  ENDCOPY2:
 13118 00002BD4 BA[EE38]                		mov	dx,COPIEDPTR
 13119 00002BD7 8B36[8942]              		mov	si,[FILECNT]
 13120 00002BDB 8936[4044]              		mov	[COPY_NUM],si
 13121 00002BDF E8E108                  		call	STD_PRINTF
 13122 00002BE2 E91FD5                  		jmp	TCOMMAND		; stack could be messed up
 13123                                  
 13124                                  ; ---------------------------------------------------------------------------
 13125                                  
 13126                                  SRCNONEXIST:
 13127                                  
 13128                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13129                                  	;	Otherwise, say 'file not found' and quit.
 13130                                  
 13131 00002BE5 803E[7642]00            		cmp	byte [CONCAT],0
 13132 00002BEA 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13133                                  
 13134                                  		; MSDOS 3.3
 13135 00002BEC BA[C444]                		mov	dx,SRCBUF
 13136 00002BEF 8916[3844]              		mov	[STRING_PTR_1],dx
 13137 00002BF3 BA[1D37]                		mov	dx,STRINGBUF1PTR
 13138 00002BF6 E8CA08                  		call	STD_PRINTF
 13139 00002BF9 BA[E837]                		mov	dx,FNOTFOUNDPTR
 13140 00002BFC E9B104                  		jmp	COPYERR
 13141                                  
 13142                                  		; MSDOS 6.0
 13143                                  	;	Set up error message.
 13144                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13145                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13146                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13147                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13148                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13149                                  		;
 13150                                  		;jmp	CopErr			; print msg and clean up
 13151                                  
 13152                                  ; ---------------------------------------------------------------------------
 13153                                  
 13154                                  SOURCEPROC:
 13155                                  
 13156                                  	;*	Preparatory processing for each source file.
 13157                                  	;	Called at FrstSrc for first source file.
 13158                                  
 13159 00002BFF E86003                  		call	SOURCE_SET		; set source variables & ascii/binary
 13160 00002C02 803E[7642]00            		cmp	byte [CONCAT],0
 13161 00002C07 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13162                                  
 13163                                  ; ---------------------------------------------------------------------------
 13164                                  
 13165                                  FRSTSRC:
 13166 00002C09 31C0                    		xor	ax,ax
 13167 00002C0B A2[8042]                		mov	[CFLAG],al		; 'destination not created'
 13168 00002C0E A3[8442]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13169 00002C11 A2[8142]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13170                                  
 13171                                  LEAVECFLAG:
 13172 00002C14 8936[7545]              		mov	[SRCPT],si		; save cmd-line ptr
 13173 00002C18 BF[4341]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13174                                  						;   current dir
 13175 00002C1B BD[BF44]                		mov	bp,SRCVARS		; BP = base of source variables
 13176 00002C1E E8D705                  		call	BUILDPATH		; cd to source dir, figure
 13177                                  						;   out stuff about source
 13178 00002C21 8B36[C144]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13179 00002C25 C3                      		retn
 13180                                  
 13181                                  ; ---------------------------------------------------------------------------
 13182                                  
 13183                                  NEXTSRC:
 13184                                  
 13185                                  	;*	Next source. Come here after handling each pathname.
 13186                                  	;	We're done unless there are additional source pathnames
 13187                                  	;	to be appended.
 13188                                  	;
 13189                                  	;	Note that all files matching an ambiguous pathname
 13190                                  	;	are processed before coming here.
 13191                                  
 13192 00002C26 803E[7F45]00            		cmp	byte [PLUS],0
 13193 00002C2B 7502                    		jne	short MORECP		; copying "+" sources - keep going
 13194                                  
 13195                                  ENDCOPYJ2:
 13196 00002C2D EBA2                    		jmp	short ENDCOPY
 13197                                  
 13198                                  MORECP:
 13199 00002C2F 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13200 00002C31 8B36[7545]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13201 00002C35 8A1E[EF3E]              		mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13202                                  
 13203                                  SCANSRC:
 13204 00002C39 BF[1E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13205 00002C3C E8C506                  		call	CPARSE			; parse first source name
 13206 00002C3F 72EC                    		jb	short ENDCOPYJ2		; CR found - we're done
 13207                                  
 13208 00002C41 F6C780                  		test	bh,80h
 13209 00002C44 74E7                    		jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13210                                  
 13211 00002C46 F6C701                  		test	bh,1
 13212 00002C49 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13213                                  
 13214                                  	;	ScanBuf contains the next source pathname.
 13215                                  
 13216 00002C4B E8B1FF                  		call	SOURCEPROC		; prepare this source
 13217 00002C4E 803E[B643]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13218 00002C53 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13219 00002C55 C606[B743]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13220 00002C5A EB89                    		jmp	short SRCNONEXIST	; we know we won't find it
 13221                                  
 13222                                  NOSTAMP:
 13223 00002C5C C606[B743]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13224                                  
 13225                                  ; ---------------------------------------------------------------------------
 13226                                  
 13227                                  FIRSTENT:
 13228                                  
 13229                                  ;M047
 13230                                  ; The only case we need to worry about is when the source is wildcarded and
 13231                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13232                                  ;concatenation. We check for this case.
 13233                                  ;
 13234                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13235                                  ;right place to do this check.
 13236                                  
 13237                                  	;	This is where we enter the loop with the first source.
 13238                                  
 13239 00002C61 BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13240 00002C64 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13241 00002C67 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13242                                  					; DS:SI	-> string to parse
 13243                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13244                                  					; AL = bit mask	to control parsing
 13245 00002C69 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13246 00002C6C 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13247 00002C6E A1[C444]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13248 00002C71 80FC3A                  		cmp	ah,':'
 13249 00002C74 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13250 00002C76 B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13251                                  DRVSPEC1:
 13252 00002C78 0C20                    		or	al,20h			; AL = lowercase drive letter
 13253 00002C7A 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13254                                  		;mov	[5Ch],al
 13255 00002C7C A25C00                  		mov	[FCB],al		; put drive id in FCB
 13256                                  
 13257                                  	;	FCB contains drive and filename to search.
 13258                                  		
 13259 00002C7F B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13260 00002C81 E80701                  		call	SEARCH
 13261                                  SRCHDONE:
 13262 00002C84 9C                      		pushf				; save flags from Search
 13263 00002C85 E806EC                  		call	RESTUDIR1		; restore users current directory
 13264 00002C88 9D                      		popf				; restore flags from search
 13265 00002C89 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13266 00002C8B E957FF                  		jmp	SRCNONEXIST		; didn't find the source
 13267                                  
 13268                                  NEXTAMBIG0:
 13269 00002C8E 30C0                    		xor	al,al
 13270 00002C90 8606[8642]              		xchg	al,[FRSTSRCH]
 13271 00002C94 08C0                    		or	al,al
 13272 00002C96 740B                    		jz	short NEXTAMBIG
 13273                                  SETNMEL:
 13274 00002C98 B90C00                  		mov	cx,12
 13275 00002C9B BF[A043]                		mov	di,SDIRBUF
 13276 00002C9E BE[5A43]                		mov	si,DIRBUF
 13277 00002CA1 F3A4                    		rep movsb			; save very first source name
 13278                                  NEXTAMBIG:
 13279 00002CA3 30C0                    		xor	al,al
 13280 00002CA5 A2[7945]                		mov	[NOWRITE],al		; turn off nowrite
 13281 00002CA8 8B3E[C144]              		mov	di,[SRCTAIL]
 13282 00002CAC BE[5B43]                		mov	si,DIRBUF+1
 13283 00002CAF E8E6EC                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13284                                  MELDO:
 13285 00002CB2 803E[7642]00            		cmp	byte [CONCAT],0
 13286 00002CB7 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13287 00002CB9 F606[C344]02            		test	byte [SRCINFO],2	; wildcard - show name
 13288 00002CBE 7410                    		jz	short DOREAD
 13289                                  SHOWCPNAM:
 13290 00002CC0 BA[C444]                		mov	dx,SRCBUF
 13291 00002CC3 8916[3E44]              		mov	[STRING_PTR_2],dx
 13292 00002CC7 BA[2F37]                		mov	dx,STRINGBUF2PTR
 13293 00002CCA E8F607                  		call	STD_PRINTF
 13294 00002CCD E89CEC                  		call	CRLF2
 13295                                  DOREAD:
 13296 00002CD0 E8C900                  		call	DOCOPY
 13297 00002CD3 803E[7642]00            		cmp	byte [CONCAT],0
 13298 00002CD8 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13299                                  
 13300 00002CDA E89F01                  		call	CLOSEDEST		; close current destination
 13301 00002CDD 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13302                                  
 13303 00002CDF C606[8042]00            		mov	byte [CFLAG],0		; 'destination not created'
 13304                                  NODCLOSE:
 13305 00002CE4 803E[7642]00            		cmp	byte [CONCAT],0		
 13306 00002CE9 740C                    		jz	short NOFLUSH
 13307                                  
 13308                                  ;	Concatenating - flush output between source files so LostErr
 13309                                  ;	stuff works correctly.
 13310                                  
 13311                                  		;invoke	FlshFil  ; MSDOS 6.0
 13312                                  
 13313 00002CEB E8AA02                  		call	FLUSHFIL ; MSDOS 3.3
 13314 00002CEE F606[BC44]FF            		test	byte [MELCOPY],0FFh
 13315 00002CF3 7402                    		jz	short NOFLUSH
 13316 00002CF5 EB0C                    		jmp	short DOMELCOPY
 13317                                  NOFLUSH:
 13318 00002CF7 E88500                  		call	SEARCHNEXT		; try next match
 13319 00002CFA 755F                    		jnz	short NEXTSRCJ		; not found - finished with 
 13320                                  						;   this source spec
 13321 00002CFC C606[8142]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13322                                  
 13323 00002D01 EBA0                    		jmp	short NEXTAMBIG		; do next ambig match
 13324                                  
 13325                                  DOMELCOPY:
 13326 00002D03 803E[BC44]FF            		cmp	byte [MELCOPY],0FFh
 13327 00002D08 740D                    		je	short CONTMEL
 13328 00002D0A 8B36[7545]              		mov	si,[SRCPT]
 13329 00002D0E 8936[BD44]              		mov	[MELSTART],si
 13330 00002D12 C606[BC44]FF            		mov	byte [MELCOPY],0FFh
 13331                                  
 13332                                  CONTMEL:
 13333 00002D17 31ED                    		xor	bp,bp
 13334 00002D19 8B36[7545]              		mov	si,[SRCPT]
 13335 00002D1D 8A1E[EF3E]              		mov	bl,[PLUS_CHR]
 13336                                  SCANSRC2:
 13337 00002D21 BF[1E45]                		mov	di,SCANBUF
 13338 00002D24 E8DD05                  		call	CPARSE
 13339 00002D27 F6C780                  		test	bh,80h
 13340 00002D2A 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13341 00002D2C F6C701                  		test	bh,1
 13342 00002D2F 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13343 00002D31 E8CBFE                  		call	SOURCEPROC
 13344 00002D34 E857EB                  		call	RESTUDIR1
 13345 00002D37 BF[DB42]                		mov	di,DESTFCB2
 13346 00002D3A B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13347 00002D3D CD21                    		int	21h		; DOS -	PARSE FILENAME
 13348                                  					; DS:SI	-> string to parse
 13349                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13350                                  					; AL = bit mask	to control parsing
 13351 00002D3F BB[A143]                		mov	bx,SDIRBUF+1
 13352 00002D42 BE[DC42]                		mov	si,DESTFCB2+1
 13353 00002D45 8B3E[C144]              		mov	di,[SRCTAIL]
 13354                                  
 13355 00002D49 E87B04                  		call	BUILDNAME
 13356                                  
 13357 00002D4C 803E[7642]00            		cmp	byte [CONCAT],0
 13358 00002D51 7405                    		je	short MELDOJ		; not concatenating - continue
 13359                                  
 13360                                  	;	Yes, turn off nowrite because this part of the code 
 13361                                  	;	is only reached after the first file has been dealt with.
 13362                                  
 13363 00002D53 C606[7945]00            		mov	byte [NOWRITE],0
 13364                                  MELDOJ:
 13365 00002D58 E957FF                  		jmp	MELDO
 13366                                  
 13367                                  NEXTSRCJ:
 13368 00002D5B E9C8FE                  		jmp	NEXTSRC
 13369                                  
 13370                                  NEXTMEL:
 13371 00002D5E E81B01                  		call	CLOSEDEST
 13372 00002D61 31C0                    		xor	ax,ax
 13373 00002D63 A2[8042]                		mov	[CFLAG],al
 13374 00002D66 A3[8442]                		mov	[NXTADD],ax
 13375 00002D69 A2[8142]                		mov	[SPECDRV],al
 13376 00002D6C 8B36[BD44]              		mov	si,[MELSTART]
 13377 00002D70 8936[7545]              		mov	[SRCPT],si
 13378 00002D74 E80800                  		call	SEARCHNEXT
 13379 00002D77 7403                    		jz	short SETNMELJ
 13380 00002D79 E958FE                  		jmp	ENDCOPY2
 13381                                  
 13382                                  SETNMELJ:
 13383 00002D7C E919FF                  		jmp	SETNMEL
 13384                                  
 13385                                  ; ---------------------------------------------------------------------------
 13386                                  
 13387                                  SEARCHNEXT:
 13388 00002D7F B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13389 00002D81 F606[C344]02            		test	byte [SRCINFO],2
 13390 00002D86 7503                    		jnz	short SEARCH		; do search-next if ambig
 13391 00002D88 08E4                    		or	ah,ah			; reset zero flag
 13392 00002D8A C3                      		retn
 13393                                  
 13394                                  ; ---------------------------------------------------------------------------
 13395                                  
 13396                                  SEARCH:
 13397 00002D8B 50                      		push	ax
 13398 00002D8C B41A                    		mov	ah,SET_DMA ; 1Ah
 13399 00002D8E BA[5A43]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13400 00002D91 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13401                                  				; DS:DX	-> disk	transfer buffer
 13402 00002D93 58                      		pop	ax		; restore search first/next command
 13403 00002D94 BA5C00                  		mov	dx,FCB ; 5Ch
 13404 00002D97 CD21                    		int	21h		; Do the search
 13405 00002D99 08C0                    		or	al,al
 13406 00002D9B C3                      		retn
 13407                                  
 13408                                  ; ---------------------------------------------------------------------------
 13409                                  
 13410                                  DOCOPY:
 13411 00002D9C BE[C444]                		mov	si,SRCBUF	; do name translate of source
 13412 00002D9F BF[8F3F]                		mov	di,SRCXNAME	; save for name comparison
 13413 00002DA2 B460                    		mov	ah,XNAMETRANS ; 60h
 13414 00002DA4 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13415                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13416                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13417 00002DA6 C606[7442]00            		mov	byte [RDEOF],0	; no EOF yet
 13418                                  
 13419                                  		; MSDOS 6.0
 13420                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13421                                  ;M046
 13422                                  ; For reads, the sharing mode should be deny none so that any process can
 13423                                  ;open this file again in any other sharing mode. This is mainly to allow
 13424                                  ;multiple command.com's to access the same file without getting sharing
 13425                                  ;violations
 13426                                  ;
 13427                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
 13428                                  		;xor	cx,cx				; no special files
 13429                                  		;mov	dx,READ_OPEN_FLAG		; set up open flags
 13430                                  		;int	21h
 13431                                  		;
 13432                                  		;jnc	OpenOk
 13433                                  
 13434                                  	;	Bogosity:  IBM wants us to issue Access Denied in this case.
 13435                                  	;	They asked for it...
 13436                                  
 13437                                  		;jmp	short Error_On_Source 		;AC022; clean up and exit
 13438                                  
 13439                                  		; MSDOS 3.3
 13440 00002DAB BA[C444]                		mov	dx,SRCBUF
 13441 00002DAE B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13442 00002DB1 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13443                                  					; DS:DX	-> ASCIZ filename
 13444                                  					; AL = access mode
 13445                                  					; 0 - read
 13446 00002DB3 7311                    		jnc	short OPENOK
 13447 00002DB5 E80CF1                  		call	GET_EXT_ERR_NUMBER
 13448 00002DB8 9C                      		pushf
 13449 00002DB9 83F841                  		cmp	ax,65
 13450 00002DBC 7506                    		jnz	short DOCOPY_ERR
 13451 00002DBE BA[0D38]                		mov	dx,ACCDENPTR
 13452 00002DC1 E8FF06                  		call	STD_PRINTF
 13453                                  DOCOPY_ERR:
 13454 00002DC4 9D                      		popf
 13455 00002DC5 C3                      		retn
 13456                                  
 13457                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13458                                  OPENOK:
 13459 00002DC6 89C3                    		mov	bx,ax
 13460 00002DC8 891E[1B45]              		mov	[SRCHAND],bx		; save handle
 13461 00002DCC B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13462 00002DCF CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13463                                  					; BX = file handle
 13464                                  
 13465                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13466                                  
 13467 00002DD1 8916[8145]              		mov	[CPDATE],dx		; save date
 13468 00002DD5 890E[8345]              		mov	[CPTIME],cx		; save time
 13469                                  
 13470                                  		; MSDOS 6.0
 13471                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13472                                  
 13473                                  ;Error_On_Source:				;AN022; we have a BAD error
 13474                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13475                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13476                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13477                                  		;invoke	Std_EprintF		;AN022; print it
 13478                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13479                                  		;je	No_Close_Src		;AN022; no - don't close
 13480                                  		;call	CloseSrc		;AN022; clean up
 13481                                  ;No_Close_Src:					;AN022;
 13482                                  		;cmp	CFlag,0			;AN022; was destination created?
 13483                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13484                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13485                                  ;EndCopyJ3:					;AN022;
 13486                                  		;jmp	EndCopy2		;AN022;
 13487                                  ;No_Copy_Xa:
 13488                                  		;mov	bx,SrcHand		;AN022; get handle back
 13489                                  
 13490                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13491 00002DD9 B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13492 00002DDC CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13493                                  					; BX = file or device handle
 13494 00002DDE 80E280                  		and	dl,devid_ISDEV ; 80h
 13495 00002DE1 8816[1D45]              		mov	[SRCISDEV],dl		; set source info
 13496 00002DE5 740D                    		jz	short COPYLP		; source not a device
 13497 00002DE7 803E[7A45]00            		cmp	byte [BINARY],0
 13498 00002DEC 7406                    		je	short COPYLP		; ascii device ok
 13499 00002DEE BA[EB3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13500 00002DF1 E9BC02                  		jmp	COPYERR
 13501                                  
 13502                                  COPYLP:
 13503 00002DF4 8B1E[1B45]              		mov	bx,[SRCHAND]
 13504 00002DF8 8B0E[8242]              		mov	cx,[BYTCNT]
 13505 00002DFC 8B16[8442]              		mov	dx,[NXTADD]
 13506 00002E00 29D1                    		sub	cx,dx			; compute available space
 13507 00002E02 750E                    		jnz	short GOTROOM
 13508                                  		;invoke	FlshFil   ; MSDOS 6.0
 13509 00002E04 E89101                  		call	FLUSHFIL  ; MSDOS 3.3
 13510 00002E07 803E[7D45]00            		cmp	byte [TERMREAD],0
 13511 00002E0C 7565                    		jne	short CLOSESRC		; give up
 13512 00002E0E 8B0E[8242]              		mov	cx,[BYTCNT]
 13513                                  GOTROOM:
 13514 00002E12 1E                      		push	ds
 13515 00002E13 8E1E[6342]              		mov	ds,[TPA]
 13516 00002E17 B43F                    		mov	ah,READ ; 3Fh
 13517 00002E19 CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13518                                  					; BX = file handle,CX = number	of bytes to read
 13519                                  					; DS:DX	-> buffer
 13520 00002E1B 1F                      		pop	ds
 13521 00002E1C 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13522                                  		;jc	Error_On_Source ; MSDOS 6.0
 13523 00002E1E 89C1                    		mov	cx,ax			; get count
 13524 00002E20 E351                    		jcxz	CLOSESRC		; no more to read
 13525 00002E22 803E[1D45]00            		cmp	byte [SRCISDEV],0
 13526 00002E27 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13527 00002E29 803E[7E45]00            		cmp	byte [ASCII],0
 13528 00002E2E 741B                    		je	short BINREAD
 13529                                  NOTESTA:
 13530 00002E30 89CA                    		mov	dx,cx
 13531 00002E32 8B3E[8442]              		mov	di,[NXTADD]
 13532 00002E36 B01A                    		mov	al,1Ah
 13533 00002E38 06                      		push	es
 13534 00002E39 8E06[6342]              		mov	es,[TPA]		; scan for EOF
 13535 00002E3D F2AE                    		repne scasb
 13536 00002E3F 07                      		pop	es
 13537 00002E40 7505                    		jnz	short USEALL
 13538 00002E42 FE06[7442]              		inc	byte [RDEOF]
 13539 00002E46 41                      		inc	cx
 13540                                  USEALL:
 13541 00002E47 29CA                    		sub	dx,cx
 13542 00002E49 89D1                    		mov	cx,dx
 13543                                  BINREAD:
 13544 00002E4B 030E[8442]              		add	cx,[NXTADD]
 13545 00002E4F 890E[8442]              		mov	[NXTADD],cx
 13546 00002E53 3B0E[8242]              		cmp	cx,[BYTCNT]		; is buffer full?
 13547 00002E57 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13548                                  		;invoke	FlshFil
 13549 00002E59 E83C01                  		call	FLUSHFIL
 13550 00002E5C 803E[7D45]00            		cmp	byte [TERMREAD],0
 13551 00002E61 7510                    		jne	short CLOSESRC		; give up
 13552 00002E63 EB8F                    		jmp	short COPYLP
 13553                                  TESTDEV:
 13554 00002E65 803E[1D45]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13555 00002E6A 7407                    		je	short CLOSESRC
 13556 00002E6C 803E[7442]00            		cmp	byte [RDEOF],0
 13557 00002E71 7481                    		je	short COPYLP		; on device, go till ^Z
 13558                                  CLOSESRC:
 13559 00002E73 8B1E[1B45]              		mov	bx,[SRCHAND]
 13560 00002E77 B43E                    		mov	ah,CLOSE ; 3Eh
 13561 00002E79 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13562                                  					; BX = file handle
 13563                                  CLOSESRCDEST_RETN:
 13564 00002E7B C3                      		retn
 13565                                  
 13566                                  ; ---------------------------------------------------------------------------
 13567                                  
 13568                                  CLOSEDEST:
 13569                                  
 13570                                  	;	We are called to close the destination.
 13571                                  	;	We need to note whether or not there is any internal data left
 13572                                  	;	to be flushed out.
 13573                                  
 13574 00002E7C 803E[8142]00            		cmp	byte [DESTCLOSED],0
 13575 00002E81 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13576 00002E83 A0[7C42]                		mov	al,byte [DESTSWITCH]
 13577 00002E86 E86602                  		call	SETASC			; check for b or a switch
 13578 00002E89 7434                    		jz	short BINCLOS		;   on destination
 13579 00002E8B 8B1E[8442]              		mov	bx,[NXTADD]
 13580                                  ;
 13581                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13582                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13583                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13584                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13585                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13586                                  ;performance overhead on single ASCII file copies which now always involve
 13587                                  ;2 writes instead of 1 before. Is this really that important?
 13588                                  ;
 13589                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13590                                  ;M048;	jne	PutZ
 13591                                  
 13592                                  		; MSDOS 3.3
 13593 00002E8F 3B1E[8242]              		cmp	bx,[BYTCNT]	; is memory full?
 13594 00002E93 7509                    		jne	short PUTZ
 13595                                  
 13596 00002E95 E8F300                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13597 00002E98 7402                    		jz	short NOCONC
 13598                                  CONCHNG:
 13599 00002E9A F9                      		stc
 13600 00002E9B C3                      		retn
 13601                                  
 13602                                  NOCONC:	
 13603 00002E9C 31DB                    		xor	bx,bx
 13604                                  PUTZ:
 13605 00002E9E 1E                      		push	ds
 13606 00002E9F 8E1E[6342]              		mov	ds,[TPA]
 13607 00002EA3 C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13608 00002EA7 1F                      		pop	ds
 13609 00002EA8 FF06[8442]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13610 00002EAC C606[7945]00            		mov	byte [NOWRITE],0
 13611 00002EB1 A1[7B45]                		mov	ax,[WRITTEN]
 13612 00002EB4 0306[8442]              		add	ax,[NXTADD]
 13613 00002EB8 7205                    		jc	short BINCLOS	; > 1
 13614 00002EBA 83F801                  		cmp	ax,1
 13615 00002EBD 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13616                                  BINCLOS:
 13617 00002EBF E8C900                  		call	TRYFLUSH
 13618 00002EC2 75D6                    		jnz	short CONCHNG
 13619                                  
 13620 00002EC4 803E[7B45]00            		cmp	byte [WRITTEN],0
 13621                                  FORGETITJ:
 13622 00002EC9 747D                    		jz	short FORGETIT	; never wrote nothing
 13623                                  NO_FORGET:				; wrote something
 13624 00002ECB 8B1E[B844]              		mov	bx,[DESTHAND]
 13625 00002ECF 8B0E[8345]              		mov	cx,[CPTIME]
 13626 00002ED3 8B16[8145]              		mov	dx,[CPDATE]
 13627 00002ED7 803E[7745]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13628 00002EDC 7431                    		je	short DODCLOSE	; if no, copy date & time
 13629 00002EDE B42C                    		mov	ah,GET_TIME ; 2Ch
 13630 00002EE0 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13631                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13632                                  					; DL = hundredths of seconds
 13633 00002EE2 D0E1                    		shl	cl,1
 13634 00002EE4 D0E1                    		shl	cl,1		; left justify min in cl
 13635 00002EE6 D1E1                    		shl	cx,1
 13636 00002EE8 D1E1                    		shl	cx,1
 13637 00002EEA D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13638 00002EEC D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13639 00002EEE 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13640 00002EF0 51                      		push	cx		; save packed time
 13641 00002EF1 B42A                    		mov	ah,GET_DATE ; 2Ah
 13642 00002EF3 CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13643                                  					; Return: DL = day,DH = month,	CX = year
 13644                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13645 00002EF5 81E9BC07                		sub	cx,1980
 13646 00002EF9 86E9                    		xchg	ch,cl
 13647 00002EFB D1E1                    		shl	cx,1		; year to high 7 bits
 13648 00002EFD D0E6                    		shl	dh,1		; month to high 3 bits
 13649 00002EFF D0E6                    		shl	dh,1
 13650 00002F01 D0E6                    		shl	dh,1
 13651 00002F03 D0E6                    		shl	dh,1
 13652 00002F05 D0E6                    		shl	dh,1		; most sig bit of month in carry
 13653 00002F07 80D500                  		adc	ch,0		; put that bit next to year
 13654 00002F0A 08F2                    		or	dl,dh		; or low three of month into day
 13655 00002F0C 88EE                    		mov	dh,ch		; get year and high bit of month
 13656 00002F0E 59                      		pop	cx
 13657                                  DODCLOSE:
 13658 00002F0F 83FB00                  		cmp	bx,0
 13659 00002F12 7E2A                    		jle	short CLOSEDONE
 13660 00002F14 B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13661 00002F17 CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13662                                  					; BX = file handle,CX = time to be set
 13663                                  					; DX = date to be set
 13664                                  		; MSDOS 6.0
 13665                                  		;jc	Cleanup_Err	;AN022; handle error
 13666                                  
 13667                                  	;	See if the destination has *anything* in it.
 13668                                  	;	If not, just close and delete it.
 13669                                  
 13670 00002F19 B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13671 00002F1C 31D2                    		xor	dx,dx
 13672 00002F1E 89D1                    		mov	cx,dx
 13673 00002F20 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13674                                  					; AL = method: offset from end of file
 13675                                  	;	DX:AX is file size
 13676                                  
 13677 00002F22 09C2                    		or	dx,ax
 13678 00002F24 9C                      		pushf
 13679 00002F25 B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13680 00002F28 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13681                                  					; BX = file or device handle
 13682 00002F2A 52                      		push	dx			; save them away
 13683 00002F2B B43E                    		mov	ah,CLOSE ; 3Eh
 13684 00002F2D CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13685                                  					; BX = file handle
 13686 00002F2F 5A                      		pop	dx
 13687                                  
 13688                                  		; MSDOS 6.0
 13689                                  		;jnc	Close_Cont	;AN022; handle error on close
 13690                                  		;popf			;AN022; get the flags back
 13691                                  ;Cleanup_Err: 				;AN022;
 13692                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13693                                  		;call	DestDelete	;AN022; attempt to delete the target
 13694                                  		;jmp	short FileClosed ;AN022; close the file
 13695                                  ;Close_Cont:				;AN022; no error - co
 13696                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13697 00002F30 9D                      		popf
 13698 00002F31 750B                    		jnz	short CLOSEDONE
 13699 00002F33 F7C28000                		test	dx,80h		; is the destination a device?
 13700 00002F37 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13701 00002F39 E81E00                  		call	DESTDELETE
 13702 00002F3C EB04                    		jmp	short FILECLOSED
 13703                                  CLOSEDONE:
 13704 00002F3E FF06[8942]              		inc	word [FILECNT]
 13705                                  FILECLOSED:
 13706 00002F42 FE06[8142]              		inc	byte [DESTCLOSED]
 13707                                  RET50:
 13708 00002F46 F8                      		clc
 13709 00002F47 C3                      		retn
 13710                                  
 13711                                  FORGETIT:
 13712 00002F48 8B1E[B844]              		mov	bx,[DESTHAND]
 13713 00002F4C E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13714 00002F4F E80800                  		call	DESTDELETE
 13715 00002F52 C706[8942]0000          		mov	word [FILECNT],0 ; no files transferred
 13716 00002F58 EBEC                    		jmp	short RET50
 13717                                  
 13718                                  ; ---------------------------------------------------------------------------
 13719                                  
 13720                                  DESTDELETE:
 13721 00002F5A BA[6144]                		mov	dx,DESTBUF
 13722 00002F5D B441                    		mov	ah,UNLINK ; 41h
 13723 00002F5F CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13724                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13725                                  				;		(no wildcards allowed)
 13726 00002F61 C3                      		retn
 13727                                  
 13728                                  ; ---------------------------------------------------------------------------
 13729                                  
 13730                                  SOURCE_SET:
 13731 00002F62 56                      		push	si
 13732 00002F63 A1[8745]                		mov	ax,[STARTEL]
 13733 00002F66 BE[1E45]                		mov	si,SCANBUF	; adjust to copy
 13734 00002F69 29F0                    		sub	ax,si
 13735 00002F6B BF[C444]                		mov	di,SRCBUF
 13736 00002F6E 01F8                    		add	ax,di
 13737 00002F70 A3[C144]                		mov	[SRCTAIL],ax
 13738 00002F73 880E[C044]              		mov	[SRCSIZ],cl	; save its size
 13739 00002F77 41                      		inc	cx		; include the nul
 13740 00002F78 F3A4                    		rep movsb		; save this source
 13741 00002F7A 883E[C344]              		mov	[SRCINFO],bh	; save info about it
 13742 00002F7E 5E                      		pop	si
 13743 00002F7F 89E8                    		mov	ax,bp		; switches so far
 13744 00002F81 E86B01                  		call	SETASC		; set a,b switches accordingly
 13745 00002F84 E823EB                  		call	SWITCH		; get any more switches on this arg
 13746 00002F87 E86501                  		call	SETASC		; set
 13747 00002F8A C3                      		retn
 13748                                  
 13749                                  ; =============== S U B	R O U T	I N E =======================================
 13750                                  
 13751                                  ; MSDOS 6.0
 13752                                  
 13753                                  ;****************************************************************
 13754                                  ;*
 13755                                  ;* ROUTINE:	CleanupErr
 13756                                  ;*
 13757                                  ;* FUNCTION:	Issues extended error message for destination
 13758                                  ;*		if not alreay issued
 13759                                  ;*
 13760                                  ;* INPUT:	return from INT 21
 13761                                  ;*
 13762                                  ;* OUTPUT:	none
 13763                                  ;*
 13764                                  ;****************************************************************
 13765                                  
 13766                                  ;CleanupErr	proc	near		;AN022;
 13767                                  ;
 13768                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13769                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13770                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13771                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13772                                  ;					;AN022; get address of failed string
 13773                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13774                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13775                                  ;
 13776                                  ;CleanupErr_Cont:			;AN022;
 13777                                  ;	ret				;AN022; return to caller
 13778                                  ;
 13779                                  ;CleanupErr	endp			;AN022;
 13780                                  
 13781                                  ;============================================================================
 13782                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13783                                  ;============================================================================
 13784                                  ; 01/10/2018 - Retro DOS v3.0
 13785                                  
 13786                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13787                                  
 13788                                  ; =============== S U B	R O U T	I N E =======================================
 13789                                  
 13790                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13791                                  ;
 13792                                  ;	EXIT	ZR set if concatenate flag unchanged
 13793                                  
 13794                                  TRYFLUSH:
 13795 00002F8B A0[7642]                		mov	al,[CONCAT]
 13796 00002F8E 50                      		push	ax
 13797 00002F8F E80600                  		call	FLUSHFIL
 13798 00002F92 58                      		pop	ax
 13799 00002F93 3A06[7642]              		cmp	al,[CONCAT]
 13800 00002F97 C3                      		retn
 13801                                  
 13802                                  ; =============== S U B	R O U T	I N E =======================================
 13803                                  
 13804                                  FLUSHFIL:
 13805 00002F98 A0[7A45]                		mov	al,[BINARY]
 13806 00002F9B 8A26[7E45]              		mov	ah,[ASCII]
 13807 00002F9F 50                      		push	ax
 13808 00002FA0 E80900                  		call	FLSHFIL
 13809 00002FA3 58                      		pop	ax
 13810 00002FA4 8826[7E45]              		mov	[ASCII],ah
 13811 00002FA8 A2[7A45]                		mov	[BINARY],al
 13812 00002FAB C3                      		retn
 13813                                  
 13814                                  ; =============== S U B	R O U T	I N E =======================================
 13815                                  
 13816                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13817                                  ;
 13818                                  ;	Inputs:
 13819                                  ;	  [NXTADD] = No. of bytes to write
 13820                                  ;	  [CFLAG] <> 0 if file has been created
 13821                                  ;	Outputs:
 13822                                  ;	  [NXTADD] = 0
 13823                                  
 13824                                  FLSHFIL:
 13825 00002FAC C606[7D45]00            		mov	byte [TERMREAD],0
 13826 00002FB1 803E[8042]00            		cmp	byte [CFLAG],0
 13827 00002FB6 7403                    		jz	short NOTEXISTS
 13828 00002FB8 E98300                  		jmp	EXISTS
 13829                                  
 13830                                  NOTEXISTS:
 13831 00002FBB E84B01                  		call	BUILDDEST	; find out all about the destination
 13832 00002FBE E82F03                  		call	COMPNAME	; source and dest. the same?
 13833 00002FC1 7516                    		jnz	short PROCDEST	; if not, go ahead
 13834 00002FC3 803E[1D45]00            		cmp	byte [SRCISDEV],0
 13835 00002FC8 750F                    		jnz	short PROCDEST	; same name on device ok
 13836 00002FCA 803E[7642]00            		cmp	byte [CONCAT],0	; concatenation?
 13837 00002FCF BA[8438]                		mov	dx,OVERWRPTR
 13838 00002FD2 745E                    		je	short COPERR	; not concatenating - overwrite error
 13839                                  		
 13840                                  ;No_Concat_Err:	; concatenating
 13841 00002FD4 C606[7945]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 13842                                  PROCDEST:
 13843                                  		; MSDOS 6.0
 13844                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13845                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 13846                                  ;M046
 13847                                  ; For writes, we want to deny writes by anyone else at the same time that we
 13848                                  ;are writing to it. For instance, on a network, 2 workstations could try
 13849                                  ;writing to the same file. Also, because we opened the source file with
 13850                                  ;DENY NONE, it is fine if the source and destination files are the same as
 13851                                  ;would happen when we append to an existing file.
 13852                                  ;
 13853                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 13854                                  		;xor	cx,cx				; no special files
 13855                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 13856                                  		;
 13857                                  		;cmp	NoWrite,0
 13858                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 13859                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 13860                                  
 13861 00002FD9 B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 13862 00002FDC 803E[7945]00            		cmp	byte [NOWRITE],0
 13863 00002FE1 7504                    		jne	short DODESTOPEN
 13864 00002FE3 B43C                    		mov	ah,CREAT ; 3Ch
 13865 00002FE5 31C9                    		xor	cx,cx
 13866                                  DODESTOPEN:
 13867 00002FE7 BA[6144]                		mov	dx,DESTBUF
 13868 00002FEA CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 13869                                  				; CX = attributes for file
 13870                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 13871                                  		
 13872                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 13873                                  		;mov	dx,FULDIRPTR
 13874                                  		;call	GET_EXT_ERR_NUMBER
 13875                                  		;jc	short COPERR
 13876                                  
 13877                                  		; 01/10/2018
 13878                                  		;jnc	short DEST_OPEN_OKAY
 13879                                  		
 13880                                  		;mov	dx,FULDIRPTR
 13881                                  		;call	GET_EXT_ERR_NUMBER
 13882                                  		;jmp	short COPERR
 13883                                  
 13884 00002FEC 723E                    		jc	short DEST_OPEN_ERROR
 13885                                  
 13886                                  ;DEST_OPEN_OKAY:
 13887 00002FEE A3[B844]                		mov	[DESTHAND],ax	; save handle
 13888 00002FF1 C606[8042]01            		mov	byte [CFLAG],1	; destination now exists
 13889 00002FF6 89C3                    		mov	bx,ax
 13890 00002FF8 B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 13891 00002FFB CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 13892                                  				   	; BX = file or device handle
 13893                                  
 13894 00002FFD 8816[BA44]              		mov	[DESTISDEV],dl	; set dest info
 13895                                  		;test	dl,80h
 13896 00003001 F6C280                  		test	dl,devid_ISDEV
 13897 00003004 7438                    		jz	short EXISTS	; Dest not a device
 13898                                  
 13899                                  ;	Destination is device.
 13900                                  
 13901 00003006 A0[7C42]                		mov	al,byte [DESTSWITCH]
 13902                                  		;and	al,0Ch
 13903 00003009 240C                    		and	al,SWITCHA+SWITCHB
 13904 0000300B 7509                    		jnz	short TESTBOTH
 13905 0000300D A0[7E45]                		mov	al,[ASCII]	; neither set, use current setting
 13906 00003010 0A06[7A45]              		or	al,[BINARY]
 13907 00003014 741E                    		jz	short EXSETA	; neither set, default to ascii
 13908                                  TESTBOTH:
 13909 00003016 7A26                    		jpe	short EXISTS	; both are set, ignore
 13910                                  		;test	al,8
 13911 00003018 A808                    		test	al,SWITCHB
 13912 0000301A 7422                    		jz	short EXISTS
 13913                                  		;mov	ax,(IOCTL shl 8) or 1
 13914 0000301C B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 13915 0000301F 30F6                    		xor	dh,dh
 13916                                  		;or	dl,20h
 13917 00003021 80CA20                  		or	dl,devid_RAW
 13918 00003024 8816[BA44]              		mov	[DESTISDEV],dl
 13919 00003028 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 13920                                  				; BX = device handle,DH = 0
 13921                                  				; DL = device information to set (bits 0-7 from	function 0)
 13922 0000302A EB12                    		jmp	short EXISTS
 13923                                  
 13924                                  		; 01/10/2018 - Retro DOS v3.0 modification
 13925                                  DEST_OPEN_ERROR:
 13926 0000302C BA[5E38]                		mov	dx,FULDIRPTR
 13927 0000302F E892EE                  		call	GET_EXT_ERR_NUMBER
 13928                                  COPERR:
 13929 00003032 EB7C                    		jmp	short COPYERR
 13930                                  
 13931                                  EXSETA:
 13932                                  
 13933                                  ;	What we read in may have been in binary mode, flag zapped write OK
 13934                                  
 13935                                  		;mov	byte [ASCII],4
 13936 00003034 C606[7E45]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 13937                                  		;or	byte [INEXACT],4
 13938 00003039 800E[7745]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 13939                                  EXISTS:
 13940 0000303E 803E[7945]00            		cmp	byte [NOWRITE],0
 13941 00003043 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 13942 00003045 803E[B743]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 13943 0000304A 741D                    		jz	short NOCHECKING
 13944 0000304C E8A102                  		call	COMPNAME		; source and dest. the same?
 13945 0000304F 7518                    		jnz	short NOCHECKING	; if not, go ahead
 13946 00003051 803E[1D45]00            		cmp	byte [SRCISDEV],0
 13947 00003056 7511                    		jne	short NOCHECKING	; same name on device ok
 13948                                  
 13949                                  ;	At this point we know in append (would have gotten overwrite error
 13950                                  ;	on first destination create otherwise), and user trying to specify
 13951                                  ;	destination which has been scribbled already (if dest had been named
 13952                                  ;	first, NoWrite would be set).
 13953                                  
 13954 00003058 BA[B038]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 13955                                  		;invoke	Std_EprintF		;ac022;
 13956 0000305B E86504                  		call	STD_PRINTF
 13957 0000305E C706[8442]0000          		mov	word [NXTADD],0		; set return
 13958 00003064 FE06[7D45]              		inc	byte [TERMREAD]		; tell read to give up
 13959                                  RET60:
 13960 00003068 C3                      		retn
 13961                                  
 13962                                  NOCHECKING:
 13963 00003069 8B1E[B844]              		mov	bx,[DESTHAND]		; get handle
 13964 0000306D 31C9                    		xor	cx,cx
 13965 0000306F 870E[8442]              		xchg	cx,[NXTADD]
 13966 00003073 E3F3                    		jcxz	RET60			; if nothing to write, forget it
 13967 00003075 FF06[7B45]              		inc	word [WRITTEN]		; flag that we wrote something
 13968 00003079 803E[7945]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 13969 0000307E 755A                    		jnz	short SEEKEND
 13970 00003080 31D2                    		xor	dx,dx
 13971 00003082 1E                      		push	ds
 13972 00003083 8E1E[6342]              		mov	ds,[TPA]
 13973 00003087 B440                    		mov	ah,WRITE ; 40h
 13974 00003089 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 13975                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 13976 0000308B 1F                      		pop	ds
 13977 0000308C BA[2938]                		mov	dx,NOSPACEPTR
 13978 0000308F 7222                    		jc	short COPERRP		; failure
 13979 00003091 29C1                    		sub	cx,ax
 13980 00003093 74D3                    		jz	short RET60		; wrote all supposed to
 13981 00003095 F606[BA44]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 13982 0000309A 7414                    		jz	short COPYERR		; is a file, error
 13983 0000309C F606[BA44]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 13984 000030A1 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 13985 000030A3 803E[7745]00            		cmp	byte [INEXACT],0
 13986 000030A8 75BE                    		jnz	short RET60		; inexact so ok
 13987 000030AA 49                      		dec	cx
 13988                                  RETZ60:
 13989 000030AB 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 13990                                  
 13991                                  DEVWRTERR:
 13992 000030AD BA[793D]                		mov	dx,DEVWMESPTR
 13993                                  
 13994                                  COPYERR:
 13995                                  		;invoke	Std_EPrintF		;AC022;
 13996 000030B0 E81004                  		call	STD_PRINTF
 13997                                  COPERRP:
 13998 000030B3 FE06[8142]              		inc	byte [DESTCLOSED]
 13999 000030B7 803E[8042]00            		cmp	byte [CFLAG],0
 14000 000030BC 7419                    		jz	short ENDCOPYJ		; never actually got it open
 14001 000030BE 8B1E[B844]              		mov	bx,[DESTHAND]
 14002 000030C2 83FB00                  		cmp	bx,0
 14003 000030C5 7E04                    		jle	short NOCLOSE
 14004                                  
 14005                                  ;	Check to see if we should save part of the destination file.
 14006                                  
 14007                                  		; MSDOS 6.0
 14008                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 14009                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 14010                                  			
 14011                                  		;mov	ax,cx
 14012                                  		;or	ax,dx
 14013                                  		;jz	ceClose			; null file ptr means nothing to save
 14014                                  
 14015                                  ;	Destination was also the first source.  Do the best we can to
 14016                                  ;	restore it.  Truncate it back to the size we took from it (which
 14017                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14018                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14019                                  
 14020                                  		;mov	ax,LSEEK shl 8
 14021                                  		;int	21h
 14022                                  
 14023                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14024                                  		;mov	ah,WRITE
 14025                                  		;int	21h			; truncate file
 14026                                  
 14027                                  		;cmp	OCtrlZ,0
 14028                                  		;je	@f			; no ctrl-z removed from original
 14029                                  		;inc	cx			; CX = # bytes to write = 1
 14030                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14031                                  		;mov	ah,WRITE
 14032                                  		;int	21h			; write ctrl-z
 14033                                  ;@@:
 14034                                  		;mov	ah,CLOSE
 14035                                  		;int	21h			; close it
 14036                                  ;;		;mov	CFlag,0
 14037                                  		;jmp	EndCopy			; and go home
 14038                                  
 14039                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14040                                  CECLOSE:
 14041 000030C7 B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14042 000030C9 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14043                                  					; BX = file handle
 14044                                  NOCLOSE:
 14045 000030CB BA[6144]                		mov	dx,DESTBUF
 14046 000030CE B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14047 000030D0 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14048                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14049 000030D2 C606[8042]00            		mov	byte [CFLAG],0
 14050                                  ENDCOPYJ:
 14051 000030D7 E9F7FA                  		jmp	ENDCOPY
 14052                                  
 14053                                  SEEKEND:
 14054 000030DA 31D2                    		xor	dx,dx
 14055 000030DC 87D1                    		xchg	dx,cx
 14056                                  		;mov	ax,(LSEEK shl 8) or 1
 14057 000030DE B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14058 000030E1 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14059                                  					; AL = method: offset from present location
 14060 000030E3 803E[7442]00            		cmp	byte [RDEOF],0
 14061 000030E8 74C1                    		jz	short RETZ60
 14062                                  
 14063                                  ;	^Z has been read - we must set the file size to the current
 14064                                  ;	file pointer location
 14065                                  
 14066 000030EA B440                    		mov	ah,WRITE ; 40h
 14067 000030EC CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14068                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14069                                  
 14070                                  		; MSDOS 6.0
 14071                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14072                                  
 14073                                  ;	Make note that ^Z was removed, in case the
 14074                                  ;	copy should fail and we need to restore the file.
 14075                                  
 14076                                  		;mov	OCtrlZ,1Ah
 14077                                  
 14078 000030EE C3                      		retn
 14079                                  
 14080                                  ;============================================================================
 14081                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14082                                  ;============================================================================
 14083                                  ; 01/10/2018 - Retro DOS v3.0
 14084                                  
 14085                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14086                                  
 14087                                  ; =============== S U B	R O U T	I N E =======================================
 14088                                  
 14089                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14090                                  ;
 14091                                  ;	Given switch vector in AX,
 14092                                  ;	  Set Ascii flag if /a is set
 14093                                  ;	  Clear Ascii flag if /b is set
 14094                                  ;	  Binary set if /b specified
 14095                                  ;	  Leave Ascii unchanged if neither or both are set
 14096                                  ; 	Also sets Inexact if Ascii is ever set. 
 14097                                  ;	AL = Ascii on exit, flags set
 14098                                  
 14099                                  SETASC:
 14100 000030EF 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14101 000030F1 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14102 000030F3 50                      		push	ax
 14103 000030F4 2408                    		and	al,SWITCHB  ; 8
 14104 000030F6 A2[7A45]                		mov	[BINARY],al
 14105 000030F9 58                      		pop	ax
 14106 000030FA 2404                    		and	al,4
 14107 000030FC A2[7E45]                		mov	[ASCII],al
 14108 000030FF 0806[7745]              		or	[INEXACT],al
 14109                                  LOADSW:
 14110 00003103 A0[7E45]                		mov	al,[ASCII]
 14111 00003106 08C0                    		or	al,al
 14112 00003108 C3                      		retn
 14113                                  
 14114                                  ; =============== S U B	R O U T	I N E =======================================
 14115                                  
 14116                                  BUILDDEST:
 14117 00003109 803E[5C44]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14118 0000310E 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14119 00003110 BF[4341]                		mov	di,USERDIR1
 14120 00003113 BD[5C44]                		mov	bp,DESTVARS
 14121 00003116 E8DF00                  		call	BUILDPATH
 14122 00003119 E872E7                  		call	RESTUDIR1
 14123                                  
 14124                                  ;	We now know all about the destination
 14125                                  
 14126                                  KNOWABOUTDEST:
 14127 0000311C 30C0                    		xor	al,al
 14128 0000311E 8606[BB44]              		xchg	al,[FIRSTDEST]
 14129 00003122 08C0                    		or	al,al
 14130 00003124 7503                    		jnz	short FIRSTDST
 14131 00003126 E98A00                  		jmp	NOFIRSTDEST
 14132                                  FIRSTDST:
 14133                                  
 14134                                  ;	Create an fcb of the original dest.
 14135                                  
 14136 00003129 8B36[5E44]              		mov	si,[DESTTAIL]
 14137 0000312D BF[1743]                		mov	di,DESTFCB
 14138 00003130 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14139 00003133 CD21                    		int	21h		; DOS -	PARSE FILENAME
 14140                                  					; DS:SI	-> string to parse
 14141                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14142                                  					; AL = bit mask	to control parsing
 14143 00003135 803C00                  		cmp	byte [si],0
 14144 00003138 7404                    		jz	short GOODPARSE
 14145 0000313A C645017C                		mov	byte [di+1],'|'
 14146                                  		; MSDOS 6.0
 14147                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14148                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14149                                  		;jmp	CopErr				;AN052;
 14150                                  GOODPARSE:
 14151 0000313E A1[6144]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14152 00003141 80FC3A                  		cmp	ah,':'
 14153 00003144 7402                    		jz	short DRVSPEC4
 14154 00003146 B040                    		mov	al,'@'
 14155                                  DRVSPEC4:
 14156                                  
 14157                                  ;	AX = "d:" for following FCB drive computation
 14158                                  
 14159 00003148 8A0E[7E45]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14160 0000314C 0C20                    		or	al,20h
 14161 0000314E 2C60                    		sub	al,60h
 14162 00003150 A2[1743]                		mov	byte [DESTFCB],al	; store drive # in FCB
 14163                                  
 14164                                  ;*	Figure out what copy mode we're in.
 14165                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14166                                  ;	+n stands for additional sources delimited by +'s.
 14167                                  ;
 14168                                  ;	copy a b	not concatenating
 14169                                  ;	copy a *	not concatenating
 14170                                  ;	copy * a	concatenating
 14171                                  ;	copy * *	not concatenating
 14172                                  ;	copy a+n b	concatenating
 14173                                  ;	copy *+n a	concatenating
 14174                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14175                                  
 14176                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14177                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14178                                  
 14179 00003153 A0[6044]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14180 00003156 8A26[C344]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14181 0000315A 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14182 0000315D 08C0                    		or	al,al
 14183 0000315F 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14184                                  
 14185                                  ;	Destination is wildcarded.
 14186                                  	
 14187 00003161 38E0                    		cmp	al,ah
 14188 00003163 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14189                                  
 14190                                  ;	Source and destination are both wildcarded.
 14191                                  
 14192 00003165 803E[7F45]00            		cmp	byte [PLUS],0
 14193 0000316A 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14194                                  
 14195                                  ;	Source and destination are wildcarded, and source includes +'s.
 14196                                  ;	It's Mel Hallorman copy time.
 14197                                  
 14198 0000316C FE06[BC44]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14199 00003170 30C0                    		xor	al,al
 14200 00003172 EB06                    		jmp	short SETCONC
 14201                                  
 14202                                  NOTMELCOPY:
 14203 00003174 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14204 00003176 20E0                    		and	al,ah
 14205 00003178 D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14206                                  				;   (implies concatenation)
 14207                                  SETCONC:
 14208 0000317A 0A06[7F45]              		or	al,[PLUS]	; "+" always infers concatenation
 14209                                  
 14210                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14211                                  
 14212 0000317E A2[7642]                		mov	[CONCAT],al
 14213 00003181 D0E0                    		shl	al,1
 14214 00003183 D0E0                    		shl	al,1
 14215 00003185 A2[7745]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14216 00003188 803E[7A45]00            		cmp	byte [BINARY],0
 14217 0000318D 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14218                                  
 14219 0000318F A2[7E45]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14220 00003192 08C9                    		or	cl,cl
 14221 00003194 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14222 00003196 08C0                    		or	al,al
 14223 00003198 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14224                                  
 14225                                  ;	At this point there may already be binary read data in the read
 14226                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14227                                  ;	amount of data in the buffer correctly.
 14228                                  
 14229 0000319A 8B0E[8442]              		mov	cx,[NXTADD]
 14230 0000319E E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14231 000031A0 B01A                    		mov	al,1Ah
 14232 000031A2 06                      		push	es
 14233 000031A3 31FF                    		xor	di,di
 14234 000031A5 8E06[6342]              		mov	es,[TPA]
 14235 000031A9 F2AE                    		repne scasb		; scan for EOF
 14236 000031AB 07                      		pop	es
 14237 000031AC 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14238 000031AE 4F                      		dec	di		; point at ^z
 14239 000031AF 893E[8442]              		mov	[NXTADD],di	; new buffer length
 14240                                  
 14241                                  NOFIRSTDEST:
 14242 000031B3 BB[5B43]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14243 000031B6 803E[7642]00            		cmp	byte [CONCAT],0
 14244 000031BB 7403                    		jz	short GOTCHRSRC	; Not a concat
 14245 000031BD BB[A143]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14246                                  GOTCHRSRC:
 14247 000031C0 BE[1843]                		mov	si,DESTFCB+1	; Original dest name
 14248 000031C3 8B3E[5E44]              		mov	di,[DESTTAIL]	; Where to put result
 14249                                  
 14250                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14251                                  
 14252                                  BUILDNAME:
 14253 000031C7 B90800                  		mov	cx,8
 14254                                  BUILDMAIN:
 14255 000031CA AC                      		lodsb
 14256 000031CB 3C3F                    		cmp	al,'?'
 14257 000031CD 7502                    		jnz	short NOTAMBIG
 14258 000031CF 8A07                    		mov	al,[bx]
 14259                                  NOTAMBIG:
 14260 000031D1 3C20                    		cmp	al,' '
 14261 000031D3 7401                    		jz	short NOSTORE
 14262 000031D5 AA                      		stosb
 14263                                  NOSTORE:
 14264 000031D6 43                      		inc	bx
 14265 000031D7 E2F1                    		loop	BUILDMAIN
 14266 000031D9 B103                    		mov	cl,3
 14267 000031DB B020                    		mov	al,' '
 14268 000031DD 3804                    		cmp	[si],al
 14269 000031DF 7413                    		jz	short ENDDEST	; No extension
 14270 000031E1 A0[F83E]                		mov	al,[DOT_CHR]
 14271 000031E4 AA                      		stosb
 14272                                  BUILDEXT:
 14273 000031E5 AC                      		lodsb
 14274 000031E6 3C3F                    		cmp	al,'?'
 14275 000031E8 7502                    		jnz	short NOTAMBIGE
 14276 000031EA 8A07                    		mov	al,[bx]
 14277                                  NOTAMBIGE:
 14278 000031EC 3C20                    		cmp	al,' '
 14279 000031EE 7401                    		jz	short NOSTOREE
 14280 000031F0 AA                      		stosb
 14281                                  NOSTOREE:
 14282 000031F1 43                      		inc	bx
 14283 000031F2 E2F1                    		loop	BUILDEXT
 14284                                  ENDDEST:
 14285 000031F4 30C0                    		xor	al,al
 14286 000031F6 AA                      		stosb			; NUL terminate
 14287 000031F7 C3                      		retn
 14288                                  
 14289                                  ; =============== S U B	R O U T	I N E =======================================
 14290                                  
 14291                                  BUILDPATH:
 14292 000031F8 F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14293 000031FC 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14294 000031FE 89EA                    		mov	dx,bp		; Set DX to spec
 14295 00003200 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14296                                  
 14297                                  		; MSDOS 6.0
 14298                                  		;push	di				;AN000;
 14299                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14300                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14301                                  		;xor	cx,cx				;AN000; no special files
 14302                                  		;mov	si,dx				;AN030; get file name offset
 14303                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14304                                  		;INT	21h
 14305                                  		;pop	di				;AN000;
 14306                                  		;jnc	pure_file			;AN022; is pure file
 14307                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14308                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14309                                  		;jz	notpfile			;AN022;
 14310                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14311                                  		;jz	notpfile			;AN022;
 14312                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14313                                  		;jz	notpfile			;AN022;
 14314                                  		;jmp	extend_setup			;AN022; exit with error
 14315                                  ;pure_file:
 14316                                  		; MSDOS 3.3
 14317 00003203 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14318 00003206 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14319                                  					; DS:DX	-> ASCIZ filename
 14320                                  					; AL = access mode
 14321                                  					; 0 - read
 14322 00003208 7216                    		jc	short NOTPFILE
 14323                                  ;PURE_FILE:
 14324 0000320A 89C3                    		mov	bx,ax
 14325 0000320C B80044                  		mov	ax,IOCTL*256 ; 4400h
 14326 0000320F CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14327                                  					; BX = file or device handle
 14328 00003211 B43E                    		mov	ah,CLOSE ;3Eh
 14329 00003213 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14330                                  					; BX = file handle
 14331 00003215 F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14332 00003218 7545                    		jnz	short ISADEV
 14333 0000321A F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14334 0000321E 743F                    		jz	short ISADEV
 14335                                  
 14336                                  NOTPFILE:
 14337 00003220 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14338                                  		
 14339                                  		;MSDOS 6.0
 14340                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14341                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14342                                  
 14343 00003223 80FE3A                  		cmp	dh,':'
 14344 00003226 7402                    		je	short DRVSPEC5
 14345                                  
 14346                                  SET_DRIVE_SPEC:
 14347 00003228 B240                    		mov	dl,'@'
 14348                                  
 14349                                  DRVSPEC5:
 14350 0000322A 80CA20                  		or	dl,20h
 14351 0000322D 80EA60                  		sub	dl,60h		; A = 1
 14352 00003230 E816E7                  		call	SAVUDIR1
 14353                                  	
 14354                                  		; MSDOS 6.0
 14355                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14356                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14357                                  		;jmp	extend_setup		;AN022; exit with error
 14358                                  
 14359                                  CURDIR_OK:
 14360 00003233 89EA                    		mov	dx,bp
 14361                                  		;add	dx,5
 14362 00003235 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14363                                  		;mov	bh,[bp+4]
 14364 00003238 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14365 0000323B 80E706                  		and	bh,6
 14366 0000323E 80FF06                  		cmp	bh,6			; Ambig and path ?
 14367 00003241 7517                    		jne	short CHECKAMB		; jmp if no
 14368                                  		;mov	si,[bp+2]
 14369 00003243 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14370 00003246 B33A                    		mov	bl,':'
 14371 00003248 385CFE                  		cmp	[si-2],bl
 14372 0000324B 7506                    		jne	short KNOWNOTSPEC
 14373                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14374                                  		;mov	byte [bp+0],2
 14375 0000324D C6460002                		mov	byte [bp],2
 14376 00003251 EB05                    		jmp	short DOPCDJ
 14377                                  
 14378                                  KNOWNOTSPEC:
 14379                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14380                                  		;mov	byte [bp+0],1		
 14381 00003253 C6460001                		mov	byte [bp],1
 14382 00003257 4E                      		dec	si
 14383                                  DOPCDJ:
 14384 00003258 EB62                    		jmp	short DOPCD
 14385                                  
 14386                                  CHECKAMB:
 14387 0000325A 80FF02                  		cmp	bh,2
 14388 0000325D 7505                    		jnz	short CHECKCD
 14389                                  ISSIMPFILE:
 14390                                  ISADEV:
 14391                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14392                                  		;mov	byte [bp+0],0		
 14393 0000325F C6460000                		mov	byte [bp],0
 14394 00003263 C3                      		retn
 14395                                  
 14396                                  CHECKCD:
 14397 00003264 E89DEC                  		call	SETREST1
 14398 00003267 B43B                    		mov	ah,CHDIR ; 3Bh
 14399 00003269 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14400                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14401 0000326B 7223                    		jb	short NOTPDIR
 14402 0000326D 89D7                    		mov	di,dx
 14403 0000326F 31C0                    		xor	ax,ax
 14404 00003271 89C1                    		mov	cx,ax
 14405 00003273 49                      		dec	cx
 14406 00003274 F2AE                    		repne scasb
 14407                                  DONE:
 14408 00003276 4F                      		dec	di
 14409 00003277 A0[6642]                		mov	al,[DIRCHAR]
 14410                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14411                                  		;mov	byte [bp+0],2
 14412 0000327A C6460002                		mov	byte [bp],2
 14413 0000327E 3A45FF                  		cmp	al,[di-1]
 14414 00003281 7405                    		jz	short GOTSRCSLSH
 14415                                  _STORE_PCHAR:
 14416 00003283 AA                      		stosb
 14417                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14418                                  		;mov	byte [bp+0],1
 14419 00003284 C6460001                		mov	byte [bp],1
 14420                                  GOTSRCSLSH:
 14421                                  		;or	byte [bp+4],6
 14422 00003288 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14423 0000328C E84500                  		call	SETSTARS
 14424                                  NOTPDIR_RETN:
 14425 0000328F C3                      		retn
 14426                                  
 14427                                  NOTPDIR:
 14428                                  		; MSDOS 6.0
 14429                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14430                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14431                                  		;jz	notpdir_try		;AN022;
 14432                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14433                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14434                                  ;notpdir_try:
 14435                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14436                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14437                                  		;mov	byte [bp+0],0
 14438 00003290 C6460000                		mov	byte [bp],0
 14439                                  		;mov	bh,[bp+4]
 14440 00003294 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14441 00003297 F6C704                  		test	bh,4
 14442 0000329A 74F3                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14443                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14444                                  		;mov	byte [bp+0],2		
 14445 0000329C C6460002                		mov	byte [bp],2
 14446                                  		;mov	si,[bp+2]
 14447 000032A0 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14448 000032A3 803C00                  		cmp	byte [si],0
 14449 000032A6 7428                    		je	short BADCDERRJ2	; Trailing '/'	
 14450 000032A8 8A1E[F83E]              		mov	bl,[DOT_CHR]
 14451 000032AC 381C                    		cmp	[si],bl
 14452 000032AE 7420                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14453 000032B0 B33A                    		mov	bl,':'
 14454 000032B2 385CFE                  		cmp	[si-2],bl
 14455 000032B5 7405                    		je	short DOPCD		   ; Know d:/file
 14456                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14457                                  		;mov	byte [bp+0],1
 14458 000032B7 C6460001                		mov	byte [bp],1
 14459 000032BB 4E                      		dec	si			; Point at last '/'
 14460                                  DOPCD:
 14461 000032BC 30DB                    		xor	bl,bl
 14462 000032BE 861C                    		xchg	bl,[si]			; Stick in a NUL
 14463 000032C0 E841EC                  		call	SETREST1
 14464 000032C3 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14465 000032C6 7408                    		je	short BADCDERRJ2
 14466 000032C8 B43B                    		mov	ah,CHDIR ; 3Bh
 14467 000032CA CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14468                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14469 000032CC 861C                    		xchg	bl,[si]
 14470 000032CE 73BF                    		jnc	short NOTPDIR_RETN
 14471                                  		
 14472                                  		; MSDOS 3.3
 14473                                  BADCDERRJ2:
 14474 000032D0 F9                      		stc
 14475 000032D1 E90ADF                  		jmp	BADCDERR
 14476                                  
 14477                                  		; MSDOS 6.0
 14478                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14479                                  ;EXTEND_SETUPJ:					;AN022;
 14480                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14481                                  ;BADCDERRJ2:
 14482                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14483                                  
 14484                                  ; =============== S U B	R O U T	I N E =======================================
 14485                                  
 14486                                  SETSTARS:
 14487                                  		;mov	[bp+2],di
 14488 000032D4 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14489                                  		;add	byte [bp+1],12
 14490 000032D7 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14491 000032DB A1[F93E]                		mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14492 000032DE B90800                  		mov	cx,8
 14493 000032E1 F3AA                    		rep stosb
 14494 000032E3 86C4                    		xchg	al,ah
 14495 000032E5 AA                      		stosb
 14496 000032E6 86C4                    		xchg	al,ah
 14497 000032E8 B103                    		mov	cl,3
 14498 000032EA F3AA                    		rep stosb
 14499 000032EC 30C0                    		xor	al,al
 14500 000032EE AA                      		stosb
 14501 000032EF C3                      		retn
 14502                                  
 14503                                  ; =============== S U B	R O U T	I N E =======================================
 14504                                  
 14505                                  COMPNAME:
 14506 000032F0 BE[6144]                		mov	si,DESTBUF	; do name translate of target
 14507 000032F3 BF[E63F]                		mov	di,TRGXNAME	; save for name comparison
 14508 000032F6 B460                    		mov	ah,XNAMETRANS ; 60h
 14509 000032F8 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14510                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14511                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14512 000032FA BE[8F3F]                		mov	si,SRCXNAME	; get name translate of source
 14513 000032FD BF[E63F]                		mov	di,TRGXNAME	; get name translate of target
 14514 00003300 E8BCE6                  		call	STRCOMP
 14515 00003303 C3                      		retn
 14516                                  
 14517                                  ;============================================================================
 14518                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14519                                  ;============================================================================
 14520                                  ; 30/09/2018 - Retro DOS v3.0
 14521                                  
 14522                                  ;-----------------------------------------------------------------------;
 14523                                  ; ENTRY:								;
 14524                                  ;	DS:SI	Points input buffer					;
 14525                                  ;	ES:DI	Points to the token buffer				;
 14526                                  ;	BL	Special delimiter for this call 			;
 14527                                  ;		    Always checked last 				;
 14528                                  ;		    set it to space if there is no special delimiter	;
 14529                                  ; EXIT: 								;
 14530                                  ;	DS:SI	Points to next char in the input buffer 		;
 14531                                  ;	ES:DI	Points to the token buffer				;
 14532                                  ;	[STARTEL] Points to start of last element of path in token	;
 14533                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14534                                  ;	CX	Character count 					;
 14535                                  ;	BH	Condition Code						;
 14536                                  ;			Bit 1H of BH set if switch character		;
 14537                                  ;				Token buffer contains char after	;
 14538                                  ;				switch character			;
 14539                                  ;				BP has switch bits set (ORing only)	;
 14540                                  ;			Bit 2H of BH set if ? or * in token		;
 14541                                  ;				if * found element ? filled		;
 14542                                  ;			Bit 4H of BH set if path sep in token		;
 14543                                  ;			Bit 80H of BH set if the special delimiter	;
 14544                                  ;			   was skipped at the start of this token	;
 14545                                  ;		Token buffer always starts d: for non switch tokens	;
 14546                                  ;	CARRY SET							;
 14547                                  ;	    if CR on input						;
 14548                                  ;		token buffer not altered				;
 14549                                  ;									;
 14550                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14551                                  ; MODIFIES:								;
 14552                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14553                                  ;									;
 14554                                  ;-----------------------------------------------------------------------;
 14555                                  
 14556                                  ; Modifications to cparse: recognition of right and left parentheses
 14557                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14558                                  ;
 14559                                  ; Both modifications were installed in the course of adding a coherent
 14560                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14561                                  ; structure for command-line arguments. This parser relies on cparse to
 14562                                  ; recognize individual tokens.
 14563                                  ;
 14564                                  ; To process for-loops correctly, parentheses must therefore be
 14565                                  ; recognized as tokens. The upper-case conversion code was removed so
 14566                                  ; that commands (such as for and echo) would be able to use the "original"
 14567                                  ; text of the command line.
 14568                                  ;
 14569                                  ; Note also the modification to prevent the automatic conversion of colons
 14570                                  ; into spaces WITHIN THE SOURCE TEXT!
 14571                                  ;
 14572                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14573                                  ; on the command line.
 14574                                  ;
 14575                                  ; Alan L, OS/MSDOS				    14 August 1983
 14576                                  
 14577                                  ; ---------------------------------------------------------------------------
 14578                                  
 14579                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14580                                  
 14581                                  ;FSWITCH	EQU	8000h
 14582                                  ;FBADSWITCH	EQU	4000h
 14583                                  
 14584                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14585                                  
 14586                                  ; =============== S U B	R O U T	I N E =======================================
 14587                                  
 14588                                  CPARSE:
 14589 00003304 31C0                    		xor	ax,ax
 14590 00003306 893E[8745]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14591 0000330A A2[8A45]                		mov	[ELPOS],al		; Start in 8 char prefix
 14592 0000330D A2[8B45]                		mov	[SOURCE],al		; No skip delimiter yet
 14593 00003310 88C7                    		mov	bh,al			; Init nothing
 14594 00003312 9C                      		pushf				; save flags
 14595 00003313 57                      		push	di			; save the token buffer addrss
 14596 00003314 31C9                    		xor	cx,cx			; no chars in token buffer
 14597 00003316 880E[B643]              		mov	[COMMA],cl		; reset comma flag
 14598                                  
 14599                                  MOREDELIM:
 14600 0000331A AC                      		lodsb
 14601 0000331B E863E6                  		call	DELIM
 14602 0000331E 751D                    		jnz	short SCANCDONE
 14603 00003320 3C20                    		cmp	al,' '
 14604 00003322 74F6                    		jz	short MOREDELIM
 14605 00003324 3C09                    		cmp	al,9
 14606 00003326 74F2                    		jz	short MOREDELIM
 14607 00003328 8606[8B45]              		xchg	al,[SOURCE]
 14608 0000332C 08C0                    		or	al,al
 14609 0000332E 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14610 00003330 F6C780                  		test	bh,80h			; has a special char been found?
 14611 00003333 7405                    		jz	short NO_COMMA		; no - just exit
 14612 00003335 C606[B643]01            		mov	byte [COMMA],1		; set comma flag
 14613                                  
 14614                                  NO_COMMA:
 14615 0000333A E92201                  		jmp	X_DONE			; Nul argument
 14616                                  
 14617                                  SCANCDONE:
 14618 0000333D 803E[4644]01            		cmp	byte [CPYFLAG],1
 14619 00003342 7503                    		jnz	short CPCONT1
 14620 00003344 E8D7E4                  		call	UPCONV_MAPCALL
 14621                                  CPCONT1:
 14622 00003347 38D8                    		cmp	al,bl			; Special delimiter?
 14623 00003349 7505                    		jnz	short NOSPEC
 14624 0000334B 80CF80                  		or	bh,80h
 14625 0000334E EBCA                    		jmp	short MOREDELIM
 14626                                  
 14627                                  NOSPEC:
 14628 00003350 3C0D                    		cmp	al,0Dh			; a CR?
 14629 00003352 7503                    		jnz	short NCPERROR
 14630 00003354 E90301                  		jmp	CPERROR
 14631                                  
 14632                                  NCPERROR:
 14633 00003357 3A06[6542]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14634 0000335B 7503                    		jnz	short NA_SWITCH		; yes, process...
 14635 0000335D E90201                  		jmp	A_SWITCH
 14636                                  
 14637                                  NA_SWITCH:
 14638 00003360 B23A                    		mov	dl,':'
 14639 00003362 3814                    		cmp	[si],dl
 14640 00003364 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14641 00003366 E83F01                  		call	MOVE_CHAR
 14642 00003369 AC                      		lodsb				; Get the ':'
 14643 0000336A E83B01                  		call	MOVE_CHAR
 14644 0000336D 893E[8745]              		mov	[STARTEL],di
 14645 00003371 C606[8945]00            		mov	byte [ELCNT],0
 14646 00003376 E9A400                  		jmp	ANUM_TEST
 14647                                  
 14648                                  ANUM_CHARD:
 14649 00003379 893E[8745]              		mov	[STARTEL],di
 14650 0000337D C606[8945]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14651 00003382 803E[4644]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14652 00003387 751F                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14653 00003389 E880E6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14654 0000338C 751A                    		jnz	short ANUM_CHAR		; no
 14655 0000338E 50                      		push	ax
 14656 0000338F A0[7542]                		mov	al,[CURDRV]		; Insert drive spec
 14657 00003392 0206[E03E]              		add	al,[CAPITAL_A]
 14658 00003396 E80F01                  		call	MOVE_CHAR
 14659 00003399 B03A                    		mov	al,':'
 14660 0000339B E80A01                  		call	MOVE_CHAR
 14661 0000339E 58                      		pop	ax
 14662 0000339F 893E[8745]              		mov	[STARTEL],di
 14663 000033A3 C606[8945]00            		mov	byte [ELCNT],0
 14664                                  
 14665                                  ANUM_CHAR:
 14666 000033A8 3A06[F83E]              		cmp	al,[DOT_CHR]
 14667 000033AC 7509                    		jnz	short TESTQUEST
 14668 000033AE FE06[8A45]              		inc	byte [ELPOS]		; flag in extension
 14669 000033B2 C606[8945]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14670                                  TESTQUEST:
 14671 000033B7 3C3F                    		cmp	al,'?'
 14672 000033B9 7503                    		jnz	short TESTSPLAT
 14673 000033BB 80CF02                  		or	bh,2
 14674                                  TESTSPLAT:
 14675 000033BE 3A06[ED3E]              		cmp	al,[STAR]
 14676 000033C2 7530                    		jnz	short TESTPATH
 14677 000033C4 80CF02                  		or	bh,2
 14678 000033C7 803E[9745]00            		cmp	byte [EXPAND_STAR],0
 14679 000033CC 7504                    		jnz	short EXPAND_FILENAME
 14680 000033CE EB24                    		jmp	short TESTPATH
 14681                                  
 14682                                  BADPERR2J:
 14683 000033D0 EB7F                    		jmp	BADPERR2
 14684                                  
 14685                                  		;db	0E9h
 14686                                  		;db	7Eh	
 14687                                  		;db	0
 14688                                  
 14689                                  EXPAND_FILENAME:
 14690 000033D2 B407                    		mov	ah,7
 14691 000033D4 803E[8A45]00            		cmp	byte [ELPOS],0
 14692 000033D9 7402                    		jz	short GOTELCNT
 14693 000033DB B402                    		mov	ah,2
 14694                                  GOTELCNT:
 14695 000033DD B03F                    		mov	al,'?'
 14696 000033DF 2A26[8945]              		sub	ah,[ELCNT]
 14697 000033E3 72EB                    		jb	short BADPERR2J
 14698 000033E5 86E1                    		xchg	ah,cl
 14699 000033E7 E309                    		jcxz	TESTPATHX
 14700                                  QMOVE:
 14701 000033E9 86E1                    		xchg	ah,cl
 14702 000033EB E8BA00                  		call	MOVE_CHAR
 14703 000033EE 86E1                    		xchg	ah,cl
 14704 000033F0 E2F7                    		loop	QMOVE
 14705                                  TESTPATHX:
 14706 000033F2 86E1                    		xchg	ah,cl
 14707                                  TESTPATH:
 14708 000033F4 E815E6                  		call	PATHCHRCMP
 14709 000033F7 7521                    		jnz	short NOTSPECIAL
 14710 000033F9 80CF04                  		or	bh,4
 14711 000033FC 803E[9745]00            		cmp	byte [EXPAND_STAR],0
 14712 00003401 7405                    		jz	short NO_ERR_CHECK
 14713 00003403 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14714 00003406 754F                    		jnz	short BADPERR
 14715                                  NO_ERR_CHECK:
 14716 00003408 893E[8745]              		mov	[STARTEL],di	  ; New element
 14717 0000340C FF06[8745]              		inc	word [STARTEL]	  ; Point to char after /
 14718 00003410 C606[8945]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14719 00003415 C606[8A45]00            		mov	byte [ELPOS],0
 14720                                  NOTSPECIAL:
 14721 0000341A E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14722                                  ANUM_TEST:
 14723 0000341D AC                      		lodsb
 14724 0000341E 803E[4644]01            		cmp	byte [CPYFLAG],1
 14725 00003423 7503                    		jnz	short CPCONT3
 14726 00003425 E8F6E3                  		call	UPCONV_MAPCALL
 14727                                  CPCONT3:
 14728 00003428 E856E5                  		call	DELIM
 14729 0000342B 7432                    		jz	short X_DONE
 14730 0000342D 3C0D                    		cmp	al,0Dh
 14731 0000342F 742E                    		jz	short X_DONE
 14732 00003431 3A06[6542]              		cmp	al,[SWITCHAR]
 14733 00003435 7428                    		jz	short X_DONE
 14734 00003437 38D8                    		cmp	al,bl
 14735 00003439 7424                    		jz	short X_DONE
 14736 0000343B 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14737 0000343D 750F                    		jnz	short ANUM_CHARJ
 14738                                  
 14739                                  ; Modification made for parseline.
 14740                                  ; Why would it be necessary to change colons to spaces? In this
 14741                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14742                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14743                                  
 14744 0000343F 803E[4644]02            		cmp	byte [CPYFLAG],2
 14745 00003444 7505                    		jnz	short CPCONT4
 14746 00003446 E85F00                  		call	MOVE_CHAR
 14747 00003449 EBD2                    		jmp	short ANUM_TEST
 14748                                  
 14749                                  CPCONT4:
 14750 0000344B 46                      		inc	si		;Skip the ':'
 14751 0000344C EB11                    		jmp	short X_DONE
 14752                                  
 14753                                  ANUM_CHARJ:
 14754 0000344E E957FF                  		jmp	ANUM_CHAR
 14755                                  
 14756                                  BADPERR2:
 14757 00003451 BA[3C3D]                		mov	dx,BADCPMESPTR
 14758 00003454 E9CCE7                  		jmp	CERROR
 14759                                  
 14760                                  BADPERR:
 14761 00003457 E984DD                  		jmp	BADCDERR  ; MSDOS 3.3	
 14762                                  
 14763                                  CPERROR:
 14764 0000345A 4E                      		dec	si		; adjust the pointer
 14765 0000345B 5F                      		pop	di		; retrive token buffer address
 14766 0000345C 9D                      		popf			; restore flags
 14767 0000345D F9                      		stc			; set the carry bit
 14768 0000345E C3                      		retn
 14769                                  
 14770                                  X_DONE:
 14771 0000345F 4E                      		dec	si		; adjust for next round
 14772                                  
 14773                                  ; Mod to recognize right and left parens as integral tokens.
 14774                                  ;X_DONE2:
 14775 00003460 EB3F                    		jmp	short OUT_TOKEN
 14776                                  
 14777                                  A_SWITCH:
 14778 00003462 80CF01                  		or	bh,1		; Indicate switch
 14779 00003465 81CD0080                		or	bp,FSWITCH ; 8000h
 14780 00003469 E80DE5                  		call	SCANOFF
 14781 0000346C 46                      		inc	si
 14782 0000346D 3C0D                    		cmp	al,0Dh
 14783 0000346F 7509                    		jnz	short STORE_SWT
 14784 00003471 B000                    		mov	al,0
 14785 00003473 AA                      		stosb
 14786 00003474 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14787 00003478 EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14788                                  					;   BP = fSwitch but no switch
 14789                                  					;   bit is set (unknown switch)
 14790                                  
 14791                                  STORE_SWT:
 14792 0000347A E82B00                  		call	MOVE_CHAR	; store the character
 14793                                  
 14794                                  ; This upconv call must stay.  It is used to identify copy-switches
 14795                                  ; on the command line, and won't store anything into the output buffer.
 14796                                  
 14797 0000347D E89EE3                  		call	UPCONV_MAPCALL
 14798 00003480 06                      		push	es
 14799 00003481 57                      		push	di
 14800 00003482 51                      		push	cx
 14801 00003483 0E                      		push	cs
 14802 00003484 07                      		pop	es
 14803 00003485 BF[0D3F]                		mov	di,SWITCH_LIST ; "VBAPW"
 14804 00003488 B90500                  		mov	cx,SWCOUNT ; 5
 14805 0000348B 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14806 0000348F F2AE                    		repne scasb
 14807 00003491 750B                    		jnz	short OUT_TOKENP
 14808 00003493 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14809 00003497 B80100                  		mov	ax,1
 14810 0000349A D3E0                    		shl	ax,cl
 14811 0000349C 09C5                    		or	bp,ax
 14812                                  OUT_TOKENP:
 14813 0000349E 59                      		pop	cx
 14814 0000349F 5F                      		pop	di
 14815 000034A0 07                      		pop	es
 14816                                  OUT_TOKEN:
 14817 000034A1 B000                    		mov	al,0		; null at the end
 14818 000034A3 AA                      		stosb
 14819 000034A4 5F                      		pop	di		; restore token buffer pointer	
 14820 000034A5 9D                      		popf
 14821 000034A6 F8                      		clc			; clear carry flag
 14822 000034A7 C3                      		retn
 14823                                  
 14824                                  ; =============== S U B	R O U T	I N E =======================================
 14825                                  
 14826                                  MOVE_CHAR:
 14827 000034A8 AA                      		stosb			; store char in token buffer
 14828 000034A9 41                      		inc	cx		; increment char count
 14829 000034AA FE06[8945]              		inc	byte [ELCNT]	; increment element count for * substi
 14830 000034AE C3                      		retn
 14831                                  
 14832                                  ;============================================================================
 14833                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 14834                                  ;============================================================================
 14835                                  ; 30/09/2018 - Retro DOS v3.0
 14836                                  
 14837                                  ; BREAK	<Message Printing Routine>
 14838                                  
 14839                                  ;
 14840                                  ;	MSDOS V3.00 PRINT
 14841                                  ;
 14842                                  ;	Message Printing Routine
 14843                                  ;
 14844                                  
 14845                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 14846                                  ;
 14847                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 14848                                  ;
 14849                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 14850                                  ;
 14851                                  ; Characters are output to PFHandle according to the
 14852                                  ; specifications contained in the Control String.
 14853                                  ;
 14854                                  ; The conversion characters are as follow:
 14855                                  ;
 14856                                  ;               %c - output the next argument as a character
 14857                                  ;               %s - output the next argument as a string
 14858                                  ;               %x - output the next argument as a hexidecimal number
 14859                                  ;                    using abcedf
 14860                                  ;               %X - output the next argument as a hexidecimal number
 14861                                  ;                    using ABCDEF
 14862                                  ;               %d - output the next argument as a decimal number
 14863                                  ;
 14864                                  ;
 14865                                  ; Other format specifiers that may precede the conversion character are:
 14866                                  ;
 14867                                  ;               - (minus sign) - causes the field to be left-adjusted
 14868                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 14869                                  ;               n - digit specifing the minimum field width (default to 1)
 14870                                  ;               L - specifing a long integer
 14871                                  ;
 14872                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 14873                                  ;   to an argument list.
 14874                                  ;
 14875                                  ;   ____________________
 14876                                  ;   |   Ret Addr       |      <= SP
 14877                                  ;   --------------------
 14878                                  ;   |  Ptr to Arg List |
 14879                                  ;   --------------------
 14880                                  ;
 14881                                  ;   And the argument list contains the following:
 14882                                  ;
 14883                                  ;       String_ptr                  (a pointer to the control string)
 14884                                  ;       Arg 1
 14885                                  ;       Arg 2
 14886                                  ;         .
 14887                                  ;         .
 14888                                  ;         .
 14889                                  ;       Arg n-1
 14890                                  ;       Arg n
 14891                                  ;
 14892                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 14893                                  ;   or character.
 14894                                  ;
 14895                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 14896                                  
 14897                                  
 14898                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 14899                                  
 14900                                  ; =============== S U B	R O U T	I N E =======================================
 14901                                  
 14902                                  PRINTF_INIT:
 14903 000034AF E81100                  		call	STD_PRINTF
 14904 000034B2 CB                      		retf
 14905                                  
 14906                                  ; =============== S U B	R O U T	I N E =======================================
 14907                                  
 14908                                  PRINTF_CRLF:
 14909 000034B3 E80D00                  		call	STD_PRINTF
 14910 000034B6 E8B3E4                  		call	CRLF2
 14911 000034B9 C3                      		retn
 14912                                  
 14913                                  ; =============== S U B	R O U T	I N E =======================================
 14914                                  
 14915                                  STD_EPRINTF:
 14916 000034BA 2EC706[293F]0200        		mov	word [cs:PRINTF_HANDLE],2
 14917 000034C1 EB07                    		jmp	short NEW_PRINTF
 14918                                  
 14919                                  ; =============== S U B	R O U T	I N E =======================================
 14920                                  
 14921                                  STD_PRINTF:
 14922                                  
 14923                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 14924                                  
 14925 000034C3 2EC706[293F]0100        		mov	word [cs:PRINTF_HANDLE],1
 14926                                  
 14927                                  NEW_PRINTF:				;Save the callers' registers
 14928 000034CA FC                      		cld
 14929 000034CB 52                      		push	dx
 14930 000034CC 55                      		push	bp
 14931 000034CD 89E5                    		mov	bp,sp
 14932 000034CF 51                      		push	cx
 14933 000034D0 53                      		push	bx
 14934 000034D1 50                      		push	ax
 14935 000034D2 57                      		push	di
 14936 000034D3 56                      		push	si
 14937 000034D4 06                      		push	es
 14938 000034D5 1E                      		push	ds
 14939 000034D6 0E                      		push	cs
 14940 000034D7 07                      		pop	es		;ES points to Printf segment
 14941 000034D8 BF[2B3F]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 14942 000034DB 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 14943                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 14944 000034DE 3E8B7600                		mov	si,[ds:bp] ; bp
 14945 000034E2 83C502                  		add	bp,2
 14946 000034E5 31DB                    		xor	bx,bx
 14947 000034E7 E8F901                  		call	CLEAR_FLAGS	; initialize the world
 14948                                  
 14949                                  GET_CHAR:
 14950 000034EA AC                      		lodsb			;Get a character
 14951 000034EB 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 14952 000034ED 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 14953 000034EF 08C0                    		or	al,al		;Is it the end of the control string?
 14954 000034F1 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 14955                                  PRINTF_PERCENT:				
 14956 000034F3 E88801                  		call	OUTCHR		;Otherwise store the character
 14957 000034F6 EBF2                    		jmp	short GET_CHAR	;And go get another
 14958                                  
 14959                                  PRINTF_DONE:
 14960 000034F8 E88B01                  		call	FLUSH
 14961 000034FB 1F                      		pop	ds
 14962 000034FC 07                      		pop	es
 14963 000034FD 5E                      		pop	si
 14964 000034FE 5F                      		pop	di
 14965 000034FF 58                      		pop	ax
 14966 00003500 5B                      		pop	bx
 14967 00003501 59                      		pop	cx
 14968 00003502 5D                      		pop	bp
 14969 00003503 5A                      		pop	dx
 14970 00003504 C3                      		retn
 14971                                  
 14972                                  CONV_CHAR:
 14973 00003505 2EC606[203F]00          		mov	byte [cs:PRINTF_LEFT],0
 14974                                  
 14975                                  NXT_CONV_CHAR:	
 14976                                  		;Look for any format specifiers preceeding the conversion character
 14977 0000350B AC                      		lodsb
 14978 0000350C 3C25                    		cmp	al,'%'			;Just print the %
 14979 0000350E 74E3                    		jz	short PRINTF_PERCENT
 14980 00003510 2E3A06[EE3E]            		cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 14981 00003515 7448                    		jz	short LEFT_ADJ
 14982 00003517 2E3A06[EF3E]            		cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 14983 0000351C 74E7                    		jz	short CONV_CHAR
 14984 0000351E 2E3A06[F03E]            		cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 14985 00003523 7442                    		jz	short LONG_INT
 14986 00003525 2E3A06[F13E]            		cmp	al,[cs:char_l]	 ; "l"		
 14987 0000352A 743B                    		jz	short LONG_INT
 14988 0000352C 3C30                    		cmp	al,'0'			;Is it a precision specification
 14989 0000352E 723F                    		jb	short LOOK_CONV_CHAR
 14990 00003530 3C39                    		cmp	al,'9'
 14991 00003532 773B                    		ja	short LOOK_CONV_CHAR
 14992 00003534 3C30                    		cmp	al,'0'
 14993 00003536 750F                    		jnz	short NOT_PAD
 14994 00003538 2E833E[243F]00          		cmp	word [cs:PRINTF_WIDTH],0
 14995 0000353E 7507                    		jnz	short NOT_PAD
 14996 00003540 B430                    		mov	ah,'0'
 14997 00003542 2E8826[283F]            		mov	[cs:PAD_CHAR],ah
 14998                                  NOT_PAD:					;Adjust decimal place on precision
 14999 00003547 50                      		push	ax
 15000 00003548 2EA1[243F]              		mov	ax,[cs:PRINTF_WIDTH]
 15001 0000354C B90A00                  		mov	cx,10
 15002 0000354F F7E1                    		mul	cx
 15003 00003551 5A                      		pop	dx
 15004 00003552 30F6                    		xor	dh,dh
 15005 00003554 80EA30                  		sub	dl,'0'
 15006 00003557 01D0                    		add	ax,dx
 15007 00003559 2EA3[243F]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 15008 0000355D EBAC                    		jmp	short NXT_CONV_CHAR
 15009                                  
 15010                                  LEFT_ADJ:
 15011 0000355F 2EC606[203F]01          		mov	byte [cs:PRINTF_LEFT],1
 15012 00003565 EBA4                    		jmp	short NXT_CONV_CHAR
 15013                                  
 15014                                  LONG_INT:
 15015 00003567 2E800E[213F]01          		or	byte [cs:PRINTF_LONG],1
 15016 0000356D EB9C                    		jmp	short NXT_CONV_CHAR
 15017                                  
 15018                                  LOOK_CONV_CHAR:
 15019 0000356F 24DF                    		and	al,0DFh
 15020 00003571 2E3A06[F73E]            		cmp	al,[cs:CHAR_X]	 ; "X"
 15021 00003576 741B                    		jz	short HEX_UP
 15022 00003578 2E3A06[F43E]            		cmp	al,[cs:CHAR_D]	 ; "D"
 15023 0000357D 741D                    		jz	short DECIMAL
 15024 0000357F 2E3A06[F53E]            		cmp	al,[cs:CHAR_C]	 ; "C"
 15025 00003584 741F                    		jz	short C_PUT_CHAR
 15026 00003586 2E3A06[F63E]            		cmp	al,[cs:CHAR_S]	 ; "S"
 15027 0000358B 7426                    		jz	short S_PUT_STRG
 15028 0000358D E85301                  		call	CLEAR_FLAGS
 15029 00003590 E957FF                  		jmp	GET_CHAR
 15030                                  
 15031                                  HEX_UP:
 15032 00003593 2EC706[263F]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15033 0000359A EB6C                    		jmp	short CONV_TO_NUM
 15034                                  DECIMAL:
 15035 0000359C 2EC706[263F]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15036 000035A3 EB63                    		jmp	short CONV_TO_NUM
 15037                                  
 15038                                  C_PUT_CHAR:
 15039 000035A5 E82E01                  		call	NEXT_CHRS
 15040 000035A8 88D0                    		mov	al,dl
 15041 000035AA E8D100                  		call	OUTCHR
 15042 000035AD E83301                  		call	CLEAR_FLAGS
 15043 000035B0 E937FF                  		jmp	GET_CHAR
 15044                                  
 15045                                  S_PUT_STRG:
 15046 000035B3 56                      		push	si			;Save pointer to control string
 15047 000035B4 E81F01                  		call	NEXT_CHRS
 15048 000035B7 89D6                    		mov	si,dx
 15049                                  S_PUT_1:
 15050 000035B9 2E8B0E[243F]            		mov	cx,[cs:PRINTF_WIDTH]
 15051 000035BE 09C9                    		or	cx,cx
 15052 000035C0 740B                    		jz	short S_PUT_2
 15053 000035C2 2E803E[203F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15054 000035C8 7503                    		jnz	short S_PUT_2
 15055 000035CA E82700                  		call	PAD_STRING
 15056                                  S_PUT_2:
 15057 000035CD 56                      		push	si
 15058                                  S_PUT_3:
 15059 000035CE AC                      		lodsb
 15060 000035CF 08C0                    		or	al,al
 15061 000035D1 7405                    		jz	short S_PUT_4
 15062 000035D3 E8A800                  		call	OUTCHR			;Put it into our buffer
 15063 000035D6 EBF6                    		jmp	short S_PUT_3
 15064                                  S_PUT_4:
 15065 000035D8 5E                      		pop	si
 15066 000035D9 2E803E[203F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15067 000035DF 740C                    		jz	short C_S_END
 15068 000035E1 2E8B0E[243F]            		mov	cx,[cs:PRINTF_WIDTH]
 15069 000035E6 09C9                    		or	cx,cx
 15070 000035E8 7403                    		jz	short C_S_END
 15071 000035EA E80700                  		call	PAD_STRING
 15072                                  C_S_END:
 15073 000035ED 5E                      		pop	si			;Restore control string pointer
 15074 000035EE E8F200                  		call	CLEAR_FLAGS
 15075 000035F1 E9F6FE                  		jmp	GET_CHAR		;Go get another character	
 15076                                  
 15077                                  
 15078                                  ; =============== S U B	R O U T	I N E =======================================
 15079                                  
 15080                                  PAD_STRING:
 15081 000035F4 31D2                    		xor	dx,dx
 15082 000035F6 56                      		push	si
 15083                                  
 15084                                  COUNT_LOOP:
 15085 000035F7 AC                      		lodsb
 15086 000035F8 08C0                    		or	al,al
 15087 000035FA 7403                    		jz	short COUNT_DONE
 15088 000035FC 42                      		inc	dx
 15089 000035FD EBF8                    		jmp	short COUNT_LOOP
 15090                                  
 15091                                  COUNT_DONE:
 15092 000035FF 5E                      		pop	si
 15093 00003600 29D1                    		sub	cx,dx
 15094 00003602 7603                    		jbe	short COUNT_RET
 15095 00003604 E86700                  		call	PAD
 15096                                  
 15097                                  COUNT_RET:
 15098 00003607 C3                      		retn
 15099                                  
 15100                                  ; ---------------------------------------------------------------------------
 15101                                  
 15102                                  CONV_TO_NUM:
 15103 00003608 E8CB00                  		call	NEXT_CHRS
 15104 0000360B 89D0                    		mov	ax,dx
 15105 0000360D 31D2                    		xor	dx,dx
 15106 0000360F 2E803E[213F]00          		cmp	byte [cs:PRINTF_LONG],0 
 15107                                  				;Is this is a short or long integer?
 15108 00003615 7403                    		jz	short NOT_LONG_INT
 15109 00003617 E8BC00                  		call	NEXT_CHRS
 15110                                  
 15111                                  NOT_LONG_INT:
 15112 0000361A 53                      		push	bx
 15113 0000361B 56                      		push	si
 15114 0000361C 2E8B36[263F]            		mov	si,[cs:PRINTF_BASE]
 15115 00003621 2E8B0E[243F]            		mov	cx,[cs:PRINTF_WIDTH]
 15116 00003626 E80B00                  		call	PNUM
 15117 00003629 5E                      		pop	si
 15118 0000362A 5B                      		pop	bx
 15119 0000362B E84000                  		call	PAD
 15120 0000362E E8B200                  		call	CLEAR_FLAGS
 15121 00003631 E9B6FE                  		jmp	GET_CHAR
 15122                                  
 15123                                  
 15124                                  ; =============== S U B	R O U T	I N E =======================================
 15125                                  
 15126                                  PNUM:
 15127 00003634 49                      		dec	cx
 15128 00003635 50                      		push	ax
 15129 00003636 89D0                    		mov	ax,dx
 15130 00003638 31D2                    		xor	dx,dx
 15131 0000363A F7F6                    		div	si
 15132 0000363C 89C3                    		mov	bx,ax
 15133 0000363E 58                      		pop	ax
 15134 0000363F F7F6                    		div	si
 15135 00003641 87DA                    		xchg	bx,dx
 15136 00003643 50                      		push	ax
 15137 00003644 09D0                    		or	ax,dx
 15138 00003646 58                      		pop	ax
 15139 00003647 7407                    		jz	short DO_PAD
 15140 00003649 53                      		push	bx
 15141 0000364A E8E7FF                  		call	PNUM
 15142 0000364D 5B                      		pop	bx
 15143 0000364E EB0B                    		jmp	short REM
 15144                                  
 15145                                  DO_PAD:
 15146 00003650 2E803E[203F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15147 00003656 7503                    		jnz	short REM
 15148 00003658 E81300                  		call	PAD
 15149                                  REM:
 15150 0000365B 80FB0A                  		cmp	bl,10
 15151 0000365E 7203                    		jb	short NOT_HEX
 15152 00003660 83C306                  		add	bx,6
 15153                                  NOT_HEX:
 15154 00003663 2E8A87[0037]            		mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 15155 00003668 51                      		push	cx
 15156 00003669 E81200                  		call	OUTCHR
 15157 0000366C 59                      		pop	cx
 15158 0000366D C3                      		retn
 15159                                  
 15160                                  ; =============== S U B	R O U T	I N E =======================================
 15161                                  
 15162                                  PAD:
 15163 0000366E 09C9                    		or	cx,cx
 15164 00003670 7E0B                    		jle	short PAD_DONE
 15165 00003672 2EA0[283F]              		mov	al,[cs:PAD_CHAR]
 15166                                  PAD_LOOP:
 15167 00003676 51                      		push	cx
 15168 00003677 E80400                  		call	OUTCHR
 15169 0000367A 59                      		pop	cx
 15170 0000367B E2F9                    		loop	PAD_LOOP
 15171                                  PAD_DONE:
 15172 0000367D C3                      		retn
 15173                                  
 15174                                  ; =============== S U B	R O U T	I N E =======================================
 15175                                  
 15176                                  OUTCHR:
 15177 0000367E AA                      		stosb
 15178 0000367F 81FF[8F3F]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15179 00003683 7401                    		je	short FLUSH
 15180                                  OUTCHR_RETN:
 15181 00003685 C3                      		retn
 15182                                  
 15183                                  ; =============== S U B	R O U T	I N E =======================================
 15184                                  
 15185                                  FLUSH:
 15186 00003686 B9[2B3F]                		mov	cx,PRINTF_BUF
 15187 00003689 87CF                    		xchg	cx,di
 15188 0000368B 29F9                    		sub	cx,di
 15189 0000368D 74F6                    		jz	short OUTCHR_RETN
 15190                                  WRITE_CHARS:
 15191 0000368F 53                      		push	bx
 15192 00003690 2E8B1E[293F]            		mov	bx,[cs:PRINTF_HANDLE]
 15193 00003695 1E                      		push	ds
 15194 00003696 0E                      		push	cs
 15195 00003697 1F                      		pop	ds
 15196 00003698 BA[2B3F]                		mov	dx,PRINTF_BUF
 15197 0000369B B440                    		mov	ah,WRITE ; 40h
 15198 0000369D CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15199                                  					; BX = file handle, CX = number	of bytes to write,
 15200                                  					; DS:DX -> buffer
 15201 0000369F 730A                    		jnb	short FOOB2_1
 15202 000036A1 E820E8                  		call	GET_EXT_ERR_NUMBER
 15203 000036A4 83F806                  		cmp	ax,6
 15204 000036A7 742A                    		jz	short FOOB2_4
 15205 000036A9 EB04                    		jmp	short FOOB2_2
 15206                                  
 15207                                  FOOB2_1:
 15208 000036AB 39C1                    		cmp	cx,ax
 15209 000036AD 7424                    		jz	short FOOB2_4
 15210                                  FOOB2_2:
 15211 000036AF 89D3                    		mov	bx,dx
 15212 000036B1 01C3                    		add	bx,ax
 15213 000036B3 803F1A                  		cmp	byte [bx],1Ah
 15214 000036B6 741B                    		jz	short FOOB2_4
 15215 000036B8 1F                      		pop	ds
 15216 000036B9 5B                      		pop	bx
 15217 000036BA 2E8E06[6142]            		mov	es,[cs:RESSEG]
 15218 000036BF BA[2938]                		mov	dx,NOSPACEPTR
 15219 000036C2 26F6065C0CFF            		test	byte [es:PIPEFLAG],0FFh
 15220 000036C8 7406                    		jz	short PRINT_ERR_EXIT
 15221 000036CA E8B9EC                  		call	PIPEOFF
 15222 000036CD BA[C23C]                		mov	dx,PIPEEMESPTR
 15223                                  PRINT_ERR_EXIT:	
 15224 000036D0 E950E5                  		jmp	CERROR
 15225                                  
 15226                                  FOOB2_4:
 15227 000036D3 1F                      		pop	ds
 15228 000036D4 5B                      		pop	bx
 15229 000036D5 C3                      		retn
 15230                                  
 15231                                  ; =============== S U B	R O U T	I N E =======================================
 15232                                  
 15233                                  NEXT_CHRS:
 15234 000036D6 56                      		push	si		;Save pointer to control string
 15235 000036D7 89DE                    		mov	si,bx		;Get index into argument list
 15236 000036D9 83C302                  		add	bx,2		;Increment the index
 15237 000036DC 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15238 000036DF 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15239 000036E1 5E                      		pop	si
 15240 000036E2 C3                      		retn
 15241                                  
 15242                                  ; =============== S U B	R O U T	I N E =======================================
 15243                                  
 15244                                  CLEAR_FLAGS:
 15245 000036E3 31C0                    		xor	ax,ax
 15246 000036E5 2EA2[203F]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15247 000036E9 2EA2[213F]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15248 000036ED 2EA3[243F]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15249 000036F1 B020                    		mov	al,' '			
 15250 000036F3 2EA2[283F]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15251 000036F7 C3                      		retn
 15252                                  
 15253                                  ; ---------------------------------------------------------------------------
 15254                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15255                                  
 15256                                  		; times 7 db 0
 15257                                  
 15258                                  ;============================================================================
 15259                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15260                                  ;============================================================================
 15261                                  ; 30/09/2018 - Retro DOS v3.0
 15262                                  
 15263                                  ; TITLE	COMMAND Transient Initialized DATA
 15264                                  
 15265                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15266                                  ;initial values at the beginning of each command cycle. It is
 15267                                  ;included in the transient checksum area. If values in TRANDATA
 15268                                  ;change, the transient will be reloaded for the next command cycle.
 15269                                  
 15270 000036F8 90<rep 8h>              align 16
 15271                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15272                                  
 15273 00003700 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15273 00003709 39414243444546     
 15274 00003710 255300                  _3740h:		db '%S',0
 15275 00003713 [1037]                  ARG_BUF_PTR:	dw _3740h
 15276 00003715 [1737]                  		dw _3747h
 15277 00003717 [B843]                  _3747h:		dw ARG_BUF ; _43E8h
 15278 00003719 25532000                _3749h:		db '%S ',0
 15279 0000371D [1937]                  STRINGBUF1PTR:	dw _3749h
 15280 0000371F [3844]                  		dw STRING_PTR_1 ; _4468h
 15281 00003721 25396C6400              _3751h:		db '%9ld',0
 15282 00003726 [2137]                  FSIZEMESPTR:	dw _3751h
 15283 00003728 [3A44]                  		dw FILESIZE_L ; _446Ah
 15284 0000372A [3C44]                  		dw FILESIZE_H ; _446Ch
 15285 0000372C 255300                  _375Ch:		db '%S',0
 15286 0000372F [2C37]                  STRINGBUF2PTR:	dw _375Ch
 15287 00003731 [3E44]                  		dw STRING_PTR_2 ; _446Eh
 15288 00003733 0900                    _3763h:		db 9,0
 15289 00003735 [3337]                  TABPTR:		dw _3763h
 15290 00003737 0D0A                    _3767h:		db 0Dh,0Ah
 15291 00003739 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15291 00003742 65206D697373696E67-
 15291 0000374B 0D0A00             
 15292 0000374E [3737]                  BADPATHPTR:	dw _3767h
 15293 00003750 0D0A                    _3780h:		db 0Dh,0Ah
 15294 00003752 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15294 0000375B 736B20776974682062-
 15294 00003764 617463682066696C65-
 15294 0000376D 0D0A               
 15295 0000376F 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15295 00003778 20616E79206B657920-
 15295 00003781 7768656E2072656164-
 15295 0000378A 790D0A00           
 15296 0000378E [5037]                  INSERTDSKPTR:	dw _3780h
 15297 00003790 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15297 00003799 6E64206F722066696C-
 15297 000037A2 65206E616D650D0A00 
 15298 000037AB [9037]                  BADNAMPTR:	dw _37C0h
 15299 000037AD 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15299 000037B6 2066696C65206E616D-
 15299 000037BF 65206F722046696C65-
 15299 000037C8 206E6F7420666F756E-
 15299 000037D1 640D0A00           
 15300 000037D5 [AD37]                  RENERRPTR:	dw _37DDh
 15301 000037D7 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15301 000037E0 666F756E640D0A00   
 15302 000037E8 [D737]                  FNOTFOUNDPTR:	dw _3807h
 15303 000037EA 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15303 000037F3 666F756E640D0A00   
 15304 000037FB [EA37]                  PNOTFOUNDPTR:	dw _381Ah
 15305 000037FD 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15305 00003806 6E6965640D0A00     
 15306 0000380D [FD37]                  ACCDENPTR:	dw _382Dh
 15307 0000380F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15307 00003818 656E74206469736B20-
 15307 00003821 73706163650D0A00   
 15308 00003829 [0F38]                  NOSPACEPTR:	dw _383Fh
 15309 0000382B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15309 00003834 7669726F6E6D656E74-
 15309 0000383D 2073706163650D0A00 
 15310 00003846 [2B38]                  ENVERRPTR:	dw _385Bh
 15311 00003848 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15311 00003851 74696F6E206572726F-
 15311 0000385A 720D0A00           
 15312 0000385E 7838                    FULDIRPTR:	dw 3878h
 15313 00003860 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15313 00003869 6F7420626520636F70-
 15313 00003872 696564206F6E746F20-
 15313 0000387B 697473656C660D0A00 
 15314 00003884 [6038]                  OVERWRPTR:	dw _3890h
 15315 00003886 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15315 0000388F 662064657374696E61-
 15315 00003898 74696F6E206C6F7374-
 15315 000038A1 206265666F72652063-
 15315 000038AA 6F70790D0A00       
 15316 000038B0 [8638]                  LOSTERRPTR:	dw _38B6h
 15317 000038B2 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15317 000038BB 696C656E616D65206F-
 15317 000038C4 722066696C65206E6F-
 15317 000038CD 7420666F756E640D0A-
 15317 000038D6 00                 
 15318 000038D7 [B238]                  INORNOTPTR:	dw _38E2h
 15319 000038D9 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15319 000038E2 732920636F70696564-
 15319 000038EB 0D0A00             
 15320 000038EE [D938]                  COPIEDPTR:	dw _3909h
 15321 000038F0 [4044]                  		dw COPY_NUM ; _4470h
 15322 000038F2 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15322 000038FB 73292000           
 15323 000038FF [F238]                  DIRMESPTR:	dw _3922h
 15324 00003901 [4744]                  		dw DIR_NUM  ; _4477h
 15325 00003903 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15325 0000390C 7320667265650D0A00 
 15326 00003915 [0339]                  BYTEMESPTR:	dw _3933h
 15327 00003917 [4944]                  		dw BYTES_FREE   ; _4479h
 15328 00003919 [4B44]                  		dw BYTES_FREE+2 ; _447Bh
 15329 0000391B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15329 00003924 726976652073706563-
 15329 0000392D 696669636174696F6E-
 15329 00003936 0D0A00             
 15330 00003939 [1B39]                  BADDRVPTR:	dw _394Bh
 15331 0000393B 0D0A                    _396Bh:		db 0Dh,0Ah
 15332 0000393D 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15332 00003946 20253564206E6F7420-
 15332 0000394F 707265706172656420-
 15332 00003958 666F72207379737465-
 15332 00003961 6D0D0A00           
 15333 00003965 [3B39]                  CPNOTSETPTR:	dw _396Bh
 15334 00003967 [FF3E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15335 00003969 0D0A                    _3999h:		db 0Dh,0Ah
 15336 0000396B 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15336 00003974 20253564206E6F7420-
 15336 0000397D 707265706172656420-
 15336 00003986 666F7220616C6C2064-
 15336 0000398F 6576696365730D0A00 
 15337 00003998 [6939]                  CPNOTALLPTR:	dw _3999h
 15338 0000399A [FF3E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15339 0000399C 0D0A                    _39CCh:		db 0Dh,0Ah
 15340 0000399E 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15340 000039A7 646520706167653A20-
 15340 000039B0 2535640D0A00       
 15341 000039B6 [9C39]                  CPACTIVEPTR:	dw _39CCh
 15342 000039B8 [FF3E]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15343 000039BA 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15343 000039C3 72697665206973206E-
 15343 000039CC 6F206C6F6E67657220-
 15343 000039D5 76616C696400       
 15344 000039DB [BA39]                  BADCURDRVPTR:	dw _39EAh
 15345 000039DD 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15345 000039E6 6B6579207768656E20-
 15345 000039EF 7265616479202E202E-
 15345 000039F8 202E2000           
 15346 000039FC [DD39]                  PAUSEMESPTR:	dw _3A0Dh
 15347 000039FE 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15347 00003A07 6172616D657465720D-
 15347 00003A10 0A00               
 15348 00003A12 [FE39]                  BADPARMPTR:	dw _3A2Eh
 15349 00003A14 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15349 00003A1D 576564546875467269-
 15349 00003A26 536174             
 15350 00003A29 0D0A                    _3A59h:		db 0Dh,0Ah
 15351 00003A2B 496E76616C69642064-     		db 'Invalid date',0
 15351 00003A34 61746500           
 15352 00003A38 [293A]                  BADDATPTR:	dw _3A59h
 15353 00003A3A 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15353 00003A43 6174652069732000   
 15354 00003A4B [3A3A]                  CURDATPTR:	dw _3A6Ah
 15355 00003A4D 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15356 00003A4F 456E746572206E6577-     		db 'Enter new date ',0
 15356 00003A58 20646174652000     
 15357 00003A5F [4D3A]                  NEWDATPTR:	dw _3A7Dh
 15358 00003A61 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15358 00003A6A 293A2000           
 15359 00003A6E [613A]                  USADATPTR:	dw _3A91h
 15360 00003A70 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15360 00003A79 293A2000           
 15361 00003A7D [703A]                  EURDATPTR:	dw _3AA0h
 15362 00003A7F 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15362 00003A88 293A2000           
 15363 00003A8C [7F3A]                  JAPDATPTR:	dw _3AAFh
 15364 00003A8E 0D0A                    _3ABEh:		db 0Dh,0Ah
 15365 00003A90 496E76616C69642074-     		db 'Invalid time ',0
 15365 00003A99 696D652000         
 15366 00003A9E [8E3A]                  BADTIMPTR:	dw _3ABEh
 15367 00003AA0 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15367 00003AA9 696D652069732000   
 15368 00003AB1 [A03A]                  CURTIMPTR:	dw _3AD0h
 15369 00003AB3 0D0A                    _3AE3h:		db 0Dh,0Ah
 15370 00003AB5 456E746572206E6577-     		db 'Enter new time: ',0
 15370 00003ABE 2074696D653A2000   
 15371 00003AC6 [B33A]                  NEWTIMPTR:	dw _3AE3h
 15372 00003AC8 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15372 00003AD1 7572652028592F4E29-
 15372 00003ADA 3F00               
 15373 00003ADC [C83A]                  SUREMESPTR:	dw _3AF8h
 15374 00003ADE 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15374 00003AE7 00                 
 15375 00003AE8 [DE3A]                  DMESPTR:	dw _3B0Eh
 15376 00003AEA 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15376 00003AF3 7273696F6E20253164-
 15376 00003AFC 2E2530326420202020-
 15376 00003B05 202020202020202020-
 15376 00003B0E 202020202020202000 
 15377 00003B17 [EA3A]                  VERMESPTR:	dw _3B1Ah
 15378 00003B19 [4D44]                  		dw MAJOR_VER_NUM ; _447Dh
 15379 00003B1B [4F44]                  		dw MINOR_VER_NUM ; _447Fh
 15380 00003B1D 254300                  _3B4Dh:		db '%C',0
 15381 00003B20 [1D3B]                  ONECHRVALPTR:	dw _3B4Dh
 15382 00003B22 [5144]                  		dw ONE_CHAR_VAL	; _4481h
 15383 00003B24 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15383 00003B2D 6E2064726976652025-
 15383 00003B36 6320257300         
 15384 00003B3B [243B]                  VOLMESPTR:	dw _3B54h
 15385 00003B3D [5444]                  		dw VOL_DRV ; _4484h
 15386 00003B3F [5244]                  		dw VOLNAME_ADDR ; _4482h
 15387 00003B41 69732000                IS:		db 'is ',0
 15388 00003B45 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15388 00003B4E 62656C00           
 15389 00003B52 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15389 00003B5B 69726563746F72790D-
 15389 00003B64 0A00               
 15390 00003B66 [523B]                  BADCDPTR:	dw _3B82h
 15391 00003B68 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15391 00003B71 206372656174652064-
 15391 00003B7A 69726563746F72790D-
 15391 00003B83 0A00               
 15392 00003B85 [683B]                  BADMKDPTR:	dw _3B98h
 15393 00003B87 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15393 00003B90 6174682C206E6F7420-
 15393 00003B99 6469726563746F7279-
 15393 00003BA2 2C0D0A             
 15394 00003BA5 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15394 00003BAE 6F7279206E6F742065-
 15394 00003BB7 6D7074790D0A00     
 15395 00003BBE [873B]                  BADRMDPTR:	dw _3BB7h
 15396 00003BC0 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15396 00003BC9 696679204F4E206F72-
 15396 00003BD2 204F46460D0A00     
 15397 00003BD9 [C03B]                  BADONOFFPTR:	dw _3BF0h
 15398 00003BDB 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15398 00003BE4 79206F66202025530D-
 15398 00003BED 0A00               
 15399 00003BEF [DB3B]                  DIRHEADPTR:	dw _3C0Bh
 15400 00003BF1 [5544]                  		dw VOL_DIR ; _4485h
 15401 00003BF3 4E6F205061746800        _3C23h:		db 'No Path',0
 15402 00003BFB [F33B]                  NULLPATHPTR:	dw _3C23h
 15403 00003BFD 504154483D              PATH_TEXT:	db 'PATH='
 15404 00003C02 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15405 00003C09 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15406 00003C11 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15406 00003C1A 7269766520696E2073-
 15406 00003C23 656172636820706174-
 15406 00003C2C 680D0A00           
 15407 00003C30 [113C]                  BADPMESPTR:	dw _3C41h
 15408 00003C32 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15408 00003C3B 65766963650D0A00   
 15409 00003C43 [323C]                  BADDEVPTR:	dw _3C62h
 15410 00003C45 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15410 00003C4E 20666F756E640D0A00 
 15411 00003C57 [453C]                  BADLABPTR:	dw _3C75h
 15412 00003C59 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15412 00003C62 726F720D0A00       
 15413 00003C68 [593C]                  SYNTMESPTR:	dw _3C89h
 15414 00003C6A 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15414 00003C73 6F74206265206E6573-
 15414 00003C7C 7465640D0A00       
 15415 00003C82 [6A3C]                  FORNESTMESTR:	dw _3C9Ah
 15416 00003C84 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15416 00003C8D 656E74206D656D6F72-
 15416 00003C96 790D0A00           
 15417 00003C9A [843C]                  INSFMEMMESPTR:	dw _3CB4h
 15418 00003C9C 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15418 00003CA5 6174652066696C6520-
 15418 00003CAE 6572726F7220647572-
 15418 00003CB7 696E6720706970650D-
 15418 00003CC0 0A00               
 15419 00003CC2 [9C3C]                  PIPEEMESPTR:	dw _3CCCh
 15420 00003CC4 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15420 00003CCD 2062696E6172792072-
 15420 00003CD6 656164732066726F6D-
 15420 00003CDF 206120646576696365-
 15420 00003CE8 0D0A00             
 15421 00003CEB [C43C]                  INBDEVPTR:	dw _3CF4h
 15422 00003CED 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15422 00003CF6 00                 
 15423 00003CF7 [ED3C]                  CTRLMESPTR:	dw _3D1Dh
 15424 00003CF9 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15424 00003D02 2000               
 15425 00003D04 [F93C]                  VERIMESPTR:	dw _3D29h
 15426 00003D06 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15427 00003D0F [063D]                  ECHOMESPTR:	dw _3D36h
 15428 00003D11 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15429 00003D17 [113D]                  OFFMESPTR:	dw _3D41h
 15430 00003D19 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15431 00003D1E [193D]                  ONMESPTR:	dw _3D49h
 15432 00003D20 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15432 00003D29 617468206F72206669-
 15432 00003D32 6C65206E616D650D0A-
 15432 00003D3B 00                 
 15433 00003D3C [203D]                  BADCPMESPTR:	dw _3D50h
 15434 00003D3E 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15434 00003D47 756D626572206F6620-
 15434 00003D50 706172616D65746572-
 15434 00003D59 730D0A00           
 15435 00003D5D [3E3D]                  BADARGSPTR:	dw _3D6Eh
 15436 00003D5F 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15436 00003D68 74696E6720746F2064-
 15436 00003D71 65766963650D0A00   
 15437 00003D79 [5F3D]                  DEVWMESPTR:	dw _3D8Fh
 15438 00003D7B 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15439 00003D7E [7B3D]                  ACRLFPTR:	dw _3DABh
 15440 00003D80 08                      _3DB0h:		db 8
 15441 00003D81 20                      		db 20h
 15442 00003D82 08                      		db 8
 15443 00003D83 00                      		db 0
 15444 00003D84 [803D]                  DBACKPTR:	dw _3DB0h
 15445 00003D86 79                      small_y:	db 'y'
 15446 00003D87 6E                      small_n:	db 'n'
 15447 00003D88 59                      CAPITAL_Y:	db 'Y'
 15448 00003D89 4E                      CAPITAL_N:	db 'N'
 15449 00003D8A 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15450                                  PROMPT_TABLE:
 15451 00003D8F 42                      		db 'B' ; 42h
 15452 00003D90 [F813]                  		dw PRINT_B
 15453 00003D92 44                      		db 'D' ; 44h
 15454 00003D93 [8F29]                  		dw PRINT_DATE
 15455 00003D95 45                      		db 'E' ; 45h
 15456 00003D96 [EA13]                  		dw PRINT_ESC
 15457 00003D98 47                      		db 'G' ; 47h
 15458 00003D99 [EE13]                  		dw PRINT_G
 15459 00003D9B 48                      		db 'H' ; 48h
 15460 00003D9C [E013]                  		dw PRINT_BACK
 15461 00003D9E 4C                      		db 'L' ; 4Ch
 15462 00003D9F [F313]                  		dw PRINT_L
 15463 00003DA1 4E                      		db 'N' ; 4Eh
 15464 00003DA2 [0E14]                  		dw PRINT_DRIVE
 15465 00003DA4 50                      		db 'P' ; 50h
 15466 00003DA5 [1A14]                  		dw BUILD_DIR_FOR_PROMPT
 15467 00003DA7 51                      		db 'Q' ; 51h
 15468 00003DA8 [E613]                  		dw PRINT_EQ
 15469 00003DAA 54                      		db 'T' ; 54h
 15470 00003DAB [2622]                  		dw PRINT_TIME
 15471 00003DAD 56                      		db 'V' ; 56h
 15472 00003DAE [7213]                  		dw PRINT_VERSION
 15473 00003DB0 5F                      		db '_' ; 5Fh
 15474 00003DB1 [6C19]                  		dw CRLF2
 15475 00003DB3 24                      		db '$' ; 24h
 15476 00003DB4 [FB13]                  		dw PRINT_CHAR
 15477 00003DB6 00                      		db 0
 15478                                  
 15479                                  		; Table of IF conditionals
 15480                                  IFTAB:
 15481 00003DB7 03                      		db 3	; First byte is count
 15482 00003DB8 4E4F54                  		db 'NOT'
 15483 00003DBB [7F09]                  		dw IFNOT
 15484 00003DBD 0A                      		db 10
 15485 00003DBE 4552524F524C455645-     		db 'ERRORLEVEL'
 15485 00003DC7 4C                 
 15486 00003DC8 [420A]                  		dw IFERLEV
 15487 00003DCA 05                      		db 5
 15488 00003DCB 4558495354              		db 'EXIST'
 15489 00003DD0 [D609]                  		dw IFEXISTS
 15490 00003DD2 00                      		db 0
 15491                                  
 15492                                  		; Table for internal command names
 15493                                  
 15494 00003DD3 03                      COMTAB:		db 3
 15495 00003DD4 444952                  		db 'DIR'
 15496 00003DD7 03                      		db 3
 15497 00003DD8 [C20E]                  		dw CATALOG
 15498 00003DDA 04                      		db 4
 15499 00003DDB 43414C4C                		db 'CALL'
 15500 00003DDF 02                      		db 2
 15501 00003DE0 [B70A]                  		dw _$CALL
 15502 00003DE2 04                      		db 4
 15503 00003DE3 43484350                		db 'CHCP'
 15504 00003DE7 02                      		db 2
 15505 00003DE8 [C115]                  		dw CHCP
 15506 00003DEA 06                      		db 6
 15507 00003DEB 52454E414D45            		db 'RENAME'
 15508 00003DF1 01                      		db 1
 15509 00003DF2 [0212]                  		dw CRENAME
 15510 00003DF4 03                      		db 3
 15511 00003DF5 52454E                  		db 'REN'
 15512 00003DF8 01                      		db 1
 15513 00003DF9 [0212]                  		dw CRENAME
 15514 00003DFB 05                      		db 5
 15515 00003DFC 4552415345              		db 'ERASE'
 15516 00003E01 01                      		db 1
 15517 00003E02 [9911]                  		dw ERASE
 15518 00003E04 03                      		db 3
 15519 00003E05 44454C                  		db 'DEL'
 15520 00003E08 01                      		db 1
 15521 00003E09 [9911]                  		dw ERASE
 15522 00003E0B 04                      		db 4
 15523 00003E0C 54595045                		db 'TYPE'
 15524 00003E10 01                      		db 1
 15525 00003E11 [7612]                  		dw TYPEFIL
 15526 00003E13 03                      		db 3
 15527 00003E14 52454D                  		db 'REM'
 15528 00003E17 02                      		db 2
 15529 00003E18 [0401]                  		dw TCOMMAND
 15530 00003E1A 04                      		db 4
 15531 00003E1B 434F5059                		db 'COPY'
 15532 00003E1F 03                      		db 3
 15533 00003E20 [E529]                  		dw COPY
 15534 00003E22 05                      		db 5
 15535 00003E23 5041555345              		db 'PAUSE'
 15536 00003E28 02                      		db 2
 15537 00003E29 [8C11]                  		dw PAUSE
 15538 00003E2B 04                      		db 4
 15539 00003E2C 44415445                		db 'DATE'
 15540 00003E30 02                      		db 2
 15541 00003E31 [FC20]                  		dw DATE
 15542 00003E33 04                      		db 4
 15543 00003E34 54494D45                		db 'TIME'
 15544 00003E38 00                      		db 0
 15545 00003E39 [1322]                  		dw CTIME
 15546 00003E3B 03                      		db 3
 15547 00003E3C 564552                  		db 'VER'
 15548 00003E3F 00                      		db 0
 15549 00003E40 [6913]                  		dw VERSION
 15550 00003E42 03                      		db 3
 15551 00003E43 564F4C                  		db 'VOL'
 15552 00003E46 01                      		db 1
 15553 00003E47 [1313]                  		dw VOLUME
 15554 00003E49 02                      		db 2
 15555 00003E4A 4344                    		db 'CD'
 15556 00003E4C 01                      		db 1
 15557 00003E4D [A818]                  		dw _$CHDIR
 15558 00003E4F 05                      		db 5
 15559 00003E50 4348444952              		db 'CHDIR'
 15560 00003E55 01                      		db 1
 15561 00003E56 [A818]                  		dw _$CHDIR
 15562 00003E58 02                      		db 2
 15563 00003E59 4D44                    		db 'MD'
 15564 00003E5B 01                      		db 1
 15565 00003E5C [EB18]                  		dw _$MKDIR
 15566 00003E5E 05                      		db 5
 15567 00003E5F 4D4B444952              		db 'MKDIR'
 15568 00003E64 01                      		db 1
 15569 00003E65 [EB18]                  		dw _$MKDIR
 15570 00003E67 02                      		db 2
 15571 00003E68 5244                    		db 'RD'
 15572 00003E6A 01                      		db 1
 15573 00003E6B [2F19]                  		dw _$RMDIR
 15574 00003E6D 05                      		db 5
 15575 00003E6E 524D444952              		db 'RMDIR'
 15576 00003E73 01                      		db 1
 15577 00003E74 [2F19]                  		dw _$RMDIR
 15578 00003E76 05                      		db 5
 15579 00003E77 425245414B              		db 'BREAK'
 15580 00003E7C 00                      		db 0
 15581 00003E7D [C528]                  		dw CNTRLC
 15582 00003E7F 06                      		db 6
 15583 00003E80 564552494659            		db 'VERIFY'
 15584 00003E86 00                      		db 0
 15585 00003E87 [F728]                  		dw VERIFY
 15586 00003E89 03                      		db 3
 15587 00003E8A 534554                  		db 'SET'
 15588 00003E8D 02                      		db 2
 15589 00003E8E [9816]                  		dw ADD_NAME_TO_ENVIRONMENT
 15590 00003E90 06                      		db 6
 15591 00003E91 50524F4D5054            		db 'PROMPT'
 15592 00003E97 02                      		db 2
 15593 00003E98 [7E16]                  		dw ADD_PROMPT
 15594 00003E9A 04                      		db 4
 15595 00003E9B 50415448                		db 'PATH'
 15596 00003E9F 02                      		db 2
 15597 00003EA0 [8314]                  		dw PATH
 15598 00003EA2 04                      		db 4
 15599 00003EA3 45584954                		db 'EXIT'
 15600 00003EA7 00                      		db 0
 15601 00003EA8 [5016]                  		dw _$EXIT
 15602 00003EAA 04                      		db 4
 15603 00003EAB 43545459                		db 'CTTY'
 15604 00003EAF 03                      		db 3
 15605 00003EB0 [5D15]                  		dw CTTY
 15606 00003EB2 04                      		db 4
 15607 00003EB3 4543484F                		db 'ECHO'
 15608 00003EB7 02                      		db 2
 15609 00003EB8 [8228]                  		dw ECHO
 15610 00003EBA 04                      		db 4
 15611 00003EBB 474F544F                		db 'GOTO'
 15612 00003EBF 02                      		db 2
 15613 00003EC0 [EB0A]                  		dw GOTO
 15614 00003EC2 05                      		db 5
 15615 00003EC3 5348494654              		db 'SHIFT'
 15616 00003EC8 02                      		db 2
 15617 00003EC9 [700A]                  		dw SHIFT
 15618 00003ECB 02                      		db 2
 15619 00003ECC 4946                    		db 'IF'
 15620 00003ECE 02                      		db 2
 15621 00003ECF [2F09]                  		dw _$IF
 15622 00003ED1 03                      		db 3
 15623 00003ED2 464F52                  		db 'FOR'
 15624 00003ED5 02                      		db 2
 15625 00003ED6 [460D]                  		dw _$FOR
 15626 00003ED8 03                      		db 3
 15627 00003ED9 434C53                  		db 'CLS'
 15628 00003EDC 00                      		db 0
 15629 00003EDD [F214]                  		dw CLS
 15630 00003EDF 00                      		db 0
 15631                                  
 15632 00003EE0 41                      CAPITAL_A:	db 'A'
 15633 00003EE1 7C                      VBAR:		db '|'
 15634 00003EE2 3C                      LABRACKET:	db '<' ; 3Ch
 15635 00003EE3 3E                      RABRACKET:	db '>' ; 3Eh
 15636 00003EE4 24                      DOLLAR:		db '$'
 15637 00003EE5 28                      LPAREN:		db '('
 15638 00003EE6 29                      RPAREN:		db ')'
 15639 00003EE7 29                      NULLRPAREN:	db ')' ; 29h
 15640 00003EE8 00                      		db 0
 15641 00003EE9 494E                    IN_WORD:	db 'I','N'
 15642 00003EEB 444F                    DO_WORD	:	db 'D','O'
 15643 00003EED 2A                      STAR:		db '*'
 15644 00003EEE 2D                      CHAR_SUB:	db '-' 
 15645 00003EEF 2B                      PLUS_CHR:	db '+'
 15646 00003EF0 4C                      CHAR_L:		db 'L'
 15647 00003EF1 6C                      char_l:		db 'l'
 15648 00003EF2 61                      small_a:	db 'a'
 15649 00003EF3 7A                      small_z:	db 'z'
 15650 00003EF4 44                      CHAR_D:		db 'D'
 15651 00003EF5 43                      CHAR_C:		db 'C'
 15652 00003EF6 53                      CHAR_S:		db 'S'
 15653 00003EF7 58                      CHAR_X:		db 'X'
 15654 00003EF8 2E                      DOT_CHR:	db '.' 
 15655 00003EF9 3F2E                    DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15656 00003EFB 2C                      		db ','
 15657 00003EFC 3A2E                    TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15658 00003EFE 70                      MNCHR:		db 'p'
 15659 00003EFF 00                      SYSTEM_CPAGE:	db 0
 15660 00003F00 00                      		db 0
 15661                                  
 15662 00003F01 2E434F4D                COMEXT:		db '.COM'
 15663 00003F05 2E455845                EXEEXT:		db '.EXE'
 15664 00003F09 2E424154                BATEXT:		db '.BAT'
 15665 00003F0D 5642415057              SWITCH_LIST:	db 'VBAPW'
 15666 00003F12 2000                    BATBUFLEN:	dw BATLEN ; 32
 15667                                  
 15668                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15669                                  
 15670                                  TRANDATAEND:
 15671                                  
 15672                                  ;============================================================================
 15673                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15674                                  ;============================================================================
 15675                                  ; 29/09/2018 - Retro DOS v3.0
 15676                                  
 15677                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15678                                  
 15679                                  ;The TRANSPACE segment contains variable data that is considered
 15680                                  ;volatile between command cycles, and therefore is not included in the
 15681                                  ;transient checksum area. Contents of these variables MUST be
 15682                                  ;initialized before use, and must not be relied upon from command
 15683                                  ;cycle to command cycle.
 15684                                  ;
 15685                                  ;No constant data values should be stored here.
 15686                                  
 15687                                  ; ---------------------------------------------------------------------------
 15688                                  ; START OF UNITIALIZED DATA
 15689                                  ; ---------------------------------------------------------------------------	
 15690                                  
 15691                                  ;	times 12 db 0
 15692                                  
 15693 00003F14 90<rep Ch>              align 16
 15694                                  
 15695                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15696                                  
 15697 00003F20 00                      PRINTF_LEFT:	db 0
 15698 00003F21 00                      PRINTF_LONG:	db 0
 15699 00003F22 00                      PRINTF_HEX:	db 0
 15700 00003F23 00                      TABLE_INDEX:	db 0
 15701 00003F24 0000                    PRINTF_WIDTH:	dw 0
 15702 00003F26 0000                    PRINTF_BASE:	dw 0
 15703 00003F28 00                      PAD_CHAR:	db 0
 15704 00003F29 0000                    PRINTF_HANDLE:	dw 0
 15705 00003F2B 00<rep 64h>             PRINTF_BUF: times 100 db 0
 15706                                  PRINTF_BUF_END: ; 30/09/2018
 15707                                  
 15708                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15709                                  
 15710 00003F8F 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15711 00003FE6 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15712 0000403D 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15713 000040C0 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15714 00004143 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15715 00004189 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15716 0000420C 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15717                                  
 15718                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15719 0000425F 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15720 00004261 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15721 00004263 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15722 00004265 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15723 00004266 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15724 00004267 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15725                                  					; MYSEG1    (dw 0)	
 15726 0000426B 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15727                                  					; MYSEG2    (dw 0)	
 15728 0000426F 0000                    		dw 0			; RESTEST   (dw 0)	
 15729 00004271 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15730                                  
 15731 00004273 00                      CHKDRV:		db 0
 15732                                  IFNOTFLAG:
 15733                                  FILTYP:
 15734 00004274 00                      RDEOF:		db 0			; Misc flags
 15735 00004275 00                      CURDRV:		db 0
 15736                                  PARM1:
 15737 00004276 00                      CONCAT:		db 0
 15738                                  PARM2:
 15739 00004277 00                      ARGC:		db 0
 15740 00004278 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15741 0000427A 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15742                                  ARG2S:					; Switches after 2nd arg		
 15743 0000427C 0000                    DESTSWITCH:	dw 0
 15744                                  ARGTS:
 15745 0000427E 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15746 00004280 00                      CFLAG:		db 0
 15747                                  DESTCLOSED:
 15748 00004281 00                      SPECDRV:	db 0
 15749 00004282 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15750 00004284 0000                    NXTADD:		dw 0
 15751 00004286 00                      FRSTSRCH:	db 0
 15752                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15753                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15754 00004287 00                      LINCNT:		db 0
 15755 00004288 00                      LINLEN:		db 0
 15756                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15757 00004289 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15758                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15759                                  
 15760                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15761                                  ;
 15762                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15763                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15764                                  
 15765                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15766                                  
 15767 0000428B 00<rep 50h>             CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15768                                  DESTFCB2:
 15769 000042DB 00                      IDLEN:		db 0
 15770 000042DC 00<rep 8h>              ID:	  times	8  db 0
 15771 000042E4 00<rep 3h>              COM:	  times	3  db 0 
 15772 000042E7 00<rep 25h>             DEST:	  times 37 db 0
 15773 0000430C 00<rep Bh>              DESTNAME: times 11 db 0
 15774                                  DESTDIR:
 15775 00004317 00<rep 43h>             DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15776                                  GOTOLEN:	; word
 15777                                  BWDBUF: 	; byte
 15778                                  EXEFCB: 	; word
 15779 0000435A 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15780                                  
 15781                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15782                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15783                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15784                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15785                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15786                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15787                                  
 15788 000043A0 00<rep Ch>              SDIRBUF:  times 12 db 0	
 15789 000043AC 0000                    _BITS:		dw 0
 15790 000043AE 0000                    PATHCNT:	dw 0
 15791 000043B0 0000                    PATHPOS:	dw 0
 15792 000043B2 0000                    PATHSW:		dw 0
 15793                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15794                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15795 000043B4 00                      LINPERPAG:	db 0
 15796 000043B5 00                      		db 0
 15797 000043B6 00                      COMMA:		db 0			; flag set if +,, occurs
 15798 000043B7 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 15799                                  
 15800                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 15801                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 15802                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 15803                                  
 15804 000043B8 00<rep 80h>             ARG_BUF:  times 128 db 0   ; _43E8h	
 15805 00004438 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 15806 0000443A 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 15807 0000443C 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 15808 0000443E 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 15809                                  
 15810 00004440 0000                    COPY_NUM:	dw 0
 15811 00004442 00<rep 4h>              	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 15812 00004446 00                      CPYFLAG:	db 0
 15813 00004447 0000                    DIR_NUM:	dw 0
 15814 00004449 0000                    BYTES_FREE:	dw 0
 15815 0000444B 0000                    		dw 0
 15816 0000444D 0000                    MAJOR_VER_NUM:	dw 0
 15817 0000444F 0000                    MINOR_VER_NUM:	dw 0
 15818 00004451 00                      ONE_CHAR_VAL:	db 0
 15819                                  		;db 0
 15820 00004452 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 15821 00004454 00                      VOL_DRV:	db 0
 15822 00004455 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 15823                                  
 15824 00004457 00                      ROM_CALL:	db 0			; flag for rom function
 15825 00004458 0000                    ROM_IP:		dw 0
 15826 0000445A 0000                    ROM_CS:		dw 0
 15827                                  
 15828                                  DESTVARS:
 15829 0000445C 00                      DESTISDIR:	db 0
 15830 0000445D 00                      DESTSIZ:	db 0
 15831 0000445E 0000                    DESTTAIL:	dw 0
 15832 00004460 00                      DESTINFO:	db 0
 15833 00004461 00<rep 57h>             DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 15834                                  ENDDESTBUF:
 15835                                  
 15836 000044B8 0000                    DESTHAND:	dw 0
 15837 000044BA 00                      DESTISDEV:	db 0
 15838 000044BB 00                      FIRSTDEST:	db 0
 15839 000044BC 00                      MELCOPY:	db 0
 15840 000044BD 0000                    MELSTART:	dw 0
 15841                                  
 15842                                  SRCVARS:
 15843 000044BF 00                      SRCISDIR:	db 0
 15844 000044C0 00                      SRCSIZ:		db 0
 15845 000044C1 0000                    SRCTAIL:	dw 0
 15846 000044C3 00                      SRCINFO:	db 0
 15847 000044C4 00<rep 57h>             SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 15848                                  
 15849 0000451B 0000                    SRCHAND:	dw 0
 15850 0000451D 00                      SRCISDEV:	db 0
 15851                                  
 15852 0000451E 00<rep 57h>             SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 15853                                  
 15854 00004575 0000                    SRCPT:		dw 0
 15855 00004577 00                      INEXACT:	db 0
 15856 00004578 00                      		db 0 ; MSDOS 3.3 
 15857 00004579 00                      NOWRITE:	db 0
 15858 0000457A 00                      BINARY:		db 0
 15859 0000457B 0000                    WRITTEN:	dw 0
 15860 0000457D 00                      TERMREAD:	db 0
 15861 0000457E 00                      ASCII:		db 0
 15862 0000457F 00                      PLUS:		db 0
 15863 00004580 00                      OBJCNT:		db 0			; Used in copy
 15864 00004581 0000                    CPDATE:		dw 0
 15865 00004583 0000                    CPTIME:		dw 0
 15866                                  
 15867                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 15868                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 15869                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 15870                                  
 15871 00004585 0000                    BATHAND:	dw 0			; Batch handle
 15872 00004587 0000                    STARTEL:	dw 0
 15873 00004589 00                      ELCNT:		db 0
 15874 0000458A 00                      ELPOS:		db 0
 15875 0000458B 00<rep Bh>              SOURCE:   times	11 db 0
 15876                                  
 15877 00004596 00                      ext_entered:	db 0			;AN005;
 15878                                  
 15879                                  ;display_ioctl	db 0			;AN000; info level
 15880                                  ;		db 0			;AN000; reserved
 15881                                  ;		dw crt_ioctl_ln		;AN000; length of data
 15882                                  ;		dw 0			;AN000; control flags
 15883                                  ;display_mode:	db 0			;AN000; display mode, colors
 15884                                  ;		db 0			;AN000; reserved
 15885                                  ;		dw 0			;AN023; colors
 15886                                  ;		dw 0			;AN000; display width (PELS)
 15887                                  ;		dw 0			;AN000; display length (PELS)
 15888                                  ;display_width:	dw 0			;AN000; display width
 15889                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 15890                                  ;
 15891                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 15892                                  ;		dw 0			;AN000; info level
 15893                                  ;vol_serial:	dd 0			;AN000; volume serial number
 15894                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 15895                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 15896                                  
 15897 00004597 00                      EXPAND_STAR:	db 0
 15898                                  
 15899                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 15900                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 15901                                  ;append_exec:	db 0			;AN041; set if internal append executed
 15902                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 15903                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 15904                                  
 15905 00004598 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 15906                                  
 15907                                  ; Data declarations taken out of parse.asm
 15908                                  
 15909                                  ; MSDOS 6.0
 15910                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 15911                                  ;argbufptr	dw	?		; index for argv[].argpointer
 15912                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 15913                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 15914                                  ;comptr		dw	?		; ptr into combuf
 15915                                  
 15916                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 15917                                  ARG:
 15918                                  ARG_ARGV:
 15919 00004599 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 15920 0000459B 00                      ARGV0_ARG_FLAGS:  db 0
 15921 0000459C 0000                    ARGV0_ARGSTARTEL: dw 0
 15922 0000459E 0000                    ARGV0_ARGLEN:	  dw 0
 15923 000045A0 0000                    ARGV0_ARGSW_WORD: dw 0
 15924 000045A2 0000                    ARGV0_OCOMPTR:	  dw 0
 15925                                  
 15926 000045A4 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 15927 000045A6 00<rep 5h>              	  times 5 db 0
 15928 000045AB 0000                    ARGV1_ARGSW_WORD: dw 0
 15929 000045AD 0000                    		  dw 0
 15930                                  
 15931 000045AF 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 15932 000045B1 00<rep 5h>              	  times 5 db 0
 15933 000045B6 0000                    ARGV2_ARGSW_WORD: dw 0
 15934 000045B8 0000                    		  dw 0
 15935                                  
 15936 000045BA 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 15937                                  	
 15938 00004859 0000                    ARG_ARGVCNT:	dw 0
 15939 0000485B 0000                    ARG_ARGSWINFO:	dw 0
 15940                                  
 15941 0000485D 0000<rep 100h>          ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 15942 00004A5D 00<rep 80h>             ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 15943                                  
 15944                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 15945                                  
 15946 00004ADD 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 15947 00004ADF 00<rep 80h>             TPBUF:    times 128 db 0		; temporary buffer
 15948 00004B5F 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 15949 00004B61 0000                    COMPTR:		dw 0			; ptr into combuf
 15950                                  
 15951                                  ; Data declarations taken out of path.asm
 15952                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 15953                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 15954                                  ;psep_char	DB	?			; '/' or '\'
 15955                                  ;search_best	DB	(?)			; best code, best filename so far
 15956                                  ;fname_max_len	equ	13
 15957                                  ;search_best_buf DB	fname_max_len DUP (?)
 15958                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 15959                                  ;search_error	DW	(?)			; address of error message to be printed
 15960                                  
 15961                                  FINDBUFLEN equ FIND_BUF.size ; 43
 15962                                  
 15963                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 15964                                  
 15965 00004B63 00<rep 2Bh>             FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 15966                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 15967                                  PATHINFO:
 15968 00004B8E 0000                    PATHINFO_0:	dw 0
 15969 00004B90 0000                    PATHINFO_2:	dw 0
 15970 00004B92 0000                    PATHINFO_4:	dw 0
 15971 00004B94 00                      PSEP_CHAR:	db 0
 15972 00004B95 00                      SEARCH_BEST:	db 0
 15973                                  ;FNAME_MAX_LEN equ 13
 15974 00004B96 00<rep Dh>              SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 15975 00004BA3 00<rep 40h>             SEARCH_CURDIR_BUF: times 64 db 0
 15976 00004BE3 0000                    SEARCH_ERROR:	dw 0
 15977                                  
 15978                                  ; Data declarations taken out of tbatch.asm
 15979                                  
 15980                                  ;if_not_count	DW	?
 15981                                  ;
 15982                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 15983                                  ;
 15984                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 15985                                  ;STACK		LABEL	WORD
 15986                                  
 15987                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 15988                                  
 15989 00004BE5 0000                    IF_NOT_COUNT:	dw 0
 15990 00004BE7 00                      ZFLAG:		db 0
 15991 00004BE8 00<rep 100h>            	  times 256 db 0 	
 15992                                  STACK:
 15993                                  
 15994                                  ;INTERNATVARS	internat_block <>
 15995                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 15996                                  ;
 15997                                  ;;		Buffer for DOS function 64h (Get extended country information)
 15998                                  ;;		subfunctions 2, 4, 6, or 7:
 15999                                  ;
 16000                                  ;CountryPtrInfo	label	byte
 16001                                  ;CountryPtrId	db	?
 16002                                  ;CountryPtr	dd	?
 16003                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 16004                                  
 16005                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 16006                                  
 16007                                  INTERNATVARS:	
 16008 00004CE8 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 16009 00004CEA 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 16010 00004CEF 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 16011 00004CF1 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 16012 00004CF3 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 16013 00004CF5 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 16014 00004CF7 00                      BIT_FIELD:	db 0			; Bit values
 16015                                  					;   Bit 0 = 0 if currency symbol first
 16016                                  					;	  = 1 if currency symbol last
 16017                                  					;   Bit 1 = 0 if No space after currency symbol
 16018                                  					;	  = 1 if space after currency symbol
 16019 00004CF8 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16020 00004CF9 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16021 00004CFA 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16022                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16023                                  					;  in pieces.
 16024 00004CFE 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16025                                  
 16026 00004D00 00<rep 8h>              		times 8 db 0
 16027                                  ;
 16028                                  ; Max size of the block returned by the INTERNATIONAL call
 16029                                  ;
 16030                                  INTERNAT_BLOCK_SIZE EQU	32
 16031                                  
 16032                                  BATLEN equ 32
 16033                                  	
 16034                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16035                                  
 16036 00004D08 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16037                                  
 16038 00004D0A 00<rep 20h>             BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16039                                  
 16040 00004D2A 0000                    BATBUFEND:	dw 0
 16041                                  
 16042                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16043                                  
 16044                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
