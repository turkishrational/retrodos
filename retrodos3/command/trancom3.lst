     1                                  ; TRANSIENT PART OF COMMAND.COM
     2                                  ; ****************************************************************************
     3                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     4                                  ; ----------------------------------------------------------------------------
     5                                  ; Last Update: 24/02/2023 ((Prev: 20/10/2018))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.11  
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  
    44                                  ; ***************************************************************************
    45                                  ; *	This file is generated by The Interactive Disassembler (IDA)	    *
    46                                  ; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
    47                                  ; *			 Licensed to: Freeware version			    *
    48                                  ; ***************************************************************************
    49                                  ;
    50                                  ; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF
    51                                  
    52                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
    53                                  ; Format      :	Binary file
    54                                  ; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch
    55                                  
    56                                  ; ***************************************************************************
    57                                  
    58                                  ; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018
    59                                  
    60                                  ; ----------------------------------------------------------------------------
    61                                  ;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
    62                                  ; ----------------------------------------------------------------------------
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  RAW_CON_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  STD_CON_STRING_INPUT		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  SET_DEFAULT_DRIVE		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  DIR_SEARCH_FIRST		EQU 17	; 17	 11
    99                                  DIR_SEARCH_NEXT 		EQU 18	; 18	 12
   100                                  FCB_DELETE			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_RENAME			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  SET_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
   123                                  GET_DATE			EQU 42	; 42	 2A
   124                                  SET_DATE			EQU 43	; 43	 2B
   125                                  GET_TIME			EQU 44	; 44	 2C
   126                                  SET_TIME			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
   142                                  GET_DRIVE_FREESPACE		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  INTERNATIONAL			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDIR				EQU 57	; 57	 39
   147                                  RMDIR				EQU 58	; 58	 3A
   148                                  CHDIR				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  CREAT				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  WRITE				EQU 64	; 64	 40
   155                                  UNLINK				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  CURRENT_DIR			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  EXEC				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  FIND_FIRST			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  FIND_NEXT			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  DUP_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  FILE_TIMES			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GETEXTENDEDERROR		EQU 89	; 89	 59
   197                                  CREATETEMPFILE			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  XNAMETRANS			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GETSETCDPG			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 		; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   277                                  
   278                                  ;	NOTE:  These offsets are also used in the DTA for
   279                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   280                                  ;	with the FCB filename field, and the rest of the
   281                                  ;	DIR_ENTRY fields follow. -DavidOls
   282                                  
   283                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   284                                  ;
   285                                  ;	+---------------------------+
   286                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   287                                  ;	+---------------------------+
   288                                  ;	|     (BYTE) attributes     |	    11	    B
   289                                  ;	+---------------------------+
   290                                  ;	|    (10 BYTE) reserved     |	    12	    C
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) time of last write |	    22	    16
   293                                  ;	+---------------------------+
   294                                  ;	| (WORD) date of last write |	    24	    18
   295                                  ;	+---------------------------+
   296                                  ;	|   (WORD) First cluster    |	    26	    1A
   297                                  ;	+---------------------------+
   298                                  ;	|     (DWORD) file size     |	    28	    1C
   299                                  ;	+---------------------------+
   300                                  ;
   301                                  ;   First byte of filename  = E5 -> free directory entry
   302                                  ;			    = 00 -> end of allocated directory
   303                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   304                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   305                                  ;
   306                                  
   307                                  STRUC DIR_ENTRY
   308 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   309 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   310 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   311 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   312 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   313 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   314 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   315 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   316 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   317 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   318 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   319                                  .size:
   320                                  
   321                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   322                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   323                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   324                                  ;	    this field is zero for subdirectory files.
   325                                  
   326                                  ENDSTRUC
   327                                  
   328                                  ATTR_READ_ONLY	equ	 1h
   329                                  ATTR_HIDDEN	equ	 2h
   330                                  ATTR_SYSTEM	equ	 4h
   331                                  ATTR_VOLUME_ID	equ	 8h
   332                                  ATTR_DIRECTORY	equ	10h
   333                                  ATTR_ARCHIVE	equ	20h
   334                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   335                                  				;   NO directory entry on a disk EVER
   336                                  				;   has this bit set. It is set non-zero
   337                                  				;   when a device is found by GETPATH
   338                                  
   339                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   340                                  				; OR of hard attributes for FINDENTRY
   341                                  
   342                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   343                                  				; ignore this(ese) attribute(s) during
   344                                  				; search first/next
   345                                  
   346                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   347                                  				; changeable via CHMOD
   348                                  
   349                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   350                                  
   351                                  ;============================================================================
   352                                  ; ERROR.INC, MSDOS 6.0, 1991
   353                                  ;============================================================================
   354                                  ; 21/09/2018 - Retro DOS v3.0
   355                                  
   356                                  ;**	ERROR.INC - DOS Error Codes
   357                                  ;
   358                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   359                                  ;    return error codes through AX.	If an error occurred then
   360                                  ;    the carry bit will be set and the error code is in AX.	If no error
   361                                  ;    occurred then the carry bit is reset and AX contains returned info.
   362                                  ;
   363                                  ;    Since the set of error codes is being extended as we extend the operating
   364                                  ;    system, we have provided a means for applications to ask the system for a
   365                                  ;    recommended course of action when they receive an error.
   366                                  ;
   367                                  ;    The GetExtendedError system call returns a universal error, an error
   368                                  ;    location and a recommended course of action.	The universal error code is
   369                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   370                                  ;    is issued.
   371                                  
   372                                  
   373                                  ;	2.0 error codes
   374                                  
   375                                  error_invalid_function		EQU	1
   376                                  ERROR_FILE_NOT_FOUND		EQU	2
   377                                  error_path_not_found		EQU	3
   378                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   379                                  ERROR_ACCESS_DENIED		EQU	5
   380                                  error_invalid_handle		EQU	6
   381                                  error_arena_trashed		EQU	7
   382                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   383                                  error_invalid_block		EQU	9
   384                                  error_bad_environment		EQU	10
   385                                  ERROR_BAD_FORMAT		EQU	11
   386                                  error_invalid_access		EQU	12
   387                                  ERROR_INVALID_DATA		EQU	13
   388                                  ;**** reserved			EQU	14	; *****
   389                                  error_invalid_drive		EQU	15
   390                                  error_current_directory 	EQU	16
   391                                  error_not_same_device		EQU	17
   392                                  error_no_more_files		EQU	18
   393                                  
   394                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   395                                  
   396                                  ERROR_WRITE_PROTECT		EQU	19
   397                                  error_bad_unit			EQU	20
   398                                  error_not_ready 		EQU	21
   399                                  error_bad_command		EQU	22
   400                                  error_CRC			EQU	23
   401                                  error_bad_length		EQU	24
   402                                  error_Seek			EQU	25
   403                                  error_not_DOS_disk		EQU	26
   404                                  error_sector_not_found		EQU	27
   405                                  error_out_of_paper		EQU	28
   406                                  error_write_fault		EQU	29
   407                                  error_read_fault		EQU	30
   408                                  ERROR_GEN_FAILURE		EQU	31
   409                                  
   410                                  ;	the new 3.0 error codes reported through INT 24
   411                                  
   412                                  error_sharing_violation 	EQU	32
   413                                  error_lock_violation		EQU	33
   414                                  error_wrong_disk		EQU	34
   415                                  ERROR_FCB_UNAVAILABLE		EQU	35
   416                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   417                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   418                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   419                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   420                                  
   421                                  ;	New OEM network-related errors are 50-79
   422                                  
   423                                  error_not_supported		EQU	50
   424                                  
   425                                  error_net_access_denied		EQU	65	;M028
   426                                  
   427                                  ;	End of INT 24 reportable errors
   428                                  
   429                                  error_file_exists		EQU	80
   430                                  error_DUP_FCB			EQU	81	; *****
   431                                  error_cannot_make		EQU	82
   432                                  error_FAIL_I24			EQU	83
   433                                  
   434                                  ;	New 3.0 network related error codes
   435                                  
   436                                  error_out_of_structures 	EQU	84
   437                                  error_Already_assigned		EQU	85
   438                                  error_invalid_password		EQU	86
   439                                  error_invalid_parameter 	EQU	87
   440                                  error_NET_write_fault		EQU	88
   441                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   442                                  
   443                                  ;============================================================================
   444                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 22/09/2018 - Retro DOS v3.0
   447                                  
   448                                  ;**	DevSym.inc - Device Symbols
   449                                  
   450                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   451                                  
   452                                  STRUC SYSDEV
   453 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   454 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   455 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   456 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   457 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   458                                  .size:
   459                                  ENDSTRUC
   460                                  
   461                                  ; 24/09/2018
   462                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   463                                  
   464                                  ;============================================================================
   465                                  ; CURDIR.INC, MSDOS 6.0, 1991
   466                                  ;============================================================================
   467                                  ; 21/09/2018 - Retro DOS v3.0
   468                                  
   469                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   470                                  
   471                                  ;============================================================================
   472                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   473                                  ;============================================================================
   474                                  ; 21/09/2018 - Retro DOS v3.0
   475                                  
   476                                  ;/*
   477                                  ; *                      Microsoft Confidential
   478                                  ; *                      Copyright (C) Microsoft Corporation 1991
   479                                  ; *                      All Rights Reserved.
   480                                  ; */
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   483                                  ;*************************************
   484                                  ; COMMAND EQUs which are not switch dependant
   485                                  
   486                                  ;		include	curdir.inc	; to get DIRSTRLEN
   487                                  ;		Note dossym.inc must already have been included!
   488                                  
   489                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   490                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   491                                  
   492                                  SYM		EQU	">"
   493                                  
   494                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   495                                  
   496                                  NORMPERLIN	EQU	1
   497                                  WIDEPERLIN	EQU	5
   498                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   499                                  BatLen		EQU	32		; buffer for batch files
   500                                  YES_ECHO	EQU	1		; echo line
   501                                  NO_ECHO 	EQU	0		; don't echo line
   502                                  NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
   503                                  call_in_progress EQU	1		; indicate we're in the CALL command
   504                                  length_call	EQU	4		; length of CALL
   505                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   506                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   507                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   508                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   509                                  nullcommand	EQU    1		; no command on command line
   510                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   511                                  end_of_line_out EQU	0		;AN000; end of line for output
   512                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   513                                  result_number	EQU	1		;AN000; number returned from parser
   514                                  result_string	EQU	3		;AN000; string returned from parser
   515                                  result_filespec EQU	5		;AN000; filespec returned from parser
   516                                  result_drive	EQU	6		;AN000; drive returned from parser
   517                                  result_date	EQU	7		;AN000; date returned from parser
   518                                  result_time	EQU	8		;AN000; time returned from parser
   519                                  result_no_error EQU	0		;AN000; no error returned from parser
   520                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   521                                  util_msg_class	EQU	-1		;AN000; message class for utility
   522                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   523                                  parse_msg_class EQU	2		;AN000; message class for parse error
   524                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   525                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   526                                  colon_char	EQU	":"             ;AN000; colon character
   527                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   528                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   529                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   530                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   531                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   532                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   533                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   534                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   535                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   536                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   537                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   538                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   539                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   540                                  parm_block_size equ	11		;AN000; size of message subst block
   541                                  blank		equ	" "             ;AN000; blank character
   542                                  no_subst	equ	0		;AN000; no substitutions for messages
   543                                  one_subst	equ	1		;AN000; one substitution for messages
   544                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   545                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   546                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   547                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   548                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   549                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   550                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   551                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   552                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   553                                  capital_A	equ	'A'             ;AC000;
   554                                  vbar		equ	'|'             ;AC000;
   555                                  labracket	equ	'<'             ;AC000;
   556                                  rabracket	equ	'>'             ;AC000;
   557                                  dollar		equ	'$'             ;AC000;
   558                                  lparen		equ	'('             ;AC000;
   559                                  rparen		equ	')'             ;AC000;
   560                                  nullrparen	equ	29h		;AC000;
   561                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   562                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   563                                  star		equ	'*'             ;AC000;
   564                                  plus_chr	equ	'+'             ;AC000;
   565                                  ;small_a 	equ	'a'             ;AC000;
   566                                  ;small_z 	equ	'z'             ;AC000;
   567                                  dot_chr 	equ	'.'             ;AC000;
   568                                  tab_chr 	equ	9		;AN032;
   569                                  equal_chr	equ	'='             ;AN032;
   570                                  semicolon	equ	';'             ;AN049;
   571                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   572                                  dot_colon	equ	2e3ah		;AC000; '.:'
   573                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   574                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   575                                  AppendInstall	equ	0B700H		;AN020; append install check
   576                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   577                                  AppendGetState	equ	0B706H		;AN020; append get current state
   578                                  AppendSetState	equ	0B707H		;AN020; append set current state
   579                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   580                                  SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   581                                  
   582                                  ;*************************************
   583                                  ;* PARSE ERROR MESSAGES
   584                                  ;*************************************
   585                                  
   586                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   587                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   588                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   589                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   590                                  
   591                                  ;*************************************
   592                                  ;* EQUATES FOR MESSAGE RETRIEVER
   593                                  ;*************************************
   594                                  
   595                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   596                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   597                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   598                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   599                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   600                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   601                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   602                                  
   603                                  ;*********************************
   604                                  ;* EQUATES FOR INT 10H
   605                                  ;*********************************
   606                                  
   607                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   608                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   609                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   610                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   611                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   612                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   613                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   614                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   615                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   616                                  
   617                                  ALTPIPECHR	equ	"|"             ; alternate pipe character
   618                                  
   619                                  FCB		EQU	5CH
   620                                  
   621                                  STRUC VARSTRUC
   622 00000000 ??                      .ISDIR:		RESB	1
   623 00000001 ??                      .SIZ:		RESB	1
   624 00000002 ????                    .TTAIL:		RESW	1
   625 00000004 ??                      .INFO:		RESB	1
   626 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   627                                  .size:
   628                                  ENDSTRUC
   629                                  ;
   630                                  ; Flags for internal command parsing
   631                                  ;
   632                                  FCHECKDRIVE	equ	00000001b	; validate drive letter
   633                                  FSWITCHALLOWED	equ	00000010b	; switches allowed
   634                                  FLIMITHELP	equ	00000100b	; /? must appear alone
   635                                  
   636                                  ;
   637                                  ; Test switches
   638                                  ;
   639                                  fParse		EQU	0001h		; display results of parseline
   640                                  
   641                                  ;
   642                                  ; Batch segment structure
   643                                  ;
   644                                  ;   BYTE    type of segment
   645                                  ;   BYTE    echo state of parent on entry to batch file
   646                                  ;   WORD    segment of last batch file
   647                                  ;   WORD    segment for FOR command
   648                                  ;   BYTE    FOR flag state on entry to batch file
   649                                  ;   DWORD   offset for next line
   650                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   651                                  ;   ASCIZ   file name (with . and ..)
   652                                  ;   BYTES   CR-terminated parameters
   653                                  ;   BYTE    0 flag to indicate end of parameters
   654                                  ;
   655                                  
   656                                  BATCHTYPE   equ 0
   657                                  
   658                                  STRUC BATCHSEGMENT
   659 00000000 ??                      .BatType:	RESB	1		; signature
   660 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   661                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  tplen		equ	64		; max size of one argument
   675                                  arg_cnt_error	equ	1		; number of args > MAXARG
   676                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   677                                  
   678                                  STRUC ARGV_ELE				; elements in the argv array
   679 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   680 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   681 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   682 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   683 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   684 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   685                                  .SIZE:
   686                                  ENDSTRUC
   687                                  
   688                                  STRUC ARG_UNIT
   689 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   690 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   691 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   692 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   693 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   694                                  .SIZE:
   695                                  ENDSTRUC
   696                                  
   697                                  ; Parse flags - 13/10/2018
   698                                  special_delim	equ	128
   699                                  path_sep 	equ	4
   700                                  wildcard 	equ	2
   701                                  sw_flag		equ	1
   702                                  
   703                                  SWITCHQUES 	EQU	20h
   704                                  SWITCHV 	EQU	10h
   705                                  SWITCHB 	EQU	08h
   706                                  SWITCHA 	EQU	04h
   707                                  SWITCHP 	EQU	02h
   708                                  SWITCHW 	EQU	01h
   709                                  FSWITCH 	EQU	8000h
   710                                  FBADSWITCH	EQU	4000h
   711                                  
   712                                  SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
   713                                  SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
   714                                  ; 13/10/2018
   715                                  ;SWITCHCOPY	EQU	801Ch
   716                                  NOT_SWITCHCOPY	EQU	7FE3h
   717                                  
   718                                  ; Equates for initialization
   719                                  ;
   720                                  INITINIT	equ	01h		; initialization in progress
   721                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   722                                  INITCTRLC	equ	04h		; already in ^C handler
   723                                  
   724                                  ;============================================================================
   725                                  ; FIND.INC (MSDOS 3.3, 1987)
   726                                  ;============================================================================
   727                                  ; 13/10/2018 - Retro DOS v3.0
   728                                  
   729                                  ;Break	<find first/next buffer>
   730                                  
   731                                  	; MSDOS 3.3 & MSDOS 6.0
   732                                  
   733                                  struc FIND_BUF
   734 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   735 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   736 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   737 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   738 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   739 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   740 00000015 ??                      .ATTR:	    resb 1	; attribute found
   741 00000016 ????                    .TIMR:	    resw 1	; time
   742 00000018 ????                    .DATE:	    resw 1	; date
   743 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   744 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   745 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   746                                  .size:
   747                                  endstruc
   748                                  
   749                                  ;=============================================================================
   750                                  ; PDB.INC, MSDOS 6.0, 1991
   751                                  ;=============================================================================
   752                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   753                                  
   754                                  ;**	Process data block (otherwise known as program header)
   755                                  
   756                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   757                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   758                                  ;	for use.
   759                                  
   760                                  FILPERPROC	EQU     20
   761                                  
   762                                  struc PDB	; Process_data_block
   763 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   764 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   765 00000004 ??                                      resb 1
   766 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   767 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   768 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   769 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   770 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   771 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   772 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   773 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   774 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   775 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   776 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   777 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   778 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   779 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   780 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   781 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   782 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   783 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   784                                  				;  an extended FCB
   785                                  ;endstruc 	; MSDOS 3.3
   786                                  	  	; MSDOS 6.0
   787 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   788 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   789 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   790 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   791                                  endstruc
   792                                  
   793                                  ;============================================================================
   794                                  ; SF.INC, MSDOS 6.0, 1991
   795                                  ;============================================================================
   796                                  ; 13/10/2018 - Retro DOS v3.0
   797                                  
   798                                  ; structure of devid field as returned by IOCTL is:
   799                                  ;
   800                                  ;	BIT	7   6	5   4	3   2	1   0
   801                                  ;	      |---|---|---|---|---|---|---|---|
   802                                  ;	      | I | E | R | S | I | I | I | I |
   803                                  ;	      | S | O | A | P | S | S | S | S |
   804                                  ;	      | D | F | W | E | C | N | C | C |
   805                                  ;	      | E |   |   | C | L | U | O | I |
   806                                  ;	      | V |   |   | L | K | L | T | N |
   807                                  ;	      |---|---|---|---|---|---|---|---|
   808                                  ;	ISDEV = 1 if this channel is a device
   809                                  ;	      = 0 if this channel is a disk file
   810                                  ;
   811                                  ;	If ISDEV = 1
   812                                  ;
   813                                  ;	      EOF = 0 if End Of File on input
   814                                  ;	      RAW = 1 if this device is in Raw mode
   815                                  ;		  = 0 if this device is cooked
   816                                  ;	      ISCLK = 1 if this device is the clock device
   817                                  ;	      ISNUL = 1 if this device is the null device
   818                                  ;	      ISCOT = 1 if this device is the console output
   819                                  ;	      ISCIN = 1 if this device is the console input
   820                                  ;
   821                                  ;	If ISDEV = 0
   822                                  ;	      EOF = 0 if channel has been written
   823                                  ;	      Bits 0-5	are  the  block  device  number  for
   824                                  ;		  the channel (0 = A, 1 = B, ...)
   825                                  
   826                                  devid_ISDEV	EQU	80h
   827                                  devid_EOF	EQU	40h
   828                                  devid_RAW	EQU	20h
   829                                  devid_SPECIAL	EQU	10H
   830                                  devid_ISCLK	EQU	08h
   831                                  devid_ISNUL	EQU	04h
   832                                  devid_ISCOT	EQU	02h
   833                                  devid_ISCIN	EQU	01h
   834                                  
   835                                  devid_block_dev EQU	1Fh		; mask for block device number
   836                                  
   837                                  ;============================================================================
   838                                  ; INTNAT.INC, MSDOS 3.3, 1987
   839                                  ;============================================================================
   840                                  ; 09/07/2018 - Retro DOS 3.0
   841                                  
   842                                  ; Current structure of the data returned by the international call
   843                                  
   844                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   845 00000000 ????                    .Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
   846 00000002 ??????????              .Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
   847 00000007 ????                    .Thous_sep:	  RESB 2	; Thousands separator 2 bytes
   848 00000009 ????                    .Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
   849 0000000B ????                    .Date_sep:	  RESB 2	; Date separator 2 bytes
   850 0000000D ????                    .Time_sep:	  RESB 2	; Time separator 2 bytes
   851 0000000F ??                      .Bit_field:	  RESB 1	; Bit values
   852                                                                  ;   Bit 0 = 0 if currency symbol first
   853                                                                  ;         = 1 if currency symbol last
   854                                                                  ;   Bit 1 = 0 if No space after currency symbol
   855                                                                  ;         = 1 if space after currency symbol
   856 00000010 ??                      .Currency_cents:  RESB 	1	; Number of places after currency dec point
   857 00000011 ??                      .Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
   858 00000012 ????                    .Map_call:	  RESW	1	; Address of case mapping call (DWORD)
   859 00000014 ????                                      RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   860                                  				;  in pieces.
   861 00000016 ????                    .Data_sep:	  RESB	2	; Data list separator character
   862                                  .size:		
   863                                  endstruc
   864                                  
   865                                  ;
   866                                  ; Max size of the block returned by the INTERNATIONAL call
   867                                  ;
   868                                  internat_block_max	EQU	32
   869                                  
   870                                  ;============================================================================
   871                                  ; VECTOR.INC, MSDOS 3.3, 1987
   872                                  ;============================================================================
   873                                  ; 13/10/2018 - Retro DOS 3.0
   874                                  
   875                                  ;BREAK <interrupt definitions>	
   876                                  
   877                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   878                                  
   879                                  INTTAB		EQU	20H
   880                                  INTBASE 	EQU	4 * INTTAB
   881                                  ENTRYPOINT	EQU	INTBASE+40H
   882                                  
   883                                  ;
   884                                  ; interrupt assignments
   885                                  ;
   886                                  
   887                                  INT_ABORT	    EQU     INTTAB	; abort process
   888                                  INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
   889                                  INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
   890                                  INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
   891                                  INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
   892                                  INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
   893                                  INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
   894                                  INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
   895                                  					; resident
   896                                  INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
   897                                  INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
   898                                  ; MSDOS 3.3 (& MSDOS 6.0)
   899                                  INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance
   900                                  
   901                                  ;============================================================================
   902                                  ; ARENA.INC, MSDOS 3.3, 1987
   903                                  ;============================================================================
   904                                  ; 13/10/2018 - Retro DOS 3.0
   905                                  
   906                                  ;BREAK <Memory arena structure>
   907                                  
   908                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   909                                  
   910                                  ;
   911                                  ; arena item
   912                                  ;
   913                                  
   914                                  struc ARENA
   915 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
   916 00000001 ????                      .owner:	resw 1		; owner of arena item
   917 00000003 ????                      .size:	resw 1		; size in paragraphs of item
   918                                  endstruc
   919                                  
   920                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
   921                                  ; and arena_owner_system are all equal to zero and are contained in DI.
   922                                  ; Change them and change ALLOC.ASM.
   923                                  
   924                                  arena_owner_system  EQU 0		; free block indication
   925                                  
   926                                  arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
   927                                  arena_signature_end	EQU 5Ah 	; valid signature, last block in arena
   928                                  
   929                                  ;============================================================================
   930                                  ; FILEMODE.INC, MSDOS 3.3, 1987
   931                                  ;============================================================================
   932                                  ; 21/09/2018 - Retro DOS v3.0
   933                                  
   934                                  ;BREAK <FILEMODE.INC - Misc. File API Values>
   935                                  
   936                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
   937                                  
   938                                  ;**	Standard I/O file handles
   939                                  ;
   940                                  
   941                                  STDIN	equ	0
   942                                  STDOUT	equ	1
   943                                  STDERR	equ	2
   944                                  STDAUX	equ	3
   945                                  STDPRN	equ	4
   946                                  
   947                                  ;**	File Modes
   948                                  
   949                                  ACCESS_MASK	    equ 0Fh
   950                                  OPEN_FOR_READ	    equ 00h
   951                                  OPEN_FOR_WRITE	    equ 01h
   952                                  OPEN_FOR_BOTH	    equ 02h
   953                                  EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
   954                                  				; made from exec
   955                                  
   956                                  ;=============================================================================
   957                                  ; COMMAND.COM Resident Portion Addresses - 13/10/2018
   958                                  ;=============================================================================
   959                                  
   960                                  ; Transient portion loader code offset in resident code segment
   961                                  LODCOM1	   equ	0318h	; 13/10/2018
   962                                  
   963                                  ; EXEC call adressses in resident portion for calling from transient portion
   964                                  EXEC_WAIT  equ 	0131h	; 13/10/2018
   965                                  
   966                                  ; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
   967                                  PUTBACKDRV equ  0A21h	; 14/10/2018
   968                                  
   969                                  ; Note: Following offset addresses are in data section of 'command3.s' file.
   970                                  ; They must be verified by using assembly list (command3.lst) of COMMAND.COM.
   971                                  
   972                                  ; Resident portion stack address  
   973                                  RSTACK	   equ  083Ch
   974                                  
   975                                  RETRABASE  equ  0B86h ; 13/10/2018 (Base address for following common params.)	
   976                                  
   977                                  ; RESGROUP       [RESSEG]
   978                                  ; DATA		  offset
   979                                  ; --------     	------------
   980                                  PARENT	  equ	RETRABASE+6	; 0B8Ch
   981                                  OLDTERM	  equ	RETRABASE+8	; 0B9Eh
   982                                  BATCH	  equ	RETRABASE+17	; 0B97h
   983                                  COMSPEC	  equ	RETRABASE+19	; 0B99h
   984                                  PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD9h
   985                                  COMSPEC_END equ	RETRABASE+85	; 0BDBh
   986                                  IN_BATCH  equ	RETRABASE+92	; 0BE2h
   987                                  BATCH_ABORT equ	RETRABASE+93	; 0BE3h
   988                                  COMDRV	  equ	RETRABASE+94	; 0BE4h
   989                                  EXTCOM	  equ	RETRABASE+99	; 0BE9h
   990                                  RETCODE	  equ	RETRABASE+100	; 0BEAh
   991                                  ECHOFLAG  equ	RETRABASE+103	; 0BEDh
   992                                  SUPPRESS  equ	RETRABASE+104	; 0BEEh
   993                                  IO_SAVE	  equ	RETRABASE+105	; 0BEFh
   994                                  RESTDIR	  equ	RETRABASE+107	; 0BF1h
   995                                  PERMCOM	  equ	RETRABASE+108	; 0BF2h
   996                                  SINGLECOM equ	RETRABASE+109	; 0BF3h
   997                                  VERVAL	  equ	RETRABASE+111	; 0BF5h
   998                                  IFFLAG	  equ	RETRABASE+114	; 0BF8h	
   999                                  FORFLAG	  equ	RETRABASE+115	; 0BF9h
  1000                                  FORPTR	  equ	RETRABASE+116	; 0BFAh 	
  1001                                  NEST	  equ	RETRABASE+118	; 0BFCh
  1002                                  CALL_FLAG equ	RETRABASE+120	; 0BFEh
  1003                                  CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFFh
  1004                                  NEXT_BATCH equ	RETRABASE+122 	; 0C00h
  1005                                  NULLFLAG  equ	RETRABASE+124	; 0C02h
  1006                                  UPPERCASETBL equ RETRABASE+126	; 0C04h
  1007                                  RE_OUT_APP equ	RETRABASE+130	; 0C08h
  1008                                  RE_OUTSTR equ	RETRABASE+131	; 0C09h
  1009                                  INITFLAG  equ	RETRABASE+211	; 0C59h	
  1010                                  PIPEFLAG  equ	RETRABASE+212	; 0C5Ah
  1011                                  PIPEFILES equ	RETRABASE+213	; 0C5Bh
  1012                                  PIPE1	  equ	RETRABASE+214	; 0C5Ch	
  1013                                  PIPE2	  equ	RETRABASE+230	; 0C6Ch
  1014                                  PIPEPTR	  equ	RETRABASE+246	; 0C7Ch
  1015                                  PIPESTR	  equ	RETRABASE+248	; 0C7Eh
  1016                                  INPIPEPTR equ	RETRABASE+377	; 0CFFh
  1017                                  OUTPIPEPTR equ	RETRABASE+379	; 0D01h
  1018                                  ENVIRSEG  equ	RETRABASE+381	; 0D03h
  1019                                  EXEC_BLOCK equ	RETRABASE+381 	; 0D03h  ; ENVIRSEG
  1020                                  LTPA	  equ	RETRABASE+399	; 0D15h
  1021                                  RES_TPA	  equ	RETRABASE+413	; 0D23h
  1022                                  
  1023                                  ;=============================================================================
  1024                                  					
  1025                                  ; (command3.s -> offset TRANGOUP)
  1026                                  
  1027                                  TRANGROUP:
  1028                                  
  1029                                  ; ----------------------------------------------------------------------------
  1030                                  ; START OF TRANSIENT PORTION
  1031                                  ; ----------------------------------------------------------------------------
  1032                                  ; SEGMENT - TRANSCODE
  1033                                  ; ----------------------------------------------------------------------------
  1034                                  ; 13/10/2018 - Retro DOS v3.0
  1035                                  
  1036                                  ;[BITS 16]
  1037                                  ;[ORG 0]
  1038 00000000 00<rep 100h>            		times 256 db 0
  1039                                  
  1040                                  ;============================================================================
  1041                                  ; TCODE.ASM, MSDOS 6.0, 1991
  1042                                  ;============================================================================
  1043                                  ; 12/10/2018 - Retro DOS v3.0
  1044                                  
  1045                                  ;[ORG 100h]
  1046                                  
  1047                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  1048                                  
  1049                                  ; ---------------------------------------------------------------------------
  1050                                  
  1051                                  SETDRV:					; Allow for 100H parameter area
  1052 00000100 B40E                    		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  1053 00000102 CD21                    		int	21h	; DOS -	SELECT DISK
  1054                                  				; DL = new default drive number	(0 = A,	1 = B,etc.)
  1055                                  				; Return: AL = number of logical drives
  1056                                  
  1057                                  ; ---------------------------------------------------------------------------
  1058                                  
  1059                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  1060                                  ; No registers (CS:IP) no flags, nothing.
  1061                                  
  1062                                  TCOMMAND:
  1063 00000104 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  1064 00000109 B8FFFF                  		mov	ax,-1
  1065 0000010C 8706F50B                		xchg	ax,word [VERVAL]
  1066 00000110 83F8FF                  		cmp	ax,-1
  1067 00000113 7404                    		jz	short NOSETVER2
  1068 00000115 B42E                    		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  1069 00000117 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
  1070                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  1071                                  NOSETVER2:
  1072 00000119 2EFF1E[6F42]            		call	far [cs:HEADCALL]   ; Make sure header fixed
  1073 0000011E 31ED                    		xor	bp,bp		    ; Flag transient not read
  1074 00000120 833EF30BFF              		cmp	word [SINGLECOM],-1
  1075 00000125 7505                    		jnz	short COMMAND
  1076                                  _$EXITPREP:
  1077 00000127 0E                      		push	cs
  1078 00000128 1F                      		pop	ds
  1079 00000129 E92415                  		jmp	_$EXIT		; Have finished the single command
  1080                                  
  1081                                  ; ---------------------------------------------------------------------------
  1082                                  ;
  1083                                  ; Main entry point from resident portion.
  1084                                  ;
  1085                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  1086                                  ;   just beginning the processing of another command.
  1087                                  ;
  1088                                  ; ---------------------------------------------------------------------------
  1089                                  
  1090                                  ; We are not always sure of the state of the world at this time. We presume
  1091                                  ; worst case and initialize the relevant registers: segments and stack.
  1092                                  
  1093                                  COMMAND:
  1094 0000012C FC                      		cld
  1095 0000012D 8CC8                    		mov	ax,cs
  1096 0000012F FA                      		cli
  1097 00000130 8ED0                    		mov	ss,ax
  1098                                  		;MOV	SP,OFFSET TRANGROUP:STACK
  1099 00000132 BC[F84C]                		mov	sp,STACK
  1100 00000135 FB                      		sti
  1101                                  		
  1102 00000136 8EC0                    		MOV	ES,AX
  1103                                  		
  1104                                  		; MSDOS 6.0
  1105                                  		;MOV	DS,AX		;AN000; set DS to transient
  1106                                  		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  1107                                  		;invoke	TSYSLOADMSG	;AN000; preload messages
  1108                                  		;mov	append_exec,0	;AN041; set internal append state off
  1109                                  
  1110                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1111 00000138 368E1E[7142]            		mov	ds,[ss:RESSEG]
  1112 0000013D 36C606[4D40]80          		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  1113 00000143 36C606[D040]80          		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  1114                                  
  1115                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  1116                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  1117                                  ; I guess not:  the only circumstances in which we reload the command processor
  1118                                  ; is after a transient program execution. In this case, we let the current
  1119                                  ; directory lie where it may.
  1120                                  
  1121 00000149 09ED                    		or	bp,bp		; See if just read
  1122 0000014B 7409                    		jz	short TESTRDIR	; Not read, check user directory
  1123 0000014D 36C706[4E40]010D        		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  1124 00000154 EB17                    		jmp	short NOSETBUF
  1125                                  TESTRDIR:
  1126 00000156 803EF10B00              		cmp	byte [RESTDIR],0
  1127 0000015B 7410                    		jz	short NOSETBUF	; User directory OK
  1128 0000015D 1E                      		push	ds
  1129                                  
  1130                                  ; We have an unusual situation to handle. The user *may* have changed his
  1131                                  ; directory as a result of an internal command that got aborted. Restoring it
  1132                                  ; twice may not help us: the problem may never go away. We just attempt it
  1133                                  ; once and give up.
  1134                                  
  1135 0000015E C606F10B00              		mov	byte [RESTDIR],0 ; Flag users dirs OK
  1136                                  
  1137                                  		; Restore users directory
  1138 00000163 0E                      		push	cs
  1139 00000164 1F                      		pop	ds
  1140 00000165 BA[5341]                		mov	dx,USERDIR1
  1141 00000168 B43B                    		mov	ah,CHDIR ; 3Bh
  1142 0000016A CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  1143                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  1144 0000016C 1F                      		pop	ds
  1145                                  NOSETBUF:
  1146 0000016D 803E5B0C00              		cmp	byte [PIPEFILES],0
  1147 00000172 740A                    		jz	short NOPCLOSE	; Don't bother if they don't exist
  1148 00000174 803E5A0C00              		cmp	byte [PIPEFLAG],0
  1149 00000179 7503                    		jnz	short NOPCLOSE	; Don't del if still piping
  1150 0000017B E8981D                  		call	PIPEDEL
  1151                                  NOPCLOSE:
  1152                                  		;mov	byte [0BE9h],0	; MSDOS 3.3
  1153 0000017E C606E90B00              		mov	byte [EXTCOM],0 ; Flag internal command
  1154 00000183 8CC8                    		mov	ax,cs		; Get segment we're in
  1155 00000185 8ED8                    		mov	ds,ax
  1156 00000187 50                      		push	ax
  1157 00000188 BA[F84C]                		mov	dx,INTERNATVARS
  1158 0000018B B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  1159 0000018E CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  1160                                  				; get current-country info
  1161                                  				; DS:DX	-> buffer for returned info
  1162 00000190 58                      		pop	ax
  1163 00000191 2B06[7342]              		sub	ax,[TPA]	; AX=size of TPA in paragraphs
  1164 00000195 53                      		push	bx
  1165 00000196 BB1000                  		mov	bx,16
  1166 00000199 F7E3                    		mul	bx		; DX:AX=size of TPA in bytes
  1167 0000019B 5B                      		pop	bx
  1168 0000019C 09D2                    		or	dx,dx		; See if over 64K
  1169 0000019E 7403                    		jz	short SAVSIZ	; OK if not
  1170 000001A0 B8FFFF                  		mov	ax,-1		; If so, limit to 65535 bytes
  1171                                  SAVSIZ:
  1172                                  
  1173                                  ; AX is the number of bytes free in the buffer between the resident and the
  1174                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  1175                                  
  1176 000001A3 3D0002                  		cmp	ax,512
  1177 000001A6 7603                    		jbe	short GOTSIZE
  1178                                  		;and	ax,~1FFh
  1179 000001A8 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FF
  1180                                  GOTSIZE:
  1181 000001AB A3[9242]                		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  1182 000001AE 8E1E[7142]              		mov	ds,[RESSEG]	; All batch work must use resident seg.
  1183                                  
  1184 000001B2 F606ED0B01              		test	byte [ECHOFLAG],1 
  1185 000001B7 741E                    		jz	short GETCOM	; Don't do the CRLF
  1186 000001B9 E8391D                  		call	SINGLETEST
  1187 000001BC 7219                    		jb	short GETCOM
  1188 000001BE F6065A0CFF              		test	byte [PIPEFLAG],0FFh ; -1
  1189 000001C3 7512                    		jnz	short GETCOM
  1190                                  					; G  Don't print prompt in FOR
  1191 000001C5 F606F90BFF              		test	byte [FORFLAG],0FFh ; -1
  1192 000001CA 750B                    		jnz	short GETCOM
  1193                                  					; G  Don't print prompt if in batch
  1194 000001CC F706970BFFFF            		test	word [BATCH],0FFFFh ; -1
  1195 000001D2 7503                    		jnz	short GETCOM
  1196 000001D4 E89517                  		call	CRLF2
  1197                                  GETCOM:
  1198 000001D7 C606FE0B00              		mov	byte [CALL_FLAG],0 ; G Reset call flags
  1199 000001DC C606FF0B00              		mov	byte [CALL_BATCH_FLAG],0
  1200 000001E1 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  1201 000001E3 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  1202 000001E5 36A2[8542]              		mov	[ss:CURDRV],al
  1203 000001E9 F6065A0CFF              		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
  1204 000001EE 7403                    		jz	short NOPIPE
  1205 000001F0 E9C51D                  		jmp	PIPEPROC	; Continue the pipeline
  1206                                  NOPIPE:
  1207 000001F3 F606ED0B01              		test	byte [ECHOFLAG],1
  1208 000001F8 7417                    		jz	short NOPDRV	; No prompt if echo off
  1209 000001FA E8F81C                  		call	SINGLETEST
  1210 000001FD 7212                    		jb	short NOPDRV
  1211 000001FF F606F90BFF              		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
  1212 00000204 750B                    		jnz	short NOPDRV
  1213 00000206 F706970BFFFF            		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
  1214 0000020C 750D                    		jnz	short TESTFORBAT
  1215 0000020E E87911                  		call	PRINT_PROMPT	; Prompt the user
  1216                                  NOPDRV:
  1217 00000211 F606F90BFF              		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
  1218 00000216 7403                    		jz	short TESTFORBAT
  1219 00000218 E9FE09                  		jmp	FORPROC		; Continue the FOR
  1220                                  
  1221                                  TESTFORBAT:
  1222 0000021B 36C606[1C42]00          		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  1223 00000221 C606090C00              		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
  1224 00000226 C606080C00              		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
  1225 0000022B C606F80B00              		mov	byte [IFFLAG],0	; no more ifs...
  1226 00000230 F706970BFFFF            		test	word [BATCH],0FFFFh ; Batch has lowest precedence
  1227 00000236 7429                    		jz	short ISNOBAT
  1228                                  
  1229                                  		; MSDOS 6.0
  1230                                  
  1231                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  1232                                  
  1233                                  		;push	es			;AN000; save ES
  1234                                  		;push	ds			;AN000; save DS
  1235                                  		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  1236                                  		;mov	es,[batch]		;AN000; get batch segment
  1237                                  		;mov	di,batfile		;AN000; get batch file name
  1238                                  		;push	cs			;AN000; get local segment to DS
  1239                                  		;pop	ds			;AN000;
  1240                                  		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  1241                                  		;int	2fh			;AN000; call the shell
  1242                                  		;cmp	al,shell_action 	;AN000; does shell have a commmand?
  1243                                  		;pop	ds			;AN000; restore DS
  1244                                  		;pop	es			;AN000; restore ES
  1245                                  		;jz	jdocom1 		;AN000; yes - go process command
  1246                                  
  1247                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1248 00000238 1E                      		push	ds
  1249 00000239 E8BC02                  		call	READBAT			; Continue BATCH
  1250 0000023C 1F                      		pop	ds
  1251 0000023D C606020C00              		mov	byte [NULLFLAG],0	;G reset no command flag
  1252 00000242 F706970BFFFF            		test	word [BATCH],0FFFFh
  1253 00000248 7513                    		jnz	short JDOCOM1		;G if batch still in progress continue
  1254 0000024A 8B1E000C                		mov	bx,word [NEXT_BATCH]
  1255 0000024E 83FB00                  		cmp	bx,0			;G see if there is a new batch file
  1256 00000251 740A                    		jz	short JDOCOM1		;G no - go do command
  1257 00000253 891E970B                		mov	word [BATCH],bx		;G get segment of next batch file
  1258 00000257 C706000C0000            		mov	word [NEXT_BATCH],0	;G reset next batch
  1259                                  JDOCOM1:
  1260 0000025D 0E                      		push	cs
  1261 0000025E 1F                      		pop	ds
  1262 0000025F EB4C                    		jmp	short DOCOM1
  1263                                  
  1264 00000261 833EF30B00              ISNOBAT:	cmp	word [SINGLECOM],0
  1265 00000266 741C                    		jz	short REGCOM
  1266                                  		;MOV	SI,[SEMIPERMCOM] ;  MSDOS 6.0
  1267 00000268 BEFFFF                  		mov	si,0FFFFh 	 ;  MSDOS 3.3
  1268 0000026B 8736F30B                		xchg	si,word [SINGLECOM]
  1269 0000026F BF[D240]                		mov	di,COMBUF+2
  1270 00000272 31C9                    		xor	cx,cx
  1271                                  SINGLELOOP:
  1272 00000274 AC                      		lodsb
  1273 00000275 AA                      		stosb
  1274 00000276 41                      		inc	cx
  1275 00000277 3C0D                    		cmp	al,0Dh
  1276 00000279 75F9                    		jnz	short SINGLELOOP
  1277 0000027B 49                      		dec	cx
  1278 0000027C 0E                      		push	cs
  1279 0000027D 1F                      		pop	ds
  1280 0000027E 880E[D140]              		mov	[COMBUF+1],cl
  1281                                  
  1282                                  ; do NOT issue a trailing CRLF...
  1283                                  
  1284 00000282 EB29                    		jmp	short DOCOM1
  1285                                  
  1286                                  		;nop
  1287                                  
  1288                                  ; We have a normal command.  
  1289                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  1290                                  ; sometimes they aren't. At this point, we automatically close all spool
  1291                                  ; files and turn on truncation mode.
  1292                                  
  1293                                  REGCOM:
  1294                                  		;MOV	AX,(ServerCall SHL 8) + 9
  1295                                  		;mov	ax,5D09h
  1296 00000284 B8095D                  		mov	ax,(SERVERCALL<<8)+9
  1297 00000287 CD21                    		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  1298                                  		;MOV	AX,(ServerCall SHL 8) + 8
  1299                                  		;mov	ax,5D08h
  1300 00000289 B8085D                  		mov	ax,(SERVERCALL<<8)+8
  1301 0000028C B201                    		mov	dl,1
  1302 0000028E CD21                    		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  1303                                  				; DL = 00h redirected output is	combined
  1304                                  				;      01h redirected output placed in separate	jobs
  1305                                  				; start	new print job now
  1306 00000290 0E                      		push	cs
  1307 00000291 1F                      		pop	ds	; Need local segment to point to buffer
  1308 00000292 BA[4D40]                		mov	dx,UCOMBUF
  1309                                  
  1310                                  		; MSDOS 6.0
  1311                                  ;	Try to read interactive command line via DOSKey.
  1312                                  ;	If that fails, use DOS Buffered Keyboard Input.
  1313                                  
  1314                                  		;mov	ax,4810h	; AX = DOSKey Read Line function
  1315                                  		;int	2fh
  1316                                  		;or	ax,ax
  1317                                  		;jz	GOTCOM		; DOSKey gave us a command line
  1318                                  
  1319                                  		;mov	ah,0Ah
  1320 00000295 B40A                    		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
  1321 00000297 CD21                    		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  1322                                  				; DS:DX	-> buffer
  1323                                  ;GOTCOM:
  1324 00000299 8A0E[4D40]              		mov	cl,[UCOMBUF]
  1325 0000029D 30ED                    		xor	ch,ch
  1326 0000029F 83C103                  		add	cx,3
  1327 000002A2 BE[4D40]                		mov	si,UCOMBUF
  1328 000002A5 BF[D040]                		mov	di,COMBUF
  1329 000002A8 F3A4                    		rep movsb		; Transfer it to the cooked buffer
  1330                                  DOCOM:
  1331 000002AA E8BF16                  		call	CRLF2
  1332                                  DOCOM1:
  1333 000002AD E87F19                  		call	PRESCAN		; Cook the input buffer
  1334 000002B0 7406                    		jz	short NOPIPEPROC
  1335 000002B2 E9AB1C                  		jmp	PIPEPROCSTRT	; Fire up the pipe
  1336                                  
  1337                                  NULLCOMJ:
  1338 000002B5 E9FA00                  		jmp	NULLCOM
  1339                                  
  1340                                  NOPIPEPROC:
  1341 000002B8 E8F520                  		call	PARSELINE
  1342 000002BB 730B                    		jnb	short OKPARSE	; user error?  or maybe we goofed?
  1343                                  BADPARSE:
  1344 000002BD 0E                      		push	cs
  1345 000002BE 1F                      		pop	ds
  1346 000002BF BA[BB37]                		mov	dx,BADNAMPTR
  1347 000002C2 E80532                  		call	STD_EPRINTF
  1348 000002C5 E93CFE                  		jmp	TCOMMAND
  1349                                  
  1350                                  OKPARSE:
  1351                                  		;test	byte [ARGV0_ARG_FLAGS],2
  1352 000002C8 F606[AB45]02            		test	byte [ARG+ARGV_ELE.argflags],wildcard
  1353 000002CD 75EE                    		jnz	short BADPARSE	; ambiguous commands not allowed
  1354                                  		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  1355 000002CF 833E[6948]00            		cmp	word [ARG+ARG_UNIT.argvcnt],0
  1356 000002D4 74DF                    		jz	short NULLCOMJ
  1357                                  		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  1358 000002D6 833E[AE45]00            		cmp	word [ARG+ARGV_ELE.arglen],0
  1359 000002DB 74D8                    		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  1360                                  
  1361 000002DD BE[D240]                		mov	si,COMBUF+2
  1362 000002E0 BF[EB42]                		mov	di,IDLEN
  1363                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1364                                  					; Make FCB with blank scan-off
  1365 000002E3 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1366                                  		;mov	ax,2901h
  1367 000002E6 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1368                                  				; DS:SI	-> string to parse
  1369                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1370                                  				; AL = bit mask	to control parsing
  1371                                  		;mov	bx,[ARG_ARGV]
  1372 000002E8 8B1E[A945]              		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  1373 000002EC 807F013A                		cmp	byte [bx+1],':'	; was a drive specified?
  1374 000002F0 751C                    		jne	short DRVGD	; no, use default of zero...
  1375 000002F2 8A17                    		mov	dl,[bx]		; pick-up drive letter
  1376                                  		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  1377                                  		;and	dl,~20h
  1378 000002F4 80E2DF                  		and	dl,0DFh		; uppercase the sucker
  1379 000002F7 2A16[F03E]              		sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  1380 000002FB 3CFF                    		cmp	al,-1		; See what PARSE said about our drive letter.
  1381 000002FD 740C                    		jz	short DRVBADJ	; It was invalid.
  1382                                  		;mov	di,[ARGV0_ARGSTARTEL]
  1383 000002FF 8B3E[AC45]              		mov	di,[ARG+ARGV_ELE.argstartel]
  1384 00000303 803D00                  		cmp	byte [di],0	; is there actually a command there?
  1385 00000306 7506                    		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  1386 00000308 E9F5FD                  		jmp	SETDRV		; and set drive to new drive spec
  1387                                  DRVBADJ:
  1388 0000030B E9CA17                  		jmp	DRVBAD
  1389                                  DRVGD:
  1390 0000030E 8A05                    		mov	al,[di]
  1391 00000310 A2[9142]                		mov	[SPECDRV],al
  1392 00000313 B020                    		mov	al,' '
  1393 00000315 B90900                  		mov	cx,9
  1394 00000318 47                      		inc	di
  1395 00000319 F2AE                    		repne scasb		; Count number of letters in command name
  1396 0000031B B008                    		mov	al,8
  1397 0000031D 28C8                    		sub	al,cl
  1398 0000031F A2[EB42]                		mov	[IDLEN],al	; IDLEN is truly the length
  1399 00000322 BF8100                  		mov	di,81h
  1400 00000325 56                      		push	si
  1401 00000326 BE[D240]                		mov	si,COMBUF+2	; Skip over all leading delims
  1402 00000329 E84D16                  		call	SCANOFF
  1403                                  
  1404                                  		; MSDOS 6.0
  1405                                  ;SR;
  1406                                  ; We are going to skip over the first char always. The logic is that the
  1407                                  ;command tail can never start from the first character. The code below is 
  1408                                  ;trying to figure out the command tail and copy it to the command line 
  1409                                  ;buffer in the PSP. However, if the first character happens to be a switch
  1410                                  ;character and the user given command line is a full 128 bytes, we try to
  1411                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  1412                                  ;char overwrites the code and leads to a crash on future commands.
  1413                                  ;
  1414                                  		;inc	si ;  MSDOS 6.0
  1415                                  DO_SKIPCOM:
  1416 0000032C AC                      		lodsb			; move command line pointer over
  1417 0000032D E85116                  		call	DELIM		; pathname -- have to do it ourselves
  1418 00000330 740A                    		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  1419 00000332 3C0D                    		cmp	al,0Dh		; can't always depend on argv[0].arglen
  1420 00000334 7406                    		jz	short DO_SKIPPED ; to be the same length as the user-
  1421 00000336 3A06[7542]              		cmp	al,[SWITCHAR]	; specified command string
  1422 0000033A 75F0                    		jnz	short DO_SKIPCOM 
  1423                                  DO_SKIPPED:
  1424 0000033C 4E                      		dec	si
  1425 0000033D 31C9                    		xor	cx,cx
  1426                                  COMTAIL:
  1427 0000033F AC                      		lodsb
  1428 00000340 AA                      		stosb			; Move command tail to 80h
  1429 00000341 3C0D                    		cmp	al,0Dh
  1430 00000343 E0FA                    		loopne	COMTAIL
  1431 00000345 4F                      		dec	di
  1432 00000346 89FD                    		mov	bp,di
  1433 00000348 F6D1                    		not	cl
  1434 0000034A 880E8000                		mov	[80h],cl
  1435 0000034E 5E                      		pop	si
  1436                                  ;-----
  1437                                  ; Some of these comments are sadly at odds with this brave new code.
  1438                                  ;-----
  1439                                  ; If the command has 0 parameters must check here for
  1440                                  ; any switches that might be present.
  1441                                  ; SI -> first character after the command.
  1442                                  
  1443                                  		;mov	di, arg.argv[0].argsw_word
  1444                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1445 0000034F 8B3E[B045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1446 00000353 893E[8842]              		mov	[COMSW],di	; ah yes, the old addressing mode problem...
  1447                                  		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  1448                                  					; s = argv[1];
  1449                                  		;mov	si,[ARGV1_ARGPOINTER]
  1450 00000357 8B36[B445]              		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  1451 0000035B 09F6                    		or	si,si		;   if (s == NULL)
  1452 0000035D 7502                    		jnz	short DOPARSE	;	s = bp; (buffer end)
  1453 0000035F 89EE                    		mov	si,bp
  1454                                  DOPARSE:
  1455 00000361 BF5C00                  		mov	di,FCB ; 5Ch
  1456                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1457                                  		;mov	ax,2901h
  1458 00000364 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1459 00000367 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1460                                  				; DS:SI	-> string to parse
  1461                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1462                                  				; AL = bit mask	to control parsing
  1463 00000369 A2[8642]                		mov	[PARM1],al	; Save result of parse
  1464                                  		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  1465                                  		;mov	di,[ARGV1_ARGSW_WORD]
  1466 0000036C 8B3E[BB45]              		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  1467 00000370 893E[8A42]              		mov	[ARG1S],di
  1468                                  		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  1469                                  					; s = argv[2];
  1470                                  		;mov	si,[ARGV2_ARGPOINTER]
  1471 00000374 8B36[BF45]              		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  1472 00000378 09F6                    		or	si,si		;   if (s == NULL)
  1473 0000037A 7502                    		jnz	short DOPARSE2
  1474 0000037C 89EE                    		mov	si,bp		;	s = bp; (buffer end)
  1475                                  DOPARSE2:			
  1476 0000037E BF6C00                  		mov	di,FCB+10H ; 6Ch
  1477                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
  1478                                  		;mov	ax,2901h
  1479 00000381 B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
  1480 00000384 CD21                    		int	21h	; DOS -	PARSE FILENAME
  1481                                  				; DS:SI	-> string to parse
  1482                                  				; ES:DI	-> buffer to fill with unopened	FCB
  1483                                  				; AL = bit mask	to control parsing
  1484 00000386 A2[8742]                		mov	[PARM2],al	; Save result
  1485                                  		;mov	di,[ARGV2_ARGSW_WORD]
  1486                                  		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  1487 00000389 8B3E[C645]              		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  1488 0000038D 893E[8C42]              		mov	[ARG2S],di
  1489                                  		;mov	di,[ARGV0_ARGSW_WORD]
  1490                                  		;mov	di,arg.argv[0].argsw_word
  1491 00000391 8B3E[B045]              		mov	di,[ARG+ARGV_ELE.argsw_word]
  1492 00000395 F7D7                    		not	di		; ARGTS doesn't include the flags
  1493                                  		;and	di,[ARG_ARGSWINFO]	; from COMSW...
  1494                                  		;and	di,arg.argswinfo	
  1495 00000397 233E[6B48]              		and	di,[ARG+ARG_UNIT.argswinfo]
  1496 0000039B 893E[8E42]              		mov	[ARGTS],di
  1497                                  
  1498 0000039F A0[EB42]                		mov	al,[IDLEN]
  1499 000003A2 8A16[9142]              		mov	dl,[SPECDRV]
  1500 000003A6 08D2                    		or	dl,dl		; if a drive was specified...
  1501 000003A8 7505                    		jnz	short EXTERNALJ1 ; it MUST be external, by this time
  1502 000003AA FEC8                    		dec	al		; (I don't know why -- old code did it)
  1503 000003AC E93217                  		jmp	FNDCOM		; otherwise, check internal com table
  1504                                  EXTERNALJ1:
  1505 000003AF E9E017                  		jmp	EXTERNAL
  1506                                  NULLCOM:
  1507 000003B2 8E1E[7142]              		mov	ds,[RESSEG]
  1508 000003B6 F706970BFFFF            		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
  1509 000003BC 7405                    		jz	short NOSETFLAG	  ;G only set flag if in batch
  1510                                  		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
  1511 000003BE C606020C01              		mov	byte [NULLFLAG],nullcommand ; 1
  1512                                  NOSETFLAG:
  1513 000003C3 833EF30BFF              		cmp	word [SINGLECOM],0FFFFh ; -1
  1514 000003C8 7403                    		jz	short EXITJ
  1515 000003CA E90AFE                  		jmp	GETCOM
  1516                                  EXITJ:
  1517 000003CD E957FD                  		jmp	_$EXITPREP
  1518                                  
  1519                                  ;============================================================================
  1520                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  1521                                  ;============================================================================
  1522                                  ; 12/10/2018 - Retro DOS v3.0
  1523                                  
  1524                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  1525                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  1526                                  ;   there is a header that describes a block of rom program.  This header
  1527                                  ;   contains information needed to initialize a module and to provide PCDOS
  1528                                  ;   with a set of reserved names for execution.
  1529                                  ;
  1530                                  ;   This header has the following format:
  1531                                  ;
  1532                                  ;   rom_header	STRUC
  1533                                  ;	Signature1  DB	55h
  1534                                  ;	Signature2  DB	AAh
  1535                                  ;	rom_length  DB	?		; number of 512 byte pieces
  1536                                  ;	init_jmp    DB	3 dup (?)
  1537                                  ;	name_list   name_struc <>
  1538                                  ;   rom_header	ENDS
  1539                                  ;
  1540                                  ;   name_struc	STRUC
  1541                                  ;	name_len    DB	?
  1542                                  ;	name_text   DB	? DUP (?)
  1543                                  ;	name_jmp    DB	3 DUP (?)
  1544                                  ;   name_struc	ENDS
  1545                                  ;
  1546                                  ;   The name list is a list of names that are reserved by a particular section
  1547                                  ;   of a module.  This list of names is terminated by a null name (length
  1548                                  ;   is zero).
  1549                                  ;
  1550                                  ;   Consider now, the PCDOS action when a user enters a command:
  1551                                  ;
  1552                                  ;	COMMAND.COM has control.
  1553                                  ;	o   If location FFFFEh has FDh then
  1554                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  1555                                  ;		    by AAh, stop scan if we get above or = F0000H
  1556                                  ;	o	When we've found one, compare the name entered by the user
  1557                                  ;		    with the one found in the rom.  If we have a match, then
  1558                                  ;		    set up the environment for execution and do a long jump
  1559                                  ;		    to the near jump after the found name.
  1560                                  ;	o	If no more names in the list, then continue scanning the module
  1561                                  ;		    for more 55h followed by AAh.
  1562                                  ;	o   We get to this point only if there is no matching name in the
  1563                                  ;		rom.  We now look on disk for the command.
  1564                                  ;
  1565                                  ;   This gives us the flexibility to execute any rom cartridge without having
  1566                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  1567                                  ;   want to be invisible to the DOS should not have any names in their lists
  1568                                  ;   (i.e. they have a single null name).
  1569                                  ;
  1570                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  1571                                  ;   Clearly this version will be available on disk.  How does a user actually
  1572                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  1573                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  1574                                  ;   solution:
  1575                                  ;
  1576                                  ;   o	Keep things consistent and force the user to have his software named
  1577                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  1578                                  
  1579                                  struc ROM_HEADER
  1580 00000000 ??                          .signature1: resb 1
  1581 00000001 ??                          .signature2: resb 1
  1582 00000002 ??                          .rom_length: resb 1
  1583 00000003 ??????                      .init_jmp:	 resb 3
  1584 00000006 ??                          .name_list:	 resb 1
  1585                                      .size:
  1586                                  endstruc
  1587                                  
  1588                                  struc NAME_STRUC
  1589 00000000 ??                          .name_len:	resb 1
  1590 00000001 ??                          .name_text:	resb 1
  1591 00000002 ??????                      .name_jmp:	resb 3
  1592                                      .size:	
  1593                                  endstruc
  1594                                  
  1595                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  1596                                  
  1597                                  ; =============== S U B	R O U T	I N E =======================================
  1598                                  
  1599                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  1600                                  
  1601                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  1602                                  
  1603                                  ROM_SCAN:
  1604 000003D0 06                      		push	es
  1605 000003D1 56                      		push	si
  1606 000003D2 57                      		push	di
  1607 000003D3 51                      		push	cx
  1608 000003D4 50                      		push	ax
  1609 000003D5 53                      		push	bx
  1610                                  
  1611                                  		; check for PC Jr signature in rom
  1612                                  
  1613 000003D6 B800F0                  		mov	ax,0F000h
  1614 000003D9 8EC0                    		mov	es,ax
  1615 000003DB 26803EFEFFFD            		cmp	byte [es:0FFFEh],0FDh
  1616 000003E1 7408                    		je	short SCAN_IT
  1617                                  NO_ROM:
  1618 000003E3 F8                      		clc
  1619                                  ROM_RET:
  1620 000003E4 5B                      		pop	bx
  1621 000003E5 58                      		pop	ax
  1622 000003E6 59                      		pop	cx
  1623 000003E7 5F                      		pop	di
  1624 000003E8 5E                      		pop	si
  1625 000003E9 07                      		pop	es
  1626 000003EA C3                      		retn
  1627                                  
  1628                                  SCAN_IT:	; start scanning at C000h
  1629                                  
  1630 000003EB B800C0                  		mov	ax,0C000h
  1631                                  SCAN_ONE:
  1632 000003EE 8EC0                    		mov	es,ax
  1633 000003F0 31FF                    		xor	di,di
  1634                                  
  1635                                  SCAN_MODULE:	; check for a valid header
  1636                                  
  1637 000003F2 26813D55AA              		cmp	word [es:di],0AA55h
  1638 000003F7 740A                    		jz	short SCAN_LIST
  1639 000003F9 058000                  		add	ax,80h
  1640                                  SCAN_END:
  1641 000003FC 3D00F0                  		cmp	ax,0F000h
  1642 000003FF 72ED                    		jb	short SCAN_ONE
  1643 00000401 EBE0                    		jmp	short NO_ROM
  1644                                  
  1645                                  		; trundle down list of names
  1646                                  SCAN_LIST:
  1647                                  		;mov	bl,[es:di+2]
  1648                                  					; number of 512-byte jobbers
  1649 00000403 268A5D02                		mov	bl,[es:di+ROM_HEADER.rom_length]
  1650 00000407 30FF                    		xor	bh,bh		; nothing in the high byte
  1651 00000409 D1E3                    		shl	bx,1
  1652 0000040B D1E3                    		shl	bx,1		; number of paragraphs
  1653 0000040D 83C37F                  		add	bx,7Fh
  1654 00000410 83E380                  		and	bx,0FF80h	; round to 2k	
  1655                                  		;mov	di,6
  1656 00000413 BF0200                  		mov	di,ROM_HEADER.rom_length
  1657                                  
  1658                                  		;nop
  1659                                  SCAN_NAME:
  1660 00000416 268A0D                  		mov	cl,[es:di]	; length of name
  1661 00000419 47                      		inc	di		; point to name
  1662 0000041A 30ED                    		xor	ch,ch
  1663 0000041C 09C9                    		or	cx,cx		; zero length name
  1664 0000041E 7504                    		jnz	short SCAN_TEST	; nope... compare
  1665 00000420 01D8                    		add	ax,bx		; yep, skip to next block
  1666 00000422 EBD8                    		jmp	short SCAN_END
  1667                                  
  1668                                  SCAN_TEST:	; compare a single name
  1669                                  
  1670 00000424 89D6                    		mov	si,dx
  1671 00000426 46                      		inc	si
  1672 00000427 F3A6                    		repe cmpsb		 ; compare name
  1673 00000429 7407                    		jz	short SCAN_FOUND ; success!
  1674                                  SCAN_NEXT:
  1675 0000042B 01CF                    		add	di,cx		; failure, next name piece
  1676 0000042D 83C703                  		add	di,3
  1677 00000430 EBE4                    		jmp	short SCAN_NAME
  1678                                  
  1679                                  SCAN_FOUND:	; found a name. save entry location
  1680                                  
  1681 00000432 803C3F                  		cmp	byte [si],'?'
  1682 00000435 7405                    		jz	short SCAN_SAVE
  1683 00000437 803C20                  		cmp	byte [si],' '
  1684 0000043A 75EF                    		jnz	short SCAN_NEXT
  1685                                  SCAN_SAVE:
  1686 0000043C 2E8C06[6A44]            		mov	[cs:ROM_CS],es
  1687 00000441 2E893E[6844]            		mov	[cs:ROM_IP],di
  1688 00000446 F9                      		stc
  1689 00000447 EB9B                    		jmp	short ROM_RET
  1690                                  
  1691                                  ; ---------------------------------------------------------------------------
  1692                                  
  1693                                  ; execute a rom-placed body of code. allocate largest block
  1694                                  
  1695                                  ROM_EXEC:
  1696 00000449 BBFFFF                  		mov	bx,0FFFFh
  1697 0000044C B448                    		mov	ah,ALLOC ; 48h
  1698 0000044E CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1699                                  				; BX = number of 16-byte paragraphs desired
  1700 00000450 B448                    		mov	ah,ALLOC ; 48h
  1701 00000452 CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  1702                                  				; BX = number of 16-byte paragraphs desired
  1703 00000454 53                      		push	bx
  1704 00000455 50                      		push	ax
  1705                                  
  1706                                  		; set terminate addresses
  1707                                  
  1708                                  		;mov	ax,2522h
  1709                                  		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
  1710 00000456 B82225                  		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
  1711 00000459 1E                      		push	ds
  1712 0000045A 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  1713                                  		;mov	dx,offset RESGROUP:EXEC_WAIT
  1714                                  		;mov	dx,131h ; MSDOS 3.3
  1715 0000045F BA3101                  		mov	dx,EXEC_WAIT
  1716 00000462 CD21                    		int	21h	; DOS -	SET INTERRUPT VECTOR
  1717                                  				; AL = interrupt number
  1718                                  				; DS:DX	= new vector to	be used	for specified interrupt
  1719 00000464 8CDA                    		mov	dx,ds
  1720 00000466 8EC2                    		mov	es,dx
  1721 00000468 1F                      		pop	ds
  1722                                  		
  1723                                  		; and create program header and dup all jfn's
  1724                                  
  1725 00000469 5A                      		pop	dx
  1726 0000046A B455                    		mov	ah,DUP_PDB ; 55h
  1727 0000046C CD21                    		int	21h	; DOS -	2+ internal - CREATE PSP
  1728                                  				; DX = segment number at which to set up PSP
  1729                                  				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
  1730                                  		
  1731                                  		; set up dma address
  1732                                  
  1733 0000046E 8EDA                    		mov	ds,dx
  1734 00000470 BA8000                  		mov	dx,80h
  1735 00000473 B41A                    		mov	ah,SET_DMA ; 1Ah
  1736 00000475 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  1737                                  				; DS:DX	-> disk	transfer buffer
  1738                                  
  1739                                  		; copy in environment info
  1740                                  
  1741 00000477 26A1030D                		mov	ax,word [es:ENVIRSEG]
  1742 0000047B A32C00                  		mov	[PDB.ENVIRON],	ax
  1743                                  
  1744                                  		; set up correct size of block
  1745                                  
  1746 0000047E 5B                      		pop	bx		; BX has size, DS has segment
  1747 0000047F 8CDA                    		mov	dx,ds
  1748 00000481 01DA                    		add	dx,bx
  1749                                  		;mov	[2],dx
  1750 00000483 89160200                		mov	word [PDB.BLOCK_LEN],dx
  1751                                  
  1752                                  		; change ownership of block
  1753                                  
  1754 00000487 8CDA                    		mov	dx,ds
  1755 00000489 4A                      		dec	dx
  1756 0000048A 8EDA                    		mov	ds,dx
  1757 0000048C 42                      		inc	dx	
  1758                                  		;mov	[1],dx
  1759 0000048D 89160100                		mov	word [ARENA.owner],dx
  1760 00000491 8EDA                    		mov	ds,dx
  1761                                  
  1762                                  		; set up correct stack
  1763                                  
  1764 00000493 81FB0010                		cmp	bx,1000h
  1765 00000497 7202                    		jb	short GOT_STACK
  1766 00000499 31DB                    		xor	bx,bx
  1767                                  GOT_STACK:
  1768 0000049B B104                    		mov	cl,4
  1769 0000049D D3E3                    		shl	bx,cl
  1770 0000049F 8CDA                    		mov	dx,ds
  1771 000004A1 8ED2                    		mov	ss,dx
  1772 000004A3 89DC                    		mov	sp,bx
  1773 000004A5 31C0                    		xor	ax,ax
  1774 000004A7 50                      		push	ax
  1775                                  
  1776                                  		; set up initial registers and go to the guy
  1777                                  
  1778 000004A8 F7D0                    		not	ax
  1779 000004AA 2EFF36[6A44]            		push	word [cs:ROM_CS]
  1780 000004AF 2EFF36[6844]            		push	word [cs:ROM_IP]
  1781 000004B4 8EC2                    		mov	es,dx
  1782 000004B6 CB                      		retf	; far return
  1783                                  
  1784                                  ;============================================================================
  1785                                  ; TBATCH.ASM, MSDOS 6.0, 1991
  1786                                  ;============================================================================
  1787                                  ; 12/10/2018 - Retro DOS v3.0
  1788                                  
  1789                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
  1790                                  
  1791                                  ; =============== S U B	R O U T	I N E =======================================
  1792                                  
  1793                                  ;Break	<PromptBat - Open or wait for batch file>
  1794                                  
  1795                                  ; Open the batch file. If we cannot find the batch file. If the media is
  1796                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
  1797                                  ; file. Leave segment registers alone.
  1798                                  
  1799                                  PROMPTBAT:
  1800 000004B7 E8EF06                  		call	BATOPEN
  1801 000004BA 7201                    		jc	short PROMPTBAT1
  1802 000004BC C3                      		retn
  1803                                  PROMPTBAT1:
  1804                                  		; MSDOS 6.0 COMMAND.COM
  1805                                  		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
  1806                                  		;jz	Bat_Remcheck		;AN022;
  1807                                  		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
  1808                                  		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
  1809                                  		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
  1810                                  		;jmp	short BatDie		;AN022;
  1811                                  ;Bat_Remcheck:					;AN022; Go see if media is removable
  1812                                  		;call	[RCH_ADDR]		; DX has error number
  1813                                  		;jz	AskForBat		; Media is removable
  1814                                  
  1815                                  		; MSDOS 3.3 COMMAND.COM
  1816 000004BD 81FA[1D38]              		cmp	dx,ACCDENPTR
  1817 000004C1 7413                    		jz	short BATDIE
  1818                                  
  1819                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1820                                  BAT_REMCHECK:				; Go see if media is removable
  1821 000004C3 2EFF1E[7B42]            		call	far [cs:RCH_ADDR] ; DX has error number
  1822 000004C8 7417                    		jz	short ASKFORBAT	; Media is removable
  1823                                  
  1824                                  ; The media is not changeable. Turn everything off.
  1825                                  
  1826 000004CA E8CE09                  		call	FOROFF
  1827 000004CD E8BC1E                  		call	PIPEOFF
  1828 000004D0 A2F80B                  		mov	byte [IFFLAG],al ; No If in progress.	
  1829 000004D3 BA[5E37]                		mov	dx,BADPATHPTR
  1830                                  BATDIE:
  1831 000004D6 E84F03                  		call	BATCHOFF
  1832 000004D9 0E                      		push	cs
  1833 000004DA 1F                      		pop	ds
  1834                                  		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
  1835 000004DB E8F52F                  		call	STD_PRINTF	; MSDOS 3.3
  1836                                  
  1837                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
  1838                                  
  1839 000004DE E923FC                  		jmp	TCOMMAND
  1840                                  
  1841                                  ; Ask the user to reinsert the batch file
  1842                                  
  1843                                  ASKFORBAT:
  1844 000004E1 1E                      		push	ds
  1845 000004E2 0E                      		push	cs
  1846 000004E3 1F                      		pop	ds
  1847                                  
  1848                                  		; MSDOS 6.0
  1849                                  		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
  1850                                  		;invoke	std_eprintf	 	;Prompt for batch file on stderr
  1851                                  		;mov	dx,offset trangroup:pausemes_ptr 
  1852                                  		;;invoke std_eprintf		;AN000; get second part of message
  1853                                  						;AN000; print it to stderr
  1854                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1855 000004E4 E8E32F                  		call	STD_EPRINTF
  1856 000004E7 E80300                  		call	GETKEYSTROKE
  1857 000004EA 1F                      		pop	ds
  1858 000004EB EBCA                    		jmp	short PROMPTBAT
  1859                                  
  1860                                  
  1861                                  ; MSDOS 6.0
  1862                                  ;****************************************************************
  1863                                  ;*
  1864                                  ;* ROUTINE:	Output_batch_name
  1865                                  ;*
  1866                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
  1867                                  ;*
  1868                                  ;* INPUT:	DX - extended error number
  1869                                  ;*
  1870                                  ;* OUTPUT:	Ready to call print routine
  1871                                  ;*
  1872                                  ;****************************************************************
  1873                                  ;
  1874                                  ;public	output_batch_name			;AN022;
  1875                                  ;
  1876                                  ;Output_batch_name    proc near			;AN022;
  1877                                  ;
  1878                                  ;		push	ds			;AN022; save resident segment
  1879                                  ;		mov	ds,[batch]		;AN022; get batch file segment
  1880                                  ;	assume	DS:nothing			;AN022;
  1881                                  ;		mov	SI,BatFile		;AN022; get offset of batch file
  1882                                  ;		invoke	dstrlen 		;AN022; get length of string
  1883                                  ;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
  1884                                  ;		rep	movsb			;AN022; move the name
  1885                                  ;
  1886                                  ;		push	cs			;AN022; get local segment
  1887                                  ;		pop	ds			;AN022;
  1888                                  ;	assume	DS:trangroup			;AN022;
  1889                                  ;		mov	extend_buf_ptr,dx	;AN022; put message number in block
  1890                                  ;		mov	msg_disp_class,ext_msg_class
  1891                                  ;						;AN022; set up extended error msg class
  1892                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  1893                                  ;						;AN022; get extended message pointer
  1894                                  ;		mov	string_ptr_2,offset trangroup:bwdbuf 
  1895                                  ;						;AN022; point to substitution
  1896                                  ;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
  1897                                  ;		pop	ds			;AN022; restore data segment
  1898                                  ;
  1899                                  ;		ret				;AN022; return
  1900                                  ;
  1901                                  ;Output_batch_name    endp			;AN022;
  1902                                  
  1903                                  
  1904                                  ; =============== S U B	R O U T	I N E =======================================
  1905                                  
  1906                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
  1907                                  
  1908                                  ; Read the next keystroke. Since there may be several characters in the queue
  1909                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
  1910                                  ; AFTER waiting.
  1911                                  
  1912                                  GETKEYSTROKE:
  1913                                  		; MSDOS 3.3
  1914                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
  1915                                  		;mov	ax,0C08h
  1916 000004ED B8080C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
  1917 000004F0 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1918                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1919                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1920                                  		;mov	ax,0C00h
  1921 000004F2 B8000C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
  1922 000004F5 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
  1923                                  				; AL must be 01h,06h,07h,08h,or 0Ah.
  1924 000004F7 C3                      		retn
  1925                                  
  1926                                  		; MSDOS 6.0
  1927                                  		;PUSH	DX				;AN000;  3/3/KK
  1928                                  		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
  1929                                  		;INT	21h				;AN000;  3/3/KK
  1930                                  		;PUSH	DX				;AN000;  save interim state 3/3/KK
  1931                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1932                                  		;MOV	DL,InterimMode			;AN000;  3/3/KK
  1933                                  		;INT	21h				;AN000;  3/3/KK
  1934                                  		;
  1935                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
  1936                                  		;INT	21h		; Get character with KB buffer flush
  1937                                  		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
  1938                                  		;INT	21h
  1939                                  		;
  1940                                  		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
  1941                                  		;POP	DX				;AN000;  restore interim state 3/3/KK
  1942                                  		;INT	21h				;AN000;  3/3/KK
  1943                                  		;POP	DX				;AN000;  3/3/KK
  1944                                  		;
  1945                                  		;return
  1946                                  
  1947                                  ; =============== S U B	R O U T	I N E =======================================
  1948                                  
  1949                                  ; Break	<ReadBat - read 1 line from batch file>
  1950                                  
  1951                                  ; ReadBat - read a single line from the batch file. 
  1952                                  ; Perform all substitutions as appropriate.
  1953                                  
  1954                                  READBAT:
  1955                                  		;ASSUME	DS:ResGroup,ES:TranGroup
  1956                                  		
  1957                                  		;mov	byte [SUPPRESS],1
  1958                                  					; initialize line suppress status
  1959 000004F8 C606EE0B01              		mov	byte [SUPPRESS],YES_ECHO 
  1960 000004FD F606E30BFF              		test	byte [BATCH_ABORT],-1 ; 0FFh
  1961 00000502 7508                    		jnz	short TRYING_TO_ABORT
  1962 00000504 C606E20B01              		mov	byte [IN_BATCH],1 ; set flag to indicate batch job
  1963                                  
  1964                                  		; MSDOS 6.0
  1965                                  ;
  1966                                  ;M037; Start of changes
  1967                                  ; We check here if we have set the flag indicating that the batchfile is at
  1968                                  ;EOF. In this case, we do not want to continue with the normal processing.
  1969                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
  1970                                  ;batch file gets closed etc. and then return as if everything is done.
  1971                                  ;
  1972                                  		;push	ds
  1973                                  		;mov	ds,Batch
  1974                                  		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
  1975                                  		;pop	ds
  1976                                  		;jz	contbat		; no, continue normal processing
  1977                                  		;invoke	GetBatByt	; frees up batchseg
  1978                                  		;mov	es:ComBuf+2,al	; stuff CR into command buffer
  1979                                  		;			; as a dummy command
  1980                                  		;invoke CrLf2		; print a CR-LF
  1981                                  		;return			; done batch processing
  1982                                  
  1983                                  ;M037; End of changes
  1984                                  		
  1985                                  		; MSDOS 3.3 (& MSDOS 6.0)
  1986                                  CONTBAT:
  1987 00000509 E8ABFF                  		call	PROMPTBAT
  1988                                  
  1989                                  TRYING_TO_ABORT:
  1990 0000050C BF[D240]                		mov	di,COMBUF+2
  1991                                  
  1992                                  ; Save position and try to scan for first non delimiter.
  1993                                  
  1994                                  TESTNOP:
  1995 0000050F 8CD8                    		mov	ax,ds
  1996 00000511 8E1E970B                		mov	ds,word [BATCH]
  1997 00000515 FF360700                		push	word [BATCHSEGMENT.BatSeek]
  1998 00000519 FF360900                		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
  1999 0000051D 8ED8                    		mov	ds,ax
  2000 0000051F E88105                  		call	SKIPDELIM	; skip to first non-delim
  2001                                  
  2002                                  ; If the first non-delimiter is not a : (label), we reseek back to the
  2003                                  ; beginning and read the line.
  2004                                  
  2005 00000522 3C3A                    		cmp	al,':'		; is it a label?
  2006 00000524 59                      		pop	cx
  2007 00000525 5A                      		pop	dx		; restore position in bat file
  2008 00000526 7431                    		jz	short NOPLINE	; yes, resync everything.
  2009 00000528 F706970BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2010 0000052E 7438                    		jz	short RDBAT	; no, go read batch file
  2011                                  
  2012                                  		;cmp	al,'@'
  2013 00000530 3C40                    		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
  2014 00000532 7507                    		jnz	short SET_BAT_POS ; no - go and set batch file position
  2015                                  		;mov	byte [SUPPRESS],0
  2016 00000534 C606EE0B00              		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
  2017 00000539 EB2D                    		jmp	short RDBAT	; go read batch file
  2018                                  
  2019                                  		;nop
  2020                                  SET_BAT_POS:
  2021 0000053B 1E                      		push	ds
  2022 0000053C 8E1E970B                		mov	ds,word [BATCH]
  2023 00000540 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
  2024 00000544 890E0900                		mov	[BATCHSEGMENT.BatSeek+2],cx
  2025 00000548 1F                      		pop	ds
  2026                                  		;MOV	AX,(LSEEK SHL 8) + 0
  2027 00000549 B80042                  		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
  2028 0000054C CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  2029                                  				; AL = method: offset from beginning of	file
  2030                                  		;mov	word [cs:BATBUFPOS],0FFFFh
  2031 0000054E 2EC706[184D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
  2032 00000555 31C9                    		xor	cx,cx		; Initialize line length to zero
  2033 00000557 EB0F                    		jmp	short RDBAT
  2034                                  
  2035                                  		;nop
  2036                                  
  2037                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
  2038                                  ; We eat characters until a CR is seen.
  2039                                  
  2040                                  NOPLINE:
  2041 00000559 E8F400                  		call	SKIPTOEOL
  2042 0000055C E82E03                  		call	GETBATBYT	; eat trailing LF
  2043                                  		;test	word [BATCH],0FFFFh
  2044 0000055F F706970BFFFF            		test	word [BATCH],-1 ; are we done with the batch file?
  2045 00000565 75A8                    		jnz	short TESTNOP	; no, go get another line
  2046                                  READBAT_RETN:				; Hit EOF			
  2047 00000567 C3                      		retn
  2048                                  
  2049                                  ; ---------------------------------------------------------------------------
  2050                                  
  2051                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
  2052                                  ; input, we are to consider two special cases:
  2053                                  ;
  2054                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
  2055                                  ;   %sym%	This is a symbol from the environment
  2056                                  
  2057                                  RDBAT:
  2058 00000568 E82203                  		call	GETBATBYT
  2059 0000056B 41                      		inc	cx		; Inc the line length
  2060                                  RDBAT1:
  2061 0000056C 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2062 00000570 7344                    		jnb	short TOOLONG	   ; Yes - handle it, handle it
  2063                                  
  2064                                  ; See if we have a parameter character.
  2065                                  
  2066 00000572 3C25                    		cmp	al,'%'		; Check for parameter
  2067 00000574 744A                    		jz	short NEEDPARM
  2068                                  
  2069                                  ; no parameter character. Store it as usual and see if we are done.
  2070                                  
  2071                                  SAVBATBYT:
  2072 00000576 AA                      		stosb			; End of line found?
  2073 00000577 3C0D                    		cmp	al,0Dh
  2074 00000579 75ED                    		jnz	short RDBAT	; no, go for more
  2075                                  
  2076                                  ; We have read in an entire line. 
  2077                                  ; Decide whether we should echo the command line or not.
  2078                                  
  2079                                  FOUND_EOL:
  2080 0000057B 81EF[D340]              		sub	di,COMBUF+3
  2081 0000057F 89F8                    		mov	ax,di		; remember that we've not counted the CR
  2082 00000581 26A2[D140]              		mov	[es:COMBUF+1],al ; Set length of line
  2083 00000585 E80503                  		call	GETBATBYT	; Eat linefeed
  2084 00000588 E80A06                  		call	BATCLOSE
  2085 0000058B 803EEE0B00              		cmp	byte [SUPPRESS],NO_ECHO ; 0
  2086 00000590 7407                    		jz	short RESET
  2087 00000592 F606ED0B01              		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
  2088 00000597 7504                    		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
  2089                                  RESET:
  2090 00000599 0E                      		push	cs
  2091 0000059A 1F                      		pop	ds		; Go back to local segment
  2092 0000059B 74CA                    		jz	short READBAT_RETN ; no echoing here...
  2093                                  TRY_NEXTFLAG:
  2094 0000059D 803E020C01              		cmp	byte [NULLFLAG],nullcommand ; 1
  2095                                  					;G was there a command last time?
  2096 000005A2 7403                    		jz	short NO_CRLF_PRINT ;G no - don't print crlf
  2097 000005A4 E8C513                  		call	CRLF2		;G  Print out prompt
  2098                                  NO_CRLF_PRINT:
  2099 000005A7 E8E00D                  		call	PRINT_PROMPT
  2100 000005AA 0E                      		push	cs		;G change data segment
  2101 000005AB 1F                      		pop	ds
  2102 000005AC BA[D240]                		mov	dx,COMBUF+2	; get command line for echoing
  2103 000005AF E81814                  		call	CRPRINT
  2104 000005B2 E8B713                  		call	CRLF2
  2105 000005B5 C3                      		retn
  2106                                  
  2107                                  ; The line was too long. Eat remainder of input text up until the CR
  2108                                  
  2109                                  TOOLONG:
  2110 000005B6 3C0D                    		cmp	al,0Dh		; Has the end of the line been reached?
  2111 000005B8 7403                    		jz	short LTLCONT	; Yes, continue
  2112 000005BA E89300                  		call	SKIPTOEOL	; Eat remainder of line	
  2113                                  LTLCONT:
  2114 000005BD AA                      		stosb			; Terminate the command
  2115 000005BE EBBB                    		jmp	short FOUND_EOL	; Go process the valid part of the line
  2116                                  
  2117                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
  2118                                  
  2119                                  NEEDPARM:
  2120 000005C0 E8CA02                  		call	GETBATBYT	; get next character
  2121 000005C3 3C25                    		cmp	al,'%'		; Check for two consecutive %
  2122 000005C5 74AF                    		jz	short SAVBATBYT	; if so, replace with a single %
  2123 000005C7 3C0D                    		cmp	al,0Dh		; Check for end-of-line
  2124 000005C9 74AB                    		jz	short SAVBATBYT	; yes, treat it normally
  2125                                  
  2126                                  ; We have found %<something>. If the <something> is in the range 0-9, we
  2127                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
  2128                                  ; see if the <something> has a terminating % and then look up the contents
  2129                                  ; in the environment.
  2130                                  
  2131                                  PAROK:
  2132 000005CB 2C30                    		sub	al,'0'
  2133 000005CD 7239                    		jb	short NEEDENV	; look for parameter in the environment
  2134 000005CF 3C09                    		cmp	al,9
  2135 000005D1 7735                    		ja	short NEEDENV
  2136                                  
  2137                                  ; We have found %<number>. This is taken from the parameters in the
  2138                                  ; allocated batch area.
  2139                                  
  2140 000005D3 98                      		cbw
  2141 000005D4 89C3                    		mov	bx,ax		; move index into AX
  2142 000005D6 D1E3                    		shl	bx,1		; convert word index into byte ptr
  2143 000005D8 06                      		push	es
  2144 000005D9 8E06970B                		mov	es,word [BATCH]
  2145                                  ;
  2146                                  ; The structure of the batch area is:
  2147                                  ;
  2148                                  ;   BYTE    type of segment
  2149                                  ;   DWORD   offset for next line
  2150                                  ;   10 WORD pointers to parameters. -1 is empty parameter
  2151                                  ;   ASCIZ   file name (with . and ..)
  2152                                  ;   BYTES   CR-terminated parameters
  2153                                  ;   BYTE    0 flag to indicate end of parameters
  2154                                  ;
  2155                                  ; Get pointer to BX'th argument
  2156                                  ;
  2157                                  		;mov	si,[es:bx+0Bh]
  2158 000005DD 268B770B                		mov	si,[es:bx+BATCHSEGMENT.BatParm]
  2159 000005E1 07                      		pop	es
  2160                                  
  2161                                  ; Is there a parameter here?
  2162                                  
  2163 000005E2 83FEFF                  		cmp	si,-1		; Check if parameter exists
  2164 000005E5 7503                    		jnz	short YES_THERE_IS ; Yes go get it
  2165 000005E7 E97EFF                  		jmp	RDBAT		; Ignore if it doesn't
  2166                                  
  2167                                  ; Copy in the found parameter from batch segment
  2168                                  
  2169                                  YES_THERE_IS:
  2170 000005EA 1E                      		push	ds
  2171 000005EB 8E1E970B                		mov	ds,word [BATCH]
  2172 000005EF 49                      		dec	cx		; Don't count '%' in line length
  2173                                  COPYPARM:
  2174 000005F0 AC                      		lodsb			; From resident segment
  2175 000005F1 3C0D                    		cmp	al,0Dh		; Check for end of parameter
  2176 000005F3 740F                    		jz	short ENDPARAM
  2177 000005F5 41                      		inc	cx		; Inc the line length
  2178 000005F6 81F98000                		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
  2179 000005FA 7303                    		jnb	short LINETOOL	; Yes - handle it, handle it
  2180 000005FC AA                      		stosb
  2181 000005FD EBF1                    		jmp	short COPYPARM
  2182                                  
  2183                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
  2184                                  ; line. We need to make sure that the tooLong code isn't fooled into
  2185                                  ; believing that we are at EOL. Clobber AL too.
  2186                                  
  2187                                  LINETOOL:
  2188 000005FF 30C0                    		xor	al,al
  2189 00000601 1F                      		pop	ds
  2190 00000602 EBB2                    		jmp	short TOOLONG
  2191                                  
  2192                                  ; We have copied in an entire parameter. Go back for more
  2193                                  
  2194                                  ENDPARAM:
  2195 00000604 1F                      		pop	ds
  2196 00000605 E960FF                  		jmp	RDBAT
  2197                                  
  2198                                  ; We have found % followed by something other than 0-9. We presume that there
  2199                                  ; will be a following % character. In between is an environment variable that
  2200                                  ; we will fetch and replace in the batch line with its value.
  2201                                  
  2202                                  NEEDENV:
  2203                                  		; MSDOS 6.0 COMMAND.COM 
  2204                                  		;dec     cx 		;AN070; Don't count "%"
  2205                                  
  2206                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2207 00000608 1E                      		push	ds
  2208 00000609 57                      		push	di
  2209                                  					; temp spot for name
  2210 0000060A BF[EC42]                		mov	di,ID
  2211 0000060D 0430                    		add	al,'0'		; reconvert character
  2212 0000060F AA                      		stosb			; store it in appropriate place
  2213                                  
  2214                                  ; loop getting characters until the next % is found or until EOL
  2215                                  
  2216                                  GETENV1:
  2217 00000610 E87A02                  		call	GETBATBYT	; get the byte
  2218 00000613 AA                      		stosb			; store it
  2219 00000614 3C0D                    		cmp	al,0Dh		; EOL?
  2220 00000616 7513                    		jnz	short GETENV15	; no, see if it the term char
  2221                                  
  2222                                  ; The user entered a string with a % but no trailing %. We copy the string.
  2223                                  
  2224 00000618 26C645FF00              		mov	byte [es:di-1],0 ; nul terminate the string
  2225 0000061D BE[EC42]                		mov	si,ID 		; point to buffer
  2226 00000620 5F                      		pop	di		; point to line buffer
  2227 00000621 0E                      		push	cs
  2228 00000622 1F                      		pop	ds
  2229 00000623 E85E02                  		call	STRCPY
  2230                                  		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
  2231 00000626 4F                      		dec	di  		;  MSDOS 3.3 COMMAND.COM	
  2232 00000627 1F                      		pop	ds
  2233 00000628 E94BFF                  		jmp	SAVBATBYT
  2234                                  GETENV15:
  2235 0000062B 3C25                    		cmp	al,'%'		; terminating %?
  2236 0000062D 75E1                    		jnz	short GETENV1	; no, go suck out more characters
  2237                                  
  2238                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
  2239                                  ; This was the source of bug #1.
  2240                                  ;		dec	cx		;AN070; Don't count "%"
  2241                                  
  2242 0000062F B03D                    		mov	al,'='		; terminate  with =
  2243 00000631 268845FF                		mov	[es:di-1],al
  2244                                  
  2245                                  ; ID now either has a =-terminated string which we are to find in the
  2246                                  ; environment or a non =-terminated string which will not be found in the
  2247                                  ; environment.
  2248                                  
  2249                                  GETENV2:
  2250 00000635 BE[EC42]                		mov	si,ID
  2251 00000638 0E                      		push	cs
  2252 00000639 1F                      		pop	ds		; DS:SI points to name
  2253 0000063A 51                      		push	cx
  2254 0000063B E85911                  		call	FIND_NAME_IN_ENVIRONMENT
  2255 0000063E 59                      		pop	cx
  2256 0000063F 06                      		push	es
  2257 00000640 1F                      		pop	ds
  2258 00000641 0E                      		push	cs
  2259 00000642 07                      		pop	es
  2260 00000643 89FE                    		mov	si,di
  2261 00000645 5F                      		pop	di		; get back pointer to command line
  2262                                  
  2263                                  ; If the parameter was not found, there is no need to perform any replacement.
  2264                                  ; We merely pretend that we've copied the parameter.
  2265                                  
  2266 00000646 7204                    		jc	short GETENV6
  2267                                  
  2268                                  ; ES:DI points to command line being built
  2269                                  ; DS:SI points either to nul-terminated environment object AFTER =
  2270                                  
  2271 00000648 E83902                  		call	STRCPY		; (let RdBat handle overflow)
  2272 0000064B 4F                      		dec	di 	; MSDOS 3.3 COMMAND.COM
  2273                                  GETENV6:
  2274 0000064C 1F                      		pop	ds
  2275 0000064D E918FF                  		jmp	RDBAT		; go back to batch file
  2276                                  
  2277                                  ; =============== S U B	R O U T	I N E =======================================
  2278                                  
  2279                                  ;   SkipToEOL - read from batch file until end of line
  2280                                  
  2281                                  SKIPTOEOL:
  2282 00000650 F706970BFFFF            		test	word [BATCH],-1 ; 0FFFFh
  2283                                  		
  2284                                  		;jnz	short SKIPTOEOL1  	
  2285                                  		;retn			; no batch file in effect
  2286                                  		
  2287 00000656 7407                    		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
  2288                                  SKIPTOEOL1:
  2289 00000658 E83202                  		call	GETBATBYT
  2290 0000065B 3C0D                    		cmp	al,0Dh		; eol character?
  2291 0000065D 75F1                    		jnz	short SKIPTOEOL	; no, go eat another
  2292                                  SKIPTOEOL2:
  2293 0000065F C3                      		retn
  2294                                  
  2295                                  ; =============== S U B	R O U T	I N E =======================================
  2296                                  
  2297                                  ;Break	<Allocate and deallocate the transient portion>
  2298                                  
  2299                                  ; Free Transient. Modify ES,AX,flags
  2300                                  
  2301                                  FREE_TPA:
  2302 00000660 06                      		push	es
  2303 00000661 8E06[7142]              		mov	es,[RESSEG]
  2304 00000665 268E06230D              		mov	es,word [es:RES_TPA]
  2305 0000066A B449                    		mov	ah,DEALLOC ; 49h
  2306 0000066C CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2307                                  				; ES = segment address of area to be freed
  2308 0000066E 07                      		pop	es
  2309 0000066F C3                      		retn
  2310                                  
  2311                                  ; =============== S U B	R O U T	I N E =======================================
  2312                                  
  2313                                  ; Allocate transient.  Modify AX,BX,DX,flags
  2314                                  
  2315                                  ALLOC_TPA:
  2316 00000670 06                      		push	es
  2317 00000671 8E06[7142]              		mov	es,[RESSEG]
  2318 00000675 BBFFFF                  		mov	bx,0FFFFh 	; Re-allocate the transient	
  2319 00000678 B448                    		mov	ah,ALLOC ; 48h
  2320 0000067A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2321                                  				; BX = number of 16-byte paragraphs desired
  2322 0000067C 53                      		push	bx	  	; Save size of block
  2323 0000067D B448                    		mov	ah,ALLOC ; 48h
  2324 0000067F CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2325                                  				; BX = number of 16-byte paragraphs desired
  2326                                  
  2327                                  ; Attempt to align TPA on 64K boundary
  2328                                  
  2329 00000681 5B                      		pop	bx		; Restore size of block
  2330 00000682 26A3230D                		mov	word [es:RES_TPA],ax ; Save segment to beginning of block
  2331 00000686 A3[8142]                		mov	[TRAN_TPA],ax
  2332                                  
  2333                                  ; Is the segment already aligned on a 64K boundary
  2334                                  
  2335 00000689 89C2                    		mov	dx,ax		; Save segment
  2336 0000068B 25FF0F                  		and	ax,0FFFh	; Test if above boundary
  2337 0000068E 7507                    		jnz	short CALC_TPA
  2338 00000690 89D0                    		mov	ax,dx
  2339 00000692 2500F0                  		and	ax,0F000h	; Test if multiple of 64K
  2340 00000695 7523                    		jnz	short NOROUND
  2341                                  CALC_TPA:
  2342 00000697 89D0                    		mov	ax,dx
  2343 00000699 2500F0                  		and	ax,0F000h
  2344 0000069C 050010                  		add	ax,1000h	; Round up to next 64K boundary
  2345 0000069F 7219                    		jc	short NOROUND	; Memory wrap if carry set
  2346                                  
  2347                                  ; Make sure that new boundary is within allocated range
  2348                                  
  2349 000006A1 268B16230D              		mov	dx,word [es:RES_TPA]
  2350 000006A6 01DA                    		add	dx,bx		; Compute maximum address
  2351 000006A8 39C2                    		cmp	dx,ax		; Is 64K address out of range?
  2352 000006AA 720E                    		jb	short NOROUND
  2353                                  
  2354                                  ; Make sure that we won't overwrite the transient
  2355                                  
  2356 000006AC 8CCB                    		mov	bx,cs		; CS is beginning of transient
  2357 000006AE 39C3                    		cmp	bx,ax
  2358 000006B0 7208                    		jb	short NOROUND
  2359                                  
  2360                                  ; The area from the 64K boundary to the beginning of the transient must
  2361                                  ; be at least 64K.
  2362                                  
  2363 000006B2 29C3                    		sub	bx,ax
  2364                                  		;cmp	bx,4096
  2365 000006B4 81FB0010                		cmp	bx,1000h	; Size greater than 64K?	
  2366 000006B8 7304                    		jnb	short ROUNDDONE
  2367                                  NOROUND:
  2368 000006BA 26A1230D                		mov	ax,word [es:RES_TPA]
  2369                                  ROUNDDONE:
  2370 000006BE 26A3150D                		mov	word [es:LTPA],ax ; Re-compute everything
  2371 000006C2 A3[7342]                		mov	[TPA],ax
  2372 000006C5 89C3                    		mov	bx,ax
  2373 000006C7 8CC8                    		mov	ax,cs
  2374 000006C9 29D8                    		sub	ax,bx
  2375 000006CB 53                      		push	bx
  2376 000006CC BB1000                  		mov	bx,16
  2377 000006CF F7E3                    		mul	bx
  2378 000006D1 5B                      		pop	bx
  2379 000006D2 09D2                    		or	dx,dx
  2380 000006D4 7403                    		jz	short SAVSIZ2
  2381 000006D6 B8FFFF                  		mov	ax,-1
  2382                                  SAVSIZ2:
  2383                                  
  2384                                  ; AX is the number of bytes free in the buffer between the resident and the
  2385                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  2386                                  
  2387 000006D9 3D0002                  		cmp	ax,512
  2388 000006DC 7603                    		jbe	short GOTSIZE2
  2389                                  		;and	ax,~1FFh
  2390 000006DE 2500FE                  		and	ax,0FE00h	; NOT 511 = NOT 1FFh
  2391                                  GOTSIZE2:
  2392 000006E1 A3[9242]                		mov	[BYTCNT],ax
  2393 000006E4 07                      		pop	es
  2394 000006E5 C3                      		retn
  2395                                  
  2396                                  ; =============== S U B	R O U T	I N E =======================================
  2397                                  
  2398                                  ;Break	<BatCom - enter a batch file>
  2399                                  
  2400                                  ; The exec search has determined that the user has requested a batch file for
  2401                                  ; execution. We parse the arguments, create the batch segment, and signal
  2402                                  ; batch processing.
  2403                                  
  2404                                  BATCOM:	
  2405                                  
  2406                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
  2407                                  
  2408                                  ; Batch parameters are read with ES set to segment of resident part
  2409                                  
  2410                                  		; MSDOS 6.0
  2411                                  		;mov	es,[RESSEG]
  2412                                  		;ASSUME	ES:RESGROUP
  2413                                  		;cmp	es:[call_batch_flag],call_in_progress
  2414                                  		;				;AN043; If in CALL,
  2415                                  		;jz	skip_ioset		;AN043; redirection was already set up
  2416                                  		;invoke	IOSET			; Set up any redirection
  2417                                  ;skip_ioset:					;AN043;
  2418                                  		;call	FREE_TPA		; G
  2419                                  		;cmp	es:[call_batch_flag],call_in_progress ;G
  2420                                  		;jz	getecho 		; G if we're in a call, don't execute
  2421                                  
  2422                                  		; MSDOS 3.3
  2423 000006E6 E81C17                  		call	IOSET
  2424 000006E9 8E06[7142]              		mov	es,[RESSEG]
  2425 000006ED E870FF                  		call	FREE_TPA
  2426                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2427 000006F0 26803EFF0B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2428 000006F6 7403                    		jz	short GETECHO		; G if we're in a call, don't execute
  2429                                  
  2430                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2431                                  
  2432                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
  2433                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
  2434                                  ; Don't execute if in call
  2435                                  
  2436 000006F8 E8A007                  		call	FOROFF
  2437                                  GETECHO:
  2438 000006FB E88E1C                  		call	PIPEOFF
  2439 000006FE 26A0ED0B                		mov	al,byte [es:ECHOFLAG] ; preserve echo state for chaining
  2440 00000702 2401                    		and	al,1		; Save current echo state
  2441                                  
  2442 00000704 50                      		push	ax
  2443 00000705 31C0                    		xor	ax,ax
  2444 00000707 26F706970BFFFF          		test	word [es:BATCH],-1 ; Are we in a batch file?
  2445 0000070E 7414                    		jz	short LEAVEBAT	   ; No, nothing to save
  2446 00000710 26A1970B                		mov	ax,word [es:BATCH] ; Get current batch segment
  2447                                  		;cmp	byte [es:CALL_BATCH_FLAG],1
  2448 00000714 26803EFF0B01            		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
  2449 0000071A 7408                    		jz	short LEAVEBAT
  2450                                  
  2451                                  ;  We are in a chained batch file, save batlast from previous batch segment
  2452                                  ;  so that if we're in a CALL, we will return to the correct batch file.
  2453                                  
  2454 0000071C 06                      		push	es
  2455 0000071D 8EC0                    		mov	es,ax		; Get current batch segment
  2456                                  		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
  2457                                  					; Get previous batch segment
  2458 0000071F 26A10200                		mov	ax,word [es:BATCHSEGMENT.BatLast]
  2459 00000723 07                      		pop	es
  2460                                  LEAVEBAT:
  2461 00000724 50                      		push	ax		; Keep segment until new one created
  2462 00000725 26803EFF0B01            		cmp	byte [es:CALL_BATCH_FLAG],1
  2463 0000072B 7403                    		jz	short STARTBAT
  2464 0000072D E8F800                  		call	BATCHOFF
  2465                                  
  2466                                  ; Find length of batch file
  2467                                  
  2468                                  STARTBAT:
  2469 00000730 26C606FF0B00            		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
  2470 00000736 BE[9941]                		mov	si,EXECPATH
  2471                                  
  2472                                  		; MSDOS 6.0
  2473                                  		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
  2474                                  		;int	2fh		;AN042;    was found with APPEND
  2475                                  		;mov	ah,Find_First	;AN042; The find_first will return it
  2476                                  		;mov	dx,si		;AN042; Get the string
  2477                                  		;mov	cx,search_attr	;AN042; filetypes to search for
  2478                                  		;int	21h		;AN042;
  2479                                  
  2480                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2481 00000739 E88017                  		call	DSTRLEN
  2482                                  ;
  2483                                  ; Allocate batch area:
  2484                                  ;   BYTE    type of segment
  2485                                  ;   WORD    segment of last batch file
  2486                                  ;   WORD    segment for FOR command
  2487                                  ;   BYTE    FOR flag state on entry to batch file
  2488                                  ;   DWORD   offset for next line
  2489                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
  2490                                  ;   ASCIZ   file name (with . and ..)
  2491                                  ;   BYTES   CR-terminated parameters
  2492                                  ;   BYTE    0 flag to indicate end of parameters
  2493                                  ;
  2494                                  ; We allocate the maximum size for the command line and use setblock to shrink
  2495                                  ; later when we've squeezed out the extra
  2496                                  ;
  2497 0000073C 89CB                    		mov	bx,cx		; length of file name.
  2498                                  		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
  2499 0000073E 81C3BE00                		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
  2500                                  					; structure + max len + round up
  2501 00000742 51                      		push	cx
  2502 00000743 B104                    		mov	cl,4
  2503 00000745 D3EB                    		shr	bx,cl		; convert to paragraphs
  2504 00000747 53                      		push	bx		; Save size of batch segment
  2505 00000748 B448                    		mov	ah,ALLOC ; 48h ; Allocate batch segment
  2506 0000074A CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
  2507                                  				; BX = number of 16-byte paragraphs desired
  2508 0000074C 5B                      		pop	bx		; Get size of batch segment
  2509                                  
  2510                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
  2511                                  ; the batch segment. This may not be true, however, in a multitasking system.
  2512                                  ; G This error will occur with nesting of batch files. We also need to
  2513                                  ; G make sure that we don't overlay the transient.
  2514                                  
  2515 0000074D 7216                    		jc	short MEM_ERROR	;G not enough memory - exit
  2516                                  
  2517 0000074F 50                      		push	ax		;G save batch segment
  2518 00000750 01D8                    		add	ax,bx		;G get end of batch segment
  2519 00000752 83C020                  		add	ax,20h		;G add some tpa work area
  2520 00000755 8CCB                    		mov	bx,cs		;G get the transient segment
  2521                                  
  2522                                  		; MSDOS 6.0
  2523                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
  2524                                  ; M006; batchseg is always above the transient. We need to change this code
  2525                                  ; M006; to only check for an overlap
  2526                                  ;
  2527                                  		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
  2528                                  		;add	dx,15		;round up para; M006
  2529                                  		;shr	dx,cl		;para size of transient; M006
  2530                                  		;add	dx,bx		;dx = top of transient; M006
  2531                                  
  2532                                  		;cmp	ax,bx		; M006
  2533                                  		;jb	enough_mem	; Batchseg below transient
  2534                                  					; enough memory ; M006
  2535                                  		;cmp	ax,dx		; M006
  2536                                  		;ja	enough_mem	; Batchseg above transient
  2537                                  					; enough memory ; M006
  2538                                  ;
  2539                                  ; M006; Batchseg overlaps transient -- insufficient memory
  2540                                  ;
  2541                                  		;pop	ax		; restore ax; M006
  2542                                  
  2543                                  ;M006;		cmp	ax,bx		;G do we end before the transient
  2544                                  ;M006;		pop	ax		;G get batch segment back
  2545                                  ;M006;		jb	enough_mem	;G we have enough memory - continue
  2546                                  
  2547                                  		; MSDOS 3.3
  2548 00000757 39D8                    		cmp	ax,bx		; do we end before the transient ?
  2549 00000759 58                      		pop	ax		; get batch segment back
  2550 0000075A 720C                    		jb	short ENOUGH_MEM ; we have enough memory - continue
  2551                                  
  2552                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2553 0000075C 06                      		push	es		;G no we're hitting the transient
  2554 0000075D 8EC0                    		mov	es,ax
  2555 0000075F B80049                  		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
  2556 00000762 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2557                                  				; ES = segment address of area to be freed
  2558 00000764 07                      		pop	es
  2559                                  MEM_ERROR:
  2560 00000765 E9B400                  		jmp	NO_MEMORY	;G Set up for message and exit
  2561                                  
  2562                                  ENOUGH_MEM:
  2563                                  		; MSDOS 6.0
  2564                                  		;pop	ax		; restore ax; M006
  2565                                  
  2566                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2567 00000768 26A3970B                		mov	word [es:BATCH],ax
  2568 0000076C E801FF                  		call	ALLOC_TPA
  2569                                  
  2570                                  ; Initialize batch segment
  2571                                  
  2572 0000076F 5A                      		pop	dx		; length of name
  2573 00000770 58                      		pop	ax		;G get saved batch segment back
  2574 00000771 26FF06FC0B              		inc	word [es:NEST]	;G increment # batch files in progress
  2575 00000776 06                      		push	es
  2576 00000777 268E06970B              		mov	es,word [es:BATCH]
  2577                                  		;mov	byte [ES:0],0
  2578                                  					; signal batch file type
  2579 0000077C 26C606000000            		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
  2580                                  		;mov	byte [ES:2],ax ; MSDOS 3.3
  2581                                  					;G save segment of last batch file
  2582 00000782 26A30200                		mov	word [es:BATCHSEGMENT.BatLast],ax
  2583 00000786 1E                      		push	ds
  2584 00000787 8E1E[7142]              		mov	ds,[RESSEG]	;G set to resident data
  2585                                  
  2586 0000078B 31C0                    		xor	ax,ax
  2587 0000078D 8A1EF90B                		mov	bl,byte [FORFLAG] ;G get the current FOR state
  2588                                  		;mov	[es:6],bl ;  MSDOS 3.3
  2589                                  					;G save it in the batch segment
  2590 00000791 26881E0600              		mov	[es:BATCHSEGMENT.BatForFlag],bl
  2591 00000796 F6C3FF                  		test	bl,-1		;G are we in a FOR?
  2592 00000799 7408                    		jz	short FOR_NOT_ON ;G no, for segment set to 0	
  2593 0000079B A1FA0B                  		mov	ax,word [FORPTR] ;G yes, get current FOR segment	
  2594 0000079E C606F90B00              		mov	byte [FORFLAG],0 ;G reset forflag
  2595                                  FOR_NOT_ON:
  2596                                  		;mov	[es:4],ax ; MSDOS 3.3
  2597                                  					;G save FOR segment in batch segment
  2598 000007A3 26A30400                		mov	[es:BATCHSEGMENT.BatForPtr],ax	
  2599 000007A7 31C0                    		xor	ax,ax
  2600 000007A9 A3FA0B                  		mov	word [FORPTR],ax ;G make sure for segment is not active
  2601 000007AC 8A1EED0B                		mov	bl,byte [ECHOFLAG]
  2602 000007B0 1F                      		pop	ds
  2603                                  		;mov	[es:1],bl 
  2604                                  					 ;G save echo state of parent
  2605 000007B1 26881E0100              		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
  2606                                  ;SR;
  2607                                  ; Initialize the new BatchEOF flag we have added to 0
  2608                                  ;
  2609                                  		;mov	es:BatchEOF,0  ; MSDOS 6.0
  2610                                  
  2611 000007B6 26A30700                		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
  2612 000007BA 26A30900                		mov	[es:BATCHSEGMENT.BatSeek+2],ax
  2613                                  
  2614                                  ; Initialize pointers
  2615                                  
  2616 000007BE 48                      		dec	ax		; put -1 into AX
  2617                                  		;mov	di,0Bh  ; MSDOS 3.3
  2618                                  					; point to parm area
  2619 000007BF BF0B00                  		mov	di,BATCHSEGMENT.BatParm
  2620 000007C2 89FB                    		mov	bx,di
  2621 000007C4 B90A00                  		mov	cx,10
  2622 000007C7 F3AB                    		rep stosw		; Init to no parms
  2623                                  
  2624                                  ; Move in batch file name
  2625                                  
  2626 000007C9 89D1                    		mov	cx,dx
  2627 000007CB F3A4                    		rep movsb
  2628                                  
  2629                                  ; Now copy the command line into batch segment, parsing the arguments along
  2630                                  ; the way. Segment will look like this:
  2631                                  ;
  2632                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
  2633                                  ;
  2634                                  ; or, in the case of fewer arguments:
  2635                                  ;
  2636                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
  2637                                  ;
  2638 000007CD BE[D240]                		mov	si,COMBUF+2
  2639 000007D0 B90A00                  		mov	cx,10		; at most 10 arguments
  2640                                  EACHPARM:
  2641 000007D3 E8A311                  		call	SCANOFF		; skip to argument
  2642                                  
  2643                                  ; AL is first non-delimiter. DS:SI points to char = AL
  2644                                  
  2645 000007D6 3C0D                    		cmp	al,0Dh		; end of road?
  2646 000007D8 741D                    		jz	short HAVPARM	; yes, no more arguments
  2647                                  
  2648                                  ; If CX = 0 then we have stored the most parm we can. Skip store
  2649                                  
  2650 000007DA E306                    		jcxz	MOVPARM		; Only first 10 parms get pointers
  2651                                  
  2652                                  ; Go into allocated piece and stick in new argument pointer.
  2653                                  
  2654 000007DC 26893F                  		mov	[es:bx],di	; store batch pointer
  2655 000007DF 83C302                  		add	bx,2		; advance arg counter
  2656                                  
  2657                                  ; Move the parameter into batch segment
  2658                                  
  2659                                  MOVPARM:
  2660 000007E2 AC                      		lodsb			; get byte
  2661 000007E3 E89B11                  		call	DELIM		; if delimiter
  2662 000007E6 7407                    		jz	short ENDPARM	; then done with parm
  2663 000007E8 AA                      		stosb			; store byte
  2664 000007E9 3C0D                    		cmp	al,0Dh		; if CR then not delimiter
  2665 000007EB 740A                    		jz	short HAVPARM	; but end of parm list, finish
  2666 000007ED EBF3                    		jmp	short MOVPARM
  2667                                  
  2668                                  ; We have copied a parameter up until the first separator.
  2669                                  ; Terminate it with CR.
  2670                                  
  2671                                  ENDPARM:
  2672 000007EF B00D                    		mov	al,0Dh
  2673 000007F1 AA                      		stosb
  2674 000007F2 E3DF                    		jcxz	EACHPARM	; if no parameters, don't dec
  2675 000007F4 49                      		dec	cx		; remember that we've seen one.	
  2676 000007F5 EBDC                    		jmp	short EACHPARM
  2677                                  
  2678                                  ; We have parsed the entire line. Terminate the arg list
  2679                                  
  2680                                  HAVPARM:
  2681 000007F7 30C0                    		xor	al,al		; Nul terminate the parms
  2682 000007F9 AA                      		stosb
  2683                                  
  2684                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
  2685                                  ; into paragraphs and setblock to the appropriate size
  2686                                  
  2687 000007FA 8D5D0F                  		lea	bx,[di+15]
  2688 000007FD B104                    		mov	cl,4
  2689 000007FF D3EB                    		shr	bx,cl
  2690 00000801 B44A                    		mov	ah,SETBLOCK ; 4Ah
  2691 00000803 CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2692                                  				; ES = segment address of block	to change
  2693                                  				; BX = new size	in paragraphs
  2694 00000805 07                      		pop	es
  2695 00000806 06                      		push	es
  2696 00000807 1F                      		pop	ds		; Simply batch FCB setup
  2697 00000808 833EF30BFF              		cmp	word [SINGLECOM],-1 ; 0FFFFh
  2698 0000080D 7506                    		jnz	short NOBATSING
  2699 0000080F C706F30BF0FF            		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
  2700                                  NOBATSING:
  2701                                  
  2702                                  ; Enter the batch file with the current echo state
  2703                                  
  2704 00000815 58                      		pop	ax		; Get original echo state
  2705 00000816 A2ED0B                  		mov	byte [ECHOFLAG],al ; restore it
  2706 00000819 E9E8F8                  		jmp	TCOMMAND
  2707                                  
  2708                                  ; The following is executed if there isn't enough memory for batch segment
  2709                                  
  2710                                  NO_MEMORY:
  2711 0000081C 5A                      		pop	dx		; even up our stack 
  2712 0000081D 58                      		pop	ax
  2713 0000081E 58                      		pop	ax
  2714 0000081F E84EFE                  		call	ALLOC_TPA	; reallocate memory
  2715                                  
  2716                                  		; MSDOS 3.3
  2717 00000822 BA[AA3C]                		mov	dx,INSFMEMMESPTR
  2718 00000825 E90114                  		jmp	CERROR
  2719                                  
  2720                                  		; MSDOS 6.0
  2721                                  		;mov	msg_disp_class,ext_msg_class
  2722                                  		;			;AN000; set up extended error msg class
  2723                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  2724                                  		;			;AC000; get extended message pointer
  2725                                  		;mov	Extend_Buf_ptr,error_not_enough_memory
  2726                                  		;			;AN000; get message number in control block
  2727                                  		;jmp	cerror		;g print error message and go...
  2728                                  
  2729                                  ; =============== S U B	R O U T	I N E =======================================
  2730                                  
  2731                                  BATCHOFF:
  2732 00000828 50                      		push	ax
  2733 00000829 06                      		push	es
  2734 0000082A 1E                      		push	ds
  2735 0000082B 53                      		push	bx
  2736                                  
  2737 0000082C 2E8E06[7142]            		mov	es,[cs:RESSEG]
  2738 00000831 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  2739 00000836 A1970B                  		mov	ax,word [BATCH]	; Free the batch segment
  2740 00000839 09C0                    		or	ax,ax
  2741 0000083B 7442                    		jz	short NOTFREE
  2742                                  
  2743 0000083D 06                      		push	es
  2744 0000083E 8EC0                    		mov	es,ax
  2745 00000840 F606ED0B01              		test	byte [ECHOFLAG],1 ;G Is echo on?
  2746 00000845 7505                    		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
  2747                                  		;mov	byte [SUPPRESS],0
  2748 00000847 C606EE0B00              		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
  2749                                  ECHO_LAST_LINE:
  2750                                  		;mov	bl,[es:1]
  2751 0000084C 268A1E0100              		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
  2752 00000851 881EED0B                		mov	byte [ECHOFLAG],bl		 ; G and restore it
  2753                                  		;mov	bx,[es:4] ;  MSDOS 3.3
  2754 00000855 268B1E0400              		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
  2755 0000085A 891EFA0B                		mov	word [FORPTR],bx		;G  and restore it
  2756                                  		;mov	bl,[es:6]
  2757 0000085E 268A1E0600              		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
  2758 00000863 881EF90B                		mov	byte [FORFLAG],bl		;G  and restore it
  2759                                  		;mov	bx,word [es:2] ; MSDOS 3.3
  2760 00000867 268B1E0200              		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment
  2761                                  
  2762 0000086C B449                    		mov	ah,DEALLOC ; 49h
  2763 0000086E CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  2764                                  				; ES = segment address of area to be freed
  2765 00000870 07                      		pop	es
  2766 00000871 891E000C                		mov	word [NEXT_BATCH],bx ;G  reset batch segment	
  2767 00000875 26FF0EFC0B              		dec	word [es:NEST]
  2768 0000087A 31C0                    		xor	ax,ax
  2769 0000087C A3970B                  		mov	word [BATCH],ax	; No batch in progress
  2770                                  NOTFREE:
  2771 0000087F 5B                      		pop	bx
  2772 00000880 1F                      		pop	ds
  2773 00000881 07                      		pop	es
  2774 00000882 58                      		pop	ax
  2775 00000883 C3                      		retn
  2776                                  
  2777                                  ; =============== S U B	R O U T	I N E =======================================
  2778                                  
  2779                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
  2780                                  ;	Entry : DS:SI ==> source string
  2781                                  ;		ES:DI ==> destination string
  2782                                  ;		CX = current length of destination string
  2783                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
  2784                                  
  2785                                  		; MSDOS 3.3
  2786                                  STRCPY:
  2787 00000884 50                      		push	ax
  2788                                  CCYCLE:
  2789 00000885 AC                      		lodsb
  2790 00000886 AA                      		stosb
  2791 00000887 08C0                    		or	al,al
  2792 00000889 75FA                    		jnz	short CCYCLE
  2793 0000088B 58                      		pop	ax
  2794 0000088C C3                      		retn
  2795                                  
  2796                                  		; MSDOS 6.0
  2797                                  ;Procedure StrCpy,NEAR
  2798                                  		;push	ax
  2799                                  ;ccycle:
  2800                                  		;lodsb
  2801                                  		;inc	cx
  2802                                  		;cmp	cx,COMBUFLEN
  2803                                  		;jb	ccopy
  2804                                  		;stc			; set carry to signal error
  2805                                  		;jmp	short ccend
  2806                                  ;ccopy:
  2807                                  		;stosb
  2808                                  		;or	al,al
  2809                                  		;jnz	ccycle
  2810                                  ;ccend:
  2811                                  		;dec	cx		; discount extra byte
  2812                                  		;dec	di		; back up pointer
  2813                                  		;pop	ax
  2814                                  		;return			; return carry clear
  2815                                  ;EndProc StrCpy
  2816                                  
  2817                                  ;============================================================================
  2818                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
  2819                                  ;============================================================================
  2820                                  ; 12/10/2018 - Retro DOS v3.0
  2821                                  
  2822                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
  2823                                  
  2824                                  ; =============== S U B	R O U T	I N E =======================================
  2825                                  
  2826                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
  2827                                  
  2828                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
  2829                                  ; <CR> and ends batch mode. DS must be set to resident segment.
  2830                                  ; AH, DX destroyed.
  2831                                  
  2832                                  GETBATBYT:
  2833 0000088D 53                      		push	bx
  2834 0000088E 51                      		push	cx
  2835 0000088F 1E                      		push	ds
  2836 00000890 F606E30BFF              		test	byte [BATCH_ABORT],-1
  2837 00000895 755E                    		jnz	short BATEOF
  2838 00000897 F706970BFFFF            		test	word [BATCH],-1
  2839 0000089D 7456                    		jz	short BATEOF
  2840 0000089F 06                      		push	es
  2841 000008A0 8E06970B                		mov	es,word [BATCH]
  2842                                  
  2843                                  		; MSDOS 6.0
  2844                                  ;M020;
  2845                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
  2846                                  ;try to read from the batchfile again.
  2847                                  ;
  2848                                  		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
  2849                                  		;jz	not_eof		;no, read batch file	;M020
  2850                                  		;jmp	At_EOF		;yes, no more reads	;M020
  2851                                  ;not_eof:							;M020
  2852                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2853 000008A4 268306070001            		add	word [es:BATCHSEGMENT.BatSeek],1
  2854 000008AA 268316090000            		adc	word [es:BATCHSEGMENT.BatSeek+2],0
  2855 000008B0 07                      		pop	es
  2856                                  
  2857                                  ; See if we have bytes buffered...
  2858                                  
  2859 000008B1 8CC8                    		mov	ax,cs
  2860 000008B3 8ED8                    		mov	ds,ax
  2861 000008B5 8B1E[184D]              		mov	bx,[BATBUFPOS]
  2862 000008B9 83FBFF                  		cmp	bx,-1
  2863 000008BC 751D                    		jnz	short UNBUF
  2864                                  
  2865                                  ; There are no bytes in the buffer. Let's try to fill it up.
  2866                                  
  2867 000008BE BA[1A4D]                		mov	dx,BATBUF
  2868 000008C1 8B0E[223F]              		mov	cx,[BATBUFLEN] ; max to read.
  2869 000008C5 8B1E[9545]              		mov	bx,[BATHAND]
  2870 000008C9 B43F                    		mov	ah,READ ; 3Fh	; Get one more byte from batch file
  2871 000008CB CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  2872                                  				; BX = file handle,CX = number	of bytes to read
  2873                                  				; DS:DX	-> buffer
  2874                                  		; MSDOS 6.0
  2875                                  		;jnc	bat_read_ok		;AN022; if no error - continue
  2876                                  		;invoke	get_ext_error_number	;AN022; get the error
  2877                                  		;push	ds			;AN022; save local segment
  2878                                  		;mov	ds,[resseg]		;AN022; get resident segment
  2879                                  		;assume ds:resgroup		;AN022;
  2880                                  		;mov	dx,ax			;AN022; put error in DX
  2881                                  		;invoke	output_batch_name	;AN022; set up to print the error
  2882                                  		;pop	ds			;AN022;
  2883                                  		;assume	ds:trangroup		;AN022;
  2884                                  		;invoke	std_eprintf		;AN022; print out the error
  2885                                  		;mov	byte ptr combuf+2,end_of_line_in
  2886                                  		;				;AN022; terminate the batch line for parsing
  2887                                  		;mov	byte ptr combuf+3,end_of_line_out 
  2888                                  		;				;AN022; terminate the batch line for output
  2889                                  ;M020;
  2890                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
  2891                                  ;error is never hit (and it shouldn't be)
  2892                                  ;
  2893                                  		;mov	ds,ResSeg		; ds = RESGROUP ; M020
  2894                                  		;
  2895                                  		;jmp	short bateof		;AN022; terminate the batch file
  2896                                  ;bat_read_ok:					;AN022;
  2897                                  
  2898                                  		; MSDOS 3.3 (& MSDOS 6.0)
  2899 000008CD 89C1                    		mov	cx,ax
  2900 000008CF E320                    		jcxz	TURN_OFF ; MSDOS 3.3
  2901                                  		;jcxz	BATEOFDS ; MSDOS 6.0
  2902 000008D1 890E[3A4D]              		mov	[BATBUFEND],cx
  2903 000008D5 31DB                    		xor	bx,bx
  2904 000008D7 891E[184D]              		mov	[BATBUFPOS],bx
  2905                                  
  2906                                  ; Buffered bytes!
  2907                                  
  2908                                  UNBUF:
  2909 000008DB 8A87[1A4D]              		mov	al,[BATBUF+bx]		; get next byte
  2910 000008DF 43                      		inc	bx
  2911 000008E0 3B1E[3A4D]              		cmp	bx,[BATBUFEND]		; beyond end of buffer?
  2912 000008E4 7203                    		jb	short SETBUFPOS
  2913 000008E6 BBFFFF                  		mov	bx,-1
  2914                                  SETBUFPOS:
  2915 000008E9 891E[184D]              		mov	[BATBUFPOS],bx
  2916 000008ED 3C1A                    		cmp	al,1Ah			; ^Z for termination?
  2917 000008EF 7533                    		jnz	short GETBYTEDONE
  2918                                  
  2919                                  ;We get here only when we hit an EOF
  2920                                  		
  2921                                  		; MSDOS 6.0
  2922                                  ;BatEOFDS:
  2923                                  ;SR;
  2924                                  ; HACK!!! A massive hack being put in here to get batch processing to work
  2925                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
  2926                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
  2927                                  ;batch processing is turned off before the last line is processed and so 
  2928                                  ;this line would never be executed. 
  2929                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
  2930                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
  2931                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
  2932                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
  2933                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
  2934                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
  2935                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
  2936                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
  2937                                  ;during this call, and there was a CR-LF previously, we are going to fake
  2938                                  ;another redundant CR-LF. There is no work-around I can think of.
  2939                                  ; 	I would love to restructure this entire routine and its caller to
  2940                                  ;make the flow really easy to understand but I guess this will have to wait.
  2941                                  ;
  2942                                  		;push	es
  2943                                  		;mov	es,ResSeg
  2944                                  ;SR;
  2945                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
  2946                                  ;or BatchEOF == 1 now), then do not do the LF check.
  2947                                  ;
  2948                                  		;mov	es,es:Batch
  2949                                  		;cmp	es:BatchEOF,0
  2950                                  		;jnz	crpresent
  2951                                  
  2952                                  		;inc	es:BatchEOF		;match the dec following
  2953                                  		;mov	bx,BatBufEnd
  2954                                  		;cmp	BatBuf[bx-1],0ah	;was a LF present?
  2955                                  		;je	crpresent		;yes, no need to fake it
  2956                                  
  2957                                  		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF
  2958                                  
  2959                                  ;crpresent:
  2960                                  ;;;		;pop	es
  2961                                  
  2962                                  		;ASSUME	DS:TranGroup
  2963                                  		;MOV	DS,ResSeg
  2964                                  		;ASSUME	DS:ResGroup
  2965                                  
  2966                                  ;SR;
  2967                                  ; The shift operation is done here to replace the decrement. This is because
  2968                                  ;we can jump to this label directly from above when bogus calls are made to
  2969                                  ;this routine even after batch processing is turned off. The shift ensures
  2970                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
  2971                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
  2972                                  ;calls.
  2973                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
  2974                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
  2975                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
  2976                                  ;turning batch processing off.
  2977                                  
  2978                                  ;At_EOF:						;new label added ;M020
  2979                                  		;shr	es:BatchEOF,1		;decrement the flag
  2980                                  		;jz	turn_off		;zero,turn batch off
  2981                                  		;cmp	es:BatchEOF,1				
  2982                                  		;jz	ret_lf			;BatchEOF was 2, return LF
  2983                                  ;
  2984                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
  2985                                  ;
  2986                                  		;mov	al,0dh			;return fake CR.
  2987                                  		;pop	es
  2988                                  		;jmp	short GetByteDone
  2989                                  ;ret_lf:
  2990                                  		;mov	al,0ah			;return fake LF
  2991                                  		;pop	es
  2992                                  		;jmp	short	GetByteDone			
  2993                                  ;turn_off:
  2994                                  		;pop	es
  2995                                  
  2996                                  ;BATEOF:
  2997                                  
  2998                                  		; MSDOS 3.3
  2999                                  TURN_OFF:
  3000 000008F1 8E1E[7142]              		mov	ds,[RESSEG]
  3001                                  
  3002                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3003                                  BATEOF:
  3004 000008F5 E830FF                  		call	BATCHOFF
  3005 000008F8 E89A02                  		call	BATCLOSE
  3006                                  ;;;		mov	BatchEOF,0	;make sure BatchEOF = 0
  3007                                  
  3008                                  ;SR; BugBug
  3009                                  ; There is a good reason why this carriage return is being returned here. 
  3010                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
  3011                                  ;of the way the caller is structured, a fake CR has to be returned again on
  3012                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
  3013                                  ;results in an extra linefeed after the batchfile is run if the last line of
  3014                                  ;the batchfile already had a CR-LF. 
  3015                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
  3016                                  ;the end-of-line. This CR is to mark the end-of-file.
  3017                                  
  3018 000008FB B00D                    		mov	al,0Dh		; If end-of-file, then end of line
  3019 000008FD F606E30BFF              		test	byte [BATCH_ABORT],-1
  3020 00000902 C606E30B00              		mov	byte [BATCH_ABORT],0
  3021 00000907 7407                    		jz	short CONT_GET_BYT
  3022 00000909 BF[D240]                		mov	di,COMBUF+2	; reset pointer to beginning of buffer
  3023 0000090C 31C9                    		xor	cx,cx		; zero line length
  3024 0000090E EB14                    		jmp	short GETBYTEDONE
  3025                                  CONT_GET_BYT:
  3026 00000910 833EF30BF0              		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
  3027 00000915 750D                    		jnz	short GETBYTEDONE
  3028 00000917 833EFC0B00              		cmp	word [NEST],0	;G See if we have nested batch files
  3029 0000091C 7506                    		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
  3030 0000091E C706F30BFFFF            		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
  3031                                  GETBYTEDONE:
  3032 00000924 1F                      		pop	ds
  3033 00000925 59                      		pop	cx
  3034 00000926 5B                      		pop	bx
  3035 00000927 C3                      		retn
  3036                                  
  3037                                  ; ---------------------------------------------------------------------------
  3038                                  
  3039                                  ;break	<$If - conditional execution>
  3040                                  
  3041                                  IFERRORP:
  3042 00000928 58                      		pop	ax
  3043                                  IFERROR:
  3044                                  FORERROR:
  3045 00000929 BA[783C]                		mov	dx,SYNTMESPTR
  3046 0000092C E9FA12                  		jmp	CERROR
  3047                                  
  3048                                  ; ---------------------------------------------------------------------------
  3049                                  
  3050                                  _$IF:
  3051                                  		; MSDOS 6.0
  3052                                  ; Turn off any pipes in progress.
  3053                                  		;push	ds			;AN004; save local DS
  3054                                  		;mov	ds,[resseg]		;AN004; get resident segment
  3055                                  		;assume	ds:resgroup		;AN004;
  3056                                  		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
  3057                                  		;jz	IFNoPipe		;AN004; no pipe - continue
  3058                                  		;invoke	PipeDel 		;AN004; turn off piping
  3059                                  ;IFNoPipe:					;AN004;
  3060                                  		;pop	ds			;AN004; get local DS back
  3061                                  		;assume	ds:trangroup		;AN004;
  3062                                  
  3063                                  		; MSDOS 3.3 (&MSDOS 6.0)
  3064 0000092F C606[8442]00            		mov	byte [IFNOTFLAG],0
  3065 00000934 C706[F54B]0000          		mov	word [IF_NOT_COUNT],0
  3066 0000093A BE8100                  		mov	si,81h
  3067                                  IFREENT:
  3068 0000093D E83910                  		call	SCANOFF
  3069 00000940 3C0D                    		cmp	al,0Dh
  3070 00000942 74E5                    		jz	short IFERROR
  3071 00000944 89F5                    		mov	bp,si
  3072 00000946 BF[C73D]                		mov	di,IFTAB	; Prepare to search if table	
  3073 00000949 B500                    		mov	ch,0
  3074                                  IFINDCOM:
  3075 0000094B 89EE                    		mov	si,bp
  3076 0000094D 8A0D                    		mov	cl,[di]
  3077 0000094F 47                      		inc	di
  3078 00000950 E337                    		jcxz	IFSTRING
  3079 00000952 EB02                    		jmp	short FIRSTCOMP
  3080                                  
  3081                                  IFCOMP:
  3082 00000954 7510                    		jnz	short IF_DIF
  3083                                  FIRSTCOMP:
  3084 00000956 AC                      		lodsb
  3085 00000957 268A25                  		mov	ah,[es:di]
  3086 0000095A 47                      		inc	di
  3087 0000095B 38E0                    		cmp	al,ah
  3088 0000095D 7405                    		jz	short IFLP
  3089 0000095F 80CC20                  		or	ah,20h		; Try lower case
  3090 00000962 38E0                    		cmp	al,ah
  3091                                  IFLP:
  3092 00000964 E2EE                    		loop	IFCOMP
  3093                                  IF_DIF:
  3094 00000966 9F                      		lahf
  3095 00000967 01CF                    		add	di,cx		; Bump to next position without affecting flags
  3096 00000969 8B1D                    		mov	bx,[di]		; Get handler address
  3097 0000096B 47                      		inc	di
  3098 0000096C 47                      		inc	di
  3099 0000096D 9E                      		sahf
  3100 0000096E 75DB                    		jnz	short IFINDCOM
  3101 00000970 AC                      		lodsb
  3102 00000971 3C0D                    		cmp	al,0Dh
  3103                                  IFERRJ:
  3104 00000973 74B4                    		jz	short IFERROR
  3105 00000975 E80910                  		call	DELIM
  3106 00000978 75D1                    		jnz	short IFINDCOM
  3107 0000097A E8FC0F                  		call	SCANOFF
  3108 0000097D FFE3                    		jmp	bx
  3109                                  
  3110                                  IFNOT:
  3111 0000097F F616[8442]              		not	byte [IFNOTFLAG]
  3112 00000983 FF06[F54B]              		inc	word [IF_NOT_COUNT]
  3113 00000987 EBB4                    		jmp	short IFREENT
  3114                                  
  3115                                  ; We are comparing two strings for equality. First, find the end of the
  3116                                  ; first string.
  3117                                  
  3118                                  IFSTRING:
  3119 00000989 56                      		push	si		; save away pointer for later compare
  3120 0000098A 31C9                    		xor	cx,cx		; count of chars in first string
  3121                                  FIRST_STRING:
  3122 0000098C AC                      		lodsb			; get character
  3123 0000098D 3C0D                    		cmp	al,0Dh		; end of line?
  3124 0000098F 7497                    		jz	short IFERRORP	; yes => error
  3125 00000991 E8ED0F                  		call	DELIM		; is it a delimiter?
  3126 00000994 7403                    		jz	short EQUAL_CHECK ; yes, go find equal sign
  3127 00000996 41                      		inc	cx		; remember 1 byte for the length
  3128 00000997 EBF3                    		jmp	short FIRST_STRING ; go back for more
  3129                                  EQUAL_CHECK:
  3130 00000999 3C3D                    		cmp	al,'='		; is char we have an = sign?
  3131 0000099B 7407                    		jz	short EQUAL_CHECK2 ; yes, go find second one.
  3132 0000099D 3C0D                    		cmp	al,0Dh		; end of line?
  3133 0000099F 7487                    		jz	short IFERRORP	; yes, syntax error
  3134 000009A1 AC                      		lodsb			; get next char
  3135 000009A2 EBF5                    		jmp	short EQUAL_CHECK
  3136                                  
  3137                                  ; The first = has been found. The next char had better be an = too.
  3138                                  
  3139                                  EQUAL_CHECK2:
  3140 000009A4 AC                      		lodsb			; get potential = char
  3141 000009A5 3C3D                    		cmp	al,'='		; is it good?	
  3142 000009A7 7520                    		jnz	short IFERRPJ	; no, error
  3143                                  
  3144                                  ; Find beginning of second string.
  3145                                  
  3146 000009A9 E8CD0F                  		call	SCANOFF
  3147 000009AC 3C0D                    		cmp	al,0Dh
  3148 000009AE 7419                    		jz	short IFERRPJ
  3149 000009B0 5F                      		pop	di
  3150                                  
  3151                                  ; DS:SI points to second string
  3152                                  ; CX has number of chars in first string
  3153                                  ; ES:DI points to first string
  3154                                  
  3155 000009B1 F3A6                    		repe cmpsb
  3156 000009B3 7417                    		jz	short MATCH	; match found!
  3157                                  
  3158                                  ; No match.  Let's find out what was wrong. The character that did not match
  3159                                  ; has been advanced over. Let's back up to it.
  3160                                  
  3161 000009B5 4E                      		dec	si
  3162                                  
  3163                                  ; If it is EOL, then syntax error
  3164                                  
  3165 000009B6 803C0D                  		cmp	byte [si],0Dh
  3166 000009B9 74B8                    		jz	short IFERRJ
  3167                                  
  3168                                  ; Advance pointer over remainder of unmatched text to next delimiter
  3169                                  
  3170                                  SKIPSTRINGEND:
  3171 000009BB AC                      		lodsb
  3172                                  NOTMATCH:
  3173 000009BC 3C0D                    		cmp	al,0Dh
  3174                                  IFERRORJ2:
  3175 000009BE 74B3                    		jz	short IFERRJ
  3176 000009C0 E8BE0F                  		call	DELIM
  3177 000009C3 75F6                    		jnz	short SKIPSTRINGEND
  3178                                  
  3179                                  ; Signal that we did NOT have a match
  3180                                  
  3181 000009C5 B0FF                    		mov	al,-1
  3182 000009C7 EB3A                    		jmp	short IFRET
  3183                                  IFERRPJ:
  3184 000009C9 E95CFF                  		jmp	IFERRORP
  3185                                  
  3186                                  ; The compare succeeded. Was the second string longer than the first?
  3187                                  ; We do this by seeing if the next char is a delimiter.
  3188                                  
  3189                                  MATCH:
  3190 000009CC AC                      		lodsb
  3191 000009CD E8B10F                  		call	DELIM
  3192 000009D0 75EA                    		jnz	short NOTMATCH ; not same.
  3193 000009D2 30C0                    		xor	al,al
  3194 000009D4 EB2D                    		jmp	short IFRET
  3195                                  
  3196                                  ; ---------------------------------------------------------------------------
  3197                                  
  3198                                  IFEXISTS:
  3199                                  
  3200                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
  3201                                  
  3202                                  ;MOREDELIM:
  3203 000009D6 AC                      		lodsb
  3204 000009D7 E8A70F                  		call	DELIM
  3205 000009DA 75FA                    		jnz	short IFEXISTS
  3206                                  		;jnz	short MOREDELIM
  3207                                  
  3208 000009DC BA[6A43]                		mov	dx,DIRBUF
  3209 000009DF B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3210 000009E2 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3211                                  				; DS:DX	-> disk	transfer buffer
  3212 000009E4 BB0200                  		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
  3213 000009E7 031E[F54B]              		add	bx,[IF_NOT_COUNT]
  3214                                  		;mov	ax,ARG_ARGV
  3215                                  		;mov	ax,ARG+ARG_UNIT.argv
  3216 000009EB B8[A945]                		mov	ax,ARG
  3217 000009EE E8E91A                  		call	ARGV_CALC	; convert arg index to pointer
  3218 000009F1 8B17                    		mov	dx,[bx]
  3219                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3220                                  		;mov	cx,6
  3221 000009F3 B90600                  		mov	cx,IFEXIST_ATTR ; filetypes to search for
  3222 000009F6 B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
  3223 000009F9 CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3224                                  				; CX = search attributes
  3225                                  				; DS:DX	-> ASCIZ filespec
  3226                                  				; (drive,path, and wildcards allowed)
  3227 000009FB 7204                    		jc	short IF_EX_C ; carry is how to determine error
  3228 000009FD 30C0                    		xor	al,al
  3229 000009FF EB02                    		jmp	short IFRET
  3230                                  
  3231                                  		;nop
  3232                                  IF_EX_C:
  3233 00000A01 B0FF                    		mov	al,-1		; false 'n' fall through...
  3234                                  IFRET:
  3235 00000A03 F606[8442]FF            		test	byte [IFNOTFLAG],-1 ; 0FFh
  3236 00000A08 7402                    		jz	short REALTEST
  3237 00000A0A F6D0                    		not	al
  3238                                  REALTEST:
  3239 00000A0C 08C0                    		or	al,al
  3240 00000A0E 7403                    		jz	short IFTRUE
  3241 00000A10 E9F1F6                  		jmp	TCOMMAND
  3242                                  
  3243                                  IFTRUE:
  3244 00000A13 E8630F                  		call	SCANOFF
  3245 00000A16 89F1                    		mov	cx,si
  3246 00000A18 81E98100                		sub	cx,81h
  3247 00000A1C 280E8000                		sub	[80h],cl
  3248 00000A20 8A0E8000                		mov	cl,[80h]
  3249 00000A24 880E[D140]              		mov	[COMBUF+1],cl
  3250 00000A28 BF[D240]                		mov	di,COMBUF+2
  3251 00000A2B FC                      		cld
  3252 00000A2C F3A4                    		rep movsb
  3253 00000A2E B00D                    		mov	al,0Dh
  3254 00000A30 AA                      		stosb
  3255                                  
  3256                                  ; Signal that an IF was done. 
  3257                                  ; This prevents the redirections from getting lost.
  3258                                  
  3259 00000A31 1E                      		push	ds
  3260 00000A32 8E1E[7142]              		mov	ds,[RESSEG]
  3261 00000A36 C606F80BFF              		mov	byte [IFFLAG],-1
  3262 00000A3B 1F                      		pop	ds
  3263                                  
  3264                                  ; Go do the command
  3265                                  
  3266 00000A3C E96EF8                  		jmp	DOCOM1
  3267                                  
  3268                                  ; ---------------------------------------------------------------------------
  3269                                  
  3270                                  IFERRORJ3:
  3271 00000A3F E97CFF                  		jmp	IFERRORJ2
  3272                                  
  3273                                  IFERLEV:
  3274 00000A42 B70A                    		mov	bh,10
  3275 00000A44 30DB                    		xor	bl,bl
  3276                                  GETNUMLP:
  3277 00000A46 AC                      		lodsb
  3278 00000A47 3C0D                    		cmp	al,0Dh
  3279 00000A49 74F4                    		jz	short IFERRORJ3
  3280 00000A4B E8330F                  		call	DELIM
  3281 00000A4E 740C                    		jz	short GOTNUM
  3282 00000A50 2C30                    		sub	al,'0'
  3283 00000A52 86C3                    		xchg	al,bl
  3284 00000A54 F6E7                    		mul	bh
  3285 00000A56 00D8                    		add	al,bl
  3286 00000A58 86C3                    		xchg	al,bl
  3287 00000A5A EBEA                    		jmp	short GETNUMLP
  3288                                  GOTNUM:
  3289 00000A5C 1E                      		push	ds
  3290 00000A5D 8E1E[7142]              		mov	ds,[RESSEG]
  3291 00000A61 8A26EA0B                		mov	ah,byte [RETCODE]  ; [0BEAh] in MSDOS 3.3 COMMAND.COM 
  3292 00000A65 1F                      		pop	ds
  3293 00000A66 30C0                    		xor	al,al
  3294 00000A68 38DC                    		cmp	ah,bl
  3295 00000A6A 7397                    		jnb	short IFRET
  3296 00000A6C FEC8                    		dec	al
  3297 00000A6E EB93                    		jmp	short IFRET
  3298                                  
  3299                                  ; ---------------------------------------------------------------------------
  3300                                  
  3301                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
  3302                                  ; This is a NOP if no batch in progress.
  3303                                  
  3304                                  SHIFT:
  3305 00000A70 8E1E[7142]              		mov	ds,[RESSEG]
  3306 00000A74 A1970B                  		mov	ax,word [BATCH]	; get batch pointer
  3307 00000A77 09C0                    		or	ax,ax		; in batch mode?
  3308 00000A79 7501                    		jnz	short SHIFT1	; yes, operate in batch segment	
  3309                                  SHIFT_RETN:				; no, done.
  3310 00000A7B C3                      		retn
  3311                                  SHIFT1:
  3312 00000A7C 8EC0                    		mov	es,ax
  3313 00000A7E 8ED8                    		mov	ds,ax
  3314                                  
  3315                                  ; Now move the batch args down by 1 word
  3316                                  
  3317                                  		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
  3318 00000A80 BF0B00                  		mov	di,BATCHSEGMENT.BatParm ; point to parm table
  3319 00000A83 8D7502                  		lea	si,[di+2]	; make source = dest + 2
  3320 00000A86 B90900                  		mov	cx,9		; move 9 parameters
  3321 00000A89 F3A5                    		rep movsw		; SHIFT down
  3322                                  
  3323                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
  3324                                  ; We have copied it into the previous position.
  3325                                  
  3326 00000A8B 833DFF                  		cmp	word [di],-1	; if last one was not in use then
  3327 00000A8E 74EB                    		jz	short SHIFT_RETN ; No new parm
  3328                                  
  3329                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
  3330                                  ; Assume, first, that there is no next argument.
  3331                                   
  3332 00000A90 8B35                    		mov	si,[di]
  3333 00000A92 C705FFFF                		mov	word [di],-1	; Assume no parm
  3334                                  
  3335                                  ; The parameters are CR separated. Scan for end of this parm.
  3336                                  
  3337                                  SKIPCRLP:
  3338 00000A96 AC                      		lodsb
  3339 00000A97 3C0D                    		cmp	al,0Dh
  3340 00000A99 75FB                    		jnz	short SKIPCRLP
  3341                                  
  3342                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
  3343                                  ; are finished. There are no more parms and the pointer has been previously
  3344                                  ; initialized to indicate it.
  3345                                  
  3346 00000A9B 803C00                  		cmp	byte [si],0
  3347 00000A9E 74DB                    		jz	short SHIFT_RETN ; End of parms
  3348 00000AA0 8935                    		mov	[di],si		; Pointer to next parm as %9
  3349 00000AA2 C3                      		retn
  3350                                  
  3351                                  ; =============== S U B	R O U T	I N E =======================================
  3352                                  
  3353                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
  3354                                  ; returns char in AL, carry set -> eof
  3355                                  
  3356                                  SKIPDELIM:
  3357 00000AA3 F706970BFFFF            		test	word [BATCH],-1	; batch file empty.  OOPS!
  3358 00000AA9 740A                    		jz	short SKIPERR
  3359 00000AAB E8DFFD                  		call	GETBATBYT	; get a char
  3360 00000AAE E8D00E                  		call	DELIM		; check for ignoreable chars
  3361 00000AB1 74F0                    		jz	short SKIPDELIM	; ignore this char.
  3362 00000AB3 F8                      		clc
  3363 00000AB4 C3                      		retn
  3364                                  SKIPERR:
  3365 00000AB5 F9                      		stc
  3366                                  GOTO_RETN:
  3367 00000AB6 C3                      		retn
  3368                                  
  3369                                  ; ---------------------------------------------------------------------------
  3370                                  
  3371                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
  3372                                  ;  .com file. This routine strips the CALL off the command line, sets
  3373                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
  3374                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
  3375                                  ;  being CALLed.
  3376                                  
  3377                                  _$CALL:
  3378                                  
  3379                                  ;  strip off CALL from command line
  3380                                  
  3381                                  		;ASSUME DS:trangroup,ES:trangroup
  3382                                  
  3383 00000AB7 56                      		push	si
  3384 00000AB8 57                      		push	di
  3385 00000AB9 50                      		push	ax
  3386 00000ABA 51                      		push	cx
  3387 00000ABB BE[D240]                		mov	si,COMBUF+2
  3388 00000ABE E8B80E                  		call	SCANOFF		;get to first non-delimeter
  3389                                  		;add	si,4
  3390 00000AC1 83C604                  		add	si,length_call	;point to char past CALL
  3391 00000AC4 BF[D240]                		mov	di,COMBUF+2
  3392                                  		;mov	cx,124		
  3393 00000AC7 B97C00                  		mov	cx,COMBUFLEN-length_call ;get length of buffer
  3394 00000ACA F3A4                    		rep movsb		;move it
  3395 00000ACC 59                      		pop	cx
  3396 00000ACD 58                      		pop	ax
  3397 00000ACE 5F                      		pop	di
  3398 00000ACF 5E                      		pop	si
  3399                                  
  3400                                  ;  set call flag to indicate call in progress
  3401                                  
  3402 00000AD0 1E                      		push	ds
  3403 00000AD1 8E1E[7142]              		mov	ds,[RESSEG]
  3404 00000AD5 C606FE0B01              		mov	byte [CALL_FLAG],call_in_progress ; 1
  3405 00000ADA C606FF0B01              		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1
  3406                                  
  3407                                  ; Turn off any pipes in progress.
  3408                                  
  3409 00000ADF 803E5B0C00              		cmp	byte [PIPEFILES],0 ; Only turn off if present.
  3410 00000AE4 7403                    		jz	short _NOPIPE
  3411 00000AE6 E82D14                  		call	PIPEDEL
  3412                                  _NOPIPE:
  3413 00000AE9 1F                      		pop	ds
  3414 00000AEA C3                      		retn
  3415                                  
  3416                                  ; ---------------------------------------------------------------------------
  3417                                  
  3418                                  GOTO:
  3419 00000AEB 8E1E[7142]              		mov	ds,[RESSEG]
  3420 00000AEF F706970BFFFF            		test	word [BATCH],-1	; If not in batch mode, a nop
  3421 00000AF5 74BF                    		jz	short GOTO_RETN
  3422 00000AF7 31D2                    		xor	dx,dx
  3423 00000AF9 1E                      		push	ds
  3424 00000AFA 8E1E970B                		mov	ds,word [BATCH]
  3425 00000AFE 89160700                		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
  3426 00000B02 89160900                		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
  3427                                  
  3428                                  		; MSDOS 6.0
  3429                                  ;M037
  3430                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
  3431                                  ;
  3432                                  		;mov	ds:BatchEOF,0	; clear eof indicator ;M037
  3433                                  
  3434                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3435                                  
  3436 00000B06 1F                      		pop	ds
  3437                                  GOTOOPEN:
  3438 00000B07 E8ADF9                  		call	PROMPTBAT
  3439                                  		;mov	di,5Dh
  3440 00000B0A BF5D00                  		mov	di,FCB+1	; Get the label
  3441 00000B0D B90B00                  		mov	cx,11
  3442 00000B10 B020                    		mov	al,' '
  3443 00000B12 F2AE                    		repne scasb
  3444 00000B14 7501                    		jnz	short NOINC
  3445 00000B16 41                      		inc	cx
  3446                                  NOINC:
  3447 00000B17 83E90B                  		sub	cx,11
  3448 00000B1A F7D9                    		neg	cx
  3449 00000B1C 2E890E[6A43]            		mov	[cs:GOTOLEN],cx
  3450                                  
  3451                                  ; At beginning of file. Skip to first non-delimiter char
  3452                                  
  3453 00000B21 E87FFF                  		call	SKIPDELIM
  3454 00000B24 721C                    		jb	short BADGOTO
  3455 00000B26 3C3A                    		cmp	al,':'
  3456 00000B28 7423                    		jz	short CHKLABEL
  3457                                  LABLKLP:				; Look for the label
  3458 00000B2A E860FD                  		call	GETBATBYT
  3459 00000B2D 3C0A                    		cmp	al,0Ah
  3460 00000B2F 7509                    		jnz	short LABLKTST
  3461                                  
  3462                                  ; At beginning of line.  Skip to first non-delimiter char
  3463                                  
  3464 00000B31 E86FFF                  		call	SKIPDELIM
  3465 00000B34 720C                    		jb	short BADGOTO
  3466 00000B36 3C3A                    		cmp	al,':'
  3467 00000B38 7413                    		jz	short CHKLABEL
  3468                                  LABLKTST:
  3469 00000B3A F706970BFFFF            		test	word [BATCH],0FFFFh ; -1
  3470 00000B40 75E8                    		jnz	short LABLKLP
  3471                                  BADGOTO:
  3472 00000B42 E85000                  		call	BATCLOSE
  3473                                  
  3474                                  		; MSDOS 6.0
  3475                                  ;SR;
  3476                                  ; At this point we are terminating without freeing up any nested batch 
  3477                                  ;segments i.e if the error occurred within a called batch file. This routine
  3478                                  ;will traverse the linked list of batch segments and free all of them.
  3479                                  ;
  3480                                  		;call	free_batch	;free up nested batch segments
  3481                                  
  3482                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3483 00000B45 0E                      		push	cs
  3484 00000B46 1F                      		pop	ds
  3485 00000B47 BA[673C]                		mov	dx,BADLABPTR
  3486 00000B4A E9DC10                  		jmp	CERROR
  3487                                  
  3488                                  ; Found the :.	Skip to first non-delimiter char
  3489                                  
  3490                                  CHKLABEL:
  3491 00000B4D E853FF                  		call	SKIPDELIM
  3492 00000B50 72F0                    		jb	short BADGOTO
  3493 00000B52 BF5D00                  		mov	di,FCB+1 ; 5Dh
  3494 00000B55 2E8B0E[6A43]            		mov	cx,[cs:GOTOLEN]
  3495 00000B5A EB05                    		jmp	short GOTBYTE
  3496                                  
  3497                                  NEXTCHRLP:
  3498 00000B5C 51                      		push	cx
  3499 00000B5D E82DFD                  		call	GETBATBYT
  3500 00000B60 59                      		pop	cx
  3501                                  GOTBYTE:
  3502 00000B61 0C20                    		or	al,20h
  3503 00000B63 263A05                  		cmp	al,[es:di]
  3504 00000B66 7502                    		jnz	short TRYUPPER
  3505 00000B68 EB07                    		jmp	short NEXTLABCHR
  3506                                  TRYUPPER:
  3507 00000B6A 2C20                    		sub	al,20h
  3508 00000B6C 263A05                  		cmp	al,[es:di]
  3509 00000B6F 75C9                    		jnz	short LABLKTST
  3510                                  NEXTLABCHR:
  3511 00000B71 47                      		inc	di
  3512 00000B72 E2E8                    		loop	NEXTCHRLP
  3513 00000B74 E816FD                  		call	GETBATBYT
  3514 00000B77 2E833E[6A43]08          		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
  3515 00000B7D 7D04                    		jge	short GOTOCONT	; Yes, then the next char doesn't matter
  3516 00000B7F 3C20                    		cmp	al,' '
  3517 00000B81 77B7                    		ja	short LABLKTST
  3518                                  GOTOCONT:
  3519 00000B83 3C0D                    		cmp	al,0Dh
  3520 00000B85 7407                    		jz	short SKIPLFEED
  3521                                  TONEXTBATLIN:
  3522 00000B87 E803FD                  		call	GETBATBYT
  3523 00000B8A 3C0D                    		cmp	al,0Dh
  3524 00000B8C 75F9                    		jnz	short TONEXTBATLIN
  3525                                  SKIPLFEED:
  3526 00000B8E E8FCFC                  		call	GETBATBYT
  3527                                  
  3528                                  		; MSDOS 6.0
  3529                                  ;SR;
  3530                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
  3531                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
  3532                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
  3533                                  ;to get the EOF has not been made yet because we encountered the Goto. On
  3534                                  ;all other cases, EOF will be hit while trying to read the next line and
  3535                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
  3536                                  ;
  3537                                  		;push	es
  3538                                  		;mov	es,Batch
  3539                                  		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
  3540                                  		;pop	es
  3541                                  
  3542                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3543 00000B91 E80100                  		call	BATCLOSE
  3544 00000B94 C3                      		retn
  3545                                  
  3546                                  ; =============== S U B	R O U T	I N E =======================================
  3547                                  
  3548                                  BATCLOSE:
  3549 00000B95 2E8B1E[9545]            		mov	bx,[cs:BATHAND]
  3550 00000B9A 83FB05                  		cmp	bx,5
  3551 00000B9D 7204                    		jb	short CLOSERETURN
  3552 00000B9F B43E                    		mov	ah,CLOSE ; 3Eh
  3553 00000BA1 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  3554                                  				; BX = file handle
  3555                                  CLOSERETURN:
  3556 00000BA3 C606E20B00              		mov	byte [IN_BATCH],0 ; reset flag	
  3557 00000BA8 C3                      		retn
  3558                                  
  3559                                  ; =============== S U B	R O U T	I N E =======================================
  3560                                  
  3561                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
  3562                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
  3563                                  
  3564                                  BATOPEN:
  3565 00000BA9 1E                      		push	ds
  3566 00000BAA 8E1E970B                		mov	ds,word [BATCH]
  3567                                  		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
  3568 00000BAE BA1F00                  		mov	dx,BATCHSEGMENT.BatFile
  3569 00000BB1 B8003D                  		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
  3570 00000BB4 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  3571                                  				; DS:DX	-> ASCIZ filename
  3572                                  				; AL = access mode
  3573                                  				; 0 - read
  3574 00000BB6 721C                    		jb	short SETERRDL
  3575 00000BB8 8B160700                		mov	dx,[BATCHSEGMENT.BatSeek]
  3576 00000BBC 8B0E0900                		mov	cx,[BATCHSEGMENT.BatSeek+2]
  3577 00000BC0 1F                      		pop	ds
  3578 00000BC1 2EA3[9545]              		mov	[cs:BATHAND],ax
  3579 00000BC5 89C3                    		mov	bx,ax
  3580 00000BC7 B80042                  		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
  3581 00000BCA CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  3582                                  				; AL = method: offset from beginning of	file
  3583                                  
  3584 00000BCC 2EC706[184D]FFFF        		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
  3585                                  BATOPEN_RETN:
  3586 00000BD3 C3                      		retn
  3587                                  
  3588                                  SETERRDL:
  3589 00000BD4 89D3                    		mov	bx,dx
  3590                                  		; MSDOS 6.0
  3591                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  3592                                  		;mov	dx,ax		     ;AN022; save extended error in DX
  3593                                  
  3594                                  		; MSDOS 3.3
  3595 00000BD6 BA[9E37]                		mov	dx,INSERTDSKPTR
  3596 00000BD9 E8EE12                  		call	GET_EXT_ERR_NUMBER
  3597                                  
  3598                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3599 00000BDC 8A07                    		mov	al,[bx]		; Get drive spec
  3600 00000BDE 2C40                    		sub	al,'@'		; A = 1
  3601 00000BE0 1F                      		pop	ds
  3602 00000BE1 F9                      		stc			; SUB mucked over carry
  3603 00000BE2 C3                      		retn
  3604                                  
  3605                                  ;============================================================================
  3606                                  ; TFOR.ASM, MSDOS 6.0, 1991
  3607                                  ;============================================================================
  3608                                  ; 10/10/2018 - Retro DOS v3.0
  3609                                  
  3610                                  ; All batch proccessing has DS set to segment of resident portion
  3611                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
  3612                                  
  3613                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h
  3614                                  
  3615                                  ; ---------------------------------------------------------------------------
  3616                                  
  3617                                  FORTERM:
  3618                                  		; MSDOS 6.0
  3619                                  		;push	cs		;AN037; Get local segment into
  3620                                  		;pop	ds		;AN037;    DS, ES
  3621                                  		;push	cs		;AN037;
  3622                                  		;pop	es		;AN037;
  3623                                  
  3624                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3625 00000BE3 E8B502                  		call	FOROFF
  3626 00000BE6 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  3627 00000BEB 813EF30B00FF            		cmp	word [SINGLECOM],0FF00h
  3628 00000BF1 750F                    		jne	short BAT_CRLF
  3629 00000BF3 833EFC0B00              		cmp	word [NEST],0	;See if we have nested batch files
  3630 00000BF8 7508                    		jne	short BAT_CRLF	;Yes - don't exit just yet
  3631 00000BFA C706F30BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
  3632 00000C00 EB12                    		jmp	short NOFORP2
  3633                                  BAT_CRLF:
  3634 00000C02 F606ED0B01              		test	byte [ECHOFLAG],1 ; Is echo on?
  3635 00000C07 740B                    		jz	short NOFORP2	; no - exit
  3636 00000C09 F706970BFFFF            		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
  3637 00000C0F 7403                    		jz	short NOFORP2
  3638 00000C11 E8580D                  		call	CRLF2
  3639                                  NOFORP2:
  3640 00000C14 E9EDF4                  		jmp	TCOMMAND
  3641                                  
  3642                                  ; ---------------------------------------------------------------------------
  3643                                  
  3644                                  ;------
  3645                                  ;   For-loop processing.  For loops are of the form:
  3646                                  ;	    for %<loop-variable> in (<list>) do <command>
  3647                                  ; where <command> may contain references of the form %<variable>, which are
  3648                                  ; later substituted with the items in <list>. The for-loop structure is
  3649                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
  3650                                  ; <command> once for each item in <list>. All of the information needed for
  3651                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
  3652                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
  3653                                  ; a complete copy of the original command-line structure as parsed by
  3654                                  ; 'parseline', loop control variables, and a dma buffer for the
  3655                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
  3656                                  ; processing has completed, this chunk of memory is returned to the system.
  3657                                  ;
  3658                                  ;   All of the previously defined variables, in 'datares', used for loop
  3659                                  ; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
  3660                                  ;
  3661                                  ;   The error message, 'for_alloc_mes', should be moved into the file
  3662                                  ; containing all of the other error messages.
  3663                                  ;
  3664                                  ;   Referencing the allocated for-loop structure is a little tricky.
  3665                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
  3666                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
  3667                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
  3668                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
  3669                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
  3670                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
  3671                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
  3672                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
  3673                                  ; instead of
  3674                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
  3675                                  ; By using 'f', we pretend that we are actually referencing an allocated
  3676                                  ; structure, and the assembler coughs up the code we want. Notice that it
  3677                                  ; doesn't matter whether we put brackets around the location or not -- the
  3678                                  ; assembler is "smart" enough to know that we want an address instead of the
  3679                                  ; contents of that location.
  3680                                  ;
  3681                                  ;   Finally, there now exists the potential to easily implement nested loops.
  3682                                  ; One method would be to have a link field in each for-structure pointing to
  3683                                  ; its parent.  Variable references that couldn't be resolved in the local
  3684                                  ; frame would cause a search of prior frames. For-structures would still be
  3685                                  ; allocated and released in exactly the same fashion. The only limit on the
  3686                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
  3687                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
  3688                                  ; maintained in the resident data area. This structure would be an array of
  3689                                  ; control-variable names and pointers to for-structure blocks. This would
  3690                                  ; greatly speed up the resolution of non-local variable references. However,
  3691                                  ; since space in the resident is precious, we would have to compromise on a
  3692                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
  3693                                  ; allocation and de-allocation would have to be modified slightly to take this
  3694                                  ; new structure into account.
  3695                                  ;
  3696                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
  3697                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
  3698                                  ; it may be easier to allocate it as part of 'for_segment'.
  3699                                  ;------
  3700                                  
  3701                                  		; include fordata.asm
  3702                                  
  3703                                  ; Data structure definitions included by tfor.asm
  3704                                  
  3705                                  struc FOR_INFO
  3706 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  3707 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
  3708 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  3709 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
  3710 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
  3711 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
  3712 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
  3713 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
  3714                                    .size:
  3715                                  endstruc
  3716                                  					; ARG_UNIT.SIZE = 1348 (544h)
  3717                                  
  3718                                  _$FOR_EXIT:
  3719 00000C17 EBCA                    		jmp	short FORTERM	; exceeding maxarg means all done
  3720                                  
  3721                                  ; ---------------------------------------------------------------------------
  3722                                  
  3723                                  FORPROC:
  3724 00000C19 A1FA0B                  		mov	ax,word [FORPTR]
  3725 00000C1C 8ED8                    		mov	ds,ax
  3726 00000C1E 8EC0                    		mov	es,ax		; operate in for-info area
  3727 00000C20 BACB05                  		mov	dx,FOR_INFO.FORDMA
  3728 00000C23 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h
  3729 00000C26 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  3730                                  				; DS:DX	-> disk	transfer buffer
  3731                                  FOR_BEGIN:
  3732 00000C28 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
  3733 00000C2D 7404                    		jz	short FOR_BEGIN1
  3734                                  					; non-zero for_expand equals FALSE
  3735 00000C2F FF064705                		inc	word [FOR_INFO.FOR_MINARG]	; [547h]
  3736                                  
  3737                                  FOR_BEGIN1:
  3738 00000C33 8B1E4705                		mov	bx,word [FOR_INFO.FOR_MINARG]
  3739                                  					; current item in <list> to examine
  3740 00000C37 3B1E4905                		cmp	bx,word [FOR_INFO.FOR_MAXARG]	; [549h]
  3741 00000C3B 7FDA                    		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
  3742                                  		;mov	ax,0
  3743 00000C3D B80000                  		mov	ax,FOR_INFO.FOR_ARGS
  3744 00000C40 E89718                  		call	ARGV_CALC	; compute argv[x] address
  3745                                  		;mov	cx,[bx+3]
  3746 00000C43 8B4F03                  		mov	cx,[bx+ARGV_ELE.argstartel]
  3747 00000C46 8B17                    		mov	dx,[bx]
  3748                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  3749                                  		;test	byte [bx+2],4	; Is there a path separator in this arg?
  3750 00000C48 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  3751 00000C4C 7516                    		jnz	short FORSUB	; Yes, argstartel should be correct
  3752 00000C4E 8B37                    		mov	si,[bx]
  3753                                  		;mov	si,[bx+ARGV_ELE.argpointer]
  3754                                  
  3755 00000C50 2EA0[F53E]              		mov	al,[cs:LPAREN]
  3756 00000C54 3844FF                  		cmp	[si-1],	al	; If the current token is the first
  3757 00000C57 750B                    		jnz	short FORSUB	;  one in the list and originally had
  3758 00000C59 41                      		inc	cx		;  the opening paren as its first char,
  3759                                  					;  the argstartel ptr needs to be
  3760                                  					;  advanced passed it before the prefix
  3761                                  					;  length is computed.
  3762 00000C5A B03A                    		mov	al,':'
  3763 00000C5C 384401                  		cmp	[si+1],	al	; If the token begins with "(d:",
  3764 00000C5F 7503                    		jnz	short FORSUB	;  argstartel has to be moved over the
  3765 00000C61 83C102                  		add	cx,2		;  rest of the prefix as well.
  3766                                  FORSUB:
  3767 00000C64 29D1                    		sub	cx,dx		; compute length of pathname prefix
  3768 00000C66 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
  3769 00000C6B 7416                    		jz	short FOR_FIND_NEXT ; if so, get next matching filename
  3770                                  		;test	byte [bx+2],2
  3771 00000C6D F6470202                		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
  3772 00000C71 7505                    		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
  3773                                  		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
  3774 00000C73 8B4F05                  		mov	cx,[bx+ARGV_ELE.arglen]
  3775 00000C76 EB1F                    		jmp	short FOR_SMOOSH
  3776                                  
  3777                                  		;nop
  3778                                  FOR_FIND_FIRST:
  3779 00000C78 51                      		push	cx
  3780 00000C79 31C9                    		xor	cx,cx
  3781 00000C7B B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h
  3782 00000C7E CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  3783                                  				; CX = search attributes
  3784                                  				; DS:DX	-> ASCIZ filespec
  3785                                  				; (drive,path, and wildcards allowed)
  3786 00000C80 59                      		pop	cx
  3787 00000C81 EB05                    		jmp	short FOR_RESULT
  3788                                  
  3789                                  		;nop
  3790                                  FOR_FIND_NEXT:
  3791 00000C83 B8004F                  		mov	ax,FIND_NEXT*256 ;4F00h
  3792 00000C86 CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
  3793                                  				; [DTA]	= data block from
  3794                                  				; last AH = 4Eh/4Fh call
  3795                                  FOR_RESULT:
  3796 00000C88 B8FFFF                  		mov	ax,-1 ; 0FFFFh	; assume worst case
  3797 00000C8B 7203                    		jc	short FOR_CHECK
  3798 00000C8D B80000                  		mov	ax,0		; Find* returns 0 for SUCCESS
  3799                                  FOR_CHECK:				; record success of findfirst/next
  3800 00000C90 A34505                  		mov	word [FOR_INFO.FOR_EXPAND],ax
  3801 00000C93 09C0                    		or	ax,ax	; anything out there?
  3802 00000C95 7591                    		jnz	short FOR_BEGIN	; if not, try next arg
  3803                                  FOR_SMOOSH:
  3804                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  3805 00000C97 8B37                    		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
  3806 00000C99 BF4B05                  		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
  3807 00000C9C F3A4                    		rep movsb		; arg, some days just the path prefix
  3808                                  					
  3809 00000C9E 833E450500              		cmp	word [FOR_INFO.FOR_EXPAND],0
  3810                                  					; if we're not expanding, we can
  3811 00000CA3 750B                    		jnz	short FOR_MAKE_COM ; skip the following	
  3812                                  
  3813                                  		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
  3814 00000CA5 BEE905                  		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
  3815                                  FOR_MORE:
  3816 00000CA8 803C00                  		cmp	byte [si],0	; tack on matching filename
  3817 00000CAB 7403                    		jz	short FOR_MAKE_COM
  3818 00000CAD A4                      		movsb
  3819 00000CAE 75F8                    		jnz	short FOR_MORE
  3820                                  FOR_MAKE_COM:
  3821 00000CB0 30C0                    		xor	al,al		; tack a null byte onto the end
  3822 00000CB2 AA                      		stosb			; of the substitute string
  3823 00000CB3 31C9                    		xor	cx,cx		; character count for command line
  3824 00000CB5 F7D1                    		not	cx		; negate it -- take advantage of loopnz
  3825 00000CB7 31DB                    		xor	bx,bx		; argpointer
  3826 00000CB9 BF[D240]                		mov	di,COMBUF+2
  3827 00000CBC 8A1E4405                		mov	bl,byte [FOR_INFO.FOR_COM_START] ; argindex
  3828 00000CC0 8A364B06                		mov	dh,byte [FOR_INFO.FOR_VAR] 
  3829                                  					; %<for-var> is replaced by [forbuf]
  3830 00000CC4 0E                      		push	cs		; time to form the <command> string
  3831 00000CC5 07                      		pop	es
  3832                                  		;assume ES:trangroup
  3833                                  		;mov	ax,FOR_INFO.FOR_ARGS
  3834 00000CC6 B80000                  		mov	ax,0		; translate offset to pointer
  3835 00000CC9 E80E18                  		call	ARGV_CALC
  3836                                  		;mov	si,[bx+9]
  3837 00000CCC 8B7709                  		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
  3838                                  					; mov ptr passed beginning space
  3839 00000CCF 46                      		inc	si
  3840                                  FOR_MAKE_LOOP:
  3841 00000CD0 8A04                    		mov	al,[si]		; the <command> arg, byte by byte
  3842 00000CD2 46                      		inc	si
  3843 00000CD3 3C25                    		cmp	al,'%'		; looking for %<control-variable>
  3844 00000CD5 7514                    		jnz	short FOR_STOSB ; no % ... add byte to string
  3845 00000CD7 3834                    		cmp	[si],dh		; got the right <variable>?
  3846 00000CD9 7510                    		jnz	short FOR_STOSB	; got a %, but wrong <variable>
  3847 00000CDB 46                      		inc	si		; skip over <for-variable>
  3848                                  
  3849 00000CDC 56                      		push	si
  3850 00000CDD BE4B05                  		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
  3851                                  					; to make a final <command> to execute
  3852                                  SLOOP:					
  3853 00000CE0 AC                      		lodsb			; grab all those <item> bytes, and
  3854 00000CE1 AA                      		stosb			; add 'em to the <command> string,
  3855 00000CE2 08C0                    		or	al,al		; until we run into a null
  3856 00000CE4 E0FA                    		loopne	SLOOP
  3857 00000CE6 4F                      		dec	di		; adjust length and <command> pointer
  3858 00000CE7 41                      		inc	cx		; so we can overwrite the null
  3859 00000CE8 5E                      		pop	si
  3860 00000CE9 EBE5                    		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes
  3861                                  
  3862                                  FOR_STOSB:
  3863 00000CEB AA                      		stosb			; take a byte from the <command> arg
  3864 00000CEC 49                      		dec	cx		; and put it into the <command> to be
  3865                                  					; executed (and note length, too)
  3866 00000CED 3C0D                    		cmp	al,0Dh		
  3867 00000CEF 75DF                    		jnz	short FOR_MAKE_LOOP ; If not done, loop.
  3868                                  FOR_MADE_COM:
  3869 00000CF1 F6D1                    		not	cl
  3870 00000CF3 2E880E[D140]            		mov	[cs:COMBUF+1],cl
  3871                                  
  3872 00000CF8 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  3873                                  		;assume DS:resgroup
  3874 00000CFD F606ED0B01              		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
  3875 00000D02 742F                    		jz	short NOECHO3
  3876                                  		;cmp	byte [NULLFLAG],nullcommand
  3877 00000D04 803E020C01              		cmp	byte [NULLFLAG],1 ;G was there a command last time?
  3878 00000D09 7403                    		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	
  3879                                  
  3880 00000D0B E85E0C                  		call	CRLF2		  ;G  Print out prompt
  3881                                  NO_CRLF_PR:
  3882 00000D0E C606020C00              		mov	byte [NULLFLAG],0 ;G reset no command flag
  3883 00000D13 0E                      		push	cs
  3884 00000D14 1F                      		pop	ds
  3885 00000D15 57                      		push	di
  3886 00000D16 E87106                  		call	PRINT_PROMPT	  ;G Prompt the user
  3887 00000D19 5F                      		pop	di
  3888                                  
  3889 00000D1A 26C645FF00              		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
  3890 00000D1F C706[4E44][D240]        		mov	word [STRING_PTR_2],COMBUF+2
  3891 00000D25 BA[3F37]                		mov	dx,STRINGBUF2PTR
  3892 00000D28 E8A827                  		call	STD_PRINTF
  3893 00000D2B 26C645FF0D              		mov	byte [es:di-1],0Dh
  3894 00000D30 E977F5                  		jmp	DOCOM		  ; run silent, run deep...
  3895                                  NOECHO3:
  3896 00000D33 C606020C00              		mov	byte [NULLFLAG],0
  3897 00000D38 0E                      		push	cs
  3898 00000D39 1F                      		pop	ds
  3899 00000D3A E970F5                  		jmp	DOCOM1
  3900                                  
  3901                                  FORNESTERRJ:				; no multi-loop processing... yet!		
  3902 00000D3D E85B01                  		call	FOROFF
  3903 00000D40 E93E01                  		jmp	FORNESTERR
  3904                                  
  3905                                  ; ---------------------------------------------------------------------------
  3906                                  
  3907                                  FORERRORJ:
  3908 00000D43 E9E3FB                  		jmp	FORERROR
  3909                                  
  3910                                  ; ---------------------------------------------------------------------------
  3911                                  
  3912                                  _$FOR:
  3913 00000D46 8E06[7142]              		mov	es,[RESSEG]
  3914 00000D4A 26803EF90B00            		cmp	byte [es:FORFLAG],0 ; is another one already running?
  3915 00000D50 75EB                    		jnz	short FORNESTERRJ   ; if flag is set.... boom!
  3916                                  
  3917                                  ; Turn off any pipes in progress.
  3918                                  
  3919 00000D52 26803E5B0C00            		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
  3920 00000D58 7403                    		jz	short NO_PIPE
  3921 00000D5A E8B911                  		call	PIPEDEL
  3922                                  NO_PIPE:
  3923 00000D5D 31D2                    		xor	dx,dx		; counter (0 <= DX < argvcnt)
  3924 00000D5F E80901                  		call	NEXTARG		; move to next argv[n]
  3925 00000D62 72DF                    		jc	short FORERRORJ	; no more args -- bad forloop
  3926 00000D64 3C25                    		cmp	al,'%'		; next arg MUST start with '%'...
  3927 00000D66 75DB                    		jnz	short FORERRORJ
  3928 00000D68 89C5                    		mov	bp,ax		; save forloop variable
  3929 00000D6A AC                      		lodsb
  3930 00000D6B 08C0                    		or	al,al		; and MUST end immediately...
  3931 00000D6D 75D4                    		jnz	short FORERRORJ
  3932 00000D6F E8F900                  		call	NEXTARG		; let's make sure the next arg is 'in'
  3933 00000D72 72CF                    		jb	short FORERRORJ
  3934                                  		;and	ax,0DFDFh
  3935 00000D74 25DFDF                  		and	ax,~2020h	; uppercase the letters
  3936 00000D77 3B06[F93E]              		cmp	ax,word [IN_WORD]
  3937 00000D7B 75C6                    		jnz	short FORERRORJ
  3938 00000D7D AC                      		lodsb
  3939                                  
  3940                                  		; MSDOS 3.3
  3941 00000D7E 08C0                    		or	al,al		; it, too, must end right away
  3942 00000D80 7416                    		jz	short CHECKLPAREN
  3943 00000D82 3A06[F53E]              		cmp	al,[LPAREN]
  3944 00000D86 75BB                    		jnz	short FORERRORJ
  3945                                  		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
  3946 00000D88 830702                  		add	word [bx],2
  3947                                  		;add	word [bx+9],2
  3948 00000D8B 83470902                		add	word [bx+ARGV_ELE.arg_ocomptr],2
  3949                                  		;sub	word [bx+5],2
  3950 00000D8F 836F0502                		sub	word [bx+ARGV_ELE.arglen],2
  3951 00000D93 8B44FF                  		mov	ax,[si-1]
  3952 00000D96 EB05                    		jmp	short LPCHECK
  3953                                  
  3954                                  		; MSDOS 6.0
  3955                                  ;; Compaq bug fix -- exit from this loop on error
  3956                                  ;
  3957                                  ;		or	al,al
  3958                                  ;		jne	forerrorj	; jump on error
  3959                                  ;
  3960                                  ;;;		je	CheckLParen
  3961                                  ;;
  3962                                  ;; Not null.  Perhaps there are no spaces between this and the (:
  3963                                  ;;   FOR %i in(foo bar...
  3964                                  ;; Check for the Lparen here
  3965                                  ;;
  3966                                  ;;;		CMP	AL,lparen
  3967                                  ;;;		JNZ	forerrorj
  3968                                  ;;
  3969                                  ;; The token was in(...	We strip off the "in" part to simulate a separator
  3970                                  ;; being there in the first place.
  3971                                  ;;
  3972                                  ;;;		ADD	[BX].argpointer,2  ; advance source pointer
  3973                                  ;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
  3974                                  ;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
  3975                                  ;;
  3976                                  ;; SI now points past the in(.  Simulate a nextarg call that results in the
  3977                                  ;; current value.
  3978                                  ;;
  3979                                  ;;;		MOV	ax,[si-1]	; get lparen and next char
  3980                                  ;;;		jmp	short lpcheck
  3981                                  ;;
  3982                                  ;; end of Compaq bug fix
  3983                                  
  3984                                  ; ---------------------------------------------------------------------------
  3985                                  
  3986                                  		; MSDOS 3.3 (& MSDOS 6.0)
  3987                                  CHECKLPAREN:
  3988 00000D98 E8D000                  		call	NEXTARG		; lparen delimits beginning of <list>
  3989 00000D9B 72A6                    		jc	short FORERRORJ
  3990                                  LPCHECK:
  3991 00000D9D 3A06[F53E]              		cmp	al,[LPAREN]
  3992 00000DA1 75A0                    		jne	short FORERRORJ
  3993 00000DA3 80FC00                  		cmp	ah,0
  3994 00000DA6 7411                    		je	short FOR_PAREN_TOKEN
  3995 00000DA8 3A26[F63E]              		cmp	ah,byte [RPAREN] ; special case:  null list	
  3996 00000DAC 7503                    		jne	short FOR_LIST_NOT_EMPTY
  3997 00000DAE E932FE                  		jmp	FORTERM
  3998                                  FOR_LIST_NOT_EMPTY:
  3999                                  		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
  4000 00000DB1 FF07                    		inc	word [bx]	; Advance ptr past "("
  4001                                  		;dec	word [bx+5]	; Adjust the rest of this argv entry	
  4002 00000DB3 FF4F05                  		dec	word [bx+ARGV_ELE.arglen] 	;  to agree.
  4003 00000DB6 46                      		inc	si		; Inc si so check for ")" works
  4004 00000DB7 EB11                    		jmp	short FOR_LIST
  4005                                  
  4006                                  		;nop
  4007                                  FOR_PAREN_TOKEN:
  4008 00000DB9 E8AF00                  		call	NEXTARG		; what have we in our <list>?
  4009 00000DBC 7285                    		jc	short FORERRORJ
  4010                                  		;cmp	ax,[RPAREN+1]	
  4011 00000DBE 3B06[F73E]              		cmp	ax,[NULLRPAREN]	; special case:  null list
  4012 00000DC2 7506                    		jne	short FOR_LIST
  4013 00000DC4 E91CFE                  		jmp	FORTERM
  4014                                  
  4015                                  FORERORJJ:
  4016 00000DC7 E95FFB                  		jmp	FORERROR
  4017                                  
  4018                                  FOR_LIST:				; skip over rest of <list>
  4019 00000DCA 89D1                    		mov	cx,dx		; first arg of <list>
  4020                                  
  4021                                  SKIP_LIST:
  4022                                  		;add	si,[bx+5]
  4023 00000DCC 037705                  		add	si,[bx+ARGV_ELE.arglen]
  4024 00000DCF 83EE03                  		sub	si,3		; si = ptr to last char of token
  4025 00000DD2 A0[F63E]                		mov	al,byte [RPAREN]
  4026 00000DD5 3804                    		cmp	[si],al		; Is this the last element in <list>
  4027 00000DD7 7407                    		je	short FOR_END_LIST ; Yes, exit loop.
  4028 00000DD9 E88F00                  		call	NEXTARG		; No, get next arg <list>
  4029 00000DDC 72E9                    		jc	short FORERORJJ	; If no more and no rparen, error.
  4030 00000DDE EBEC                    		jmp	short SKIP_LIST
  4031                                  
  4032                                  FOR_END_LIST:
  4033 00000DE0 89D7                    		mov	di,dx		; record position of last arg in <list>
  4034 00000DE2 C60400                  		mov	byte [si],0	; Zap the rparen
  4035                                  		;cmp	ax,[RPAREN+1]	
  4036 00000DE5 3B06[F73E]              		cmp	ax,[NULLRPAREN] ; Was this token only a rparen
  4037 00000DE9 7401                    		je	short FOR_DO	; Yes, continue
  4038 00000DEB 47                      		inc	di		; No, inc position of last arg
  4039                                  FOR_DO:
  4040 00000DEC E87C00                  		call	NEXTARG		; now we had BETTER find a 'do'...
  4041 00000DEF 72D6                    		jc	short FORERORJJ
  4042                                  		;and	ax,0DFDFh	
  4043 00000DF1 25DFDF                  		and	ax,~2020h	; uppercase the letters
  4044 00000DF4 3B06[FB3E]              		cmp	ax,word [DO_WORD]
  4045 00000DF8 75CD                    		jne	short FORERORJJ
  4046 00000DFA AC                      		lodsb
  4047 00000DFB 08C0                    		or	al,al		; and it had BETTER be ONLY a 'do'...
  4048 00000DFD 75C8                    		jnz	short FORERORJJ
  4049                                  		
  4050 00000DFF E86900                  		call	NEXTARG		; on to the beginning of <command>
  4051 00000E02 72C3                    		jc	short FORERORJJ	; null <command> not legal
  4052                                  
  4053 00000E04 50                      		push	ax
  4054 00000E05 53                      		push	bx
  4055 00000E06 51                      		push	cx
  4056 00000E07 52                      		push	dx		; preserve registers against disaster
  4057 00000E08 57                      		push	di
  4058 00000E09 56                      		push	si
  4059 00000E0A 55                      		push	bp
  4060 00000E0B E852F8                  		call	FREE_TPA	; need to make free memory, first
  4061 00000E0E E88A00                  		call	FOROFF
  4062                                  		;mov	bx,264
  4063 00000E11 BB0801                  		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
  4064 00000E14 E8A519                  		call	SAVE_ARGS	; extra bytes needed for for-info
  4065 00000E17 9C                      		pushf
  4066 00000E18 26A3FA0B                		mov	word [es:FORPTR],ax
  4067 00000E1C E851F8                  		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
  4068 00000E1F 9D                      		popf
  4069 00000E20 5D                      		pop	bp
  4070 00000E21 5E                      		pop	si
  4071 00000E22 5F                      		pop	di
  4072 00000E23 5A                      		pop	dx
  4073 00000E24 59                      		pop	cx
  4074 00000E25 5B                      		pop	bx
  4075 00000E26 58                      		pop	ax
  4076 00000E27 723C                    		jc	short FOR_ALLOC_ERR
  4077                                  
  4078 00000E29 06                      		push	es		; save resgroup seg...
  4079 00000E2A 26FF36FA0B              		push	word [es:FORPTR]
  4080 00000E2F 07                      		pop	es
  4081                                  		;assume ES:for_segment	
  4082 00000E30 49                      		dec	cx		; forproc wants min pointing before
  4083 00000E31 4F                      		dec	di		; first arg, max right at last one
  4084 00000E32 26890E4705              		mov	word [es:FOR_INFO.FOR_MINARG],cx
  4085 00000E37 26893E4905              		mov	word [es:FOR_INFO.FOR_MAXARG],di
  4086 00000E3C 2688164405              		mov	byte [es:FOR_INFO.FOR_COM_START],dl
  4087 00000E41 26C7064505FFFF          		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
  4088 00000E48 89E8                    		mov	ax,bp
  4089 00000E4A 2688264B06              		mov	byte [es:FOR_INFO.FOR_VAR],ah
  4090 00000E4F 07                      		pop	es
  4091                                  		;assume ES:resgroup	
  4092 00000E50 26FE06F90B              		inc	byte [es:FORFLAG]
  4093 00000E55 26833EF30BFF            		cmp	word [es:SINGLECOM],-1
  4094 00000E5B 7507                    		jne	short FOR_RET
  4095 00000E5D 26C706F30B00FF          		mov	word [es:SINGLECOM],0FF00h
  4096                                  FOR_RET:
  4097 00000E64 C3                      		retn
  4098                                  
  4099                                  FOR_ALLOC_ERR:
  4100                                  		; MSDOS 3.0
  4101 00000E65 BA[AA3C]                		mov	dx,INSFMEMMESPTR
  4102 00000E68 E9BE0D                  		jmp	CERROR
  4103                                  
  4104                                  		; MSDOS 6.0
  4105                                  		;mov	msg_disp_class,ext_msg_class	
  4106                                  		;			;AN000; set up extended error msg class
  4107                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr     
  4108                                  		;			;AC000; get extended message pointer
  4109                                  		;mov	Extend_Buf_ptr,error_not_enough_memory 
  4110                                  		;			;AN000; get message number in control block
  4111                                  		;jmp	cerror
  4112                                  
  4113                                  
  4114                                  ; =============== S U B	R O U T	I N E =======================================
  4115                                  
  4116                                  NEXTARG:
  4117 00000E6B 42                      		inc	dx		; next argv[n]
  4118                                  		;cmp	dx,[ARG_ARGVCNT]
  4119 00000E6C 3B16[6948]              		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
  4120 00000E70 7D0D                    		jge	short NEXTARG_ERR ; of argv[]...	
  4121 00000E72 89D3                    		mov	bx,dx
  4122                                  		;mov	ax,ARG_ARGV
  4123                                  		;mov	ax,ARG+ARG_UNIT.argv
  4124 00000E74 B8[A945]                		mov	ax,ARG
  4125 00000E77 E86016                  		call	ARGV_CALC	; convert array index to pointer
  4126 00000E7A 8B37                    		mov	si,[bx]		; load pointer to argstring
  4127                                  		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
  4128 00000E7C AD                      		lodsw			; and load first two chars
  4129 00000E7D F8                      		clc
  4130 00000E7E C3                      		retn
  4131                                  NEXTARG_ERR:
  4132 00000E7F F9                      		stc
  4133 00000E80 C3                      		retn
  4134                                  
  4135                                  ; ---------------------------------------------------------------------------
  4136                                  
  4137                                  FORNESTERR:
  4138 00000E81 1E                      		push	ds
  4139 00000E82 8E1E[7142]              		mov	ds,[RESSEG]
  4140                                  		;ASSUME DS:RESGROUP
  4141 00000E86 BA[923C]                		mov	dx,FORNESTMESTR
  4142 00000E89 813EF30B00FF            		cmp	word [SINGLECOM],0FF00h
  4143 00000E8F 7506                    		jnz	short NOFORP3
  4144 00000E91 C706F30BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
  4145                                  NOFORP3:
  4146 00000E97 1F                      		pop	ds
  4147 00000E98 E98E0D                  		jmp	CERROR
  4148                                  
  4149                                  ; =============== S U B	R O U T	I N E =======================================
  4150                                  
  4151                                  ; General routine called to free the for segment. We also clear the forflag
  4152                                  ; too. Change no registers.
  4153                                  
  4154                                  FOROFF:
  4155 00000E9B 50                      		push	ax
  4156 00000E9C 06                      		push	es
  4157 00000E9D 2E8E06[7142]            		mov	es,[cs:RESSEG]
  4158 00000EA2 26A1FA0B                		mov	ax,word [es:FORPTR]
  4159 00000EA6 09C0                    		or	ax,ax
  4160 00000EA8 7408                    		jz	short FREEDONE
  4161 00000EAA 06                      		push	es
  4162 00000EAB 8EC0                    		mov	es,ax
  4163 00000EAD B449                    		mov	ah,DEALLOC ; 49h
  4164 00000EAF CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  4165                                  				; ES = segment address of area to be freed
  4166 00000EB1 07                      		pop	es
  4167                                  FREEDONE:
  4168 00000EB2 26C706FA0B0000          		mov	word [es:FORPTR],0
  4169 00000EB9 26C606F90B00            		mov	byte [es:FORFLAG],0
  4170 00000EBF 07                      		pop	es
  4171 00000EC0 58                      		pop	ax
  4172 00000EC1 C3                      		retn
  4173                                  
  4174                                  ;============================================================================
  4175                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
  4176                                  ;============================================================================
  4177                                  ; 09/10/2018 - Retro DOS v3.0
  4178                                  
  4179                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
  4180                                  
  4181                                  ; ---------------------------------------------------------------------------
  4182                                  
  4183                                  ; The DIR command displays the contents of a directory.
  4184                                  ;
  4185                                  ; ****************************************************************
  4186                                  ; *
  4187                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
  4188                                  ; *
  4189                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
  4190                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
  4191                                  ; *		 If an error occurs issue and error message and
  4192                                  ; *		 transfer control to CERROR.
  4193                                  ; *
  4194                                  ; * INPUT:	 command line at offset 81H
  4195                                  ; *
  4196                                  ; * OUTPUT:	 none
  4197                                  ; *
  4198                                  ; ****************************************************************
  4199                                  
  4200                                  CATALOG:
  4201                                  		; MSDOS 3.3
  4202                                  
  4203                                  		;mov	ax,ARG_ARGV
  4204                                  		;mov	ax,ARG+ARG_UNIT.argv
  4205 00000EC2 B8[A945]                		mov	ax,ARG
  4206 00000EC5 BAFFFF                  		mov	dx,0FFFFh
  4207 00000EC8 31C9                    		xor	cx,cx
  4208 00000ECA 31F6                    		xor	si,si
  4209                                  
  4210                                  DIR1:
  4211                                  		;cmp	cx,[ARG_ARGVCNT]
  4212 00000ECC 3B0E[6948]              		cmp	cx,[ARG+ARG_UNIT.argvcnt]
  4213 00000ED0 733F                    		jnb	short DIR6 ; No more arguments
  4214 00000ED2 89CB                    		mov	bx,cx
  4215 00000ED4 E80316                  		call	ARGV_CALC
  4216                                  		;or	si,[bx+7]
  4217 00000ED7 0B7707                  		or	si,[bx+ARGV_ELE.argsw_word]
  4218 00000EDA F7C6FC7F                		test	si,7FFCh  ; test si,~8003
  4219 00000EDE 7508                    		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
  4220                                  		;test	byte [bx+2],1
  4221 00000EE0 F6470201                		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
  4222 00000EE4 7408                    		jz	short DIR3
  4223 00000EE6 EB26                    		jmp	short DIR5
  4224                                  DIR2:
  4225 00000EE8 BA[223A]                		mov	dx,BADPARMPTR
  4226 00000EEB E93B0D                  		jmp	CERROR
  4227                                  DIR3:
  4228 00000EEE 09C9                    		or	cx,cx
  4229 00000EF0 7515                    		jnz	short DIR4	
  4230                                  		;cmp	word [bx+5],3
  4231 00000EF2 837F0503                		cmp	word [bx+ARGV_ELE.arglen],3
  4232 00000EF6 7416                    		jz	short DIR5
  4233                                  		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
  4234 00000EF8 830703                  		add	word [bx],3
  4235                                  		;add	word [bx+9],3
  4236 00000EFB 83470903                		add	word [bx+ARGV_ELE.arg_ocomptr],3
  4237                                  		;add	word [bx+3],3
  4238 00000EFF 83470303                		add	word [bx+ARGV_ELE.argstartel],3
  4239                                  		;sub	word [bx+5],3
  4240 00000F03 836F0503                		sub	word [bx+ARGV_ELE.arglen],3
  4241                                  DIR4:
  4242 00000F07 83FAFF                  		cmp	dx,0FFFFh
  4243 00000F0A 75DC                    		jnz	short DIR2
  4244 00000F0C 89DA                    		mov	dx,bx
  4245                                  
  4246 00000F0E 41                      DIR5:		inc	cx
  4247 00000F0F EBBB                    		jmp	short DIR1
  4248                                  DIR6:
  4249 00000F11 8936[8842]              		mov	[COMSW],si
  4250 00000F15 52                      		push	dx
  4251 00000F16 30C0                    		xor	al,al
  4252 00000F18 83FAFF                  		cmp	dx,0FFFFh
  4253 00000F1B 7410                    		jz	short DIR7
  4254 00000F1D 89D3                    		mov	bx,dx
  4255                                  		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
  4256 00000F1F 8B3F                    		mov	di,[bx]
  4257 00000F21 807D013A                		cmp	byte [di+1],':'
  4258 00000F25 7506                    		jnz	short DIR7
  4259 00000F27 8A05                    		mov	al,[di]
  4260 00000F29 0C20                    		or	al,20h		; Lowercase drive name	
  4261 00000F2B 2C60                    		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
  4262                                  DIR7:
  4263                                  		;mov	[5CH],al
  4264 00000F2D A25C00                  		mov	[FCB],al
  4265 00000F30 E80A04                  		call	OKVOLARG
  4266 00000F33 B03F                    		mov	al,'?'		; *.* is default file spec.
  4267                                  		;mov	di,5Dh
  4268 00000F35 BF5D00                  		mov	di,FCB+1
  4269 00000F38 B90B00                  		mov	cx,11
  4270 00000F3B F3AA                    		rep stosb
  4271                                  
  4272                                  ; Begin by processing any switches that may have been specified.
  4273                                  ; BITS will contain any information about switches that was
  4274                                  ; found when the command line was parsed.
  4275                                  
  4276 00000F3D A1[8842]                		mov	ax,[COMSW]	; Get switches from command
  4277 00000F40 A3[BC43]                		mov	word [_BITS],ax	; initialize switches
  4278 00000F43 C706[8842]0000          		mov	word [COMSW],0	; initialize flags
  4279 00000F49 C606[C443]17            		mov	byte [LINPERPAG],23 ; Set default for lines per page
  4280                                  		;test	al,1
  4281 00000F4E A801                    		test	al,SWITCHW	; /W ?
  4282                                  		;mov	al,1
  4283 00000F50 B001                    		mov	al,NORMPERLIN
  4284 00000F52 7402                    		jz	short DIR8
  4285                                  		;mov	al,5
  4286 00000F54 B005                    		mov	al,WIDEPERLIN
  4287                                  DIR8:
  4288 00000F56 A2[9842]                		mov	[LINLEN],al	; Set number of entries per line
  4289 00000F59 A2[9742]                		mov	[LINCNT],al
  4290 00000F5C C706[9942]0000          		mov	word [FILECNT],0 ; Keep track of how many files found
  4291 00000F62 BA[6A43]                		mov	dx,DIRBUF
  4292 00000F65 B41A                    		mov	ah,SET_DMA ; 1Ah
  4293 00000F67 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  4294                                  				; DS:DX	-> disk	transfer buffer
  4295                                  		;mov	dl,[5Ch]
  4296 00000F69 8A165C00                		mov	dl,[FCB]
  4297 00000F6D E8D609                  		call	SAVUDIR
  4298 00000F70 5B                      		pop	bx
  4299 00000F71 83FBFF                  		cmp	bx,0FFFFh
  4300 00000F74 7415                    		jz	short DIR9
  4301                                  		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
  4302 00000F76 8B17                    		mov	dx,[bx]
  4303                                  
  4304                                  ; The user may have specified a device. Search for the path and see if the
  4305                                  ; attributes indicate a device.
  4306                                  
  4307 00000F78 B44E                    		mov	ah,FIND_FIRST ; 4Eh
  4308 00000F7A CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
  4309                                  				; CX = search attributes
  4310                                  				; DS:DX	-> ASCIZ filespec
  4311                                  				; (drive,path, and wildcards allowed)
  4312 00000F7C 720F                    		jc	short DIR10
  4313                                  				; Check device atrribute..
  4314                                  		;test	byte [DIRBUF_ATTRIB2],40h
  4315                                  		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
  4316                                  		; 14/10/2018
  4317                                  		;test	byte [DIRBUF+21],40h
  4318 00000F7E F606[7F43]40            		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
  4319 00000F83 7408                    		jz	short DIR10	; no, go do normal operation
  4320 00000F85 C706[8842]FEFF          		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
  4321                                  DIR9:
  4322 00000F8B EB7B                    		jmp	short DOHEADER
  4323                                  DIR10:
  4324                                  		;mov	dx,[bx+ARGV_ELE.argpointer]
  4325 00000F8D 8B17                    		mov	dx,[bx]
  4326 00000F8F B43B                    		mov	ah,CHDIR ; 3Bh
  4327 00000F91 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4328                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4329 00000F93 7373                    		jnc	short DOHEADER
  4330                                  		;mov	si,[bx+3]
  4331 00000F95 8B7703                  		mov	si,[bx+ARGV_ELE.argstartel]
  4332 00000F98 39F2                    		cmp	dx,si
  4333 00000F9A 7449                    		jz	short DIR_NO_DRIVE
  4334 00000F9C 30C9                    		xor	cl,cl
  4335 00000F9E 860C                    		xchg	cl,[si]
  4336 00000FA0 B43B                    		mov	ah,CHDIR ; 3Bh
  4337 00000FA2 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4338                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4339 00000FA4 860C                    		xchg	cl,[si]
  4340 00000FA6 733D                    		jnc	short DIR_NO_DRIVE
  4341 00000FA8 8A44FF                  		mov	al,[si-1]
  4342 00000FAB E85E0A                  		call	PATHCHRCMP
  4343 00000FAE 7514                    		jnz	short DIR11
  4344 00000FB0 8A44FE                  		mov	al,[si-2]
  4345 00000FB3 E8560A                  		call	PATHCHRCMP
  4346 00000FB6 741E                    		jz	short DIR12
  4347 00000FB8 864CFF                  		xchg	cl,[si-1]
  4348 00000FBB B43B                    		mov	ah,CHDIR ; 3Bh
  4349 00000FBD CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  4350                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  4351 00000FBF 864CFF                  		xchg	cl,[si-1]
  4352 00000FC2 7321                    		jnc	short DIR_NO_DRIVE
  4353                                  DIR11:
  4354 00000FC4 B53A                    		mov	ch,':'
  4355 00000FC6 3A6CFF                  		cmp	ch,[si-1]
  4356 00000FC9 750B                    		jnz	short DIR12
  4357                                  		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
  4358 00000FCB 8B0F                    		mov	cx,[bx]
  4359 00000FCD 87CE                    		xchg	cx,si
  4360 00000FCF 29F1                    		sub	cx,si
  4361 00000FD1 83F902                  		cmp	cx,2
  4362 00000FD4 740F                    		jz	short DIR_NO_DRIVE
  4363                                  DIR12:
  4364 00000FD6 BA[763B]                		mov	dx,BADCDPTR
  4365                                  		;test	byte [bx+2],4
  4366 00000FD9 F6470204                		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
  4367 00000FDD 7503                    		jnz	short DIRERROR
  4368                                  DIRNF:
  4369 00000FDF BA[F837]                		mov	dx,FNOTFOUNDPTR
  4370                                  DIRERROR:
  4371 00000FE2 E9440C                  		jmp	CERROR
  4372                                  DIR_NO_DRIVE:
  4373 00000FE5 813C2E2E                		cmp	word [si],'..'
  4374 00000FE9 750C                    		jnz	short DOREALPARSE
  4375 00000FEB 807C0200                		cmp	byte [si+2],0
  4376 00000FEF 7506                    		jnz	short DOREALPARSE
  4377 00000FF1 FF06[8842]              		inc	word [COMSW]
  4378 00000FF5 EB11                    		jmp	short DOHEADER
  4379                                  DOREALPARSE:
  4380 00000FF7 BF5C00                  		mov	di,FCB ; 5Ch	
  4381                                  		;mov	ax,290Eh
  4382 00000FFA B80E29                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
  4383 00000FFD CD21                    		int	21h	; DOS -	PARSE FILENAME
  4384                                  				; DS:SI	-> string to parse
  4385                                  				; ES:DI	-> buffer to fill with unopened	FCB
  4386                                  				; AL = bit mask	to control parsing
  4387 00000FFF 803C00                  		cmp	byte [si],0
  4388 00001002 7404                    		jz	short DOHEADER
  4389 00001004 FF0E[8842]              		dec	word [COMSW]
  4390                                  DOHEADER:
  4391                                  
  4392                                  ; Display the header
  4393                                  
  4394 00001008 53                      		push	bx
  4395 00001009 E84804                  		call	BUILD_DIR_STRING
  4396 0000100C BA[6A43]                		mov	dx,DIRBUF
  4397 0000100F 8916[6544]              		mov	[VOL_DIR],dx
  4398 00001013 BA[FF3B]                		mov	dx,DIRHEADPTR
  4399 00001016 E8AA24                  		call	PRINTF_CRLF
  4400 00001019 5B                      		pop	bx
  4401 0000101A 83FBFF                  		cmp	bx,0FFFFh
  4402 0000101D 7417                    		jz	short DOSEARCH
  4403                                  
  4404                                  ; If there were chars left after parse or device, then invalid file name
  4405                                  
  4406 0000101F 833E[8842]00            		cmp	word [COMSW],0
  4407 00001024 7410                    		jz	short DOSEARCH	; nothing left; good parse
  4408 00001026 7C09                    		jl	short DIRNFFIX	; not .. => error file not found
  4409 00001028 E87008                  		call	RESTUDIR
  4410 0000102B BA[763B]                		mov	dx,BADCDPTR
  4411 0000102E E9F80B                  		jmp	CERROR		; was .. => error directory not found
  4412                                  DIRNFFIX:
  4413 00001031 E86708                  		call	RESTUDIR
  4414 00001034 EBA9                    		jmp	short DIRNF
  4415                                  
  4416                                  ; We are assured that everything is correct. Let's go and search. Use
  4417                                  ; attributes that will include finding directories. Perform the first search
  4418                                  ; and reset our directory afterward.
  4419                                  
  4420                                  DOSEARCH:
  4421                                  		;mov	byte [55h],0FFh
  4422 00001036 C6065500FF              		mov	byte [FCB-7],0FFh
  4423                                  		;mov	byte [5Bh],10h
  4424 0000103B C6065B0010              		mov	byte [FCB-1],10h
  4425                                  
  4426                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
  4427                                  ; the directory information as an extended FCB. We must bias all fetches into
  4428                                  ; DIRBUF by 8 (Extended FCB part + drive)
  4429                                  
  4430 00001040 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  4431 00001042 BA5500                  		mov	dx,FCB-7 ; 55h
  4432 00001045 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  4433                                  				; DS:DX	-> FCB
  4434                                  
  4435                                  ; Restore the user's directory. We preserve, though, the return from the
  4436                                  ; previous system call for later checking.
  4437                                  
  4438                                  FOUND_FIRST_FILE:
  4439 00001047 50                      		push	ax		; save return state
  4440 00001048 E85008                  		call	RESTUDIR	; restore user's dir	
  4441 0000104B 58                      		pop	ax		; get return state back
  4442                                  
  4443                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4444                                  ; no more.
  4445                                  
  4446                                  DIRSTART:
  4447 0000104C FEC0                    		inc	al		; 0FFh = file not found
  4448 0000104E 7503                    		jnz	short DISPLAY	; Either an error or we are finished
  4449 00001050 E9D200                  		jmp	CHKCNT
  4450                                  DISPLAY:
  4451 00001053 FF06[9942]              		inc	word [FILECNT]	; Keep track of how many we find
  4452 00001057 BE[7243]                		mov	si,DIRBUF+8	; SI -> information returned by sys call
  4453                                  		;call	SHONAME
  4454 0000105A E80C01                  		call	DISPLAYNAME
  4455                                  		;test	byte [_BITS],1
  4456 0000105D F606[BC43]01            		test	byte [_BITS],SWITCHW ; W switch set?
  4457 00001062 7403                    		jz	short DIRTEST	; If so, no size, date, or time
  4458 00001064 E98800                  		jmp	NEXENT
  4459                                  DIRTEST:
  4460                                  		;test	byte [DIRBUF_ATTRIB1],10h
  4461                                  		; 14/10/2018
  4462                                  		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
  4463                                  		;test	byte [DIRBUF+19],10h
  4464 00001067 F606[7D43]10            		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
  4465 0000106C 7408                    		jz	short FILEENT
  4466 0000106E BA[F83A]                		mov	dx,DMESPTR
  4467 00001071 E85F24                  		call	STD_PRINTF
  4468 00001074 EB16                    		jmp	short NOFSIZ
  4469                                  FILEENT:
  4470                                  		;mov	dx,[DIRBUF_FSIZ_L]
  4471                                  		;mov	dx,[DIRBUF+36]
  4472 00001076 8B16[8E43]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
  4473 0000107A 8916[4A44]              		mov	[FILESIZE_L],dx
  4474                                  		;mov	dx,[DIRBUF_FSIZ_H]
  4475                                  		;mov	dx,[DIRBUF+38]
  4476 0000107E 8B16[9043]              		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
  4477 00001082 8916[4C44]              		mov	[FILESIZE_H],dx
  4478 00001086 BA[3637]                		mov	dx,FSIZEMESPTR
  4479 00001089 E84724                  		call	STD_PRINTF	; Print size of file
  4480                                  NOFSIZ:
  4481                                  		;mov	ax,[DIRBUF_FDATE]  ; Get date
  4482                                  		;mov	ax,[DIRBUF+32]
  4483 0000108C A1[8A43]                		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
  4484 0000108F 09C0                    		or	ax,ax
  4485 00001091 745C                    		jz	short NEXENT	; Skip if no date
  4486 00001093 BF[9B42]                		mov	di,CHARBUF
  4487 00001096 50                      		push	ax
  4488 00001097 B82020                  		mov	ax,'  '
  4489 0000109A AB                      		stosw
  4490 0000109B 58                      		pop	ax
  4491 0000109C 89C3                    		mov	bx,ax
  4492 0000109E 83E01F                  		and	ax,1Fh		; Get day
  4493 000010A1 88C2                    		mov	dl,al
  4494 000010A3 89D8                    		mov	ax,bx
  4495 000010A5 B105                    		mov	cl,5
  4496 000010A7 D3E8                    		shr	ax,cl		; Align month
  4497 000010A9 240F                    		and	al,0Fh		; Get month
  4498 000010AB 88C6                    		mov	dh,al
  4499 000010AD 88F9                    		mov	cl,bh
  4500 000010AF D0E9                    		shr	cl,1		; Align year
  4501 000010B1 30ED                    		xor	ch,ch
  4502 000010B3 83C150                  		add	cx,80		; Relative 1980
  4503 000010B6 80F964                  		cmp	cl,100
  4504 000010B9 7203                    		jb	short MILLENIUM
  4505 000010BB 80E964                  		sub	cl,100
  4506                                  MILLENIUM:
  4507 000010BE E8DB0F                  		call	DATE_CXDX
  4508                                  		;mov	cx,[DIRBUF_FTIME]
  4509                                  		;mov	cx,[DIRBUF+30]
  4510 000010C1 8B0E[8843]              		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
  4511 000010C5 E318                    		jcxz	PRBUF		; Time field present?
  4512 000010C7 B82020                  		mov	ax,2020h
  4513 000010CA AB                      		stosw
  4514 000010CB D1E9                    		shr	cx,1
  4515 000010CD D1E9                    		shr	cx,1
  4516 000010CF D1E9                    		shr	cx,1
  4517 000010D1 D0E9                    		shr	cl,1
  4518 000010D3 D0E9                    		shr	cl,1		; Hours in CH, minutes in CL
  4519 000010D5 8A1E[094D]              		mov	bl,[TIME_24]
  4520 000010D9 80CB80                  		or	bl,80h		; Tell P_TIME called from DIR
  4521 000010DC E87011                  		call	P_TIME		; Don't care about DX, never used with DIR
  4522                                  PRBUF:
  4523 000010DF 31C0                    		xor	ax,ax
  4524 000010E1 AA                      		stosb
  4525 000010E2 BA[9B42]                		mov	dx,CHARBUF
  4526 000010E5 8916[4E44]              		mov	[STRING_PTR_2],dx
  4527 000010E9 BA[3F37]                		mov	dx,STRINGBUF2PTR
  4528 000010EC E8E423                  		call	STD_PRINTF
  4529                                  NEXENT:
  4530 000010EF FE0E[9742]              		dec	byte [LINCNT]
  4531 000010F3 7520                    		jnz	short SAMLIN
  4532                                  NEXLIN:
  4533 000010F5 A0[9842]                		mov	al,[LINLEN]
  4534 000010F8 A2[9742]                		mov	[LINCNT],al
  4535 000010FB E86E08                  		call	CRLF2
  4536 000010FE FE0E[C443]              		dec	byte [LINPERPAG]
  4537 00001102 7517                    		jnz	short SCROLL
  4538                                  		;test	byte [_BITS],2
  4539 00001104 F606[BC43]02            		test	byte [_BITS],SWITCHP ; P switch present?
  4540 00001109 7410                    		jz	short SCROLL	; If not, just continue
  4541 0000110B C606[C443]17            		mov	byte [LINPERPAG],23
  4542 00001110 E87900                  		call	PAUSE
  4543 00001113 EB06                    		jmp	short SCROLL
  4544                                  SAMLIN:
  4545 00001115 BA[4537]                		mov	dx,TABPTR	; Output a tab
  4546 00001118 E8B823                  		call	STD_PRINTF
  4547                                  SCROLL:
  4548 0000111B B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
  4549                                  		;mov	dx,55h
  4550 0000111D BA5500                  		mov	dx,FCB-7	; DX -> Unopened FCB
  4551 00001120 CD21                    		int	21h	; DOS -	SEARCH NEXT USING FCB
  4552                                  				; DS:DX	-> FCB
  4553                                  				; Return: AL = status
  4554 00001122 E927FF                  		jmp	DIRSTART
  4555                                  CHKCNT:
  4556 00001125 F706[9942]FFFF          		test	word [FILECNT],0FFFFh ; -1
  4557 0000112B 7503                    		jnz	short TRAILER
  4558 0000112D E9AFFE                  		jmp	DIRNF
  4559                                  TRAILER:
  4560 00001130 A0[9842]                		mov	al,[LINLEN]
  4561 00001133 3A06[9742]              		cmp	al,[LINCNT]
  4562 00001137 7403                    		jz	short MMESSAGE
  4563 00001139 E83008                  		call	CRLF2
  4564                                  MMESSAGE:
  4565 0000113C BA[0F39]                		mov	dx,DIRMESPTR
  4566 0000113F 8B36[9942]              		mov	si,[FILECNT]
  4567 00001143 8936[5744]              		mov	[DIR_NUM],si
  4568 00001147 E88923                  		call	STD_PRINTF
  4569                                  DTFREE:
  4570 0000114A B436                    		mov	ah,GET_DRIVE_FREESPACE ; 36h
  4571                                  		;mov	dl,[5Ch]
  4572 0000114C 8A165C00                		mov	dl,[FCB]
  4573 00001150 CD21                    		int	21h	; DOS -	2+ - GET DISK SPACE
  4574                                  				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
  4575 00001152 83F8FF                  		cmp	ax,-1
  4576 00001155 7501                    		jnz	short DTFREE1
  4577                                  DTRET:
  4578 00001157 C3                      		retn
  4579                                  DTFREE1:
  4580 00001158 F7E1                    		mul	cx
  4581 0000115A F7E3                    		mul	bx
  4582 0000115C A3[5944]                		mov	[BYTES_FREE],ax
  4583 0000115F 8916[5B44]              		mov	[BYTES_FREE+2],dx
  4584 00001163 BA[2539]                		mov	dx,BYTEMESPTR
  4585 00001166 E96A23                  		jmp	STD_PRINTF
  4586                                  
  4587                                  
  4588                                  	; MSDOS 6.0
  4589                                  ;CATALOG:
  4590                                  
  4591                                  ;;
  4592                                  ;; Set up DTA for dir search firsts
  4593                                  ;;
  4594                                  ;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
  4595                                  ;	mov	ah,Set_DMA			;AC000;
  4596                                  ;	int	int_command			;AC000;
  4597                                  ;;
  4598                                  ;; Set up defaults for switches and parse the command line.
  4599                                  ;;
  4600                                  ;	mov	msg_numb,0			;AN022; initialize message flag
  4601                                  ;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
  4602                                  ;	mov	[pathpos],di			;AN000; this is start of path
  4603                                  ;	mov	[pathcnt],1			;AN000; initialize length to 1 char
  4604                                  ;	mov	al,star 			;AN000; initialize srcbuf to *,0d
  4605                                  ;	stosb					;AN000;
  4606                                  ;	mov	al,end_of_line_in		;AN000;
  4607                                  ;	stosb					;AN000;
  4608                                  ;	mov	si,81H				;AN000; Get command line
  4609                                  ;	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
  4610                                  ;	xor	cx,cx				;AC000; clear counter for positionals
  4611                                  ;	mov	ComSw,cx			;AC000; initialize flags
  4612                                  ;	mov	bits,cx 			;AC000; initialize switches
  4613                                  ;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
  4614                                  ;	mov	linlen,normperlin		;AC000; Set number of entries per line
  4615                                  ;	mov	lincnt,normperlin		;AC000;
  4616                                  ;
  4617                                  ;dirscan:
  4618                                  ;	xor	dx,dx				;AN000;
  4619                                  ;	invoke	parse_with_msg			;AC018; call parser
  4620                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  4621                                  ;	jne	dirscan_cont			;AN000; No - continue parsing
  4622                                  ;	jmp	scandone			;AN000; yes - go process
  4623                                  ;
  4624                                  ;dirscan_cont:
  4625                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  4626                                  ;	jz	dirscan_cont2			;AN000; No - continue parsing
  4627                                  ;	jmp	badparm 			;AN000; yes - exit
  4628                                  ;
  4629                                  ;dirscan_cont2:
  4630                                  ;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
  4631                                  ;	je	set_dir_width			;AN000; yes - go set wide lines
  4632                                  ;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
  4633                                  ;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
  4634                                  ;;
  4635                                  ;; Must be filespec since no other matches occurred. Move filename to srcbuf
  4636                                  ;;
  4637                                  ;	push	si				;AC000; save position in line
  4638                                  ;	lds	si,parse1_addr			;AC000; get address of filespec
  4639                                  ;	push	si				;AN000; save address
  4640                                  ;	invoke	move_to_srcbuf			;AC000; move to srcbuf
  4641                                  ;	pop	dx				;AC000; get address in DX
  4642                                  ;
  4643                                  ;;
  4644                                  ;; The user may have specified a device. Search for the path and see if the
  4645                                  ;; attributes indicate a device.
  4646                                  ;;
  4647                                  ;	mov	ah,Find_First			;AC000; find the file
  4648                                  ;	int	int_command			;AC000;
  4649                                  ;	jnc	Dir_check_device		;AN022; if no error - check device
  4650                                  ;	invoke	get_ext_error_number		;AN022; get the extended error
  4651                                  ;	cmp	ax,error_no_more_files		;AN022; was error no file found
  4652                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4653                                  ;	cmp	ax,error_path_not_found 	;AN022; was error no file found
  4654                                  ;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
  4655                                  ;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
  4656                                  ;
  4657                                  ;dir_check_device:				;AN022;
  4658                                  ;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
  4659                                  ;	jz	Dir_fspec_end			;AC000; no, go do normal operation
  4660                                  ;	mov	ComSw,-2			;AC000; signal device
  4661                                  ;
  4662                                  ;dir_fspec_end:
  4663                                  ;	pop	si				;AC000; restore position in line
  4664                                  ;	jmp	short dirscan			;AC000; keep parsing
  4665                                  ;
  4666                                  ;set_dir_width:
  4667                                  ;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
  4668                                  ;	jz	ok_set_width			;AN018; no - okay to set width
  4669                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4670                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4671                                  ;	jmp	badparm 			;AN018; exit
  4672                                  ;
  4673                                  ;ok_set_width:
  4674                                  ;	or	bits,switchw			;AC000; indicate /w was selected
  4675                                  ;	mov	linlen,wideperlin		;AC000; Set number of entries per line
  4676                                  ;	mov	lincnt,wideperlin		;AC000;
  4677                                  ;	jmp	short dirscan			;AC000; keep parsing
  4678                                  ;
  4679                                  ;set_dir_pause:
  4680                                  ;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
  4681                                  ;	jz	ok_set_pause			;AN018; no - okay to set width
  4682                                  ;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
  4683                                  ;	invoke	setup_parse_error_msg		;AN018; set up an error message
  4684                                  ;	jmp	badparm 			;AN018; exit
  4685                                  ;
  4686                                  ;ok_set_pause:
  4687                                  ;	or	bits,switchp			;AC000; indicate /p was selected
  4688                                  ;	push	cx				;AN000; save necessary registers
  4689                                  ;	push	si				;AN000;
  4690                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
  4691                                  ;	mov	bx,stdout			;AN000; lines for stdout
  4692                                  ;	mov	ch,ioc_sc			;AN000; type is display
  4693                                  ;	mov	cl,get_generic			;AN000; get information
  4694                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  4695                                  ;	int	int_command			;AN000;
  4696                                  ;
  4697                                  ;lines_set:
  4698                                  ;	dec	linperpag			;AN000; lines per actual page should
  4699                                  ;	dec	linperpag			;AN000;     two less than the max
  4700                                  ;	mov	ax,linperpag			;AN000; get number of lines into
  4701                                  ;	mov	[fullscr],ax			;AC000;    screen line counter
  4702                                  ;	pop	si				;AN000; restore registers
  4703                                  ;	pop	cx				;AN000;
  4704                                  ;	jmp	dirscan 			;AC000; keep parsing
  4705                                  ;
  4706                                  ;;
  4707                                  ;; The syntax is incorrect. Report only message we can.
  4708                                  ;;
  4709                                  ;BadParm:
  4710                                  ;	jmp	cerror				;AC000; invalid switches get displayed
  4711                                  ;
  4712                                  ;ScanDone:
  4713                                  ;
  4714                                  ;;
  4715                                  ;; Find and display the volume ID on the drive.
  4716                                  ;;
  4717                                  ;
  4718                                  ;	invoke	okvolarg			;AC000;
  4719                                  ;;
  4720                                  ;; OkVolArg also disables APPEND, which will be re-enabled
  4721                                  ;; in the HeadFix routine, after we're done.
  4722                                  ;;
  4723                                  ;	mov	[filecnt],0			;AC000; Keep track of how many files found
  4724                                  ;	cmp	comsw,0 			;AC000; did an error occur?
  4725                                  ;	jnz	doheader			;AC000; yes - don't bother to fix path
  4726                                  ;
  4727                                  ;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
  4728                                  ;	invoke	pathcrunch			;AC000; set up FCB for dir
  4729                                  ;	mov	dirflag,0			;AN015; reset dirflag
  4730                                  ;	jc	DirCheckPath			;AC015; no CHDIRs worked.
  4731                                  ;	jz	doheader			;AC015; chdirs worked - path\*.*
  4732                                  ;	mov	si,[desttail]			;AN015; get filename back
  4733                                  ;	jmp	short DoRealParse		;AN015; go parse it
  4734                                  ;
  4735                                  ;DirCheckPath:
  4736                                  ;	mov	ax,[msg_numb]			;AN022; get message number
  4737                                  ;	cmp	ax,0				;AN022; Is there a message?
  4738                                  ;	jnz	dir_err_setup			;AN022; yes - there's an error
  4739                                  ;	cmp	[destisdir],0			;AC000; Were pathchars found?
  4740                                  ;	jz	doparse 			;AC000; no - no problem
  4741                                  ;	inc	comsw				;AC000; indicate error
  4742                                  ;	jmp	short doheader			;AC000; go print header
  4743                                  ;
  4744                                  ;DirNF:
  4745                                  ;	mov	ax,error_file_not_found 	;AN022; get message number in control block
  4746                                  ;
  4747                                  ;dir_err_setup:
  4748                                  ;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
  4749                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
  4750                                  ;	mov	extend_buf_ptr,ax		;AN022;
  4751                                  ;
  4752                                  ;DirError:
  4753                                  ;	jmp	Cerror
  4754                                  ;
  4755                                  ;;
  4756                                  ;; We have changed to something. We also have a file. Parse it into a
  4757                                  ;; reasonable form, leaving drive alone, leaving extention alone and leaving
  4758                                  ;; filename alone. We need to special case ... If we are at the root, the
  4759                                  ;; parse will fail and it will give us a file not found instead of file not
  4760                                  ;; found.
  4761                                  ;;
  4762                                  ;DoParse:
  4763                                  ;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
  4764                                  ;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
  4765                                  ;	jnz	dir_no_drive			;AN000; no - keep going
  4766                                  ;	lodsw					;AN000; bypass drive
  4767                                  ;
  4768                                  ;dir_no_drive:
  4769                                  ;	cmp	[si],".."
  4770                                  ;	jnz	DoRealParse
  4771                                  ;	cmp	byte ptr [si+2],0
  4772                                  ;	jnz	DoRealParse
  4773                                  ;	inc	ComSw
  4774                                  ;	jmp	short DoHeader
  4775                                  ;
  4776                                  ;DoRealParse:
  4777                                  ;	mov	di,FCB			; where to put the file name
  4778                                  ;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
  4779                                  ;	int	int_command
  4780                                  ;
  4781                                  ;;
  4782                                  ;; Check to see if APPEND installed. If it is installed, set all flags
  4783                                  ;; off.	This will be reset in the HEADFIX routine
  4784                                  ;;
  4785                                  ;
  4786                                  ;DoHeader:
  4787                                  ;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
  4788                                  ;
  4789                                  ;;
  4790                                  ;; Display the header
  4791                                  ;;
  4792                                  ;
  4793                                  ;DoHeaderCont:
  4794                                  ;	mov	al,blank			;AN051; Print out a blank
  4795                                  ;	invoke	print_char			;AN051;   before DIR header
  4796                                  ;	invoke	build_dir_string		; get current dir string
  4797                                  ;	mov	dx,offset trangroup:Dirhead_ptr
  4798                                  ;	invoke	printf_crlf			; bang!
  4799                                  ;
  4800                                  ;;
  4801                                  ;; If there were chars left after parse or device, then invalid file name
  4802                                  ;;
  4803                                  ;	cmp	ComSw,0
  4804                                  ;	jz	DoSearch			; nothing left; good parse
  4805                                  ;	jl	DirNFFix			; not .. => error file not found
  4806                                  ;	invoke	RestUDir
  4807                                  ;	mov	dx,offset TranGroup:BadCD_ptr
  4808                                  ;	jmp	Cerror				; was .. => error directory not found
  4809                                  ;DirNFFix:
  4810                                  ;	invoke	RestUDir
  4811                                  ;	jmp	DirNF
  4812                                  ;;
  4813                                  ;; We are assured that everything is correct.  Let's go and search.  Use
  4814                                  ;; attributes that will include finding directories.  perform the first search
  4815                                  ;; and reset our directory afterward.
  4816                                  ;;
  4817                                  ;DoSearch:
  4818                                  ;	mov	byte ptr DS:[FCB-7],0FFH
  4819                                  ;	mov	byte ptr DS:[FCB-1],010H
  4820                                  ;;
  4821                                  ;; Caution!  Since we are using an extended FCB, we will *also* be returning
  4822                                  ;; the directory information as an extended FCB. We must bias all fetches into
  4823                                  ;; DIRBUF by 8 (Extended FCB part + drive)
  4824                                  ;;
  4825                                  ;	mov	ah,Dir_Search_First
  4826                                  ;	mov	dx,FCB-7
  4827                                  ;	int	int_command
  4828                                  ;
  4829                                  ;	push	ax				;AN022; save return state
  4830                                  ;	inc	al				;AN022; did an error occur?
  4831                                  ;	pop	ax				;AN022; get return state back
  4832                                  ;	jnz	found_first_file		;AN022; no error - start dir
  4833                                  ;	invoke	set_ext_error_msg		;AN022; yes - set up error message
  4834                                  ;	push	dx				;AN022; save message
  4835                                  ;	invoke	restudir			;AN022; restore user's dir
  4836                                  ;	pop	dx				;AN022; restore message
  4837                                  ;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
  4838                                  ;	jnz	DirCerrorJ			;AN022; 	file not found
  4839                                  ;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
  4840                                  ;
  4841                                  ;DirCerrorJ:					;AN022;
  4842                                  ;	jmp	Cerror				;AN022; exit
  4843                                  ;
  4844                                  ;;
  4845                                  ;; Restore the user's directory.  We preserve, though, the return from the
  4846                                  ;; previous system call for later checking.
  4847                                  ;;
  4848                                  ;
  4849                                  ;found_first_file:
  4850                                  ;	push	ax
  4851                                  ;	invoke	restudir
  4852                                  ;	pop	ax
  4853                                  ;;
  4854                                  ;; Main scanning loop. Entry has AL = Search first/next error code. Test for
  4855                                  ;; no more.
  4856                                  ;;
  4857                                  ;DIRSTART:
  4858                                  ;	inc	al				; FF = file not found
  4859                                  ;	jnz	Display
  4860                                  ;	jmp	DirDone 			; Either an error or we are finished
  4861                                  ;;
  4862                                  ;; Note that we've seen a file and display the found file.
  4863                                  ;;
  4864                                  ;
  4865                                  ;Display:
  4866                                  ;	inc	[filecnt]			; Keep track of how many we find
  4867                                  ;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
  4868                                  ;	call	shoname
  4869                                  ;;
  4870                                  ;; If we are displaying in wide mode, do not output the file info
  4871                                  ;;
  4872                                  ;	test	byte ptr[bits],SwitchW		; W switch set?
  4873                                  ;	jz	DirTest
  4874                                  ;	jmp	nexent				; If so, no size, date, or time
  4875                                  ;
  4876                                  ;;
  4877                                  ;; Test for directory.
  4878                                  ;;
  4879                                  ;DirTest:
  4880                                  ;	test	[dirbuf+8].dir_attr,attr_directory
  4881                                  ;	jz	fileent
  4882                                  ;;
  4883                                  ;; We have a directory.	Display the <DIR> field in place of the file size
  4884                                  ;;
  4885                                  ;	mov	dx,offset trangroup:Dmes_ptr
  4886                                  ;	call	std_printf
  4887                                  ;	jmp	short nofsiz
  4888                                  ;;
  4889                                  ;; We have a file.  Display the file size
  4890                                  ;;
  4891                                  ;fileent:
  4892                                  ;	mov	dx,[DirBuf+8].dir_size_l
  4893                                  ;	mov	file_size_low,dx
  4894                                  ;	mov	dx,[DirBuf+8].dir_size_h
  4895                                  ;	mov	file_size_high,dx
  4896                                  ;	mov	dx,offset trangroup:disp_file_size_ptr
  4897                                  ;	call	std_printf
  4898                                  ;;
  4899                                  ;; Display time and date of last modification
  4900                                  ;;
  4901                                  ;nofsiz:
  4902                                  ;	mov	ax,[DirBuf+8].dir_date		; Get date
  4903                                  ;;
  4904                                  ;; If the date is 0, then we have found a 1.x level diskette.  We skip the
  4905                                  ;; date/time fields as 1.x did not have them.
  4906                                  ;;
  4907                                  ;	or	ax,ax
  4908                                  ;	jz	nexent				; Skip if no date
  4909                                  ;	mov	bx,ax
  4910                                  ;	and	ax,1FH				; get day
  4911                                  ;	mov	dl,al
  4912                                  ;	mov	ax,bx
  4913                                  ;	mov	cl,5
  4914                                  ;	shr	ax,cl				; Align month
  4915                                  ;	and	al,0FH				; Get month
  4916                                  ;	mov	dh,al
  4917                                  ;	mov	cl,bh
  4918                                  ;	shr	cl,1				; Align year
  4919                                  ;	xor	ch,ch
  4920                                  ;	add	cx,80				; Relative 1980
  4921                                  ;	cmp	cl,100
  4922                                  ;	jb	millenium
  4923                                  ;	sub	cl,100
  4924                                  ;
  4925                                  ;millenium:
  4926                                  ;	xchg	dh,dl				;AN000; switch month & day
  4927                                  ;	mov	DirDat_yr,cx			;AC000; put year into message control block
  4928                                  ;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
  4929                                  ;	mov	cx,[DirBuf+8].dir_time		; Get time
  4930                                  ;	jcxz	prbuf				; Time field present?
  4931                                  ;	shr	cx,1
  4932                                  ;	shr	cx,1
  4933                                  ;	shr	cx,1
  4934                                  ;	shr	cl,1
  4935                                  ;	shr	cl,1				; Hours in CH, minutes in CL
  4936                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
  4937                                  ;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
  4938                                  ;
  4939                                  ;prbuf:
  4940                                  ;	mov	dx,offset trangroup:DirDatTim_ptr
  4941                                  ;	call	std_printf
  4942                                  ;	invoke	crlf2				;AC066;end the line
  4943                                  ;	dec	byte ptr [fullscr]		;AC066;count the line
  4944                                  ;	jnz	endif04 			;AN066;IF the last on the screen THEN
  4945                                  ;	   call    check_for_P			;AN066;   pause if /P requested
  4946                                  ;	endif04:				;AN066;
  4947                                  ;	jmp	scroll				; If not, just continue
  4948                                  ;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
  4949                                  ;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
  4950                                  ;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
  4951                                  ;;
  4952                                  ;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
  4953                                  ;; is only for /W case.
  4954                                  ;;
  4955                                  ;nexent:
  4956                                  ;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
  4957                                  ;	dec	[lincnt]			      ;count this entry on the line
  4958                                  ;	jnz	else01				;AX066;IF last entry on line THEN
  4959                                  ;	   mov	   al,[linlen]
  4960                                  ;	   mov	   [lincnt],al
  4961                                  ;	   invoke  crlf2
  4962                                  ;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
  4963                                  ;	   jnz	   endif02			;AN066;
  4964                                  ;	      call    check_for_P		;AN066;   reinitialize fullscr,
  4965                                  ;	   endif02:				;AN066;   IF P requested THEN pause
  4966                                  ;	   jmp	   short endif01		;AN066;
  4967                                  ;	else01: 				;AN066;ELSE since screen not full
  4968                                  ;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
  4969                                  ;	   jne	   endif03			;	     count the line
  4970                                  ;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
  4971                                  ;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
  4972                                  ;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
  4973                                  ;	   call    std_printf
  4974                                  ;	endif01:				;AX066;
  4975                                  ;;
  4976                                  ;; All we need to do now is to get the next directory entry.
  4977                                  ;;
  4978                                  ;scroll:
  4979                                  ;	mov	ah,Dir_Search_Next
  4980                                  ;	mov	dx,FCB-7			; DX -> Unopened FCB
  4981                                  ;	int	int_command			; Search for a file to match FCB
  4982                                  ;	jmp	DirStart
  4983                                  ;;
  4984                                  ;; If no files have been found, display a not-found message
  4985                                  ;;
  4986                                  ;DirDone:
  4987                                  ;	invoke	get_ext_error_number		;AN022; get the extended error number
  4988                                  ;	cmp	ax,error_no_more_files		;AN022; was error file not found?
  4989                                  ;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
  4990                                  ;	test	[filecnt],-1
  4991                                  ;	jnz	Trailer
  4992                                  ;	mov	ax,error_file_not_found 	;AN022;
  4993                                  ;
  4994                                  ;dir_err_setup_jmp:				;AN022;
  4995                                  ;	jmp	dir_err_setup			;AN022; go setup error msg & print it
  4996                                  ;;
  4997                                  ;; If we have printed the maximum number of files per line, terminate it with
  4998                                  ;; CRLF.
  4999                                  ;;
  5000                                  ;Trailer:
  5001                                  ;	mov	al,[linlen]
  5002                                  ;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
  5003                                  ;	jz	mmessage
  5004                                  ;	invoke	crlf2
  5005                                  ;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
  5006                                  ;	jnz	endif06 			;AN066;   pause before going on
  5007                                  ;	   call    check_for_P			;AN066;   to number and freespace
  5008                                  ;	endif06:				;AN066;   displays
  5009                                  ;
  5010                                  ;mmessage:
  5011                                  ;	mov	dx,offset trangroup:Dirmes_ptr
  5012                                  ;	mov	si,[filecnt]
  5013                                  ;	mov	dir_num,si
  5014                                  ;	call	std_printf
  5015                                  ;	mov	ah,Get_Drive_Freespace
  5016                                  ;	mov	dl,byte ptr DS:[FCB]
  5017                                  ;	int	int_command
  5018                                  ;	cmp	ax,-1
  5019                                  ;	retz
  5020                                  ;	mul	cx				; AX is bytes per cluster
  5021                                  ;	mul	bx
  5022                                  ;	mov	bytes_free,ax			;AC000;
  5023                                  ;	mov	bytes_free+2,dx 		;AC000;
  5024                                  ;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
  5025                                  ;	jmp	std_printf
  5026                                  ;
  5027                                  ;shoname:
  5028                                  ;	mov	di,offset trangroup:charbuf
  5029                                  ;	mov	cx,8
  5030                                  ;	rep	movsb
  5031                                  ;	mov	al,' '
  5032                                  ;	stosb
  5033                                  ;	mov	cx,3
  5034                                  ;	rep	movsb
  5035                                  ;	xor	ax,ax
  5036                                  ;	stosb
  5037                                  ;	push	dx
  5038                                  ;	mov	dx,offset trangroup:charbuf
  5039                                  ;	mov	string_ptr_2,dx
  5040                                  ;	mov	dx,offset trangroup:string_buf_ptr
  5041                                  ;	call	std_printf
  5042                                  ;	pop	DX
  5043                                  ;	return
  5044                                  ;
  5045                                  ;check_for_P    PROC  NEAR		;AN066;
  5046                                  ;
  5047                                  ;	test	byte ptr[bits],SwitchP	;P switch present?
  5048                                  ;	jz	endif05 		;AN066;
  5049                                  ; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
  5050                                  ; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
  5051                                  ;   	invoke  Pause
  5052                                  ;endif05:
  5053                                  ;	ret				;AN066;
  5054                                  ;
  5055                                  ;check_for_P    ENDP			;AN066;
  5056                                  
  5057                                  ; =============== S U B	R O U T	I N E =======================================
  5058                                  
  5059                                  SHONAME:
  5060                                  DISPLAYNAME:
  5061                                  		; MSDOS 3.3
  5062 00001169 BF[9B42]                		mov	di,CHARBUF
  5063 0000116C B90800                  		mov	cx,8
  5064 0000116F F3A4                    		rep movsb
  5065 00001171 B020                    		mov	al,' '
  5066 00001173 AA                      		stosb
  5067 00001174 B90300                  		mov	cx,3
  5068 00001177 F3A4                    		rep movsb
  5069 00001179 31C0                    		xor	ax,ax
  5070 0000117B AA                      		stosb
  5071 0000117C 52                      		push	dx
  5072 0000117D BA[9B42]                		mov	dx,CHARBUF
  5073 00001180 8916[4E44]              		mov	[STRING_PTR_2],dx
  5074 00001184 BA[3F37]                		mov	dx,STRINGBUF2PTR
  5075 00001187 E84923                  		call	STD_PRINTF
  5076 0000118A 5A                      		pop	dx
  5077 0000118B C3                      		retn
  5078                                  
  5079                                  ;============================================================================
  5080                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
  5081                                  ;============================================================================
  5082                                  ; 09/10/2018 - Retro DOS v3.0
  5083                                  
  5084                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
  5085                                  
  5086                                  
  5087                                  ; =============== S U B	R O U T	I N E =======================================
  5088                                  
  5089                                  PAUSE:
  5090 0000118C BA[0C3A]                		mov	dx,PAUSEMESPTR
  5091 0000118F E84123                  		call	STD_PRINTF
  5092 00001192 E858F3                  		call	GETKEYSTROKE
  5093 00001195 E8D407                  		call	CRLF2
  5094 00001198 C3                      		retn
  5095                                  
  5096                                  ; ---------------------------------------------------------------------------
  5097                                  
  5098                                  ;****************************************************************
  5099                                  ;*
  5100                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
  5101                                  ;*
  5102                                  ;* FUNCTION:	PARSE command line for file or path name and /P
  5103                                  ;*		and invoke PATHCRUNCH.	If an error occurs, set
  5104                                  ;*		up an error message and transfer control to CERROR.
  5105                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
  5106                                  ;*		entered or SLASHP_ERASE if /P entered.
  5107                                  ;*
  5108                                  ;* INPUT:	command line at offset 81H
  5109                                  ;*
  5110                                  ;* OUTPUT:	if no error:
  5111                                  ;*		FCB at 5ch set up with filename(s) entered
  5112                                  ;*		Current directory set to entered directory
  5113                                  ;*
  5114                                  ;****************************************************************
  5115                                  
  5116                                  ERASE:
  5117                                  		; MSDOS 6.0
  5118                                  
  5119                                  ;assume	ds:trangroup,es:trangroup
  5120                                  
  5121                                  ;		mov	si,81H		;AC000; get command line
  5122                                  ;		mov	comsw,0 	;AN000; clear switch indicator
  5123                                  ;		mov	di,offset trangroup:parse_erase
  5124                                  ;					;AN000; Get adderss of PARSE_erase
  5125                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5126                                  ;
  5127                                  ;erase_scan:
  5128                                  ;		xor	dx,dx		;AN000;
  5129                                  ;		invoke	parse_with_msg	;AC018; call parser
  5130                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
  5131                                  ;		jz	good_line	;AN000; yes - done parsing
  5132                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5133                                  ;		jnz	errj2		;AC000; yes exit
  5134                                  ;
  5135                                  ;		cmp	parse1_syn,offset trangroup:slash_p_syn 
  5136                                  ;					;AN000; was /P entered?
  5137                                  ;		je	set_erase_prompt ;AN000; yes - go set prompt
  5138                                  ;
  5139                                  ;;
  5140                                  ;; Must be filespec since no other matches occurred. move filename to srcbuf
  5141                                  ;;
  5142                                  ;		push	si		;AC000; save position in line
  5143                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5144                                  ;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
  5145                                  ;		jnz	Erase_drive_ok	;AC000; no - continue
  5146                                  ;		cmp	byte ptr[si+2],end_of_line_out	
  5147                                  ;					;AC000; was only drive entered?
  5148                                  ;		jnz	erase_drive_ok	;AC000; no - continue
  5149                                  ;		mov	ax,error_file_not_found 
  5150                                  ;					;AN022; get message number in control block
  5151                                  ;		jmp	short extend_setup ;AC000; exit
  5152                                  ;
  5153                                  ;erase_drive_ok:
  5154                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5155                                  ;		pop	si		;AC000; get position back
  5156                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5157                                  ;
  5158                                  ;set_erase_prompt:
  5159                                  ;		cmp	comsw,0 	;AN018; was /P already entered?
  5160                                  ;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
  5161                                  ;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
  5162                                  ;		invoke	setup_parse_error_msg ;AN018; set up an error message
  5163                                  ;		jmp	short errj2	;AN018; exit
  5164                                  ;
  5165                                  ;ok_to_set_erase_prompt: 		;AN018;
  5166                                  ;		inc	comsw		;AN000; indicate /p specified
  5167                                  ;		jmp	short erase_scan ;AN000; continue parsing
  5168                                  ;
  5169                                  ;good_line:				;G  We know line is good
  5170                                  ;		invoke	pathcrunch
  5171                                  ;		jnc	checkdr
  5172                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5173                                  ;		cmp	ax,0		;AN022; was message flag set?
  5174                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5175                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5176                                  ;		jnz	badpath_err	;AC022; see if they should have
  5177                                  ;
  5178                                  ;checkdr:
  5179                                  ;		cmp	comsw,0 	;AN000; was /p specified
  5180                                  ;		jz	notest2j	;AN000; no - go to notest2
  5181                                  ;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
  5182                                  ;
  5183                                  ;notest2j:
  5184                                  ;		jmp	notest2
  5185                                  ;
  5186                                  ;badpath_err:				;AN022; "Path not found" message
  5187                                  ;		mov	ax,error_path_not_found ;AN022; set up error number
  5188                                  ;
  5189                                  ;extend_setup:				;AN022;
  5190                                  ;		mov	msg_disp_class,ext_msg_class
  5191                                  ;					;AN022; set up extended error msg class
  5192                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5193                                  ;					;AC022; get extended message pointer
  5194                                  ;		mov	Extend_Buf_ptr,ax
  5195                                  ;					;AN022; get message number in control block
  5196                                  ;errj2:					;AC022; exit jump
  5197                                  ;		jmp	Cerror		;AN022;
  5198                                  
  5199                                  		; MSDOS 3.3
  5200 00001199 BA[6D3D]                		mov	dx,BADARGSPTR
  5201 0000119C BE8000                  		mov	si,80h
  5202 0000119F AC                      		lodsb
  5203 000011A0 08C0                    		or	al,al
  5204 000011A2 743E                    		jz	short ERRJ2
  5205 000011A4 E8D207                  		call	SCANOFF
  5206 000011A7 3C0D                    		cmp	al,0Dh		; Return key
  5207 000011A9 7437                    		jz	short ERRJ2	; If so no parameters specified
  5208 000011AB 52                      		push	dx
  5209 000011AC 56                      		push	si
  5210 000011AD BA[F837]                		mov	dx,FNOTFOUNDPTR
  5211                                  ERASE_SCAN:
  5212 000011B0 AC                      		lodsb
  5213 000011B1 E8CD07                  		call	DELIM
  5214 000011B4 7406                    		jz	short ERASE_CHKDELIMCHR
  5215 000011B6 3C0D                    		cmp	al,0Dh
  5216 000011B8 7415                    		jz	short GOOD_LINE
  5217 000011BA EBF4                    		jmp	short ERASE_SCAN
  5218                                  ERASE_CHKDELIMCHR:
  5219 000011BC 3C20                    		cmp	al,20h
  5220 000011BE 7F22                    		jg	short ERRJ2
  5221 000011C0 AC                      		lodsb
  5222 000011C1 E8BD07                  		call	DELIM
  5223 000011C4 74F6                    		jz	short ERASE_CHKDELIMCHR
  5224 000011C6 3C0D                    		cmp	al,0Dh
  5225 000011C8 7405                    		jz	short GOOD_LINE
  5226 000011CA BA[6D3D]                		mov	dx,BADARGSPTR
  5227 000011CD EB13                    		jmp	short ERRJ2
  5228                                  GOOD_LINE:
  5229 000011CF 5E                      		pop	si
  5230 000011D0 5A                      		pop	dx
  5231 000011D1 56                      		push	si
  5232 000011D2 E84808                  		call	PATHCRUNCH
  5233 000011D5 730E                    		jnc	short CHECKDR
  5234 000011D7 803E[6C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5235 000011DC 7407                    		jz	short CHECKDR	   ; see if they should have
  5236                                  BADCDERR:
  5237 000011DE 5E                      		pop	si
  5238 000011DF BA[763B]                		mov	dx,BADCDPTR
  5239                                  ERRJ2:
  5240 000011E2 E9440A                  		jmp	CERROR
  5241                                  CHECKDR:
  5242 000011E5 BA[F837]                		mov	dx,FNOTFOUNDPTR
  5243 000011E8 59                      		pop	cx
  5244 000011E9 B020                    		mov	al,' '
  5245                                  		;cmp	[5Dh],al
  5246 000011EB 38065D00                		cmp	[FCB+1],al
  5247 000011EF 74F1                    		jz	short ERRJ2
  5248 000011F1 83C103                  		add	cx,3
  5249 000011F4 39CE                    		cmp	si,cx
  5250 000011F6 7507                    		jnz	short NOTEST2J
  5251 000011F8 B03A                    		mov	al,':'
  5252 000011FA 3844FE                  		cmp	[si-2],al
  5253 000011FD 74E3                    		jz	short ERRJ2
  5254                                  NOTEST2J:
  5255 000011FF E92116                  		jmp	NOTEST2
  5256                                  
  5257                                  ; ---------------------------------------------------------------------------
  5258                                  
  5259                                  ; ****************************************************************
  5260                                  ; *
  5261                                  ; * ROUTINE:	 CRENAME - rename file(s)
  5262                                  ; *
  5263                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
  5264                                  ; *		 filename.  Invoke PATHCRUNCH on the full filespec.
  5265                                  ; *		 Make sure the second filespec only contains a
  5266                                  ; *		 filename.  If both openands are valid, attempt
  5267                                  ; *		 to rename the file.
  5268                                  ; *
  5269                                  ; * INPUT:	 command line at offset 81H
  5270                                  ; *
  5271                                  ; * OUTPUT:	 none
  5272                                  ; *
  5273                                  ; ****************************************************************
  5274                                  
  5275                                  CRENAME:
  5276                                  		; MSDOS 6.0
  5277                                  		;assume	ds:trangroup,es:trangroup
  5278                                  ;
  5279                                  ;		mov	si,81H		;AC000; Point to command line
  5280                                  ;		mov	di,offset trangroup:parse_rename
  5281                                  ;					;AN000; Get adderss of PARSE_RENAME
  5282                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5283                                  ;		xor	dx,dx		;AN000;
  5284                                  ;		invoke	parse_with_msg	;AC018; call parser
  5285                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5286                                  ;;		jz	crename_no_parse_error ;AC000; no - continue
  5287                                  ;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
  5288                                  ;;
  5289                                  ;;  Get first file name returned from parse into our buffer
  5290                                  ;;
  5291                                  ;crename_no_parse_error:
  5292                                  ;		push	si		;AN000; save position in line
  5293                                  ;		lds	si,parse1_addr	;AN000; get address of filespec
  5294                                  ;		invoke	move_to_srcbuf	;AN000; move to srcbuf
  5295                                  ;		pop	si		;AN000; restore position in line
  5296                                  ;
  5297                                  ;		xor	dx,dx		;AN000; clear dx
  5298                                  ;		invoke	parse_with_msg	;AC018; call parser
  5299                                  ;		cmp	ax,result_no_error ;AN000; did we have an error?
  5300                                  ;		JNZ	crename_parse_error ;AN000; Yes, fail.
  5301                                  ;;
  5302                                  ;;  Check the second file name for drive letter colon
  5303                                  ;;
  5304                                  ;		push	si		;AN000; save position in line
  5305                                  ;		lds	si,parse1_addr	;AC000; get address of path
  5306                                  ;
  5307                                  ;		mov	al,':'		;AC000;
  5308                                  ;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
  5309                                  ;		jnz	ren_no_drive	;AN000; Yes, error
  5310                                  ;		mov	msg_disp_class,parse_msg_class
  5311                                  ;					;AN000; set up parse error msg class
  5312                                  ;		mov	dx,offset TranGroup:Extend_Buf_ptr
  5313                                  ;					;AC000; get extended message pointer
  5314                                  ;		mov	Extend_Buf_ptr,BadParm_ptr
  5315                                  ;					;AN000; get "Invalid parameter" message number
  5316                                  ;		pop	si		;AN000;
  5317                                  ;crename_parse_error:			;AC022;
  5318                                  ;		jmp	short errj	;AC000;
  5319                                  ;
  5320                                  ;;  Get second file name returned from parse into the fCB. Save
  5321                                  ;;  character after file name so we can later check to make sure it
  5322                                  ;;  isn't a path character.
  5323                                  ;
  5324                                  ;
  5325                                  ;ren_no_drive:
  5326                                  ;		mov	di,FCB+10H	;AC000; set up to parse second file name
  5327                                  ;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
  5328                                  ;		int	21h		;AC000; do the function
  5329                                  ;		lodsb			;AC000; Load char after filename
  5330                                  ;		mov	one_char_val,al ;AN000; save char after filename
  5331                                  ;		pop	si		;AN000; get line position back
  5332                                  ;
  5333                                  ;;
  5334                                  ;; We have source and target.  See if any args beyond.
  5335                                  ;;
  5336                                  ;
  5337                                  ;		mov	di,offset trangroup:parse_rename
  5338                                  ;					;AC000; get address of parse_rename
  5339                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5340                                  ;		jnz	crename_parse_error ;AN000; no, fail.
  5341                                  ;
  5342                                  ;		invoke	pathcrunch
  5343                                  ;		mov	dx,offset trangroup:badcpmes_ptr
  5344                                  ;		jz	errj2		; If 1st parm a dir, print error msg
  5345                                  ;		jnc	notest3
  5346                                  ;		mov	ax,[msg_numb]	;AN022; get message number
  5347                                  ;		cmp	ax,0		;AN022; was message flag set?
  5348                                  ;		jnz	extend_setup	;AN022; yes - print out message
  5349                                  ;		cmp	[destisdir],0	; No CHDIRs worked
  5350                                  ;		jz	notest3 	; see if they should have
  5351                                  ;		Jmp	badpath_err	;AC022; set up error
  5352                                  ;
  5353                                  ;notest3:
  5354                                  ;		mov	al,one_char_val ;AN000; move char into AX
  5355                                  ;		mov	dx,offset trangroup:inornot_ptr 
  5356                                  ;					; Load invalid fname error ptr
  5357                                  ;		invoke	pathchrcmp	; Is the char in al a path sep?
  5358                                  ;		jz	errj		; Yes, error - 2nd arg must be
  5359                                  ;					;  filename only.
  5360                                  ;		mov	ah,FCB_Rename
  5361                                  ;		mov	dx,FCB
  5362                                  ;		int	21h
  5363                                  ;		cmp	al, 0FFH	; Did an error occur??
  5364                                  ;		jnz	renameok
  5365                                  ;
  5366                                  ;		invoke	get_ext_error_number ;AN022; get extended error
  5367                                  ;		SaveReg <AX>		;AC022; Save results
  5368                                  ;		mov	al, 0FFH	; Restore original error state
  5369                                  ;
  5370                                  ;renameok:
  5371                                  ;		push	ax
  5372                                  ;		invoke	restudir
  5373                                  ;		pop	ax
  5374                                  ;		inc	al
  5375                                  ;		retnz
  5376                                  ;
  5377                                  ;		RestoreReg  <AX>	;AC022; get the error number back
  5378                                  ;		cmp	ax,error_file_not_found 
  5379                                  ;					;AN022; error file not found?
  5380                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5381                                  ;		cmp	ax,error_access_denied
  5382                                  ;					;AN022; error file not found?
  5383                                  ;		jz	use_renerr	;AN022; yes - use generic error message
  5384                                  ;		jmp	extend_setup	;AN022; need long jump - use extended error
  5385                                  ;
  5386                                  ;use_renerr:
  5387                                  ;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
  5388                                  ;ERRJ:
  5389                                  ;		jmp	Cerror
  5390                                  ;
  5391                                  ;ret56:		ret
  5392                                  
  5393                                  		; MSDOS 3.3
  5394 00001202 BA[6D3D]                		mov	dx,BADARGSPTR
  5395 00001205 E87107                  		call	SCANOFF
  5396 00001208 3C0D                    		cmp	al,0Dh
  5397 0000120A 74D6                    		jz	short ERRJ2
  5398 0000120C E80E08                  		call	PATHCRUNCH
  5399 0000120F BA[4C3D]                		mov	dx,BADCPMESPTR
  5400 00001212 74CE                    		jz	short ERRJ2
  5401 00001214 7309                    		jnb	short CRENAME_NO_PARSE_ERROR
  5402 00001216 803E[6C44]00            		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
  5403 0000121B 7402                    		jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
  5404 0000121D EBBF                    		jmp	short BADCDERR
  5405                                  
  5406                                  ;  Get first file name returned from parse into our buffer
  5407                                  
  5408                                  CRENAME_NO_PARSE_ERROR:
  5409 0000121F 8B36[C043]              		mov	si,[PATHPOS]
  5410 00001223 E85307                  		call	SCANOFF
  5411 00001226 3C0D                    		cmp	al,0Dh
  5412 00001228 BA[6D3D]                		mov	dx,BADARGSPTR
  5413 0000122B 7443                    		jz	short ERRJ
  5414 0000122D B03A                    		mov	al,':'
  5415 0000122F BA[223A]                		mov	dx,BADPARMPTR
  5416 00001232 384401                  		cmp	[si+1],al
  5417 00001235 7439                    		jz	short ERRJ
  5418                                  
  5419                                  ;  Get second file name returned from parse into the FCB. Save
  5420                                  ;  character after file name so we can later check to make sure it
  5421                                  ;  isn't a path character.
  5422                                  
  5423                                  REN_NO_DRIVE:
  5424                                  		;mov	di,6Ch
  5425 00001237 BF6C00                  		mov	di,FCB+10h
  5426 0000123A B80129                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
  5427 0000123D CD21                    		int	21h	; DOS -	PARSE FILENAME
  5428                                  				; DS:SI	-> string to parse
  5429                                  				; ES:DI	-> buffer to fill with unopened	FCB
  5430                                  				; AL = bit mask	to control parsing
  5431 0000123F B020                    		mov	al,' '
  5432                                  		;cmp	[6Dh],al
  5433 00001241 38066D00                		cmp	[FCB+10h+1],al	; Check if parameter exists
  5434 00001245 7429                    		jz	short ERRJ	; Error if missing parameter
  5435 00001247 AC                      		lodsb
  5436 00001248 BA[E738]                		mov	dx,INORNOTPTR
  5437 0000124B E8BE07                  		call	PATHCHRCMP
  5438 0000124E 7420                    		jz	short ERRJ
  5439 00001250 B417                    		mov	ah,FCB_RENAME ; 17h
  5440 00001252 BA5C00                  		mov	dx,FCB ; 5Ch
  5441 00001255 CD21                    		int	21h	; DOS -	RENAME FILE via	FCB
  5442                                  				; DS:DX	-> FCB
  5443                                  				; FCB contains new name	starting at byte 17h.
  5444 00001257 3CFF                    		cmp	al,0FFh		; Did an error occur??	
  5445 00001259 750A                    		jnz	short RENAMEOK
  5446 0000125B F9                      		stc
  5447 0000125C BA[E537]                		mov	dx,RENERRPTR
  5448 0000125F E8680C                  		call	GET_EXT_ERR_NUMBER ; get extended error
  5449 00001262 52                      		push	dx
  5450 00001263 B0FF                    		mov	al,0FFh		; Restore original error state
  5451                                  RENAMEOK:
  5452 00001265 50                      		push	ax
  5453 00001266 E83206                  		call	RESTUDIR
  5454 00001269 58                      		pop	ax
  5455 0000126A FEC0                    		inc	al
  5456 0000126C 7401                    		jz	short RENAME_ERR
  5457                                  RENAME_RETN:
  5458                                  TYPELP_RET:
  5459 0000126E C3                      		retn
  5460                                  RENAME_ERR:
  5461 0000126F 5A                      		pop	dx
  5462                                  ERRJ:					; Retro DOS v3.0
  5463 00001270 E85722                  		call	STD_EPRINTF
  5464 00001273 E98EEE                  		jmp	TCOMMAND
  5465                                  
  5466                                  ; ---------------------------------------------------------------------------
  5467                                  
  5468                                  ;ERRJ:
  5469                                  ;		jmp	CERROR
  5470                                  
  5471                                  ; ---------------------------------------------------------------------------
  5472                                  
  5473                                  ;TYPELP_RET:
  5474                                  ;		retn
  5475                                  
  5476                                  ; ---------------------------------------------------------------------------
  5477                                  
  5478                                  ;****************************************************************
  5479                                  ;*
  5480                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
  5481                                  ;*		standard output device
  5482                                  ;*
  5483                                  ;* SYNTAX:	TYPE filespec
  5484                                  ;*
  5485                                  ;* FUNCTION:	If a valid filespec is found, read the file until
  5486                                  ;*		1Ah and display the contents to STDOUT.
  5487                                  ;*
  5488                                  ;* INPUT:	command line at offset 81H
  5489                                  ;*
  5490                                  ;* OUTPUT:	none
  5491                                  ;*
  5492                                  ;****************************************************************
  5493                                  
  5494                                  TYPEFIL:
  5495                                  		; MSDOS 6.0	
  5496                                  		;assume	ds:trangroup,es:trangroup
  5497                                  
  5498                                  ;		mov	si,81H
  5499                                  ;		mov	di,offset trangroup:parse_mrdir 
  5500                                  ;					;AN000; Get adderss of PARSE_MRDIR
  5501                                  ;		xor	cx,cx		;AN000; clear cx,dx
  5502                                  ;		xor	dx,dx		;AN000;
  5503                                  ;		invoke	parse_with_msg	;AC018; call parser
  5504                                  ;		cmp	ax,result_no_error ;AC000; did we have an error?
  5505                                  ;		jnz	typefil_parse_error ;AN000; yes - issue error message
  5506                                  ;
  5507                                  ;		push	si		;AC000; save position in line
  5508                                  ;		lds	si,parse1_addr	;AC000; get address of filespec
  5509                                  ;		invoke	move_to_srcbuf	;AC000; move to srcbuf
  5510                                  ;		pop	si		;AC000; get position back
  5511                                  ;		mov	di,offset trangroup:parse_mrdir 
  5512                                  ;					;AC000; get address of parse_mrdir
  5513                                  ;		invoke	parse_check_eol ;AC000; are we at end of line?
  5514                                  ;		jz	gottarg 	;AC000; yes - continue
  5515                                  ;
  5516                                  ;typefil_parse_error:			;AN000; no - set up error message and exit
  5517                                  ;		jmp	Cerror
  5518                                  ;
  5519                                  ;gottarg:
  5520                                  ;		invoke	setpath
  5521                                  ;		test	[destinfo],00000010b ; Does the filespec contain wildcards
  5522                                  ;		jz	nowilds 	; No, continue processing
  5523                                  ;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
  5524                                  ;		jmp	Cerror
  5525                                  ;nowilds:
  5526                                  ;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
  5527                                  ;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
  5528                                  ;		xor	cx,cx		;AN000; no special files
  5529                                  ;		mov	dx,read_open_flag ;AN000; set up open flags
  5530                                  ;		mov	si,offset trangroup:srcbuf ;AN030; get file name
  5531                                  ;		int	21h
  5532                                  ;		jnc	typecont	; If open worked, continue. Otherwise load
  5533                                  ;
  5534                                  ;Typerr: 				;AN022;
  5535                                  ;		push	cs		;AN022; make sure we have local segment
  5536                                  ;		pop	ds		;AN022;
  5537                                  ;		invoke	set_ext_error_msg ;AN022;
  5538                                  ;		mov	string_ptr_2,offset trangroup:srcbuf 
  5539                                  ;					;AC022; get address of failed string
  5540                                  ;		mov	Extend_buf_sub,one_subst
  5541                                  ;					;AC022; put number of subst in control block
  5542                                  ;		jmp	cerror		;AC022; exit
  5543                                  ;
  5544                                  ;typecont:
  5545                                  ;		mov	bx,ax		;AC000; get  Handle
  5546                                  ;;M043
  5547                                  ;; We should do the LSEEK for filesize only if this handle belongs to a file
  5548                                  ;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
  5549                                  ;;indicate it is a device.
  5550                                  ;;
  5551                                  ;		mov	ax,(IOCTL shl 8) or 0
  5552                                  ;		int	21h
  5553                                  ;
  5554                                  ;		test	dl,80h		;is it a device?
  5555                                  ;		jz	not_device	;no, a file
  5556                                  ;
  5557                                  ;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
  5558                                  ;		jmp	short dotype
  5559                                  ;not_device:
  5560                                  ;
  5561                                  ;;SR;
  5562                                  ;; Find the filesize by seeking to the end and then reset file pointer to
  5563                                  ;;start of file
  5564                                  ;;
  5565                                  ;		mov	ax,(LSEEK shl 8) or 2
  5566                                  ;		xor	dx,dx
  5567                                  ;		mov	cx,dx		;seek  to end of file
  5568                                  ;		int	21h
  5569                                  ;
  5570                                  ;		mov	word ptr TypeFilSiz,ax
  5571                                  ;		mov	word ptr TypeFilSiz+2,dx ;store filesize
  5572                                  ;
  5573                                  ;		mov	ax,(LSEEK shl 8) or 0
  5574                                  ;		xor	dx,dx
  5575                                  ;		int	21h	        ;reset file pointer to start
  5576                                  ;dotype:					;M043
  5577                                  ;		mov	zflag,0 	; Reset ^Z flag
  5578                                  ;		mov	ds,[TPA]
  5579                                  ;		xor	dx,dx
  5580                                  ;		;ASSUME	DS:NOTHING
  5581                                  ;
  5582                                  ;typelp:
  5583                                  ;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
  5584                                  ;		retnz			; Yes, return
  5585                                  ;		mov	cx,cs:[bytcnt]	;AC056; No, continue
  5586                                  ;;
  5587                                  ;;Update the filesize left to read
  5588                                  ;;
  5589                                  ;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
  5590                                  ;		je	typ_read	;yes, just read from it; M043
  5591                                  ;
  5592                                  ;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
  5593                                  ;		jz	lt64k		;no, do word subtraction
  5594                                  ;		sub	word ptr cs:TypeFilSiz,cx
  5595                                  ;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
  5596                                  ;      		jmp	short typ_read	;do the read
  5597                                  ;lt64k:
  5598                                  ;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
  5599                                  ;		jbe	gtbuf		; yes, just update readsize
  5600                                  ;;
  5601                                  ;;Buffer size is larger than bytes to read
  5602                                  ;;
  5603                                  ;		mov	cx,word ptr cs:TypeFilSiz
  5604                                  ;		jcxz	typelp_ret
  5605                                  ;		mov	word ptr cs:TypeFilSiz,0
  5606                                  ;		jmp	short typ_read
  5607                                  ;gtbuf:
  5608                                  ;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
  5609                                  ;typ_read:
  5610                                  ;		mov	ah,read
  5611                                  ;		int	21h		
  5612                                  ;		jnc	@f		;M043
  5613                                  ;		jmp	typerr		;M043
  5614                                  ;@@:					;M043
  5615                                  ;;M043;		jc	typerr		;AN022; Exit if error
  5616                                  ;
  5617                                  ;		mov	cx,ax
  5618                                  ;		jcxz	typelp_ret	;AC000; exit if nothing read
  5619                                  ;		push	ds
  5620                                  ;		pop	es		; Check to see if a ^Z was read.
  5621                                  ;		;assume es:nothing
  5622                                  ;		xor	di,di
  5623                                  ;		push	ax
  5624                                  ;		mov	al,1ah
  5625                                  ;		repnz	scasb
  5626                                  ;		pop	ax
  5627                                  ;		xchg	ax,cx
  5628                                  ;		cmp	ax,0
  5629                                  ;		jnz	foundz		; Yes, handle it
  5630                                  ;		cmp	byte ptr [di-1],1ah ; No, double check
  5631                                  ;		jnz	typecont2	; No ^Z, continue
  5632                                  ;
  5633                                  ;foundz:
  5634                                  ;		sub	cx,ax		; Otherwise change cx so that only those
  5635                                  ;		dec	cx		;  bytes up to but NOT including the ^Z
  5636                                  ;		push	cs		;  will be typed.
  5637                                  ;		pop	es
  5638                                  ;		;assume es:trangroup
  5639                                  ;		not	zflag		; Turn on ^Z flag so that the routine
  5640                                  ;typecont2:				;  will quit after this write.
  5641                                  ;		push	bx
  5642                                  ;		mov	bx,1
  5643                                  ;		mov	ah,write
  5644                                  ;		int	21h
  5645                                  ;		pop	bx
  5646                                  ;		jc	Error_outputj
  5647                                  ;		cmp	ax,cx
  5648                                  ;		jnz	@f		;M043
  5649                                  ;		jmp	typelp		;M043
  5650                                  ;@@:					;M043
  5651                                  ;;M043;		jz	typelp
  5652                                  ;		dec	cx
  5653                                  ;		cmp	ax,cx
  5654                                  ;		retz			; One less byte OK (^Z)
  5655                                  ;Error_outputj:
  5656                                  ;		mov	bx,1
  5657                                  ;		mov	ax,IOCTL SHL 8
  5658                                  ;		int	21h
  5659                                  ;		test	dl,devid_ISDEV
  5660                                  ;		retnz			; If device, no error message
  5661                                  ;		jmp	error_output
  5662                                  ;typelp_ret:
  5663                                  ;		ret
  5664                                  
  5665                                  		; MSDOS 3.3
  5666 00001276 BE8100                  		mov	si,81h
  5667 00001279 E8FD06                  		call	SCANOFF		; Skip to first non-delim
  5668 0000127C 3C0D                    		cmp	al,0Dh
  5669 0000127E 7505                    		jnz	short GOTTARG
  5670 00001280 BA[6D3D]                		mov	dx,BADARGSPTR
  5671                                  
  5672                                  		;jmp	CERROR
  5673 00001283 EBEB                    		jmp	short ERRJ	; No args
  5674                                  GOTTARG:
  5675 00001285 E8EF0A                  		call	SETPATH
  5676 00001288 F606[7044]02            		test	byte [DESTINFO],2
  5677 0000128D 7405                    		jz	short NOWILDS
  5678 0000128F BA[E738]                		mov	dx,INORNOTPTR
  5679                                  
  5680                                  		;jmp	CERROR
  5681 00001292 EBDC                    		jmp	short ERRJ
  5682                                  NOWILDS:
  5683 00001294 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  5684 00001297 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  5685                                  				; DS:DX	-> ASCIZ filename
  5686                                  				; AL = access mode
  5687                                  				; 0 - read
  5688 00001299 7311                    		jnc	short TYPECONT
  5689 0000129B BA[F837]                		mov	dx,FNOTFOUNDPTR
  5690 0000129E 83F802                  		cmp	ax,2
  5691 000012A1 74CD                    		jz	short ERRJ
  5692 000012A3 BA[4C3D]                		mov	dx,BADCPMESPTR
  5693 000012A6 F9                      		stc
  5694 000012A7 E8200C                  		call	GET_EXT_ERR_NUMBER
  5695                                  
  5696                                  		;jmp	CERROR
  5697 000012AA EBC4                    		jmp	short ERRJ
  5698                                  TYPECONT:
  5699 000012AC C606[F74B]00            		mov	byte [ZFLAG],0	; Reset ^Z flag
  5700 000012B1 89C3                    		mov	bx,ax		; Handle
  5701 000012B3 8E1E[7342]              		mov	ds,[TPA]
  5702 000012B7 31D2                    		xor	dx,dx
  5703                                  TYPELP:
  5704 000012B9 2E803E[F74B]00          		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
  5705 000012BF 75AD                    		jnz	short RENAME_RETN ; Yes, return	
  5706 000012C1 2E8B0E[9242]            		mov	cx,[cs:BYTCNT]	; No, continue
  5707 000012C6 B43F                    		mov	ah,READ ; 3Fh
  5708 000012C8 CD21                    		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
  5709                                  				; BX = file handle,CX = number	of bytes to read
  5710                                  				; DS:DX	-> buffer
  5711 000012CA 89C1                    		mov	cx,ax
  5712 000012CC E3A0                    		jcxz	TYPELP_RET	; exit if nothing read
  5713                                  					; Check to see if a ^Z was read.
  5714 000012CE 1E                      		push	ds
  5715 000012CF 07                      		pop	es		
  5716 000012D0 31FF                    		xor	di,di
  5717 000012D2 50                      		push	ax
  5718 000012D3 B01A                    		mov	al,1Ah
  5719 000012D5 F2AE                    		repne scasb
  5720 000012D7 58                      		pop	ax
  5721 000012D8 91                      		xchg	ax,cx
  5722 000012D9 83F800                  		cmp	ax,0
  5723 000012DC 7506                    		jnz	short FOUNDZ	; Yes, handle it
  5724 000012DE 807DFF1A                		cmp	byte [di-1],1Ah	; No, double check
  5725 000012E2 750A                    		jnz	short TYPECONT2	; No ^Z, continue
  5726                                  FOUNDZ:
  5727 000012E4 29C1                    		sub	cx,ax		; Otherwise change cx so that only those
  5728 000012E6 49                      		dec	cx		;  bytes up to but NOT including the ^Z
  5729 000012E7 0E                      		push	cs		;  will be typed.
  5730 000012E8 07                      		pop	es
  5731 000012E9 2EF616[F74B]            		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
  5732                                  					;  will quit after this write.
  5733                                  TYPECONT2:
  5734 000012EE 53                      		push	bx
  5735 000012EF BB0100                  		mov	bx,1
  5736 000012F2 B440                    		mov	ah,WRITE ; 40h
  5737 000012F4 CD21                    		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
  5738                                  				; BX = file handle, CX = number of bytes to write,
  5739                                  				; DS:DX -> buffer
  5740 000012F6 5B                      		pop	bx
  5741 000012F7 720A                    		jc	short ERROR_OUTPUTJ
  5742 000012F9 39C8                    		cmp	ax,cx
  5743 000012FB 74BC                    		jz	short TYPELP
  5744 000012FD 49                      		dec	cx
  5745 000012FE 39C8                    		cmp	ax,cx		; One less byte OK (^Z)
  5746 00001300 7501                    		jnz	short ERROR_OUTPUTJ
  5747                                  TYPEFIL_RETN:
  5748 00001302 C3                      		retn
  5749                                  ERROR_OUTPUTJ:
  5750 00001303 BB0100                  		mov	bx,1
  5751 00001306 B80044                  		mov	ax,IOCTL*256 ; 4400h
  5752 00001309 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  5753                                  				; BX = file or device handle
  5754                                  		;test	dl,devid_ISDEV
  5755 0000130B F6C280                  		test	dl,80h
  5756 0000130E 75F2                    		jnz	short TYPEFIL_RETN ; If device, no error message
  5757 00001310 E9DF06                  		jmp	ERROR_OUTPUT
  5758                                  
  5759                                  ; ---------------------------------------------------------------------------
  5760                                  
  5761                                  ; VOLUME command displays the volume ID on the specified drive
  5762                                  
  5763                                  VOLUME:
  5764                                  		; MSDOS 6.0
  5765                                  		;mov	si,81H
  5766                                  		;mov	di,offset trangroup:parse_vol
  5767                                  		;			;AN000; Get adderss of PARSE_VOL
  5768                                  		;xor	cx,cx		;AN000; clear cx,dx
  5769                                  		;xor	dx,dx		;AN000;
  5770                                  		;invoke	parse_with_msg	;AC018; call parser
  5771                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  5772                                  		;jz	OkVolArg	;AC000; Yes, display default volume ID
  5773                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  5774                                  		;jnz	BadVolArg	;AC000; Yes, fail.
  5775                                  
  5776                                  ; We have parsed off the drive. See if there are any more chars left
  5777                                  
  5778                                  		;mov	di,offset trangroup:parse_vol	
  5779                                  					;AC000; get address of parse_vol
  5780                                  		;xor	dx,dx		;AC000;
  5781                                  		;invoke	parse_check_eol ;AC000; call parser
  5782                                  		;jz	OkVolArg	;AC000; yes, end of road
  5783                                  
  5784                                  ; The line was not interpretable. Report an error.
  5785                                  
  5786                                  ;badvolarg:
  5787                                  		;jmp	Cerror
  5788                                  
  5789                                  		; MSDOS 3.3
  5790 00001313 BE8100                  		mov	si,81h
  5791 00001316 E86006                  		call	SCANOFF		; Skip to first non-delim
  5792                                  		;mov	ah,[5Ch]
  5793 00001319 8A265C00                		mov	ah,[FCB]
  5794                                  		;mov	byte [5Ch],0
  5795 0000131D C6065C0000              		mov	byte [FCB],0
  5796 00001322 3C0D                    		cmp	al,0Dh		; are we at end of line?
  5797 00001324 7417                    		jz	short OKVOLARG	; Yes, display default volume ID
  5798                                  		;mov	[5Ch],ah
  5799 00001326 88265C00                		mov	[FCB],ah
  5800 0000132A AC                      		lodsb
  5801 0000132B AC                      		lodsb
  5802 0000132C 3C3A                    		cmp	al,':'
  5803 0000132E 7507                    		jnz	short VOLUME_ERR
  5804 00001330 E84606                  		call	SCANOFF
  5805 00001333 3C0D                    		cmp	al,0Dh
  5806 00001335 7406                    		jz	short OKVOLARG
  5807                                  VOLUME_ERR:
  5808 00001337 BA[4939]                		mov	dx,BADDRVPTR
  5809 0000133A E9EC08                  		jmp	CERROR
  5810                                  
  5811                                  ; ---------------------------------------------------------------------------
  5812                                  
  5813                                  OKVOLARG:
  5814 0000133D E82C06                  		call	CRLF2
  5815 00001340 1E                      		push	ds
  5816 00001341 07                      		pop	es
  5817                                  		;mov	di,55h
  5818 00001342 BF5500                  		mov	di,FCB-7	; Set up extended FCB
  5819 00001345 B0FF                    		mov	al,-1
  5820 00001347 AA                      		stosb
  5821 00001348 31C0                    		xor	ax,ax
  5822 0000134A AB                      		stosw
  5823 0000134B AB                      		stosw
  5824 0000134C AA                      		stosb
  5825 0000134D B008                    		mov	al,8		; Look for volume label
  5826 0000134F AA                      		stosb
  5827 00001350 47                      		inc	di		; Skip drive byte
  5828 00001351 B90B00                  		mov	cx,11
  5829 00001354 B03F                    		mov	al,'?'
  5830 00001356 F3AA                    		rep stosb
  5831 00001358 BA[6A43]                		mov	dx,DIRBUF
  5832 0000135B B41A                    		mov	ah,SET_DMA ; 1Ah
  5833 0000135D CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
  5834                                  				; DS:DX	-> disk	transfer buffer
  5835                                  		;mov	dx,55h
  5836 0000135F BA5500                  		mov	dx,FCB-7
  5837 00001362 B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
  5838 00001364 CD21                    		int	21h	; DOS -	SEARCH FIRST USING FCB
  5839                                  				; DS:DX	-> FCB
  5840 00001366 E9F915                  		jmp	PRINTVOL
  5841                                  
  5842                                  ;============================================================================
  5843                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
  5844                                  ;============================================================================
  5845                                  ; 08/10/2018 - Retro DOS v3.0
  5846                                  
  5847                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
  5848                                  
  5849                                  ; ---------------------------------------------------------------------------
  5850                                  
  5851                                  ; MSDOS 6.0
  5852                                  ;***	Version - display DOS version
  5853                                  ;
  5854                                  ;	SYNTAX	ver [/debug]
  5855                                  ;
  5856                                  ;		/debug - display additional DOS configuration info
  5857                                  ;
  5858                                  ;	ENTRY	command-line tail is in PSP
  5859                                  ;
  5860                                  ;	EXIT	if successful, nothing
  5861                                  ;		if parse fails,
  5862                                  ;		  parse error message is set up (for Std_EPrintf)
  5863                                  ;		    AX = system parser error code
  5864                                  ;		    DX = ptr to message block
  5865                                  ;		  we jump to CError
  5866                                  ;
  5867                                  ;	EFFECTS
  5868                                  ;	  If parse fails, a parse error message is displayed.
  5869                                  ;	  Otherwise, version message is displayed.
  5870                                  ;	  If /debug is specified, additional DOS info is displayed.
  5871                                  
  5872                                  ;	assume	ds:TRANGROUP,es:TRANGROUP
  5873                                  ;
  5874                                  ;;	Parse command line for /debug switch.
  5875                                  ;
  5876                                  ;	mov	si,81h				; DS:SI = ptr to command tail
  5877                                  ;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
  5878                                  ;	xor	cx,cx				; CX = # positional param's found
  5879                                  ;	invoke	Parse_With_Msg
  5880                                  ;
  5881                                  ;	mov	bl,1			; BL = flag = /debug present
  5882                                  ;	cmp	ax,RESULT_NO_ERROR
  5883                                  ;	je	verPrintVer		; something parsed - must be /debug
  5884                                  ;	dec	bl			; BL = flag = no /debug present
  5885                                  ;	cmp	ax,END_OF_LINE
  5886                                  ;	je	verPrintVer		; reached end of line - ok
  5887                                  ;
  5888                                  ;;	The parse failed.  Error message has been set up.
  5889                                  ;
  5890                                  ;	jmp	CError
  5891                                  ;
  5892                                  ;verPrintVer:
  5893                                  ;	push	bx			; save /debug flag
  5894                                  ;	call	Crlf2
  5895                                  ;	call	Print_Version
  5896                                  ;	call	Crlf2
  5897                                  ;	pop	bx   			; BL = /debug flag
  5898                                  ;	or	bl,bl
  5899                                  ;	jz	verDone			; /debug is false - we're done
  5900                                  ;
  5901                                  ;;*	For /debug, display DOS internal revision and DOS location
  5902                                  ;;	(low memory, HMA, or ROM).
  5903                                  ;
  5904                                  ;;	Bugbug:	use symbols for bitmasks below.
  5905                                  ;
  5906                                  ;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
  5907                                  ;	int	21h
  5908                                  ;	mov	al,dl			;revision number in dl; M013
  5909                                  ;	mov	bh,dh			;flags in dh now; M013
  5910                                  ;;M032	and	al,7			; AL = DOS internal revision
  5911                                  ;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
  5912                                  ;	jbe	@f		;M032	; A-to-Z revision ok
  5913                                  ;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
  5914                                  ;@@:	add	al,'A'			; AL = DOS internal rev letter
  5915                                  ;	mov	One_Char_Val,al
  5916                                  ;	mov	dx,offset TRANGROUP:DosRev_Ptr
  5917                                  ;	invoke	Std_Printf		; print DOS internal revision
  5918                                  ;
  5919                                  ;	mov	cl,4
  5920                                  ;	shr	bh,cl			; CY = DOS in ROM
  5921                                  ;	jc	verRom
  5922                                  ;	shr	bh,1			; CY = DOS in HMA
  5923                                  ;	jc	verHma
  5924                                  ;
  5925                                  ;;	DOS isn't in ROM or HMA, so it must be in lower memory.
  5926                                  ;
  5927                                  ;	mov	dx,offset TRANGROUP:DosLow_Ptr
  5928                                  ;	jmp	short verPrintLoc
  5929                                  ;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
  5930                                  ;	jmp	short verPrintLoc
  5931                                  ;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
  5932                                  ;verPrintLoc:
  5933                                  ;	invoke	Std_Printf
  5934                                  ;verDone:
  5935                                  ;	jmp	Crlf2
  5936                                  
  5937                                  		; MSDOS 3.3
  5938                                  VERSION:
  5939 00001369 E80006                  		call	CRLF2
  5940 0000136C E80300                  		call	PRINT_VERSION
  5941 0000136F E9FA05                  		jmp	CRLF2
  5942                                  
  5943                                  ; =============== S U B	R O U T	I N E =======================================
  5944                                  
  5945                                  PRINT_VERSION:
  5946 00001372 B430                    		mov	ah,GET_VERSION ; 30h
  5947 00001374 CD21                    		int	21h	; DOS -	GET DOS	VERSION
  5948                                  				; Return: AL = major version number (00h for DOS 1.x)
  5949 00001376 50                      		push	ax
  5950 00001377 30E4                    		xor	ah,ah
  5951 00001379 A3[5D44]                		mov	[MAJOR_VER_NUM],ax
  5952 0000137C 58                      		pop	ax
  5953 0000137D 86E0                    		xchg	ah,al
  5954 0000137F 30E4                    		xor	ah,ah
  5955 00001381 A3[5F44]                		mov	[MINOR_VER_NUM],ax
  5956 00001384 BA[273B]                		mov	dx,VERMESPTR
  5957 00001387 E94921                  		jmp	STD_PRINTF
  5958                                  
  5959                                  ; =============== S U B	R O U T	I N E =======================================
  5960                                  
  5961                                  PRINT_PROMPT:
  5962 0000138A 1E                      		push	ds
  5963 0000138B 0E                      		push	cs
  5964 0000138C 1F                      		pop	ds		; Make sure Ds is in TRANGROUP
  5965 0000138D 06                      		push	es
  5966 0000138E E80304                  		call	FIND_PROMPT	; Look for prompt string
  5967 00001391 7206                    		jc	short PP0	; Can't find one	
  5968 00001393 26803D00                		cmp	byte [es:di],0
  5969 00001397 750A                    		jnz	short PP1
  5970                                  PP0:					; Use default prompt
  5971 00001399 E87200                  		call	PRINT_DRIVE
  5972                                  		;mov	al,'>'
  5973 0000139C B03E                    		mov	al,SYM
  5974 0000139E E85A00                  		call	PRINT_CHAR
  5975 000013A1 EB3A                    		jmp	short PP5
  5976                                  PP1:
  5977 000013A3 268A05                  		mov	al,[es:di]	; Get a char
  5978 000013A6 47                      		inc	di
  5979 000013A7 08C0                    		or	al,al
  5980 000013A9 7432                    		jz	short PP5	; Nul terminated
  5981 000013AB 3A06[F43E]              		cmp	al,[DOLLAR]	; Meta character
  5982 000013AF 7405                    		jz	short PP2	; Nope
  5983 000013B1 E84700                  		call	PRINT_CHAR
  5984 000013B4 EBED                    		jmp	short PP1
  5985                                  PP2:
  5986 000013B6 268A05                  		mov	al,[es:di]
  5987 000013B9 47                      		inc	di
  5988                                  		;mov	bx,CLSSTRING+2	; "[2J"
  5989 000013BA BB[9C3D]                		mov	bx,PROMPT_TABLE-3
  5990 000013BD 08C0                    		or	al,al
  5991 000013BF 741C                    		jz	short PP5
  5992                                  PP3:
  5993 000013C1 83C303                  		add	bx,3
  5994                                  		;call	UPCONV
  5995 000013C4 E85704                  		call	UPCONV_MAPCALL
  5996 000013C7 3A07                    		cmp	al,[bx]
  5997 000013C9 7407                    		jz	short PP4
  5998 000013CB 803F00                  		cmp	byte [bx],0
  5999 000013CE 75F1                    		jnz	short PP3
  6000 000013D0 EBD1                    		jmp	short PP1
  6001                                  PP4:
  6002 000013D2 06                      		push	es
  6003 000013D3 57                      		push	di
  6004 000013D4 0E                      		push	cs
  6005 000013D5 07                      		pop	es
  6006 000013D6 FF5701                  		call	word [bx+1]
  6007 000013D9 5F                      		pop	di
  6008 000013DA 07                      		pop	es
  6009 000013DB EBC6                    		jmp	short PP1
  6010                                  PP5:
  6011 000013DD 07                      		pop	es		; Restore segments
  6012 000013DE 1F                      		pop	ds
  6013 000013DF C3                      		retn
  6014                                  
  6015                                  ; ---------------------------------------------------------------------------
  6016                                  
  6017                                  PRINT_BACK:
  6018 000013E0 BA[943D]                		mov	dx,DBACKPTR
  6019 000013E3 E9ED20                  		jmp	STD_PRINTF
  6020                                  
  6021                                  ; ---------------------------------------------------------------------------
  6022                                  
  6023                                  PRINT_EQ:
  6024 000013E6 B03D                    		mov	al,'='
  6025 000013E8 EB11                    		jmp	short PRINT_CHAR
  6026                                  
  6027                                  ; ---------------------------------------------------------------------------
  6028                                  
  6029                                  PRINT_ESC:
  6030 000013EA B01B                    		mov	al,1Bh
  6031 000013EC EB0D                    		jmp	short PRINT_CHAR
  6032                                  
  6033                                  ; ---------------------------------------------------------------------------
  6034                                  
  6035                                  PRINT_G:
  6036 000013EE A0[F33E]                		mov	al,[RABRACKET]
  6037 000013F1 EB08                    		jmp	short PRINT_CHAR
  6038                                  
  6039                                  ; ---------------------------------------------------------------------------
  6040                                  
  6041                                  PRINT_L:
  6042 000013F3 A0[F23E]                		mov	al,[LABRACKET]
  6043 000013F6 EB03                    		jmp	short PRINT_CHAR
  6044                                  
  6045                                  ; ---------------------------------------------------------------------------
  6046                                  
  6047                                  PRINT_B:
  6048 000013F8 A0[F13E]                		mov	al,[VBAR]
  6049                                  
  6050                                  ; =============== S U B	R O U T	I N E =======================================
  6051                                  
  6052                                  PRINT_CHAR:
  6053                                  		; MSDOS 6.0
  6054                                  
  6055                                  ;	Bugbug:	Why bother with ds,es here?
  6056                                  		
  6057                                  		;push	es
  6058                                  		;push	ds
  6059                                  		;pop	es
  6060                                  		;push	di
  6061                                  		;push	dx
  6062                                  		;mov	dl,al		;AC000; Get char into al
  6063                                  		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
  6064                                  		;int	21h		;AC000;
  6065                                  		;pop	dx
  6066                                  		;pop	di
  6067                                  		;pop	es
  6068                                  		;retn
  6069                                  
  6070                                  		; MSDOS 3.3
  6071 000013FB 06                      		push	es
  6072 000013FC 1E                      		push	ds
  6073 000013FD 07                      		pop	es
  6074 000013FE 57                      		push	di
  6075 000013FF 52                      		push	dx
  6076 00001400 BF[6144]                		mov	di,ONE_CHAR_VAL	
  6077 00001403 AA                      		stosb
  6078 00001404 BA[303B]                		mov	dx,ONECHRVALPTR
  6079 00001407 E8C920                  		call	STD_PRINTF
  6080 0000140A 5A                      		pop	dx
  6081 0000140B 5F                      		pop	di
  6082 0000140C 07                      		pop	es
  6083 0000140D C3                      		retn
  6084                                  
  6085                                  ; ---------------------------------------------------------------------------
  6086                                  
  6087                                  PRINT_DRIVE:
  6088 0000140E B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h
  6089 00001410 CD21                    		int	21h	; DOS -	GET DEFAULT DISK NUMBER
  6090                                  		;add	al,'A'
  6091 00001412 0206[F03E]              		add	al,[CAPITAL_A]
  6092 00001416 E8E2FF                  		call	PRINT_CHAR
  6093 00001419 C3                      		retn
  6094                                  
  6095                                  ; ---------------------------------------------------------------------------
  6096                                  
  6097                                  BUILD_DIR_FOR_PROMPT:
  6098 0000141A 30D2                    		xor	dl,dl
  6099 0000141C BE[6A43]                		mov	si,BWDBUF
  6100 0000141F 89F7                    		mov	di,si
  6101 00001421 A0[8542]                		mov	al,[CURDRV]
  6102 00001424 0441                    		add	al,'A'
  6103 00001426 B43A                    		mov	ah,':'
  6104 00001428 AB                      		stosw
  6105 00001429 A0[7642]                		mov	al,[DIRCHAR]
  6106 0000142C AA                      		stosb
  6107 0000142D 87F7                    		xchg	si,di
  6108 0000142F 893E[4E44]              		mov	[STRING_PTR_2],di
  6109 00001433 B447                    		mov	ah,CURRENT_DIR ; 47h
  6110 00001435 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6111                                  				; DL = drive (0=default,1=A,etc.)
  6112                                  				; DS:SI	points to 64-byte buffer area
  6113 00001437 BA[3F37]                		mov	dx,STRINGBUF2PTR
  6114 0000143A 7303                    		jnc	short DOPRINT
  6115 0000143C BA[EB39]                		mov	dx,BADCURDRVPTR
  6116                                  DOPRINT:
  6117 0000143F E89120                  		call	STD_PRINTF
  6118 00001442 C3                      		retn
  6119                                  
  6120                                  ; =============== S U B	R O U T	I N E =======================================
  6121                                  
  6122                                  BUILD_DIR_FOR_CHDIR:
  6123 00001443 E80E00                  		call	BUILD_DIR_STRING
  6124 00001446 BA[6A43]                		mov	dx,DIRBUF
  6125 00001449 8916[4E44]              		mov	[STRING_PTR_2],dx
  6126                                  		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
  6127 0000144D BA[3F37]                		mov	dx,STRINGBUF2PTR
  6128 00001450 E88020                  		call	STD_PRINTF
  6129 00001453 C3                      		retn
  6130                                  
  6131                                  
  6132                                  ; =============== S U B	R O U T	I N E =======================================
  6133                                  
  6134                                  BUILD_DIR_STRING:
  6135 00001454 8A165C00                		mov	dl,[FCB] ; mov dl,[5Ch]
  6136 00001458 88D0                    		mov	al,dl
  6137 0000145A 0440                    		add	al,'@'
  6138 0000145C 3C40                    		cmp	al,'@'
  6139 0000145E 7506                    		jnz	short GOTDRIVE
  6140 00001460 0206[8542]              		add	al,[CURDRV]
  6141 00001464 FEC0                    		inc	al
  6142                                  GOTDRIVE:
  6143 00001466 50                      		push	ax
  6144 00001467 BE[6D43]                		mov	si,BWDBUF+3
  6145 0000146A B447                    		mov	ah,CURRENT_DIR ; 47h
  6146 0000146C CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  6147                                  				; DL = drive (0=default,1=A,etc.)
  6148                                  				; DS:SI	points to 64-byte buffer area
  6149 0000146E 7305                    		jnc	short DPBISOK
  6150 00001470 0E                      		push	cs
  6151 00001471 1F                      		pop	ds
  6152 00001472 E96306                  		jmp	DRVBAD
  6153                                  DPBISOK:
  6154 00001475 BF[6A43]                		mov	di,BWDBUF
  6155 00001478 89FA                    		mov	dx,di
  6156 0000147A 58                      		pop	ax
  6157 0000147B B43A                    		mov	ah,':'
  6158 0000147D AB                      		stosw
  6159 0000147E A0[7642]                		mov	al,[DIRCHAR]
  6160 00001481 AA                      		stosb
  6161 00001482 C3                      		retn
  6162                                  
  6163                                  ; ---------------------------------------------------------------------------
  6164                                  
  6165                                  PATH:
  6166                                  		; MSDOS 6.0
  6167                                  		;xor	al,al		;AN049; Set up holding buffer
  6168                                  		;mov	di,offset Trangroup:srcxname
  6169                                  					;AN049;   for PATH while parsing
  6170                                  		;stosb				;AN049; Initialize PATH to null
  6171                                  		;dec	di			;AN049; point to the start of buffer
  6172                                  		;invoke	PGetarg 		; Pre scan for arguments
  6173                                  		;jz	disppath		; Print the current path
  6174                                  		;cmp	al,semicolon		;AC049; NUL path argument?
  6175                                  		;jnz	pathslp 		;AC049;
  6176                                  		;inc	si			;AN049; point past semicolon
  6177                                  		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
  6178                                  ;pathslp:					; Get the user specified path
  6179                                  		;lodsb				; Get a character
  6180                                  		;cmp	al,end_of_line_in	;AC049; Is it end of line?
  6181                                  		;jz	path_eol		;AC049; yes - end of command
  6182                                  		;invoke	testkanj		;See if DBCS
  6183                                  		;jz	notkanj2		;No - continue
  6184                                  		;stosb				;AC049; Yes - store the first byte
  6185                                  		;lodsb				;skip second byte of DBCS
  6186                                  ;path_hold:					;AN049;
  6187                                  		;stosb				;AC049; Store a byte in the PATH buffer
  6188                                  		;jmp	short pathslp		;continue parsing
  6189                                  ;notkanj2:
  6190                                  		;invoke	upconv			;upper case the character
  6191                                  		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
  6192                                  		;jz	path_hold		;AC049; go store it
  6193                                  		;invoke	delim			;delimiter?
  6194                                  		;jnz	path_hold		;AC049; no - go store character
  6195                                  ;scan_white:					;AN049; make sure were at EOL
  6196                                  		;lodsb				;AN049; get a character
  6197                                  		;cmp	al,end_of_line_in	;AN049; end of line?
  6198                                  		;jz	path_eol		;AN049; yes - go set path
  6199                                  		;cmp	al,blank		;AN049; whitespace?
  6200                                  		;jz	scan_white		;AN049; yes - continue scanning
  6201                                  		;cmp	al,tab_chr		;AN049; whitespace?
  6202                                  		;jz	scan_white		;AN049; yes - continue scanning
  6203                                  
  6204                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  6205                                  						;AN049; no - set up error message
  6206                                  		;mov	Extend_Buf_ptr,MoreArgs_ptr
  6207                                  						;AN049; get "Too many parameters" message number
  6208                                  		;mov	msg_disp_class,parse_msg_class
  6209                                  						;AN049; set up parse error msg class
  6210                                  		;jmp	cerror			;AN049;
  6211                                  ;path_eol:					;AN049; Parsing was clean
  6212                                  		;xor	al,al			;AN049; null terminate the PATH
  6213                                  		;stosb				;AN049;    buffer
  6214                                  		;invoke	find_path		;AN049; Find PATH in environment
  6215                                  		;invoke	delete_path		;AC049; Delete any offending name
  6216                                  		;invoke	scan_double_null	;AC049; Scan to end of environment
  6217                                  		;invoke	move_name		;AC049; move in PATH=
  6218                                  		;mov	si,offset Trangroup:srcxname	
  6219                                  						;AN049; Set up source as PATH buffer
  6220                                  ;store_path:					;AN049; Store the PATH in the environment
  6221                                  		;lodsb				;AN049; Get a character
  6222                                  		;cmp	al,end_of_line_out	;AN049; null character?
  6223                                  		;jz	got_paths		;AN049; yes - exit
  6224                                  		;invoke	store_char		;AN049; no - store character
  6225                                  		;jmp	short store_path	;AN049; continue
  6226                                  ;got_paths:					;AN049; we're finished
  6227                                  		;xor	ax,ax			;	null terminate the PATH in
  6228                                  		;stosw				;    	the environment
  6229                                  		;return
  6230                                  ;disppath:
  6231                                  		;invoke	find_path		;AN049;
  6232                                  		;call	print_path
  6233                                  		;call	crlf2
  6234                                  		;retn
  6235                                  
  6236                                  		; MSDOS 3.3
  6237 00001483 E80903                  		call	FIND_PATH		; Find PATH in environment
  6238 00001486 E86209                  		call	PGETARG			; Pre scan for arguments
  6239 00001489 742A                    		jz	short DISPPATH		; Print the current path
  6240 0000148B E8DF02                  		call	DELETE_PATH		; Delete any offending name
  6241 0000148E E86B03                  		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
  6242 00001491 E84903                  		call	MOVE_NAME		; Move in PATH=
  6243 00001494 E85409                  		call	PGETARG
  6244 00001497 3C3B                    		cmp	al,';'
  6245 00001499 7416                    		jz	short GOTPATHS
  6246                                  PATHSLP:
  6247 0000149B AC                      		lodsb
  6248 0000149C 3C0D                    		cmp	al,0Dh			; End of line (CR) ?		
  6249 0000149E 7411                    		jz	short GOTPATHS		; yes - exit
  6250                                  		;call	UPCONV
  6251 000014A0 E87B03                  		call	UPCONV_MAPCALL		; convert to uppercase
  6252 000014A3 3C3B                    		cmp	al,';'			; ';' not a delimiter on PATH
  6253 000014A5 7405                    		jz	short NOTDELIM		; go set path
  6254 000014A7 E8D704                  		call	DELIM			; is it delim/null char ?
  6255 000014AA 7405                    		jz	short GOTPATHS		; yes - exit
  6256                                  NOTDELIM:
  6257 000014AC E88303                  		call	STORE_CHAR		; no - store character
  6258 000014AF EBEA                    		jmp	short PATHSLP
  6259                                  GOTPATHS:
  6260 000014B1 31C0                    		xor	ax,ax			; null terminate the PATH
  6261 000014B3 AB                      		stosw				; in the environment
  6262 000014B4 C3                      		retn
  6263                                  DISPPATH:
  6264 000014B5 E80400                  		call	PRINT_PATH
  6265 000014B8 E8B104                  		call	CRLF2
  6266 000014BB C3                      		retn
  6267                                  
  6268                                  ; =============== S U B	R O U T	I N E =======================================
  6269                                  
  6270                                  PRINT_PATH:
  6271 000014BC 26803D00                		cmp	byte [es:di],0
  6272 000014C0 750A                    		jnz	short PATH1
  6273                                  PATH0:
  6274 000014C2 BA[0B3C]                		mov	dx,NULLPATHPTR
  6275 000014C5 0E                      		push	cs
  6276 000014C6 07                      		pop	es
  6277 000014C7 0E                      		push	cs
  6278 000014C8 1F                      		pop	ds
  6279 000014C9 E90720                  		jmp	STD_PRINTF
  6280                                  PATH1:
  6281 000014CC 06                      		push	es
  6282 000014CD 1F                      		pop	ds
  6283 000014CE 83EF05                  		sub	di,5
  6284 000014D1 89FE                    		mov	si,di
  6285 000014D3 E84003                  		call	SCASB2		; Look for null
  6286 000014D6 81F9FF00                		cmp	cx,0FFh
  6287 000014DA 74E6                    		jz	short PATH0
  6288 000014DC 0E                      		push	cs
  6289 000014DD 07                      		pop	es
  6290 000014DE BF[C843]                		mov	di,ARG_BUF
  6291 000014E1 BA0001                  		mov	dx,100h
  6292 000014E4 29CA                    		sub	dx,cx
  6293 000014E6 87D1                    		xchg	dx,cx
  6294 000014E8 F3A4                    		rep movsb
  6295 000014EA BA[2337]                		mov	dx,ARG_BUF_PTR
  6296 000014ED 0E                      		push	cs
  6297 000014EE 1F                      		pop	ds
  6298 000014EF E9E11F                  		jmp	STD_PRINTF
  6299                                  
  6300                                  ; ---------------------------------------------------------------------------
  6301                                  
  6302                                  ; ****************************************************************
  6303                                  ; *
  6304                                  ; * ROUTINE:	 CLS
  6305                                  ; *
  6306                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
  6307                                  ; *		 installed, send a control string to clear the
  6308                                  ; *		 screen.
  6309                                  ; *
  6310                                  ; * INPUT:	 command line at offset 81H
  6311                                  ; *
  6312                                  ; * OUTPUT:	 none
  6313                                  ; *
  6314                                  ; ****************************************************************
  6315                                  
  6316                                  ; MSDOS 3.3
  6317                                  
  6318                                  CLS:
  6319 000014F2 BB0100                  		mov	bx,STDOUT ; 1
  6320 000014F5 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6321 000014F8 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6322                                  				; BX = file or device handle
  6323 000014FA F6C280                  		test	dl,80h	; devid_ISDEV
  6324 000014FD 744C                    		jz	short ANSICLS	; If a file put out ANSI
  6325 000014FF F6C210                  		test	dl,10h  ; devid_SPECIAL
  6326 00001502 7447                    		jz	short ANSICLS	; If not special CON, do ANSI
  6327                                  
  6328 00001504 B82935                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
  6329 00001507 CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6330                                  				; AL = interrupt number
  6331                                  				; Return: ES:BX	= value	of interrupt vector
  6332 00001509 8CC2                    		mov	dx,es
  6333 0000150B B82035                  		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
  6334 0000150E CD21                    		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
  6335                                  				; AL = interrupt number
  6336                                  				; Return: ES:BX	= value	of interrupt vector
  6337 00001510 8CC0                    		mov	ax,es
  6338 00001512 39C2                    		cmp	dx,ax	; If not default driver, do ANSI
  6339 00001514 7735                    		ja	short ANSICLS
  6340                                  
  6341 00001516 B40F                    		mov	ah,0Fh
  6342 00001518 CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6343                                  				; Return: AH = number of columns on screen
  6344                                  				; AL = current video mode
  6345                                  				; BH = current active display page
  6346 0000151A 3C03                    		cmp	al,3
  6347 0000151C 7609                    		jbe	short DOALPHA
  6348 0000151E 3C07                    		cmp	al,7
  6349 00001520 7405                    		jz	short DOALPHA
  6350 00001522 B400                    		mov	ah,0
  6351 00001524 CD10                    		int	10h	; - VIDEO - SET	VIDEO MODE
  6352                                  				; AL = mode
  6353 00001526 C3                      		retn
  6354                                  
  6355                                  DOALPHA:
  6356 00001527 B40B                    		mov	ah,0Bh	; Set overscan to black
  6357 00001529 31DB                    		xor	bx,bx
  6358 0000152B CD10                    		int	10h	; - VIDEO - SET	COLOR PALETTE
  6359                                  				; BH = 00h, BL = border color
  6360                                  				; BH = 01h, BL = palette (0-3)
  6361 0000152D B40F                    		mov	ah,0Fh
  6362 0000152F CD10                    		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
  6363                                  				; Return: AH = number of columns on screen
  6364                                  				; AL = current video mode
  6365                                  				; BH = current active display page
  6366 00001531 88E2                    		mov	dl,ah
  6367 00001533 FECA                    		dec	dl
  6368 00001535 B618                    		mov	dh,24
  6369 00001537 31C0                    		xor	ax,ax
  6370 00001539 89C1                    		mov	cx,ax
  6371 0000153B BB0007                  		mov	bx,700h
  6372 0000153E B406                    		mov	ah,6
  6373 00001540 CD10                    		int	10h	; - VIDEO - SCROLL PAGE	UP
  6374                                  				; AL = number of lines to scroll window	
  6375                                  				;	(0 = blank whole window)
  6376                                  				; BH = attributes to be	used on	blanked	lines
  6377                                  				; CH,CL	= row,column of	upper left corner of window 
  6378                                  				;	  to scroll
  6379                                  				; DH,DL	= row,column of	lower right corner of window
  6380 00001542 31D2                    		xor	dx,dx
  6381 00001544 B700                    		mov	bh,0
  6382 00001546 B402                    		mov	ah,2
  6383 00001548 CD10                    		int	10h	; - VIDEO - SET	CURSOR POSITION
  6384                                  				; DH,DL	= row,column (0,0 = upper left)
  6385                                  				; BH = page number
  6386 0000154A C3                      		retn
  6387                                  
  6388                                  ANSICLS:
  6389 0000154B BE[9A3D]                		mov	si,CLSSTRING
  6390 0000154E AC                      		lodsb
  6391 0000154F 88C1                    		mov	cl,al
  6392 00001551 30ED                    		xor	ch,ch
  6393 00001553 B406                    		mov	ah,RAW_CON_IO ; 6
  6394                                  CLRLOOP:
  6395 00001555 AC                      		lodsb
  6396 00001556 88C2                    		mov	dl,al
  6397 00001558 CD21                    		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
  6398                                  				; DL = character <> FFh
  6399                                  				;  Return: ZF set = no character
  6400                                  				;   ZF clear = character recieved, AL = character
  6401 0000155A E2F9                    		loop	CLRLOOP
  6402 0000155C C3                      		retn
  6403                                  
  6404                                  ; ---------------------------------------------------------------------------
  6405                                  
  6406                                  ; MSDOS 6.0
  6407                                  
  6408                                  ;ANSI_installed		equ    0ffh
  6409                                  ;
  6410                                  ;CLS:
  6411                                  ;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
  6412                                  ;	mov	al,0			;AN000;
  6413                                  ;	int	2fh			;AN000;
  6414                                  ;	cmp	al,ANSI_installed	;AN000;
  6415                                  ;	jz	ansicls 		;AN000; installed - go do ANSI CLS
  6416                                  ;
  6417                                  ;check_lines:
  6418                                  ;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
  6419                                  ;					;AN000; get lines per page on display
  6420                                  ;	mov	bx,stdout		;AN000; lines for stdout
  6421                                  ;	mov	ch,ioc_sc		;AN000; type is display
  6422                                  ;	mov	cl,get_generic		;AN000; get information
  6423                                  ;	mov	dx,offset trangroup:display_ioctl ;AN000;
  6424                                  ;	int	21h			;AN000;
  6425                                  ;	jc	no_variable		;AN000; function had error, use default
  6426                                  ;	mov	ax,linperpag		;AN000; get number of rows returned
  6427                                  ;	mov	dh,al			;AN000; set number of rows
  6428                                  ;	mov	ax,display_width	;AN000; get number of columns returned
  6429                                  ;	mov	dl,al			;AN000; set number of columns
  6430                                  ;	jmp	short regcls		;AN000; go do cls
  6431                                  ;
  6432                                  ;no_variable:
  6433                                  ;	mov	bx,stdout		;AC000; set handle as stdout
  6434                                  ;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
  6435                                  ;	int	21h			;AC000;
  6436                                  ;	test	dl,devid_ISDEV		;AC000; is handle a device
  6437                                  ;	jz	ANSICLS 		;AC000; If a file put out ANSI
  6438                                  ;	test	dl,devid_SPECIAL	;AC000;
  6439                                  ;	jnz	cls_normal		;AC000; If not special CON, do ANSI
  6440                                  ;
  6441                                  ;ansicls:
  6442                                  ;	call	ansi_cls		;AN000; clear the screen
  6443                                  ;	jmp	short cls_ret		;AN000; exit
  6444                                  ;
  6445                                  ;;
  6446                                  ;; Get video mode
  6447                                  ;;
  6448                                  ;
  6449                                  ;cls_normal:				;AC000;
  6450                                  ;
  6451                                  ;	mov	ah,get_video_state	;AC000; set up to get video state
  6452                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6453                                  ;	cmp	al,video_alpha		;AC000; see if in text mode
  6454                                  ;	jbe	DoAlpha
  6455                                  ;	cmp	al,video_bw		;AC000; see if black & white card
  6456                                  ;	jz	DoAlpha
  6457                                  ;;
  6458                                  ;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
  6459                                  ;; be just as bogus and set the mode that we just got. This will blank the
  6460                                  ;; screen too.
  6461                                  ;;
  6462                                  ;	mov	ah,set_video_mode	;AC000; set video mode call
  6463                                  ;	int	video_io_int		;AC000; do int 10h - BIOS video IO
  6464                                  ;	jmp	short cls_ret		;AC000; exit
  6465                                  ;
  6466                                  ;DoAlpha:
  6467                                  ;;
  6468                                  ;; Get video mode and number of columns to scroll
  6469                                  ;;
  6470                                  ;
  6471                                  ;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
  6472                                  ;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
  6473                                  ;;M01   area
  6474                                  ;;M01   Commented out code here is the original
  6475                                  ;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
  6476                                  ;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
  6477                                  ;;M01	mov	dl,ah
  6478                                  ;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
  6479                                  ;
  6480                                  ;;M01   Following code lifted from a fix Compaq applied to ANSI
  6481                                  ;
  6482                                  ;	push	ds
  6483                                  ;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
  6484                                  ;	MOV	DS,AX			;  *			M01
  6485                                  ;	Assume	DS:ROMBIOS_DATA
  6486                                  ;
  6487                                  ;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
  6488                                  ;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
  6489                                  ;	pop	ds			;			M01
  6490                                  ;	Assume	DS:Trangroup
  6491                                  ;
  6492                                  ;	or	dh,dh			; Q:ZERO		M01
  6493                                  ;	jnz	regcls			;  *JMP IF NO		M01
  6494                                  ;
  6495                                  ;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
  6496                                  ;
  6497                                  ;regcls:
  6498                                  ;	inc	dh			; height+1		M018
  6499                                  ;	call	reg_cls 		; go clear the screen
  6500                                  ;
  6501                                  ;cls_ret:
  6502                                  ;	ret				; exit
  6503                                  
  6504                                  ; ---------------------------------------------------------------------------
  6505                                  
  6506                                  ; MSDOS 6.0
  6507                                  
  6508                                  ; ****************************************************************
  6509                                  ; *
  6510                                  ; * ROUTINE:	 REG_CLS
  6511                                  ; *
  6512                                  ; * FUNCTION:	 Clear the screen using INT 10H.
  6513                                  ; *
  6514                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
  6515                                  ; *		 DH = NUMBER OF ROWS
  6516                                  ; *
  6517                                  ; * OUTPUT:	 none
  6518                                  ; *
  6519                                  ; ****************************************************************
  6520                                  
  6521                                  ;reg_cls proc	near
  6522                                  ;
  6523                                  ;;
  6524                                  ;; Set overscan to black.
  6525                                  ;;
  6526                                  ;	dec	dh			;  decrement rows and columns
  6527                                  ;	dec	dl			;     to zero base
  6528                                  ;	push	dx			;  save rows,columns
  6529                                  ;	mov	ah,set_color_palette	;  set up to set the color to blank
  6530                                  ;	xor	bx,bx
  6531                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6532                                  ;	pop	dx			;  retore rows,colums
  6533                                  ;
  6534                                  ;	xor	ax,ax			;  zero out ax
  6535                                  ;	mov	CX,ax			;     an cx
  6536                                  ;;
  6537                                  ;; Scroll active page
  6538                                  ;;
  6539                                  ;	mov	ah,scroll_video_page	; set up to scroll page up
  6540                                  ;	mov	bh,video_attribute	; attribute for blank line
  6541                                  ;	xor	bl,bl			; set BL to 0
  6542                                  ;	int	video_io_int		; do int 10h - BIOS video IO
  6543                                  ;;
  6544                                  ;; Seek to cursor to 0,0
  6545                                  ;;
  6546                                  ;;M022 following two lines added
  6547                                  ;	mov	ah,get_video_state	; get current video page in BH
  6548                                  ;	int	video_io_int
  6549                                  ;	mov	ah,set_cursor_position	; set up to set cursor position
  6550                                  ;	xor	dx,dx			; row and column 0
  6551                                  ;;M022	mov	bh.0
  6552                                  ;	int	video_io_int		; do into 10h - BIOS video IO
  6553                                  ;
  6554                                  ;	ret
  6555                                  ;
  6556                                  ;reg_cls endp
  6557                                  
  6558                                  ; ---------------------------------------------------------------------------
  6559                                  
  6560                                  ; MSDOS 6.0
  6561                                  
  6562                                  ; ****************************************************************
  6563                                  ; *
  6564                                  ; * ROUTINE:	 ANSI_CLS
  6565                                  ; *
  6566                                  ; * FUNCTION:	 Clear the screen using by writing a control code
  6567                                  ; *		 to STDOUT.
  6568                                  ; *
  6569                                  ; * INPUT:	 none
  6570                                  ; *
  6571                                  ; * OUTPUT:	 none
  6572                                  ; *
  6573                                  ; ****************************************************************
  6574                                  
  6575                                  ;ansi_cls proc	near			;AC000;
  6576                                  ;
  6577                                  ;	mov	si,offset trangroup:clsstring
  6578                                  ;	lodsb
  6579                                  ;	mov	cl,al
  6580                                  ;	xor	ch,ch
  6581                                  ;	mov	ah,Raw_CON_IO
  6582                                  ;clrloop:
  6583                                  ;	lodsb
  6584                                  ;	mov	DL,al
  6585                                  ;	int	21h
  6586                                  ;	loop	clrloop
  6587                                  ;	return
  6588                                  ;
  6589                                  ;ansi_cls	endp			;AC000;
  6590                                  
  6591                                  ;============================================================================
  6592                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
  6593                                  ;============================================================================
  6594                                  ; 08/10/2018 - Retro DOS v3.0
  6595                                  
  6596                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
  6597                                  
  6598                                  ; ---------------------------------------------------------------------------
  6599                                  
  6600                                  ; ****************************************************************
  6601                                  ; *
  6602                                  ; * ROUTINE:	 CTTY - Change console
  6603                                  ; *
  6604                                  ; * SYNTAX:	 CTTY device
  6605                                  ; *
  6606                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
  6607                                  ; *		 duplicate the device handle to STDIN, STDOUT and
  6608                                  ; *		 STDERR.  This routine returns to LODCOM1.
  6609                                  ; *
  6610                                  ; * INPUT:	 command line at offset 81H
  6611                                  ; *
  6612                                  ; * OUTPUT:	 none
  6613                                  ; *
  6614                                  ; ****************************************************************
  6615                                  
  6616                                  CTTY:
  6617                                  		; MSDOS 6.0
  6618                                  		;push	ds			;AN000; Get local ES
  6619                                  		;pop	es			;AN000;
  6620                                  		;mov	si,81H			;AC000; Get command argument for CTTY
  6621                                  
  6622                                  		;mov	di,offset trangroup:parse_ctty	
  6623                                  						;AC000; Get adderss of PARSE_CTTY
  6624                                  		;xor	cx,cx			;AC000; clear cx,dx
  6625                                  		;xor	dx,dx			;AC000;
  6626                                  		;invoke	cmd_parse		;AC000; call parser
  6627                                  		;cmp	ax,end_of_line		;AN000; are we at end of line?
  6628                                  		;jz	ctty_error		;AN000; yes - error
  6629                                  		;cmp	ax,result_no_error	;AN000; did an error occur
  6630                                  		;jnz	ctty_error		;AN000; YES -ERROR
  6631                                  
  6632                                  		;push	si			;AN000; save position in line
  6633                                  		;lds	si,parse1_addr		;AN000; get address of filespec
  6634                                  		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf
  6635                                  
  6636                                  ;ctty_move_filename:				;AN000; put filespec in srcbuf
  6637                                  		;lodsb				;AN000; get a char from buffer
  6638                                  		;stosb				;AN000; store in srcbuf
  6639                                  		;cmp	al,end_of_line_out	;AN000; it char a terminator?
  6640                                  		;jnz	ctty_move_filename	;AN000; no - keep moving
  6641                                  		;pop	si			;AN000; get line position back
  6642                                  		;mov	di,offset trangroup:parse_ctty	
  6643                                  						;AC000; Get adderss of PARSE_CTTY
  6644                                  		;call	parse_check_eol 	;AN000; are we at end of line?
  6645                                  		;jz	nocolon 		;AN000; yes - continue
  6646                                  
  6647                                  ;ctty_error:
  6648                                  		;jmp	short isbaddev		;AC000; yes - exit
  6649                                  
  6650                                  		; MSDOS 3.3
  6651 0000155D E81708                  		call	SETPATH
  6652 00001560 4E                      		dec	si
  6653 00001561 4E                      		dec	si
  6654 00001562 803C3A                  		cmp	byte [si],':'
  6655 00001565 7503                    		jnz	short NOCOLON
  6656 00001567 C60400                  		mov	byte [si],0
  6657                                  NOCOLON:
  6658                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6659                                  		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
  6660 0000156A B8023D                  		mov	ax,(OPEN<<8)|2 ; 3D02h
  6661 0000156D CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  6662                                  				; DS:DX	-> ASCIZ filename
  6663                                  				; AL = access mode
  6664                                  				; 2 - read & write
  6665 0000156F 7210                    		jc	short ISBADDEV
  6666 00001571 89C3                    			mov	bx,ax
  6667 00001573 B80044                  		mov	ax,IOCTL*256 ; 4400h
  6668 00001576 CD21                    		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
  6669                                  				; BX = file or device handle
  6670 00001578 F6C280                  		test	dl,80h
  6671 0000157B 750C                    		jnz	short DEVISOK
  6672                                  CLOSEDEV:
  6673 0000157D B43E                    		mov	ah,CLOSE ; 3Eh ; Close initial handle
  6674 0000157F CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6675                                  				; BX = file handle
  6676                                  ISBADDEV:
  6677 00001581 BA[533C]                		mov	dx,BADDEVPTR
  6678 00001584 E84C1F                  		call	STD_PRINTF
  6679 00001587 EB28                    		jmp	short RESRET
  6680                                  
  6681                                  		;nop
  6682                                  DEVISOK:
  6683                                  		; MSDOS 6.0
  6684                                  		;push	dx		;AN007; save device info
  6685                                  		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
  6686                                  		;mov	dh,util_msg_class ;AN021; this is a utility message
  6687                                  		;push	bx		;AN021; save handle
  6688                                  		;invoke	Tsysgetmsg	;AN021; get the address of the message
  6689                                  		;mov	dx,si		;AN021; get address into dx
  6690                                  		;mov	ax,(write shl 8) ;AN007; write to device
  6691                                  		;mov	cx,2		;AN007; write two bytes
  6692                                  		;int	21h		;AN007;
  6693                                  		;pop	bx		;AN021; get back handle
  6694                                  		;pop	dx		;AN007; get back device info
  6695                                  		;jc	closedev	;AN007; if error, quit
  6696                                  
  6697                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6698 00001589 30F6                    		xor	dh,dh
  6699 0000158B 80CA03                  		or	dl,3
  6700                                  		;MOV	AX,(IOCTL SHL 8) OR 1
  6701 0000158E B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
  6702 00001591 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
  6703                                  				; BX = device handle,DH = 0
  6704                                  				; DL = device information to set 
  6705                                  				;		(bits 0-7 from	function 0)
  6706 00001593 53                      		push	bx
  6707 00001594 B90300                  		mov	cx,3
  6708 00001597 31DB                    		xor	bx,bx
  6709                                  
  6710                                  ICLLOOP:				; Close basic handles
  6711 00001599 B43E                    		mov	ah,CLOSE ; 3Eh
  6712 0000159B CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6713                                  				; BX = file handle
  6714 0000159D 43                      		inc	bx
  6715 0000159E E2F9                    		loop	ICLLOOP
  6716 000015A0 5B                      		pop	bx		; Get handle
  6717 000015A1 B445                    		mov	ah,XDUP ; 45h
  6718 000015A3 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6719                                  				; BX = file handle to duplicate
  6720 000015A5 B445                    		mov	ah,XDUP ; 45h
  6721 000015A7 CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6722                                  				; BX = file handle to duplicate
  6723 000015A9 B445                    		mov	ah,XDUP ;45h
  6724 000015AB CD21                    		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
  6725                                  				; BX = file handle to duplicate
  6726 000015AD B43E                    		mov	ah,CLOSE ; 3Eh
  6727 000015AF CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  6728                                  				; BX = file handle
  6729                                  RESRET:
  6730 000015B1 8E1E[7142]              		mov	ds,[RESSEG]
  6731 000015B5 1E                      		push	ds
  6732 000015B6 A11800                  		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
  6733 000015B9 A3EF0B                  		mov	word [IO_SAVE],ax
  6734                                  		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
  6735                                  		;mov	ax,31Eh ;  MSDOS 3.3
  6736 000015BC B81803                  		mov	ax,LODCOM1
  6737 000015BF 50                      		push	ax
  6738                                  
  6739 000015C0 CB                      		retf		; Far return
  6740                                  
  6741                                  ; ---------------------------------------------------------------------------
  6742                                  
  6743                                  ;****************************************************************
  6744                                  ;*
  6745                                  ;* ROUTINE:	CHCP - Change code page internal command
  6746                                  ;*		(added DOS 3.30 07/21/86)
  6747                                  ;*
  6748                                  ;* SYNTAX:	CHCP [xxx]
  6749                                  ;*		where xxx is a valid code page
  6750                                  ;*
  6751                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
  6752                                  ;*		6402H to set the code page to xxxx. If no parameters
  6753                                  ;*		are specified, CHCP will use INT 21H function 6401H
  6754                                  ;*		to get global code page and display it to the user.
  6755                                  ;*
  6756                                  ;* INPUT:	command line at offset 81H
  6757                                  ;*
  6758                                  ;* OUTPUT:	none
  6759                                  ;*
  6760                                  ;****************************************************************
  6761                                  
  6762                                  ;NLSFUNC_installed equ  0FFh
  6763                                  set_global_cp	  equ   2
  6764                                  get_global_cp	  equ   1
  6765                                  
  6766                                  CHCP:
  6767                                  		; MSDOS 6.0
  6768                                  		;push	ds		;AN000; Get local ES
  6769                                  		;pop	es		;AN000;
  6770                                  		;mov	si,81H		;AC000; Get command argument for CHCP
  6771                                  
  6772                                  		;mov	di,offset trangroup:parse_chcp	
  6773                                  					;AN000; Get adderss of PARSE_CHCP
  6774                                  		;xor	cx,cx		;AC000; clear cx,dx
  6775                                  		;xor	dx,dx		;AC000;
  6776                                  		;call	parse_with_msg	;AC018; call parser
  6777                                  		;cmp	ax,end_of_line	;AN000; are we at end of line?
  6778                                  
  6779                                  		;;jnz	setcp		;AC000; no go get number & set code page
  6780                                  		;jz	getcp		;AC000; yes - no parm - get code page
  6781                                  ;setcp:
  6782                                  		;cmp	ax,result_no_error ;AN000; did we have an error?
  6783                                  		;jne	cp_error	;AC018; yes - go issue message
  6784                                  
  6785                                  		;push	cx		;AN000; save positional count
  6786                                  		;mov	bx,offset trangroup:parse1_addr 
  6787                                  					;AN000; get number returned
  6788                                  		;mov	cx,word ptr [bx] ;AN000;     into cx
  6789                                  		;mov	system_cpage,cx ;AN000; save user input number
  6790                                  		;pop	cx		;AC000; restore positional count
  6791                                  		;mov	di,offset trangroup:parse_chcp	
  6792                                  					;AN000; Get adderss of PARSE_CHCP
  6793                                  		;call	parse_check_eol ;AN000; are we at end of line?
  6794                                  		;jnz	cp_error	;AC000; no - exit
  6795                                  ;okset:
  6796                                  		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
  6797                                  		;mov	al,0		;AN000;
  6798                                  		;int	2fh		;AN000;
  6799                                  		;cmp	al,NLSFUNC_installed ;AN000;
  6800                                  		;jz	got_NLS 	;AN000; Yes - continue
  6801                                  		;mov	dx,offset trangroup:NLSFUNC_ptr
  6802                                  					;AN000; no - set up error message
  6803                                  		;jmp	short cp_error	;AN000; error exit
  6804                                  ;got_NLS:
  6805                                  
  6806                                  		; MSDOS 3.3
  6807 000015C1 BE8100                  		mov	si,81h
  6808 000015C4 E8B203                  		call	SCANOFF
  6809 000015C7 3C0D                    		cmp	al,0Dh ; CR
  6810 000015C9 7502                    		jnz	short SETCP
  6811 000015CB EB72                    		jmp	short GETCP
  6812                                  
  6813                                  		;nop
  6814                                  SETCP:
  6815 000015CD 31DB                    		xor	bx,bx
  6816 000015CF 89D9                    		mov	cx,bx
  6817 000015D1 89D8                    		mov	ax,bx
  6818                                  GET_CP_DIGIT:
  6819 000015D3 AC                      		lodsb
  6820 000015D4 3C30                    		cmp	al,'0'
  6821 000015D6 721C                    		jb	short CHRNOTNUMBER
  6822 000015D8 3C39                    		cmp	al,'9'
  6823 000015DA 7718                    		ja	short CHRNOTNUMBER
  6824 000015DC 2C30                    		sub	al,'0'
  6825 000015DE FEC1                    		inc	cl
  6826 000015E0 80F904                  		cmp	cl,4
  6827 000015E3 771B                    		ja	short CHCP_BADPARM
  6828 000015E5 89DA                    		mov	dx,bx
  6829 000015E7 D1E2                    		shl	dx,1
  6830 000015E9 D1E2                    		shl	dx,1
  6831 000015EB 01D3                    		add	bx,dx
  6832 000015ED D1E3                    		shl	bx,1
  6833 000015EF 01C3                    		add	bx,ax
  6834 000015F1 EBE0                    		jmp	short GET_CP_DIGIT
  6835                                  CP_NEXTCHR:
  6836 000015F3 AC                      		lodsb
  6837                                  CHRNOTNUMBER:
  6838 000015F4 3C20                    		cmp	al,' '		; SPACE
  6839 000015F6 74FB                    		jz	short CP_NEXTCHR
  6840 000015F8 3C09                    		cmp	al,9		; TAB
  6841 000015FA 74F7                    		jz	short CP_NEXTCHR
  6842 000015FC 3C0D                    		cmp	al,0Dh		; CR
  6843 000015FE 7406                    		jz	short SET_CP_TBL_NUM
  6844                                  CHCP_BADPARM:
  6845 00001600 BA[223A]                		mov	dx,BADPARMPTR
  6846 00001603 E92306                  		jmp	CERROR
  6847                                  ;GOT_NLS:
  6848                                  SET_CP_TBL_NUM:
  6849                                  		; MSDOS 3.3 (& MSDOS 6.0)
  6850 00001606 891E[0F3F]              		mov	word [SYSTEM_CPAGE],bx
  6851 0000160A B466                    		mov	ah,GETSETCDPG  ; 66h
  6852 0000160C B002                    		mov	al,set_global_cp ; 2
  6853 0000160E CD21                    		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
  6854                                  				; BX = active code page
  6855                                  				; DX = system code page	(active	page at	boot time)
  6856 00001610 733D                    		jnc	short CHCP_RETURN
  6857                                  
  6858 00001612 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
  6859 00001615 7511                    		jnz	short CHCP_OTHER_ERROR
  6860                                  
  6861 00001617 B459                    		mov	ah,GETEXTENDEDERROR ; 59h
  6862 00001619 31DB                    		xor	bx,bx
  6863 0000161B CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6864                                  				; BX = version code (0000h for DOS 3.x)
  6865 0000161D 83F80D                  		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
  6866 00001620 7417                    		jz	short NONE_SET
  6867 00001622 BA[F837]                		mov	dx,FNOTFOUNDPTR
  6868 00001625 E90106                  		jmp	CERROR
  6869                                  CHCP_OTHER_ERROR:			; end of p716
  6870 00001628 B459                    		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
  6871 0000162A 31DB                    		xor	bx,bx
  6872 0000162C CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  6873                                  				; BX = version code (0000h for DOS 3.x)
  6874 0000162E 83F841                  		cmp	ax,65		;was it access denied?
  6875 00001631 7506                    		jnz	short NONE_SET	;no - assume all failed
  6876 00001633 BA[A839]                		mov	dx,CPNOTALLPTR	;set up message
  6877 00001636 E9F005                  		jmp	CERROR		;AC000; error exit
  6878                                  NONE_SET:
  6879 00001639 BA[7539]                		mov	dx,CPNOTSETPTR	;set up message
  6880                                  CP_ERROR:
  6881 0000163C E9EA05                  		jmp	CERROR		;exit
  6882                                  GETCP:
  6883 0000163F B466                    		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
  6884 00001641 B001                    		mov	al,get_global_cp ; 1 ;minor - get
  6885 00001643 CD21                    		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
  6886 00001645 891E[0F3F]              		mov	word [SYSTEM_CPAGE],bx ;get active cp for output
  6887 00001649 BA[C639]                		mov	dx,CPACTIVEPTR
  6888 0000164C E8841E                  		call	STD_PRINTF	;print it out
  6889                                  CHCP_RETURN:
  6890 0000164F C3                      		retn
  6891                                  
  6892                                  ; ---------------------------------------------------------------------------
  6893                                  
  6894                                  ; ****************************************************************
  6895                                  ; *
  6896                                  ; * ROUTINE:	 TRUENAME
  6897                                  ; *
  6898                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
  6899                                  ; *		 Parses the command line. If a path is found, set
  6900                                  ; *		 SRCXNAME to path.  If only a drive letter is
  6901                                  ; *		 found, set SRCXNAME to the drive letter.  If
  6902                                  ; *		 no path is found, set the path of SRCXNAME to
  6903                                  ; *		 dot (.) for current directory.  Use the NAME
  6904                                  ; *		 TRANSLATE system call to get the real name and
  6905                                  ; *		 then display the real name.  If an error occurs
  6906                                  ; *		 issue an error message and transfer control to
  6907                                  ; *		 CERROR.
  6908                                  ; *
  6909                                  ; * INPUT:	 command line at offset 81H
  6910                                  ; *
  6911                                  ; * OUTPUT:	 none
  6912                                  ; *
  6913                                  ; ****************************************************************
  6914                                  
  6915                                  ;assume	ds:trangroup,es:trangroup		;AN000;
  6916                                  ;
  6917                                  ;TRUENAME:					;AN000; TRUENAME entry point
  6918                                  ;	push	ds				;AN000; Get local ES
  6919                                  ;	pop	es				;AN000;
  6920                                  ;	mov	si,81H				;AN000; Get command line
  6921                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
  6922                                  ;	xor	cx,cx				;AN000; clear cx,dx
  6923                                  ;	xor	dx,dx				;AN000;
  6924                                  ;	call	parse_with_msg			;AC018; call parser
  6925                                  ;
  6926                                  ;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
  6927                                  ;	cmp	ax,end_of_line			;AN000; are we at end of line?
  6928                                  ;	je	tn_eol				;AN000; yes - go process
  6929                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  6930                                  ;	jne	tn_parse_error			;AN000; yes - go issue message
  6931                                  ;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
  6932                                  ;	je	tn_drive			;AN000; yes - go process
  6933                                  ;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
  6934                                  ;
  6935                                  ;tn_eol: 					;AN000; no parameters on line
  6936                                  ;	mov	ah,end_of_line_out		;AN000; set buffer to .
  6937                                  ;	mov	al,dot_chr			;AN000;     for current dir
  6938                                  ;	stosw					;AN000; store in srcxname
  6939                                  ;	jmp	short tn_doit			;AN000; go do command
  6940                                  ;
  6941                                  ;tn_drive:					;AN000; a drive was entered
  6942                                  ;	push	si				;AN000; save position in line
  6943                                  ;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
  6944                                  ;	lodsb					;AN000; get the drive number
  6945                                  ;	add	al,"A"-1                        ;AN000; convert it to char
  6946                                  ;	stosb					;AN000; store it in srcxname
  6947                                  ;	mov	ax,dot_colon			;AN000; get colon and . and
  6948                                  ;	stosw					;AN000;    store in srcxname
  6949                                  ;	mov	al,end_of_line_out		;AN000; put a terminator char
  6950                                  ;	stosb					;AN000;
  6951                                  ;	pop	si				;AN000; get line position back
  6952                                  ;	jmp	short tn_check_eol		;AN000; check to make sure eol
  6953                                  ;
  6954                                  ;tn_filespec:					;AN000; a filespec was entered
  6955                                  ;	push	si				;AN000; save position in line
  6956                                  ;	lds	si,parse1_addr			;AN000; get address of filespec
  6957                                  ;
  6958                                  ;tn_move_filename:				;AN000; put filespec in srcxname
  6959                                  ;	lodsb					;AN000; get a char from buffer
  6960                                  ;	stosb					;AN000; store in srcxname
  6961                                  ;	cmp	al,end_of_line_out		;AN000; it char a terminator?
  6962                                  ;	jnz	tn_move_filename		;AN000; no - keep moving
  6963                                  ;	pop	si				;AN000; get line position back
  6964                                  ;
  6965                                  ;tn_check_eol:					;AN000; make sure no extra parms
  6966                                  ;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
  6967                                  ;	call	parse_check_eol 		;AN000; are we at end of line?
  6968                                  ;	je	tn_doit 			;AN000; Yes - do the command
  6969                                  ;
  6970                                  ;tn_parse_error: 				;AN000; A parse error occurred
  6971                                  ;	jmp	cerror				;AN000; Go to error routine
  6972                                  ;
  6973                                  ;tn_doit:					;AN000;
  6974                                  ;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
  6975                                  ;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
  6976                                  ;	mov	ah,xnametrans			;AN000; do name translate call
  6977                                  ;	int	21h			;AN000;
  6978                                  ;	jnc	tn_print_xname			;AN000; If no error - print result
  6979                                  ;
  6980                                  ;	invoke	Set_ext_error_msg		;AN000; get extended message
  6981                                  ;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
  6982                                  ;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
  6983                                  ;	jmp	cerror				;AN000; Go to error routine
  6984                                  ;
  6985                                  ;tn_print_xname: 				;AN000;
  6986                                  ;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
  6987                                  ;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
  6988                                  ;	invoke	crlf2				;AN000; print a crlf
  6989                                  ;	invoke	printf_crlf			;AN000; print it out
  6990                                  ;
  6991                                  ;	ret					;AN000;
  6992                                  ;
  6993                                  
  6994                                  ; ---------------------------------------------------------------------------
  6995                                  
  6996                                  _$EXIT:
  6997                                  		; MSDOS 3.3
  6998 00001650 8E06[7142]              		mov	es,[RESSEG]
  6999 00001654 26A18C0B                		mov	ax,word [es:PARENT]
  7000                                  		;mov	[es:16h],ax
  7001 00001658 26A31600                		mov	[es:PDB.PARENT_PID],ax
  7002 0000165C 26A18E0B                		mov	ax,word [es:OLDTERM]
  7003                                  		;mov	[es:0Ah],ax
  7004 00001660 26A30A00                		mov	[es:PDB.EXIT],ax
  7005 00001664 26A1900B                		mov	ax,word [es:OLDTERM+2]
  7006                                  		;mov	[es:0Ch],ax
  7007 00001668 26A30C00                		mov	[es:PDB.EXIT+2],ax
  7008 0000166C 06                      		push	es
  7009 0000166D 8E06[8142]              		mov	es,[TRAN_TPA]
  7010 00001671 B449                    		mov	ah,DEALLOC ; 49h
  7011 00001673 CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  7012                                  				; ES = segment address of area to be freed
  7013 00001675 07                      		pop	es
  7014 00001676 B44C                    		mov	ah,EXIT ; 4Ch
  7015                                  		;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
  7016 00001678 26A0EA0B                		mov	al,byte [es:RETCODE]
  7017 0000167C CD21                    		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
  7018                                  
  7019                                  ;;here:
  7020                                  ;;		jmp	short here
  7021                                  
  7022                                  		; MSDOS 6.0
  7023                                  		;push	ds			;AN000; save data segment
  7024                                  		;mov	ds,[resseg]		;AN000; get resident data segment
  7025                                  
  7026                                  		;assume	ds:resgroup		;AN000;
  7027                                  
  7028                                  		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
  7029                                  		;jz	free_com		;AN045; no - free everything
  7030                                  
  7031                                  ;	We're a permanent command.
  7032                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
  7033                                  
  7034                                  		;cmp	[singlecom],-1		;M034
  7035                                  		;je	no_reset		;M034	;exit singlecom
  7036                                  
  7037                                  		;jmp	TCommand		;permanent command, recycle
  7038                                  
  7039                                  ;free_com:
  7040                                  		;mov	ax,(multdos shl 8 or message_2f)
  7041                                  						;AN060; reset parse message pointers
  7042                                  		;mov	dl,set_critical_msg	;AN000; set up critical error message address
  7043                                  		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
  7044                                  		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
  7045                                  		;int	2fh			;AN000; go set it
  7046                                  ;no_reset:					;AN045;
  7047                                  		;pop	ds			;AN000; restore local data segment
  7048                                  
  7049                                  		;assume	ds:trangroup		;AN000;
  7050                                  ;
  7051                                  ;M040
  7052                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
  7053                                  ;this, restores user dir if flag is set and resets the flag.
  7054                                  ;
  7055                                  		;invoke	RestUDir1		;restore user dir if needed ;M040
  7056                                  		;MOV	ES,[RESSEG]
  7057                                  
  7058                                  		;assume	es:resgroup
  7059                                  
  7060                                  		;MOV	AX,[PARENT]
  7061                                  		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
  7062                                  		;MOV	AX,WORD PTR OldTerm
  7063                                  		;MOV	WORD PTR ES:[PDB_Exit],AX
  7064                                  		;MOV	AX,WORD PTR OldTerm+2
  7065                                  		;MOV	WORD PTR ES:[PDB_Exit+2],AX
  7066                                  
  7067                                  		;PUSH	ES
  7068                                  		;MOV	ES,[TRAN_TPA]
  7069                                  		;MOV	AH,DEALLOC
  7070                                  		;INT	21h			; Now running in "free" space
  7071                                  		;POP	ES
  7072                                  
  7073                                  		;MOV	AH,Exit
  7074                                  		;MOV	AL,BYTE PTR RetCode
  7075                                  		;INT	21h
  7076                                  
  7077                                  ; ---------------------------------------------------------------------------
  7078                                  
  7079                                  ; MSDOS 6.0
  7080                                  ; ****************************************************************
  7081                                  ; *
  7082                                  ; * ROUTINE:	 PARSE_CHECK_EOL
  7083                                  ; *
  7084                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
  7085                                  ; *		 If not end of line, set up to print parse
  7086                                  ; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
  7087                                  ; *		 EXPECTED!
  7088                                  ; *
  7089                                  ; * INPUT:	 DS:SI	  last output from parser
  7090                                  ; *		 ES:DI	  points to parse block
  7091                                  ; *		 CX	  last output from parser
  7092                                  ; *
  7093                                  ; * OUTPUT:	 AX	  parser return code
  7094                                  ; *
  7095                                  ; *		 if end of line found
  7096                                  ; *		     zero flag set
  7097                                  ; *		 else
  7098                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7099                                  ; *
  7100                                  ; ****************************************************************
  7101                                  
  7102                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
  7103                                  ;
  7104                                  ;parse_check_eol Proc near			;AN000;
  7105                                  ;
  7106                                  ;	xor	dx,dx				;AN000;
  7107                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7108                                  ;	invoke	cmd_parse			;AN000; call parser
  7109                                  ;	cmp	al,end_of_line			;AN000; Are we at end of line?
  7110                                  ;	jz	parse_good_eol			;AN000; yes - no problem
  7111                                  ;
  7112                                  ;	cmp	ax,result_no_error		;AN018; was any error found?
  7113                                  ;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
  7114                                  ;	inc	ax				;AN018; set AX to 1 and turn off zero flag
  7115                                  ;
  7116                                  ;ok_to_setup_pmsg:
  7117                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7118                                  ;
  7119                                  ;parse_good_eol:
  7120                                  ;	ret					;AN000;
  7121                                  ;
  7122                                  ;parse_check_eol endp				;AN000;
  7123                                  
  7124                                  ; ---------------------------------------------------------------------------
  7125                                  
  7126                                  ; MSDOS 6.0
  7127                                  ; ****************************************************************
  7128                                  ; *
  7129                                  ; * ROUTINE:	 PARSE_WITH_MSG
  7130                                  ; *
  7131                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7132                                  ; *		 message is set up.
  7133                                  ; *
  7134                                  ; * INPUT:	 DS:SI	  last output from parser
  7135                                  ; *		 ES:DI	  points to parse block
  7136                                  ; *		 CX	  last output from parser
  7137                                  ; *
  7138                                  ; * OUTPUT:	 AX	  parser return code
  7139                                  ; *
  7140                                  ; *		 if no error
  7141                                  ; *		     outputs from parser
  7142                                  ; *		 else
  7143                                  ; *		     MSG_DISPLAY_CLASS set to parse error
  7144                                  ; *		     error message set up for STD_PRINTF
  7145                                  ; *
  7146                                  ; ****************************************************************
  7147                                  
  7148                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7149                                  ;
  7150                                  ;parse_with_msg	Proc near			;AN018;
  7151                                  ;
  7152                                  ;	mov	[parse_last],si 		;AN018; save start of parameter
  7153                                  ;	invoke	cmd_parse			;AN018; call parser
  7154                                  ;	cmp	al,end_of_line			;AN018; Are we at end of line?
  7155                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7156                                  ;	cmp	ax,result_no_error		;AN018; did an error occur
  7157                                  ;	jz	parse_msg_good			;AN018; yes - no problem
  7158                                  ;
  7159                                  ;	call	setup_parse_error_msg		;AN018; go set up error message
  7160                                  ;
  7161                                  ;parse_msg_good:
  7162                                  ;	ret					;AN018;
  7163                                  ;
  7164                                  ;parse_with_msg endp				;AN018;
  7165                                  
  7166                                  ; ---------------------------------------------------------------------------
  7167                                  
  7168                                  ; MSDOS 6.0
  7169                                  ; ****************************************************************
  7170                                  ; *
  7171                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
  7172                                  ; *
  7173                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
  7174                                  ; *		 message is set up.
  7175                                  ; *
  7176                                  ; * INPUT:	 AX	     Parse error number
  7177                                  ; *		 SI	     Set to past last parameter
  7178                                  ; *		 Parse_last  Set to start of last parameter
  7179                                  ; *
  7180                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
  7181                                  ; *		 error message set up for STD_PRINTF
  7182                                  ; *
  7183                                  ; ****************************************************************
  7184                                  
  7185                                  ;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
  7186                                  ;
  7187                                  ;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
  7188                                  ;
  7189                                  ;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
  7190                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
  7191                                  ;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
  7192                                  ;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
  7193                                  ;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
  7194                                  ;	jz	Setup_parse_msg_ret		;AN018;    no subst
  7195                                  ;	mov	si,[parse_last] 		;AC018; get start of parameter
  7196                                  ;	mov	string_ptr_2,si 		;AC018; get address of failed string
  7197                                  ;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
  7198                                  ;
  7199                                  ;setup_parse_msg_ret:
  7200                                  ;	inc	si				;AN018; make sure zero flag not set
  7201                                  ;
  7202                                  ;	ret					;AC018;
  7203                                  ;
  7204                                  ;SETUP_PARSE_ERROR_MSG	Endp			;AN018;
  7205                                  
  7206                                  ;============================================================================
  7207                                  ; TENV.ASM, MSDOS 6.0, 1991
  7208                                  ;============================================================================
  7209                                  ; 08/10/2018 - Retro DOS v3.0
  7210                                  
  7211                                  ; TITLE	Part6 COMMAND Transient routines.
  7212                                  
  7213                                  ;	Environment utilities and misc. routines
  7214                                  
  7215                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
  7216                                  
  7217                                  ; ---------------------------------------------------------------------------
  7218                                  
  7219                                  ADD_PROMPT:
  7220 0000167E E8F100                  		call	DELETE_PROMPT	; Delete any existing prompt
  7221 00001681 E87801                  		call	SCAN_DOUBLE_NULL
  7222                                  
  7223                                  ADD_PROMPT2:
  7224 00001684 56                      		push	si
  7225 00001685 E86601                  		call	GETARG
  7226 00001688 5E                      		pop	si
  7227 00001689 7501                    		jnz	short ADD_PROMPT3
  7228                                  ADD_PROMPT_RETN:
  7229 0000168B C3                      		retn
  7230                                  ADD_PROMPT3:				; Pre scan for arguments
  7231 0000168C E84E01                  		call	MOVE_NAME	 ;Move in name
  7232 0000168F E85C01                  		call	GETARG
  7233 00001692 56                      		push	si
  7234 00001693 EB4F                    		jmp	short ADD_NAME
  7235                                  
  7236                                  ;break	The SET command
  7237                                  
  7238                                  ; Input: DS:SI points to a CR terminated string
  7239                                  ; Output: carry flag is set if no room
  7240                                  ;	  otherwise name is added to environment
  7241                                  
  7242                                  DISP_ENVJ:
  7243 00001695 E9B100                  		jmp	DISP_ENV
  7244                                  
  7245                                  ADD_NAME_TO_ENVIRONMENT:
  7246 00001698 E85301                  		call	GETARG
  7247 0000169B 74F8                    		jz	short DISP_ENVJ
  7248                                  
  7249                                  ; check if line contains exactly one equals sign
  7250                                  
  7251 0000169D 31DB                    		xor	bx,bx		; = count is 0
  7252 0000169F 56                      		push	si		; Save pointer to beginning of line
  7253                                  EQLP:
  7254 000016A0 AC                      		lodsb			; Get a char
  7255 000016A1 3C0D                    		cmp	al,13		; IF CR we're all done
  7256 000016A3 740F                    		jz	short QUEQ	
  7257 000016A5 3C3D                    		cmp	al,'='		; Look for = sign	
  7258 000016A7 75F7                    		jnz	short EQLP	; not there, get next char
  7259 000016A9 FEC3                    		inc	bl		; Otherwise increment EQ count
  7260 000016AB 803C0D                  		cmp	byte [si],13	; Look for CR following = sign
  7261 000016AE 75F0                    		jnz	short EQLP
  7262 000016B0 FEC7                    		inc	bh		; Set BH=1 means no parameters
  7263 000016B2 EBEC                    		jmp	short EQLP	; And look for more
  7264                                  QUEQ:
  7265 000016B4 5E                      		pop	si		; Restore beginning of line
  7266 000016B5 FECB                    		dec	bl		; Zero flag means only one EQ
  7267 000016B7 7406                    		jz	short ONEQ	; Good line
  7268 000016B9 BA[783C]                		mov	dx,SYNTMESPTR
  7269 000016BC E96A05                  		jmp	CERROR
  7270                                  ONEQ:
  7271 000016BF 53                      		push	bx
  7272 000016C0 E8B200                  		call	DELETE_NAME_IN_ENVIRONMENT
  7273 000016C3 5B                      		pop	bx
  7274 000016C4 FECF                    		dec	bh
  7275 000016C6 74C3                    		jz	short ADD_PROMPT_RETN
  7276 000016C8 E83101                  		call	SCAN_DOUBLE_NULL
  7277 000016CB 89FB                    		mov	bx,di		; Save ptr to beginning of env var name
  7278 000016CD E80D01                  		call	MOVE_NAME
  7279 000016D0 56                      		push	si
  7280 000016D1 87DF                    		xchg	bx,di		; Switch ptrs to beginning and end of
  7281                                  					;  env var name
  7282                                  		
  7283                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
  7284                                  ; necessary in the resident for re-reading the transient. Let's look for
  7285                                  ; COMSPEC=
  7286                                  
  7287                                  		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
  7288 000016D3 BE[193C]                		mov	si,COMSPEC_TEXT	; "COMSPEC="
  7289 000016D6 B90400                  		mov	cx,4
  7290 000016D9 F3A7                    		repe cmpsw
  7291 000016DB 7505                    		jnz	short NOT_COMSPEC
  7292                                  					; Zero set => exact match
  7293                                  		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
  7294 000016DD C606[A845]01            		mov	byte [COMSPEC_FLAG],1
  7295                                  NOT_COMSPEC:
  7296 000016E2 89DF                    		mov	di,bx		; Load ptr to end of env var name
  7297                                  ADD_NAME:
  7298 000016E4 5E                      		pop	si		; Add the value of the new env var
  7299 000016E5 56                      		push	si		;  to the environment.
  7300                                  ADD_NAME1:
  7301 000016E6 AC                      		lodsb
  7302 000016E7 3C0D                    		cmp	al,13
  7303 000016E9 7405                    		jz	short ADD_NAME_RET
  7304 000016EB E84401                  		call	STORE_CHAR
  7305 000016EE EBF6                    		jmp	short ADD_NAME1
  7306                                  ADD_NAME_RET:
  7307 000016F0 5E                      		pop	si
  7308 000016F1 803E[A845]00            		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
  7309                                  ADD_NAME_JZ_RET:
  7310 000016F6 7493                    		jz	short ADD_PROMPT_RETN 
  7311                                  					;  copy the value into the
  7312                                  					;  comspec var in the resident
  7313                                  
  7314                                  ; We have changed the COMSPEC variable. We need to update the resident
  7315                                  ; pieces necessary to reread in the info. First, skip all delimiters
  7316                                  
  7317 000016F8 E87E02                  		call	SCANOFF
  7318 000016FB 8E06[7142]              		mov	es,[RESSEG]	;  comspec var in the resident
  7319                                  
  7320                                  ; Make sure that the printer knows where the beginning of the string is
  7321                                  
  7322 000016FF BF990B                  		mov	di,COMSPEC
  7323 00001702 89FB                    		mov	bx,di
  7324                                  
  7325                                  ; Generate drive letter for display
  7326                                  
  7327 00001704 31C0                    		xor	ax,ax		;g assume no drive first
  7328 00001706 26A2E40B                		mov	byte [es:COMDRV],al ;g
  7329 0000170A 807C013A                		cmp	byte [si+1],':'	 ; drive specified?
  7330 0000170E 7512                    		jnz	short _GOTDRIVE
  7331 00001710 8A04                    		mov	al,[si]		; get his specified drive
  7332                                  		;call	UPCONV
  7333 00001712 E80901                  		call	UPCONV_MAPCALL	; convert to uppercase
  7334 00001715 2C41                    		sub	al,'A'		; convert to 0-based
  7335 00001717 83C702                  		add	di,2
  7336 0000171A FEC0                    		inc	al		; convert to 1-based number
  7337 0000171C 26A2E40B                		mov	byte [es:COMDRV],al
  7338                                  
  7339                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
  7340                                  ; done here..
  7341                                  		;add	al,40h
  7342 00001720 0440                    		add	al,'A'-1
  7343                                  _GOTDRIVE:
  7344                                  		;mov	word [es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
  7345 00001722 26893ED90B              		mov	word [es:PUTBACKSUBSTPTR],di
  7346                                  					;g point to beginning of name after drive
  7347                                  		;mov	byte [es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
  7348 00001727 26A2210A                		mov	byte [es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND
  7349                                  
  7350                                  ; Copy chars until delim      	
  7351                                  
  7352 0000172B 89DF                    		mov	di,bx
  7353                                  COPY_COMSPEC:
  7354 0000172D AC                      		lodsb
  7355 0000172E E85002                  		call	DELIM
  7356 00001731 7407                    		jz	short COPYDONE
  7357 00001733 3C0D                    		cmp	al,13
  7358 00001735 7403                    		jz	short COPYDONE
  7359 00001737 AA                      		stosb
  7360 00001738 EBF3                    		jmp	short COPY_COMSPEC
  7361                                  COPYDONE:
  7362 0000173A 30C0                    		xor	al,al		; Null terminate the string and quit
  7363 0000173C AA                      		stosb
  7364 0000173D C606[A845]00            		mov	byte [COMSPEC_FLAG],0
  7365 00001742 4F                      		dec	di
  7366 00001743 26893EDB0B              		mov	word [es:COMSPEC_END],di
  7367 00001748 C3                      		retn
  7368                                  DISP_ENV:
  7369 00001749 8E1E[7142]              		mov	ds,[RESSEG]
  7370 0000174D 8E1E030D                		mov	ds,word [ENVIRSEG]
  7371                                  		; assume ds:nothing
  7372 00001751 31F6                    		xor	si,si
  7373                                  PENVLP:
  7374 00001753 803C00                  		cmp	byte [si],0
  7375 00001756 749E                    		jz	short ADD_NAME_JZ_RET
  7376 00001758 BF[C843]                		mov	di,ARG_BUF
  7377                                  PENVLP2:
  7378 0000175B AC                      		lodsb
  7379 0000175C AA                      		stosb
  7380 0000175D 08C0                    		or	al,al
  7381 0000175F 75FA                    		jnz	short PENVLP2
  7382 00001761 BA[2337]                		mov	dx,ARG_BUF_PTR
  7383 00001764 1E                      		push	ds
  7384 00001765 06                      		push	es
  7385 00001766 1F                      		pop	ds
  7386                                  		; assume ds:nothing
  7387 00001767 E8591D                  		call	PRINTF_CRLF
  7388 0000176A 1F                      		pop	ds
  7389 0000176B EBE6                    		jmp	short PENVLP
  7390                                  
  7391                                  ; =============== S U B	R O U T	I N E =======================================
  7392                                  
  7393                                  DELETE_PATH:
  7394 0000176D BE[0D3C]                		mov	si,PATH_TEXT ; "PATH="
  7395 00001770 EB03                    		jmp	short DELETE_NAME_IN_ENVIRONMENT
  7396                                  
  7397                                  ; =============== S U B	R O U T	I N E =======================================
  7398                                  
  7399                                  DELETE_PROMPT:
  7400 00001772 BE[123C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7401                                  
  7402                                  ; ---------------------------------------------------------------------------
  7403                                  
  7404                                  DELETE_NAME_IN_ENVIRONMENT:
  7405                                  
  7406                                  ; Input: DS:SI points to a "=" terminated string
  7407                                  ; Output: carry flag is set if name not found
  7408                                  ;	  otherwise name is deleted
  7409                                  
  7410 00001775 56                      		push	si
  7411 00001776 1E                      		push	ds
  7412 00001777 E82400                  		call	FIND		; ES:DI points to name
  7413 0000177A 7210                    		jc	short DEL1
  7414 0000177C 89FE                    		mov	si,di		; Save it
  7415 0000177E E89500                  		call	SCASB2		; Scan for the nul
  7416 00001781 87F7                    		xchg	si,di
  7417                                  ;SR;
  7418                                  ; If we have only one env string, then the double null is lost when the last
  7419                                  ;string is deleted and we have an invalid empty environment with only a 
  7420                                  ;single null. To avoid this, we will look for the double null case and then
  7421                                  ;move an extra null char.
  7422                                  ; Bugbug: The only possible problem is that the last pathstring 
  7423                                  ;will be followed by a triple null. Is this really a problem?
  7424                                  
  7425                                  		; MSDOS 6.0
  7426                                  		;cmp	byte ptr es:[si],0 ;null char?
  7427                                  		;jnz	not_dnull	   ;no, we are at a double null
  7428                                  		;dec	si		   ;point at the double null
  7429                                  ;not_dnull:
  7430                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7431 00001783 E8F400                  		call	GETENVSIZ
  7432 00001786 29F1                    		sub	cx,si
  7433 00001788 06                      		push	es
  7434 00001789 1F                      		pop	ds		; ES:DI points to name
  7435                                  					; DS:SI points to next name
  7436 0000178A F3A4                    		rep movsb
  7437                                  DEL1:
  7438 0000178C 1F                      		pop	ds
  7439 0000178D 5E                      		pop	si
  7440                                  FIND_RETN:
  7441 0000178E C3                      		retn
  7442                                  
  7443                                  ; =============== S U B	R O U T	I N E =======================================
  7444                                  
  7445                                  FIND_PATH:
  7446 0000178F BE[0D3C]                		mov	si,PATH_TEXT ; "PATH="
  7447 00001792 EB03                    		jmp	short FIND_NAME_IN_ENVIRONMENT
  7448                                  
  7449                                  
  7450                                  ; =============== S U B	R O U T	I N E =======================================
  7451                                  
  7452                                  FIND_PROMPT:
  7453 00001794 BE[123C]                		mov	si,PROMPT_TEXT ; "PROMPT="
  7454                                  
  7455                                  ; ---------------------------------------------------------------------------
  7456                                  
  7457                                  FIND_NAME_IN_ENVIRONMENT:
  7458                                  
  7459                                  ; Input: DS:SI points to a "=" terminated string
  7460                                  ; Output: ES:DI points to the arguments in the environment
  7461                                  ;	  zero is set if name not found
  7462                                  ;	  carry flag is set if name not valid format
  7463                                  
  7464 00001797 E80400                  		call	FIND		; Find the name
  7465 0000179A 72F2                    		jc	short FIND_RETN	; Carry means not found	
  7466 0000179C EB74                    		jmp	short SCASB1	; Scan for = sign
  7467                                  
  7468                                  ; ---------------------------------------------------------------------------
  7469                                  		;nop
  7470                                  
  7471                                  ; =============== S U B	R O U T	I N E =======================================
  7472                                  
  7473                                  ; On return of FIND1, ES:DI points to beginning of name
  7474                                  
  7475                                  FIND:
  7476 0000179E FC                      		cld
  7477 0000179F E82D00                  		call	COUNT0		; CX = Length of name
  7478 000017A2 8E06[7142]              		mov	es,[RESSEG]
  7479                                  		; assume es:RESGROUP
  7480 000017A6 268E06030D              		mov	es,word [es:ENVIRSEG]
  7481                                  		; assume es:NOTHING
  7482 000017AB 31FF                    		xor	di,di
  7483                                  FIND1:	
  7484 000017AD 51                      		push	cx
  7485 000017AE 56                      		push	si
  7486 000017AF 57                      		push	di
  7487                                  FIND11:
  7488 000017B0 AC                      		lodsb
  7489                                  		;call	UPCONV
  7490 000017B1 E86A00                  		call	UPCONV_MAPCALL
  7491 000017B4 47                      		inc	di
  7492 000017B5 263A45FF                		cmp	al,[es:di-1]
  7493 000017B9 7502                    		jnz	short FIND12
  7494 000017BB E2F3                    		loop	FIND11
  7495                                  FIND12:
  7496 000017BD 5F                      		pop	di
  7497 000017BE 5E                      		pop	si
  7498 000017BF 59                      		pop	cx
  7499 000017C0 74CC                    		jz	short FIND_RETN
  7500 000017C2 51                      		push	cx
  7501 000017C3 E85000                  		call	SCASB2		; Scan for a nul
  7502 000017C6 59                      		pop	cx
  7503 000017C7 26803D00                		cmp	byte [es:di],0
  7504 000017CB 75E0                    		jnz	short FIND1
  7505 000017CD F9                      		stc			; Indicate not found
  7506 000017CE C3                      		retn
  7507                                  
  7508                                  ; =============== S U B	R O U T	I N E =======================================
  7509                                  
  7510                                  COUNT0:
  7511 000017CF 1E                      		push	ds
  7512 000017D0 07                      		pop	es
  7513                                  		; assume es:nothing
  7514 000017D1 89F7                    		mov	di,si
  7515                                  ;COUNT1:
  7516 000017D3 57                      		push	di		; Count number of chars until "="
  7517 000017D4 E83B00                  		call	SCASB1
  7518                                  		; 24/02/2023
  7519                                  		;jmp	short COUNTX
  7520                                  ;COUNT2:
  7521                                  ;		push	di		; Count number of chars until nul
  7522                                  ;		call	SCASB2
  7523                                  ;COUNTX:
  7524 000017D7 59                      		pop	cx
  7525 000017D8 29CF                    		sub	di,cx
  7526 000017DA 87F9                    		xchg	di,cx
  7527                                  MOVE_NAME_RETN:
  7528 000017DC C3                      		retn
  7529                                  
  7530                                  ; =============== S U B	R O U T	I N E =======================================
  7531                                  
  7532                                  MOVE_NAME:
  7533 000017DD 803C0D                  		cmp	byte [si],13
  7534 000017E0 74FA                    		jz	short MOVE_NAME_RETN
  7535 000017E2 AC                      		lodsb
  7536                                  		;call	UPCONV
  7537 000017E3 E83800                  		call	UPCONV_MAPCALL
  7538 000017E6 E84900                  		call	STORE_CHAR
  7539 000017E9 3C3D                    		cmp	al,'='
  7540 000017EB 75F0                    		jnz	short MOVE_NAME
  7541                                  GETARG_RETN:
  7542 000017ED C3                      		retn
  7543                                  
  7544                                  ; =============== S U B	R O U T	I N E =======================================
  7545                                  
  7546                                  GETARG:
  7547 000017EE BE8000                  		mov	si,80h
  7548 000017F1 AC                      		lodsb
  7549 000017F2 08C0                    		or	al,al
  7550 000017F4 74F7                    		jz	short GETARG_RETN
  7551 000017F6 E88001                  		call	SCANOFF
  7552 000017F9 3C0D                    		cmp	al,13
  7553                                  SDN_RETN:
  7554 000017FB C3                      		retn
  7555                                  
  7556                                  ; =============== S U B	R O U T	I N E =======================================
  7557                                  
  7558                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
  7559                                  ; there is NO double NULL, merely a string that is empty.
  7560                                  
  7561                                  SCAN_DOUBLE_NULL:
  7562 000017FC 8E06[7142]              		mov	es,[RESSEG]
  7563                                  		; ASSUME ES:RESGROUP
  7564 00001800 268E06030D              		mov	es,word [es:ENVIRSEG]
  7565                                  		; ASSUME ES:NOTHING
  7566 00001805 31FF                    		xor	di,di
  7567                                  
  7568                                  ; Top cycle-point. If the string here is empty, then we are done
  7569                                  
  7570                                  SDN1:
  7571 00001807 26803D00                		cmp	byte [es:di],0	; nul string?
  7572 0000180B 74EE                    		jz	short SDN_RETN	; yep, all done
  7573 0000180D E80600                  		call	SCASB2
  7574 00001810 EBF5                    		jmp	short SDN1
  7575                                  
  7576                                  ; =============== S U B	R O U T	I N E =======================================
  7577                                  
  7578                                  SCASB1:
  7579 00001812 B03D                    		mov	al,'='		; Scan for an =
  7580 00001814 EB02                    		jmp	short SCASBX
  7581                                  
  7582                                  ; =============== S U B	R O U T	I N E =======================================
  7583                                  
  7584                                  SCASB2:
  7585 00001816 30C0                    		xor	al,al		; Scan for a nul
  7586                                  
  7587                                  ; ---------------------------------------------------------------------------
  7588                                  
  7589                                  SCASBX:
  7590 00001818 B90001                  		mov	cx,256
  7591 0000181B F2AE                    		repne scasb
  7592 0000181D C3                      		retn
  7593                                  
  7594                                  ; =============== S U B	R O U T	I N E =======================================
  7595                                  
  7596                                  ; MSDOS 6.0
  7597                                  
  7598                                  ; ****************************************************************
  7599                                  ; *
  7600                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
  7601                                  ; *
  7602                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7603                                  ; *		 the character in AL from the file upper case table
  7604                                  ; *		 in DOS if character if above  ascii 128, else
  7605                                  ; *		 subtracts 20H if between "a" and "z".
  7606                                  ; *
  7607                                  ; * INPUT:	 AL	      char to be upper cased
  7608                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7609                                  ; *
  7610                                  ; * OUTPUT:	 AL	      upper cased character
  7611                                  ; *
  7612                                  ; ****************************************************************
  7613                                  
  7614                                  ;assume	ds:trangroup			;AN000;
  7615                                  ;
  7616                                  ;upconv	proc	near			;AN000;
  7617                                  ;
  7618                                  ;	cmp	al,80h			;AN000;  see if char is > ascii 128
  7619                                  ;	jb	oth_fucase		;AN000;  no - upper case math
  7620                                  ;	sub	al,80h			;AN000;  only upper 128 chars in table
  7621                                  ;	push	ds			;AN000;
  7622                                  ;	push	bx			;AN000;
  7623                                  ;	mov	ds,[resseg]		;AN000;  get resident data segment
  7624                                  ;assume	ds:resgroup			;AN000;
  7625                                  ;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
  7626                                  ;	add	bx,2			;AN000;  skip over first word
  7627                                  ;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
  7628                                  ;	pop	bx			;AN000;
  7629                                  ;	pop	ds			;AN000;
  7630                                  ;assume	ds:trangroup			;AN000;
  7631                                  ;	jmp	short upconv_end	;AN000;  we finished - exit
  7632                                  ;
  7633                                  ;oth_fucase:				;AN000;
  7634                                  ;	cmp	al,small_a		;AC000; if between "a" and "z",
  7635                                  ;	jb	upconv_end		;AC000;     subtract 20h to get
  7636                                  ;	cmp	al,small_z		;AC000;    upper case equivalent.
  7637                                  ;	ja	upconv_end		;AC000;
  7638                                  ;	sub	al,20h			;AC000; Change lower-case to upper
  7639                                  ;
  7640                                  ;upconv_end:				;AN000;
  7641                                  ;	ret
  7642                                  ;
  7643                                  ;upconv	endp				;AN000;
  7644                                  
  7645                                  ; ---------------------------------------------------------------------------
  7646                                  
  7647                                  ; MSDOS 3.3
  7648                                  
  7649                                  UPCONV_MAPCALL:
  7650                                  					; If between "a" and "z"
  7651 0000181E 3A06[023F]              		cmp	al,[small_a]
  7652 00001822 7208                    		jb	short UPCONV_END
  7653 00001824 3A06[033F]              		cmp	al,[small_z]
  7654 00001828 7702                    		ja	short UPCONV_END
  7655 0000182A 2C20                    		sub	al,20h		; Change lower-case to upper
  7656                                  UPCONV_END:
  7657 0000182C 2EFF1E[0A4D]            		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
  7658                                  					  ; 	  for (current) country
  7659 00001831 C3                      		retn
  7660                                  
  7661                                  ; =============== S U B	R O U T	I N E =======================================
  7662                                  
  7663                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
  7664                                  
  7665                                  STORE_CHAR:
  7666 00001832 51                      		push	cx
  7667 00001833 53                      		push	bx
  7668                                  
  7669                                  		; 16/10/2018
  7670                                  		; MSDOS 6.0
  7671                                  		;PUSH	ES		;AN056;*
  7672                                  		;PUSH	DS		;AN056; Save local DS
  7673                                  		;MOV	DS,[RESSEG]	;AN056; Get resident segment
  7674                                  		;;ASSUME DS:RESGROUP	;AN056;
  7675                                  		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
  7676                                  		;; ASSUME ES:NOTHING	;AN056;
  7677                                  		;POP	DS		;AN056; Get local segment back
  7678                                  		;; ASSUME DS:TRANGROUP	;AN056;
  7679                                  
  7680                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7681 00001834 E84300                  		call	GETENVSIZ
  7682 00001837 89CB                    		mov	bx,cx		; Save room for double nul	
  7683 00001839 83EB02                  		sub	bx,2
  7684 0000183C 39DF                    		cmp	di,bx
  7685 0000183E 7231                    		jb	short STORE1
  7686                                  
  7687 00001840 50                      		push	ax
  7688 00001841 51                      		push	cx
  7689 00001842 53                      		push	bx		; Save Size of environment
  7690 00001843 E81AEE                  		call	FREE_TPA
  7691 00001846 5B                      		pop	bx
  7692 00001847 83C302                  		add	bx,2		; Recover true environment size
  7693                                  
  7694 0000184A 81FB0080                		cmp	bx,8000h	; Don't let environment grow > 32K	
  7695 0000184E 7203                    		jb	short ENVSIZ_OK
  7696                                  BAD_ENV_SIZE:				;AN056;
  7697 00001850 F9                      		stc
  7698 00001851 EB09                    		jmp	short ENVNOSET
  7699                                  
  7700                                  		;nop
  7701                                  ENVSIZ_OK:
  7702 00001853 B104                    		mov	cl,4
  7703 00001855 D3EB                    		shr	bx,cl		; Convert back to paragraphs
  7704 00001857 43                      		inc	bx
  7705                                  
  7706                                  		; MSDOS 6.0
  7707                                  		;MOV	CX,ES		;AN056; Get environment segment
  7708                                  		;ADD	CX,BX		;AN056; Add in size of environment
  7709                                  		;ADD	CX,020H 	;AN056; Add in some TPA
  7710                                  		;MOV	AX,CS		;AN056; Get the transient segment
  7711                                  		;CMP	CX,AX		;AN056; Are we hitting the transient?
  7712                                  		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!
  7713                                  
  7714                                  		; MSDOS 3.3 (& MSDOS 6.0)
  7715 00001858 B44A                    		mov	ah,SETBLOCK ; 4Ah
  7716 0000185A CD21                    		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7717                                  				; ES = segment address of block	to change
  7718                                  				; BX = new size	in paragraphs
  7719                                  ENVNOSET:
  7720 0000185C 9C                      		pushf
  7721 0000185D 06                      		push	es
  7722 0000185E 8E06[7142]              		mov	es,[RESSEG]
  7723                                  		;ASSUME ES:RESGROUP
  7724 00001862 E80BEE                  		call	ALLOC_TPA
  7725 00001865 07                      		pop	es
  7726 00001866 9D                      		popf
  7727 00001867 59                      		pop	cx
  7728 00001868 58                      		pop	ax
  7729                                  		;POP	ES	; MSDOS 6.0 ;AN056;*	
  7730 00001869 7306                    		jnc	short STORE1
  7731 0000186B BA[5638]                		mov	dx,ENVERRPTR
  7732 0000186E E9B803                  		jmp	CERROR
  7733                                  
  7734                                  STORE1:	
  7735 00001871 AA                      		stosb
  7736 00001872 26C7050000              		mov	word [es:di],0	; NULL IS AT END
  7737                                  		;POP	ES	; MSDOS 6.0 ;AN056;*
  7738 00001877 5B                      		pop	bx
  7739 00001878 59                      		pop	cx
  7740 00001879 C3                      		retn
  7741                                  
  7742                                  ; =============== S U B	R O U T	I N E =======================================
  7743                                  
  7744                                  GETENVSIZ:
  7745                                  
  7746                                  ;Get size of environment in bytes, rounded up to paragraph boundry
  7747                                  ;ES has environment segment
  7748                                  ;Size returned in CX, all other registers preserved
  7749                                  
  7750 0000187A 06                      		push	es
  7751 0000187B 50                      		push	ax
  7752 0000187C 8CC0                    		mov	ax,es
  7753 0000187E 48                      		dec	ax	;Point at arena	
  7754 0000187F 8EC0                    		mov	es,ax
  7755 00001881 26A10300                		mov	ax,word [es:ARENA.size]
  7756 00001885 B104                    		mov	cl,4
  7757 00001887 D3E0                    		shl	ax,cl	;Convert to bytes
  7758 00001889 89C1                    		mov	cx,ax
  7759 0000188B 58                      		pop	ax
  7760 0000188C 07                      		pop	es
  7761                                  GETENVSIZ_RETN:
  7762 0000188D C3                      		retn
  7763                                  
  7764                                  ; =============== S U B	R O U T	I N E =======================================
  7765                                  
  7766                                  RESTUDIR1:
  7767 0000188E 1E                      		push	ds
  7768 0000188F 8E1E[7142]              		mov	ds,[RESSEG]
  7769                                  		;ASSUME	DS:RESGROUP
  7770 00001893 803EF10B00              		cmp	byte [RESTDIR],0
  7771 00001898 1F                      		pop	ds
  7772                                  		;ASSUME	DS:TRANGROUP
  7773 00001899 74F2                    		jz	short GETENVSIZ_RETN
  7774                                  
  7775                                  ; =============== S U B	R O U T	I N E =======================================
  7776                                  
  7777                                  RESTUDIR:
  7778 0000189B BA[5341]                		mov	dx,USERDIR1
  7779 0000189E B43B                    		mov	ah,CHDIR ; 3Bh
  7780 000018A0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7781                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7782 000018A2 30C0                    		xor	al,al
  7783 000018A4 E86506                  		call	SETREST
  7784 000018A7 C3                      		retn
  7785                                  
  7786                                  ;============================================================================
  7787                                  ; TENV2.ASM, MSDOS 6.0, 1991
  7788                                  ;============================================================================
  7789                                  ; 07/10/2018 - Retro DOS v3.0
  7790                                  
  7791                                  ; TITLE	Part6 COMMAND Transient routines.
  7792                                  
  7793                                  ;	Environment utilities and misc. routines
  7794                                  
  7795                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
  7796                                  
  7797                                  ; ---------------------------------------------------------------------------
  7798                                  
  7799                                  ; ****************************************************************
  7800                                  ; *
  7801                                  ; * ROUTINE:	 $CHDIR
  7802                                  ; *
  7803                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
  7804                                  ; *		 line. If path is found, CHDIR to path. If a drive
  7805                                  ; *		 letter is found, get and display the current dir
  7806                                  ; *		 of the specified drive. If nothing is found, get
  7807                                  ; *		 and display the current dir of the default drive.
  7808                                  ; *
  7809                                  ; * INPUT:	 command line at offset 81H
  7810                                  ; *
  7811                                  ; * OUTPUT:	 none
  7812                                  ; *
  7813                                  ; ****************************************************************
  7814                                  
  7815                                  _$CHDIR:
  7816                                  		; MSDOS 6.0
  7817                                  		;mov	si,81H
  7818                                  		;mov	di,offset trangroup:parse_chdir 
  7819                                  		;			;AN000; Get address of PARSE_CHDIR
  7820                                  		;xor	cx,cx		;AN000; clear cx,dx
  7821                                  		;xor	dx,dx		;AN000;
  7822                                  		;invoke	parse_with_msg	;AC018; call parser
  7823                                  
  7824                                  		;cmp	ax,end_of_line	;AC000; are we at end of line?
  7825                                  		;jz	bwdJ		; No args
  7826                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  7827                                  		;jnz	ChDirErr	;AC018; yes - exit
  7828                                  
  7829                                  		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
  7830                                  		;jnz	REALCD		; no
  7831                                  ;;
  7832                                  ;; D: was found. See if there is anything more.
  7833                                  ;;
  7834                                  		;mov	di,offset trangroup:parse_chdir 
  7835                                  					;AC000; get address of parse_chdir
  7836                                  		;xor	dx,dx		;AC000;
  7837                                  		;invoke	parse_check_eol ;AC000; call parser
  7838                                  		;jnz	ChDirErr	;AC000;
  7839                                  	;bwdJ:
  7840                                  		;invoke	build_dir_for_chdir ; Drive only specified
  7841                                  		;call	crlf2
  7842                                  		;return
  7843                                  
  7844                                  		; MSDOS 3.3
  7845 000018A8 A1[8842]                		mov	ax,[COMSW]
  7846 000018AB 0B06[8E42]              		or	ax,[ALLSWITCH]
  7847 000018AF BA[223A]                		mov	dx,BADPARMPTR
  7848 000018B2 7533                    		jnz	short CHDIR_ERR
  7849 000018B4 BE8100                  		mov	si,81h
  7850 000018B7 E8BF00                  		call	SCANOFF
  7851 000018BA 3C0D                    		cmp	al,0Dh		; are we at end of line?
  7852 000018BC 740F                    		je	short BWDJ	; No args
  7853 000018BE 46                      		inc	si
  7854 000018BF AC                      		lodsb
  7855 000018C0 3C3A                    		cmp	al,':'
  7856 000018C2 7510                    		jne	short REALCD
  7857 000018C4 56                      		push	si
  7858 000018C5 E8B100                  		call	SCANOFF
  7859 000018C8 5E                      		pop	si
  7860 000018C9 3C0D                    		cmp	al,0Dh		; was a drive entered?
  7861 000018CB 7507                    		jne	short REALCD	; no
  7862                                  BWDJ:
  7863 000018CD E873FB                  		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
  7864 000018D0 E89900                  		call	CRLF2
  7865                                  CHDIR_RETN:
  7866 000018D3 C3                      		retn
  7867                                  
  7868                                  		; MSDOS 6.0
  7869                                  ;REALCD:
  7870                                  		;push	si		;AN000; save position in line
  7871                                  		;lds	si,parse1_addr	;AN000; get address of filespec
  7872                                  		;invoke	move_to_srcbuf	;AN000; move to srcbuf
  7873                                  		;pop	si		;AN000; restore position in line
  7874                                  		;mov	di,offset trangroup:parse_chdir 
  7875                                  		;			;AC000; get address of parse_chdir
  7876                                  		;xor	dx,dx		;AC000;
  7877                                  		;invoke	parse_check_eol ;AC000; call parser
  7878                                  		;jnz	ChDirErr	;AC000;
  7879                                  		;
  7880                                  		;invoke	SETPATH
  7881                                  		;TEST	[DESTINFO],2
  7882                                  		;JNZ	BadChdir
  7883                                  		;MOV	AH,CHDIR
  7884                                  		;INT	21h
  7885                                  		;retnc
  7886                                  		;
  7887                                  		;invoke	get_ext_error_number
  7888                                  		;			;AN022; get the extended error
  7889                                  		;cmp	ax,error_path_not_found
  7890                                  		;			;AN022; see if path not found
  7891                                  		;jz	BadChDir	;AN022; yes - issue old message
  7892                                  ;;SR;
  7893                                  ;; We want to issue "Invalid Directory" message even if the path is valid
  7894                                  ;;but is not a directory. The extended error returns "Access denied" which
  7895                                  ;;is kind of confusing. Issue the old message if access denied error is 
  7896                                  ;;returned
  7897                                  ;;
  7898                                  		;cmp	ax,error_access_denied
  7899                                  		;jz	BadChDir
  7900                                  		;
  7901                                  		;call	Set_Ext_Error_Subst ;AN022;
  7902                                  		;jmp	short  chdirerr ;AN022;
  7903                                  ;BadChDir:
  7904                                  		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
  7905                                  ;ChDirErr:
  7906                                  		;invoke	Std_Eprintf
  7907                                  		;return
  7908                                  
  7909                                  		; MSDOS 3.3
  7910                                  REALCD:
  7911 000018D4 E8A004                  		call	SETPATH
  7912 000018D7 F606[7044]02            		test	byte [DESTINFO],2
  7913 000018DC 7506                    		jnz	short BADCHDIR
  7914 000018DE B43B                    		mov	ah,CHDIR ; 3Bh
  7915 000018E0 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  7916                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  7917 000018E2 73EF                    		jnc	short CHDIR_RETN
  7918                                  BADCHDIR:
  7919 000018E4 BA[763B]                		mov	dx,BADCDPTR
  7920                                  CHDIR_ERR:
  7921 000018E7 E8E01B                  		call	STD_EPRINTF
  7922                                  MKDIR_RETN:
  7923 000018EA C3                      		retn
  7924                                  
  7925                                  ; ---------------------------------------------------------------------------
  7926                                  
  7927                                  _$MKDIR:
  7928                                  		; MSDOS 6.0
  7929                                  		;CALL	SETRMMK
  7930                                  		;JC	MkDirErr
  7931                                  		;MOV	AH,MKDIR
  7932                                  		;INT	21h
  7933                                  		;retnc
  7934                                  
  7935                                  		;invoke	get_ext_error_number	
  7936                                  		;			;AN022; get the extended error
  7937                                  		;cmp	ax,error_path_not_found 
  7938                                  		;			;AN022; see if path not found
  7939                                  		;jz	MD_other_err	;AN022; yes - issue old message
  7940                                  		;cmp	ax,error_access_denied
  7941                                  		;			;AN022; access denied?
  7942                                  		;jz	badmderr	;AN022; yes - see if file exists
  7943                                  		
  7944                                  		;call	Set_Ext_Error_Subst ;AN022;
  7945                                  		;jmp	short MkDirerr	;AC022; yes - go print it
  7946                                  ;BADMDERR:
  7947                                  		;mov	dx,offset trangroup:srcxname	
  7948                                  		;			;AN006; Set Disk transfer address
  7949                                  		;mov	ah,Set_DMA	;AN006;
  7950                                  		;int	21h		;AN006;
  7951                                  		;MOV	AH,Find_First	;AN006; see if file/dir exists
  7952                                  		;mov	cx,attr_directory ;AN006;   search for directory
  7953                                  		;INT	21h		;AN006;
  7954                                  		;jc	MD_other_err	;AN006; doesn't exist - must be something else
  7955                                  		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
  7956                                  		;test	dl,attr_directory ;AN006; was it a directory?
  7957                                  		;jz	MD_other_err	;AN006; no - must have been a file
  7958                                  		;mov	dx,offset trangroup:MD_exists_ptr 
  7959                                  		;			;AN006; set up already exists error
  7960                                  		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
  7961                                  ;MD_other_err:				;AN006;
  7962                                  		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
  7963                                  ;MkDirErr:
  7964                                  		;invoke	Std_Eprintf
  7965                                  		;return
  7966                                  
  7967                                  		; MSDOS 3.3
  7968 000018EB E81200                  		call	SETRMMK
  7969 000018EE 720C                    		jb	short MKDIRERR
  7970 000018F0 B439                    		mov	ah,MKDIR ; 39h
  7971 000018F2 CD21                    		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
  7972                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  7973 000018F4 73F4                    		jnc	short MKDIR_RETN
  7974 000018F6 BA[953B]                		mov	dx,BADMKDPTR
  7975 000018F9 E8CE05                  		call	GET_EXT_ERR_NUMBER
  7976                                  MKDIRERR:
  7977 000018FC E8CB1B                  		call	STD_EPRINTF
  7978 000018FF C3                      		retn
  7979                                  
  7980                                  ; =============== S U B	R O U T	I N E =======================================
  7981                                  
  7982                                  ; 	<Common MkDir/RmDir set up code>
  7983                                  ;****************************************************************
  7984                                  ;*
  7985                                  ;* ROUTINE:	SETRMMK
  7986                                  ;*
  7987                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
  7988                                  ;*		commands. Parses the command line for a required
  7989                                  ;*		filespec.
  7990                                  ;*
  7991                                  ;* INPUT:	command line at offset 81H
  7992                                  ;*
  7993                                  ;* OUTPUT:	carry clear
  7994                                  ;*		    DS:DX points to ASCIIZ argument
  7995                                  ;*		carry set
  7996                                  ;*		    DS:DX has error message pointer
  7997                                  ;*
  7998                                  ;****************************************************************
  7999                                  
  8000                                  		; MSDOS 6.0
  8001                                  		;mov	si,81H
  8002                                  		;mov	di,offset trangroup:parse_mrdir 
  8003                                  					;AN000; Get adderss of PARSE_MRDIR
  8004                                  		;xor	cx,cx		;AN000; clear cx,dx
  8005                                  		;xor	dx,dx		;AN000;
  8006                                  		;invoke	parse_with_msg	;AC000; call parser
  8007                                  		;cmp	ax,result_no_error ;AC000; did we have an error?
  8008                                  		;jnz	 NOARGERR	;AC000; yes - exit
  8009                                  
  8010                                  		;mov	di,offset trangroup:srcxname
  8011                                  		;			;AN000; get address of srcxname
  8012                                  		;push	di		;AN000; save address
  8013                                  		;push	si		;AN000; save position in line
  8014                                  		;lds	si,parse1_addr	;AN000; get address of path
  8015                                  
  8016                                  ;mrdir_move_filename:			;AN000; put filespec in srcxname
  8017                                  		;lodsb			;get a char from buffer
  8018                                  		;stosb			;AN000; store in srcxname
  8019                                  		;cmp	al,end_of_line_out ;AC000; it char a terminator?
  8020                                  		;jnz	mrdir_move_filename ;AC000; no - keep moving
  8021                                  		;pop	si		;AN000; get line position back
  8022                                  ;;
  8023                                  ;; we have scanned an argument.	See if any args beyond.
  8024                                  ;;
  8025                                  		;mov	di,offset trangroup:parse_mrdir 
  8026                                  		;			;AC000; get address of parse_mrdir
  8027                                  		;invoke	parse_check_eol ;AC000; are we at end of line?
  8028                                  		;pop	dx		;AC000; get address of SRCXNAME
  8029                                  		;retz			;yes - return no error
  8030                                  ;NOARGERR:
  8031                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr
  8032                                  		;			;AC000; get extended message pointer
  8033                                  		;XOR	AX,AX
  8034                                  		;STC
  8035                                  		;return
  8036                                  
  8037                                  		; MSDOS 3.3
  8038                                  SETRMMK:
  8039 00001900 BE8100                  		mov	si,81h
  8040 00001903 E87300                  		call	SCANOFF
  8041 00001906 3C0D                    		cmp	al,0Dh
  8042 00001908 741E                    		je	short NOARGERR
  8043 0000190A 89F2                    		mov	dx,si
  8044                                  SETRMMK1:
  8045 0000190C AC                      		lodsb
  8046 0000190D E87100                  		call	DELIM
  8047 00001910 7409                    		jz	short SETRMMK3
  8048 00001912 3C0D                    		cmp	al,0Dh
  8049 00001914 75F6                    		jne	short SETRMMK1
  8050 00001916 C644FF00                		mov	byte [si-1],0
  8051                                  SETRMMK2:
  8052 0000191A C3                      		retn
  8053                                  SETRMMK3:
  8054 0000191B C644FF00                		mov	byte [si-1],0
  8055 0000191F 56                      		push	si
  8056 00001920 E85600                  		call	SCANOFF
  8057 00001923 5E                      		pop	si
  8058 00001924 3C0D                    		cmp	al,0Dh
  8059 00001926 74F2                    		je	short SETRMMK2
  8060                                  NOARGERR:
  8061 00001928 BA[6D3D]                		mov	dx,BADARGSPTR
  8062 0000192B 31C0                    		xor	ax,ax
  8063 0000192D F9                      		stc
  8064                                  SETRMMK_RETN:
  8065 0000192E C3                      		retn
  8066                                  
  8067                                  ; ---------------------------------------------------------------------------
  8068                                  
  8069                                  _$RMDIR:
  8070 0000192F E8CEFF                  		call	SETRMMK
  8071 00001932 720E                    		jb	short RMDIRERR
  8072 00001934 7506                    		jnz	short BADRDERR
  8073 00001936 B43A                    		mov	ah,RMDIR ; 3Ah
  8074 00001938 CD21                    		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
  8075                                  				; DS:DX	-> ASCIZ pathname (may include drive)
  8076 0000193A 73F2                    		jnc	short SETRMMK_RETN
  8077                                  
  8078                                  		; MSDOS 6.0
  8079                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8080                                  		;cmp	ax,error_path_not_found ;AN022; see if path not found
  8081                                  		;jz	badrderr	;AN022; yes - issue old message
  8082                                  		;cmp	ax,error_access_denied 	;AN022; access denied?
  8083                                  		;jz	badrderr	;AN022; yes - issue old message
  8084                                  
  8085                                  		;call	Set_Ext_Error_Subst ;AN022;
  8086                                  		;jmp	short RmDirerr	;AC022; yes - go print it
  8087                                  
  8088                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8089                                  BADRDERR:
  8090 0000193C BA[CE3B]                		mov	dx,BADRMDPTR
  8091 0000193F E88805                  		call	GET_EXT_ERR_NUMBER
  8092                                  RMDIRERR:
  8093 00001942 E8851B                  		call	STD_EPRINTF
  8094                                  RMDIR_RETN:
  8095 00001945 C3                      		retn
  8096                                  
  8097                                  ; =============== S U B	R O U T	I N E =======================================
  8098                                  
  8099                                  ; MSDOS 6.0
  8100                                  
  8101                                  ;****************************************************************
  8102                                  ;*
  8103                                  ;* ROUTINE:	Set_ext_error_subst
  8104                                  ;*
  8105                                  ;* FUNCTION:	Sets up substitution for extended error
  8106                                  ;*
  8107                                  ;* INPUT:	AX - extended error number
  8108                                  ;*		DX - offset of string
  8109                                  ;*
  8110                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
  8111                                  ;*
  8112                                  ;****************************************************************
  8113                                  
  8114                                  ;Set_ext_error_subst  proc near		;AN022;
  8115                                  ;
  8116                                  ;	mov	msg_disp_class,ext_msg_class
  8117                                  ;					;AN022; set up extended error msg class
  8118                                  ;	mov	string_ptr_2,dx 	;AN022; get address of failed string
  8119                                  ;	mov	Extend_buf_sub,one_subst 
  8120                                  ;					;AN022; put number of subst in control block
  8121                                  ;	mov	dx,offset TranGroup:Extend_Buf_ptr 
  8122                                  ;					;AN022; get extended message pointer
  8123                                  ;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
  8124                                  ;
  8125                                  ;	ret				;AN022; return
  8126                                  ;
  8127                                  ;Set_ext_error_subst  endp		;AN022;
  8128                                  
  8129                                  ; =============== S U B	R O U T	I N E =======================================
  8130                                  
  8131                                  ; <SavUDir - preserve the users current directory on a particular drive>
  8132                                  
  8133                                  ; SavUDir - move the user's current directory on a drive into UserDir1
  8134                                  ; SavUDir1 - move the user's current directory on a drive into a specified
  8135                                  ;   buffer
  8136                                  ;
  8137                                  ;   Inputs:	DL has 1-based drive number
  8138                                  ;		ES:DI has destination buffer (SavUDir1 only)
  8139                                  ;   Outputs:	Carry Clear
  8140                                  ;		    DS = TranGroup
  8141                                  ;		Carry Set
  8142                                  ;		    AX has error code
  8143                                  ;   Registers Modified: AX, SI
  8144                                  
  8145                                  SAVUDIR:
  8146 00001946 BF[5341]                		mov	di,USERDIR1
  8147                                  
  8148                                  ; ---------------------------------------------------------------------------
  8149                                  
  8150                                  SAVUDIR1:
  8151 00001949 88D0                    		mov	al,dl
  8152 0000194B 0440                    		add	al,'@'
  8153 0000194D 3C40                    		cmp	al,'@'
  8154 0000194F 7506                    		jnz	short GOTUDRV
  8155 00001951 0206[8542]              		add	al,[CURDRV]
  8156 00001955 FEC0                    		inc	al		; A = 1
  8157                                  GOTUDRV:
  8158 00001957 AA                      		stosb
  8159 00001958 8A26[7642]              		mov	ah,[DIRCHAR]
  8160 0000195C B03A                    		mov	al,':'
  8161 0000195E AB                      		stosw
  8162 0000195F 06                      		push	es
  8163 00001960 1F                      		pop	ds
  8164 00001961 89FE                    		mov	si,di
  8165 00001963 B447                    		mov	ah,CURRENT_DIR	; 47h
  8166 00001965 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
  8167                                  				; DL = drive (0=default,1=A,etc.)
  8168                                  				; DS:SI	points to 64-byte buffer area
  8169 00001967 72DC                    		jc	short RMDIR_RETN
  8170 00001969 0E                      		push	cs
  8171 0000196A 1F                      		pop	ds
  8172 0000196B C3                      		retn
  8173                                  
  8174                                  ; =============== S U B	R O U T	I N E =======================================
  8175                                  
  8176                                  CRLF2:
  8177 0000196C 52                      		push	dx
  8178 0000196D BA[8E3D]                		mov	dx,ACRLFPTR
  8179 00001970 1E                      		push	ds
  8180 00001971 0E                      		push	cs
  8181 00001972 1F                      		pop	ds
  8182 00001973 E85D1B                  		call	STD_PRINTF
  8183 00001976 1F                      		pop	ds
  8184 00001977 5A                      		pop	dx
  8185 00001978 C3                      		retn
  8186                                  
  8187                                  ; =============== S U B	R O U T	I N E =======================================
  8188                                  
  8189                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
  8190                                  ; may NOT be TRANGROUP
  8191                                  
  8192                                  SCANOFF:
  8193 00001979 AC                      		lodsb
  8194 0000197A E80400                  		call	DELIM
  8195 0000197D 74FA                    		jz	short SCANOFF
  8196 0000197F 4E                      		dec	si		; Point to first non-delimiter
  8197                                  SCANOFF_RETN:
  8198 00001980 C3                      		retn
  8199                                  
  8200                                  ; ---------------------------------------------------------------------------
  8201                                  
  8202                                  ; Input:    AL is character to classify
  8203                                  ; Output:   Z set if delimiter
  8204                                  ;	    NZ set otherwise
  8205                                  ; Registers modified: none
  8206                                  
  8207                                  DELIM:
  8208 00001981 3C20                    		cmp	al,' '
  8209 00001983 74FB                    		jz	short SCANOFF_RETN
  8210 00001985 3C3D                    		cmp	al,'='
  8211 00001987 74F7                    		jz	short SCANOFF_RETN
  8212 00001989 3C2C                    		cmp	al,','
  8213 0000198B 74F3                    		jz	short SCANOFF_RETN
  8214 0000198D 3C3B                    		cmp	al,';'
  8215 0000198F 74EF                    		jz	short SCANOFF_RETN
  8216 00001991 3C09                    		cmp	al,9		; Check for TAB character
  8217 00001993 74EB                    		jz	short SCANOFF_RETN
  8218 00001995 3C0A                    		cmp	al,0Ah		; Check for line feed character - BAS
  8219 00001997 C3                      		retn
  8220                                  
  8221                                  
  8222                                  ; =============== S U B	R O U T	I N E =======================================
  8223                                  
  8224                                  FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
  8225 00001998 B90800                  		mov	cx,8
  8226                                  MAINNAME:
  8227 0000199B AC                      		lodsb
  8228 0000199C 3C20                    		cmp	al,' '
  8229 0000199E 7401                    		jz	short SKIPSPC
  8230 000019A0 AA                      		stosb
  8231                                  SKIPSPC:
  8232 000019A1 E2F8                    		loop	MAINNAME
  8233 000019A3 AC                      		lodsb
  8234 000019A4 3C20                    		cmp	al,' '
  8235 000019A6 7413                    		jz	short GOTNAME
  8236 000019A8 88C4                    		mov	ah,al
  8237                                  		;mov	al,'.'
  8238 000019AA A0[083F]                		mov	al,[DOT_CHR]
  8239 000019AD AA                      		stosb
  8240 000019AE 86C4                    		xchg	al,ah
  8241 000019B0 AA                      		stosb
  8242 000019B1 B102                    		mov	cl,2
  8243                                  EXTNAME:
  8244 000019B3 AC                      		lodsb
  8245 000019B4 3C20                    		cmp	al,' '
  8246 000019B6 7403                    		jz	short GOTNAME
  8247 000019B8 AA                      		stosb
  8248 000019B9 E2F8                    		loop	EXTNAME
  8249                                  GOTNAME:
  8250 000019BB 30C0                    		xor	al,al
  8251 000019BD AA                      		stosb
  8252                                  STRCOMP_RETN:
  8253 000019BE C3                      		retn
  8254                                  
  8255                                  ; =============== S U B	R O U T	I N E =======================================
  8256                                  
  8257                                  ; Compare ASCIZ DS:SI with ES:DI.
  8258                                  ; SI,DI destroyed.
  8259                                  
  8260                                  STRCOMP:	
  8261 000019BF A6                      		cmpsb
  8262 000019C0 75FC                    		jnz	short STRCOMP_RETN ; Strings not equal
  8263 000019C2 807CFF00                		cmp	byte [si-1],0	; Hit NUL terminator?	
  8264 000019C6 74F6                    		jz	short STRCOMP_RETN ; Yes, strings equal
  8265 000019C8 EBF5                    		jmp	short STRCOMP	; Equal so far, keep going
  8266                                  
  8267                                  ; =============== S U B	R O U T	I N E =======================================
  8268                                  
  8269                                  CRPRINT:
  8270 000019CA 50                      		push	ax
  8271                                  		;mov	al,13
  8272 000019CB B00D                    		mov	al,0Dh
  8273 000019CD 51                      		push	cx
  8274 000019CE 57                      		push	di
  8275 000019CF 89D7                    		mov	di,dx
  8276 000019D1 B9FFFF                  		mov	cx,65535
  8277 000019D4 06                      		push	es
  8278 000019D5 1E                      		push	ds
  8279 000019D6 07                      		pop	es
  8280 000019D7 F2AE                    		repne scasb		; LOOK FOR TERMINATOR
  8281 000019D9 C645FF00                		mov	byte [di-1],0	; nul terminate the string
  8282 000019DD 07                      		pop	es
  8283 000019DE 8916[4E44]              		mov	[STRING_PTR_2],dx
  8284 000019E2 BA[3F37]                		mov	dx,STRINGBUF2PTR
  8285 000019E5 E8EB1A                  		call	STD_PRINTF
  8286                                  		;mov	byte [di-1],13
  8287 000019E8 C645FF0D                		mov	byte [di-1],0Dh	; now put the CR back
  8288 000019EC 7204                    		jb	short ERROR_OUTPUT
  8289 000019EE 5F                      		pop	di
  8290 000019EF 59                      		pop	cx
  8291 000019F0 58                      		pop	ax
  8292 000019F1 C3                      		retn
  8293                                  
  8294                                  ; ---------------------------------------------------------------------------
  8295                                  
  8296                                  ERROR_OUTPUT:
  8297 000019F2 0E                      		push	cs
  8298 000019F3 1F                      		pop	ds
  8299 000019F4 8E06[7142]              		mov	es,[RESSEG]
  8300 000019F8 BA[3938]                		mov	dx,NOSPACEPTR
  8301 000019FB 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  8302 00001A01 7406                    		jz	short GO_TO_ERROR
  8303 00001A03 E88609                  		call	PIPEOFF
  8304 00001A06 BA[D23C]                		mov	dx,PIPEEMESPTR
  8305                                  GO_TO_ERROR:
  8306 00001A09 E91D02                  		jmp	CERROR
  8307                                  
  8308                                  ; =============== S U B	R O U T	I N E =======================================
  8309                                  
  8310                                  ;---- Mod for path invocation ----
  8311                                  
  8312                                  PATHCHRCMP:
  8313 00001A0C 50                      		push	ax
  8314 00001A0D B42F                    		mov	ah,'/'
  8315 00001A0F 3826[7542]              		cmp	[SWITCHAR],ah
  8316 00001A13 7404                    		jz	short NOSLASHT
  8317 00001A15 3C2F                    		cmp	al,'/'
  8318 00001A17 7402                    		jz	short PCCONT
  8319                                  NOSLASHT:
  8320 00001A19 3C5C                    		cmp	al,'\'
  8321                                  PCCONT:	
  8322 00001A1B 58                      		pop	ax
  8323 00001A1C C3                      		retn
  8324                                  
  8325                                  ; =============== S U B	R O U T	I N E =======================================
  8326                                  
  8327                                  ; PATHCRUNCH -
  8328                                  ;
  8329                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
  8330                                  ;       PathPos = ptr to string with pathname in it
  8331                                  ;       PathCnt = length of string
  8332                                  ;
  8333                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
  8334                                  ;       PathCnt = length left in string
  8335                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
  8336                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
  8337                                  ;       If path crunched successfully,
  8338                                  ;         CY = clear
  8339                                  ;         Current directory is changed to directory in pathname
  8340                                  ;         UserDir1 contains previous directory for use by RestUDir
  8341                                  ;         RestDir = nonzero to flag later restoration of user's dir
  8342                                  ;         DestTail = ptr to beginning of filename
  8343                                  ;         If filename found in pathname,
  8344                                  ;           ZR = clear
  8345                                  ;           FCB filename fields contain filename
  8346                                  ;         If filename not found (pure directory path),
  8347                                  ;           ZR = set
  8348                                  ;           FCB filename fields are wildcarded with ?'s
  8349                                  ;       If pathcrunch failed (no ChDir's worked),
  8350                                  ;         CY = set
  8351                                  ;         Msg_Numb = extended error code
  8352                                  ;
  8353                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
  8354                                  ;       FCB by setting DirFlag.  In this case, the FCB is returned
  8355                                  ;       with the filename wildcarded.
  8356                                  
  8357                                  PATHCRUNCH:
  8358                                  		; MSDOS 6.0
  8359                                  		;mov     [msg_numb],0	;AN022; Set up message flag
  8360                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8361                                  		;mov	dl,[5CH]
  8362 00001A1D 8A165C00                		mov	dl,[FCB]	; DL = drive # (1 = A)
  8363 00001A21 E822FF                  		call	SAVUDIR		; save current directory in UserDir1
  8364 00001A24 E85003                  		call	SETPATH
  8365                                  		; MSDOS 6.0
  8366                                   		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report
  8367                                  
  8368                                  ;       DX = ptr to pathname, NULL-terminated
  8369                                  ;       PathPos = ptr to byte after NULL at end of pathname
  8370                                  
  8371                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8372 00001A27 F606[7044]02            		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
  8373 00001A2C 7516                    		jnz	short TRYPEEL	; wildcard seen, peel filename
  8374                                  
  8375 00001A2E B43B                    		mov	ah,CHDIR ; 3Bh
  8376 00001A30 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8377                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8378                                  		; MSDOS 6.0
  8379                                  		;jnc	chdir_worked            ;AN022; no error - continue
  8380                                  		;
  8381                                  		;invoke	get_ext_error_number    ;AN022; get the extended error
  8382                                  		;cmp	ax,error_path_not_found ;AN022; if path not found
  8383                                  		;jz	trypeel                 ;AC022;     keep trying
  8384                                  		;cmp	ax,error_access_denied  ;AN022; if access denied
  8385                                  		;jz	trypeel                 ;AC022;     keep trying
  8386                                  		;mov	[msg_numb],ax           ;AN022; set up message flag
  8387                                  		;jmp	peelfail                ;AN022; exit with other error
  8388                                  
  8389                                  		; MSDOS 3.3
  8390 00001A32 7210                    		jc	short TRYPEEL
  8391                                  ;chdir_worked:
  8392                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8393 00001A34 E8D304                  		call	SETREST1	; set 'Restore Directory' flag true
  8394 00001A37 B03F                    		mov	al,'?'		; if pure dir, wildcard filename in FCB
  8395 00001A39 BF5D00                  		mov	di,5Dh
  8396 00001A3C B90B00                  		mov	cx,11
  8397 00001A3F F3AA                    		rep stosb
  8398 00001A41 30C0                    		xor	al,al		; return carry clear, zero set
  8399 00001A43 C3                      		retn
  8400                                  ;pcrunch_cderrj: 			;AN022; need this for long jmp
  8401                                  		;jmp	pcrunch_cderr	;AN022;
  8402                                  TRYPEEL:
  8403 00001A44 8B36[C043]              		mov	si,[PATHPOS]
  8404 00001A48 4E                      		dec	si		; SI = ptr to NULL at end of pathname
  8405 00001A49 8A44FF                  		mov	al,[si-1]	; AL = last char of pathname	
  8406 00001A4C E8BDFF                  		call	PATHCHRCMP
  8407 00001A4F 7424                    		jz	short PEELFAIL
  8408                                  DELLOOP:
  8409 00001A51 39D6                    		cmp	si,dx
  8410 00001A53 742C                    		jz	short BADRET
  8411 00001A55 8A04                    		mov	al,[si]
  8412 00001A57 E8B2FF                  		call	PATHCHRCMP
  8413 00001A5A 7403                    		jz	short TRYCD
  8414 00001A5C 4E                      		dec	si
  8415 00001A5D EBF2                    		jmp	short DELLOOP
  8416                                  TRYCD:
  8417 00001A5F 50                      		push	ax
  8418                                  		;mov	al,'.'
  8419 00001A60 A0[083F]                		mov	al,[DOT_CHR]	; AL = '.'
  8420                                  		; MSDOS 6.0
  8421                                  		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
  8422                                  					;M019; allow continuation if '. ' or 
  8423                                  					;M019; '..' is not found.
  8424                                  		;jnz	@f		;M019; '.' not found
  8425                                  		;cmp	byte ptr [SI+2],al ;M019; check for '..'
  8426                                  		;jz	@f		;M019; found '..'
  8427                                  		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
  8428                                  ;@@:		;pop     ax
  8429                                  		;jz      PEELFAIL	; if . or .., pure cd should have worked
  8430                                  
  8431                                  		; MSDOS 3.3
  8432 00001A63 384401                  		cmp	[si+1],	al	; check for '.' after path delim
  8433 00001A66 58                      		pop	ax
  8434 00001A67 740C                    		jz	short PEELFAIL	; if . or .., pure cd should have worked
  8435                                  
  8436                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8437 00001A69 8A44FF                  		mov	al,[si-1]	; Special case d:\file	
  8438 00001A6C 3C3A                    		cmp	al,':'
  8439 00001A6E 7411                    		jz	short BADRET
  8440 00001A70 E899FF                  		call	PATHCHRCMP
  8441 00001A73 7502                    		jnz	short NODOUBLESL
  8442                                  PEELFAIL:
  8443 00001A75 F9                      		stc
  8444 00001A76 C3                      		retn
  8445                                  NODOUBLESL:
  8446 00001A77 C60400                  		mov	byte [si],0
  8447 00001A7A B43B                    		mov	ah,CHDIR ; 3Bh
  8448 00001A7C CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8449                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8450 00001A7E 7317                    		jnc	short CDSUCC
  8451                                  
  8452                                  		; MSDOS 6.0
  8453                                  ;pcrunch_cderr:
  8454                                  		;invoke	get_ext_error_number ;AN022; get the extended error
  8455                                  		;mov	[msg_numb],ax	;AN022; set up message flag
  8456                                  		;or	si,si		;AN022; set up zero flag to not zero
  8457                                  		;stc			;AN022; set up carry flag
  8458                                  		;return
  8459                                  		
  8460                                  		; MSDOS 3.3
  8461                                  PATHCRUNCH_RETN:
  8462 00001A80 C3                      		retn
  8463                                  
  8464                                  BADRET:
  8465 00001A81 8A04                    		mov	al,[si]
  8466 00001A83 E886FF                  		call	PATHCHRCMP
  8467 00001A86 F9                      		stc
  8468 00001A87 75F7                    		jnz	short PATHCRUNCH_RETN
  8469 00001A89 30DB                    		xor	bl,bl
  8470 00001A8B 865C01                  		xchg	bl,[si+1]
  8471 00001A8E B43B                    		mov	ah,CHDIR ; 3Bh
  8472 00001A90 CD21                    		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  8473                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
  8474 00001A92 72EC                    		jb	short PATHCRUNCH_RETN
  8475 00001A94 885C01                  		mov	[si+1],	bl
  8476                                  CDSUCC:
  8477 00001A97 E87004                  		call	SETREST1
  8478 00001A9A 46                      		inc	si
  8479 00001A9B 8936[6E44]              		mov	[DESTTAIL],si
  8480                                  		; MSDOS 6.0
  8481                                  		;pushf			;AN015; save flags
  8482                                  		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
  8483                                  		;jz	pcrunch_end	;AN015;
  8484                                  		;MOV	DI,FCB
  8485                                  		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
  8486                                  					; Parse with default drive
  8487                                  		;INT	21h
  8488                                  ;pcrunch_end:
  8489                                  		;popf			;AN015; get flags back
  8490                                  		;return
  8491                                  
  8492                                  		; MSDOS 3.3
  8493 00001A9F BF5C00                  		mov	di,FCB ; 5Ch
  8494 00001AA2 B80229                  		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
  8495 00001AA5 CD21                    		int	21h	; DOS -	PARSE FILENAME
  8496                                  				; DS:SI	-> string to parse
  8497                                  				; ES:DI	-> buffer to fill with unopened	FCB
  8498                                  				; AL = bit mask	to control parsing
  8499 00001AA7 C3                      		retn
  8500                                  
  8501                                  ;============================================================================
  8502                                  ; TMISC1.ASM, MSDOS 6.0, 1991
  8503                                  ;============================================================================
  8504                                  ; 05/10/2018 - Retro DOS v3.0
  8505                                  
  8506                                  ;TITLE	Part7 COMMAND Transient Routines
  8507                                  
  8508                                  ;	More misc routines
  8509                                  
  8510                                  ;---------------------------
  8511                                  ; We can get rid of this switch processing code if we can take
  8512                                  ; care of the remaining two calls to switch, later in the file.
  8513                                  ; However, I have not checked whether or not any other files use
  8514                                  ; switch -- after all, it IS public!
  8515                                  ;---------------------------
  8516                                  
  8517                                  ;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
  8518                                  SWCOUNT	 EQU  5  ; MSDOS 3.3	
  8519                                  
  8520                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
  8521                                  
  8522                                  ; ---------------------------------------------------------------------------
  8523                                  
  8524 00001AA8 93                      RETSW:		xchg	ax,bx		; Put switches in AX
  8525 00001AA9 C3                      		retn
  8526                                  
  8527                                  ; =============== S U B	R O U T	I N E =======================================
  8528                                  
  8529                                  SWITCH:
  8530 00001AAA 31DB                    		xor	bx,bx		; Initialize - no switches set
  8531                                  SWLOOP:
  8532 00001AAC E8CAFE                  		call	SCANOFF		; Skip any delimiters
  8533 00001AAF 3A06[7542]              		cmp	al,[SWITCHAR]	; Is it a switch specifier?
  8534 00001AB3 75F3                    		jnz	short RETSW	; No -- we're finished
  8535                                  		;or	bx,8000h
  8536 00001AB5 81CB0080                		or	bx,FSWITCH	; Indicate there is a switch specified
  8537 00001AB9 46                      		inc	si		; Skip over the switch character
  8538 00001ABA E8BCFE                  		call	SCANOFF
  8539 00001ABD 3C0D                    		cmp	al,0Dh
  8540 00001ABF 74E7                    		je	short RETSW	; Oops
  8541 00001AC1 46                      		inc	si
  8542                                  
  8543                                  		; Convert lower case input to upper case
  8544                                  
  8545                                  		;call	UPCONV
  8546 00001AC2 E859FD                  		call	UPCONV_MAPCALL
  8547                                  
  8548 00001AC5 BF[1D3F]                		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
  8549                                  					; ("?VBAPW" (for MSDOS 6.0))				
  8550                                  		;mov	cx,5  ; MSDOS 3.3
  8551 00001AC8 B90500                  		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
  8552                                  		
  8553                                  		;nop
  8554                                  		
  8555 00001ACB F2AE                    		repne scasb		; Look for matching switch
  8556 00001ACD 7507                    		jnz	short BADSW
  8557 00001ACF B80100                  		mov	ax,1
  8558 00001AD2 D3E0                    		shl	ax,cl		; Set a bit for the switch
  8559 00001AD4 09C3                    		or	bx,ax
  8560                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
  8561 00001AD6 EBD4                    		jmp	short SWLOOP
  8562                                  
  8563                                  ;BADSW:
  8564                                  		;jmp	short SWLOOP
  8565                                  
  8566                                  DRVBAD:
  8567 00001AD8 BA[4939]                		mov	dx,BADDRVPTR
  8568 00001ADB E94B01                  		jmp	CERROR
  8569                                  
  8570                                  EXTERNALJ:
  8571 00001ADE E9B100                  		jmp	EXTERNAL
  8572                                  
  8573                                  FNDCOM:					; search the internal command table
  8574 00001AE1 08C0                    		or	al,al		; Get real length of first arg
  8575 00001AE3 74F9                    		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
  8576                                  					;  to be external.
  8577                                  ; barryf code starts here
  8578                                  
  8579 00001AE5 E87E02                  		call	TEST_APPEND	; see if APPEND installed
  8580 00001AE8 7421                    		jz	short CONTCOM	; not loaded
  8581                                  
  8582                                  APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
  8583 00001AEA 8A0E[EB42]              		mov	cl,[IDLEN]
  8584 00001AEE B500                    		mov	ch,0
  8585 00001AF0 890E[C043]              		mov	[PATHPOS],cx
  8586                                  		
  8587                                  		; MSDOS 6.0
  8588                                  		;inc 	append_exec	;AN041; set APPEND to ON
  8589                                  
  8590 00001AF4 E80E03                  		call	IOSET		; re-direct the o'l io
  8591                                  
  8592 00001AF7 BE[EB42]                		mov	si,IDLEN	; address command name, DS already set	
  8593 00001AFA BAFFFF                  		mov	dx,-1 ; 0FFFFh	; set invoke function
  8594                                  		
  8595                                  		; MSDOS 6.0
  8596                                  		;mov	di,offset TRANGROUP:APPEND_PARSE
  8597                                  					;AN010; Get the entry point for PARSE for APPEND
  8598                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8599 00001AFD B801AE                  		mov	ax,0AE01h
  8600 00001B00 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal
  8601                                  				; - INSTALLABLE	COMMAND	- EXECUTE
  8602                                  				; DX = FFFFh,[SI -> buffer
  8603                                  				; Return: buffer at DS:SI filled with a	length byte
  8604                                  				;		 followed by the uppercase
  8605                                  				; internal command to execute (if length not 0)
  8606 00001B02 803E[EB42]00            		cmp	byte [IDLEN],0 ; execute requested
  8607 00001B07 7502                    		jne	short CONTCOM
  8608 00001B09 EB57                    		jmp	short CMD_DONE
  8609                                  
  8610                                  		;nop
  8611                                  CONTCOM:				; continue with internal scan
  8612 00001B0B BF[E33D]                		mov	di,COMTAB
  8613 00001B0E 31C9                    		xor	cx,cx
  8614                                  FINDCOM:
  8615 00001B10 BE[EC42]                		mov	si,ID		; pointer to command argument
  8616 00001B13 8A0D                    		mov	cl,[di]		; load length of internal command
  8617 00001B15 47                      		inc	di		; advance past length
  8618 00001B16 E3C6                    		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
  8619 00001B18 3A0E[EB42]              		cmp	cl,[IDLEN]	; that of the command argument
  8620 00001B1C 7506                    		jne	short ABCD	; lengths not equal ==> strings not eq
  8621 00001B1E 890E[C043]              		mov	[PATHPOS],cx	; store length of command
  8622 00001B22 F3A6                    		repe cmpsb
  8623                                  ABCD:					
  8624 00001B24 9F                      		lahf			; save the good ol' flags
  8625 00001B25 01CF                    		add	di,cx		; skip over remaining internal, if any
  8626 00001B27 8A05                    		mov	al,[di]		; load drive-check indicator byte (DCIB)
  8627 00001B29 A2[8342]                		mov	[CHKDRV],al	; save command flag byte in chkdrv
  8628 00001B2C 47                      		inc	di		; increment DI (OK, OK, I'll stop)
  8629 00001B2D 8B1D                    		mov	bx,[di]		; load internal command address
  8630 00001B2F 47                      		inc	di		; skip over the puppy
  8631 00001B30 47                      		inc	di
  8632                                  		
  8633                                  		; MSDOS 6.0
  8634                                  		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
  8635                                  		;inc     DI
  8636                                  		;inc     DI
  8637                                  		;sahf			; remember those flags?
  8638                                  		;jnz     findcom	; well, if all the cmps worked...
  8639                                  ;;
  8640                                  ;; All messages get redirected.
  8641                                  ;;
  8642                                  		;cmp     append_exec,0	;AN041; APPEND just executed?
  8643                                  		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
  8644                                  		;invoke  ioset		; re-direct the ol' i/o
  8645                                  
  8646                                  ;dont_set_io:					;AN041;
  8647                                  ;;
  8648                                  ;; Check for /?.  Certain commands, flagged fLimitHelp,
  8649                                  ;; respond to /? only if it is the only command-line argument.
  8650                                  ;;
  8651                                  		;mov     ax,[COMSW]	; AX = switches after command
  8652                                  		;or      ax,[ALLSWITCH]	; AX = all switches
  8653                                  		;and     ax,SwitchQues	
  8654                                  		;jz      drive_check	; /? not in command line
  8655                                  		;	
  8656                                  		;test    [CHKDRV],fLimitHelp
  8657                                  		;jz      do_help	; /? allowed in combination
  8658                                  ;;
  8659                                  ;; Make sure /? is the only argument on the command line.
  8660                                  ;;
  8661                                  		;cmp     [arg.argvcnt],2
  8662                                  		;jne     drive_check	; /? not only arg - ignore
  8663                                  ;;
  8664                                  ;; Note:  this is all the check we need, even against things like /??.
  8665                                  ;; Our argv parser breaks /?? into two args, /? and ?.
  8666                                  ;;
  8667                                  
  8668                                  ;do_help:
  8669                                  ;
  8670                                  ; DX = ptr to word list of msg #s, terminated by zero word
  8671                                  
  8672                                  		;mov     si,dx		; SI = ptr to list of msg #s
  8673                                      		;mov     ax,NO_SUBST	; AL = no subst's code
  8674                                  		;push    ax		; build subst block on stack
  8675                                  
  8676                                  ;next_help_msg:
  8677                                  		;lodsw			; AX = help msg # or zero
  8678                                  		;or      ax,ax
  8679                                  		;jz      help_done
  8680                                  		;push    ax		; SS:SP = ptr to subst block
  8681                                  					;  (msg # and no_subst byte)
  8682                                  ;; We assume DS = SS.
  8683                                  
  8684                                      		;mov     dx,sp		; DS:DX = ptr to subst block
  8685                                      		;invoke  Std_PrintF	; display help message
  8686                                      		;pop     ax		; remove msg # from stack
  8687                                     		;jmp     next_help_msg
  8688                                  
  8689                                  ;help_done:
  8690                                  		;pop     ax		; clean up stack
  8691                                  		;jmp     TCommand	
  8692                                  
  8693                                  		; MSDOS 3.3
  8694 00001B31 9E                      		sahf			; remember those flags?
  8695 00001B32 75DC                    		jnz	short FINDCOM	; well, if all the cmps worked...
  8696 00001B34 E8CE02                  		call	IOSET		; re-direct the ol' i/o
  8697                                  
  8698                                  DRIVE_CHECK:
  8699                                  		;test	byte [CHKDRV],1
  8700 00001B37 F606[8342]01            		test	byte [CHKDRV],FCHECKDRIVE 
  8701                                  					; did we wanna check those drives?
  8702 00001B3C 740D                    		jz	short NOCHECK
  8703 00001B3E A0[8642]                		mov	al,[PARM1]	; parse_file_descriptor results tell
  8704 00001B41 0A06[8742]              		or	al,[PARM2]	; us whether those drives were OK
  8705 00001B45 3CFF                    		cmp	al,-1
  8706 00001B47 7502                    		jnz	short NOCHECK
  8707 00001B49 EB8D                    		jmp	short DRVBAD
  8708                                  
  8709                                  ; The user may have omitted the space between the command and its arguments.
  8710                                  ; We need to copy the remainder of the user's command line into the buffer.
  8711                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
  8712                                  ; into the command line at 80.
  8713                                  
  8714                                  NOCHECK:
  8715 00001B4B E8FB01                  		call	CMD_COPY
  8716                                  SWITCHECK:
  8717                                  		;test	byte [CHKDRV],2
  8718 00001B4E F606[8342]02            		test	byte [CHKDRV],FSWITCHALLOWED 
  8719                                  					; Does the command take switches
  8720 00001B53 750B                    		jnz	short REALWORK	; Yes, process the command
  8721 00001B55 E82400                  		call	NOSWIT		; No, check to see if any switches
  8722 00001B58 7506                    		jnz	short REALWORK	; None, process the command
  8723                                  
  8724                                  		; MSDOS 6.0
  8725                                  		;mov	msg_disp_class,parse_msg_class	
  8726                                  		;			;AN000; set up parse error msg class
  8727                                  		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
  8728                                  		;			;AC000; get extended message pointer
  8729                                  		;mov	Extend_Buf_ptr,BadSwt_ptr		
  8730                                  		;			;AN000; get "Invalid switch" message number
  8731                                  		;jmp	CERROR		; Print error and chill out...
  8732                                  
  8733                                  		; MSDOS 3.0
  8734 00001B5A BA[223A]                		mov	dx,BADPARMPTR
  8735 00001B5D E9C900                  		jmp	CERROR
  8736                                  
  8737                                  REALWORK:
  8738 00001B60 FFD3                    		call	bx		; do some real work, at last
  8739                                  
  8740                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
  8741                                  ; otherwise, go get another command.
  8742                                  
  8743                                  CMD_DONE:
  8744 00001B62 0E                      		push	cs		; g  restore data segment
  8745 00001B63 1F                      		pop	ds		; g
  8746 00001B64 1E                      		push	ds
  8747 00001B65 8E1E[7142]              		mov	ds,[RESSEG]	; g  save data segment
  8748                                  		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
  8749 00001B69 803EFE0B01              		cmp	byte [CALL_FLAG],call_in_progress
  8750 00001B6E C606FE0B00              		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
  8751 00001B73 1F                      		pop	ds		; g  get data segment back
  8752 00001B74 7403                    		jz	short INCALL	; G
  8753 00001B76 E98BE5                  		jmp	TCOMMAND	; chill out...
  8754                                  INCALL:
  8755 00001B79 E931E7                  		jmp	DOCOM1
  8756                                  
  8757                                  ; =============== S U B	R O U T	I N E =======================================
  8758                                  
  8759                                  NOSWIT:
  8760 00001B7C 57                      		push	di		; Save di
  8761 00001B7D BF8100                  		mov	di,81h		; di = ptr to command args
  8762 00001B80 BE8000                  		mov	si,80h		; Get address of length of command args
  8763 00001B83 AC                      		lodsb			; Load length
  8764 00001B84 88C1                    		mov	cl,al		; Move length to cl
  8765 00001B86 30ED                    		xor	ch,ch		; Zero ch
  8766 00001B88 2EA0[7542]              		mov	al,[cs:SWITCHAR] ; al = switch character
  8767 00001B8C 3C00                    		cmp	al,0		; Turn off ZF
  8768 00001B8E F2AE                    		repne scasb		; Scan for a switch character and return
  8769 00001B90 5F                      		pop	di		;  with ZF set if one was found
  8770 00001B91 C3                      		retn
  8771                                  
  8772                                  ; ---------------------------------------------------------------------------
  8773                                  
  8774                                  EXTERNAL:
  8775 00001B92 E8D101                  		call	TEST_APPEND	; check to see if append installed
  8776 00001B95 7403                    		jz	short NOT_BARRYF ; no - truly external command
  8777 00001B97 E950FF                  		jmp	APPEND_INTERNAL	; yes - go to Barryf code
  8778                                  
  8779                                  NOT_BARRYF:
  8780 00001B9A 2EC606[8442]00          		mov	byte [cs:FILTYP],0
  8781 00001BA0 2E8A16[9142]            		mov	dl,[cs:SPECDRV]
  8782 00001BA5 2E8816[EB42]            		mov	[cs:IDLEN],dl
  8783 00001BAA 2EC606[6744]00          		mov	byte [cs:ROM_CALL],0
  8784 00001BB0 52                      		push	dx
  8785 00001BB1 BA[EB42]                		mov	dx,IDLEN
  8786 00001BB4 E819E8                  		call	ROM_SCAN
  8787 00001BB7 5A                      		pop	dx
  8788                                  		;jnc	short POSTSAVE
  8789 00001BB8 7305                    		jnc	short DO_SCAN
  8790 00001BBA 2EFE06[6744]            		inc	byte [cs:ROM_CALL]
  8791                                  		;jmp	short POSTSAVE
  8792                                  
  8793                                  		;nop
  8794                                  DO_SCAN:
  8795                                  POSTSAVE:
  8796 00001BBF BF[9941]                		mov	di,EXECPATH
  8797 00001BC2 C60500                  		mov	byte [di],0	; Initialize to current directory
  8798                                  	
  8799 00001BC5 2E803E[6744]00          		cmp	byte [cs:ROM_CALL],0
  8800 00001BCB 7402                    		jz	short RESEARCH
  8801 00001BCD EB13                    		jmp	short NEOEXECUTE
  8802                                  		
  8803                                  		;nop
  8804                                  RESEARCH:
  8805 00001BCF E81E09                  		call	PATH_SEARCH	; find the mother (result in execpath)
  8806 00001BD2 09C0                    		or	ax,ax		; did we find anything?
  8807 00001BD4 740A                    		jz	short BADCOMJ45	; null means no (sob)
  8808 00001BD6 83F804                  		cmp	ax,4		; 04H and 08H are .exe and .com
  8809                                  					; fuckin' sixteen-bit machine ought
  8810 00001BD9 7C02                    		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
  8811                                  					; DISPLACEMENT!!
  8812                                  		;jmp	short NEOEXECUTE
  8813 00001BDB EB05                    		jmp	short EXECUTE	
  8814                                  
  8815                                  		; 02H is .bat
  8816                                  
  8817                                  		;nop
  8818                                  BATCOMJ:
  8819 00001BDD E906EB                  		jmp	BATCOM
  8820                                  
  8821                                  BADCOMJ45:
  8822 00001BE0 EB42                    		jmp	short BADCOM
  8823                                  
  8824                                  		;nop
  8825                                  EXECUTE:
  8826                                  NEOEXECUTE:
  8827 00001BE2 E82002                  		call	IOSET
  8828                                  
  8829                                  ; MSDOS 6.0
  8830                                  ;M051
  8831                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
  8832                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
  8833                                  ;After a close, this would still leave one open active resulting in sharing
  8834                                  ;errors on subsequent opens of the redirected file.
  8835                                  ;
  8836                                  ;LH_EXECUTE:				;M051	
  8837 00001BE5 8E06[8142]              		mov	es,[TRAN_TPA]
  8838 00001BE9 B449                    		mov	ah,DEALLOC ; 49h
  8839 00001BEB CD21                    		int	21h	; DOS -	2+ - FREE MEMORY
  8840                                  				; ES = segment address of area to be freed
  8841                                  					; Now running in "free" space
  8842 00001BED 8E06[7142]              		mov	es,[RESSEG]
  8843 00001BF1 26FE06E90B              		inc	byte [es:EXTCOM] ; Indicate external command
  8844 00001BF6 26C606F10B00            		mov	byte [es:RESTDIR],0 
  8845                                  					; Since USERDIR1 is in transient, insure
  8846                                  					; this flag value for re-entry to COMMAND
  8847                                  		; MSDOS 6.0
  8848                                  		;MOV	SI,OFFSET TRANGROUP:EXECPATH
  8849                                  		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
  8850                                  		;MOV	CX,LenMsgOrPathBuf
  8851                                  		;CLD
  8852                                  		;REP	MOVSB		; copy program pathname to resident
  8853                                  
  8854                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8855 00001BFC BF5C00                  		mov	di,FCB ; 5Ch
  8856 00001BFF 89FE                    		mov	si,di
  8857 00001C01 B95200                  		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
  8858 00001C04 F3A5                    		rep movsw		; Transfer parameters to resident header
  8859 00001C06 BA[9941]                		mov	dx,EXECPATH
  8860                                  		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
  8861 00001C09 BB030D                  		mov	bx,EXEC_BLOCK
  8862 00001C0C B8004B                  		mov	ax,EXEC*256 ; 4B00h
  8863 00001C0F F606[6744]FF            		test	byte [ROM_CALL],-1 ; 0FFh
  8864 00001C14 7403                    		jz	short OK_EXEC
  8865 00001C16 E930E8                  		jmp	ROM_EXEC
  8866                                  OK_EXEC:
  8867                                  ;
  8868                                  ; we are now running in free space. Anything we do from here on may get
  8869                                  ; trashed. Move the stack (also in free space) to allocated space because
  8870                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
  8871                                  ;
  8872 00001C19 8CC1                    		mov	cx,es
  8873 00001C1B 8ED1                    		mov	ss,cx
  8874 00001C1D BC3C08                  		mov	sp,RSTACK
  8875 00001C20 FF2E[7742]              		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
  8876                                  
  8877                                  ; ---------------------------------------------------------------------------
  8878                                  
  8879                                  BADCOM:
  8880 00001C24 0E                      		push	cs
  8881 00001C25 1F                      		pop	ds
  8882 00001C26 BA[BB37]                		mov	dx,BADNAMPTR
  8883                                  CERROR:		
  8884 00001C29 E89E18                  		call	STD_EPRINTF
  8885 00001C2C E9D5E4                  		jmp	TCOMMAND
  8886                                  
  8887                                  
  8888                                  ; =============== S U B	R O U T	I N E =======================================
  8889                                  
  8890                                  ; Prescan converts the input buffer into a canonicalized form.
  8891                                  ; All redirections and pipes are removed.
  8892                                  
  8893                                  PRESCAN:
  8894 00001C2F 31C9                    		xor	cx,cx
  8895 00001C31 8E06[7142]              		mov	es,[RESSEG]
  8896 00001C35 BE[D240]                		mov	si,COMBUF+2
  8897 00001C38 89F7                    		mov	di,si
  8898                                  COUNTQUOTES:
  8899 00001C3A AC                      		lodsb			; get a byte
  8900 00001C3B 3C22                    		cmp	al,22h		; is it a quote?
  8901 00001C3D 7504                    		jne	short COUNTEND	; no, try for end of road
  8902 00001C3F FEC5                    		inc	ch		; bump count
  8903 00001C41 EBF7                    		jmp	short COUNTQUOTES ; go get next char
  8904                                  COUNTEND:
  8905 00001C43 3C0D                    		cmp	al,0Dh		; end of road?
  8906 00001C45 75F3                    		jne	short COUNTQUOTES ; no, go back for next char
  8907 00001C47 89FE                    		mov	si,di		; restore pointer to begining
  8908                                  PRESCANLP:
  8909 00001C49 AC                      		lodsb
  8910 00001C4A 3C22                    		cmp	al,'"'		; " character
  8911 00001C4C 7510                    		jne	short TRYGREATER
  8912 00001C4E FECD                    		dec	ch
  8913 00001C50 740C                    		jz	short TRYGREATER
  8914                                  QLOOP:
  8915 00001C52 8805                    		mov	[di],al
  8916 00001C54 47                      		inc	di
  8917 00001C55 FEC1                    		inc	cl
  8918 00001C57 AC                      		lodsb
  8919 00001C58 3C22                    		cmp	al,'"'		; " character
  8920 00001C5A 75F6                    		jne	short QLOOP
  8921 00001C5C FECD                    		dec	ch
  8922                                  TRYGREATER:
  8923 00001C5E 3A06[F33E]              		cmp	al,[RABRACKET]
  8924 00001C62 753E                    		jne	short NOOUT
  8925                                  
  8926                                  ; We have found a ">" char. We need to see if there is another ">"
  8927                                  ; following it.
  8928                                  
  8929 00001C64 3804                    		cmp	[si],al
  8930 00001C66 7506                    		jnz	short NOAPPND
  8931 00001C68 AC                      		lodsb
  8932 00001C69 26FE06080C              		inc	byte [es:RE_OUT_APP] ; Flag >>
  8933                                  NOAPPND:
  8934                                  ; Now we attempt to find the file name. First, scan off all whitespace
  8935                                  
  8936 00001C6E E808FD                  		call	SCANOFF
  8937                                  
  8938                                  		; MSDOS 6.0
  8939                                  		;CMP	AL,[LABRACKET]	   ;AN040; was there no filename?
  8940                                  		;Je	short REOUT_ERRSET ;AN040; yes - set up error
  8941                                  
  8942                                  		; MSDOS 3.3 (& MSDOS 6.0)
  8943 00001C71 3C0D                    		cmp	al,0Dh
  8944 00001C73 750D                    		jnz	short GOTREOFIL
  8945                                  
  8946                                  ; There was no file present.  Set us up at end-of-line.
  8947                                  
  8948                                  REOUT_ERRSET:				;AN040; set up for an error
  8949 00001C75 C6050D                  		mov	byte [di],0Dh	; Clobber first ">"
  8950 00001C78 26C706090C0900          		mov	word [es:RE_OUTSTR],9 ; Cause an error later
  8951 00001C7F E99E00                  		jmp	PRESCANEND
  8952                                  
  8953                                  GOTREOFIL:
  8954 00001C82 57                      		push	di
  8955                                  		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
  8956 00001C83 BF090C                  		mov	di,RE_OUTSTR
  8957 00001C86 89FB                    		mov	bx,di
  8958 00001C88 06                      		push	es
  8959                                  
  8960                                  		; MSDOS 6.0
  8961                                  SETREOUTSTR:				; Get the output redirection name
  8962                                  					; MSKK06 07/14/89
  8963                                  		;push	cx		; save cx
  8964                                  		;mov	cx,64+13	; CX = max string length
  8965                                  ;SETREOUTSTR_LOOP:
  8966                                  		;LODSB
  8967                                  		;CMP	AL,0DH
  8968                                  		;JZ	GOTRESTR_J
  8969                                  		;INVOKE	DELIM
  8970                                  		;JZ	GOTRESTR_J
  8971                                  		;CMP	AL,[SWITCHAR]
  8972                                  		;JZ	GOTRESTR_J
  8973                                  		;CMP	AL,'"'		;AN033; Is the character a quote?
  8974                                  		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
  8975                                  		;CMP	AL,labracket	;AN002; Is char for input redirection
  8976                                  		;JZ	ABRACKET_TERM	;AN002; yes - end of string
  8977                                  		;CMP	AL,rabracket	;AN002; Is char for output redirection
  8978                                  		;JNZ	NO_ABRACKET	;AN002; no - not end of string
  8979                                  ;ABRACKET_TERM:				;AN002; have end of string by < or >
  8980                                  		;DEC	SI		;AN002; back up over symbol
  8981                                  		;MOV	AL,BLANK	;AN002; show delimiter as char
  8982                                  ;GOTRESTR_J:
  8983                                  		;pop	cx		; MSKK06 07/14/89
  8984                                  		;JMP	SHORT GOTRESTR	;AN002; go process it
  8985                                  ;NO_ABRACKET:				;AN002; NOT AT END OF STRING
  8986                                  		;STOSB			; store it into resgroup
  8987                                  		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
  8988                                  		;jmp	GOTRESTR_j
  8989                                  ;PIPEERRSYNJ5_J:
  8990                                  		;pop	cx		; recover CX
  8991                                  		;jmp	short PIPEERRSYNJ5
  8992                                  
  8993                                  		; MSDOS 3.3
  8994                                  SETREOUTSTR_LOOP:			; Get the output redirection name
  8995 00001C89 AC                      		lodsb
  8996 00001C8A 3C0D                    		cmp	al,0Dh
  8997 00001C8C 746E                    		jz	short GOTRESTR
  8998 00001C8E E8F0FC                  		call	DELIM
  8999 00001C91 7469                    		jz	short GOTRESTR
  9000 00001C93 3A06[7542]              		cmp	al,[SWITCHAR]
  9001 00001C97 7463                    		je	short GOTRESTR
  9002 00001C99 3C22                    		cmp	al,'"'
  9003 00001C9B 7502                    		jne	short NO_ABRACKET
  9004 00001C9D FECD                    		dec	ch
  9005                                  NO_ABRACKET:
  9006 00001C9F AA                      		stosb
  9007 00001CA0 EBE7                    		jmp	short SETREOUTSTR_LOOP
  9008                                  NOOUT:
  9009                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9010 00001CA2 3A06[F23E]              		cmp	al,[LABRACKET]
  9011 00001CA6 751F                    		jnz	short CHKPIPE
  9012 00001CA8 89F3                    		mov	bx,si		; Save loc of "<"
  9013 00001CAA E8CCFC                  		call	SCANOFF
  9014                                  		; MSDOS 6.0
  9015                                  		;CMP	AL,[RABRACKET]	;AN040; was there no filename?
  9016                                  		;jz	short REIN_ERRSET ;AN040; yes - set up error
  9017                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9018 00001CAD 3C0D                    		cmp	al,0Dh
  9019 00001CAF 750B                    		jnz	short GOTREIFIL
  9020                                  REIN_ERRSET:				;AN040; set up for error
  9021 00001CB1 C6050D                  		mov	byte [di],0Dh		; Clobber "<"
  9022 00001CB4 C706[1C42]0900          		mov	word [RE_INSTR],9	; Cause an error later
  9023 00001CBA EB64                    		jmp	short PRESCANEND
  9024                                  GOTREIFIL:
  9025 00001CBC 57                      		push	di
  9026 00001CBD BF[1C42]                		mov	di,RE_INSTR
  9027 00001CC0 89FB                    		mov	bx,di
  9028 00001CC2 06                      		push	es
  9029 00001CC3 0E                      		push	cs
  9030 00001CC4 07                      		pop	es		; store in TRANGROUP
  9031 00001CC5 EBC2                    		jmp	short SETREOUTSTR_LOOP 
  9032                                  					; Get the input redirection name
  9033                                  CHKPIPE:
  9034 00001CC7 88C4                    		mov	ah,al
  9035                                  		;cmp	ah,'|'
  9036 00001CC9 80FC7C                  		cmp	ah,ALTPIPECHR
  9037 00001CCC 7406                    		je	short ISPIPE3
  9038 00001CCE 3A26[F13E]              		cmp	ah,[VBAR]
  9039 00001CD2 753F                    		jne	short CONTPRESCAN
  9040                                  ISPIPE3:
  9041                                  ; Only push the echo flag if we are entering the pipe for the first time.
  9042                                  
  9043 00001CD4 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  9044 00001CDA 7505                    		jne	short NOECHOPUSH
  9045 00001CDC 26D026ED0B              		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
  9046                                  NOECHOPUSH:
  9047 00001CE1 26FE065A0C              		inc	byte [es:PIPEFLAG]
  9048 00001CE6 E890FC                  		call	SCANOFF
  9049 00001CE9 3C0D                    		cmp	al,0Dh
  9050 00001CEB 740A                    		jz	short PIPEERRSYNJ5
  9051                                  		;cmp	al,'|'
  9052 00001CED 3C7C                    		cmp	al,ALTPIPECHR
  9053 00001CEF 7406                    		jz	short PIPEERRSYNJ5
  9054 00001CF1 3A06[F13E]              		cmp	al,[VBAR]	; Double '|'?	
  9055 00001CF5 751C                    		jnz	short CONTPRESCAN
  9056                                  
  9057                                  PIPEERRSYNJ5:
  9058 00001CF7 06                      		push	es
  9059 00001CF8 1F                      		pop	ds
  9060 00001CF9 E93A02                  		jmp	PIPEERRSYN
  9061                                  
  9062                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
  9063                                  ; than just a : in the redir string.
  9064                                  
  9065                                  GOTRESTR:
  9066 00001CFC 86E0                    		xchg	ah,al
  9067 00001CFE B03A                    		mov	al,':'
  9068 00001D00 29FB                    		sub	bx,di		; compute negative of number of chars
  9069 00001D02 83FBFF                  		cmp	bx,-1		; is there just a :?
  9070 00001D05 7407                    		je	short NOTRAILCOL ; yep, don't change
  9071 00001D07 263845FF                		cmp	[es:di-1],al	; Trailing ':' OK on devices
  9072 00001D0B 7501                    		jne	short NOTRAILCOL
  9073 00001D0D 4F                      		dec	di		; Back up over trailing ':'
  9074                                  NOTRAILCOL:
  9075 00001D0E 30C0                    		xor	al,al
  9076 00001D10 AA                      		stosb			; NUL terminate the string
  9077 00001D11 07                      		pop	es
  9078 00001D12 5F                      		pop	di		; Remember the start
  9079                                  CONTPRESCAN:
  9080 00001D13 8825                    		mov	[di],ah		; "delete" the redirection string
  9081 00001D15 47                      		inc	di
  9082 00001D16 80FC0D                  		cmp	ah,0Dh
  9083 00001D19 7405                    		je	short PRESCANEND
  9084 00001D1B FEC1                    		inc	cl
  9085 00001D1D E929FF                  		jmp	PRESCANLP
  9086                                  PRESCANEND:
  9087 00001D20 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  9088 00001D26 7414                    		je	short ISNOPIPE
  9089                                  		;MOV	DI,OFFSET RESGROUP:PIPESTR
  9090 00001D28 BF7E0C                  		mov	di,PIPESTR
  9091 00001D2B 26893E7C0C              		mov	word [es:PIPEPTR],di
  9092 00001D30 BE[D240]                		mov	si,COMBUF+2
  9093 00001D33 E843FC                  		call	SCANOFF
  9094                                  PIPESETLP:				; Transfer the pipe into the resident
  9095 00001D36 AC                      		lodsb			; pipe buffer
  9096 00001D37 AA                      		stosb
  9097 00001D38 3C0D                    		cmp	al,0Dh
  9098 00001D3A 75FA                    		jnz	short PIPESETLP
  9099                                  ISNOPIPE:
  9100 00001D3C 880E[D140]              		mov	[COMBUF+1],cl
  9101 00001D40 26803E5A0C00            		cmp	byte [es:PIPEFLAG],0
  9102 00001D46 0E                      		push	cs
  9103 00001D47 07                      		pop	es
  9104 00001D48 C3                      		retn
  9105                                  
  9106                                  ; =============== S U B	R O U T	I N E =======================================
  9107                                  
  9108                                  CMD_COPY:
  9109 00001D49 BE[D240]                		mov	si,COMBUF+2
  9110 00001D4C E82AFC                  		call	SCANOFF		; advance past separators...
  9111 00001D4F 0336[C043]              		add	si,[PATHPOS]
  9112 00001D53 BF8100                  		mov	di,81h
  9113 00001D56 31C9                    		xor	cx,cx
  9114                                  CMDCOPY:
  9115 00001D58 AC                      		lodsb
  9116 00001D59 AA                      		stosb
  9117 00001D5A 3C0D                    		cmp	al,0Dh
  9118 00001D5C 7403                    		je	short COPY_DONE
  9119 00001D5E 41                      		inc	cx
  9120 00001D5F EBF7                    		jmp	short CMDCOPY
  9121                                  COPY_DONE:
  9122 00001D61 880E8000                		mov	[80h],cl
  9123 00001D65 C3                      		retn
  9124                                  
  9125                                  ; =============== S U B	R O U T	I N E =======================================
  9126                                  
  9127                                  TEST_APPEND:
  9128 00001D66 BB[D040]                		mov	bx,COMBUF	; barry can address
  9129 00001D69 BE[EB42]                		mov	si,IDLEN	; address command name, DS already set 	
  9130 00001D6C BAFFFF                  		mov	dx,-1
  9131 00001D6F B800AE                  		mov	ax,0AE00h
  9132 00001D72 CD2F                    		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
  9133                                  				; - INSTALLABLE	COMMAND	- INSTALL CHECK
  9134                                  				; DX = FFFFh,[BX -> command line
  9135                                  				; Return: AL = FFh if this command is a TSR extension 
  9136                                  				;		   to COMMAND.COM
  9137                                  				; AL = 00h if the command should be executed as	usual
  9138 00001D74 3C00                    		cmp	al,0
  9139 00001D76 C3                      		retn
  9140                                  
  9141                                  ;============================================================================
  9142                                  ; TMISC2.ASM, MSDOS 6.0, 1991
  9143                                  ;============================================================================
  9144                                  ; 05/10/2018 - Retro DOS v3.0
  9145                                  
  9146                                  ;	More misc routines
  9147                                  
  9148                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
  9149                                  
  9150                                  ; =============== S U B	R O U T	I N E =======================================
  9151                                  
  9152                                  SETPATH:
  9153                                  
  9154                                  ; ENTRY PathPos = ptr to string
  9155                                  ;       PathCnt = length of string
  9156                                  ;
  9157                                  ; EXIT  PathPos = ptr to string after pathname
  9158                                  ;       PathCnt = length of rest of string
  9159                                  ;       DX = ptr to pathname in string, made ASCIIZ
  9160                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
  9161                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
  9162                                  ;
  9163                                  ;       A null character is dropped at the end of the pathname. If the
  9164                                  ;       character in that spot previously was CR, it is copied into the
  9165                                  ;       following byte. So there must be at least two two character 
  9166                                  ;       positions in the buffer following the pathname.
  9167                                  
  9168                                  		; MSDOS 6.0
  9169                                  		;mov	ax,[PATHCNT]	;AC000; get length of string
  9170                                  		;mov	si,[PATHPOS]	;AC000; get start of source buffer
  9171                                  
  9172                                  		; MSDOS 3.3
  9173 00001D77 BE8000                  		mov	si,80h
  9174 00001D7A AC                      		lodsb
  9175 00001D7B 30E4                    		xor	ah,ah
  9176 00001D7D A3[BE43]                		mov	[PATHCNT],ax
  9177 00001D80 8936[C043]              		mov	[PATHPOS],si
  9178                                  GETPATH:
  9179                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9180 00001D84 C606[7044]00            		mov	byte [DESTINFO],0
  9181 00001D89 C606[6C44]00            		mov	byte [DESTVARS],0
  9182 00001D8E 8B36[C043]              		mov	si,[PATHPOS]	; SI = ptr to string
  9183 00001D92 8B0E[BE43]              		mov	cx,[PATHCNT]	; CX = string length
  9184 00001D96 89F2                    		mov	dx,si		; DX = ptr to string
  9185 00001D98 E33D                    		jcxz	PATHDONE	; string length is zero, we're done
  9186 00001D9A 51                      		push	cx		; save string length
  9187 00001D9B 56                      		push	si		; save ptr to string
  9188 00001D9C E80BFD                  		call	SWITCH
  9189                                  
  9190                                  ;       After Switch, SI has been scanned past any switches, and
  9191                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
  9192                                  
  9193 00001D9F A3[C243]                		mov	[PATHSW],ax	; PathSw = switch occurrence mask
  9194 00001DA2 5B                      		pop	bx		; BX = ptr to original string
  9195 00001DA3 29F3                    		sub	bx,si		; BX = -(# chars scanned by Switch)
  9196 00001DA5 59                      		pop	cx		; CX = string length
  9197 00001DA6 01D9                    		add	cx,bx		; CX = string length from current SI
  9198 00001DA8 89F2                    		mov	dx,si		; DX = ptr to current string
  9199                                  SKIPPATH:
  9200 00001DAA E32B                    		jcxz	PATHDONE	; string length is zero, we're done
  9201 00001DAC 49                      		dec	cx		; CX = length left after next char
  9202 00001DAD AC                      		lodsb			; AL = next char of string
  9203                                  					; SI = ptr to char after this one
  9204 00001DAE E85BFC                  		call	PATHCHRCMP	; compare AL to path delimiter char
  9205 00001DB1 7504                    		jnz	short TESTPMETA	; it's not a path delim
  9206 00001DB3 FE06[6C44]              		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
  9207                                  TESTPMETA:
  9208 00001DB7 3C3F                    		cmp	al,'?'
  9209 00001DB9 7505                    		jne	short TESTPSTAR	; char is not '?'
  9210 00001DBB 800E[7044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9211                                  TESTPSTAR:
  9212                                  		;cmp	al,'*'
  9213 00001DC0 3A06[FD3E]              		cmp	al,[STAR]
  9214 00001DC4 7505                    		jne	short TESTPDELIM ; char is not '*'
  9215 00001DC6 800E[7044]02            		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
  9216                                  TESTPDELIM:
  9217 00001DCB E8B3FB                  		call	DELIM		; compare AL to all delimiters
  9218 00001DCE 7406                    		jz	short PATHDONEDEC ; delimiter found, back up & leave
  9219 00001DD0 3A06[7542]              		cmp	al,[SWITCHAR]
  9220 00001DD4 75D4                    		jne	short SKIPPATH	; char isn't switch, go get next char
  9221                                  PATHDONEDEC:
  9222 00001DD6 4E                      		dec	si		; SI = ptr to char after pathname
  9223                                  PATHDONE:
  9224 00001DD7 30C0                    		xor	al,al		; AL = NULL
  9225 00001DD9 8604                    		xchg	al,[si]		; place NULL after pathname
  9226 00001DDB 46                      		inc	si		; SI = ptr to byte after NULL
  9227 00001DDC 3C0D                    		cmp	al,0Dh		; were we at end of line?
  9228 00001DDE 7502                    		jne	short NOPSTORE	; not EOL, finish up
  9229 00001DE0 8804                    		mov	[si],al		; save EOL after NULL
  9230                                  NOPSTORE:
  9231 00001DE2 8936[C043]              		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
  9232 00001DE6 890E[BE43]              		mov	[PATHCNT],cx	; PathCnt = length of string left
  9233                                  SETPATH_RETN:
  9234 00001DEA C3                      		retn
  9235                                  
  9236                                  ; ---------------------------------------------------------------------------
  9237                                  
  9238                                  PGETARG:
  9239 00001DEB BE8000                  		mov	si,80h
  9240 00001DEE AC                      		lodsb
  9241 00001DEF 08C0                    		or	al,al
  9242 00001DF1 74F7                    		jz	short SETPATH_RETN
  9243 00001DF3 E80300                  		call	PSCANOFF
  9244 00001DF6 3C0D                    		cmp	al,0Dh
  9245 00001DF8 C3                      		retn
  9246                                  
  9247                                  ; ---------------------------------------------------------------------------
  9248                                  
  9249                                  PSCANOFF:
  9250 00001DF9 AC                      		lodsb
  9251 00001DFA E884FB                  		call	DELIM
  9252 00001DFD 7504                    		jnz	short PSCANOFFD
  9253 00001DFF 3C3B                    		cmp	al,';'
  9254 00001E01 75F6                    		jne	short PSCANOFF	; ';' is not a delimiter
  9255                                  PSCANOFFD:
  9256 00001E03 4E                      		dec	si		; Point to first non-delimiter
  9257 00001E04 C3                      		retn
  9258                                  
  9259                                  ; =============== S U B	R O U T	I N E =======================================
  9260                                  
  9261                                  IOSET:
  9262                                  		; ALL REGISTERS PRESERVED
  9263 00001E05 1E                      		push	ds
  9264 00001E06 52                      		push	dx
  9265 00001E07 50                      		push	ax
  9266 00001E08 53                      		push	bx
  9267 00001E09 51                      		push	cx
  9268 00001E0A 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9269 00001E0F 803E5A0C00              		cmp	byte [PIPEFLAG],0
  9270 00001E14 750D                    		jne	short NOREDIR
  9271 00001E16 F606F80BFF              		test	byte [IFFLAG],0FFh
  9272 00001E1B 7506                    		jnz	short NOREDIR
  9273 00001E1D E80900                  		call	TESTDOREIN
  9274 00001E20 E85400                  		call	TESTDOREOUT
  9275                                  NOREDIR:
  9276 00001E23 59                      		pop	cx
  9277 00001E24 5B                      		pop	bx
  9278 00001E25 58                      		pop	ax
  9279 00001E26 5A                      		pop	dx
  9280 00001E27 1F                      		pop	ds
  9281                                  IOSET_RETN:
  9282 00001E28 C3                      		retn
  9283                                  
  9284                                  ; =============== S U B	R O U T	I N E =======================================
  9285                                  
  9286                                  TESTDOREIN:
  9287 00001E29 2E803E[1C42]00          		cmp	byte [cs:RE_INSTR],0
  9288 00001E2F 74F7                    		jz	short IOSET_RETN
  9289 00001E31 1E                      		push	ds
  9290 00001E32 0E                      		push	cs
  9291 00001E33 1F                      		pop	ds
  9292 00001E34 BA[1C42]                		mov	dx,RE_INSTR
  9293 00001E37 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9294 00001E3A 89C3                    		mov	bx,ax
  9295 00001E3C CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9296                                  				; DS:DX	-> ASCIZ filename
  9297                                  				; AL = access mode
  9298                                  				; 0 - read
  9299 00001E3E 1F                      		pop	ds
  9300 00001E3F 720B                    		jb	short REDIRERR
  9301 00001E41 89C3                    		mov	bx,ax
  9302 00001E43 B0FF                    		mov	al,0FFh
  9303                                  
  9304                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
  9305                                  ; spot. We invalidate the new JFN we got.
  9306                                  
  9307                                  		;xchg	al,[bx+18h]
  9308 00001E45 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9309 00001E48 A21800                  		mov	byte [PDB.JFN_TABLE],al
  9310 00001E4B C3                      		retn
  9311                                  
  9312                                  ; ---------------------------------------------------------------------------
  9313                                  
  9314                                  ; We had some kind of error on the redirection. Figure out what the
  9315                                  ; appropriate message should be; BX has the system call that failed
  9316                                  
  9317                                  REDIRERR:
  9318 00001E4C 0E                      		push	cs
  9319 00001E4D 1F                      		pop	ds
  9320                                  		;call	TriageError
  9321 00001E4E E87900                  		call	GET_EXT_ERR_NUMBER
  9322                                  
  9323                                  ; At this point, we have recognized the network-generated access denied error.
  9324                                  ; The correct message is in DX
  9325                                  
  9326 00001E51 83F841                  		cmp	ax,65
  9327 00001E54 7408                    		jz	short _CERRORJ	;AC000; just issue message returned
  9328 00001E56 80FF3D                  		cmp	bh,OPEN ; 3Dh
  9329 00001E59 7406                    		jz	short OPENERR
  9330 00001E5B BA[6E38]                		mov	dx,FULDIRPTR
  9331                                  _CERRORJ:
  9332 00001E5E E9C8FD                  		jmp	CERROR
  9333                                  
  9334                                  OPENERR:
  9335                                  ; The system call was an OPEN. Report either file not found or path not found.
  9336                                  
  9337                                  		; MSDOS 6.0
  9338                                  		;mov	msg_disp_class,ext_msg_class 
  9339                                  		;			;AN000; set up extended error msg class
  9340                                  		;mov	dx,offset TranGroup:Extend_Buf_ptr 
  9341                                  		;			;AC000; get extended message pointer
  9342                                  		;mov	Extend_Buf_ptr,ax	
  9343                                  		;			;AN000; get message number in control block
  9344                                  		;JMP	CERROR
  9345                                  
  9346                                  		; MSDOS 3.3
  9347 00001E61 BA[F837]                		mov	dx,FNOTFOUNDPTR
  9348                                  		;cmp	ax,2
  9349 00001E64 83F802                  		cmp	ax,ERROR_FILE_NOT_FOUND
  9350 00001E67 74F5                    		je	short _CERRORJ
  9351 00001E69 BA[1D38]                		mov	dx,ACCDENPTR
  9352                                  		;cmp	ax,5 ; Access denied error
  9353 00001E6C 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9354 00001E6F 74ED                    		je	short _CERRORJ
  9355                                  			; ERROR_PATH_NOT_FOUND
  9356 00001E71 BA[0B38]                		mov	dx,PNOTFOUNDPTR
  9357 00001E74 E9B2FD                  		jmp	CERROR
  9358                                  
  9359                                  ; =============== S U B	R O U T	I N E =======================================
  9360                                  
  9361                                  TESTDOREOUT:
  9362 00001E77 803E090C00              		cmp	byte [RE_OUTSTR],0
  9363 00001E7C 743D                    		je	short NOREOUT
  9364                                  
  9365                                  REOUTEXISTS:
  9366 00001E7E 803E080C00              		cmp	byte [RE_OUT_APP],0
  9367 00001E83 741F                    		je	short REOUTCRT
  9368                                  
  9369 00001E85 BA090C                  		mov	dx,RE_OUTSTR
  9370                                  
  9371                                  		; MSDOS 6.0
  9372                                  		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
  9373                                  		;mov	ax,3D02h
  9374                                  
  9375                                  		; MSDOS 3.3
  9376 00001E88 B8013D                  		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
  9377                                  	
  9378                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9379 00001E8B 50                      		push	ax
  9380 00001E8C CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9381                                  				; DS:DX	-> ASCIZ filename
  9382                                  				; AL = access mode
  9383                                  				; 1 - write
  9384 00001E8E 5B                      		pop	bx
  9385 00001E8F 720D                    		jc	short OPENWRITEERROR
  9386                                  
  9387                                  		; MSDOS 6.0
  9388                                  		;MOV	BX,AX
  9389                                  		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
  9390                                  		;INT	21h			;AN035;
  9391                                  		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
  9392                                  		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
  9393                                  		;
  9394                                  		;MOV	AX,(LSEEK SHL 8) OR 2
  9395                                  		;MOV	CX,-1			;AC011; MOVE TO EOF -1
  9396                                  		;MOV	DX,CX			;AC011;
  9397                                  		;INT	21h
  9398                                  		;PUSH	CS			;AN011; Get transient seg to DS
  9399                                  		;POP	DS			;AN011;
  9400                                  		;assume	DS:Trangroup		;AN011;
  9401                                  		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
  9402                                  		;MOV	CX,1			;AN011;   file into one_char_val
  9403                                  		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
  9404                                  		;INT	21h			;AN011;
  9405                                  		;JC	OpenWriteError		;AN011; If error, exit
  9406                                  		;cmp	ax,cx			;AN017; Did we read 1 byte?
  9407                                  		;jnz	reout_0_length		;AN017; No - file must be 0 length
  9408                                  		;
  9409                                  		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
  9410                                  		;mov	DS,[resseg]		;AN011; Get resident segment back
  9411                                  		;assume	DS:Resgroup		;AN011;
  9412                                  		;JNZ	SET_REOUT		;AN011; No, just continue
  9413                                  		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
  9414                                  		;MOV	CX,-1			;AN011; LSEEK back one byte
  9415                                  		;MOV	DX,CX			;AN011;
  9416                                  		;INT	21h			;AN011;
  9417                                  		;JMP	SHORT SET_REOUT
  9418                                  ;reout_0_length: 				;AN017; We have a 0 length file
  9419                                  		;mov	DS,[resseg]		;AN017; Get resident segment back
  9420                                  		;assume	DS:Resgroup		;AN017;
  9421                                  		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
  9422                                  		;XOR	CX,CX			;AN017; Offset is 0
  9423                                  		;MOV	DX,CX			;AN017;
  9424                                  		;INT	21h			;AN017;
  9425                                  		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection
  9426                                  
  9427                                  		; MSDOS 3.3
  9428 00001E91 31D2                    		xor	dx,dx
  9429 00001E93 31C9                    		xor	cx,cx
  9430 00001E95 89C3                    		mov	bx,ax
  9431 00001E97 B80242                  		mov	ax,(LSEEK<<8)|2 ; 4202h
  9432 00001E9A CD21                    		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
  9433                                  				; AL = method: offset from end of file
  9434 00001E9C EB15                    		jmp	short SET_REOUT
  9435                                  		
  9436                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9437                                  OPENWRITEERROR:	
  9438                                  		;cmp	ax,5
  9439 00001E9E 83F805                  		cmp	ax,ERROR_ACCESS_DENIED
  9440 00001EA1 F9                      		stc
  9441 00001EA2 74A8                    		je	short REDIRERR
  9442                                  REOUTCRT:	
  9443 00001EA4 BA090C                  		mov	dx,RE_OUTSTR
  9444 00001EA7 31C9                    		xor	cx,cx
  9445 00001EA9 B43C                    		mov	ah,CREAT ; 3Ch
  9446 00001EAB 50                      		push	ax
  9447 00001EAC CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9448                                  				; CX = attributes for file
  9449                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9450 00001EAE 5B                      		pop	bx
  9451 00001EAF 729B                    		jc	short REDIRERR
  9452                                  NOREDIRERR:
  9453 00001EB1 89C3                    		mov	bx,ax
  9454                                  SET_REOUT:
  9455                                  
  9456                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
  9457                                  ; spot. We invalidate the new JFN we got.
  9458                                  
  9459 00001EB3 B0FF                    		mov	al,0FFh
  9460                                  		;xchg	al,[bx+18h]
  9461 00001EB5 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9462 00001EB8 A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9463                                  NOREOUT:
  9464 00001EBB C3                      		retn
  9465                                  
  9466                                  ; =============== S U B	R O U T	I N E =======================================
  9467                                  
  9468                                  ; Compute length of string (including NUL) in DS:SI into CX.  Change no other
  9469                                  ; registers
  9470                                  
  9471                                  DSTRLEN:
  9472 00001EBC 50                      		push	ax
  9473 00001EBD 31C9                    		xor	cx,cx
  9474 00001EBF FC                      		cld
  9475                                  DLOOP:
  9476 00001EC0 AC                      		lodsb
  9477 00001EC1 41                      		inc	cx
  9478 00001EC2 08C0                    		or	al,al
  9479 00001EC4 75FA                    		jnz	short DLOOP
  9480 00001EC6 29CE                    		sub	si,cx
  9481 00001EC8 58                      		pop	ax
  9482                                  TRIAGEERR_RETN:
  9483 00001EC9 C3                      		retn
  9484                                  
  9485                                  ; =============== S U B	R O U T	I N E =======================================
  9486                                  
  9487                                  ;Break	<Extended error support>
  9488                                  
  9489                                  TriageError:  ; MSDOS 6.0
  9490                                  
  9491                                  ;
  9492                                  ; TriageError will examine the return from a carry-set system call and
  9493                                  ; return the correct error if applicable.
  9494                                  ;
  9495                                  ;   Inputs:	outputs from a carry-settable system call
  9496                                  ;		No system calls may be done in the interrim
  9497                                  ;   Outputs:	If carry was set on input
  9498                                  ;		    carry set on output
  9499                                  ;		    DX contains trangroup offset to printf message
  9500                                  ;		else
  9501                                  ;		    No registers changed
  9502                                  ;
  9503                                  
  9504                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
  9505                                  
  9506                                  GET_EXT_ERR_NUMBER:
  9507 00001ECA 73FD                    		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
  9508 00001ECC 9C                      		pushf
  9509 00001ECD 53                      		push	bx
  9510 00001ECE 51                      		push	cx
  9511 00001ECF 56                      		push	si
  9512 00001ED0 57                      		push	di
  9513 00001ED1 55                      		push	bp
  9514 00001ED2 06                      		push	es
  9515 00001ED3 1E                      		push	ds
  9516 00001ED4 50                      		push	ax
  9517 00001ED5 52                      		push	dx
  9518                                  		;mov	ah,59h
  9519 00001ED6 B459                    		mov	ah,GETEXTENDEDERROR
  9520 00001ED8 CD21                    		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
  9521                                  				; BX = version code (0000h for DOS 3.x)
  9522 00001EDA 59                      		pop	cx
  9523 00001EDB 5B                      		pop	bx		; restore original AX
  9524 00001EDC BA[1D38]                		mov	dx,ACCDENPTR
  9525 00001EDF 83F841                  		cmp	ax,65		; network access denied?
  9526 00001EE2 7404                    		je	short NOMOVE	; Yes, return it.
  9527 00001EE4 89D8                    		mov	ax,bx
  9528 00001EE6 89CA                    		mov	dx,cx
  9529                                  NOMOVE:
  9530 00001EE8 1F                      		pop	ds
  9531 00001EE9 07                      		pop	es
  9532 00001EEA 5D                      		pop	bp
  9533 00001EEB 5F                      		pop	di
  9534 00001EEC 5E                      		pop	si
  9535 00001EED 59                      		pop	cx
  9536 00001EEE 5B                      		pop	bx
  9537 00001EEF 9D                      		popf
  9538 00001EF0 C3                      		retn
  9539                                  
  9540                                  ; =============== S U B	R O U T	I N E =======================================
  9541                                  
  9542                                  		; Far call from resident portion/segment of COMMAND.COM
  9543                                  
  9544                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
  9545                                  
  9546                                  TRIAGE_INIT:
  9547                                  		;call	TriageError
  9548 00001EF1 E8D6FF                  		call	GET_EXT_ERR_NUMBER
  9549 00001EF4 CB                      		retf
  9550                                  
  9551                                  ;============================================================================
  9552                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (1)
  9553                                  ;============================================================================
  9554                                  ; 03/10/2018 - Retro DOS v3.0
  9555                                  
  9556                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
  9557                                  
  9558                                  ; =============== S U B	R O U T	I N E =======================================
  9559                                  
  9560                                  SINGLETEST:
  9561 00001EF5 1E                      		push	ds
  9562 00001EF6 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9563 00001EFB 833EF30B00              		cmp	word [SINGLECOM],0
  9564 00001F00 7406                    		jz	short TESTDONE
  9565 00001F02 813EF30BFFEF            		cmp	word [SINGLECOM],0EFFFh
  9566                                  TESTDONE:
  9567 00001F08 1F                      		pop	ds
  9568 00001F09 C3                      		retn
  9569                                  
  9570                                  ; =============== S U B	R O U T	I N E =======================================
  9571                                  
  9572                                  SETREST1:
  9573 00001F0A B001                    		mov	al,1
  9574                                  
  9575                                  ; ---------------------------------------------------------------------------
  9576                                  
  9577                                  SETREST:
  9578 00001F0C 1E                      		push	ds
  9579 00001F0D 8E1E[7142]              		mov	ds,[RESSEG]
  9580 00001F11 A2F10B                  		mov	byte [RESTDIR],al
  9581 00001F14 1F                      		pop	ds
  9582 00001F15 C3                      		retn
  9583                                  
  9584                                  ; =============== S U B	R O U T	I N E =======================================
  9585                                  
  9586                                  ; Note that we need to handle the same thing that RestDir handles: the
  9587                                  ; requirement that we try only once to restore the user's environment after
  9588                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
  9589                                  ; disappear, we just give up.
  9590                                  
  9591                                  PIPEDEL:
  9592 00001F16 1E                      		push	ds
  9593 00001F17 52                      		push	dx
  9594 00001F18 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
  9595 00001F1D BA5C0C                  		mov	dx,PIPE1	; Clean up in case ^C
  9596 00001F20 B441                    		mov	ah,UNLINK ; 41h 
  9597 00001F22 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9598                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9599                                  				;		(no wildcards allowed)
  9600 00001F24 BA6C0C                  		mov	dx,PIPE2
  9601 00001F27 B441                    		mov	ah,UNLINK ; 41h
  9602 00001F29 CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
  9603                                  				; DS:DX	-> ASCIZ pathname of file to delete 
  9604                                  				;		(no wildcards allowed)
  9605 00001F2B 5A                      		pop	dx
  9606 00001F2C E85D04                  		call	PIPEOFF
  9607 00001F2F C6065B0C00              		mov	byte [PIPEFILES],0
  9608 00001F34 1F                      		pop	ds
  9609 00001F35 C3                      		retn
  9610                                  
  9611                                  ; ---------------------------------------------------------------------------
  9612                                  
  9613                                  PIPEERRSYN:
  9614 00001F36 BA[783C]                		mov	dx,SYNTMESPTR
  9615 00001F39 E8DAFF                  		call	PIPEDEL
  9616 00001F3C 0E                      		push	cs
  9617 00001F3D 1F                      		pop	ds
  9618 00001F3E E9E8FC                  		jmp	CERROR
  9619                                  
  9620                                  ; ---------------------------------------------------------------------------
  9621                                  
  9622                                  PIPERR:
  9623 00001F41 9C                      		pushf
  9624                                  		;invoke	TRIAGEERROR
  9625 00001F42 E885FF                  		call	GET_EXT_ERR_NUMBER
  9626 00001F45 50                      		push	ax		; Save results from TriageError
  9627 00001F46 52                      		push	dx
  9628 00001F47 BA[D23C]                		mov	dx,PIPEEMESPTR
  9629 00001F4A E8C9FF                  		call	PIPEDEL
  9630 00001F4D 0E                      		push	cs
  9631 00001F4E 1F                      		pop	ds
  9632 00001F4F E87815                  		call	STD_EPRINTF
  9633 00001F52 5A                      		pop	dx		; Restore results from TriageError
  9634 00001F53 58                      		pop	ax
  9635 00001F54 9D                      		popf
  9636 00001F55 83F841                  		cmp	ax,65
  9637 00001F58 7503                    		jnz	short TCOMMANDJ
  9638 00001F5A E9CCFC                  		jmp	CERROR
  9639                                  
  9640                                  TCOMMANDJ:
  9641 00001F5D E9A4E1                  		jmp	TCOMMAND
  9642                                  
  9643                                  PIPEPROCSTRT:
  9644 00001F60 8E1E[7142]              		mov	ds,[RESSEG]
  9645 00001F64 FE065B0C                		inc	byte [PIPEFILES] ; Flag that the pipe files exist
  9646                                  
  9647                                  		; MSDOS 6.0
  9648                                  		;push	es
  9649                                  		;push	di
  9650                                  		;push	ds
  9651                                  		;push	si
  9652                                  		;
  9653                                  		;push	ds
  9654                                  		;push	es
  9655                                  		;pop	ds				;ds = TRANGROUP
  9656                                  		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
  9657                                  ;
  9658                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
  9659                                  ;so the routine is not really general
  9660                                  ;
  9661                                  		;call	Find_Name_In_Environment	;es:di points at path
  9662                                  		;pop	ds				;ds = DATARES again
  9663                                  		;jc	no_temp_path
  9664                                  		;
  9665                                  		;push	ds
  9666                                  		;push	es
  9667                                  		;pop	ds
  9668                                  		;pop	es				;swap ds and es
  9669                                  		;mov	si,di				;ds:si points at path
  9670                                  		;
  9671                                  		;call	skip_white			;skip white space chars
  9672                                  ;
  9673                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
  9674                                  ;
  9675                                  		;call	copy_pipe_path			;copy the pipe path
  9676                                  		;
  9677                                  ;
  9678                                  ;Check if the TEMP path is valid
  9679                                  ;
  9680                                  		;push	es
  9681                                  		;pop	ds				;ds = DATARES
  9682                                  		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
  9683                                  		;mov	ax, (CHMOD shl 8) or 0
  9684                                  		;int	21h
  9685                                  		;jc	no_temp_path
  9686                                  		;
  9687                                  		;test	cx,10h				;is it a directory?
  9688                                  		;jnz	no_temp_path			;yes, continue (carry clear)
  9689                                  		;
  9690                                  		;stc					;no, indicate fail
  9691                                  no_temp_path:
  9692                                  		;pop	si
  9693                                  		;pop	ds
  9694                                  		;pop	di
  9695                                  		;pop	es
  9696                                  		;jnc	crt_temp			;path found, create tempfiles
  9697                                  
  9698                                  		; MSDOS 3.3
  9699 00001F68 B419                    		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
  9700 00001F6A CD21                    		int	21h ; DOS - GET DEFAULT DISK NUMBER
  9701 00001F6C 2E0206[F03E]            		add	al,[cs:CAPITAL_A]
  9702 00001F71 A26C0C                  		mov	byte [PIPE2],al		; Make pipe files in root of def drv
  9703 00001F74 BB5C0C                  		mov	bx,PIPE1
  9704 00001F77 8807                    		mov	[bx],al
  9705 00001F79 30E4                    		xor	ah,ah			; nul terminate path names
  9706 00001F7B 88265F0C                		mov	byte [PIPE1+3],ah
  9707 00001F7F 88266F0C                		mov	byte [PIPE2+3],ah
  9708                                  
  9709                                  		; MSDOS 6.0
  9710                                  ;SR;
  9711                                  ; We want to create temp files in the current directory rather than in the 
  9712                                  ;root of the drive. This is because the number of files that can be present
  9713                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
  9714                                  ;
  9715                                  		;mov	ah,'.'
  9716                                  		;mov	Pipe1,ah
  9717                                  		;mov	Pipe2,ah
  9718                                  		;xor	ah,ah
  9719                                  		;mov	Pipe1+1,ah
  9720                                  		;mov	Pipe2+1,ah		;create files in current dir
  9721                                  
  9722                                  ;crt_temp:
  9723                                  		; MSDOS 6.0
  9724                                  		;mov	dx,offset DATARES:Pipe1
  9725                                  		;mov	dx,PIPE1
  9726                                  	
  9727                                  		; MSDOS 3.3 (& MSDOS 6.0)
  9728 00001F83 89DA                    		mov	dx,bx
  9729 00001F85 31C9                    		xor	cx,cx
  9730 00001F87 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9731 00001F89 CD21                    		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
  9732                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9733                                  			; receive generated filename
  9734                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9735 00001F8B 72B4                    		jc	short PIPERR	; Couldn't create
  9736 00001F8D 89C3                    		mov	bx,ax
  9737 00001F8F B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9738 00001F91 CD21                    		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9739                                  				; BX = file handle
  9740 00001F93 BA6C0C                  		mov	dx,PIPE2
  9741 00001F96 B45A                    		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
  9742 00001F98 CD21                    		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
  9743                                  			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
  9744                                  			; receive generated filename
  9745                                  			; CX = file attributes (only bits 0,1,2,5 may be set)
  9746 00001F9A 72A5                    		jc	short PIPERR
  9747 00001F9C 89C3                    		mov	bx,ax
  9748 00001F9E B43E                    		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
  9749 00001FA0 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
  9750                                  					; BX = file handle
  9751                                  		;call	near ptr TESTDOREIN ; Set up a redirection if specified
  9752 00001FA2 E884FE                  		call	TESTDOREIN
  9753 00001FA5 8B367C0C                		mov	si,word [PIPEPTR]
  9754 00001FA9 833EF30BFF              		cmp	word [SINGLECOM],-1
  9755 00001FAE 7506                    		jne	short NOSINGP
  9756 00001FB0 C706F30B00F0            		mov	word [SINGLECOM],0F000h ; Flag single command pipe
  9757                                  NOSINGP:
  9758 00001FB6 EB30                    		jmp	short FIRSTPIPE
  9759                                  
  9760                                  ; ---------------------------------------------------------------------------
  9761                                  
  9762                                  PIPEPROC:
  9763 00001FB8 8026ED0BFE              		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
  9764 00001FBD 8B367C0C                		mov	si,word [PIPEPTR]
  9765 00001FC1 AC                      		lodsb
  9766                                  		;cmp	al,'|'		
  9767 00001FC2 3C7C                    		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
  9768 00001FC4 740A                    		je	short ISPIPE1	; Yes
  9769 00001FC6 2E3A06[F13E]            		cmp	al,[cs:VBAR]
  9770 00001FCB 7403                    		je	short ISPIPE1
  9771 00001FCD E98900                  		jmp	PIPEEND		; Pipe done
  9772                                  ISPIPE1:
  9773 00001FD0 8B16FF0C                		mov	dx,word [INPIPEPTR] ; Get the input file name
  9774 00001FD4 B8003D                  		mov	ax,OPEN*256 ; 3D00h
  9775 00001FD7 CD21                    		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
  9776                                  				; DS:DX	-> ASCIZ filename
  9777                                  				; AL = access mode
  9778                                  				; 0 - read
  9779                                  PIPEERRJ:
  9780 00001FD9 7303                    		jnc	short NO_PIPEERR
  9781 00001FDB E963FF                  		jmp	PIPERR		; Lost the pipe file
  9782                                  NO_PIPEERR:
  9783 00001FDE 89C3                    		mov	bx,ax
  9784 00001FE0 B0FF                    		mov	al,0FFh
  9785                                  		;xchg	al,[bx+18h]
  9786 00001FE2 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9787 00001FE5 A21800                  		mov	byte [PDB.JFN_TABLE],al	; Redirect
  9788                                  FIRSTPIPE:
  9789 00001FE8 BF[D240]                		mov	di,COMBUF+2
  9790 00001FEB 31C9                    		xor	cx,cx
  9791 00001FED 803C0D                  		cmp	byte [si],0Dh	; '|<CR>'
  9792 00001FF0 7503                    		jne	short PIPEOK1
  9793                                  PIPEERRSYNJ:
  9794 00001FF2 E941FF                  		jmp	PIPEERRSYN
  9795                                  PIPEOK1:
  9796 00001FF5 2EA0[F13E]              		mov	al,[cs:VBAR]
  9797 00001FF9 3804                    		cmp	[si],al		; '||'
  9798 00001FFB 74F5                    		je	short PIPEERRSYNJ
  9799                                  		;cmp	byte [si],'|'
  9800 00001FFD 803C7C                  		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
  9801 00002000 74F0                    		je	short PIPEERRSYNJ
  9802                                  PIPECOMLP:
  9803 00002002 AC                      		lodsb
  9804 00002003 AA                      		stosb
  9805 00002004 3C0D                    		cmp	al,0Dh
  9806 00002006 743F                    		je	short LASTPIPE
  9807 00002008 41                      		inc	cx
  9808                                  		;cmp	al,'|'
  9809 00002009 3C7C                    		cmp	al,ALTPIPECHR
  9810 0000200B 7407                    		je	short ISPIPE2
  9811 0000200D 2E3A06[F13E]            		cmp	al,[cs:VBAR]
  9812 00002012 75EE                    		jne	short PIPECOMLP
  9813                                  ISPIPE2:
  9814 00002014 26C645FF0D              		mov	byte [es:di-1],0Dh
  9815 00002019 49                      		dec	cx
  9816 0000201A 2E880E[D140]            		mov	[cs:COMBUF+1],cl
  9817 0000201F 4E                      		dec	si
  9818 00002020 89367C0C                		mov	word [PIPEPTR],si	; On to next pipe element
  9819 00002024 8B16010D                		mov	dx,word [OUTPIPEPTR]
  9820 00002028 51                      		push	cx
  9821 00002029 31C9                    		xor	cx,cx
  9822 0000202B B8003C                  		mov	ax,CREAT*256 ; 3C00h
  9823 0000202E CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
  9824                                  				; CX = attributes for file
  9825                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
  9826 00002030 59                      		pop	cx
  9827 00002031 72A6                    		jc	short PIPEERRJ		; Lost the file
  9828 00002033 89C3                    		mov	bx,ax
  9829 00002035 B0FF                    		mov	al,0FFh
  9830                                  		;xchg	al,[bx+18h]
  9831 00002037 864718                  		xchg	al,[bx+PDB.JFN_TABLE]
  9832 0000203A A21900                  		mov	byte [PDB.JFN_TABLE+1],al
  9833 0000203D 8716FF0C                		xchg	dx,word [INPIPEPTR]	; Swap for next element of pipe
  9834 00002041 8916010D                		mov	word [OUTPIPEPTR],dx
  9835 00002045 EB0D                    		jmp	short PIPECOM
  9836                                  LASTPIPE:
  9837 00002047 2E880E[D140]            		mov	[cs:COMBUF+1],cl 
  9838 0000204C 4E                      		dec	si
  9839 0000204D 89367C0C                		mov	word [PIPEPTR],si ; Point at the CR (anything not '|' will do)
  9840 00002051 E823FE                  		call	TESTDOREOUT	; Set up the redirection if specified
  9841                                  PIPECOM:
  9842 00002054 0E                      		push	cs
  9843 00002055 1F                      		pop	ds
  9844 00002056 E95FE2                  		jmp	NOPIPEPROC	; Process the pipe element
  9845                                  PIPEEND:
  9846 00002059 E8BAFE                  		call	PIPEDEL
  9847 0000205C 813EF30B00F0            		cmp	word [SINGLECOM],0F000h
  9848 00002062 7506                    		jnz	short NOSINGP2
  9849 00002064 C706F30BFFFF            		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
  9850                                  NOSINGP2:
  9851 0000206A E997E0                  		jmp	TCOMMAND
  9852                                  
  9853                                  ; =============== S U B	R O U T	I N E =======================================
  9854                                  
  9855                                  ; Date and time are set during initialization and use
  9856                                  ; this routines since they need to do a long return
  9857                                  
  9858                                  DATINIT:
  9859 0000206D 2E8C1E[7142]            		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
  9860 00002072 06                      		push	es
  9861 00002073 1E                      		push	ds		; Going to use the previous stack
  9862 00002074 8CC8                    		mov	ax,cs		; Set up the appropriate segment registers
  9863 00002076 8EC0                    		mov	es,ax
  9864 00002078 8ED8                    		mov	ds,ax
  9865                                  		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
  9866 0000207A BA[F84C]                		mov	dx,INTERNATVARS
  9867 0000207D B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h
  9868 00002080 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9869                                  				; get current-country info
  9870                                  				; DS:DX	-> buffer for returned info
  9871                                  		; 20/10/2018
  9872 00002082 C70681000D00            		mov	word [81H],0Dh ; Want to prompt for date during initialization
  9873 00002088 C606[D040]80            		mov	byte [COMBUF],128 ; Init COMBUF
  9874 0000208D C706[D140]010D          		mov	word [COMBUF+1],0D01h
  9875 00002093 E86C00                  		call	DATE
  9876 00002096 E88001                  		call	CTIME
  9877 00002099 1F                      		pop	ds
  9878 0000209A 07                      		pop	es
  9879 0000209B CB                      		retf
  9880                                  
  9881                                  ; =============== S U B	R O U T	I N E =======================================
  9882                                  
  9883                                  ; MSDOS 6.0
  9884                                  
  9885                                  ; ****************************************************************
  9886                                  ; *
  9887                                  ; * ROUTINE:	 DATE - Set system date
  9888                                  ; *
  9889                                  ; * FUNCTION:	 If a date is specified, set the system date,
  9890                                  ; *		 otherwise display the current system date and
  9891                                  ; *		 prompt the user for a new date.  If an invalid
  9892                                  ; *		 date is specified, issue an error message and
  9893                                  ; *		 prompt for a new date.  If the user enters
  9894                                  ; *		 nothing when prompted for a date, terminate.
  9895                                  ; *
  9896                                  ; * INPUT:	 command line at offset 81H
  9897                                  ; *
  9898                                  ; * OUTPUT:	 none
  9899                                  ; *
  9900                                  ; ****************************************************************
  9901                                  
  9902                                  ;assume	ds:trangroup,es:trangroup
  9903                                  ;
  9904                                  ;DATE:
  9905                                  ;	MOV	SI,81H				; Accepting argument for date inline
  9906                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
  9907                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9908                                  ;	xor	dx,dx				;AN000;
  9909                                  ;	invoke	cmd_parse			;AC000; call parser
  9910                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9911                                  ;	JZ	PRMTDAT 			;AC000; yes - go ask for date
  9912                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9913                                  ;	jne	daterr				;AN000; yes - go issue message
  9914                                  ;	JMP	short COMDAT			;AC000; we have a date
  9915                                  ;
  9916                                  ;PRMTDAT:
  9917                                  ;	; Print "Current date is
  9918                                  ;
  9919                                  ;	invoke	GetDate 			;AN000; get date  for output
  9920                                  ;	xchg	dh,dl				;AN000; switch month & day
  9921                                  ;	mov	CurDat_yr,cx			;AC000; put year into message control block
  9922                                  ;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
  9923                                  ;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
  9924                                  ;	invoke	std_printf
  9925                                  ;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
  9926                                  ;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
  9927                                  ;
  9928                                  ;GET_NEW_DATE:					;AN000;
  9929                                  ;	call	getdat				;AC000; prompt user for date
  9930                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9931                                  ;	jz	date_end			;AC000; yes - exit
  9932                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9933                                  ;	jne	daterr				;AN000; yes - go issue message
  9934                                  ;COMDAT:
  9935                                  ;	mov	cx,date_year			;AC000; get parts of date in
  9936                                  ;	mov	dh,date_month			;AC000;    cx and dx for set
  9937                                  ;	mov	dl,date_day			;AC000;    date function call.
  9938                                  ;	push	cx				;AC000; save date
  9939                                  ;	push	dx				;AC000;
  9940                                  ;	mov	cx,1				;AC000; set 1 positional entered
  9941                                  ;	xor	dx,dx				;AN029;
  9942                                  ;	invoke	cmd_parse			;AN029; call parser
  9943                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
  9944                                  ;	pop	dx				;AC000; retrieve date
  9945                                  ;	pop	cx				;AC000;
  9946                                  ;	jnz	daterr				;AC000; extra stuff on line - try again
  9947                                  ;	MOV	AH,SET_DATE			;yes - set date
  9948                                  ;	INT	21h
  9949                                  ;	OR	AL,AL
  9950                                  ;	JNZ	DATERR
  9951                                  ;date_end:
  9952                                  ;	ret
  9953                                  ;
  9954                                  ;DATERR:
  9955                                  ;	invoke	crlf2				;AN028; print out a blank line
  9956                                  ;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
  9957                                  ;	invoke	std_printf
  9958                                  ;	JMP	GET_NEW_DATE			;AC000; get date again
  9959                                  
  9960                                  ; =============== S U B	R O U T	I N E =======================================
  9961                                  
  9962                                  ; MSDOS 6.0
  9963                                  
  9964                                  ; TIME gets and sets the time
  9965                                  
  9966                                  ; ****************************************************************
  9967                                  ; *
  9968                                  ; * ROUTINE:	 TIME - Set system time
  9969                                  ; *
  9970                                  ; * FUNCTION:	 If a time is specified, set the system time,
  9971                                  ; *		 otherwise display the current system time and
  9972                                  ; *		 prompt the user for a new time.  If an invalid
  9973                                  ; *		 time is specified, issue an error message and
  9974                                  ; *		 prompt for a new time.  If the user enters
  9975                                  ; *		 nothing when prompted for a time, terminate.
  9976                                  ; *
  9977                                  ; * INPUT:	 command line at offset 81H
  9978                                  ; *
  9979                                  ; * OUTPUT:	 none
  9980                                  ; *
  9981                                  ; ****************************************************************
  9982                                  
  9983                                  ;assume	ds:trangroup,es:trangroup
  9984                                  ;
  9985                                  ;CTIME:
  9986                                  ;	MOV	SI,81H				; Accepting argument for time inline
  9987                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
  9988                                  ;	xor	cx,cx				;AN000; clear counter for positionals
  9989                                  ;	xor	dx,dx				;AN000;
  9990                                  ;	invoke	cmd_parse			;AC000; call parser
  9991                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
  9992                                  ;	JZ	PRMTTIM 			;AC000; yes - prompt for time
  9993                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
  9994                                  ;	jne	timerr				;AN000; yes - go issue message
  9995                                  ;	JMP	short COMTIM			;AC000; we have a time
  9996                                  ;
  9997                                  ;PRMTTIM:
  9998                                  ;	;Printf "Current time is ... "
  9999                                  ;
 10000                                  ;	MOV	AH,GET_TIME			;AC000; get the current time
 10001                                  ;	INT	21h				;AC000;    Get time in CX:DX
 10002                                  ;	xchg	ch,cl				;AN000; switch hours & minutes
 10003                                  ;	xchg	dh,dl				;AN000; switch seconds & hundredths
 10004                                  ;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10005                                  ;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10006                                  ;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
 10007                                  ;	invoke	std_printf
 10008                                  ;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
 10009                                  ;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
 10010                                  ;
 10011                                  ;GET_NEW_TIME:
 10012                                  ;	call	gettim				;AC000;
 10013                                  ;	cmp	ax,end_of_line			;AC000; are we at end of line?
 10014                                  ;	jz	time_end			;AC000;
 10015                                  ;	cmp	ax,result_no_error		;AN000; did we have an error?
 10016                                  ;	jne	timerr				;AN000; yes - go issue message
 10017                                  ;
 10018                                  ;COMTIM:
 10019                                  ;	mov	ch,time_hour			;AC000; get parts of time in
 10020                                  ;	mov	cl,time_minutes 		;AC000;    cx and dx for set
 10021                                  ;	mov	dh,time_seconds 		;AC000;    time function call
 10022                                  ;	mov	dl,time_fraction		;AC000;
 10023                                  ;	push	cx				;AC000; save time
 10024                                  ;	push	dx				;AC000;
 10025                                  ;	mov	cx,1				;AC000; set 1 positional parm entered
 10026                                  ;	xor	dx,dx				;AN029;
 10027                                  ;	invoke	cmd_parse			;AN029; call parser
 10028                                  ;	cmp	al,end_of_line			;AN029; Are we at end of line?
 10029                                  ;	pop	dx				;AC000; retieve time
 10030                                  ;	pop	cx				;AC000;
 10031                                  ;	jnz	timerr				;AC000; extra stuff on line - try again
 10032                                  ;
 10033                                  ;SAVTIM:
 10034                                  ;	MOV	AH,SET_TIME
 10035                                  ;	INT	21h
 10036                                  ;	OR	AL,AL
 10037                                  ;	JNZ	TIMERR				;AC000; if an error occured, try again
 10038                                  ;
 10039                                  ;TIME_END:
 10040                                  ;
 10041                                  ;	ret
 10042                                  ;
 10043                                  ;TIMERR:
 10044                                  ;	invoke	crlf2				;AN028; print out a blank line
 10045                                  ;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
 10046                                  ;	invoke	std_printf			; Print error message
 10047                                  ;	JMP	GET_NEW_TIME			;AC000; Try again
 10048                                  
 10049                                  ; =============== S U B	R O U T	I N E =======================================
 10050                                  
 10051                                  ; MSDOS 6.0
 10052                                  
 10053                                  ;
 10054                                  ; Set the special flag in the INIT flag to the value in CX.
 10055                                  ;
 10056                                  
 10057                                  ;SetInitFlag:
 10058                                  ;	mov	ds,[RESSEG]
 10059                                  ;assume ds:resgroup
 10060                                  ;	and	InitFlag,NOT initSpecial
 10061                                  ;	or	InitFlag,cL
 10062                                  ;	push	cs
 10063                                  ;	pop	ds
 10064                                  ;	return
 10065                                  ;
 10066                                  ;Public	PipeOff
 10067                                  ;PipeOff:
 10068                                  ;	ASSUME	DS:NOTHING,ES:NOTHING
 10069                                  ;	SaveReg <DS,AX>
 10070                                  ;	MOV	DS,ResSeg
 10071                                  ;	ASSUME	DS:RESGroup
 10072                                  ;	XOR	AL,AL
 10073                                  ;	XCHG	PipeFlag,AL
 10074                                  ;	OR	AL,AL
 10075                                  ;	JZ	PipeOffDone
 10076                                  ;	SHR	EchoFlag,1
 10077                                  ;PipeOffDone:
 10078                                  ;	RestoreReg  <AX,DS>
 10079                                  ;	return
 10080                                  
 10081                                  ; =============== S U B	R O U T	I N E =======================================
 10082                                  
 10083                                  ; MSDOS 6.0
 10084                                  
 10085                                  ;PRINT_TIME:
 10086                                  ;
 10087                                  ;	MOV	AH,GET_TIME
 10088                                  ;	INT	21h			; Get time in CX:DX
 10089                                  ;
 10090                                  ;	PUSH	ES
 10091                                  ;	PUSH	CS
 10092                                  ;	POP	ES
 10093                                  ;	xchg	ch,cl			;AN000; switch hours & minutes
 10094                                  ;	xchg	dh,dl			;AN000; switch seconds & hundredths
 10095                                  ;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
 10096                                  ;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
 10097                                  ;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
 10098                                  ;	invoke	std_printf
 10099                                  ;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
 10100                                  ;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
 10101                                  ;
 10102                                  ;	POP	ES
 10103                                  ;	return
 10104                                  
 10105                                  ; =============== S U B	R O U T	I N E =======================================
 10106                                  
 10107                                  ; MSDOS 6.0
 10108                                  
 10109                                  ; ****************************************************************
 10110                                  ; *
 10111                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 10112                                  ; *
 10113                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 10114                                  ; *		 INFORMATION and issues the "Enter new date"
 10115                                  ; *		 message with the proper date format.  COMBUF
 10116                                  ; *		 is reset to get a date from the command line.
 10117                                  ; *		 The PARSE_DATE blocks are then reset and the
 10118                                  ; *		 PARSE function call is issued.
 10119                                  ; *
 10120                                  ; * INPUT:	 NONE
 10121                                  ; *
 10122                                  ; * OUTPUT:	 COMBUF
 10123                                  ; *		 PARSER RETURN CODES
 10124                                  ; *
 10125                                  ; ****************************************************************
 10126                                  
 10127                                  ;GETDAT	proc	near				;AC000;
 10128                                  ;
 10129                                  ;	mov	ax,(International SHL 8)	; Determine what format the date
 10130                                  ;	mov	dx,5ch				;  should be entered in and
 10131                                  ;	int	21h			;  print a message describing it
 10132                                  ;	mov	si,dx
 10133                                  ;	lodsw
 10134                                  ;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
 10135                                  ;	dec	ax
 10136                                  ;	js	printformat
 10137                                  ;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
 10138                                  ;	jz	printformat
 10139                                  ;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
 10140                                  ;printformat:
 10141                                  ;	mov	ax,dx				;AN000; get message number of format
 10142                                  ;	mov	dh,util_msg_class		;AN000; this is a utility message
 10143                                  ;	call	Tsysgetmsg			;AN000; get the address of the message
 10144                                  ;	mov	newdat_format,si		;AN000; put the address in subst block
 10145                                  ;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
 10146                                  ;	invoke	std_printf
 10147                                  ;	mov	newdat_format,no_subst		;AN000; reset subst block
 10148                                  ;
 10149                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10150                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10151                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10152                                  ;	call	SetInitFlag			;  prompting for date.
 10153                                  ;	INT	21h			; Get input line
 10154                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10155                                  ;	call	SetInitFlag			;  prompting for date.
 10156                                  ;	invoke	CRLF2
 10157                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10158                                  ;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
 10159                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10160                                  ;	xor	dx,dx				;AN000;
 10161                                  ;	invoke	cmd_parse			;AC000; call parser
 10162                                  ;
 10163                                  ;	ret
 10164                                  ;
 10165                                  ;GETDAT	endp					;AC000;
 10166                                  
 10167                                  ; =============== S U B	R O U T	I N E =======================================
 10168                                  
 10169                                  ; MSDOS 6.0
 10170                                  
 10171                                  ; ****************************************************************
 10172                                  ; *
 10173                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 10174                                  ; *
 10175                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 10176                                  ; *		 INFORMATION and issues the "Enter new time"
 10177                                  ; *		 message. COMBUF is reset to get a time from the
 10178                                  ; *		 command line.	The PARSE_TIME blocks are then
 10179                                  ; *		 reset and the PARSE function call is issued.
 10180                                  ; *
 10181                                  ; * INPUT:	 NONE
 10182                                  ; *
 10183                                  ; * OUTPUT:	 COMBUF
 10184                                  ; *		 PARSER RETURN CODES
 10185                                  ; *
 10186                                  ; ****************************************************************
 10187                                  
 10188                                  ;GETTIM	proc	near				;AC000;
 10189                                  ;
 10190                                  ;	XOR	CX,CX				; Initialize hours and minutes to zero
 10191                                  ;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
 10192                                  ;	invoke	std_printf
 10193                                  ;	MOV	AH,STD_CON_STRING_INPUT
 10194                                  ;	MOV	DX,OFFSET TRANGROUP:COMBUF
 10195                                  ;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
 10196                                  ;	call	SetInitFlag			;  prompting for time.
 10197                                  ;	INT	21h			; Get input line
 10198                                  ;	xor	cx,cx				; Reset bit in InitFlag that indicates
 10199                                  ;	call	SetInitFlag			;  prompting for time.
 10200                                  ;	invoke	CRLF2
 10201                                  ;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
 10202                                  ;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
 10203                                  ;	xor	cx,cx				;AN000; clear counter for positionals
 10204                                  ;	xor	dx,dx				;AN000;
 10205                                  ;	invoke	cmd_parse			;AC000; call parser
 10206                                  ;
 10207                                  ;	ret
 10208                                  ;
 10209                                  ;GETTIM	endp					;AC000;
 10210                                  
 10211                                  ; =============== S U B	R O U T	I N E =======================================
 10212                                  
 10213                                  ; MSDOS 6.0
 10214                                  
 10215                                  ;Skip_white: Skips over the whitespace chars that could be present after
 10216                                  ;the '=' sign in the environment variable before the actual path.
 10217                                  ;
 10218                                  ;	ENTRY:	ds:si = arguments of the environment variable
 10219                                  ;
 10220                                  ;	EXIT:	ds:si = start of the path
 10221                                  ;
 10222                                  ;	REGISTERS AFFECTED: ax
 10223                                  ;
 10224                                  
 10225                                  ;Skip_white	proc	near
 10226                                  ;
 10227                                  ;	cld
 10228                                  ;skw_lp:
 10229                                  ;	lodsb
 10230                                  ;	cmp	al,' '				;blank char?
 10231                                  ;	jz	skw_lp				;yes, skip it
 10232                                  ;	cmp	al,09				;tab char?
 10233                                  ;	jz	skw_lp				;yes, skip it
 10234                                  ;
 10235                                  ;	dec	si				;point at first non-white
 10236                                  ;
 10237                                  ;	ret
 10238                                  ;
 10239                                  ;Skip_white	endp
 10240                                  
 10241                                  ; =============== S U B	R O U T	I N E =======================================
 10242                                  
 10243                                  ; MSDOS 6.0
 10244                                  
 10245                                  ;Copy_pipe_path:	This routine copies the path from the TEMP environment
 10246                                  ;variable into the path buffers Pipe1 & Pipe2.
 10247                                  ;
 10248                                  ;	ENTRY:	ds:si = path to be copied
 10249                                  ;		es = RESGROUP
 10250                                  ;
 10251                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 10252                                  ;
 10253                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 10254                                  ;
 10255                                  
 10256                                  ;Copy_pipe_path	proc	near
 10257                                  ;
 10258                                  ;	mov	cx,0ffffh
 10259                                  ;	xor	al,al
 10260                                  ;
 10261                                  ;	mov	di,si
 10262                                  ;	push	es			;save es
 10263                                  ;	push	ds
 10264                                  ;	pop	es			;es:di = path to be copied
 10265                                  ;	
 10266                                  ;	cld
 10267                                  ;	push	di
 10268                                  ;	repnz	scasb			;look for the null char
 10269                                  ;	pop	di
 10270                                  ;
 10271                                  ;	pop	es			;es = RESGROUP again
 10272                                  ;
 10273                                  ;	not	cx			;length including the null
 10274                                  ;
 10275                                  ;	mov	di,offset DATARES:Pipe1	
 10276                                  ;	push	di
 10277                                  ;	push	cx			
 10278                                  ;	rep	movsb			;copy path into Pipe1
 10279                                  ;	pop	cx
 10280                                  ;	pop	di
 10281                                  ;
 10282                                  ;	push	ds
 10283                                  ;	push	es
 10284                                  ;	pop	ds			;ds:si = Pipe1
 10285                                  ;	mov	si,di
 10286                                  ;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 10287                                  ;	rep	movsb			;copy path into Pipe2
 10288                                  ;	pop	ds
 10289                                  ;
 10290                                  ;	ret				;
 10291                                  ;
 10292                                  ;Copy_pipe_path	endp
 10293                                  
 10294                                  ;============================================================================
 10295                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10296                                  ;============================================================================
 10297                                  ; 05/10/2018 - Retro DOS v3.0
 10298                                  
 10299                                  ; DATE - Gets and sets the time
 10300                                  
 10301                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 10302                                  
 10303                                  ; =============== S U B	R O U T	I N E =======================================
 10304                                  
 10305                                  DATE_CXDX:
 10306 0000209C 89CB                    		mov	bx,cx
 10307                                  
 10308                                  ; =============== S U B	R O U T	I N E =======================================
 10309                                  
 10310                                  P_DATE:
 10311 0000209E 89D8                    		mov	ax,bx
 10312 000020A0 89D1                    		mov	cx,dx
 10313 000020A2 B264                    		mov	dl,100
 10314 000020A4 F6F2                    		div	dl
 10315 000020A6 86C4                    		xchg	al,ah
 10316 000020A8 92                      		xchg	ax,dx
 10317 000020A9 B710                    		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 10318                                  		;mov	ax,[INTERNATVARS]
 10319 000020AB A1[F84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10320 000020AE 09C0                    		or	ax,ax
 10321 000020B0 7415                    		jz	short USPDAT
 10322 000020B2 48                      		dec	ax
 10323 000020B3 7422                    		jz	short EUPDAT
 10324 000020B5 B700                    		mov	bh,0	 ; Disable leading zero suppression	
 10325 000020B7 E83900                  		call	P_YR
 10326 000020BA E82B00                  		call	P_DSEP
 10327 000020BD E82200                  		call	P_MON
 10328 000020C0 E82500                  		call	P_DSEP
 10329 000020C3 E82700                  		call	P_DAY
 10330 000020C6 C3                      		retn
 10331                                  
 10332                                  USPDAT:
 10333 000020C7 E81800                  		call	P_MON
 10334 000020CA E81B00                  		call	P_DSEP
 10335 000020CD E81D00                  		call	P_DAY
 10336                                  PLST:
 10337 000020D0 E81500                  		call	P_DSEP
 10338 000020D3 E81D00                  		call	P_YR
 10339 000020D6 C3                      		retn
 10340                                  
 10341                                  EUPDAT:
 10342 000020D7 E81300                  		call	P_DAY
 10343 000020DA E80B00                  		call	P_DSEP
 10344 000020DD E80200                  		call	P_MON
 10345 000020E0 EBEE                    		jmp	short PLST
 10346                                  
 10347                                  ; ---------------------------------------------------------------------------
 10348                                  
 10349                                  P_MON:
 10350 000020E2 88E8                    		mov	al,ch
 10351 000020E4 E88402                  		call	OUT2
 10352 000020E7 C3                      		retn
 10353                                  
 10354                                  ; ---------------------------------------------------------------------------
 10355                                  
 10356                                  P_DSEP:
 10357                                  		;mov	al,[DATE_SEP] ; INTERNATVARS+11
 10358 000020E8 A0[034D]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 10359 000020EB AA                      		stosb
 10360 000020EC C3                      		retn
 10361                                  
 10362                                  ; ---------------------------------------------------------------------------
 10363                                  
 10364                                  P_DAY:
 10365 000020ED 88C8                    		mov	al,cl
 10366 000020EF E87902                  		call	OUT2
 10367 000020F2 C3                      		retn
 10368                                  
 10369                                  ; ---------------------------------------------------------------------------
 10370                                  
 10371                                  P_YR:
 10372 000020F3 88F0                    		mov	al,dh
 10373 000020F5 08C0                    		or	al,al
 10374 000020F7 7403                    		jz	short TWODIGYR	; Two instead of 4 digit year
 10375 000020F9 E86F02                  		call	OUT2
 10376                                  TWODIGYR:
 10377 000020FC 88D0                    		mov	al,dl
 10378 000020FE E86A02                  		call	OUT2
 10379                                  DATE_RETN:
 10380 00002101 C3                      		retn
 10381                                  
 10382                                  ; =============== S U B	R O U T	I N E =======================================
 10383                                  
 10384                                  DATE:				 	; Accepting argument for date inline
 10385 00002102 BE8100                  		mov	si,81h
 10386 00002105 E871F8                  		call	SCANOFF
 10387 00002108 3C0D                    		cmp	al,0Dh
 10388 0000210A 7402                    		jz	short PRMTDAT
 10389 0000210C EB48                    		jmp	short COMDAT
 10390                                  
 10391                                  		;nop
 10392                                  
 10393                                  PRMTDAT:
 10394                                  		; MSDOS 3.3
 10395 0000210E BA[5B3A]                		mov	dx,CURDATPTR
 10396 00002111 E8BF13                  		call	STD_PRINTF	; Print "Current date is "	
 10397 00002114 E88808                  		call	PRINT_DATE
 10398                                  
 10399                                  GETDAT:	
 10400 00002117 BA[6F3A]                		mov	dx,NEWDATPTR
 10401 0000211A E8B613                  		call	STD_PRINTF	 ; Print "Enter new date: "
 10402                                  
 10403 0000211D B80038                  		mov	ax,INTERNATIONAL*256 ; 3800h 
 10404                                  					; Determine what format the date
 10405 00002120 BA5C00                  		mov	dx,5Ch		;  should be entered in and
 10406 00002123 CD21                    		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 10407                                  				; get current-country info
 10408                                  				; DS:DX	-> buffer for returned info
 10409 00002125 89D6                    		mov	si,dx		;  print a message describing it
 10410 00002127 AD                      		lodsw
 10411 00002128 BA[7E3A]                		mov	dx,USADATPTR	; get mm-dd-yy
 10412 0000212B 48                      		dec	ax
 10413 0000212C 7808                    		js	short PRINTFORMAT
 10414 0000212E BA[8D3A]                		mov	dx,EURDATPTR	; get dd-mm-yy
 10415 00002131 7403                    		jz	short PRINTFORMAT
 10416 00002133 BA[9C3A]                		mov	dx,JAPDATPTR	; get yy-mm-dd
 10417                                  PRINTFORMAT:
 10418 00002136 E89A13                  		call	STD_PRINTF
 10419 00002139 B40A                    		mov	ah,STD_CON_STRING_INPUT	; 0Ah
 10420 0000213B BA[D040]                		mov	dx,COMBUF
 10421 0000213E B90200                  		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 10422 00002141 E83802                  		call	SETINITFLAG	;  prompting for date.
 10423 00002144 CD21                    		int	21h		; Get input line
 10424 00002146 31C9                    		xor	cx,cx		; Reset bit in InitFlag that indicates
 10425 00002148 E83102                  		call	SETINITFLAG	;  prompting for date.
 10426 0000214B E81EF8                  		call	CRLF2
 10427 0000214E BE[D240]                		mov	si,COMBUF+2
 10428 00002151 803C0D                  		cmp	byte [si],0Dh
 10429 00002154 74AB                    		jz	short DATE_RETN
 10430                                  COMDAT:
 10431                                  		;mov	ax,[INTERNATVARS]
 10432 00002156 A1[F84C]                		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 10433 00002159 09C0                    		or	ax,ax
 10434 0000215B 7435                    		jz	short USSDAT
 10435 0000215D 48                      		dec	ax
 10436 0000215E 744B                    		jz	short EUSDAT
 10437 00002160 E86500                  		call	GET_YR
 10438 00002163 7235                    		jc	short DATERRJ
 10439 00002165 E89E00                  		call	GET_DSEP
 10440 00002168 7230                    		jc	short DATERRJ
 10441 0000216A E84D00                  		call	GET_MON
 10442 0000216D 722B                    		jc	short DATERRJ
 10443 0000216F E89400                  		call	GET_DSEP
 10444 00002172 7226                    		jc	short DATERRJ
 10445 00002174 E84B00                  		call	GET_DAY
 10446                                  DAT_SET:
 10447 00002177 7303                    		jnc	short DATSET
 10448 00002179 E98100                  		jmp	DATERR
 10449                                  
 10450                                  ; ---------------------------------------------------------------------------
 10451                                  
 10452                                  DATSET:
 10453 0000217C AC                      		lodsb
 10454 0000217D 3C20                    		cmp	al,' '
 10455 0000217F 74FB                    		jz	short DATSET
 10456 00002181 3C09                    		cmp	al,9
 10457 00002183 74F7                    		jz	short DATSET
 10458 00002185 3C0D                    		cmp	al,0Dh
 10459 00002187 7574                    		jnz	short DATERR
 10460 00002189 B42B                    		mov	ah,SET_DATE ; 2Bh
 10461 0000218B CD21                    		int	21h	; DOS -	SET CURRENT DATE
 10462                                  				; DL = day,DH = month,	CX = year
 10463                                  				; Return: AL = 00h if no error 
 10464                                  				; 	     = FFh if bad value sent to routine
 10465 0000218D 08C0                    		or	al,al
 10466 0000218F 756C                    		jnz	short DATERR
 10467                                  DAT_SET_RETN:
 10468 00002191 C3                      		retn
 10469                                  
 10470                                  ; ---------------------------------------------------------------------------
 10471                                  
 10472                                  USSDAT:
 10473 00002192 E82500                  		call	GET_MON
 10474 00002195 7266                    		jb	short DATERR
 10475 00002197 E86C00                  		call	GET_DSEP
 10476                                  DATERRJ:
 10477 0000219A 7261                    		jc	short DATERR
 10478 0000219C E82300                  		call	GET_DAY
 10479                                  TGET:
 10480 0000219F 725C                    		jc	short DATERR
 10481 000021A1 E86200                  		call	GET_DSEP
 10482 000021A4 7257                    		jc	short DATERR
 10483 000021A6 E81F00                  		call	GET_YR
 10484 000021A9 EBCC                    		jmp	short DAT_SET
 10485                                  
 10486                                  ; ---------------------------------------------------------------------------
 10487                                  
 10488                                  EUSDAT:
 10489 000021AB E81400                  		call	GET_DAY
 10490 000021AE 724D                    		jc	short DATERR
 10491 000021B0 E85300                  		call	GET_DSEP
 10492 000021B3 7248                    		jc	short DATERR
 10493 000021B5 E80200                  		call	GET_MON
 10494 000021B8 EBE5                    		jmp	short TGET
 10495                                  
 10496                                  
 10497                                  ; =============== S U B	R O U T	I N E =======================================
 10498                                  
 10499                                  GET_MON:
 10500 000021BA E88E01                  		call	GETNUM		; Get one or two digit number
 10501 000021BD 72D2                    		jc	short DAT_SET_RETN
 10502 000021BF 88E6                    		mov	dh,ah		; Put in position
 10503 000021C1 C3                      		retn
 10504                                  
 10505                                  
 10506                                  ; =============== S U B	R O U T	I N E =======================================
 10507                                  
 10508                                  GET_DAY:
 10509 000021C2 E88601                  		call	GETNUM
 10510 000021C5 88E2                    		mov	dl,ah		; Put in position
 10511                                  GET_DAY_RETN:
 10512 000021C7 C3                      		retn
 10513                                  
 10514                                  ; =============== S U B	R O U T	I N E =======================================
 10515                                  
 10516                                  GET_YR:
 10517 000021C8 E88001                  		call	GETNUM
 10518 000021CB 72FA                    		jc	short GET_DAY_RETN
 10519 000021CD B96C07                  		mov	cx,1900
 10520 000021D0 E83300                  		call	GET_DSEP
 10521 000021D3 9C                      		pushf
 10522 000021D4 4E                      		dec	si
 10523 000021D5 9D                      		popf
 10524 000021D6 741E                    		jz	short BIAS
 10525 000021D8 803C0D                  		cmp	byte [si],0Dh
 10526 000021DB 7419                    		je	short BIAS
 10527 000021DD 803C20                  		cmp	byte [si],' '
 10528 000021E0 7414                    		je	short BIAS
 10529 000021E2 803C09                  		cmp	byte [si],9
 10530 000021E5 740F                    		je	short BIAS
 10531 000021E7 53                      		push	bx
 10532 000021E8 B364                    		mov	bl,100
 10533 000021EA 88E0                    		mov	al,ah
 10534 000021EC F6E3                    		mul	bl
 10535 000021EE 5B                      		pop	bx
 10536 000021EF 89C1                    		mov	cx,ax
 10537 000021F1 E85701                  		call	GETNUM
 10538 000021F4 72D1                    		jc	short GET_DAY_RETN
 10539                                  BIAS:
 10540 000021F6 88E0                    		mov	al,ah
 10541 000021F8 B400                    		mov	ah,0
 10542 000021FA 01C1                    		add	cx,ax
 10543                                  BIAS_RETN:
 10544 000021FC C3                      		retn
 10545                                  
 10546                                  ; ---------------------------------------------------------------------------
 10547                                  
 10548                                  DATERR:
 10549 000021FD BA[483A]                		mov	dx,BADDATPTR
 10550 00002200 E8D012                  		call	STD_PRINTF
 10551 00002203 E911FF                  		jmp	GETDAT
 10552                                  
 10553                                  ; =============== S U B	R O U T	I N E =======================================
 10554                                  
 10555                                  GET_DSEP:
 10556 00002206 AC                      		lodsb
 10557 00002207 3C2F                    		cmp	al,'/'
 10558 00002209 74F1                    		je	short BIAS_RETN
 10559                                  		;cmp	al,'.'
 10560 0000220B 3A06[083F]              		cmp	al,[DOT_CHR]
 10561 0000220F 74EB                    		je	short BIAS_RETN
 10562                                  		;cmp	al,'-'
 10563 00002211 3A06[FE3E]              		cmp	al,[CHAR_SUB]
 10564 00002215 74E5                    		je	short BIAS_RETN
 10565 00002217 F9                      		stc
 10566 00002218 C3                      		retn
 10567                                  
 10568                                  ; =============== S U B	R O U T	I N E =======================================
 10569                                  
 10570                                  ; TIME gets and sets the time
 10571                                  
 10572                                  CTIME:
 10573 00002219 BE8100                  		mov	si,81h		; Accepting argument for time inline
 10574 0000221C E85AF7                  		call	SCANOFF
 10575 0000221F 3C0D                    		cmp	al,0Dh
 10576 00002221 747C                    		je	short PRMTTIM
 10577 00002223 BB3A2E                  		mov	bx,2E3Ah ; ":."
 10578 00002226 E80601                  		call	INLINE
 10579 00002229 E98B00                  		jmp	COMTIM
 10580                                  
 10581                                  ; =============== S U B	R O U T	I N E =======================================
 10582                                  
 10583                                  PRINT_TIME:
 10584 0000222C B42C                    		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
 10585 0000222E CD21                    		int	21h	; DOS -	GET CURRENT TIME
 10586                                  				; Return: CH = hours,CL = minutes,DH = seconds
 10587                                  				; DL = hundredths of seconds
 10588 00002230 57                      		push	di
 10589 00002231 06                      		push	es
 10590 00002232 0E                      		push	cs
 10591 00002233 07                      		pop	es
 10592 00002234 BF[9B42]                		mov	di,CHARBUF
 10593 00002237 B301                    		mov	bl,1	; Always 24 hour time
 10594 00002239 E81300                  		call	P_TIME
 10595 0000223C 31C0                    		xor	ax,ax
 10596 0000223E AA                      		stosb
 10597 0000223F BA[9B42]                		mov	dx,CHARBUF
 10598 00002242 8916[4E44]              		mov	[STRING_PTR_2],dx
 10599 00002246 BA[3F37]                		mov	dx,STRINGBUF2PTR
 10600 00002249 E88712                  		call	STD_PRINTF
 10601 0000224C 07                      		pop	es
 10602 0000224D 5F                      		pop	di
 10603                                  P_TIME_RETN:
 10604 0000224E C3                      		retn
 10605                                  
 10606                                  ; =============== S U B	R O U T	I N E =======================================
 10607                                  
 10608                                  P_TIME:
 10609 0000224F 88E8                    		mov	al,ch	
 10610 00002251 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10611 00002254 7512                    		jnz	short T24	; 24 hr time?
 10612 00002256 B761                    		mov	bh,'a'		; Assume A.M.
 10613 00002258 3C0C                    		cmp	al,12		; In the afternoon?
 10614 0000225A 7206                    		jb	short MORN
 10615 0000225C B770                    		mov	bh,'p'
 10616 0000225E 7402                    		jz	short MORN
 10617 00002260 2C0C                    		sub	al,12		; Keep it to 12 hours or less
 10618                                  MORN:
 10619 00002262 08C0                    		or	al,al		; Before 1 am?
 10620 00002264 7502                    		jnz	short T24
 10621 00002266 B00C                    		mov	al,12
 10622                                  T24:
 10623 00002268 53                      		push	bx
 10624 00002269 B710                    		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 10625 0000226B E8FD00                  		call	OUT2
 10626 0000226E E82900                  		call	P_TSEP
 10627 00002271 88C8                    		mov	al,cl
 10628 00002273 E8F500                  		call	OUT2
 10629 00002276 5B                      		pop	bx
 10630 00002277 53                      		push	bx
 10631 00002278 F6C380                  		test	bl,80h
 10632 0000227B 7513                    		jnz	short PAP	; If from DIR, go directly to am pm
 10633 0000227D B700                    		mov	bh,0		; Disable leading zero suppression
 10634 0000227F E81800                  		call	P_TSEP
 10635 00002282 88F0                    		mov	al,dh
 10636 00002284 E8E400                  		call	OUT2
 10637                                  		;mov	al,'.'
 10638 00002287 A0[014D]                		mov	al,[DECIMAL_SEP]
 10639 0000228A AA                      		stosb
 10640 0000228B 88D0                    		mov	al,dl
 10641 0000228D E8DB00                  		call	OUT2
 10642                                  PAP:
 10643 00002290 5B                      		pop	bx
 10644 00002291 F6C37F                  		test	bl,7Fh		; Ignore high bit
 10645 00002294 75B8                    		jnz	short P_TIME_RETN
 10646 00002296 88F8                    		mov	al,bh
 10647 00002298 AA                      		stosb
 10648 00002299 C3                      		retn
 10649                                  
 10650                                  ; =============== S U B	R O U T	I N E =======================================
 10651                                  
 10652                                  P_TSEP:
 10653                                  		;mov	al,[TIME_SEP]
 10654 0000229A A0[054D]                		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 10655 0000229D AA                      		stosb
 10656                                  P_TSEP_RETN:
 10657 0000229E C3                      		retn
 10658                                  
 10659                                  ; ---------------------------------------------------------------------------
 10660                                  
 10661                                  PRMTTIM:
 10662 0000229F BA[C13A]                		mov	dx,CURTIMPTR
 10663 000022A2 E82E12                  		call	STD_PRINTF	; Print "Current time is "
 10664 000022A5 E884FF                  		call	PRINT_TIME
 10665                                  GETTIM:
 10666 000022A8 31C9                    		xor	cx,cx		; Initialize hours and minutes to zero
 10667 000022AA BA[D63A]                		mov	dx,NEWTIMPTR
 10668 000022AD E82312                  		call	STD_PRINTF
 10669                                  		;mov	bx,':.'
 10670 000022B0 8B1E[0C3F]              		mov	bx,[TIMECHARS] 
 10671 000022B4 E85B00                  		call	GETBUF
 10672                                  COMTIM:
 10673 000022B7 74E5                    		jz	short P_TSEP_RETN ; If no time present, don't change it	
 10674 000022B9 724F                    		jc	short TIMEERR
 10675 000022BB 89D1                    		mov	cx,dx
 10676 000022BD 31D2                    		xor	dx,dx
 10677 000022BF AC                      		lodsb
 10678 000022C0 3C0D                    		cmp	al,0Dh
 10679 000022C2 743E                    		je	short SAVTIM
 10680 000022C4 3C20                    		cmp	al,' '
 10681 000022C6 742D                    		je	short GOTSEC2
 10682 000022C8 3C09                    		cmp	al,9
 10683 000022CA 7429                    		je	short GOTSEC2
 10684 000022CC 38D8                    		cmp	al,bl
 10685 000022CE 7404                    		je	short GOTSEC
 10686 000022D0 38F8                    		cmp	al,bh
 10687 000022D2 7536                    		jne	short TIMEERR
 10688                                  GOTSEC:
 10689 000022D4 E87400                  		call	GETNUM
 10690 000022D7 7231                    		jc	short TIMEERR
 10691 000022D9 88E6                    		mov	dh,ah		; Position seconds
 10692 000022DB AC                      		lodsb
 10693 000022DC 3C0D                    		cmp	al,0Dh
 10694 000022DE 7422                    		je	short SAVTIM
 10695 000022E0 3C20                    		cmp	al,' '
 10696 000022E2 7411                    		je	short GOTSEC2
 10697 000022E4 3C09                    		cmp	al,9
 10698 000022E6 740D                    		je	short GOTSEC2
 10699                                  		;cmp	al,'.'
 10700 000022E8 3A06[014D]              		cmp	al,[DECIMAL_SEP]
 10701 000022EC 751C                    		jne	short TIMEERR
 10702 000022EE E85A00                  		call	GETNUM
 10703 000022F1 7217                    		jc	short TIMEERR
 10704 000022F3 88E2                    		mov	dl,ah
 10705                                  GOTSEC2:
 10706 000022F5 AC                      		lodsb
 10707 000022F6 3C20                    		cmp	al,' '
 10708 000022F8 74FB                    		je	short GOTSEC2
 10709 000022FA 3C09                    		cmp	al,9
 10710 000022FC 74F7                    		je	short GOTSEC2
 10711 000022FE 3C0D                    		cmp	al,0Dh
 10712 00002300 7508                    		jne	short TIMEERR
 10713                                  SAVTIM:
 10714 00002302 B42D                    		mov	ah,SET_TIME ; 2Dh
 10715 00002304 CD21                    		int	21h	; DOS -	SET CURRENT TIME
 10716                                  				; CH = hours,CL = minutes,DH = seconds,
 10717                                  				;		DL = hundredths of seconds
 10718                                  				; Return: AL = 00h if no error 
 10719                                  				;	     = FFh if bad value sent to routine
 10720 00002306 08C0                    		or	al,al
 10721                                  P_TSEP_JRETN:
 10722 00002308 7494                    		jz	short P_TSEP_RETN ; Error in time?
 10723                                  TIMEERR:
 10724 0000230A BA[AE3A]                		mov	dx,BADTIMPTR
 10725 0000230D E8C311                  		call	STD_PRINTF	; Print "Enter new time: "
 10726 00002310 EB96                    		jmp	short GETTIM
 10727                                  
 10728                                  ; =============== S U B	R O U T	I N E =======================================
 10729                                  
 10730                                  GETBUF:
 10731 00002312 B40A                    		mov	ah,STD_CON_STRING_INPUT ; 0Ah
 10732 00002314 BA[D040]                		mov	dx,COMBUF
 10733 00002317 B90200                  		mov	cx,2
 10734 0000231A E85F00                  		call	SETINITFLAG
 10735 0000231D CD21                    		int	21h		; Get input line
 10736 0000231F 31C9                    		xor	cx,cx
 10737 00002321 E85800                  		call	SETINITFLAG
 10738 00002324 E845F6                  		call	CRLF2
 10739 00002327 BE[D240]                		mov	si,COMBUF+2
 10740 0000232A 803C0D                  		cmp	byte [si],0Dh	; Check if new time entered
 10741 0000232D 74D9                    		jz	short P_TSEP_JRETN
 10742                                  
 10743                                  ; =============== S U B	R O U T	I N E =======================================
 10744                                  
 10745                                  INLINE:
 10746 0000232F E81900                  		call	GETNUM		; Get one or two digit number
 10747 00002332 7301                    		jnb	short INLINE1
 10748 00002334 C3                      		retn
 10749                                  INLINE1:
 10750 00002335 88E6                    		mov	dh,ah		; Put in position
 10751 00002337 AC                      		lodsb
 10752 00002338 38D8                    		cmp	al,bl
 10753 0000233A 7409                    		jz	short NEXT
 10754 0000233C 38F8                    		cmp	al,bh
 10755 0000233E 7405                    		jz	short NEXT
 10756 00002340 4E                      		dec	si		; Clears zero flag
 10757 00002341 F8                      		clc
 10758 00002342 B200                    		mov	dl,0
 10759 00002344 C3                      		retn			; Time may have only an hour specified
 10760                                  NEXT:
 10761 00002345 E80300                  		call	GETNUM
 10762 00002348 88E2                    		mov	dl,ah		; Put in position
 10763                                  INLINE_RETN:
 10764 0000234A C3                      		retn
 10765                                  
 10766                                  ;============================================================================
 10767                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 10768                                  ;============================================================================
 10769                                  ; 05/10/2018 - Retro DOS v3.0
 10770                                  
 10771                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 10772                                  
 10773                                  ; =============== S U B	R O U T	I N E =======================================
 10774                                  
 10775                                  GETNUM:
 10776 0000234B E81000                  		call	INDIG
 10777 0000234E 72FA                    		jb	short INLINE_RETN
 10778 00002350 88C4                    		mov	ah,al		; Save first digit
 10779 00002352 E80900                  		call	INDIG		; Another digit?
 10780 00002355 7204                    		jb	short OKRET
 10781 00002357 D50A                    		aad			; Convert unpacked BCD to decimal
 10782 00002359 88C4                    		mov	ah,al
 10783                                  OKRET:
 10784 0000235B 0C01                    		or	al,1
 10785                                  GETNUM_RETN:
 10786 0000235D C3                      		retn
 10787                                  
 10788                                  ; =============== S U B	R O U T	I N E =======================================
 10789                                  
 10790                                  INDIG:
 10791 0000235E 8A04                    		mov	al,[si]
 10792 00002360 2C30                    		sub	al,'0'
 10793 00002362 72F9                    		jc	short GETNUM_RETN
 10794 00002364 3C0A                    		cmp	al,10
 10795 00002366 F5                      		cmc
 10796 00002367 72F4                    		jc	short GETNUM_RETN
 10797 00002369 46                      		inc	si
 10798 0000236A C3                      		retn
 10799                                  
 10800                                  ; =============== S U B	R O U T	I N E =======================================
 10801                                  
 10802                                  OUT2:					; Output binary number as two ASCII digits
 10803 0000236B D40A                    		aam			; Convert binary to unpacked BCD
 10804 0000236D 86C4                    		xchg	al,ah
 10805 0000236F 0D3030                  		or	ax,3030h	; Add "0" bias to both digits
 10806 00002372 3C30                    		cmp	al,'0'		; Is MSD zero?
 10807 00002374 7502                    		jnz	short NOSUP
 10808 00002376 28F8                    		sub	al,bh		; Suppress leading zero if enabled
 10809                                  NOSUP:
 10810 00002378 B700                    		mov	bh,0		; Disable zero suppression
 10811 0000237A AB                      		stosw
 10812 0000237B C3                      		retn
 10813                                  
 10814                                  ; ---------------------------------------------------------------------------
 10815                                  		;stosb
 10816                                  		;retn
 10817                                  
 10818                                  ;============================================================================
 10819                                  ; TPIPE.ASM, MSDOS 6.0, 1991 (2)
 10820                                  ;============================================================================
 10821                                  ; 03/10/2018 - Retro DOS v3.0
 10822                                  
 10823                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 10824                                  
 10825                                  ; =============== S U B	R O U T	I N E =======================================
 10826                                  
 10827                                  ; Set the special flag in the INIT flag to the value in CX.
 10828                                  
 10829                                  SETINITFLAG:
 10830 0000237C 8E1E[7142]              		mov	ds,[RESSEG]
 10831                                  		;and	byte [INITFLAG],0FDh
 10832 00002380 8026590CFD              		and	byte [INITFLAG],~INITSPECIAL
 10833 00002385 080E590C                		or	byte [INITFLAG],cl
 10834 00002389 0E                      		push	cs
 10835 0000238A 1F                      		pop	ds
 10836 0000238B C3                      		retn
 10837                                  
 10838                                  ; =============== S U B	R O U T	I N E =======================================
 10839                                  
 10840                                  PIPEOFF:
 10841 0000238C 1E                      		push	ds
 10842 0000238D 50                      		push	ax
 10843 0000238E 2E8E1E[7142]            		mov	ds,[cs:RESSEG]
 10844 00002393 30C0                    		xor	al,al
 10845 00002395 86065A0C                		xchg	al,byte [PIPEFLAG]
 10846 00002399 08C0                    		or	al,al
 10847 0000239B 7404                    		jz	short PIPEOFFDONE
 10848 0000239D D02EED0B                		shr	byte [ECHOFLAG],1
 10849                                  PIPEOFFDONE:
 10850 000023A1 58                      		pop	ax
 10851 000023A2 1F                      		pop	ds
 10852 000023A3 C3                      		retn
 10853                                  
 10854                                  ; ---------------------------------------------------------------------------
 10855                                  		;db    0,0,0,0,0
 10856                                  		;times 5 db 0
 10857 000023A4 90<rep Ch>              align 16
 10858                                  
 10859                                  ;============================================================================
 10860                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 10861                                  ;============================================================================
 10862                                  ; 03/10/2018 - Retro DOS v3.0
 10863                                  
 10864                                  ;----------------------------------------------------------------------------
 10865                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 10866                                  ; argv[argvcnt] array. The most important difference between this array and
 10867                                  ; the tradition UNIX format is the extra cparse information included with
 10868                                  ; each argument element.
 10869                                  ;---------------
 10870                                  ; ENTRY:
 10871                                  ;	BL	     special delimiter for cparse -- not implemented)
 10872                                  ;---------------
 10873                                  ; EXIT:
 10874                                  ;	CF	    set if error
 10875                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 10876                                  ;	argv[]	    array of cparse flags and pointers to arguments
 10877                                  ;	argvcnt     argument count
 10878                                  ;---------------
 10879                                  ; NOTE(S):
 10880                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 10881                                  ;	*   Parseflags record contains cparse flags, as follows:
 10882                                  ;		sw_flag 	--	was this arg a switch?
 10883                                  ;		wildcard	--	whether or not it contained a * or ?
 10884                                  ;		path_sep	--	maybe it was a pathname
 10885                                  ;		unused		--	for future expansion
 10886                                  ;		special_delim	--	was there an initial special delimiter?
 10887                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 10888                                  ;	*   Relationship between input, cparse output, and comtail can be
 10889                                  ;	    found in the following chart.  Despite the claim of the cparse
 10890                                  ;	    documentation that, "Token buffer always starts d:  for non switch
 10891                                  ;	    tokens", such is not the case (see column two, row two).
 10892                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 10893                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 10894                                  ;	    STARTEL addresses) will be null. This is clearly just a
 10895                                  ;	    documentation error.
 10896                                  ;	*   cparse also returns a switch code in BP for each switch it
 10897                                  ;	    recognizes on the command line.
 10898                                  ;	*   arglen for each token does NOT include the terminating null.
 10899                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 10900                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 10901                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 10902                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 10903                                  ;	    line parsing may result in slightly different behavior than
 10904                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 10905                                  ;
 10906                                  ;	    Input		    Cparse		Command Line (80H)
 10907                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 10908                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 10909                                  ;	foo.bat 		foo.bat 		foo.bat
 10910                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 10911                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 10912                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 10913                                  
 10914                                  ; =============== S U B	R O U T	I N E =======================================
 10915                                  
 10916                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 10917                                  
 10918                                  PARSELINE:
 10919 000023B0 50                      		push	ax			; most of these are clobbered
 10920 000023B1 53                      		push	bx			; by cparse...
 10921 000023B2 51                      		push	cx
 10922 000023B3 52                      		push	dx
 10923 000023B4 57                      		push	di
 10924 000023B5 56                      		push	si
 10925 000023B6 9C                      		pushf
 10926 000023B7 C606[5644]00            		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
 10927 000023BC C706[6F4B]FFFF          		mov	word [LASTARG],-1 ; last argument at which to accumulate
 10928 000023C2 31C0                    		xor	ax,ax
 10929                                  		;mov	cx,1348
 10930 000023C4 B94405                  		mov	cx,ARG_UNIT.SIZE
 10931 000023C7 BF[A945]                		mov	di,ARG
 10932 000023CA F3AA                    		rep stosb
 10933                                  		;mov	word [ARGBUFPTR],ARG_ARGBUF
 10934 000023CC C706[ED4A][6D48]        		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
 10935                                  		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 10936 000023D2 C706[6B48]0000          		mov	word [ARG+ARG_UNIT.argswinfo],0
 10937                                  		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 10938 000023D8 C706[6948]0000          		mov	word [ARG+ARG_UNIT.argvcnt],0
 10939 000023DE BE[D240]                		mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 10940                                  
 10941                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 10942                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 10943                                  ; otherwise. This is done so that commands can get arg pointers into their
 10944                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 10945                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 10946                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 10947                                  ; the command to be repeated or the transient part of command has been
 10948                                  ; reloaded.
 10949                                  
 10950 000023E1 1E                      		push	ds
 10951 000023E2 8E1E[7142]              		mov	ds,[RESSEG]
 10952 000023E6 803EF90B00              		cmp	byte [FORFLAG],0
 10953 000023EB 1F                      		pop	ds
 10954 000023EC 7510                    		jnz	short PCONT
 10955                                  		;mov	di,ARG_ARGFORCOMBUF
 10956 000023EE BF[6D4A]                		mov	di,ARG+ARG_UNIT.argforcombuf 
 10957 000023F1 30ED                    		xor	ch,ch
 10958 000023F3 8A0E[D140]              		mov	cl,[COMBUF+1]
 10959 000023F7 FEC1                    		inc	cl
 10960 000023F9 F3A4                    		rep movsb
 10961                                  		;mov	si,ARG_ARGFORCOMBUF
 10962 000023FB BE[6D4A]                		mov	si,ARG+ARG_UNIT.argforcombuf 
 10963                                  PCONT:
 10964 000023FE BF[EF4A]                		mov	di,TPBUF	; destination is temporary token buffer	
 10965 00002401 B320                    		mov	bl,' '		; no special delimiter, for now
 10966                                  PARSELOOP:
 10967 00002403 8936[714B]              		mov	[COMPTR],si	; save ptr into original command buffer
 10968 00002407 31ED                    		xor	bp,bp		; switch information put here by cparse
 10969 00002409 C606[A745]00            		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
 10970 0000240E E868F5                  		call	SCANOFF		; skip leading blanks...
 10971 00002411 E8000F                  		call	CPARSE		; byte off a token (args in SI, DI, BL)
 10972 00002414 7309                    		jnb	short MORE_PRSE
 10973 00002416 09ED                    		or	bp,bp		; Check for trailing switch character
 10974 00002418 7411                    		jz	short PARSEDONE
 10975 0000241A E81B00                  		call	NEWARG		; We hit CR but BP is non-zero. The
 10976                                  					;   typical cause of this is that a
 10977                                  					;   switch char IMMEDIATELY preceeds
 10978                                  					;   the CR. We have an argument, but it
 10979                                  					;   is sort of an error.
 10980 0000241D EB0C                    		jmp	short PARSEDONE	; We're done (found the CR).
 10981                                  
 10982                                  MORE_PRSE:
 10983 0000241F C606[5644]02            		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
 10984 00002424 E81100                  		call	NEWARG		; add to argv array (CX has char count)
 10985 00002427 73DA                    		jnb	short PARSELOOP	; was everything OK?
 10986 00002429 EB04                    		jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 10987                                  
 10988                                  PARSEDONE:
 10989 0000242B 9D                      		popf
 10990 0000242C F8                      		clc
 10991 0000242D EB02                    		jmp	short PARSE_EXIT
 10992                                  
 10993                                  PARSE_ERROR:				; error entry (er, exit) point
 10994 0000242F 9D                      		popf
 10995 00002430 F9                      		stc
 10996                                  PARSE_EXIT:				; depend on not changing CF
 10997 00002431 5E                      		pop	si
 10998 00002432 5F                      		pop	di
 10999 00002433 5A                      		pop	dx
 11000 00002434 59                      		pop	cx
 11001 00002435 5B                      		pop	bx
 11002 00002436 58                      		pop	ax
 11003 00002437 C3                      		retn
 11004                                  
 11005                                  ; =============== S U B	R O U T	I N E =======================================
 11006                                  
 11007                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 11008                                  ;
 11009                                  ; ENTRY:
 11010                                  ;   BH			argflags
 11011                                  ;   CX			character count in argstring
 11012                                  ;   DI			pointer to argstring
 11013                                  ;   comptr		ptr to starting loc of current token in original command
 11014                                  ;   [STARTEL]		cparse's answer to where the last element starts
 11015                                  ; EXIT:
 11016                                  ;   argbufptr		points to next free section of argbuffer
 11017                                  ;   arg.argbuf		contains null-terminated argument strings
 11018                                  ;   arg.argvcnt 	argument count
 11019                                  ;   arg.argv[]		array of flags and pointers
 11020                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 11021                                  ;   CF			set if error
 11022                                  ;   AL			carry set:  error code; otherwise, zero
 11023                                  
 11024                                  NEWARG:
 11025 00002438 53                      		push	bx
 11026 00002439 51                      		push	cx
 11027 0000243A 52                      		push	dx
 11028 0000243B 57                      		push	di
 11029 0000243C 56                      		push	si
 11030 0000243D 9C                      		pushf
 11031 0000243E E86600                  		call	ARG_SWITCH	; if it's a switch, record switch info
 11032                                  					; LEAVE SWITCH ON COMMAND LINE!!
 11033                                  		;;;jc	short newarg_done ; previous arg's switches -- and leave
 11034                                  
 11035                                  		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 11036 00002441 833E[6948]40            		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 11037 00002446 7D4F                    		jge	short TO_MANY_ARGS	; exceeded array limits
 11038 00002448 88FE                    		mov	dh,bh			
 11039                                  		;mov	bx,[ARG_ARGVCNT]	; save argflags	
 11040 0000244A 8B1E[6948]              		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 11041                                  		;inc	word [ARG_ARGVCNT]
 11042 0000244E FF06[6948]              		inc	word [ARG+ARG_UNIT.argvcnt]
 11043                                  		;mov	ax,ARG_ARGV
 11044 00002452 B8[A945]                		mov	ax,ARG+ARG_UNIT.argv
 11045 00002455 E88200                  		call	ARGV_CALC	; convert offset to pointer
 11046                                  		;mov	[BX].argsw_word,0 ; no switch information, yet...
 11047                                  		;mov	word [bx+7],0
 11048 00002458 C747070000              		mov	word [bx+ARGV_ELE.argsw_word],0
 11049                                  		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
 11050                                  		;mov	[bx+5],cx
 11051 0000245D 894F05                  		mov	[bx+ARGV_ELE.arglen],cx 
 11052                                  		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
 11053                                  		;mov	[bx+2],dh
 11054 00002460 887702                  		mov	[bx+ARGV_ELE.argflags],dh
 11055 00002463 8B36[ED4A]              		mov	si,[ARGBUFPTR]
 11056                                  		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
 11057                                  		;mov	[bx+ARGV_ELE.argpointer],si
 11058 00002467 8937                    		mov	[bx],si			
 11059 00002469 0336[9745]              		add	si,[STARTEL]		; save startel from new location
 11060 0000246D 29FE                    		sub	si,di			; form pointer into argbuf
 11061                                  		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 11062                                  		;mov	[bx+3],si
 11063 0000246F 897703                  		mov	[bx+ARGV_ELE.argstartel],si
 11064 00002472 8B36[714B]              		mov	si,[COMPTR]
 11065                                  		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 11066                                  		;mov	[bx+9],si
 11067 00002476 897709                  		mov	[bx+ARGV_ELE.arg_ocomptr],si
 11068                                  
 11069 00002479 89FE                    		mov	si,di			; now save argstring in argbuffer
 11070 0000247B 8B3E[ED4A]              		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
 11071 0000247F 01CF                    		add	di,cx			; sure we're not about to run off
 11072                                  		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 11073                                  		;cmp	di,ARG_ARGBUF+255
 11074 00002481 81FF[6C49]              		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 11075 00002485 7D15                    		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
 11076 00002487 29CF                    		sub	di,cx
 11077 00002489 FC                      		cld
 11078 0000248A F3A4                    		rep movsb
 11079 0000248C B000                    		mov	al,ANULL ; 0		; tack a null byte on the end
 11080 0000248E AA                      		stosb
 11081 0000248F 893E[ED4A]              		mov	[ARGBUFPTR],di		; update argbufptr after copy
 11082                                  
 11083                                  NEWARG_DONE:
 11084 00002493 9D                      		popf
 11085 00002494 F8                      		clc
 11086 00002495 EB0A                    		jmp	short NEWARG_EXIT
 11087                                  
 11088                                  TO_MANY_ARGS:
 11089 00002497 B80100                  		mov	ax,1
 11090 0000249A EB03                    		jmp	short NEWARG_ERROR
 11091                                  
 11092                                  BUF_OVFLOW:
 11093 0000249C B80200                  		mov	ax,2
 11094                                  NEWARG_ERROR:
 11095 0000249F 9D                      		popf
 11096 000024A0 F9                      		stc
 11097                                  NEWARG_EXIT:
 11098 000024A1 5E                      		pop	si
 11099 000024A2 5F                      		pop	di
 11100 000024A3 5A                      		pop	dx
 11101 000024A4 59                      		pop	cx
 11102 000024A5 5B                      		pop	bx
 11103 000024A6 C3                      		retn
 11104                                  
 11105                                  ; =============== S U B	R O U T	I N E =======================================
 11106                                  
 11107                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 11108                                  ; event that it is, and we can recognize
 11109                                  ;
 11110                                  ; ENTRY:
 11111                                  ;   As in <newarg>.
 11112                                  ; EXIT:
 11113                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 11114                                  ; NOTE(S):
 11115                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 11116                                  ;	on the order of definition in the <switch_list> variable and the
 11117                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 11118                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 11119                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 11120                                  ;   *	The <switch_list> declared below is redundant to one declared in
 11121                                  ;	TDATA.ASM, and used in TCODE.ASM.
 11122                                  ;   *	An ugly routine.
 11123                                  
 11124                                  ARG_SWITCH:
 11125 000024A7 50                      		push	ax
 11126 000024A8 53                      		push	bx
 11127 000024A9 51                      		push	cx
 11128 000024AA 57                      		push	di
 11129 000024AB 9C                      		pushf
 11130 000024AC F6C701                  		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
 11131 000024AF 741C                    		jz	short ARG_NO_SWITCH0
 11132 000024B1 833E[6F4B]FF            		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
 11133 000024B6 741B                    		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
 11134 000024B8 8B1E[6F4B]              		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
 11135                                  		;mov	ax,offset TRANGROUP:arg.argv
 11136                                  		;mov	ax,ARG_ARGV
 11137 000024BC B8[A945]                		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 11138 000024BF E81800                  		call	ARGV_CALC
 11139                                  		;or	[BX].argsw_word,BP
 11140                                  		;or	[bx+7],bp
 11141 000024C2 096F07                  		or	[bx+ARGV_ELE.argsw_word],bp
 11142                                  		;or	arg.argswinfo,BP
 11143                                  		;or	[ARG_ARGSWINFO],bp
 11144 000024C5 092E[6B48]              		or	[ARG+ARG_UNIT.argswinfo],bp
 11145                                  ARG_YES_SWITCH:
 11146 000024C9 9D                      		popf
 11147 000024CA F9                      		stc
 11148 000024CB EB08                    		jmp	short ARG_SWITCH_EXIT
 11149                                  
 11150                                  ARG_NO_SWITCH0:
 11151                                  		;mov	ax,[ARG_ARGVCNT]
 11152 000024CD A1[6948]                		mov	ax,[ARG+ARG_UNIT.argvcnt]
 11153 000024D0 A3[6F4B]                		mov	[LASTARG],ax
 11154                                  ARG_NO_SWITCH1:
 11155 000024D3 9D                      		popf
 11156 000024D4 F8                      		clc
 11157                                  ARG_SWITCH_EXIT:
 11158 000024D5 5F                      		pop	di
 11159 000024D6 59                      		pop	cx
 11160 000024D7 5B                      		pop	bx
 11161 000024D8 58                      		pop	ax
 11162 000024D9 C3                      		retn
 11163                                  
 11164                                  ; =============== S U B	R O U T	I N E =======================================
 11165                                  
 11166                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 11167                                  ; the supplied array.  Method used for computing the address is:
 11168                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 11169                                  ; ENTRY:
 11170                                  ;   AX	    --	    base of array
 11171                                  ;   BX	    --	    array index
 11172                                  ; EXIT:
 11173                                  ;   BX	    --	    byte offset
 11174                                  
 11175                                  ARGV_CALC:
 11176 000024DA 50                      		push	ax		; Save base
 11177 000024DB 88D8                    		mov	al,bl		; al = array index
 11178                                  		;mov	bl,11
 11179 000024DD B30B                    		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 11180 000024DF F6E3                    		mul	bl		; ax = base offset
 11181 000024E1 5B                      		pop	bx		; Get base
 11182 000024E2 01D8                    		add	ax,bx		; Add in base offset
 11183 000024E4 93                      		xchg	ax,bx		; Restore ax and put byte offset in bx
 11184 000024E5 C3                      		retn
 11185                                  
 11186                                  ; ---------------------------------------------------------------------------
 11187                                  	
 11188                                  		;db 0Ah dup(0)
 11189                                  		;times 10 db 0
 11190 000024E6 90<rep Ah>              align 16
 11191                                  
 11192                                  ;============================================================================
 11193                                  ; PATH1.ASM, MSDOS 6.0, 1991
 11194                                  ;============================================================================
 11195                                  ; 03/10/2018 - Retro DOS v3.0
 11196                                  
 11197                                  ;----------------------------------------------------------------------------
 11198                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 11199                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 11200                                  ;    given a pathname, attempts to find a corresponding executable or batch
 11201                                  ;    file on disk. Directories specified in the user's search path will be
 11202                                  ;    searched for a matching file, if a match is not found in the current
 11203                                  ;    directory and if the pathname is actually only an MSDOS filename.
 11204                                  ;    <Path_Search> assumes that the parsed command name can be found in
 11205                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 11206                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 11207                                  ;    information could be placed in argv[0], or <Path_Search> could be
 11208                                  ;    (easily) modified to make no assumptions about where its input is found.
 11209                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 11210                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 11211                                  ;    allocated memory. This is handy for for-loop processing, and anything
 11212                                  ;    else that wants to save the whole shebang and then process other command
 11213                                  ;    lines.
 11214                                  ;
 11215                                  ; Alan L, OS/MSDOS				    August 15, 1983
 11216                                  ;
 11217                                  ; ENTRY:
 11218                                  ;   <Path_Search>:	    argv[0].
 11219                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 11220                                  ; EXIT:
 11221                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 11222                                  ;   <Save_Args>:	    success flag, segment address of new memory
 11223                                  ; NOTE(S):
 11224                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 11225                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 11226                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 11227                                  ;	does not function as specified; see <Parseline> for more details.
 11228                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 11229                                  ;	need to know about. This extra information is stored in a switch_flag
 11230                                  ;	word with each command-line argument; the switches themselves will not
 11231                                  ;	appear in the resulting arg structure.
 11232                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 11233                                  ;----------------------------------------------------------------------------
 11234                                  
 11235                                  ; =============== S U B	R O U T	I N E =======================================
 11236                                  
 11237                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 11238                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 11239                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 11240                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 11241                                  ; have a match, either in the current working directory if we were handed
 11242                                  ; a filename, or in the specified directory, given a pathname. If this call
 11243                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 11244                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 11245                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 11246                                  ; either the first invocation of search or on one of the succeeding calls
 11247                                  ; sets up the appropriate information for copying the successful pathname
 11248                                  ; prefix (if any) into the result buffer, followed by the successful filename
 11249                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 11250                                  ;
 11251                                  ; ENTRY:
 11252                                  ;   argv[0]		--	command name and associated information
 11253                                  ; EXIT:
 11254                                  ;   AX			--	non-zero indicates type of file found
 11255                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 11256                                  ; NOTE(S):
 11257                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 11258                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 11259                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 11260                                  ;	if search returns an .exe or .bat.
 11261                                  ;   5)	Clobbers dma address.
 11262                                  
 11263                                  PBUFLEN 	EQU	128		; length of EXECPATH
 11264                                  PATH_SEP_CHAR	EQU	';'
 11265                                  
 11266                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 11267                                  
 11268                                  		;special_delim equ 128
 11269                                  		;path_sep equ 4
 11270                                  		;wildcard equ 2
 11271                                  		;sw_flag  equ 1
 11272                                  
 11273                                  ;----------------------------------------------------------------------------
 11274                                  
 11275                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 11276                                  
 11277                                  PATH_SEARCH:
 11278 000024F0 53                      		push	bx
 11279 000024F1 51                      		push	cx
 11280 000024F2 52                      		push	dx		; could use a "stack 'em" instruction
 11281 000024F3 56                      		push	si
 11282 000024F4 57                      		push	di
 11283 000024F5 55                      		push	bp
 11284 000024F6 9C                      		pushf
 11285                                  
 11286                                  		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 11287                                  		;test	byte [ARGV0_ARG_FLAGS],3
 11288 000024F7 F606[AB45]03            		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
 11289 000024FC 7403                    		jz	short PATH_SEARCH_OK
 11290                                  
 11291                                  PATH_FAILURE_JMP:
 11292 000024FE E9C300                  		jmp	PATH_FAILURE	; ambiguous commands not allowed
 11293                                  
 11294                                  PATH_SEARCH_OK:
 11295 00002501 E83C01                  		call	STORE_PCHAR	; figure out the pathname separator
 11296 00002504 BA[734B]                		mov	dx,FBUF		; clobber old dma value with
 11297 00002507 B8001A                  		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
 11298 0000250A CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11299                                  				; DS:DX	-> disk	transfer buffer
 11300 0000250C 06                      		push	es
 11301 0000250D E87FF2                  		call	FIND_PATH	; get a handle (ES:DI) on user path
 11302 00002510 8C06[9E4B]              		mov	[PATHINFO+0],es	; and squirrel it away
 11303 00002514 893E[A04B]              		mov	[PATHINFO+2],di	; "old" pathstring pointer
 11304 00002518 893E[A24B]              		mov	[PATHINFO+4],di	; "new" pathstring pointer
 11305 0000251C 07                      		pop	es
 11306                                  		
 11307 0000251D BB8000                  		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 11308 00002520 BE[9941]                		mov	si,EXECPATH
 11309 00002523 E84B02                  		call	STRIP
 11310 00002526 72D6                    		jc	short PATH_FAILURE_JMP ; if possible, of course
 11311                                  		
 11312 00002528 89F2                    		mov	dx,si		; search (EXECPATH, error_message)
 11313 0000252A C706[F34B][4939]        		mov	word [SEARCH_ERROR],BADDRVPTR
 11314 00002530 E88301                  		call	PSEARCH		; must do at least one search
 11315 00002533 09C0                    		or	ax,ax		; find anything?
 11316 00002535 746B                    		jz	short PATH_NOINIT ; failure ... search farther	
 11317                                  		
 11318 00002537 89C5                    		mov	bp,ax		; success... save filetype code	
 11319 00002539 BF[9941]                		mov	di,EXECPATH
 11320                                  		;mov	si,ds:arg.argv[0].argpointer
 11321                                  		;mov	si,[ARG_ARGV]
 11322 0000253C 8B36[A945]              		mov	si,[ARG+ARGV_ELE.argpointer]
 11323                                  		;mov	cx,ds:arg.argv[0].argstartel
 11324                                  		;mov	cx,[ARGV0_ARGSTARTEL]
 11325 00002540 8B0E[AC45]              		mov	cx,[ARG+ARGV_ELE.argstartel]
 11326 00002544 29F1                    		sub	cx,si		; compute prefix bytes to copy
 11327                                  
 11328                                  ; We have the number of bytes in the prefix (up to the final component).
 11329                                  ; We need to form the complete pathname including leading drive and current
 11330                                  ; directory.
 11331                                  ;
 11332                                  ; Is there a drive letter present?
 11333                                  
 11334 00002546 B43A                    		mov	ah,':'
 11335 00002548 83F902                  		cmp	cx,2		; room for drive letter?
 11336 0000254B 7205                    		jb	short ADDDRIVE	; no, stick it in
 11337 0000254D 386401                  		cmp	[si+1],	ah	; colon present?
 11338 00002550 7408                    		jz	short MOVEDRIVE	; yes, just move it
 11339                                  ADDDRIVE:
 11340 00002552 A0[8542]                		mov	al,[CURDRV]	; get current drive
 11341 00002555 0441                    		add	al,'A'		; convert to uppercase letter
 11342 00002557 AB                      		stosw			; store d:
 11343 00002558 EB05                    		jmp	short CHECKPATH
 11344                                  
 11345                                  MOVEDRIVE:
 11346 0000255A AD                      		lodsw			; move d:
 11347 0000255B AB                      		stosw
 11348 0000255C 83E902                  		sub	cx,2		; 2 bytes less to move
 11349                                  CHECKPATH:
 11350 0000255F 0C20                    		or	al,20h
 11351 00002561 88C2                    		mov	dl,al		
 11352                                  		;sub	dl,60h
 11353 00002563 80EA60                  		sub	dl,'a'-1	; convert to 1-based for current dir
 11354                                  
 11355                                  ; Stick in beginning path char
 11356                                  
 11357 00002566 A0[A44B]                		mov	al,[PSEP_CHAR]
 11358 00002569 AA                      		stosb
 11359                                  
 11360                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 11361                                  ; Otherwise, get current dir for DL.
 11362                                  
 11363 0000256A 83F901                  		cmp	cx,1		; is there room for path char?
 11364 0000256D 720A                    		jb	short ADDPATH	; no, go add path
 11365 0000256F AC                      		lodsb
 11366 00002570 49                      		dec	cx
 11367 00002571 3A06[A44B]              		cmp	al,[PSEP_CHAR]	; is there a path separator?
 11368 00002575 741E                    		jz	short MOVEPATH	; yes, go move remainder of path
 11369 00002577 41                      		inc	cx
 11370 00002578 4E                      		dec	si		; undo the lodsb
 11371                                  ADDPATH:
 11372 00002579 56                      		push	si
 11373 0000257A 89FE                    		mov	si,di		; remainder of buffer
 11374 0000257C B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11375 0000257F CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11376                                  				; DL = drive (0=default,1=A,etc.)
 11377                                  				; DS:SI	points to 64-byte buffer area
 11378                                  
 11379                                  ; The previous current dir will succeed a previous find_first already worked.
 11380                                  ;
 11381                                  ; Find end of string.
 11382                                  
 11383 00002581 89F7                    		mov	di,si
 11384 00002583 5E                      		pop	si
 11385 00002584 A0[A44B]                		mov	al,[PSEP_CHAR]
 11386 00002587 803D00                  		cmp	byte [di],0	; root (empty dir string)?
 11387 0000258A 7409                    		jz	short MOVEPATH	; yes, no need for path char
 11388                                  SCANEND:
 11389 0000258C 803D00                  		cmp	byte [di],0	; end of string?
 11390 0000258F 7403                    		jz	short FOUNDEND
 11391 00002591 47                      		inc	di
 11392 00002592 EBF8                    		jmp	short SCANEND
 11393                                  
 11394                                  ; Stick in a trailing path char.
 11395                                  
 11396                                  FOUNDEND:
 11397 00002594 AA                      		stosb
 11398                                  
 11399                                  ; Move remaining part of path.	Skip leading path char if present.
 11400                                  
 11401                                  MOVEPATH:
 11402 00002595 3804                    		cmp	[si],al		; first char a path char?
 11403 00002597 7502                    		jnz	short COPYPATH
 11404 00002599 46                      		inc	si		; move past leading char
 11405 0000259A 49                      		dec	cx		; drop from count
 11406                                  COPYPATH:
 11407 0000259B E302                    		jcxz	_COPYDONE	; no chars to move!	
 11408 0000259D F3A4                    		rep movsb
 11409                                  _COPYDONE:
 11410 0000259F E98900                  		jmp	PATH_SUCCESS	; run off and form complete pathname
 11411                                  
 11412                                  PATH_NOINIT:
 11413                                  		;test	ds:arg.argv[0].argflags, MASK path_sep
 11414                                  		;test	byte [ARGV0_ARG_FLAGS],4
 11415 000025A2 F606[AB45]04            		test	byte [ARG+ARGV_ELE.argflags],path_sep
 11416 000025A7 751B                    		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
 11417                                  		;mov	bh,';'
 11418 000025A9 B73B                    		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
 11419                                  		;mov	dx,ds:arg.argv[0].argstartel
 11420                                  					; this is where the last element starts
 11421                                  		;mov	dx,[ARGV0_ARGSTARTEL]
 11422 000025AB 8B16[AC45]              		mov	dx,[ARG+ARGV_ELE.argstartel]
 11423                                  		;sub	dx,ds:arg.argv[0].argpointer
 11424                                  					; form pointer into EXECPATH,
 11425                                  		;sub	dx,[ARG_ARGV]
 11426 000025AF 2B16[A945]              		sub	dx,[ARG+ARGV_ELE.argpointer]
 11427 000025B3 81C2[9941]              		add	dx,EXECPATH	; skipping over drive spec, if any
 11428                                  PATH_LOOP:
 11429 000025B7 E89A00                  		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
 11430 000025BA 89C5                    		mov	bp,ax		; save filetype code
 11431 000025BC 9F                      		lahf			; save flags, just in case
 11432 000025BD 09ED                    		or	bp,bp		; did path_crunch find anything?		
 11433 000025BF 7507                    		jnz	short PATH_FOUND 
 11434 000025C1 9E                      		sahf			; see?	needed those flags, after all!
 11435 000025C2 73F3                    		jnb	short PATH_LOOP	; is there anything left to the path?
 11436                                  PATH_FAILURE:
 11437 000025C4 31C0                    		xor	ax,ax
 11438 000025C6 EB70                    		jmp	short PATH_EXIT
 11439                                  
 11440                                  PATH_FOUND:				; pathinfo[] points to winner
 11441 000025C8 BF[9941]                		mov	di,EXECPATH
 11442                                  		;mov	cx,pathinfo[4] 
 11443 000025CB 8B0E[A24B]              		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
 11444                                  		;mov	SI,pathinfo[2]
 11445 000025CF 8B36[A04B]              		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string
 11446                                  
 11447                                  ;	BAS Nov 20/84
 11448                                  ;   Look at the pathname and expand . and .. if they are the first element
 11449                                  ;   in the pathname (after the drive letter)
 11450                                  
 11451 000025D3 06                      		push	es
 11452                                  		;push	pathinfo[0]
 11453 000025D4 FF36[9E4B]              		push	word [PATHINFO+0]
 11454 000025D8 07                      		pop	es
 11455                                  ;SR;
 11456                                  ; Oops! Gets fooled if path= \;..
 11457                                  ; We should also check if a drive letter is really present
 11458                                  ;
 11459 000025D9 26807C022E              		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
 11460 000025DE 7534                    		jnz	short PATH_CPY
 11461                                  
 11462                                  		; MSDOS 6.0
 11463                                  		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
 11464                                  		;jnz	path_cpy	       ;no, copy the path string
 11465                                  
 11466 000025E0 51                      		push	cx		; Save pointer to end of string
 11467 000025E1 268A04                  		mov	al,[es:si]
 11468 000025E4 8805                    		mov	[di],al		; Copy drive letter, :, and root char
 11469 000025E6 268A4401                		mov	al,[es:si+1]	; to EXECPATH
 11470 000025EA 884501                  		mov	[di+1],al
 11471 000025ED A0[A44B]                		mov	al,[PSEP_CHAR]
 11472 000025F0 884502                  		mov	[di+2],	al
 11473 000025F3 56                      		push	si		; Save pointer to begining of string
 11474 000025F4 268A14                  		mov	dl,[es:si]	; Convert device letter for cur dir
 11475 000025F7 80CA20                  		or	dl,20h
 11476                                  		;sub	dl,60h
 11477 000025FA 80EA60                  		sub	dl,'a'-1
 11478 000025FD 89FE                    		mov	si,di		; pointer to EXECPATH
 11479 000025FF 83C603                  		add	si,3		; Don't wipe out drive and root info
 11480 00002602 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11481 00002605 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11482                                  				; DL = drive (0=default,1=A,etc.)
 11483                                  				; DS:SI	points to 64-byte buffer area
 11484 00002607 E8B2F8                  		call	DSTRLEN		; Determine length of present info
 11485 0000260A 01CE                    		add	si,cx		; Don't copy over drive and root info
 11486 0000260C 4E                      		dec	si
 11487 0000260D 89F7                    		mov	di,si		; Point to end of target string
 11488 0000260F 5E                      		pop	si		; Restore pointer to begining of string
 11489 00002610 83C603                  		add	si,3		; Point past drive letter, :, .
 11490 00002613 59                      		pop	cx		; Restore pointer to end of string
 11491                                  PATH_CPY:
 11492 00002614 07                      		pop	es
 11493 00002615 29F1                    		sub	cx,si		; yields character count
 11494 00002617 1E                      		push	ds		; time to switch segments
 11495 00002618 FF36[9E4B]              		push	word [PATHINFO+0] ; string lives in this segment
 11496 0000261C 1F                      		pop	ds
 11497 0000261D FC                      		cld
 11498 0000261E F3A4                    		rep movsb
 11499 00002620 1F                      		pop	ds		; return to our segment
 11500 00002621 4F                      		dec	di		; overwrite terminator
 11501 00002622 A0[A44B]                		mov	al,[PSEP_CHAR]	; with a pathname separator
 11502 00002625 3A45FF                  		cmp	al,[di-1]
 11503 00002628 7401                    		jz	short PATH_SUCCESS
 11504 0000262A AA                      		stosb
 11505                                  PATH_SUCCESS:
 11506 0000262B BE[A64B]                		mov	si,SEARCH_BEST_BUF
 11507 0000262E 31C9                    		xor	cx,cx
 11508                                  PATH_SUCC_LOOP:
 11509 00002630 AC                      		lodsb			; append winning filename to path
 11510 00002631 AA                      		stosb			; (including terminating null)	
 11511 00002632 08C0                    		or	al,al
 11512 00002634 75FA                    		jnz	short PATH_SUCC_LOOP
 11513 00002636 89E8                    		mov	ax,bp		; retrieve filetype code
 11514                                  PATH_EXIT:
 11515 00002638 9D                      		popf
 11516 00002639 5D                      		pop	bp
 11517 0000263A 5F                      		pop	di
 11518 0000263B 5E                      		pop	si		; chill out...
 11519 0000263C 5A                      		pop	dx
 11520 0000263D 59                      		pop	cx
 11521 0000263E 5B                      		pop	bx
 11522 0000263F C3                      		retn
 11523                                  
 11524                                  
 11525                                  ; =============== S U B	R O U T	I N E =======================================
 11526                                  
 11527                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 11528                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 11529                                  ;
 11530                                  ; ENTRY:
 11531                                  ; EXIT:
 11532                                  ; NOTE(S):
 11533                                  ;   *	Uses <psep_char>, defined in <path_search>.
 11534                                  
 11535                                  STORE_PCHAR:
 11536 00002640 50                      		push	ax
 11537 00002641 B02F                    		mov	al,'/'		; is the pathname-element separator
 11538 00002643 E8C6F3                  		call	PATHCHRCMP	; a regular slash?
 11539 00002646 7407                    		jz	short STORE_SLASH ; if yes, remember slash
 11540 00002648 B05C                    		mov	al,'\'
 11541 0000264A A2[A44B]                		mov	[PSEP_CHAR],al	; otherwise, remember back-slash
 11542 0000264D 58                      		pop	ax
 11543 0000264E C3                      		retn
 11544                                  STORE_SLASH:
 11545 0000264F A2[A44B]                		mov	[PSEP_CHAR],al
 11546 00002652 58                      		pop	ax
 11547 00002653 C3                      		retn
 11548                                  
 11549                                  ; =============== S U B	R O U T	I N E =======================================
 11550                                  
 11551                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 11552                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 11553                                  ; additional separator to use for breaking up the path-string. Null is the
 11554                                  ; default. Once the user-string has been formed, search is invoked to see
 11555                                  ; what's out there.
 11556                                  ;
 11557                                  ; ENTRY:
 11558                                  ;   BH			--	additional terminator character
 11559                                  ;   SI			--	pointer into pathstring to be dissected
 11560                                  ;   DX			--	pointer to stripped filename
 11561                                  ; EXIT:
 11562                                  ;   AX			--	non-zero (file type), zero (nothing found)
 11563                                  ;   SI			--	moves along pathstring from call to call
 11564                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 11565                                  ;   [tpbuf]		--	clobbered
 11566                                  ; NOTE(S):
 11567                                  ;   *	Implicit in this code is the ability to specify when to search
 11568                                  ;	the current directory (if at all) through the PATH defined by
 11569                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 11570                                  ;	current directory before the bin and etc directories of drive c).
 11571                                  
 11572                                  PATH_CRUNCH:
 11573 00002654 53                      		push	bx
 11574 00002655 51                      		push	cx
 11575 00002656 52                      		push	dx
 11576 00002657 57                      		push	di
 11577 00002658 56                      		push	si
 11578 00002659 9C                      		pushf
 11579 0000265A E8E3FF                  		call	STORE_PCHAR	; figure out pathname separator
 11580 0000265D BF[EF4A]                		mov	di,TPBUF	; destination of concatenated string
 11581 00002660 8B36[A24B]              		mov	si,[PATHINFO+4]	; "new" pointer to start with
 11582 00002664 8936[A04B]              		mov	[PATHINFO+2],si	; becomes "old" pointer
 11583 00002668 1E                      		push	ds		; save old segment pointer
 11584 00002669 FF36[9E4B]              		push	word [PATHINFO+0] ; replace with pointer to userpath's
 11585 0000266D 1F                      		pop	ds		; segment		
 11586                                  PATH_CR_COPY:
 11587 0000266E AC                      		lodsb			; get a pathname byte
 11588 0000266F 08C0                    		or	al,al		; check for terminator(s)
 11589 00002671 7407                    		jz	short PATH_SEG	; null terminates segment & pathstring
 11590 00002673 38F8                    		cmp	al,bh
 11591 00002675 7403                    		jz	short PATH_SEG	; BH terminates a pathstring segment
 11592 00002677 AA                      		stosb
 11593 00002678 EBF4                    		jmp	short PATH_CR_COPY
 11594                                  
 11595                                  PATH_SEG:
 11596 0000267A 1F                      		pop	ds		; restore old data segment
 11597 0000267B 8936[A24B]              		mov	[PATHINFO+4],si	; save "new" pointer for next time
 11598 0000267F 88C3                    		mov	bl,al		; remember if we saw null or not...
 11599                                  					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 11600 00002681 31C0                    		xor	ax,ax		; in case nothing in pathstr...
 11601 00002683 81FF[EF4A]              		cmp	di,TPBUF	; was there really anything in pathstr?		
 11602 00002687 741D                    		jz	short PATH_CR_LEAVE 
 11603                                  					; if nothing was copied, pathstr empty
 11604                                  PATH_CR_LOOK:
 11605 00002689 A0[A44B]                		mov	al,[PSEP_CHAR]	; form complete pathname
 11606 0000268C 3A45FF                  		cmp	al,[di-1]	; add pathname separator for suffix
 11607 0000268F 7401                    		jz	short PATH_CR_L1
 11608 00002691 AA                      		stosb
 11609                                  PATH_CR_L1:
 11610 00002692 89D6                    		mov	si,dx
 11611                                  PATH_CR_L2:
 11612 00002694 AC                      		lodsb			; tack the stripped filename onto
 11613 00002695 AA                      		stosb			; the end of the path, up to and
 11614 00002696 08C0                    		or	al,al		; including the terminating null
 11615 00002698 75FA                    		jnz	short PATH_CR_L2
 11616 0000269A BA[EF4A]                		mov	dx,TPBUF	; and look for an appropriate file...	
 11617 0000269D C706[F34B][403C]        		mov	word [SEARCH_ERROR],BADPMESPTR
 11618                                  		;invoke search
 11619 000026A3 E81000                  		call	PSEARCH		; results are in AX & search_best_buf
 11620                                  
 11621                                  PATH_CR_LEAVE:
 11622 000026A6 08DB                    		or	bl,bl		; did we finish off the pathstring?
 11623 000026A8 7404                    		jz	short PATH_CR_EMPTY ; null in BL means all gone...
 11624 000026AA 9D                      		popf			; otherwise, plenty left
 11625 000026AB F8                      		clc
 11626 000026AC EB02                    		jmp	short PATH_CR_EXIT
 11627                                  
 11628                                  PATH_CR_EMPTY:
 11629 000026AE 9D                      		popf
 11630 000026AF F9                      		stc
 11631                                  PATH_CR_EXIT:
 11632 000026B0 5E                      		pop	si
 11633 000026B1 5F                      		pop	di
 11634 000026B2 5A                      		pop	dx
 11635 000026B3 59                      		pop	cx
 11636 000026B4 5B                      		pop	bx
 11637 000026B5 C3                      		retn
 11638                                  
 11639                                  ;============================================================================
 11640                                  ; PATH2.ASM, MSDOS 6.0, 1991
 11641                                  ;============================================================================
 11642                                  ; 02/10/2018 - Retro DOS v3.0
 11643                                  
 11644                                  ;----------------------------------------------------------------------------
 11645                                  ;   SEARCH, when given a pathname, attempts to find a file with
 11646                                  ; one of the following extensions: .com, .exe, .bat (highest to
 11647                                  ; lowest priority). Where conflicts arise, the extension with
 11648                                  ; the highest priority is favored.
 11649                                  ; ENTRY:
 11650                                  ;   DX		--	pointer to null-terminated pathname
 11651                                  ;   fbuf	--	dma buffer for findfirst/next
 11652                                  ; EXIT:
 11653                                  ;   AX		--	8)  file found with .com extension
 11654                                  ;			4)  file found with .exe extension
 11655                                  ;			2)  file found with .bat extension
 11656                                  ;			0)  no such file to be found
 11657                                  ;   (if AX is non-zero:)
 11658                                  ;   [search_best]	identical to AX
 11659                                  ;   [search_best_buf]	null-terminated filename
 11660                                  ; NOTES:
 11661                                  ;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
 11662                                  ;---------------
 11663                                  ; CONSTANTS:
 11664                                  ;---------------
 11665                                  SEARCH_FILE_NOT_FOUND	EQU	0
 11666                                  SEARCH_COM		EQU	8
 11667                                  SEARCH_EXE		EQU	4
 11668                                  SEARCH_BAT		EQU	2
 11669                                  FNAME_LEN		EQU	8
 11670                                  FNAME_MAX_LEN		EQU	13
 11671                                  DOT			EQU	'.'
 11672                                  WILDCHAR		EQU	'?'
 11673                                  
 11674                                  
 11675                                  ; =============== S U B	R O U T	I N E =======================================
 11676                                  
 11677                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 11678                                  
 11679                                  PSEARCH:
 11680 000026B6 51                      		push	cx
 11681 000026B7 52                      		push	dx
 11682 000026B8 57                      		push	di
 11683 000026B9 56                      		push	si
 11684 000026BA 9C                      		pushf
 11685 000026BB 52                      		push	dx		; check drivespec (save pname ptr)
 11686 000026BC 89D7                    		mov	di,dx		; working copy of pathname
 11687 000026BE BE[B34B]                		mov	si,SEARCH_CURDIR_BUF
 11688 000026C1 31D2                    		xor	dx,dx		; zero means current drive
 11689 000026C3 807D013A                		cmp	byte [di+1],':'	; is there a drive spec?
 11690 000026C7 7508                    		jne	short SEARCH_DIR_CHECK
 11691 000026C9 8A15                    		mov	dl,[di]		; get the drive byte
 11692 000026CB 80E2DF                  		and	dl,0DFh ; ~20h	; uppercase the sucker
 11693 000026CE 80EA40                  		sub	dl,'@'		; and convert to drive number
 11694                                  SEARCH_DIR_CHECK:
 11695 000026D1 B80047                  		mov	ax,CURRENT_DIR*256 ; 4700h
 11696 000026D4 CD21                    		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 11697                                  				; DL = drive (0=default,1=A,etc.)
 11698                                  				; DS:SI	points to 64-byte buffer area
 11699 000026D6 5A                      		pop	dx		; directory? If we can't we'll		
 11700 000026D7 723F                    		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
 11701 000026D9 B91300                  		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
 11702 000026DC B8004E                  		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
 11703 000026DF CD21                    		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11704                                  				; CX = search attributes
 11705                                  				; DS:DX	-> ASCIZ filespec
 11706                                  				; (drive,path,	and wildcards allowed)
 11707 000026E1 723C                    		jc	short SEARCH_NO_FILE
 11708 000026E3 C606[A54B]00            		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
 11709 000026E8 C606[A64B]00            		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
 11710                                  SEARCH_LOOP:
 11711 000026ED E83800                  		call	SEARCH_FTYPE	; determine if .com, &c...
 11712 000026F0 3A06[A54B]              		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
 11713 000026F4 7E13                    		jle	short SEARCH_NEXT ; no, look for another	
 11714 000026F6 A2[A54B]                		mov	[SEARCH_BEST],al ; found something... save its code	
 11715                                  		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 11716                                  		;mov	si,FBUF_PNAME
 11717 000026F9 BE[914B]                		mov	si,FBUF+FIND_BUF.PNAME
 11718 000026FC BF[A64B]                		mov	di,SEARCH_BEST_BUF
 11719 000026FF B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11720 00002702 FC                      		cld
 11721 00002703 F3A4                    		rep movsb		; save complete pathname representation
 11722 00002705 3C08                    		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
 11723 00002707 740A                    		je	short SEARCH_DONE
 11724                                  SEARCH_NEXT:				; keep on looking
 11725 00002709 B91300                  		mov	cx,SEARCH_ATTR ; 13h
 11726 0000270C B8004F                  		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
 11727 0000270F CD21                    		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 11728                                  				; [DTA]	= data block from
 11729                                  				; last AH = 4Eh/4Fh call
 11730 00002711 73DA                    		jnc	short SEARCH_LOOP
 11731                                  SEARCH_DONE:				; it's all over with...
 11732 00002713 A0[A54B]                		mov	al,[SEARCH_BEST] ; pick best to return with
 11733                                  		; MSDOS 6.0
 11734                                  		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
 11735                                  		;jz	search_exit	;AN005; no - exit
 11736                                  		;mov	al,ext_entered	;AN005; yes - get the real file type back
 11737                                  		;mov	search_best,al	;AN005; save the real file type
 11738                                  		;
 11739 00002716 EB0A                    		jmp	short SEARCH_EXIT
 11740                                  
 11741                                  SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
 11742 00002718 8B16[F34B]              		mov	dx,[SEARCH_ERROR] ; appropriate error message
 11743 0000271C E8B40D                  		call	STD_PRINTF	 ; and pretend no file found
 11744                                  
 11745                                  SEARCH_NO_FILE:				; couldn't find a match
 11746 0000271F B80000                  		mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 11747                                  
 11748                                  SEARCH_EXIT:
 11749 00002722 9D                      		popf
 11750 00002723 5E                      		pop	si
 11751 00002724 5F                      		pop	di
 11752 00002725 5A                      		pop	dx
 11753 00002726 59                      		pop	cx
 11754 00002727 C3                      		retn
 11755                                  
 11756                                  ; =============== S U B	R O U T	I N E =======================================
 11757                                  
 11758                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 11759                                  ;
 11760                                  ; ENTRY:
 11761                                  ;   fbuf    --	    dma buffer containing filename
 11762                                  ; EXIT:
 11763                                  ;   AX	    --	    file code, as given in search header
 11764                                  ; NOTE(S):
 11765                                  ;   *	Implicit assumption that NULL == search_file_not_found
 11766                                  
 11767                                  SEARCH_FTYPE:
 11768 00002728 57                      		push	di
 11769 00002729 56                      		push	si
 11770 0000272A B80000                  		mov	ax,ANULL ; 0	; find the end of the filename
 11771                                  		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 11772                                  		;mov	di,FBUF_PNAME
 11773 0000272D BF[914B]                		mov	di,FBUF+FIND_BUF.PNAME
 11774 00002730 B90D00                  		mov	cx,FNAME_MAX_LEN ; 13
 11775 00002733 FC                      		cld
 11776 00002734 F2AE                    		repnz scasb		; search for the terminating null
 11777 00002736 7536                    		jnz	short FTYPE_EXIT ; weird... no null byte at end
 11778 00002738 83EF05                  		sub	di,5		; . + E + X + T + NULL
 11779                                  
 11780                                  		; Compare .COM
 11781                                  
 11782 0000273B BE[113F]                		mov	si,COMEXT ; ".COM"
 11783 0000273E 89F8                    		mov	ax,di
 11784 00002740 A7                      		cmpsw
 11785 00002741 7508                    		jnz	short FTYPE_EXE
 11786 00002743 A7                      		cmpsw
 11787 00002744 7505                    		jnz	short FTYPE_EXE
 11788                                  		;mov	ax,8
 11789 00002746 B80800                  		mov	ax,SEARCH_COM	; success!
 11790 00002749 EB23                    		jmp	short FTYPE_EXIT
 11791                                  
 11792                                  		; Compare .EXE
 11793                                  FTYPE_EXE:				; still looking... now for '.exe'
 11794 0000274B 89C7                    		mov	di,ax
 11795 0000274D BE[153F]                		mov	si,EXEEXT ; ".EXE"
 11796 00002750 A7                      		cmpsw
 11797 00002751 7508                    		jnz	short FTYPE_BAT
 11798 00002753 A7                      		cmpsw
 11799 00002754 7505                    		jnz	short FTYPE_BAT
 11800                                  		;mov	ax,4
 11801 00002756 B80400                  		mov	ax,SEARCH_EXE	; success!
 11802 00002759 EB13                    		jmp	short FTYPE_EXIT
 11803                                  
 11804                                  		; Compare .BAT
 11805                                  FTYPE_BAT:				; still looking... now for '.bat'
 11806 0000275B 89C7                    		mov	di,ax
 11807 0000275D BE[193F]                		mov	si,BATEXT ; ".BAT"
 11808 00002760 A7                      		cmpsw
 11809 00002761 7508                    		jnz	short FTYPE_FAIL
 11810 00002763 A7                      		cmpsw
 11811 00002764 7505                    		jnz	short FTYPE_FAIL
 11812                                  		;mov	ax,2
 11813 00002766 B80200                  		mov	ax,SEARCH_BAT	; success!
 11814 00002769 EB03                    		jmp	short FTYPE_EXIT
 11815                                  
 11816                                  FTYPE_FAIL:				; file doesn't match what we need
 11817 0000276B B80000                  		mov	ax,ANULL ; 0
 11818                                  
 11819                                  FTYPE_EXIT:
 11820                                  		; MSDOS 6.0
 11821                                  		;cmp	ext_entered,1	;AN005; was an extension entered?
 11822                                  		;jz	ftype_done	;AN005; no - exit
 11823                                  		;cmp	ax,ANULL	;AN005; was any match found
 11824                                  		;jz	ftype_done	;AN005; no - exit
 11825                                  		;mov	ext_entered,al	;AN005; save the match type found
 11826                                  		;mov	AX,search_com	;AN005; send back best was found to stop search
 11827                                  ;ftype_done:
 11828 0000276E 5E                      		pop	si
 11829 0000276F 5F                      		pop	di
 11830 00002770 C3                      		retn
 11831                                  
 11832                                  ; =============== S U B	R O U T	I N E =======================================
 11833                                  
 11834                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 11835                                  ; replacing any extension with wildcards.
 11836                                  ;
 11837                                  ; ENTRY:
 11838                                  ;	BX		--		maximum length of destination buffer
 11839                                  ;	DS:SI		--		address of destination buffer
 11840                                  ;	argv[0] 	--		command name to be stripped
 11841                                  ; EXIT:
 11842                                  ;	CF		--		set if failure, clear if successful
 11843                                  ; NOTE(S):
 11844                                  
 11845                                  
 11846                                  STRIP:
 11847 00002771 50                      		push	ax
 11848 00002772 53                      		push	bx
 11849 00002773 51                      		push	cx
 11850 00002774 52                      		push	dx
 11851 00002775 57                      		push	di
 11852 00002776 56                      		push	si
 11853 00002777 9C                      		pushf
 11854                                  		
 11855                                  		; MSDOS 6.0
 11856                                  		;mov	ext_entered,1	;AN005; assume no extension on file name
 11857                                  
 11858                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11859                                  		;mov	dx,[ARG_ARGV]
 11860                                  		;mov	dx,ds:arg.argv[0].argpointer
 11861                                  					; save pointer to beginning of argstring
 11862                                  		;mov	dx,[ARGV0_ARGPOINTER]
 11863 00002778 8B16[A945]              		mov	dx,[ARG+ARGV_ELE.argpointer]
 11864                                  		;mov	di,ds:arg.argv[0].argstartel
 11865                                  					; beginning of last pathname element
 11866                                  		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 11867 0000277C 8B3E[AC45]              		mov	di,[ARG+ARGV_ELE.argstartel]
 11868 00002780 803D00                  		cmp	byte [di],0	; *STARTEL == NULL means no command
 11869 00002783 742E                    		je	short STRIP_ERROR
 11870 00002785 89D1                    		mov	cx,dx		; compute where end of argstring lies
 11871                                  		;add	cx,ds:arg.argv[0].arglen
 11872                                  		;add	cx,[ARGV0_ARGLEN]
 11873 00002787 030E[AE45]              		add	cx,[ARG+ARGV_ELE.arglen]
 11874 0000278B 29F9                    		sub	cx,di		; and then find length of last element
 11875 0000278D 41                      		inc	cx		; include null as well
 11876                                  		;mov	al,'.'
 11877 0000278E B02E                    		mov	al,DOT		; let's find the filetype extension
 11878 00002790 FC                      		cld
 11879 00002791 F2AE                    		repnz scasb		; wind up pointing to either null or dot
 11880                                  
 11881                                  		; MSDOS 6.0
 11882                                  		;jcxz	process_ext	;AN005; if no extension found, just continue
 11883                                  		;mov	ext_entered,0	;AN005; we found an extension
 11884                                  		;mov	al,ANULL	;AN005; continue scanning until the
 11885                                  		;repnz	scasb		;AN005;    end of line is reached.
 11886                                  PROCESS_EXT:
 11887                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11888 00002793 89F9                    		mov	cx,di		; pointer to end of argstring yields
 11889 00002795 29D1                    		sub	cx,dx		; number of bytes to be copied
 11890 00002797 83EB04                  		sub	bx,4		; can argstring fit into dest. buffer?
 11891 0000279A 39D9                    		cmp	cx,bx
 11892 0000279C 7F15                    		jg	short STRIP_ERROR ; if not, we must have a bad pathname
 11893 0000279E 89F7                    		mov	di,si		; destination buffer
 11894 000027A0 89D6                    		mov	si,dx		; source is beginning of pathname
 11895 000027A2 FC                      		cld
 11896 000027A3 F3A4                    		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 11897                                  
 11898                                  		; MSDOS 6.0
 11899                                  		;cmp	ext_entered,1	;AN005; if an extension was entered
 11900                                  		;jne	skip_wilds	;AN005;    don't set up wildcard ext.
 11901                                  
 11902                                  		; MSDOS 3.3 (& MSDOS 6.0)
 11903 000027A5 4F                      		dec	di		; overwrite null or dot
 11904 000027A6 AA                      		stosb			; with a dot
 11905                                  		;mov	al,'?'
 11906 000027A7 B03F                    		mov	al,WILDCHAR	; now add wildcards
 11907 000027A9 AA                      		stosb
 11908 000027AA AA                      		stosb
 11909 000027AB AA                      		stosb
 11910                                  		;mov	al,0
 11911 000027AC B000                    		mov	al,ANULL	; and a terminating null	
 11912 000027AE AA                      		stosb
 11913                                  SKIP_WILDS:
 11914 000027AF 9D                      		popf
 11915 000027B0 F8                      		clc
 11916 000027B1 EB02                    		jmp	short STRIP_EXIT ; chill out...
 11917                                  
 11918                                  STRIP_ERROR:
 11919 000027B3 9D                      		popf
 11920 000027B4 F9                      		stc
 11921                                  STRIP_EXIT:
 11922 000027B5 5E                      		pop	si
 11923 000027B6 5F                      		pop	di
 11924 000027B7 5A                      		pop	dx
 11925 000027B8 59                      		pop	cx
 11926 000027B9 5B                      		pop	bx
 11927 000027BA 58                      		pop	ax
 11928 000027BB C3                      		retn
 11929                                  
 11930                                  ; =============== S U B	R O U T	I N E =======================================
 11931                                  
 11932                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 11933                                  ;
 11934                                  ; structure in newly allocated memory. The argv[] structure is found at the
 11935                                  ; beginning of this area. The caller indicates how much extra space is
 11936                                  ; needed in the resulting structure; Save_Args returns a segment number and
 11937                                  ; an offset into that area, indicating where the caller may preserve its own
 11938                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 11939                                  ; ENTRY:
 11940                                  ;   BX	    --	    size (in bytes) of extra area to allocate
 11941                                  ; EXIT:
 11942                                  ;   AX	    --	    segment of new area.
 11943                                  ;   CF	    --	    set if unable to save a copy.
 11944                                  ; NOTE(S):
 11945                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 11946                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 11947                                  ;	paragraphs.
 11948                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 11949                                  ;	as the caller of Save_Args requests.
 11950                                  ;   3)	AX is undefined if CF indicates an error.
 11951                                  
 11952                                  SAVE_ARGS:
 11953 000027BC 53                      		push	bx
 11954 000027BD 51                      		push	cx
 11955 000027BE 52                      		push	dx
 11956 000027BF 57                      		push	di
 11957 000027C0 56                      		push	si
 11958 000027C1 55                      		push	bp
 11959 000027C2 9C                      		pushf
 11960                                  		;add	bx,1363		; space for arg structure, round up
 11961 000027C3 81C35305                		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 11962 000027C7 B104                    		mov	cl,4		; to paragraph size and convert
 11963 000027C9 D3EB                    		shr	bx,cl		; size in bytes to size in paragraphs
 11964 000027CB B80048                  		mov	ax,ALLOC*256 ; 4800h
 11965 000027CE CD21                    		int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11966                                  				; BX = number of 16-byte paragraphs desired
 11967 000027D0 7244                    		jc	short SAVE_ERROR
 11968 000027D2 89C5                    		mov	bp,ax		; save segment id
 11969 000027D4 06                      		push	es		; save TRANGROUP address
 11970 000027D5 8EC0                    		mov	es,ax		; switch to new memory segment
 11971                                  		; assume es:nothing
 11972                                  		;mov	cx,1348		; get back structure size
 11973 000027D7 B94405                  		mov	cx,ARG_UNIT.SIZE
 11974 000027DA 31FF                    		xor	di,di		; destination is new memory area
 11975                                  		;mov	si,ARG_ARGV
 11976 000027DC BE[A945]                		mov	si,ARG		; source is arg structure
 11977 000027DF F3A4                    		rep movsb		; move that sucker!
 11978                                  		;mov	cx,arg.argvcnt 	; adjust argv pointers
 11979                                  		;mov	cx,[ARG_ARGVCNT]
 11980 000027E1 8B0E[6948]              		mov	cx,[ARG+ARG_UNIT.argvcnt]
 11981 000027E5 31C0                    		xor	ax,ax		; base address for argv_calc
 11982                                  
 11983                                  	;	Bugbug:	What did they mean by this?
 11984                                  	;	Note that the replacement line produces exactly the same code.
 11985                                  	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 11986                                  	;	mov	SI, OFFSET TRANGROUP:arg
 11987                                  
 11988                                  		;mov	si,ARG_ARGV
 11989 000027E7 BE[A945]                		mov	si,ARG	
 11990                                  SAVE_PTR_LOOP:
 11991 000027EA 49                      		dec	cx		; exhausted all args?
 11992 000027EB 7C24                    		jl	short SAVE_DONE
 11993 000027ED 89CB                    		mov	bx,cx		; get arg index and
 11994 000027EF E8E8FC                  		call	ARGV_CALC	; convert to a pointer
 11995                                  		;mov	dx,ds:arg.argv[bx].argpointer
 11996                                  		;mov	dx,[ARG_ARGV+bx]
 11997 000027F2 8B97[A945]              		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 11998 000027F6 29F2                    		sub	dx,si		; adjust argpointer
 11999                                  		;mov	es:argv[BX].argpointer,dx
 12000                                  		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 12001 000027F8 268917                  		mov	[es:bx],dx
 12002                                  		;mov	dx,ds:arg.argv[bx].argstartel
 12003                                  		;mov	dx,[ARGV0_ARGSTARTEL+bx]
 12004 000027FB 8B97[AC45]              		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 12005 000027FF 29F2                    		sub	dx,si		; and adjust argstartel
 12006                                  		;mov	es:argv[bx].argstartel,dx
 12007                                  		;mov	[es:bx+3],dx
 12008 00002801 26895703                		mov	[es:bx+ARGV_ELE.argstartel],dx
 12009                                  		;mov	dx,ds:arg.argv[bx].arg_ocomptr
 12010                                  		;mov	dx,[ARGV0_OCOMPTR+bx]
 12011 00002805 8B97[B245]              		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 12012 00002809 29F2                    		sub	dx,si		; and adjust arg_ocomptr
 12013                                  		;mov	es:argv[bx].arg_ocomptr,dx
 12014                                  		;mov	[es:bx+9],dx
 12015 0000280B 26895709                		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 12016 0000280F EBD9                    		jmp	short SAVE_PTR_LOOP
 12017                                  SAVE_DONE:
 12018 00002811 07                      		pop	es		; back we go to TRANGROUP
 12019                                  		; assume es:nothing
 12020 00002812 89E8                    		mov	ax,bp		; restore segment id
 12021 00002814 EB04                    		jmp	short SAVE_OK
 12022                                  
 12023                                  SAVE_ERROR:
 12024 00002816 9D                      		popf
 12025 00002817 F9                      		stc
 12026 00002818 EB02                    		jmp	short SAVE_EXIT
 12027                                  
 12028                                  SAVE_OK:
 12029 0000281A 9D                      		popf
 12030 0000281B F8                      		clc
 12031                                  SAVE_EXIT:
 12032 0000281C 5D                      		pop	bp
 12033 0000281D 5E                      		pop	si
 12034 0000281E 5F                      		pop	di
 12035 0000281F 5A                      		pop	dx
 12036 00002820 59                      		pop	cx
 12037 00002821 5B                      		pop	bx
 12038 00002822 C3                      		retn
 12039                                  
 12040                                  ;============================================================================
 12041                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 12042                                  ;============================================================================
 12043                                  ; 02/10/2018 - Retro DOS v3.0
 12044                                  
 12045                                  ; Title	COMMAND Language midifiable Code Transient
 12046                                  
 12047                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 12048                                  
 12049                                  ; =============== S U B	R O U T	I N E =======================================
 12050                                  
 12051                                  ; ****************************************************************
 12052                                  ; *
 12053                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 12054                                  ; *
 12055                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 12056                                  ; *		 user for Y/N if necessary. If an error occurs,
 12057                                  ; *		 set up an error message and go to CERROR.
 12058                                  ; *
 12059                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 12060                                  ; *		 Current directory set to entered directory
 12061                                  ; *
 12062                                  ; * OUTPUT:	 none
 12063                                  ; *
 12064                                  ; ****************************************************************
 12065                                  ;
 12066                                  ; ARE YOU SURE prompt when deleting *.*
 12067                                  
 12068                                  NOTEST2:
 12069 00002823 B90B00                  		mov	cx,11
 12070 00002826 BE5D00                  		mov	si,FCB+1 ; 5Dh
 12071                                  AMBSPEC:
 12072 00002829 AC                      		lodsb
 12073 0000282A 3C3F                    		cmp	al,'?'
 12074 0000282C 7502                    		jnz	short ALLFIL
 12075 0000282E E2F9                    		loop	AMBSPEC
 12076                                  ALLFIL:
 12077 00002830 83F900                  		cmp	cx,0
 12078 00002833 7531                    		jnz	short NOPRMPT
 12079                                  ASKAGN:	
 12080 00002835 BA[EC3A]                		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
 12081 00002838 E8980C                  		call	STD_PRINTF
 12082 0000283B BE8000                  		mov	si,80h
 12083 0000283E 89F2                    		mov	dx,si
 12084 00002840 C7047800                		mov	word [si],120	; zero length
 12085                                  		;mov	ax,0C0Ah
 12086 00002844 B80A0C                  		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
 12087 00002847 CD21                    		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 12088                                  				; AL must be 01h,06h,07h,08h or 0Ah.
 12089 00002849 AD                      		lodsw
 12090 0000284A 08E4                    		or	ah,ah
 12091 0000284C 74E7                    		jz	short ASKAGN
 12092 0000284E E828F1                  		call	SCANOFF
 12093                                  		; MSDOS 6.0
 12094                                  		;call	char_in_xlat	; Convert to upper case
 12095                                  		;retc			; return if function not supported
 12096                                  		; MSDOS 3.3
 12097 00002851 E87E01                  		call	UPCONV
 12098                                  		
 12099                                  		;; MSDOS 3.3 (& MSDOS 6.0)
 12100 00002854 3A06[993D]              		cmp	al,[CAPITAL_N]
 12101 00002858 7501                    		jne	short CHECK_Y
 12102 0000285A C3                      		retn
 12103                                  CHECK_Y:
 12104 0000285B 3A06[983D]              		cmp	al,[CAPITAL_Y]
 12105 0000285F 9C                      		pushf
 12106 00002860 E809F1                  		call	CRLF2
 12107 00002863 9D                      		popf
 12108 00002864 75CF                    		jne	short ASKAGN
 12109                                  NOPRMPT:
 12110 00002866 B413                    		mov	ah,FCB_DELETE ; 13h
 12111 00002868 BA5C00                  		mov	dx,FCB ; 5Ch
 12112 0000286B CD21                    		int	21h	; DOS -	DELETE FILE via	FCB
 12113                                  				; DS:DX	-> FCB with filename field filled with
 12114                                  				; template for	deletion ('?' wildcard allowed,but not '*')
 12115                                  				; Return: AL = 00h file	found,FFh file	not found
 12116 0000286D FEC0                    		inc	al
 12117 0000286F 7404                    		jz	short ERAERR
 12118 00002871 E827F0                  		call	RESTUDIR
 12119 00002874 C3                      		retn
 12120                                  
 12121                                  		; MSDOS 6.0
 12122                                  ;eraerr:
 12123                                  		;invoke	set_ext_error_msg	;AN022; set up the extended error
 12124                                  		;push	dx			;AN022; save message
 12125                                  		;invoke	RESTUDIR
 12126                                  		;pop	dx			;AN022; restore message
 12127                                  		;
 12128                                  		;cmp	word ptr extend_buf_ptr,error_no_more_files 
 12129                                  		;				;AN022; convert no more files to
 12130                                  		;jnz	cerrorj2		;AN022; 	file not found
 12131                                  		;mov	Extend_Buf_ptr,error_file_not_found  
 12132                                  		;			;AN000; get message number in control block
 12133                                  ;cerrorj2:
 12134                                  		;jmp	cerror
 12135                                  	
 12136                                  		; MSDOS 3.3
 12137                                  ERAERR:	
 12138 00002875 B41A                    		mov	ah,SET_DMA ; 1Ah
 12139 00002877 BA5C00                  		mov	dx,FCB ; 5Ch
 12140 0000287A CD21                    		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 12141                                  					; DS:DX	-> disk	transfer buffer
 12142 0000287C B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h
 12143 0000287E CD21                    		int	21h		; DOS -	SEARCH FIRST USING FCB
 12144                                  					; DS:DX	-> FCB
 12145 00002880 50                      		push	ax
 12146 00002881 E817F0                  		call	RESTUDIR
 12147 00002884 58                      		pop	ax
 12148 00002885 BA[F837]                		mov	dx,FNOTFOUNDPTR
 12149 00002888 FEC0                    		inc	al
 12150 0000288A 743D                    		jz	short CERRORJ
 12151 0000288C BA[1D38]                		mov	dx,ACCDENPTR
 12152 0000288F E997F3                  		jmp	CERROR
 12153                                  
 12154                                  ; =============== S U B	R O U T	I N E =======================================
 12155                                  
 12156                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 12157                                  
 12158                                  ECHO:
 12159 00002892 E89400                  		call	ON_OFF
 12160 00002895 7212                    		jb	short DOEMES
 12161 00002897 8E1E[7142]              		mov	ds,[RESSEG]
 12162 0000289B 7506                    		jnz	short ECH_OFF
 12163 0000289D 800EED0B01              		or	byte [ECHOFLAG],1
 12164 000028A2 C3                      		retn
 12165                                  
 12166                                  ECH_OFF:
 12167 000028A3 8026ED0BFE              		and	byte [ECHOFLAG],0FEh
 12168 000028A8 C3                      		retn
 12169                                  
 12170                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 12171                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 12172                                  
 12173                                  DOEMES:
 12174                                  		; MSDOS 6.0
 12175                                  		;cmp	cl,0		;AC000; was anything on the line?
 12176                                  		;jz	PECHO		; just display current state.
 12177                                  		;MOV	DX,82H		; Skip one char after "ECHO"
 12178                                  		;invoke	CRPRINT
 12179                                  		;JMP	CRLF2
 12180                                  
 12181                                  		; MSDOS 3.3
 12182 000028A9 E82000                  		call	MOVE_TO_FIRST_ARG
 12183 000028AC 7409                    		jz	short PECHO
 12184 000028AE BA8200                  		mov	dx,82h
 12185 000028B1 E816F1                  		call	CRPRINT
 12186 000028B4 E9B5F0                  		jmp	CRLF2
 12187                                  
 12188                                  PECHO:
 12189                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12190 000028B7 8E1E[7142]              		mov	ds,[RESSEG]
 12191 000028BB 8A1EED0B                		mov	bl,byte [ECHOFLAG]
 12192 000028BF 0E                      		push	cs
 12193 000028C0 1F                      		pop	ds
 12194 000028C1 80E301                  		and	bl,1
 12195 000028C4 BA[1F3D]                		mov	dx,ECHOMESPTR
 12196 000028C7 EB2E                    		jmp	short PYN
 12197                                  
 12198                                  ; ---------------------------------------------------------------------------
 12199                                  
 12200                                  		; MSDOS 3.3
 12201                                  CERRORJ:
 12202 000028C9 E95DF3                  		jmp	CERROR
 12203                                  
 12204                                  
 12205                                  ; =============== S U B	R O U T	I N E =======================================
 12206                                  
 12207                                  MOVE_TO_FIRST_ARG:
 12208 000028CC BE8100                  		mov	si,81h
 12209 000028CF E8A7F0                  		call	SCANOFF
 12210 000028D2 3C0D                    		cmp	al,0Dh
 12211 000028D4 C3                      		retn
 12212                                  
 12213                                  ; =============== S U B	R O U T	I N E =======================================
 12214                                  
 12215                                  CNTRLC:
 12216 000028D5 E85100                  		call	ON_OFF
 12217 000028D8 B80133                  		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
 12218 000028DB 720C                    		jc	short PCNTRLC
 12219 000028DD 7505                    		jnz	short CNTRLC_OFF
 12220 000028DF B201                    		mov	dl,1
 12221 000028E1 CD21                    		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 12222                                  				; AL = 00h get state / 01h set state / 02h set AND get
 12223                                  				; DL = 00h for OFF or 01h for ON
 12224 000028E3 C3                      		retn
 12225                                  
 12226                                  ; ---------------------------------------------------------------------------
 12227                                  
 12228                                  CNTRLC_OFF:
 12229 000028E4 30D2                    		xor	dl,dl
 12230 000028E6 CD21                    		int	21h		; Turn off ^C check
 12231 000028E8 C3                      		retn
 12232                                  
 12233                                  ; ---------------------------------------------------------------------------
 12234                                  
 12235                                  PCNTRLC:
 12236                                  		; MSDOS 6.0
 12237                                  		;CMP	CL,0		;AC000; rest of line blank?
 12238                                  		;JNZ	CERRORJ 	; no, oops!
 12239                                  
 12240                                  		; MSDOS 3.3
 12241 000028E9 E8E0FF                  		call	MOVE_TO_FIRST_ARG
 12242 000028EC 75DB                    		jnz	short CERRORJ
 12243                                  ;pccont:
 12244                                  		; MSDOS 3.3 (& MSDOS 6.0)
 12245 000028EE 30C0                    		xor	al,al
 12246 000028F0 CD21                    		int	21h		; get Ctrl-Break state (ah=33h)
 12247 000028F2 88D3                    		mov	bl,dl
 12248 000028F4 BA[073D]                		mov	dx,CTRLMESPTR
 12249                                  
 12250                                  ; ---------------------------------------------------------------------------
 12251                                  
 12252                                  PYN:		; write "ON" or "OFF" state 
 12253                                  
 12254 000028F7 E8D90B                  		call	STD_PRINTF
 12255 000028FA BA[2E3D]                		mov	dx,ONMESPTR	;AC000; get ON pointer
 12256 000028FD 08DB                    		or	bl,bl
 12257 000028FF 7503                    		jnz	short PRINTVAL
 12258 00002901 BA[273D]                		mov	dx,OFFMESPTR	;AC000; get OFF pointer
 12259                                  
 12260                                  PRINTVAL:
 12261                                  		; MSDOS 3.3
 12262 00002904 E9CC0B                  		jmp	STD_PRINTF
 12263                                  
 12264                                  		; MSDOS 6.0
 12265                                  		;push	dx		;AN000; save offset of message block
 12266                                  		;mov	bx,dx		;AN000; save offset value
 12267                                  		;lodsw			;AN000; get message number of on or off
 12268                                  		;mov	dh,util_msg_class ;AN000; this is a utility message
 12269                                  		;invoke	Tsysgetmsg	;AN000; get the address of the message
 12270                                  		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
 12271                                  		;mov	word ptr [bx],si ;AN000; put the offset in the message block
 12272                                  		;pop	dx		;AN000; get message back
 12273                                  		;invoke	std_printf	;AC000; go print message
 12274                                  		;mov	word ptr [bx],0 ;AN000; zero out message pointer
 12275                                  		;
 12276                                  		;ret			;AN000; exit
 12277                                  
 12278                                  ; =============== S U B	R O U T	I N E =======================================
 12279                                  
 12280                                  VERIFY:
 12281 00002907 E81F00                  		call	ON_OFF
 12282 0000290A B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 12283 0000290D 720A                    		jc	short PVERIFY
 12284 0000290F 7503                    		jnz	short VER_OFF
 12285 00002911 CD21                    		int	21h	; DOS -	SET VERIFY FLAG
 12286                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 12287 00002913 C3                      		retn
 12288                                  
 12289                                  ; ---------------------------------------------------------------------------
 12290                                  
 12291                                  VER_OFF:
 12292 00002914 FEC8                    		dec	al
 12293 00002916 CD21                    		int	21h		; Turn off verify after write
 12294 00002918 C3                      		retn
 12295                                  
 12296                                  ; ---------------------------------------------------------------------------
 12297                                  
 12298                                  PVERIFY:
 12299                                  		; MSDOS 6.0
 12300                                  		;CMP	CL,0		;AC000; is rest of line blank?
 12301                                  		;JNZ	CERRORJ 	; nope...
 12302                                  
 12303                                  		; MSDOS 3.3
 12304 00002919 E8B0FF                  		call	MOVE_TO_FIRST_ARG
 12305 0000291C 75AB                    		jnz	short CERRORJ
 12306                                  
 12307 0000291E B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 12308 00002920 CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 12309                                  					; Return: AL = 00h if flag OFF
 12310                                  					; AL = 01h if flag ON
 12311 00002922 88C3                    		mov	bl,al
 12312 00002924 BA[143D]                		mov	dx,VERIMESPTR
 12313 00002927 EBCE                    		jmp	short PYN
 12314                                  
 12315                                  ; =============== S U B	R O U T	I N E =======================================
 12316                                  
 12317                                  ; ****************************************************************
 12318                                  ; *
 12319                                  ; * ROUTINE:	 ON_OFF
 12320                                  ; *
 12321                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 12322                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 12323                                  ; *		 routines.
 12324                                  ; *
 12325                                  ; * INPUT:	 command line at offset 81H
 12326                                  ; *		 PARSE_BREAK control block
 12327                                  ; *
 12328                                  ; * OUTPUT:	 If carry is clear
 12329                                  ; *		    If ON is found
 12330                                  ; *		       Zero flag set
 12331                                  ; *		    If OFF is found
 12332                                  ; *		       Zero flag clear
 12333                                  ; *		 If carry set
 12334                                  ; *		    If nothing on command line
 12335                                  ; *		       CL set to zero
 12336                                  ; *		    If error
 12337                                  ; *		       CL contains error value from parse
 12338                                  ; *
 12339                                  ; ****************************************************************
 12340                                  
 12341                                  ON_OFF:
 12342 00002929 BE8100                  		mov	si,81h
 12343                                  
 12344                                  		; MSDOS 3.3
 12345 0000292C E84AF0                  		call	SCANOFF		; scan off leading blanks & equal
 12346 0000292F 3C0D                    		cmp	al,0Dh		; are we at end of line?
 12347 00002931 742A                    		je	short BAD_ONF	; yes, return error
 12348 00002933 AD                      		lodsw
 12349 00002934 0D2020                  		or	ax,2020h	; convert to lowercase
 12350 00002937 3D6F6E                  		cmp	ax,6E6Fh ;'on'
 12351 0000293A 7410                    		je	short ON_CHECK
 12352 0000293C 3D6F66                  		cmp	ax,666Fh ;'of'
 12353 0000293F 751C                    		jne	short BAD_ONF
 12354 00002941 AC                      		lodsb
 12355 00002942 0C20                    		or	al,20h		; convert to lowercase		
 12356 00002944 3C66                    		cmp	al,66h	 ; 'f'
 12357 00002946 7515                    		jne	short BAD_ONF	
 12358 00002948 0C66                    		or	al,66h ; or al,'f'
 12359 0000294A EB02                    		jmp	short OFF_CHECK
 12360                                  ON_CHECK:
 12361 0000294C 30C0                    		xor	al,al
 12362                                  OFF_CHECK:
 12363 0000294E 9F                      		lahf
 12364 0000294F 89C3                    		mov	bx,ax
 12365 00002951 E825F0                  		call	SCANOFF		; scan off leading blanks & equal
 12366 00002954 3C0D                    		cmp	al,0Dh		; are we at end of line?	
 12367 00002956 7505                    		jne	short BAD_ONF	; no, return error
 12368 00002958 89D8                    		mov	ax,bx
 12369 0000295A 9E                      		sahf
 12370 0000295B F8                      		clc
 12371 0000295C C3                      		retn
 12372                                  
 12373                                  		; MSDOS 6.0
 12374                                  ;scan_on_off:				;AN032; scan off leading blanks & equal
 12375                                  ;		lodsb			;AN032; get a char
 12376                                  ;		cmp	al,blank	;AN032; if whitespace
 12377                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12378                                  ;		cmp	al,tab_chr	;AN032; if tab
 12379                                  ;		jz	scan_on_off	;AN032;    keep scanning
 12380                                  ;		cmp	al,equal_chr	;AN032; if equal char
 12381                                  ;		jz	parse_on_off	;AN032;    start parsing
 12382                                  ;		dec	si		;AN032; if none of above - back up
 12383                                  ;
 12384                                  ;parse_on_off:				;AN032;    and start parsing
 12385                                  ;		mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
 12386                                  ;		xor	cx,cx		;AN000; clear cx,dx
 12387                                  ;		xor	dx,dx		;AN000;
 12388                                  ;		invoke	cmd_parse	;AC000; call parser
 12389                                  ;		cmp	ax,end_of_line	;AC000; are we at end of line?
 12390                                  ;		jz	BADONF		;AC000; yes, return error
 12391                                  ;		cmp	ax,result_no_error ;AN000; did an error occur
 12392                                  ;		jz	on_off_there	;AN000; no - continue
 12393                                  ;		mov	cx,ax		;AN000; yes - set cl to error code
 12394                                  ;		jmp	short BADONF	;AN000; return error
 12395                                  ;
 12396                                  ;on_off_there:
 12397                                  ;		cmp	parse1_code,-1	;AN014; was a valid positional present?
 12398                                  ;		jnz	good_on_off	;AN014; yes - continue
 12399                                  ;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
 12400                                  ;		jmp	short BADONF	;AN014; return error
 12401                                  ;
 12402                                  ;good_on_off:				;AN014;
 12403                                  ;		xor	ax,ax		;AC000; set up return code for
 12404                                  ;		or	al,parse1_code	;AC000;    ON or OFF in AX
 12405                                  ;		pushf			;AN000; save flags
 12406                                  ;		mov	di,offset trangroup:parse_break
 12407                                  ;					;AN000; Get adderss of PARSE_BREAK
 12408                                  ;		xor	dx,dx		;AN000;
 12409                                  ;		invoke	cmd_parse	;AN000; call parser
 12410                                  ;		cmp	ax,end_of_line	;AN000; are we at end of line?
 12411                                  ;		jnz	BADONF_flags	;AN000; NO, return error
 12412                                  ;		popf			;AN000; restore flags
 12413                                  ;		clc			;AC000; no error
 12414                                  ;		jmp	short on_off_end ;AN000; return to caller
 12415                                  ;
 12416                                  ;BADONF_flags:
 12417                                  ;		mov	cx,ax
 12418                                  ;		popf
 12419                                  
 12420                                  ; ---------------------------------------------------------------------------
 12421                                  
 12422                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 12423                                  ; and return the error
 12424                                  
 12425                                  BAD_ONF:
 12426 0000295D BA[E93B]                		mov	dx,BADONOFFPTR
 12427 00002960 F9                      		stc
 12428                                  ;on_off_end:
 12429 00002961 C3                      		retn
 12430                                  
 12431                                  ;============================================================================
 12432                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 12433                                  ;============================================================================
 12434                                  ; 02/10/2018 - Retro DOS v3.0
 12435                                  
 12436                                  ; Print volume ID info
 12437                                  
 12438                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 12439                                  
 12440                                  ; ---------------------------------------------------------------------------
 12441                                  
 12442                                  PRINTVOL:
 12443 00002962 50                      		push	ax		; AX return from SEARCH_FIRST for VOL ID
 12444 00002963 A05C00                  		mov	al,[FCB] ; 5Ch	; get drive letter
 12445 00002966 0440                    		add	al,'@'
 12446 00002968 3C40                    		cmp	al,'@'
 12447 0000296A 7507                    		jnz	short DRVOK
 12448 0000296C A0[8542]                		mov	al,[CURDRV]
 12449 0000296F 0206[F03E]              		add	al,[CAPITAL_A]
 12450                                  DRVOK:
 12451 00002973 A2[6444]                		mov	[VOL_DRV],al	; get drive letter into argument
 12452 00002976 58                      		pop	ax		; get return code back
 12453 00002977 BA[553B]                		mov	dx,NOVOL ; "has	no label" 
 12454 0000297A 08C0                    		or	al,al		; volume label found?
 12455 0000297C 7517                    		jnz	short PRINTVOL2	; print no volume message
 12456                                  GOODVOL:
 12457                                  		; MSDOS 3.3
 12458 0000297E BF[9B42]                		mov	di,CHARBUF
 12459 00002981 89FA                    		mov	dx,di
 12460 00002983 BE[513B]                		mov	si,IS	; "is "
 12461 00002986 E8FBDE                  		call	STRCPY
 12462 00002989 4F                      		dec	di
 12463 0000298A BE[7243]                		mov	si,DIRBUF+8
 12464 0000298D B90B00                  		mov	cx,11
 12465 00002990 F3A4                    		rep movsb
 12466 00002992 31C0                    		xor	ax,ax
 12467                                  		;xor	al,al  ; MSDOS 6.0
 12468 00002994 AA                      		stosb			; store a zero to terminate the string
 12469                                  PRINTVOL2:
 12470 00002995 8916[6244]              		mov	[VOLNAME_ADDR],dx
 12471 00002999 BA[4B3B]                		mov	dx,VOLMESPTR
 12472 0000299C E9240B                  		jmp	PRINTF_CRLF
 12473                                  
 12474                                  		; MSDOS 6.0
 12475                                  ;drvok:
 12476                                  ;		mov	vol_drv,al	;AC000; get drive letter into argument
 12477                                  ;		pop	ax		;AC000; get return code back
 12478                                  ;		or	al,al		;AC000; volume label found?
 12479                                  ;		jz	Get_vol_name	;AC000; volume label exists - go get it
 12480                                  ;		mov	dx,offset trangroup:VolMes_ptr_2 
 12481                                  ;					;AC000; set up no volume message
 12482                                  ;		jmp	short print_serial	;AC000; go print it
 12483                                  ;
 12484                                  ;Get_vol_name:
 12485                                  ;		mov	di,offset trangroup:charbuf
 12486                                  ;		mov	dx,di
 12487                                  ;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 12488                                  ;		mov	cx,11				;AN000;  3/3/KK
 12489                                  ;		rep	movsb				;AN000;  3/3/KK
 12490                                  ;
 12491                                  ;		xor	al,al		;AC000; store a zero to terminate the string
 12492                                  ;		stosb
 12493                                  ;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 12494                                  ;
 12495                                  ;PRINT_SERIAL:
 12496                                  ;
 12497                                  ;; Attempt to get the volume serial number from the disk.  If an error
 12498                                  ;; occurs, do not print volume serial number.
 12499                                  ;
 12500                                  ;		push	dx		;AN000; save message offset
 12501                                  ;		mov	ax,(GetSetMediaID SHL 8) 
 12502                                  ;					;AC036; Get the volume serial info
 12503                                  ;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 12504                                  ;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 12505                                  ;		int	21h		;AN000; do the call
 12506                                  ;		pop	dx		;AN000; get message offset back
 12507                                  ;		jc	printvol_end	;AN000; if error, just go print label
 12508                                  ;		call	std_printf	;AC000; go print volume message
 12509                                  ;		mov	al,blank	;AN051; Print out a blank
 12510                                  ;		invoke	print_char	;AN051;   before volume message
 12511                                  ;		mov	dx,offset trangroup:VolSerMes_ptr 
 12512                                  ;					;AN000; get serial number message
 12513                                  ;printvol_end:
 12514                                  ;		jmp	std_printf	;AC000; go print and exit
 12515                                  
 12516                                  ;============================================================================
 12517                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 12518                                  ;============================================================================
 12519                                  ; 02/10/2018 - Retro DOS v3.0
 12520                                  
 12521                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 12522                                  
 12523                                  ; =============== S U B	R O U T	I N E =======================================
 12524                                  
 12525                                  PRINT_DATE:
 12526                                  		; MSDOS 3.3
 12527 0000299F 06                      		push	es
 12528 000029A0 57                      		push	di
 12529 000029A1 0E                      		push	cs
 12530 000029A2 07                      		pop	es
 12531 000029A3 BF[C843]                		mov	di,ARG_BUF
 12532 000029A6 B42A                    		mov	ah,GET_DATE ; 2Ah
 12533 000029A8 CD21                    		int	21h	; DOS -	GET CURRENT DATE
 12534                                  				; Return: DL = day,DH = month,	CX = year
 12535                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 12536 000029AA 98                      		cbw
 12537 000029AB E80F00                  		call	GETDATE
 12538 000029AE E8EDF6                  		call	P_DATE
 12539 000029B1 30C0                    		xor	al,al
 12540 000029B3 AA                      		stosb
 12541 000029B4 BA[2337]                		mov	dx,ARG_BUF_PTR
 12542 000029B7 E8190B                  		call	STD_PRINTF
 12543 000029BA 07                      		pop	es
 12544 000029BB 5F                      		pop	di
 12545 000029BC C3                      		retn
 12546                                  
 12547                                  		; MSDOS 6.0
 12548                                  		;PUSH	ES
 12549                                  		;PUSH	DI
 12550                                  		;PUSH	CS
 12551                                  		;POP	ES
 12552                                  		;CALL	GetDate 		; get date
 12553                                  		;xchg	dh,dl			;AN000; switch month & day
 12554                                  		;mov	promptDat_yr,cx 	;AC000; put year into message control block
 12555                                  		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
 12556                                  		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
 12557                                  		;invoke	std_printf
 12558                                  	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
 12559                                  	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
 12560                                  		;POP	DI			;AC000; restore di,es
 12561                                  		;POP	ES			;AC000;
 12562                                  		;return
 12563                                  
 12564                                  ; ---------------------------------------------------------------------------
 12565                                  
 12566                                  GETDATE:
 12567                                  		; MSDOS 3.3
 12568 000029BD 89C6                    		mov	si,ax
 12569 000029BF D1E6                    		shl	si,1
 12570 000029C1 01C6                    		add	si,ax
 12571 000029C3 81C6[243A]              		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 12572 000029C7 89CB                    		mov	bx,cx
 12573 000029C9 B90300                  		mov	cx,3
 12574 000029CC F3A4                    		rep movsb
 12575 000029CE B020                    		mov	al,' '
 12576 000029D0 AA                      		stosb
 12577 000029D1 C3                      		retn
 12578                                  
 12579                                  		; MSDOS 6.0
 12580                                  
 12581                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 12582                                  ; for output.  Date will be returned in CX,DX.
 12583                                  
 12584                                  ;GetDate:
 12585                                  		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
 12586                                  		;MOV	AH,GET_DATE		;AC000; get current date
 12587                                  		;INT	21h			;AC000; Get date in CX:DX
 12588                                  		;CBW				;AC000;
 12589                                  		;
 12590                                  		;push	cx			;AN000; save date returned in
 12591                                  		;push	dx			;AN000;      CX:DX
 12592                                  		;MOV	SI,AX
 12593                                  		;
 12594                                  		;SHL	SI,1
 12595                                  		;ADD	SI,AX			; SI=AX*3
 12596                                  		;
 12597                                  		;mov	cx,si			;AN000; save si
 12598                                  		;mov	ax,weektab		;AN000; get message number of weektab
 12599                                  		;mov	dh,util_msg_class	;AN000; this is a utility message
 12600                                  		;push	di			;AN000; save argument buffer
 12601                                  		;invoke	Tsysgetmsg		;AN000; get the address of the message
 12602                                  		;pop	di			;AN000; retrieve argument buffer
 12603                                  		;add	si,cx			;AC000; get day of week
 12604                                  		;
 12605                                  		;MOV	CX,3
 12606                                    		;REP	MOVSB
 12607                                  		;mov	al,end_of_line_out	;AC000; terminate the string
 12608                                  		;stosb
 12609                                  		;pop	dx			;AN000; get back date
 12610                                  		;pop	cx			;AN000;
 12611                                  		;
 12612                                  		;return
 12613                                  
 12614                                  ; =============== S U B	R O U T	I N E =======================================
 12615                                  
 12616                                  		; MSDOS 6.0
 12617                                  
 12618                                  ; This routine determines whether the character in AL is a
 12619                                  ; Yes or No character. On return, if AL=0, the character is
 12620                                  ; No, if AL=1, the character is Yes.
 12621                                  
 12622                                  ;		assume	ds:trangroup
 12623                                  
 12624                                  ;char_in_xlat	proc	near
 12625                                  ;
 12626                                  ;		mov	dl,al			;AC000; get character into DX
 12627                                  ;		xor	dh,dh			;AC000;
 12628                                  ;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
 12629                                  ;		int	21h			;AC000;
 12630                                  ;
 12631                                  ;		ret
 12632                                  ;
 12633                                  ;char_in_xlat	endp
 12634                                  
 12635                                  ;============================================================================
 12636                                  ; TENV.ASM, MSDOS 6.0, 1991
 12637                                  ;============================================================================
 12638                                  ; 02/10/2018 - Retro DOS v3.0
 12639                                  
 12640                                  ;	Environment utilities and misc. routines
 12641                                  
 12642                                  ; MSDOS 6.0
 12643                                  ; ****************************************************************
 12644                                  ; *
 12645                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 12646                                  ; *
 12647                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 12648                                  ; *		 the character in AL from the file upper case table
 12649                                  ; *		 in DOS if character if above  ascii 128, else
 12650                                  ; *		 subtracts 20H if between "a" and "z".
 12651                                  ; *
 12652                                  ; * INPUT:	 AL	      char to be upper cased
 12653                                  ; *		 FUCASE_ADDR  set to the file upper case table
 12654                                  ; *
 12655                                  ; * OUTPUT:	 AL	      upper cased character
 12656                                  ; *
 12657                                  ; ****************************************************************
 12658                                  ;
 12659                                  ;assume	ds:trangroup				;AN000;
 12660                                  ;
 12661                                  ;upconv	proc	near				;AN000;
 12662                                  ;
 12663                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 12664                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 12665                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 12666                                  ;	push	ds				;AN000;
 12667                                  ;	push	bx				;AN000;
 12668                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 12669                                  ;assume	ds:resgroup				;AN000;
 12670                                  ;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
 12671                                  ;	add	bx,2				;AN000;  skip over first word
 12672                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 12673                                  ;	pop	bx				;AN000;
 12674                                  ;	pop	ds				;AN000;
 12675                                  ;assume	ds:trangroup				;AN000;
 12676                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 12677                                  ;
 12678                                  ;oth_fucase:					;AN000;
 12679                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 12680                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 12681                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 12682                                  ;	ja	upconv_end			;AC000;
 12683                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 12684                                  ;
 12685                                  ;upconv_end:					;AN000;
 12686                                  ;	ret
 12687                                  ;
 12688                                  ;upconv	endp					;AN000;
 12689                                  
 12690                                  
 12691                                  ; =============== S U B	R O U T	I N E =======================================
 12692                                  
 12693                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 12694                                  
 12695                                  UPCONV:
 12696 000029D2 3C80                    		cmp	al,80h
 12697 000029D4 7214                    		jb	short OTH_UCASE
 12698 000029D6 2C80                    		sub	al,80h
 12699 000029D8 1E                      		push	ds
 12700 000029D9 53                      		push	bx
 12701 000029DA 8E1E[7142]              		mov	ds,[RESSEG]
 12702 000029DE C51E040C                		lds	bx,[UPPERCASETBL]
 12703 000029E2 83C302                  		add	bx,2
 12704 000029E5 D7                      		xlat
 12705 000029E6 5B                      		pop	bx
 12706 000029E7 1F                      		pop	ds
 12707 000029E8 EB0A                    		jmp	short UPCONV_RETN
 12708                                  
 12709                                  OTH_UCASE:
 12710 000029EA 3C61                    		cmp	al,'a'
 12711 000029EC 7206                    		jb	short UPCONV_RETN
 12712 000029EE 3C7A                    		cmp	al,'z'
 12713 000029F0 7702                    		ja	short UPCONV_RETN
 12714 000029F2 2C20                    		sub	al,20h
 12715                                  
 12716                                  UPCONV_RETN:
 12717 000029F4 C3                      		retn
 12718                                  
 12719                                  ;============================================================================
 12720                                  ; COPY.ASM, MSDOS 6.0, 1991
 12721                                  ;============================================================================
 12722                                  ; 01/10/2018 - Retro DOS v3.0
 12723                                  
 12724                                  ;	title	COMMAND COPY routines.
 12725                                  
 12726                                  ;/*
 12727                                  ; *                      Microsoft Confidential
 12728                                  ; *                      Copyright (C) Microsoft Corporation 1991
 12729                                  ; *                      All Rights Reserved.
 12730                                  ; */
 12731                                  
 12732                                  ;***	COPY.ASM
 12733                                  
 12734                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 12735                                  
 12736                                  
 12737                                  ;***	MODIFICATION HISTORY
 12738                                  
 12739                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 12740                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 12741                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 12742                                  ;	     to tokens which begin with path characters so that PARSELINE
 12743                                  ;	     will work correctly.
 12744                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 12745                                  ;	     individual tokens.  That distinction is no longer needed for
 12746                                  ;	     FOR loop processing.
 12747                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
 12748                                  ;	     1 when Cparse is called from COPY.
 12749                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 12750                                  ;	     mod.  It now is conditional on flag like previous mod.
 12751                                  ;11/21/83 NP  Added printf
 12752                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 12753                                  ;	     be added to a token.
 12754                                  ;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
 12755                                  ;	     NOTE: DestHand is the destination handle.  There are two
 12756                                  ;	     special values:  -1 meaning destination was never opened and
 12757                                  ;	     0 which means that the destination has been openned and
 12758                                  ;	     closed.
 12759                                  ;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
 12760                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 12761                                  ;	     lost on large and multiple file (wildcard) copies.
 12762                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 12763                                  ;	     destination are not equal.
 12764                                  ;
 12765                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 12766                                  ;	     first source file AND we run out of disk space before
 12767                                  ;	     completing the concatenation, restore the first source
 12768                                  ;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
 12769                                  ;
 12770                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 12771                                  ;		instead of compatibility mode. This gives lesser sharing
 12772                                  ;		violations when files are opened for read on a copy.
 12773                                  
 12774                                  ; ---------------------------------------------------------------------------
 12775                                  ;***	COPY CODE
 12776                                  ; ---------------------------------------------------------------------------
 12777                                  
 12778                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 12779                                  
 12780                                  COPY:
 12781                                  	; 	Initialize internal variables.
 12782                                  
 12783 000029F5 31C0                    		xor	ax,ax		; AX = 0
 12784 000029F7 A3[5044]                		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
 12785 000029FA A3[8545]                		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 12786 000029FD A3[D144]                		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
 12787 00002A00 A2[9042]                		mov	[CFLAG],al	; 'destination file created' = false
 12788 00002A03 A3[9442]                		mov	[NXTADD],ax	; ptr into TPA buffer = 0
 12789 00002A06 A3[8C42]                		mov	[DESTSWITCH],ax	; destination switches = none
 12790 00002A09 A3[9745]                		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 12791 00002A0C A3[6E44]                		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
 12792 00002A0F A2[9142]                		mov	[DESTCLOSED],al	; 'destination file closed' = false
 12793 00002A12 A2[6D44]                		mov	[DESTSIZ],al	; length of destination pathname = 0
 12794 00002A15 A2[D044]                		mov	[SRCSIZ],al	; length of source pathname = 0
 12795 00002A18 A2[7044]                		mov	[DESTINFO],al	; destination pathname flags = none
 12796 00002A1B A2[D344]                		mov	[SRCINFO],al	; source pathname flags = none
 12797 00002A1E A2[8745]                		mov	[INEXACT],al	; 'inexact copy' = false
 12798 00002A21 A2[6C44]                		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
 12799 00002A24 A2[CF44]                		mov	[SRCVARS],al	; 'source pathname is directory' = false
 12800 00002A27 A2[5341]                		mov	[USERDIR1],al	; saved working directory = null
 12801 00002A2A A2[8945]                		mov	[NOWRITE],al	; 'no write' (source = dest) = false
 12802 00002A2D A2[8442]                		mov	[RDEOF],al	; 'read end of file' = false
 12803 00002A30 A3[2B45]                		mov	[SRCHAND],ax	; source handle = 0
 12804 00002A33 A3[9145]                		mov	[CPDATE],ax	; copy date = 0
 12805 00002A36 A3[9345]                		mov	[CPTIME],ax	; copy time = 0
 12806 00002A39 A2[2D45]                		mov	[SRCISDEV],al	; 'source is device' = false
 12807                                  		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 12808                                  		;mov	[OFilePtr_Lo],ax
 12809                                  		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 12810 00002A3C A2[8D45]                		mov	[TERMREAD],al	; 'terminate read' = false
 12811 00002A3F A2[C643]                		mov	[COMMA],al	; '"+,," found' = false
 12812 00002A42 A2[C743]                		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
 12813 00002A45 A3[8E42]                		mov	[ALLSWITCH],ax	; all switches = none
 12814 00002A48 A2[8742]                		mov	[ARGC],al	; source/dest argument count = 0
 12815 00002A4B A2[8F45]                		mov	[PLUS],al	; '"+" in command line' = false
 12816 00002A4E A2[8A45]                		mov	[BINARY],al	; 'binary copy' = false
 12817 00002A51 A2[8E45]                		mov	[ASCII],al	; 'ascii copy' = false
 12818 00002A54 A3[9942]                		mov	[FILECNT],ax	; # files copied (destinations) = 0
 12819 00002A57 A3[8B45]                		mov	[WRITTEN],ax	; 'destination written to' = false
 12820 00002A5A A2[8642]                		mov	[CONCAT],al	; 'concatenating' = false
 12821 00002A5D A2[CC44]                		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 12822 00002A60 A3[CD44]                		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 12823                                  
 12824                                  	;	Initialize buffers with double-nulls.
 12825                                  
 12826 00002A63 A3[2E45]                		mov	[SCANBUF],ax
 12827 00002A66 A3[7144]                		mov	[DESTBUF],ax
 12828 00002A69 A3[D444]                		mov	[SRCBUF],ax
 12829 00002A6C A3[B043]                		mov	[SDIRBUF],ax
 12830 00002A6F A3[6A43]                		mov	[DIRBUF],ax
 12831 00002A72 A3[2743]                		mov	[DESTFCB],ax
 12832                                  
 12833 00002A75 A2[9045]                		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
 12834                                  		
 12835 00002A78 48                      		dec	ax		; AX = 0FFFFh
 12836 00002A79 A3[C844]                		mov	[DESTHAND],ax	; destination handle = 'never opened'
 12837 00002A7C A2[9642]                		mov	[FRSTSRCH],al	; 'first search for source' = true
 12838 00002A7F A2[CB44]                		mov	[FIRSTDEST],al	; 'first time for dest' = true
 12839 00002A82 A2[6C44]                		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
 12840                                  		
 12841 00002A85 BE8100                  		mov	si,81h		; SI = ptr to command line
 12842 00002A88 8A1E[FF3E]              		mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 12843 00002A8C FE06[A745]              		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
 12844 00002A90 C606[5644]01            		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true
 12845                                  
 12846                                  	;*	Scan the command line for destination information.
 12847                                  
 12848                                  DESTSCAN:
 12849 00002A95 31ED                    		xor	bp,bp			; BP = switch flag accumulator
 12850 00002A97 BF[2E45]                		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
 12851                                  		;mov	[Parse_Last],si		;AN018; save cmd line ptr
 12852 00002A9A E87708                  		call	CPARSE			; parse next object
 12853 00002A9D 9C                      		pushf				; save CParse flags
 12854 00002A9E FE06[9045]              		inc	byte [OBJCNT]		; count object
 12855 00002AA2 F6C780                  		test	bh,80h
 12856 00002AA5 7405                    		jz	short NOCOPY		; no "+" delimiter
 12857 00002AA7 C606[8F45]01            		mov	byte [PLUS],1		; "+" delimiter occurred
 12858                                  NOCOPY:
 12859 00002AAC F6C701                  		test	bh,1
 12860 00002AAF 740D                    		jz	short TESTP2		; not a switch
 12861                                  
 12862                                  	;	Found a switch.
 12863                                  
 12864                                  		; MSDOS 6.0
 12865                                  		;test	bp,SwitchV		;AN038; Verify requested?
 12866                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12867                                  		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
 12868                                  		;jz	Not_SlashV		;AN038; No - set the switch
 12869                                  ;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
 12870                                  		;or	bp,FBadSwitch		;AN018; Set up bad switch
 12871                                  
 12872                                  NOT_SLASHV:
 12873 00002AB1 092E[8C42]              		or	[DESTSWITCH],bp		; assume destination
 12874 00002AB5 092E[8E42]              		or	[ALLSWITCH],bp		; keep tabs on all switches
 12875                                  
 12876                                  		; MSDOS 6.0
 12877                                  		;test	bp,not SwitchCopy	;AN018; Bad switch?
 12878                                  		;jz	Not_Bad_Switch		;AN018; Switches are okay
 12879                                  		;popf				;AN018; fix up stack
 12880                                  		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
 12881                                  		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
 12882                                  		;jmp	CError			;AC018; exit
 12883                                  
 12884                                  NOT_BAD_SWITCH:
 12885 00002AB9 9D                      		popf				; restore CParse flags
 12886 00002ABA 7233                    		jc	short CHECKDONE		; found CR
 12887 00002ABC EBD7                    		jmp	short DESTSCAN		; continue scanning for destination
 12888                                  
 12889                                  TESTP2:
 12890 00002ABE 9D                      		popf				; restore CParse flags
 12891 00002ABF 722E                    		jc	short CHECKDONE		; found CR
 12892 00002AC1 F6C780                  		test	bh,80h
 12893 00002AC4 7504                    		jnz	short GOTPLUS		; found a "+pathname" argument
 12894 00002AC6 FE06[8742]              		inc	byte [ARGC]		; count independent pathname args
 12895                                  GOTPLUS:
 12896 00002ACA 56                      		push	si			; save cmd line ptr
 12897 00002ACB A1[9745]                		mov	ax,[STARTEL]		; AX = ptr to last path element
 12898 00002ACE BE[2E45]                		mov	si,SCANBUF		; SI = ptr to path string
 12899 00002AD1 29F0                    		sub	ax,si			; AX = offset of last element
 12900 00002AD3 BF[7144]                		mov	di,DESTBUF		; DI = ptr to destination buf
 12901 00002AD6 01F8                    		add	ax,di			; AX = ptr to last element in
 12902                                  						;  destination path buffer
 12903 00002AD8 A3[6E44]                		mov	[DESTTAIL],ax		; save ptr to last element
 12904 00002ADB 880E[6D44]              		mov	[DESTSIZ],cl		; save path string length
 12905 00002ADF 41                      		inc	cx			; CX = mov length (incl null)
 12906 00002AE0 F3A4                    		rep movsb			; DestBuf = possible destination path
 12907 00002AE2 883E[7044]              		mov	[DESTINFO],bh		; save CParse info flags
 12908 00002AE6 C706[8C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12909 00002AEC 5E                      		pop	si			; SI = ptr into cmd line again
 12910 00002AED EBA6                    		jmp	short DESTSCAN		;AC018; continue scanning for dest
 12911                                  
 12912                                  CHECKDONE:
 12913                                  
 12914                                  	;	We reached the CR. The destination scan is finished.
 12915                                  
 12916                                  	;	Disallow "copy file1+" as file overwriting itself.
 12917                                  	;
 12918                                  	;	(Note that "copy file1+file2+" will be accepted, and
 12919                                  	;	equivalent to "copy file1+file2".)
 12920                                  
 12921                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 12922                                  	;	through this check, since the switch would count
 12923                                  	;	as another object in ObjCnt.
 12924                                  
 12925 00002AEF 803E[8F45]01            		cmp	byte [PLUS],1		; "+" with
 12926 00002AF4 7514                    		jnz	short CDCONT
 12927 00002AF6 803E[8742]01            		cmp	byte [ARGC],1		; one arg,
 12928 00002AFB 750D                    		jnz	short CDCONT
 12929 00002AFD 803E[9045]02            		cmp	byte [OBJCNT],2		; two objects..
 12930 00002B02 7506                    		jnz	short CDCONT
 12931 00002B04 BA[9438]                		mov	dx,OVERWRPTR
 12932 00002B07 E9B605                  		jmp	COPYERR			; is file overwrite
 12933                                  
 12934                                  CDCONT:
 12935 00002B0A A0[8F45]                		mov	al,[PLUS]		; AL = '"+" occurred'
 12936 00002B0D A2[8642]                		mov	[CONCAT],al		; if "+" occurred, we're concatenating
 12937 00002B10 D0E0                    		shl	al,1
 12938 00002B12 D0E0                    		shl	al,1
 12939 00002B14 A2[8745]                		mov	[INEXACT],al		; therefore making an inexact copy
 12940 00002B17 BA[6D3D]                		mov	dx,BADARGSPTR
 12941 00002B1A A0[8742]                		mov	al,[ARGC]		; AL = # independent arguments
 12942 00002B1D 08C0                    		or	al,al
 12943 00002B1F 7404                    		jz	short CERROR4J
 12944                                  
 12945                                  		; MSDOS 6.0
 12946                                  		;or	al,al
 12947                                  		;jnz	Try_Too_Many		; more than 0 args; check if too many
 12948                                  		
 12949                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12950                                  		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
 12951                                  		;jmp	short CError_ParseJ		; take parse error exit		
 12952                                  
 12953                                  	; more than 0 args; check if too many
 12954                                  
 12955                                  TRY_TOO_MANY:
 12956 00002B21 3C02                    		cmp	al,2
 12957 00002B23 7603                    		jbe	short ACOUNTOK		; <= 2 arguments - ok
 12958                                  
 12959                                  		; MSDOS 6.0
 12960                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
 12961                                  		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
 12962                                  ;CError_ParseJ:
 12963                                  		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	
 12964                                  
 12965                                  CERROR4J:
 12966 00002B25 E901F1                  		jmp	CERROR
 12967                                  
 12968                                  ACOUNTOK:
 12969 00002B28 BD[6C44]                		mov	bp,DESTVARS		; BP = base of dest variables
 12970                                  
 12971 00002B2B 3C01                    		cmp	al,1
 12972 00002B2D 7522                    		jnz	short GOT2ARGS
 12973                                  
 12974                                  	;	Only one independent pathname argument on command line.
 12975                                  	;	Set destination to d:*.*, where d: is current drive.
 12976                                  
 12977                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 12978                                  	;	The two files would be appended as d:file1, rather than x:file1.
 12979                                  
 12980 00002B2F A0[8542]                		mov	al,[CURDRV]		; AL = current drive (0 = A)
 12981 00002B32 0206[F03E]              		add	al,[CAPITAL_A]		; AL = current drive letter
 12982 00002B36 B43A                    		mov	ah,':'			; AX = "d:"
 12983                                  		;mov	byte [bp+1],2
 12984 00002B38 C6460102                		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 12985                                  
 12986 00002B3C BF[7144]                		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
 12987 00002B3F AB                      		stosw				; store "d:"
 12988                                  		
 12989 00002B40 C706[8C42]0000          		mov	word [DESTSWITCH],0	; clear destination switches
 12990                                  		;mov	byte [bp+4],2		
 12991 00002B46 C6460402                		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 12992                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 12993                                  		;mov	byte [bp+0],0		
 12994 00002B4A C6460000                		mov	byte [bp],0
 12995 00002B4E E89307                  		call	SETSTARS		; add wildcards
 12996                                  GOT2ARGS:
 12997                                  
 12998                                  	;	If destination pathname is "d:", add full wildcard filename
 12999                                  
 13000                                  		;cmp	byte [bp+1],2
 13001 00002B51 807E0102                		cmp	byte [bp+VARSTRUC.SIZ],2
 13002 00002B55 7516                    		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 13003 00002B57 B03A                    		mov	al,':'
 13004 00002B59 3806[7244]              		cmp	byte [DESTBUF+1],al
 13005 00002B5D 750E                    		jnz	short NOTSHORTDEST	; it's just a 2-character filename
 13006                                  		;or	byte [bp+4],2
 13007 00002B5F 804E0402                		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 13008 00002B63 BF[7344]                		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
 13009                                  		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 13010                                  		;mov	byte [bp+0],0		
 13011 00002B66 C6460000                		mov	byte [bp],0
 13012 00002B6A E87707                  		call	SETSTARS		; add wildcards
 13013                                  
 13014                                  NOTSHORTDEST:
 13015                                  
 13016                                  	;	If destination pathname ends with "\", try to make
 13017                                  	;	sure it's "d:\".
 13018                                  
 13019                                  		;mov	di,[bp+2]
 13020 00002B6D 8B7E02                  		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 13021 00002B70 803D00                  		cmp	byte [di],0
 13022 00002B73 7515                    		jnz	short CHKSWTCHES	; not a null, so last char not "\"
 13023                                  
 13024 00002B75 BA[763B]                		mov	dx,BADCDPTR
 13025 00002B78 B03A                    		mov	al,':'
 13026 00002B7A 3845FE                  		cmp	[di-2],al
 13027 00002B7D 75A6                    		jne	short CERROR4J		; it's not "d:\", exit with error msg
 13028                                  		;mov	byte [bp+0],2
 13029                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 13030 00002B7F C6460002                		mov	byte [bp],2
 13031                                  		;or	byte [bp+4],6
 13032 00002B83 804E0406                		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 13033                                  						  ;  path character
 13034 00002B87 E85A07                  		call	SETSTARS		; add wildcards
 13035                                  
 13036                                  CHKSWTCHES:
 13037                                  
 13038                                  	;	We have enough information about the destination for now.
 13039                                  
 13040                                  	;	Turn on verify if requested. Save the current verify flag.
 13041                                  
 13042 00002B8A BA[223A]                		mov	dx,BADPARMPTR
 13043 00002B8D A1[8E42]                		mov	ax,[ALLSWITCH]		; AX = all switch flags
 13044                                  
 13045                                  		; MSDOS 3.3
 13046                                  		;test	ax,~SWITCHCOPY ; 7FE3h
 13047 00002B90 A9E37F                  		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 13048 00002B93 7590                    		jnz	short CERROR4J
 13049                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13050 00002B95 A91000                  		test	ax,SWITCHV ; 10h
 13051 00002B98 7414                    		jz	short NOVERIF		; no /v, no verify
 13052                                  
 13053 00002B9A B454                    		mov	ah,GET_VERIFY_ON_WRITE ; 54h
 13054 00002B9C CD21                    		int	21h		; DOS -	2+ - GET VERIFY	FLAG
 13055                                  					; Return: AL = 00h if flag OFF
 13056                                  					; AL = 01h if flag ON
 13057 00002B9E 1E                      		push	ds
 13058 00002B9F 8E1E[7142]              		mov	ds,[RESSEG]
 13059 00002BA3 30E4                    		xor	ah,ah
 13060 00002BA5 A3F50B                  		mov	word [VERVAL],ax	; save current verify flag
 13061 00002BA8 1F                      		pop	ds
 13062 00002BA9 B8012E                  		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 13063 00002BAC CD21                    		int	21h		; DOS -	SET VERIFY FLAG
 13064                                  					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 13065                                  NOVERIF:
 13066                                  		;*	Scan for first source.
 13067                                  
 13068 00002BAE 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13069 00002BB0 BE8100                  		mov	si,81h			; SI = ptr into command line
 13070 00002BB3 8A1E[FF3E]              		mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 13071                                  SCANFSRC:
 13072 00002BB7 BF[2E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13073 00002BBA E85707                  		call	CPARSE			; parse first source pathname
 13074 00002BBD F6C701                  		test	bh,1			; switch?
 13075 00002BC0 75F5                    		jnz	short SCANFSRC		; yes, try again
 13076 00002BC2 092E[8C42]              		or	[DESTSWITCH],bp		; include copy-wide switches on dest
 13077                                  
 13078                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 13079                                  
 13080                                  		;test	bp,8
 13081 00002BC6 F7C50800                		test	bp,SWITCHB
 13082 00002BCA 750C                    		jnz	short NOSETCASC		; /b - explicit binary copy
 13083 00002BCC 803E[8642]00            		cmp	byte [CONCAT],0
 13084 00002BD1 7405                    		je	short NOSETCASC		; we're not concatenating
 13085                                  		;mov	byte [ASCII],4
 13086 00002BD3 C606[8E45]04            		mov	byte [ASCII],SWITCHA	; set ascii copy
 13087                                  NOSETCASC:
 13088 00002BD8 E89703                  		call	SOURCE_SET		; set source variables
 13089 00002BDB E83B00                  		call	FRSTSRC			; set up first source copy
 13090 00002BDE E99000                  		jmp	FIRSTENT		; jump into the copy loop
 13091                                  
 13092                                  ; ---------------------------------------------------------------------------
 13093                                  
 13094                                  ENDCOPY:
 13095                                  
 13096                                  	;*	End of the road. Close destination, display # files
 13097                                  	;	copied (meaning # destinations), and go back to main
 13098                                  	;	transient COMMAND code.
 13099                                  
 13100 00002BE1 E8A802                  		call	CLOSEDEST
 13101                                  ENDCOPY2:
 13102 00002BE4 BA[FE38]                		mov	dx,COPIEDPTR
 13103 00002BE7 8B36[9942]              		mov	si,[FILECNT]
 13104 00002BEB 8936[5044]              		mov	[COPY_NUM],si
 13105 00002BEF E8E108                  		call	STD_PRINTF
 13106 00002BF2 E90FD5                  		jmp	TCOMMAND		; stack could be messed up
 13107                                  
 13108                                  ; ---------------------------------------------------------------------------
 13109                                  
 13110                                  SRCNONEXIST:
 13111                                  
 13112                                  	;*	Source doesn't exist.  If concatenating, ignore and continue.
 13113                                  	;	Otherwise, say 'file not found' and quit.
 13114                                  
 13115 00002BF5 803E[8642]00            		cmp	byte [CONCAT],0
 13116 00002BFA 753A                    		jne	short NEXTSRC	; concatenating - go on to next source
 13117                                  
 13118                                  		; MSDOS 3.3
 13119 00002BFC BA[D444]                		mov	dx,SRCBUF
 13120 00002BFF 8916[4844]              		mov	[STRING_PTR_1],dx
 13121 00002C03 BA[2D37]                		mov	dx,STRINGBUF1PTR
 13122 00002C06 E8CA08                  		call	STD_PRINTF
 13123 00002C09 BA[F837]                		mov	dx,FNOTFOUNDPTR
 13124 00002C0C E9B104                  		jmp	COPYERR
 13125                                  
 13126                                  		; MSDOS 6.0
 13127                                  	;	Set up error message.
 13128                                  		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
 13129                                  		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
 13130                                  		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
 13131                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
 13132                                  		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
 13133                                  		;
 13134                                  		;jmp	CopErr			; print msg and clean up
 13135                                  
 13136                                  ; ---------------------------------------------------------------------------
 13137                                  
 13138                                  SOURCEPROC:
 13139                                  
 13140                                  	;*	Preparatory processing for each source file.
 13141                                  	;	Called at FrstSrc for first source file.
 13142                                  
 13143 00002C0F E86003                  		call	SOURCE_SET		; set source variables & ascii/binary
 13144 00002C12 803E[8642]00            		cmp	byte [CONCAT],0
 13145 00002C17 750B                    		jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 13146                                  
 13147                                  ; ---------------------------------------------------------------------------
 13148                                  
 13149                                  FRSTSRC:
 13150 00002C19 31C0                    		xor	ax,ax
 13151 00002C1B A2[9042]                		mov	[CFLAG],al		; 'destination not created'
 13152 00002C1E A3[9442]                		mov	[NXTADD],ax		; copy buffer ptr = 0
 13153 00002C21 A2[9142]                		mov	[DESTCLOSED],al		; 'destination not closed'
 13154                                  
 13155                                  LEAVECFLAG:
 13156 00002C24 8936[8545]              		mov	[SRCPT],si		; save cmd-line ptr
 13157 00002C28 BF[5341]                		mov	di,USERDIR1		; DI = ptr to buf for user's 
 13158                                  						;   current dir
 13159 00002C2B BD[CF44]                		mov	bp,SRCVARS		; BP = base of source variables
 13160 00002C2E E8D705                  		call	BUILDPATH		; cd to source dir, figure
 13161                                  						;   out stuff about source
 13162 00002C31 8B36[D144]              		mov	si,[SRCTAIL]		; SI = ptr to source filename
 13163 00002C35 C3                      		retn
 13164                                  
 13165                                  ; ---------------------------------------------------------------------------
 13166                                  
 13167                                  NEXTSRC:
 13168                                  
 13169                                  	;*	Next source. Come here after handling each pathname.
 13170                                  	;	We're done unless there are additional source pathnames
 13171                                  	;	to be appended.
 13172                                  	;
 13173                                  	;	Note that all files matching an ambiguous pathname
 13174                                  	;	are processed before coming here.
 13175                                  
 13176 00002C36 803E[8F45]00            		cmp	byte [PLUS],0
 13177 00002C3B 7502                    		jne	short MORECP		; copying "+" sources - keep going
 13178                                  
 13179                                  ENDCOPYJ2:
 13180 00002C3D EBA2                    		jmp	short ENDCOPY
 13181                                  
 13182                                  MORECP:
 13183 00002C3F 31ED                    		xor	bp,bp			; BP = switch flags accumulator
 13184 00002C41 8B36[8545]              		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 13185 00002C45 8A1E[FF3E]              		mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 13186                                  
 13187                                  SCANSRC:
 13188 00002C49 BF[2E45]                		mov	di,SCANBUF		; DI = ptr to pathname buf
 13189 00002C4C E8C506                  		call	CPARSE			; parse first source name
 13190 00002C4F 72EC                    		jb	short ENDCOPYJ2		; CR found - we're done
 13191                                  
 13192 00002C51 F6C780                  		test	bh,80h
 13193 00002C54 74E7                    		jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 13194                                  
 13195 00002C56 F6C701                  		test	bh,1
 13196 00002C59 75EE                    		jnz	short SCANSRC		; switch found - keep looking
 13197                                  
 13198                                  	;	ScanBuf contains the next source pathname.
 13199                                  
 13200 00002C5B E8B1FF                  		call	SOURCEPROC		; prepare this source
 13201 00002C5E 803E[C643]01            		cmp	byte [COMMA],1		; was +,, found last time?
 13202 00002C63 7507                    		jnz	short NOSTAMP		;  no - try for a file
 13203 00002C65 C606[C743]01            		mov	byte [PLUS_COMMA],1	; yes - set flag
 13204 00002C6A EB89                    		jmp	short SRCNONEXIST	; we know we won't find it
 13205                                  
 13206                                  NOSTAMP:
 13207 00002C6C C606[C743]00            		mov	byte [PLUS_COMMA],0	; reset +,, flag
 13208                                  
 13209                                  ; ---------------------------------------------------------------------------
 13210                                  
 13211                                  FIRSTENT:
 13212                                  
 13213                                  ;M047
 13214                                  ; The only case we need to worry about is when the source is wildcarded and
 13215                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 13216                                  ;concatenation. We check for this case.
 13217                                  ;
 13218                                  ;NB: This change has been backed out and replaced by M048. This is not the
 13219                                  ;right place to do this check.
 13220                                  
 13221                                  	;	This is where we enter the loop with the first source.
 13222                                  
 13223 00002C71 BF5C00                  		mov	di,FCB ; 5Ch		; DI = ptr to FCB
 13224 00002C74 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13225 00002C77 CD21                    		int	21h		; DOS -	PARSE FILENAME
 13226                                  					; DS:SI	-> string to parse
 13227                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13228                                  					; AL = bit mask	to control parsing
 13229 00002C79 803C00                  		cmp	byte [si],0		; did we parse the whole thing?
 13230 00002C7C 7516                    		jne	short SRCHDONE		; no, error, simulate 'not found'
 13231 00002C7E A1[D444]                		mov	ax,[SRCBUF]		; AX = possible "d:"
 13232 00002C81 80FC3A                  		cmp	ah,':'
 13233 00002C84 7402                    		je	short DRVSPEC1		; AX = definite "d:"
 13234 00002C86 B040                    		mov	al,'@'			; AL = drive 'letter' for current drive
 13235                                  DRVSPEC1:
 13236 00002C88 0C20                    		or	al,20h			; AL = lowercase drive letter
 13237 00002C8A 2C60                    		sub	al,60h			; AL = drive id (0=current,1=A,..)
 13238                                  		;mov	[5Ch],al
 13239 00002C8C A25C00                  		mov	[FCB],al		; put drive id in FCB
 13240                                  
 13241                                  	;	FCB contains drive and filename to search.
 13242                                  		
 13243 00002C8F B411                    		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
 13244 00002C91 E80701                  		call	SEARCH
 13245                                  SRCHDONE:
 13246 00002C94 9C                      		pushf				; save flags from Search
 13247 00002C95 E8F6EB                  		call	RESTUDIR1		; restore users current directory
 13248 00002C98 9D                      		popf				; restore flags from search
 13249 00002C99 7403                    		jz	short NEXTAMBIG0	; found the source - continue
 13250 00002C9B E957FF                  		jmp	SRCNONEXIST		; didn't find the source
 13251                                  
 13252                                  NEXTAMBIG0:
 13253 00002C9E 30C0                    		xor	al,al
 13254 00002CA0 8606[9642]              		xchg	al,[FRSTSRCH]
 13255 00002CA4 08C0                    		or	al,al
 13256 00002CA6 740B                    		jz	short NEXTAMBIG
 13257                                  SETNMEL:
 13258 00002CA8 B90C00                  		mov	cx,12
 13259 00002CAB BF[B043]                		mov	di,SDIRBUF
 13260 00002CAE BE[6A43]                		mov	si,DIRBUF
 13261 00002CB1 F3A4                    		rep movsb			; save very first source name
 13262                                  NEXTAMBIG:
 13263 00002CB3 30C0                    		xor	al,al
 13264 00002CB5 A2[8945]                		mov	[NOWRITE],al		; turn off nowrite
 13265 00002CB8 8B3E[D144]              		mov	di,[SRCTAIL]
 13266 00002CBC BE[6B43]                		mov	si,DIRBUF+1
 13267 00002CBF E8D6EC                  		call	FCB_TO_ASCZ		; SrcBuf has complete name
 13268                                  MELDO:
 13269 00002CC2 803E[8642]00            		cmp	byte [CONCAT],0
 13270 00002CC7 7507                    		jnz	short SHOWCPNAM		; concatenating - show name
 13271 00002CC9 F606[D344]02            		test	byte [SRCINFO],2	; wildcard - show name
 13272 00002CCE 7410                    		jz	short DOREAD
 13273                                  SHOWCPNAM:
 13274 00002CD0 BA[D444]                		mov	dx,SRCBUF
 13275 00002CD3 8916[4E44]              		mov	[STRING_PTR_2],dx
 13276 00002CD7 BA[3F37]                		mov	dx,STRINGBUF2PTR
 13277 00002CDA E8F607                  		call	STD_PRINTF
 13278 00002CDD E88CEC                  		call	CRLF2
 13279                                  DOREAD:
 13280 00002CE0 E8C900                  		call	DOCOPY
 13281 00002CE3 803E[8642]00            		cmp	byte [CONCAT],0
 13282 00002CE8 750A                    		jnz	short NODCLOSE		; concatenating - don't close dest
 13283                                  
 13284 00002CEA E89F01                  		call	CLOSEDEST		; close current destination
 13285 00002CED 7205                    		jc	short NODCLOSE		; concatenating - dest not closed
 13286                                  
 13287 00002CEF C606[9042]00            		mov	byte [CFLAG],0		; 'destination not created'
 13288                                  NODCLOSE:
 13289 00002CF4 803E[8642]00            		cmp	byte [CONCAT],0		
 13290 00002CF9 740C                    		jz	short NOFLUSH
 13291                                  
 13292                                  ;	Concatenating - flush output between source files so LostErr
 13293                                  ;	stuff works correctly.
 13294                                  
 13295                                  		;invoke	FlshFil  ; MSDOS 6.0
 13296                                  
 13297 00002CFB E8AA02                  		call	FLUSHFIL ; MSDOS 3.3
 13298 00002CFE F606[CC44]FF            		test	byte [MELCOPY],0FFh
 13299 00002D03 7402                    		jz	short NOFLUSH
 13300 00002D05 EB0C                    		jmp	short DOMELCOPY
 13301                                  NOFLUSH:
 13302 00002D07 E88500                  		call	SEARCHNEXT		; try next match
 13303 00002D0A 755F                    		jnz	short NEXTSRCJ		; not found - finished with 
 13304                                  						;   this source spec
 13305 00002D0C C606[9142]00            		mov	byte [DESTCLOSED],0	; 'destination not closed'
 13306                                  
 13307 00002D11 EBA0                    		jmp	short NEXTAMBIG		; do next ambig match
 13308                                  
 13309                                  DOMELCOPY:
 13310 00002D13 803E[CC44]FF            		cmp	byte [MELCOPY],0FFh
 13311 00002D18 740D                    		je	short CONTMEL
 13312 00002D1A 8B36[8545]              		mov	si,[SRCPT]
 13313 00002D1E 8936[CD44]              		mov	[MELSTART],si
 13314 00002D22 C606[CC44]FF            		mov	byte [MELCOPY],0FFh
 13315                                  
 13316                                  CONTMEL:
 13317 00002D27 31ED                    		xor	bp,bp
 13318 00002D29 8B36[8545]              		mov	si,[SRCPT]
 13319 00002D2D 8A1E[FF3E]              		mov	bl,[PLUS_CHR]
 13320                                  SCANSRC2:
 13321 00002D31 BF[2E45]                		mov	di,SCANBUF
 13322 00002D34 E8DD05                  		call	CPARSE
 13323 00002D37 F6C780                  		test	bh,80h
 13324 00002D3A 7432                    		jz	short NEXTMEL		; no "+" - go back to start
 13325 00002D3C F6C701                  		test	bh,1
 13326 00002D3F 75F0                    		jnz	short SCANSRC2		; switch - keep scanning
 13327 00002D41 E8CBFE                  		call	SOURCEPROC
 13328 00002D44 E847EB                  		call	RESTUDIR1
 13329 00002D47 BF[EB42]                		mov	di,DESTFCB2
 13330 00002D4A B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 13331 00002D4D CD21                    		int	21h		; DOS -	PARSE FILENAME
 13332                                  					; DS:SI	-> string to parse
 13333                                  					; ES:DI	-> buffer to fill with unopened	FCB
 13334                                  					; AL = bit mask	to control parsing
 13335 00002D4F BB[B143]                		mov	bx,SDIRBUF+1
 13336 00002D52 BE[EC42]                		mov	si,DESTFCB2+1
 13337 00002D55 8B3E[D144]              		mov	di,[SRCTAIL]
 13338                                  
 13339 00002D59 E87B04                  		call	BUILDNAME
 13340                                  
 13341 00002D5C 803E[8642]00            		cmp	byte [CONCAT],0
 13342 00002D61 7405                    		je	short MELDOJ		; not concatenating - continue
 13343                                  
 13344                                  	;	Yes, turn off nowrite because this part of the code 
 13345                                  	;	is only reached after the first file has been dealt with.
 13346                                  
 13347 00002D63 C606[8945]00            		mov	byte [NOWRITE],0
 13348                                  MELDOJ:
 13349 00002D68 E957FF                  		jmp	MELDO
 13350                                  
 13351                                  NEXTSRCJ:
 13352 00002D6B E9C8FE                  		jmp	NEXTSRC
 13353                                  
 13354                                  NEXTMEL:
 13355 00002D6E E81B01                  		call	CLOSEDEST
 13356 00002D71 31C0                    		xor	ax,ax
 13357 00002D73 A2[9042]                		mov	[CFLAG],al
 13358 00002D76 A3[9442]                		mov	[NXTADD],ax
 13359 00002D79 A2[9142]                		mov	[SPECDRV],al
 13360 00002D7C 8B36[CD44]              		mov	si,[MELSTART]
 13361 00002D80 8936[8545]              		mov	[SRCPT],si
 13362 00002D84 E80800                  		call	SEARCHNEXT
 13363 00002D87 7403                    		jz	short SETNMELJ
 13364 00002D89 E958FE                  		jmp	ENDCOPY2
 13365                                  
 13366                                  SETNMELJ:
 13367 00002D8C E919FF                  		jmp	SETNMEL
 13368                                  
 13369                                  ; ---------------------------------------------------------------------------
 13370                                  
 13371                                  SEARCHNEXT:
 13372 00002D8F B412                    		mov	ah,DIR_SEARCH_NEXT ; 12h
 13373 00002D91 F606[D344]02            		test	byte [SRCINFO],2
 13374 00002D96 7503                    		jnz	short SEARCH		; do search-next if ambig
 13375 00002D98 08E4                    		or	ah,ah			; reset zero flag
 13376 00002D9A C3                      		retn
 13377                                  
 13378                                  ; ---------------------------------------------------------------------------
 13379                                  
 13380                                  SEARCH:
 13381 00002D9B 50                      		push	ax
 13382 00002D9C B41A                    		mov	ah,SET_DMA ; 1Ah
 13383 00002D9E BA[6A43]                		mov	dx,DIRBUF	; put result of search in dirbuf
 13384 00002DA1 CD21                    		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13385                                  				; DS:DX	-> disk	transfer buffer
 13386 00002DA3 58                      		pop	ax		; restore search first/next command
 13387 00002DA4 BA5C00                  		mov	dx,FCB ; 5Ch
 13388 00002DA7 CD21                    		int	21h		; Do the search
 13389 00002DA9 08C0                    		or	al,al
 13390 00002DAB C3                      		retn
 13391                                  
 13392                                  ; ---------------------------------------------------------------------------
 13393                                  
 13394                                  DOCOPY:
 13395 00002DAC BE[D444]                		mov	si,SRCBUF	; do name translate of source
 13396 00002DAF BF[9F3F]                		mov	di,SRCXNAME	; save for name comparison
 13397 00002DB2 B460                    		mov	ah,XNAMETRANS ; 60h
 13398 00002DB4 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 13399                                  				; DS:SI	-> ASCIZ relative path string or directory name
 13400                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 13401 00002DB6 C606[8442]00            		mov	byte [RDEOF],0	; no EOF yet
 13402                                  
 13403                                  		; MSDOS 6.0
 13404                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13405                                  ;M046
 13406                                  ; For reads, the sharing mode should be deny none so that any process can
 13407                                  ;open this file again in any other sharing mode. This is mainly to allow
 13408                                  ;multiple command.com's to access the same file without getting sharing
 13409                                  ;violations
 13410                                  ;
 13411                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
 13412                                  		;xor	cx,cx				; no special files
 13413                                  		;mov	dx,READ_OPEN_FLAG		; set up open flags
 13414                                  		;int	21h
 13415                                  		;
 13416                                  		;jnc	OpenOk
 13417                                  
 13418                                  	;	Bogosity:  IBM wants us to issue Access Denied in this case.
 13419                                  	;	They asked for it...
 13420                                  
 13421                                  		;jmp	short Error_On_Source 		;AC022; clean up and exit
 13422                                  
 13423                                  		; MSDOS 3.3
 13424 00002DBB BA[D444]                		mov	dx,SRCBUF
 13425 00002DBE B8003D                  		mov	ax,OPEN*256 ; 3D00h
 13426 00002DC1 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 13427                                  					; DS:DX	-> ASCIZ filename
 13428                                  					; AL = access mode
 13429                                  					; 0 - read
 13430 00002DC3 7311                    		jnc	short OPENOK
 13431 00002DC5 E802F1                  		call	GET_EXT_ERR_NUMBER
 13432 00002DC8 9C                      		pushf
 13433 00002DC9 83F841                  		cmp	ax,65
 13434 00002DCC 7506                    		jnz	short DOCOPY_ERR
 13435 00002DCE BA[1D38]                		mov	dx,ACCDENPTR
 13436 00002DD1 E8FF06                  		call	STD_PRINTF
 13437                                  DOCOPY_ERR:
 13438 00002DD4 9D                      		popf
 13439 00002DD5 C3                      		retn
 13440                                  
 13441                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13442                                  OPENOK:
 13443 00002DD6 89C3                    		mov	bx,ax
 13444 00002DD8 891E[2B45]              		mov	[SRCHAND],bx		; save handle
 13445 00002DDC B80057                  		mov	ax,FILE_TIMES*256 ; 5700h
 13446 00002DDF CD21                    		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 13447                                  					; BX = file handle
 13448                                  
 13449                                  		;jc	Error_On_Source  ; MSDOS 6.0
 13450                                  
 13451 00002DE1 8916[9145]              		mov	[CPDATE],dx		; save date
 13452 00002DE5 890E[9345]              		mov	[CPTIME],cx		; save time
 13453                                  
 13454                                  		; MSDOS 6.0
 13455                                  		;jmp	short No_Copy_Xa  ; (xa copy code removed)
 13456                                  
 13457                                  ;Error_On_Source:				;AN022; we have a BAD error
 13458                                  		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
 13459                                  		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
 13460                                  		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13461                                  		;invoke	Std_EprintF		;AN022; print it
 13462                                  		;cmp	SrcHand,0		;AN022; did we open the file?
 13463                                  		;je	No_Close_Src		;AN022; no - don't close
 13464                                  		;call	CloseSrc		;AN022; clean up
 13465                                  ;No_Close_Src:					;AN022;
 13466                                  		;cmp	CFlag,0			;AN022; was destination created?
 13467                                  		;je	EndCopyJ3		;AN022; no - just cleanup and exit
 13468                                  		;jmp	EndCopy			;AN022; clean up concatenation and exit
 13469                                  ;EndCopyJ3:					;AN022;
 13470                                  		;jmp	EndCopy2		;AN022;
 13471                                  ;No_Copy_Xa:
 13472                                  		;mov	bx,SrcHand		;AN022; get handle back
 13473                                  
 13474                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13475 00002DE9 B80044                  		mov	ax,(IOCTL<<8) ; 4400h
 13476 00002DEC CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13477                                  					; BX = file or device handle
 13478 00002DEE 80E280                  		and	dl,devid_ISDEV ; 80h
 13479 00002DF1 8816[2D45]              		mov	[SRCISDEV],dl		; set source info
 13480 00002DF5 740D                    		jz	short COPYLP		; source not a device
 13481 00002DF7 803E[8A45]00            		cmp	byte [BINARY],0
 13482 00002DFC 7406                    		je	short COPYLP		; ascii device ok
 13483 00002DFE BA[FB3C]                		mov	dx,INBDEVPTR		; cannot do binary input
 13484 00002E01 E9BC02                  		jmp	COPYERR
 13485                                  
 13486                                  COPYLP:
 13487 00002E04 8B1E[2B45]              		mov	bx,[SRCHAND]
 13488 00002E08 8B0E[9242]              		mov	cx,[BYTCNT]
 13489 00002E0C 8B16[9442]              		mov	dx,[NXTADD]
 13490 00002E10 29D1                    		sub	cx,dx			; compute available space
 13491 00002E12 750E                    		jnz	short GOTROOM
 13492                                  		;invoke	FlshFil   ; MSDOS 6.0
 13493 00002E14 E89101                  		call	FLUSHFIL  ; MSDOS 3.3
 13494 00002E17 803E[8D45]00            		cmp	byte [TERMREAD],0
 13495 00002E1C 7565                    		jne	short CLOSESRC		; give up
 13496 00002E1E 8B0E[9242]              		mov	cx,[BYTCNT]
 13497                                  GOTROOM:
 13498 00002E22 1E                      		push	ds
 13499 00002E23 8E1E[7342]              		mov	ds,[TPA]
 13500 00002E27 B43F                    		mov	ah,READ ; 3Fh
 13501 00002E29 CD21                    		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 13502                                  					; BX = file handle,CX = number	of bytes to read
 13503                                  					; DS:DX	-> buffer
 13504 00002E2B 1F                      		pop	ds
 13505 00002E2C 7255                    		jc	short CLOSESRC	; MSDOS 3.3
 13506                                  		;jc	Error_On_Source ; MSDOS 6.0
 13507 00002E2E 89C1                    		mov	cx,ax			; get count
 13508 00002E30 E351                    		jcxz	CLOSESRC		; no more to read
 13509 00002E32 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13510 00002E37 7507                    		jne	short NOTESTA		; is a device, ascii mode
 13511 00002E39 803E[8E45]00            		cmp	byte [ASCII],0
 13512 00002E3E 741B                    		je	short BINREAD
 13513                                  NOTESTA:
 13514 00002E40 89CA                    		mov	dx,cx
 13515 00002E42 8B3E[9442]              		mov	di,[NXTADD]
 13516 00002E46 B01A                    		mov	al,1Ah
 13517 00002E48 06                      		push	es
 13518 00002E49 8E06[7342]              		mov	es,[TPA]		; scan for EOF
 13519 00002E4D F2AE                    		repne scasb
 13520 00002E4F 07                      		pop	es
 13521 00002E50 7505                    		jnz	short USEALL
 13522 00002E52 FE06[8442]              		inc	byte [RDEOF]
 13523 00002E56 41                      		inc	cx
 13524                                  USEALL:
 13525 00002E57 29CA                    		sub	dx,cx
 13526 00002E59 89D1                    		mov	cx,dx
 13527                                  BINREAD:
 13528 00002E5B 030E[9442]              		add	cx,[NXTADD]
 13529 00002E5F 890E[9442]              		mov	[NXTADD],cx
 13530 00002E63 3B0E[9242]              		cmp	cx,[BYTCNT]		; is buffer full?
 13531 00002E67 720C                    		jb	short TESTDEV		; if not, we may have found eof
 13532                                  		;invoke	FlshFil
 13533 00002E69 E83C01                  		call	FLUSHFIL
 13534 00002E6C 803E[8D45]00            		cmp	byte [TERMREAD],0
 13535 00002E71 7510                    		jne	short CLOSESRC		; give up
 13536 00002E73 EB8F                    		jmp	short COPYLP
 13537                                  TESTDEV:
 13538 00002E75 803E[2D45]00            		cmp	byte [SRCISDEV],0	; if file then EOF
 13539 00002E7A 7407                    		je	short CLOSESRC
 13540 00002E7C 803E[8442]00            		cmp	byte [RDEOF],0
 13541 00002E81 7481                    		je	short COPYLP		; on device, go till ^Z
 13542                                  CLOSESRC:
 13543 00002E83 8B1E[2B45]              		mov	bx,[SRCHAND]
 13544 00002E87 B43E                    		mov	ah,CLOSE ; 3Eh
 13545 00002E89 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13546                                  					; BX = file handle
 13547                                  CLOSESRCDEST_RETN:
 13548 00002E8B C3                      		retn
 13549                                  
 13550                                  ; ---------------------------------------------------------------------------
 13551                                  
 13552                                  CLOSEDEST:
 13553                                  
 13554                                  	;	We are called to close the destination.
 13555                                  	;	We need to note whether or not there is any internal data left
 13556                                  	;	to be flushed out.
 13557                                  
 13558 00002E8C 803E[9142]00            		cmp	byte [DESTCLOSED],0
 13559 00002E91 75F8                    		jne	short CLOSESRCDEST_RETN	; don't double close
 13560 00002E93 A0[8C42]                		mov	al,byte [DESTSWITCH]
 13561 00002E96 E86602                  		call	SETASC			; check for b or a switch
 13562 00002E99 7434                    		jz	short BINCLOS		;   on destination
 13563 00002E9B 8B1E[9442]              		mov	bx,[NXTADD]
 13564                                  ;
 13565                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 13566                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 13567                                  ;just return without appending a ^Z incorrectly for the first file (since we
 13568                                  ;are concatenating now). Also, in case it is a single file copy, we will
 13569                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 13570                                  ;performance overhead on single ASCII file copies which now always involve
 13571                                  ;2 writes instead of 1 before. Is this really that important?
 13572                                  ;
 13573                                  ;M048;	cmp	bx,BytCnt		; is memory full?
 13574                                  ;M048;	jne	PutZ
 13575                                  
 13576                                  		; MSDOS 3.3
 13577 00002E9F 3B1E[9242]              		cmp	bx,[BYTCNT]	; is memory full?
 13578 00002EA3 7509                    		jne	short PUTZ
 13579                                  
 13580 00002EA5 E8F300                  		call	TRYFLUSH	; flush (and double-check for concat)	
 13581 00002EA8 7402                    		jz	short NOCONC
 13582                                  CONCHNG:
 13583 00002EAA F9                      		stc
 13584 00002EAB C3                      		retn
 13585                                  
 13586                                  NOCONC:	
 13587 00002EAC 31DB                    		xor	bx,bx
 13588                                  PUTZ:
 13589 00002EAE 1E                      		push	ds
 13590 00002EAF 8E1E[7342]              		mov	ds,[TPA]
 13591 00002EB3 C7071A00                		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 13592 00002EB7 1F                      		pop	ds
 13593 00002EB8 FF06[9442]              		inc	word [NXTADD]	; make sure our ^z gets written	
 13594 00002EBC C606[8945]00            		mov	byte [NOWRITE],0
 13595 00002EC1 A1[8B45]                		mov	ax,[WRITTEN]
 13596 00002EC4 0306[9442]              		add	ax,[NXTADD]
 13597 00002EC8 7205                    		jc	short BINCLOS	; > 1
 13598 00002ECA 83F801                  		cmp	ax,1
 13599 00002ECD 740A                    		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 13600                                  BINCLOS:
 13601 00002ECF E8C900                  		call	TRYFLUSH
 13602 00002ED2 75D6                    		jnz	short CONCHNG
 13603                                  
 13604 00002ED4 803E[8B45]00            		cmp	byte [WRITTEN],0
 13605                                  FORGETITJ:
 13606 00002ED9 747D                    		jz	short FORGETIT	; never wrote nothing
 13607                                  NO_FORGET:				; wrote something
 13608 00002EDB 8B1E[C844]              		mov	bx,[DESTHAND]
 13609 00002EDF 8B0E[9345]              		mov	cx,[CPTIME]
 13610 00002EE3 8B16[9145]              		mov	dx,[CPDATE]
 13611 00002EE7 803E[8745]00            		cmp	byte [INEXACT],0 ; copy not exact?
 13612 00002EEC 7431                    		je	short DODCLOSE	; if no, copy date & time
 13613 00002EEE B42C                    		mov	ah,GET_TIME ; 2Ch
 13614 00002EF0 CD21                    		int	21h		; DOS -	GET CURRENT TIME
 13615                                  					; Return: CH = hours,CL = minutes,DH = seconds
 13616                                  					; DL = hundredths of seconds
 13617 00002EF2 D0E1                    		shl	cl,1
 13618 00002EF4 D0E1                    		shl	cl,1		; left justify min in cl
 13619 00002EF6 D1E1                    		shl	cx,1
 13620 00002EF8 D1E1                    		shl	cx,1
 13621 00002EFA D1E1                    		shl	cx,1		; hours to high 5 bits, min to 5-10
 13622 00002EFC D0EE                    		shr	dh,1		; divide seconds by 2 (now 5 bits)
 13623 00002EFE 08F1                    		or	cl,dh		; and stick into low 5 bits of cx
 13624 00002F00 51                      		push	cx		; save packed time
 13625 00002F01 B42A                    		mov	ah,GET_DATE ; 2Ah
 13626 00002F03 CD21                    		int	21h		; DOS -	GET CURRENT DATE
 13627                                  					; Return: DL = day,DH = month,	CX = year
 13628                                  					; AL = day of the week (0=Sunday,1=Monday,etc.)
 13629 00002F05 81E9BC07                		sub	cx,1980
 13630 00002F09 86E9                    		xchg	ch,cl
 13631 00002F0B D1E1                    		shl	cx,1		; year to high 7 bits
 13632 00002F0D D0E6                    		shl	dh,1		; month to high 3 bits
 13633 00002F0F D0E6                    		shl	dh,1
 13634 00002F11 D0E6                    		shl	dh,1
 13635 00002F13 D0E6                    		shl	dh,1
 13636 00002F15 D0E6                    		shl	dh,1		; most sig bit of month in carry
 13637 00002F17 80D500                  		adc	ch,0		; put that bit next to year
 13638 00002F1A 08F2                    		or	dl,dh		; or low three of month into day
 13639 00002F1C 88EE                    		mov	dh,ch		; get year and high bit of month
 13640 00002F1E 59                      		pop	cx
 13641                                  DODCLOSE:
 13642 00002F1F 83FB00                  		cmp	bx,0
 13643 00002F22 7E2A                    		jle	short CLOSEDONE
 13644 00002F24 B80157                  		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
 13645 00002F27 CD21                    		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 13646                                  					; BX = file handle,CX = time to be set
 13647                                  					; DX = date to be set
 13648                                  		; MSDOS 6.0
 13649                                  		;jc	Cleanup_Err	;AN022; handle error
 13650                                  
 13651                                  	;	See if the destination has *anything* in it.
 13652                                  	;	If not, just close and delete it.
 13653                                  
 13654 00002F29 B80242                  		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 13655 00002F2C 31D2                    		xor	dx,dx
 13656 00002F2E 89D1                    		mov	cx,dx
 13657 00002F30 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 13658                                  					; AL = method: offset from end of file
 13659                                  	;	DX:AX is file size
 13660                                  
 13661 00002F32 09C2                    		or	dx,ax
 13662 00002F34 9C                      		pushf
 13663 00002F35 B80044                  		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 13664 00002F38 CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 13665                                  					; BX = file or device handle
 13666 00002F3A 52                      		push	dx			; save them away
 13667 00002F3B B43E                    		mov	ah,CLOSE ; 3Eh
 13668 00002F3D CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 13669                                  					; BX = file handle
 13670 00002F3F 5A                      		pop	dx
 13671                                  
 13672                                  		; MSDOS 6.0
 13673                                  		;jnc	Close_Cont	;AN022; handle error on close
 13674                                  		;popf			;AN022; get the flags back
 13675                                  ;Cleanup_Err: 				;AN022;
 13676                                  		;call	CleanUpErr	;AN022; attempt to delete the target
 13677                                  		;call	DestDelete	;AN022; attempt to delete the target
 13678                                  		;jmp	short FileClosed ;AN022; close the file
 13679                                  ;Close_Cont:				;AN022; no error - co
 13680                                  		; MSDOS 3.3 (& MSDOS 6.0)
 13681 00002F40 9D                      		popf
 13682 00002F41 750B                    		jnz	short CLOSEDONE
 13683 00002F43 F7C28000                		test	dx,80h		; is the destination a device?
 13684 00002F47 7505                    		jnz	short CLOSEDONE	; yes, copy succeeded
 13685 00002F49 E81E00                  		call	DESTDELETE
 13686 00002F4C EB04                    		jmp	short FILECLOSED
 13687                                  CLOSEDONE:
 13688 00002F4E FF06[9942]              		inc	word [FILECNT]
 13689                                  FILECLOSED:
 13690 00002F52 FE06[9142]              		inc	byte [DESTCLOSED]
 13691                                  RET50:
 13692 00002F56 F8                      		clc
 13693 00002F57 C3                      		retn
 13694                                  
 13695                                  FORGETIT:
 13696 00002F58 8B1E[C844]              		mov	bx,[DESTHAND]
 13697 00002F5C E8C0FF                  		call	DODCLOSE	 ; close the dest	
 13698 00002F5F E80800                  		call	DESTDELETE
 13699 00002F62 C706[9942]0000          		mov	word [FILECNT],0 ; no files transferred
 13700 00002F68 EBEC                    		jmp	short RET50
 13701                                  
 13702                                  ; ---------------------------------------------------------------------------
 13703                                  
 13704                                  DESTDELETE:
 13705 00002F6A BA[7144]                		mov	dx,DESTBUF
 13706 00002F6D B441                    		mov	ah,UNLINK ; 41h
 13707 00002F6F CD21                    		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 13708                                  				; DS:DX	-> ASCIZ pathname of file to delete 
 13709                                  				;		(no wildcards allowed)
 13710 00002F71 C3                      		retn
 13711                                  
 13712                                  ; ---------------------------------------------------------------------------
 13713                                  
 13714                                  SOURCE_SET:
 13715 00002F72 56                      		push	si
 13716 00002F73 A1[9745]                		mov	ax,[STARTEL]
 13717 00002F76 BE[2E45]                		mov	si,SCANBUF	; adjust to copy
 13718 00002F79 29F0                    		sub	ax,si
 13719 00002F7B BF[D444]                		mov	di,SRCBUF
 13720 00002F7E 01F8                    		add	ax,di
 13721 00002F80 A3[D144]                		mov	[SRCTAIL],ax
 13722 00002F83 880E[D044]              		mov	[SRCSIZ],cl	; save its size
 13723 00002F87 41                      		inc	cx		; include the nul
 13724 00002F88 F3A4                    		rep movsb		; save this source
 13725 00002F8A 883E[D344]              		mov	[SRCINFO],bh	; save info about it
 13726 00002F8E 5E                      		pop	si
 13727 00002F8F 89E8                    		mov	ax,bp		; switches so far
 13728 00002F91 E86B01                  		call	SETASC		; set a,b switches accordingly
 13729 00002F94 E813EB                  		call	SWITCH		; get any more switches on this arg
 13730 00002F97 E86501                  		call	SETASC		; set
 13731 00002F9A C3                      		retn
 13732                                  
 13733                                  ; =============== S U B	R O U T	I N E =======================================
 13734                                  
 13735                                  ; MSDOS 6.0
 13736                                  
 13737                                  ;****************************************************************
 13738                                  ;*
 13739                                  ;* ROUTINE:	CleanupErr
 13740                                  ;*
 13741                                  ;* FUNCTION:	Issues extended error message for destination
 13742                                  ;*		if not alreay issued
 13743                                  ;*
 13744                                  ;* INPUT:	return from INT 21
 13745                                  ;*
 13746                                  ;* OUTPUT:	none
 13747                                  ;*
 13748                                  ;****************************************************************
 13749                                  
 13750                                  ;CleanupErr	proc	near		;AN022;
 13751                                  ;
 13752                                  ;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
 13753                                  ;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
 13754                                  ;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
 13755                                  ;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
 13756                                  ;					;AN022; get address of failed string
 13757                                  ;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
 13758                                  ;	invoke	Std_EPrintF		;AN022; issue the error message
 13759                                  ;
 13760                                  ;CleanupErr_Cont:			;AN022;
 13761                                  ;	ret				;AN022; return to caller
 13762                                  ;
 13763                                  ;CleanupErr	endp			;AN022;
 13764                                  
 13765                                  ;============================================================================
 13766                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 13767                                  ;============================================================================
 13768                                  ; 01/10/2018 - Retro DOS v3.0
 13769                                  
 13770                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 13771                                  
 13772                                  ; =============== S U B	R O U T	I N E =======================================
 13773                                  
 13774                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 13775                                  ;
 13776                                  ;	EXIT	ZR set if concatenate flag unchanged
 13777                                  
 13778                                  TRYFLUSH:
 13779 00002F9B A0[8642]                		mov	al,[CONCAT]
 13780 00002F9E 50                      		push	ax
 13781 00002F9F E80600                  		call	FLUSHFIL
 13782 00002FA2 58                      		pop	ax
 13783 00002FA3 3A06[8642]              		cmp	al,[CONCAT]
 13784 00002FA7 C3                      		retn
 13785                                  
 13786                                  ; =============== S U B	R O U T	I N E =======================================
 13787                                  
 13788                                  FLUSHFIL:
 13789 00002FA8 A0[8A45]                		mov	al,[BINARY]
 13790 00002FAB 8A26[8E45]              		mov	ah,[ASCII]
 13791 00002FAF 50                      		push	ax
 13792 00002FB0 E80900                  		call	FLSHFIL
 13793 00002FB3 58                      		pop	ax
 13794 00002FB4 8826[8E45]              		mov	[ASCII],ah
 13795 00002FB8 A2[8A45]                		mov	[BINARY],al
 13796 00002FBB C3                      		retn
 13797                                  
 13798                                  ; =============== S U B	R O U T	I N E =======================================
 13799                                  
 13800                                  ;***	Flshfil - write out any data remaining in copy buffer.
 13801                                  ;
 13802                                  ;	Inputs:
 13803                                  ;	  [NXTADD] = No. of bytes to write
 13804                                  ;	  [CFLAG] <> 0 if file has been created
 13805                                  ;	Outputs:
 13806                                  ;	  [NXTADD] = 0
 13807                                  
 13808                                  FLSHFIL:
 13809 00002FBC C606[8D45]00            		mov	byte [TERMREAD],0
 13810 00002FC1 803E[9042]00            		cmp	byte [CFLAG],0
 13811 00002FC6 7403                    		jz	short NOTEXISTS
 13812 00002FC8 E98300                  		jmp	EXISTS
 13813                                  
 13814                                  NOTEXISTS:
 13815 00002FCB E84B01                  		call	BUILDDEST	; find out all about the destination
 13816 00002FCE E82F03                  		call	COMPNAME	; source and dest. the same?
 13817 00002FD1 7516                    		jnz	short PROCDEST	; if not, go ahead
 13818 00002FD3 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13819 00002FD8 750F                    		jnz	short PROCDEST	; same name on device ok
 13820 00002FDA 803E[8642]00            		cmp	byte [CONCAT],0	; concatenation?
 13821 00002FDF BA[9438]                		mov	dx,OVERWRPTR
 13822 00002FE2 745E                    		je	short COPERR	; not concatenating - overwrite error
 13823                                  		
 13824                                  ;No_Concat_Err:	; concatenating
 13825 00002FE4 C606[8945]01            		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
 13826                                  PROCDEST:
 13827                                  		; MSDOS 6.0
 13828                                  		;mov	ax,EXTOPEN shl 8		; open the file
 13829                                  		;mov	si,offset TRANGROUP:DestBuf	; get file name
 13830                                  ;M046
 13831                                  ; For writes, we want to deny writes by anyone else at the same time that we
 13832                                  ;are writing to it. For instance, on a network, 2 workstations could try
 13833                                  ;writing to the same file. Also, because we opened the source file with
 13834                                  ;DENY NONE, it is fine if the source and destination files are the same as
 13835                                  ;would happen when we append to an existing file.
 13836                                  ;
 13837                                  		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
 13838                                  		;xor	cx,cx				; no special files
 13839                                  		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
 13840                                  		;
 13841                                  		;cmp	NoWrite,0
 13842                                  		;jne	DoDestOpen		; don't actually create if nowrite set
 13843                                  		;mov	dx,CREAT_OPEN_FLAG	; set up create flags
 13844                                  
 13845 00002FE9 B8013D                  		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 13846 00002FEC 803E[8945]00            		cmp	byte [NOWRITE],0
 13847 00002FF1 7504                    		jne	short DODESTOPEN
 13848 00002FF3 B43C                    		mov	ah,CREAT ; 3Ch
 13849 00002FF5 31C9                    		xor	cx,cx
 13850                                  DODESTOPEN:
 13851 00002FF7 BA[7144]                		mov	dx,DESTBUF
 13852 00002FFA CD21                    		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 13853                                  				; CX = attributes for file
 13854                                  				; DS:DX	-> ASCIZ filename (may include drive and path)
 13855                                  		
 13856                                  		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 13857                                  		;mov	dx,FULDIRPTR
 13858                                  		;call	GET_EXT_ERR_NUMBER
 13859                                  		;jc	short COPERR
 13860                                  
 13861                                  		; 01/10/2018
 13862                                  		;jnc	short DEST_OPEN_OKAY
 13863                                  		
 13864                                  		;mov	dx,FULDIRPTR
 13865                                  		;call	GET_EXT_ERR_NUMBER
 13866                                  		;jmp	short COPERR
 13867                                  
 13868 00002FFC 723E                    		jc	short DEST_OPEN_ERROR
 13869                                  
 13870                                  ;DEST_OPEN_OKAY:
 13871 00002FFE A3[C844]                		mov	[DESTHAND],ax	; save handle
 13872 00003001 C606[9042]01            		mov	byte [CFLAG],1	; destination now exists
 13873 00003006 89C3                    		mov	bx,ax
 13874 00003008 B80044                  		mov	ax,IOCTL*256 ; 4400h ; get device stuff
 13875 0000300B CD21                    		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 13876                                  				   	; BX = file or device handle
 13877                                  
 13878 0000300D 8816[CA44]              		mov	[DESTISDEV],dl	; set dest info
 13879                                  		;test	dl,80h
 13880 00003011 F6C280                  		test	dl,devid_ISDEV
 13881 00003014 7438                    		jz	short EXISTS	; Dest not a device
 13882                                  
 13883                                  ;	Destination is device.
 13884                                  
 13885 00003016 A0[8C42]                		mov	al,byte [DESTSWITCH]
 13886                                  		;and	al,0Ch
 13887 00003019 240C                    		and	al,SWITCHA+SWITCHB
 13888 0000301B 7509                    		jnz	short TESTBOTH
 13889 0000301D A0[8E45]                		mov	al,[ASCII]	; neither set, use current setting
 13890 00003020 0A06[8A45]              		or	al,[BINARY]
 13891 00003024 741E                    		jz	short EXSETA	; neither set, default to ascii
 13892                                  TESTBOTH:
 13893 00003026 7A26                    		jpe	short EXISTS	; both are set, ignore
 13894                                  		;test	al,8
 13895 00003028 A808                    		test	al,SWITCHB
 13896 0000302A 7422                    		jz	short EXISTS
 13897                                  		;mov	ax,(IOCTL shl 8) or 1
 13898 0000302C B80144                  		mov	ax,(IOCTL<<8)|1 ; 4401h
 13899 0000302F 30F6                    		xor	dh,dh
 13900                                  		;or	dl,20h
 13901 00003031 80CA20                  		or	dl,devid_RAW
 13902 00003034 8816[CA44]              		mov	[DESTISDEV],dl
 13903 00003038 CD21                    		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 13904                                  				; BX = device handle,DH = 0
 13905                                  				; DL = device information to set (bits 0-7 from	function 0)
 13906 0000303A EB12                    		jmp	short EXISTS
 13907                                  
 13908                                  		; 01/10/2018 - Retro DOS v3.0 modification
 13909                                  DEST_OPEN_ERROR:
 13910 0000303C BA[6E38]                		mov	dx,FULDIRPTR
 13911 0000303F E888EE                  		call	GET_EXT_ERR_NUMBER
 13912                                  COPERR:
 13913 00003042 EB7C                    		jmp	short COPYERR
 13914                                  
 13915                                  EXSETA:
 13916                                  
 13917                                  ;	What we read in may have been in binary mode, flag zapped write OK
 13918                                  
 13919                                  		;mov	byte [ASCII],4
 13920 00003044 C606[8E45]04            		mov	byte [ASCII],SWITCHA	; set ascii mode
 13921                                  		;or	byte [INEXACT],4
 13922 00003049 800E[8745]04            		or	byte [INEXACT],SWITCHA	; ascii -> inexact
 13923                                  EXISTS:
 13924 0000304E 803E[8945]00            		cmp	byte [NOWRITE],0
 13925 00003053 7524                    		jnz	short NOCHECKING	; if nowrite don't bother with name check
 13926 00003055 803E[C743]01            		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
 13927 0000305A 741D                    		jz	short NOCHECKING
 13928 0000305C E8A102                  		call	COMPNAME		; source and dest. the same?
 13929 0000305F 7518                    		jnz	short NOCHECKING	; if not, go ahead
 13930 00003061 803E[2D45]00            		cmp	byte [SRCISDEV],0
 13931 00003066 7511                    		jne	short NOCHECKING	; same name on device ok
 13932                                  
 13933                                  ;	At this point we know in append (would have gotten overwrite error
 13934                                  ;	on first destination create otherwise), and user trying to specify
 13935                                  ;	destination which has been scribbled already (if dest had been named
 13936                                  ;	first, NoWrite would be set).
 13937                                  
 13938 00003068 BA[C038]                		mov	dx,LOSTERRPTR		; tell him he's not going to get it
 13939                                  		;invoke	Std_EprintF		;ac022;
 13940 0000306B E86504                  		call	STD_PRINTF
 13941 0000306E C706[9442]0000          		mov	word [NXTADD],0		; set return
 13942 00003074 FE06[8D45]              		inc	byte [TERMREAD]		; tell read to give up
 13943                                  RET60:
 13944 00003078 C3                      		retn
 13945                                  
 13946                                  NOCHECKING:
 13947 00003079 8B1E[C844]              		mov	bx,[DESTHAND]		; get handle
 13948 0000307D 31C9                    		xor	cx,cx
 13949 0000307F 870E[9442]              		xchg	cx,[NXTADD]
 13950 00003083 E3F3                    		jcxz	RET60			; if nothing to write, forget it
 13951 00003085 FF06[8B45]              		inc	word [WRITTEN]		; flag that we wrote something
 13952 00003089 803E[8945]00            		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 13953 0000308E 755A                    		jnz	short SEEKEND
 13954 00003090 31D2                    		xor	dx,dx
 13955 00003092 1E                      		push	ds
 13956 00003093 8E1E[7342]              		mov	ds,[TPA]
 13957 00003097 B440                    		mov	ah,WRITE ; 40h
 13958 00003099 CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 13959                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 13960 0000309B 1F                      		pop	ds
 13961 0000309C BA[3938]                		mov	dx,NOSPACEPTR
 13962 0000309F 7222                    		jc	short COPERRP		; failure
 13963 000030A1 29C1                    		sub	cx,ax
 13964 000030A3 74D3                    		jz	short RET60		; wrote all supposed to
 13965 000030A5 F606[CA44]80            		test	byte [DESTISDEV],devid_ISDEV ;80h
 13966 000030AA 7414                    		jz	short COPYERR		; is a file, error
 13967 000030AC F606[CA44]20            		test	byte [DESTISDEV],devid_RAW ; 20h
 13968 000030B1 750A                    		jnz	short DEVWRTERR		; is a raw device, error
 13969 000030B3 803E[8745]00            		cmp	byte [INEXACT],0
 13970 000030B8 75BE                    		jnz	short RET60		; inexact so ok
 13971 000030BA 49                      		dec	cx
 13972                                  RETZ60:
 13973 000030BB 74BB                    		jz	short RET60		; wrote one byte less (the ^z)		
 13974                                  
 13975                                  DEVWRTERR:
 13976 000030BD BA[893D]                		mov	dx,DEVWMESPTR
 13977                                  
 13978                                  COPYERR:
 13979                                  		;invoke	Std_EPrintF		;AC022;
 13980 000030C0 E81004                  		call	STD_PRINTF
 13981                                  COPERRP:
 13982 000030C3 FE06[9142]              		inc	byte [DESTCLOSED]
 13983 000030C7 803E[9042]00            		cmp	byte [CFLAG],0
 13984 000030CC 7419                    		jz	short ENDCOPYJ		; never actually got it open
 13985 000030CE 8B1E[C844]              		mov	bx,[DESTHAND]
 13986 000030D2 83FB00                  		cmp	bx,0
 13987 000030D5 7E04                    		jle	short NOCLOSE
 13988                                  
 13989                                  ;	Check to see if we should save part of the destination file.
 13990                                  
 13991                                  		; MSDOS 6.0
 13992                                  		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
 13993                                  		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
 13994                                  			
 13995                                  		;mov	ax,cx
 13996                                  		;or	ax,dx
 13997                                  		;jz	ceClose			; null file ptr means nothing to save
 13998                                  
 13999                                  ;	Destination was also the first source.  Do the best we can to
 14000                                  ;	restore it.  Truncate it back to the size we took from it (which
 14001                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 14002                                  ;	file).  If a Ctrl-Z was originally read, put it back.
 14003                                  
 14004                                  		;mov	ax,LSEEK shl 8
 14005                                  		;int	21h
 14006                                  
 14007                                  		;xor	cx,cx			; CX = # bytes to write = 0
 14008                                  		;mov	ah,WRITE
 14009                                  		;int	21h			; truncate file
 14010                                  
 14011                                  		;cmp	OCtrlZ,0
 14012                                  		;je	@f			; no ctrl-z removed from original
 14013                                  		;inc	cx			; CX = # bytes to write = 1
 14014                                  		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
 14015                                  		;mov	ah,WRITE
 14016                                  		;int	21h			; write ctrl-z
 14017                                  ;@@:
 14018                                  		;mov	ah,CLOSE
 14019                                  		;int	21h			; close it
 14020                                  ;;		;mov	CFlag,0
 14021                                  		;jmp	EndCopy			; and go home
 14022                                  
 14023                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14024                                  CECLOSE:
 14025 000030D7 B43E                    		mov	ah,CLOSE ; 3Eh		; close the file
 14026 000030D9 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14027                                  					; BX = file handle
 14028                                  NOCLOSE:
 14029 000030DB BA[7144]                		mov	dx,DESTBUF
 14030 000030DE B441                    		mov	ah,UNLINK ; 41h 	; and delete it
 14031 000030E0 CD21                    		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 14032                                  					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 14033 000030E2 C606[9042]00            		mov	byte [CFLAG],0
 14034                                  ENDCOPYJ:
 14035 000030E7 E9F7FA                  		jmp	ENDCOPY
 14036                                  
 14037                                  SEEKEND:
 14038 000030EA 31D2                    		xor	dx,dx
 14039 000030EC 87D1                    		xchg	dx,cx
 14040                                  		;mov	ax,(LSEEK shl 8) or 1
 14041 000030EE B80142                  		mov	ax,(LSEEK<<8)|1 ; 4201h
 14042 000030F1 CD21                    		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 14043                                  					; AL = method: offset from present location
 14044 000030F3 803E[8442]00            		cmp	byte [RDEOF],0
 14045 000030F8 74C1                    		jz	short RETZ60
 14046                                  
 14047                                  ;	^Z has been read - we must set the file size to the current
 14048                                  ;	file pointer location
 14049                                  
 14050 000030FA B440                    		mov	ah,WRITE ; 40h
 14051 000030FC CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 14052                                  					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 14053                                  
 14054                                  		; MSDOS 6.0
 14055                                  		;jc	Xa_Set_Error_Jmp	;AC022; failure
 14056                                  
 14057                                  ;	Make note that ^Z was removed, in case the
 14058                                  ;	copy should fail and we need to restore the file.
 14059                                  
 14060                                  		;mov	OCtrlZ,1Ah
 14061                                  
 14062 000030FE C3                      		retn
 14063                                  
 14064                                  ;============================================================================
 14065                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 14066                                  ;============================================================================
 14067                                  ; 01/10/2018 - Retro DOS v3.0
 14068                                  
 14069                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 14070                                  
 14071                                  ; =============== S U B	R O U T	I N E =======================================
 14072                                  
 14073                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 14074                                  ;
 14075                                  ;	Given switch vector in AX,
 14076                                  ;	  Set Ascii flag if /a is set
 14077                                  ;	  Clear Ascii flag if /b is set
 14078                                  ;	  Binary set if /b specified
 14079                                  ;	  Leave Ascii unchanged if neither or both are set
 14080                                  ; 	Also sets Inexact if Ascii is ever set. 
 14081                                  ;	AL = Ascii on exit, flags set
 14082                                  
 14083                                  SETASC:
 14084 000030FF 240C                    		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 14085 00003101 7A10                    		jpe	short LOADSW	; even parity - both or neither
 14086 00003103 50                      		push	ax
 14087 00003104 2408                    		and	al,SWITCHB  ; 8
 14088 00003106 A2[8A45]                		mov	[BINARY],al
 14089 00003109 58                      		pop	ax
 14090 0000310A 2404                    		and	al,4
 14091 0000310C A2[8E45]                		mov	[ASCII],al
 14092 0000310F 0806[8745]              		or	[INEXACT],al
 14093                                  LOADSW:
 14094 00003113 A0[8E45]                		mov	al,[ASCII]
 14095 00003116 08C0                    		or	al,al
 14096 00003118 C3                      		retn
 14097                                  
 14098                                  ; =============== S U B	R O U T	I N E =======================================
 14099                                  
 14100                                  BUILDDEST:
 14101 00003119 803E[6C44]FF            		cmp	byte [DESTISDIR],-1 ; 0FFh
 14102 0000311E 750C                    		jnz	short KNOWABOUTDEST	; figuring already done
 14103 00003120 BF[5341]                		mov	di,USERDIR1
 14104 00003123 BD[6C44]                		mov	bp,DESTVARS
 14105 00003126 E8DF00                  		call	BUILDPATH
 14106 00003129 E862E7                  		call	RESTUDIR1
 14107                                  
 14108                                  ;	We now know all about the destination
 14109                                  
 14110                                  KNOWABOUTDEST:
 14111 0000312C 30C0                    		xor	al,al
 14112 0000312E 8606[CB44]              		xchg	al,[FIRSTDEST]
 14113 00003132 08C0                    		or	al,al
 14114 00003134 7503                    		jnz	short FIRSTDST
 14115 00003136 E98A00                  		jmp	NOFIRSTDEST
 14116                                  FIRSTDST:
 14117                                  
 14118                                  ;	Create an fcb of the original dest.
 14119                                  
 14120 00003139 8B36[6E44]              		mov	si,[DESTTAIL]
 14121 0000313D BF[2743]                		mov	di,DESTFCB
 14122 00003140 B80029                  		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
 14123 00003143 CD21                    		int	21h		; DOS -	PARSE FILENAME
 14124                                  					; DS:SI	-> string to parse
 14125                                  					; ES:DI	-> buffer to fill with unopened	FCB
 14126                                  					; AL = bit mask	to control parsing
 14127 00003145 803C00                  		cmp	byte [si],0
 14128 00003148 7404                    		jz	short GOODPARSE
 14129 0000314A C645017C                		mov	byte [di+1],'|'
 14130                                  		; MSDOS 6.0
 14131                                  	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
 14132                                  		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
 14133                                  		;jmp	CopErr				;AN052;
 14134                                  GOODPARSE:
 14135 0000314E A1[7144]                		mov	ax,[DESTBUF]		; AX = possible "d:"
 14136 00003151 80FC3A                  		cmp	ah,':'
 14137 00003154 7402                    		jz	short DRVSPEC4
 14138 00003156 B040                    		mov	al,'@'
 14139                                  DRVSPEC4:
 14140                                  
 14141                                  ;	AX = "d:" for following FCB drive computation
 14142                                  
 14143 00003158 8A0E[8E45]              		mov	cl,[ASCII]		; CL = saved Ascii flag
 14144 0000315C 0C20                    		or	al,20h
 14145 0000315E 2C60                    		sub	al,60h
 14146 00003160 A2[2743]                		mov	byte [DESTFCB],al	; store drive # in FCB
 14147                                  
 14148                                  ;*	Figure out what copy mode we're in.
 14149                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 14150                                  ;	+n stands for additional sources delimited by +'s.
 14151                                  ;
 14152                                  ;	copy a b	not concatenating
 14153                                  ;	copy a *	not concatenating
 14154                                  ;	copy * a	concatenating
 14155                                  ;	copy * *	not concatenating
 14156                                  ;	copy a+n b	concatenating
 14157                                  ;	copy *+n a	concatenating
 14158                                  ;	copy *+n *	concatenating, Mel Hallerman style
 14159                                  
 14160                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 14161                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 14162                                  
 14163 00003163 A0[7044]                		mov	al,[DESTINFO]	; AL = destination CParse flags
 14164 00003166 8A26[D344]              		mov	ah,[SRCINFO]	; AH = source CParse flags
 14165 0000316A 250202                  		and	ax,202h		; AH,AL = source,dest wildcard flags
 14166 0000316D 08C0                    		or	al,al
 14167 0000316F 7413                    		jz	short NOTMELCOPY ; no destination wildcard
 14168                                  
 14169                                  ;	Destination is wildcarded.
 14170                                  	
 14171 00003171 38E0                    		cmp	al,ah
 14172 00003173 750F                    		jnz	short NOTMELCOPY ; no source wildcard
 14173                                  
 14174                                  ;	Source and destination are both wildcarded.
 14175                                  
 14176 00003175 803E[8F45]00            		cmp	byte [PLUS],0
 14177 0000317A 7408                    		jz	short NOTMELCOPY ; no +'s in source
 14178                                  
 14179                                  ;	Source and destination are wildcarded, and source includes +'s.
 14180                                  ;	It's Mel Hallorman copy time.
 14181                                  
 14182 0000317C FE06[CC44]              		inc	byte [MELCOPY]	; 'Mel copy' = true
 14183 00003180 30C0                    		xor	al,al
 14184 00003182 EB06                    		jmp	short SETCONC
 14185                                  
 14186                                  NOTMELCOPY:
 14187 00003184 3402                    		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
 14188 00003186 20E0                    		and	al,ah
 14189 00003188 D0E8                    		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
 14190                                  				;   (implies concatenation)
 14191                                  SETCONC:
 14192 0000318A 0A06[8F45]              		or	al,[PLUS]	; "+" always infers concatenation
 14193                                  
 14194                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 14195                                  
 14196 0000318E A2[8642]                		mov	[CONCAT],al
 14197 00003191 D0E0                    		shl	al,1
 14198 00003193 D0E0                    		shl	al,1
 14199 00003195 A2[8745]                		mov	[INEXACT],al	; concatenation -> inexact copy
 14200 00003198 803E[8A45]00            		cmp	byte [BINARY],0
 14201 0000319D 7524                    		jne	short NOFIRSTDEST ; explicit binary copy	
 14202                                  
 14203 0000319F A2[8E45]                		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
 14204 000031A2 08C9                    		or	cl,cl
 14205 000031A4 751D                    		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
 14206 000031A6 08C0                    		or	al,al
 14207 000031A8 7419                    		jz	short NOFIRSTDEST ; Ascii flag did not change state
 14208                                  
 14209                                  ;	At this point there may already be binary read data in the read
 14210                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 14211                                  ;	amount of data in the buffer correctly.
 14212                                  
 14213 000031AA 8B0E[9442]              		mov	cx,[NXTADD]
 14214 000031AE E313                    		jcxz	NOFIRSTDEST	; no data, everything ok
 14215 000031B0 B01A                    		mov	al,1Ah
 14216 000031B2 06                      		push	es
 14217 000031B3 31FF                    		xor	di,di
 14218 000031B5 8E06[7342]              		mov	es,[TPA]
 14219 000031B9 F2AE                    		repne scasb		; scan for EOF
 14220 000031BB 07                      		pop	es
 14221 000031BC 7505                    		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
 14222 000031BE 4F                      		dec	di		; point at ^z
 14223 000031BF 893E[9442]              		mov	[NXTADD],di	; new buffer length
 14224                                  
 14225                                  NOFIRSTDEST:
 14226 000031C3 BB[6B43]                		mov	bx,DIRBUF+1	; Source of replacement chars
 14227 000031C6 803E[8642]00            		cmp	byte [CONCAT],0
 14228 000031CB 7403                    		jz	short GOTCHRSRC	; Not a concat
 14229 000031CD BB[B143]                		mov	bx,SDIRBUF+1	; Source of replacement chars
 14230                                  GOTCHRSRC:
 14231 000031D0 BE[2843]                		mov	si,DESTFCB+1	; Original dest name
 14232 000031D3 8B3E[6E44]              		mov	di,[DESTTAIL]	; Where to put result
 14233                                  
 14234                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 14235                                  
 14236                                  BUILDNAME:
 14237 000031D7 B90800                  		mov	cx,8
 14238                                  BUILDMAIN:
 14239 000031DA AC                      		lodsb
 14240 000031DB 3C3F                    		cmp	al,'?'
 14241 000031DD 7502                    		jnz	short NOTAMBIG
 14242 000031DF 8A07                    		mov	al,[bx]
 14243                                  NOTAMBIG:
 14244 000031E1 3C20                    		cmp	al,' '
 14245 000031E3 7401                    		jz	short NOSTORE
 14246 000031E5 AA                      		stosb
 14247                                  NOSTORE:
 14248 000031E6 43                      		inc	bx
 14249 000031E7 E2F1                    		loop	BUILDMAIN
 14250 000031E9 B103                    		mov	cl,3
 14251 000031EB B020                    		mov	al,' '
 14252 000031ED 3804                    		cmp	[si],al
 14253 000031EF 7413                    		jz	short ENDDEST	; No extension
 14254 000031F1 A0[083F]                		mov	al,[DOT_CHR]
 14255 000031F4 AA                      		stosb
 14256                                  BUILDEXT:
 14257 000031F5 AC                      		lodsb
 14258 000031F6 3C3F                    		cmp	al,'?'
 14259 000031F8 7502                    		jnz	short NOTAMBIGE
 14260 000031FA 8A07                    		mov	al,[bx]
 14261                                  NOTAMBIGE:
 14262 000031FC 3C20                    		cmp	al,' '
 14263 000031FE 7401                    		jz	short NOSTOREE
 14264 00003200 AA                      		stosb
 14265                                  NOSTOREE:
 14266 00003201 43                      		inc	bx
 14267 00003202 E2F1                    		loop	BUILDEXT
 14268                                  ENDDEST:
 14269 00003204 30C0                    		xor	al,al
 14270 00003206 AA                      		stosb			; NUL terminate
 14271 00003207 C3                      		retn
 14272                                  
 14273                                  ; =============== S U B	R O U T	I N E =======================================
 14274                                  
 14275                                  BUILDPATH:
 14276 00003208 F6460402                		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
 14277 0000320C 7522                    		jnz	short NOTPFILE	; If ambig don't bother with open
 14278 0000320E 89EA                    		mov	dx,bp		; Set DX to spec
 14279 00003210 83C205                  		add	dx,VARSTRUC.BUF ; add dx,5
 14280                                  
 14281                                  		; MSDOS 6.0
 14282                                  		;push	di				;AN000;
 14283                                  		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
 14284                                  		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
 14285                                  		;xor	cx,cx				;AN000; no special files
 14286                                  		;mov	si,dx				;AN030; get file name offset
 14287                                  		;mov	dx,read_open_flag		;AN000; set up open flags
 14288                                  		;INT	21h
 14289                                  		;pop	di				;AN000;
 14290                                  		;jnc	pure_file			;AN022; is pure file
 14291                                  		;invoke	get_ext_error_number		;AN022; get the extended error
 14292                                  		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
 14293                                  		;jz	notpfile			;AN022;
 14294                                  		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
 14295                                  		;jz	notpfile			;AN022;
 14296                                  		;cmp	ax,error_access_denied		;AN022; if access denied - okay
 14297                                  		;jz	notpfile			;AN022;
 14298                                  		;jmp	extend_setup			;AN022; exit with error
 14299                                  ;pure_file:
 14300                                  		; MSDOS 3.3
 14301 00003213 B8003D                  		mov	ax,OPEN*256 ; 3D00h
 14302 00003216 CD21                    		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 14303                                  					; DS:DX	-> ASCIZ filename
 14304                                  					; AL = access mode
 14305                                  					; 0 - read
 14306 00003218 7216                    		jc	short NOTPFILE
 14307                                  ;PURE_FILE:
 14308 0000321A 89C3                    		mov	bx,ax
 14309 0000321C B80044                  		mov	ax,IOCTL*256 ; 4400h
 14310 0000321F CD21                    		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 14311                                  					; BX = file or device handle
 14312 00003221 B43E                    		mov	ah,CLOSE ;3Eh
 14313 00003223 CD21                    		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 14314                                  					; BX = file handle
 14315 00003225 F6C280                  		test	dl,devid_ISDEV ; test dl, 80h
 14316 00003228 7545                    		jnz	short ISADEV
 14317 0000322A F6460404                		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 14318 0000322E 743F                    		jz	short ISADEV
 14319                                  
 14320                                  NOTPFILE:
 14321 00003230 8B5605                  		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 14322                                  		
 14323                                  		;MSDOS 6.0
 14324                                  		;cmp	dl,0		     	;AN034; If no drive specified, get
 14325                                  		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 14326                                  
 14327 00003233 80FE3A                  		cmp	dh,':'
 14328 00003236 7402                    		je	short DRVSPEC5
 14329                                  
 14330                                  SET_DRIVE_SPEC:
 14331 00003238 B240                    		mov	dl,'@'
 14332                                  
 14333                                  DRVSPEC5:
 14334 0000323A 80CA20                  		or	dl,20h
 14335 0000323D 80EA60                  		sub	dl,60h		; A = 1
 14336 00003240 E806E7                  		call	SAVUDIR1
 14337                                  	
 14338                                  		; MSDOS 6.0
 14339                                  		;jnc	short curdir_ok		;AN022; if error - exit
 14340                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14341                                  		;jmp	extend_setup		;AN022; exit with error
 14342                                  
 14343                                  CURDIR_OK:
 14344 00003243 89EA                    		mov	dx,bp
 14345                                  		;add	dx,5
 14346 00003245 83C205                  		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 14347                                  		;mov	bh,[bp+4]
 14348 00003248 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14349 0000324B 80E706                  		and	bh,6
 14350 0000324E 80FF06                  		cmp	bh,6			; Ambig and path ?
 14351 00003251 7517                    		jne	short CHECKAMB		; jmp if no
 14352                                  		;mov	si,[bp+2]
 14353 00003253 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14354 00003256 B33A                    		mov	bl,':'
 14355 00003258 385CFE                  		cmp	[si-2],bl
 14356 0000325B 7506                    		jne	short KNOWNOTSPEC
 14357                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
 14358                                  		;mov	byte [bp+0],2
 14359 0000325D C6460002                		mov	byte [bp],2
 14360 00003261 EB05                    		jmp	short DOPCDJ
 14361                                  
 14362                                  KNOWNOTSPEC:
 14363                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
 14364                                  		;mov	byte [bp+0],1		
 14365 00003263 C6460001                		mov	byte [bp],1
 14366 00003267 4E                      		dec	si
 14367                                  DOPCDJ:
 14368 00003268 EB62                    		jmp	short DOPCD
 14369                                  
 14370                                  CHECKAMB:
 14371 0000326A 80FF02                  		cmp	bh,2
 14372 0000326D 7505                    		jnz	short CHECKCD
 14373                                  ISSIMPFILE:
 14374                                  ISADEV:
 14375                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14376                                  		;mov	byte [bp+0],0		
 14377 0000326F C6460000                		mov	byte [bp],0
 14378 00003273 C3                      		retn
 14379                                  
 14380                                  CHECKCD:
 14381 00003274 E893EC                  		call	SETREST1
 14382 00003277 B43B                    		mov	ah,CHDIR ; 3Bh
 14383 00003279 CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14384                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14385 0000327B 7223                    		jb	short NOTPDIR
 14386 0000327D 89D7                    		mov	di,dx
 14387 0000327F 31C0                    		xor	ax,ax
 14388 00003281 89C1                    		mov	cx,ax
 14389 00003283 49                      		dec	cx
 14390 00003284 F2AE                    		repne scasb
 14391                                  DONE:
 14392 00003286 4F                      		dec	di
 14393 00003287 A0[7642]                		mov	al,[DIRCHAR]
 14394                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14395                                  		;mov	byte [bp+0],2
 14396 0000328A C6460002                		mov	byte [bp],2
 14397 0000328E 3A45FF                  		cmp	al,[di-1]
 14398 00003291 7405                    		jz	short GOTSRCSLSH
 14399                                  _STORE_PCHAR:
 14400 00003293 AA                      		stosb
 14401                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 14402                                  		;mov	byte [bp+0],1
 14403 00003294 C6460001                		mov	byte [bp],1
 14404                                  GOTSRCSLSH:
 14405                                  		;or	byte [bp+4],6
 14406 00003298 804E0406                		or 	byte [bp+VARSTRUC.INFO],6 
 14407 0000329C E84500                  		call	SETSTARS
 14408                                  NOTPDIR_RETN:
 14409 0000329F C3                      		retn
 14410                                  
 14411                                  NOTPDIR:
 14412                                  		; MSDOS 6.0
 14413                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14414                                  		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
 14415                                  		;jz	notpdir_try		;AN022;
 14416                                  		;cmp	ax,error_access_denied	;AN022; if access denied - okay
 14417                                  		;jnz	extend_setupj		;AN022; otherwise - exit error
 14418                                  ;notpdir_try:
 14419                                  		; MSDOS 3.3 (& MSDOS 6.0)
 14420                                  		;mov	byte [bp+VARSTRUC.ISDIR],0
 14421                                  		;mov	byte [bp+0],0
 14422 000032A0 C6460000                		mov	byte [bp],0
 14423                                  		;mov	bh,[bp+4]
 14424 000032A4 8A7E04                  		mov	bh,[bp+VARSTRUC.INFO]
 14425 000032A7 F6C704                  		test	bh,4
 14426 000032AA 74F3                    		jz	short NOTPDIR_RETN	; Know pure file, no path seps
 14427                                  		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 14428                                  		;mov	byte [bp+0],2		
 14429 000032AC C6460002                		mov	byte [bp],2
 14430                                  		;mov	si,[bp+2]
 14431 000032B0 8B7602                  		mov	si,[bp+VARSTRUC.TTAIL]
 14432 000032B3 803C00                  		cmp	byte [si],0
 14433 000032B6 7428                    		je	short BADCDERRJ2	; Trailing '/'	
 14434 000032B8 8A1E[083F]              		mov	bl,[DOT_CHR]
 14435 000032BC 381C                    		cmp	[si],bl
 14436 000032BE 7420                    		je	short BADCDERRJ2	; If . or .. pure cd should have worked
 14437 000032C0 B33A                    		mov	bl,':'
 14438 000032C2 385CFE                  		cmp	[si-2],bl
 14439 000032C5 7405                    		je	short DOPCD		   ; Know d:/file
 14440                                  		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
 14441                                  		;mov	byte [bp+0],1
 14442 000032C7 C6460001                		mov	byte [bp],1
 14443 000032CB 4E                      		dec	si			; Point at last '/'
 14444                                  DOPCD:
 14445 000032CC 30DB                    		xor	bl,bl
 14446 000032CE 861C                    		xchg	bl,[si]			; Stick in a NUL
 14447 000032D0 E837EC                  		call	SETREST1
 14448 000032D3 3A5CFF                  		cmp	bl,[si-1]		; if double slash, then complain.
 14449 000032D6 7408                    		je	short BADCDERRJ2
 14450 000032D8 B43B                    		mov	ah,CHDIR ; 3Bh
 14451 000032DA CD21                    		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 14452                                  					; DS:DX	-> ASCIZ directory name	(may include drive)
 14453 000032DC 861C                    		xchg	bl,[si]
 14454 000032DE 73BF                    		jnc	short NOTPDIR_RETN
 14455                                  		
 14456                                  		; MSDOS 3.3
 14457                                  BADCDERRJ2:
 14458 000032E0 F9                      		stc
 14459 000032E1 E9FADE                  		jmp	BADCDERR
 14460                                  
 14461                                  		; MSDOS 6.0
 14462                                  		;invoke	get_ext_error_number	;AN022; get the extended error
 14463                                  ;EXTEND_SETUPJ:					;AN022;
 14464                                  		;JMP	EXTEND_SETUP		;AN022; go issue the error message
 14465                                  ;BADCDERRJ2:
 14466                                  		;jmp	badpath_err		;AC022; go issue path not found message
 14467                                  
 14468                                  ; =============== S U B	R O U T	I N E =======================================
 14469                                  
 14470                                  SETSTARS:
 14471                                  		;mov	[bp+2],di
 14472 000032E4 897E02                  		mov	[bp+VARSTRUC.TTAIL],di
 14473                                  		;add	byte [bp+1],12
 14474 000032E7 8046010C                		add	byte [bp+VARSTRUC.SIZ],12
 14475 000032EB A1[093F]                		mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 14476 000032EE B90800                  		mov	cx,8
 14477 000032F1 F3AA                    		rep stosb
 14478 000032F3 86C4                    		xchg	al,ah
 14479 000032F5 AA                      		stosb
 14480 000032F6 86C4                    		xchg	al,ah
 14481 000032F8 B103                    		mov	cl,3
 14482 000032FA F3AA                    		rep stosb
 14483 000032FC 30C0                    		xor	al,al
 14484 000032FE AA                      		stosb
 14485 000032FF C3                      		retn
 14486                                  
 14487                                  ; =============== S U B	R O U T	I N E =======================================
 14488                                  
 14489                                  COMPNAME:
 14490 00003300 BE[7144]                		mov	si,DESTBUF	; do name translate of target
 14491 00003303 BF[F63F]                		mov	di,TRGXNAME	; save for name comparison
 14492 00003306 B460                    		mov	ah,XNAMETRANS ; 60h
 14493 00003308 CD21                    		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 14494                                  				; DS:SI	-> ASCIZ relative path string or directory name
 14495                                  				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 14496 0000330A BE[9F3F]                		mov	si,SRCXNAME	; get name translate of source
 14497 0000330D BF[F63F]                		mov	di,TRGXNAME	; get name translate of target
 14498 00003310 E8ACE6                  		call	STRCOMP
 14499 00003313 C3                      		retn
 14500                                  
 14501                                  ;============================================================================
 14502                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 14503                                  ;============================================================================
 14504                                  ; 30/09/2018 - Retro DOS v3.0
 14505                                  
 14506                                  ;-----------------------------------------------------------------------;
 14507                                  ; ENTRY:								;
 14508                                  ;	DS:SI	Points input buffer					;
 14509                                  ;	ES:DI	Points to the token buffer				;
 14510                                  ;	BL	Special delimiter for this call 			;
 14511                                  ;		    Always checked last 				;
 14512                                  ;		    set it to space if there is no special delimiter	;
 14513                                  ; EXIT: 								;
 14514                                  ;	DS:SI	Points to next char in the input buffer 		;
 14515                                  ;	ES:DI	Points to the token buffer				;
 14516                                  ;	[STARTEL] Points to start of last element of path in token	;
 14517                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 14518                                  ;	CX	Character count 					;
 14519                                  ;	BH	Condition Code						;
 14520                                  ;			Bit 1H of BH set if switch character		;
 14521                                  ;				Token buffer contains char after	;
 14522                                  ;				switch character			;
 14523                                  ;				BP has switch bits set (ORing only)	;
 14524                                  ;			Bit 2H of BH set if ? or * in token		;
 14525                                  ;				if * found element ? filled		;
 14526                                  ;			Bit 4H of BH set if path sep in token		;
 14527                                  ;			Bit 80H of BH set if the special delimiter	;
 14528                                  ;			   was skipped at the start of this token	;
 14529                                  ;		Token buffer always starts d: for non switch tokens	;
 14530                                  ;	CARRY SET							;
 14531                                  ;	    if CR on input						;
 14532                                  ;		token buffer not altered				;
 14533                                  ;									;
 14534                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 14535                                  ; MODIFIES:								;
 14536                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 14537                                  ;									;
 14538                                  ;-----------------------------------------------------------------------;
 14539                                  
 14540                                  ; Modifications to cparse: recognition of right and left parentheses
 14541                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 14542                                  ;
 14543                                  ; Both modifications were installed in the course of adding a coherent
 14544                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 14545                                  ; structure for command-line arguments. This parser relies on cparse to
 14546                                  ; recognize individual tokens.
 14547                                  ;
 14548                                  ; To process for-loops correctly, parentheses must therefore be
 14549                                  ; recognized as tokens. The upper-case conversion code was removed so
 14550                                  ; that commands (such as for and echo) would be able to use the "original"
 14551                                  ; text of the command line.
 14552                                  ;
 14553                                  ; Note also the modification to prevent the automatic conversion of colons
 14554                                  ; into spaces WITHIN THE SOURCE TEXT!
 14555                                  ;
 14556                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 14557                                  ; on the command line.
 14558                                  ;
 14559                                  ; Alan L, OS/MSDOS				    14 August 1983
 14560                                  
 14561                                  ; ---------------------------------------------------------------------------
 14562                                  
 14563                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 14564                                  
 14565                                  ;FSWITCH	EQU	8000h
 14566                                  ;FBADSWITCH	EQU	4000h
 14567                                  
 14568                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 14569                                  
 14570                                  ; =============== S U B	R O U T	I N E =======================================
 14571                                  
 14572                                  CPARSE:
 14573 00003314 31C0                    		xor	ax,ax
 14574 00003316 893E[9745]              		mov	[STARTEL],di		; No path element (Is DI correct?)
 14575 0000331A A2[9A45]                		mov	[ELPOS],al		; Start in 8 char prefix
 14576 0000331D A2[9B45]                		mov	[SOURCE],al		; No skip delimiter yet
 14577 00003320 88C7                    		mov	bh,al			; Init nothing
 14578 00003322 9C                      		pushf				; save flags
 14579 00003323 57                      		push	di			; save the token buffer addrss
 14580 00003324 31C9                    		xor	cx,cx			; no chars in token buffer
 14581 00003326 880E[C643]              		mov	[COMMA],cl		; reset comma flag
 14582                                  
 14583                                  MOREDELIM:
 14584 0000332A AC                      		lodsb
 14585 0000332B E853E6                  		call	DELIM
 14586 0000332E 751D                    		jnz	short SCANCDONE
 14587 00003330 3C20                    		cmp	al,' '
 14588 00003332 74F6                    		jz	short MOREDELIM
 14589 00003334 3C09                    		cmp	al,9
 14590 00003336 74F2                    		jz	short MOREDELIM
 14591 00003338 8606[9B45]              		xchg	al,[SOURCE]
 14592 0000333C 08C0                    		or	al,al
 14593 0000333E 74EA                    		jz	short MOREDELIM		; One non space/tab delimiter allowed
 14594 00003340 F6C780                  		test	bh,80h			; has a special char been found?
 14595 00003343 7405                    		jz	short NO_COMMA		; no - just exit
 14596 00003345 C606[C643]01            		mov	byte [COMMA],1		; set comma flag
 14597                                  
 14598                                  NO_COMMA:
 14599 0000334A E92201                  		jmp	X_DONE			; Nul argument
 14600                                  
 14601                                  SCANCDONE:
 14602 0000334D 803E[5644]01            		cmp	byte [CPYFLAG],1
 14603 00003352 7503                    		jnz	short CPCONT1
 14604 00003354 E8C7E4                  		call	UPCONV_MAPCALL
 14605                                  CPCONT1:
 14606 00003357 38D8                    		cmp	al,bl			; Special delimiter?
 14607 00003359 7505                    		jnz	short NOSPEC
 14608 0000335B 80CF80                  		or	bh,80h
 14609 0000335E EBCA                    		jmp	short MOREDELIM
 14610                                  
 14611                                  NOSPEC:
 14612 00003360 3C0D                    		cmp	al,0Dh			; a CR?
 14613 00003362 7503                    		jnz	short NCPERROR
 14614 00003364 E90301                  		jmp	CPERROR
 14615                                  
 14616                                  NCPERROR:
 14617 00003367 3A06[7542]              		cmp	al,[SWITCHAR]		; is the char the switch char?
 14618 0000336B 7503                    		jnz	short NA_SWITCH		; yes, process...
 14619 0000336D E90201                  		jmp	A_SWITCH
 14620                                  
 14621                                  NA_SWITCH:
 14622 00003370 B23A                    		mov	dl,':'
 14623 00003372 3814                    		cmp	[si],dl
 14624 00003374 7513                    		jnz	short ANUM_CHARD	; Drive not specified
 14625 00003376 E83F01                  		call	MOVE_CHAR
 14626 00003379 AC                      		lodsb				; Get the ':'
 14627 0000337A E83B01                  		call	MOVE_CHAR
 14628 0000337D 893E[9745]              		mov	[STARTEL],di
 14629 00003381 C606[9945]00            		mov	byte [ELCNT],0
 14630 00003386 E9A400                  		jmp	ANUM_TEST
 14631                                  
 14632                                  ANUM_CHARD:
 14633 00003389 893E[9745]              		mov	[STARTEL],di
 14634 0000338D C606[9945]00            		mov	byte [ELCNT],0		; Store of this char sets it to one
 14635 00003392 803E[5644]01            		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
 14636 00003397 751F                    		jnz	short ANUM_CHAR		; No, don't add drive spec.
 14637 00003399 E870E6                  		call	PATHCHRCMP		; Starts with a pathchar?
 14638 0000339C 751A                    		jnz	short ANUM_CHAR		; no
 14639 0000339E 50                      		push	ax
 14640 0000339F A0[8542]                		mov	al,[CURDRV]		; Insert drive spec
 14641 000033A2 0206[F03E]              		add	al,[CAPITAL_A]
 14642 000033A6 E80F01                  		call	MOVE_CHAR
 14643 000033A9 B03A                    		mov	al,':'
 14644 000033AB E80A01                  		call	MOVE_CHAR
 14645 000033AE 58                      		pop	ax
 14646 000033AF 893E[9745]              		mov	[STARTEL],di
 14647 000033B3 C606[9945]00            		mov	byte [ELCNT],0
 14648                                  
 14649                                  ANUM_CHAR:
 14650 000033B8 3A06[083F]              		cmp	al,[DOT_CHR]
 14651 000033BC 7509                    		jnz	short TESTQUEST
 14652 000033BE FE06[9A45]              		inc	byte [ELPOS]		; flag in extension
 14653 000033C2 C606[9945]FF            		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 14654                                  TESTQUEST:
 14655 000033C7 3C3F                    		cmp	al,'?'
 14656 000033C9 7503                    		jnz	short TESTSPLAT
 14657 000033CB 80CF02                  		or	bh,2
 14658                                  TESTSPLAT:
 14659 000033CE 3A06[FD3E]              		cmp	al,[STAR]
 14660 000033D2 7530                    		jnz	short TESTPATH
 14661 000033D4 80CF02                  		or	bh,2
 14662 000033D7 803E[A745]00            		cmp	byte [EXPAND_STAR],0
 14663 000033DC 7504                    		jnz	short EXPAND_FILENAME
 14664 000033DE EB24                    		jmp	short TESTPATH
 14665                                  
 14666                                  BADPERR2J:
 14667 000033E0 EB7F                    		jmp	BADPERR2
 14668                                  
 14669                                  		;db	0E9h
 14670                                  		;db	7Eh	
 14671                                  		;db	0
 14672                                  
 14673                                  EXPAND_FILENAME:
 14674 000033E2 B407                    		mov	ah,7
 14675 000033E4 803E[9A45]00            		cmp	byte [ELPOS],0
 14676 000033E9 7402                    		jz	short GOTELCNT
 14677 000033EB B402                    		mov	ah,2
 14678                                  GOTELCNT:
 14679 000033ED B03F                    		mov	al,'?'
 14680 000033EF 2A26[9945]              		sub	ah,[ELCNT]
 14681 000033F3 72EB                    		jb	short BADPERR2J
 14682 000033F5 86E1                    		xchg	ah,cl
 14683 000033F7 E309                    		jcxz	TESTPATHX
 14684                                  QMOVE:
 14685 000033F9 86E1                    		xchg	ah,cl
 14686 000033FB E8BA00                  		call	MOVE_CHAR
 14687 000033FE 86E1                    		xchg	ah,cl
 14688 00003400 E2F7                    		loop	QMOVE
 14689                                  TESTPATHX:
 14690 00003402 86E1                    		xchg	ah,cl
 14691                                  TESTPATH:
 14692 00003404 E805E6                  		call	PATHCHRCMP
 14693 00003407 7521                    		jnz	short NOTSPECIAL
 14694 00003409 80CF04                  		or	bh,4
 14695 0000340C 803E[A745]00            		cmp	byte [EXPAND_STAR],0
 14696 00003411 7405                    		jz	short NO_ERR_CHECK
 14697 00003413 F6C702                  		test	bh,2		; If just hit a '/', cannot have ? or * yet
 14698 00003416 754F                    		jnz	short BADPERR
 14699                                  NO_ERR_CHECK:
 14700 00003418 893E[9745]              		mov	[STARTEL],di	  ; New element
 14701 0000341C FF06[9745]              		inc	word [STARTEL]	  ; Point to char after /
 14702 00003420 C606[9945]FF            		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
 14703 00003425 C606[9A45]00            		mov	byte [ELPOS],0
 14704                                  NOTSPECIAL:
 14705 0000342A E88B00                  		call	MOVE_CHAR	; just an alphanum string
 14706                                  ANUM_TEST:
 14707 0000342D AC                      		lodsb
 14708 0000342E 803E[5644]01            		cmp	byte [CPYFLAG],1
 14709 00003433 7503                    		jnz	short CPCONT3
 14710 00003435 E8E6E3                  		call	UPCONV_MAPCALL
 14711                                  CPCONT3:
 14712 00003438 E846E5                  		call	DELIM
 14713 0000343B 7432                    		jz	short X_DONE
 14714 0000343D 3C0D                    		cmp	al,0Dh
 14715 0000343F 742E                    		jz	short X_DONE
 14716 00003441 3A06[7542]              		cmp	al,[SWITCHAR]
 14717 00003445 7428                    		jz	short X_DONE
 14718 00003447 38D8                    		cmp	al,bl
 14719 00003449 7424                    		jz	short X_DONE
 14720 0000344B 3C3A                    		cmp	al,':'		; ':' allowed as trailer because of devices
 14721 0000344D 750F                    		jnz	short ANUM_CHARJ
 14722                                  
 14723                                  ; Modification made for parseline.
 14724                                  ; Why would it be necessary to change colons to spaces? In this
 14725                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 14726                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 14727                                  
 14728 0000344F 803E[5644]02            		cmp	byte [CPYFLAG],2
 14729 00003454 7505                    		jnz	short CPCONT4
 14730 00003456 E85F00                  		call	MOVE_CHAR
 14731 00003459 EBD2                    		jmp	short ANUM_TEST
 14732                                  
 14733                                  CPCONT4:
 14734 0000345B 46                      		inc	si		;Skip the ':'
 14735 0000345C EB11                    		jmp	short X_DONE
 14736                                  
 14737                                  ANUM_CHARJ:
 14738 0000345E E957FF                  		jmp	ANUM_CHAR
 14739                                  
 14740                                  BADPERR2:
 14741 00003461 BA[4C3D]                		mov	dx,BADCPMESPTR
 14742 00003464 E9C2E7                  		jmp	CERROR
 14743                                  
 14744                                  BADPERR:
 14745 00003467 E974DD                  		jmp	BADCDERR  ; MSDOS 3.3	
 14746                                  
 14747                                  CPERROR:
 14748 0000346A 4E                      		dec	si		; adjust the pointer
 14749 0000346B 5F                      		pop	di		; retrive token buffer address
 14750 0000346C 9D                      		popf			; restore flags
 14751 0000346D F9                      		stc			; set the carry bit
 14752 0000346E C3                      		retn
 14753                                  
 14754                                  X_DONE:
 14755 0000346F 4E                      		dec	si		; adjust for next round
 14756                                  
 14757                                  ; Mod to recognize right and left parens as integral tokens.
 14758                                  ;X_DONE2:
 14759 00003470 EB3F                    		jmp	short OUT_TOKEN
 14760                                  
 14761                                  A_SWITCH:
 14762 00003472 80CF01                  		or	bh,1		; Indicate switch
 14763 00003475 81CD0080                		or	bp,FSWITCH ; 8000h
 14764 00003479 E8FDE4                  		call	SCANOFF
 14765 0000347C 46                      		inc	si
 14766 0000347D 3C0D                    		cmp	al,0Dh
 14767 0000347F 7509                    		jnz	short STORE_SWT
 14768 00003481 B000                    		mov	al,0
 14769 00003483 AA                      		stosb
 14770 00003484 81CD0040                		or	bp,FBADSWITCH ; 4000h
 14771 00003488 EBE0                    		jmp	short CPERROR	; Trailing switch character error
 14772                                  					;   BP = fSwitch but no switch
 14773                                  					;   bit is set (unknown switch)
 14774                                  
 14775                                  STORE_SWT:
 14776 0000348A E82B00                  		call	MOVE_CHAR	; store the character
 14777                                  
 14778                                  ; This upconv call must stay.  It is used to identify copy-switches
 14779                                  ; on the command line, and won't store anything into the output buffer.
 14780                                  
 14781 0000348D E88EE3                  		call	UPCONV_MAPCALL
 14782 00003490 06                      		push	es
 14783 00003491 57                      		push	di
 14784 00003492 51                      		push	cx
 14785 00003493 0E                      		push	cs
 14786 00003494 07                      		pop	es
 14787 00003495 BF[1D3F]                		mov	di,SWITCH_LIST ; "VBAPW"
 14788 00003498 B90500                  		mov	cx,SWCOUNT ; 5
 14789 0000349B 81CD0040                		or	bp,FBADSWITCH  ; 4000h
 14790 0000349F F2AE                    		repne scasb
 14791 000034A1 750B                    		jnz	short OUT_TOKENP
 14792 000034A3 81E5FFBF                		and	bp,~FBADSWITCH ; 0BFFFh
 14793 000034A7 B80100                  		mov	ax,1
 14794 000034AA D3E0                    		shl	ax,cl
 14795 000034AC 09C5                    		or	bp,ax
 14796                                  OUT_TOKENP:
 14797 000034AE 59                      		pop	cx
 14798 000034AF 5F                      		pop	di
 14799 000034B0 07                      		pop	es
 14800                                  OUT_TOKEN:
 14801 000034B1 B000                    		mov	al,0		; null at the end
 14802 000034B3 AA                      		stosb
 14803 000034B4 5F                      		pop	di		; restore token buffer pointer	
 14804 000034B5 9D                      		popf
 14805 000034B6 F8                      		clc			; clear carry flag
 14806 000034B7 C3                      		retn
 14807                                  
 14808                                  ; =============== S U B	R O U T	I N E =======================================
 14809                                  
 14810                                  MOVE_CHAR:
 14811 000034B8 AA                      		stosb			; store char in token buffer
 14812 000034B9 41                      		inc	cx		; increment char count
 14813 000034BA FE06[9945]              		inc	byte [ELCNT]	; increment element count for * substi
 14814 000034BE C3                      		retn
 14815                                  
 14816                                  ;============================================================================
 14817                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 14818                                  ;============================================================================
 14819                                  ; 30/09/2018 - Retro DOS v3.0
 14820                                  
 14821                                  ; BREAK	<Message Printing Routine>
 14822                                  
 14823                                  ;
 14824                                  ;	MSDOS V3.00 PRINT
 14825                                  ;
 14826                                  ;	Message Printing Routine
 14827                                  ;
 14828                                  
 14829                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 14830                                  ;
 14831                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 14832                                  ;
 14833                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 14834                                  ;
 14835                                  ; Characters are output to PFHandle according to the
 14836                                  ; specifications contained in the Control String.
 14837                                  ;
 14838                                  ; The conversion characters are as follow:
 14839                                  ;
 14840                                  ;               %c - output the next argument as a character
 14841                                  ;               %s - output the next argument as a string
 14842                                  ;               %x - output the next argument as a hexidecimal number
 14843                                  ;                    using abcedf
 14844                                  ;               %X - output the next argument as a hexidecimal number
 14845                                  ;                    using ABCDEF
 14846                                  ;               %d - output the next argument as a decimal number
 14847                                  ;
 14848                                  ;
 14849                                  ; Other format specifiers that may precede the conversion character are:
 14850                                  ;
 14851                                  ;               - (minus sign) - causes the field to be left-adjusted
 14852                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 14853                                  ;               n - digit specifing the minimum field width (default to 1)
 14854                                  ;               L - specifing a long integer
 14855                                  ;
 14856                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 14857                                  ;   to an argument list.
 14858                                  ;
 14859                                  ;   ____________________
 14860                                  ;   |   Ret Addr       |      <= SP
 14861                                  ;   --------------------
 14862                                  ;   |  Ptr to Arg List |
 14863                                  ;   --------------------
 14864                                  ;
 14865                                  ;   And the argument list contains the following:
 14866                                  ;
 14867                                  ;       String_ptr                  (a pointer to the control string)
 14868                                  ;       Arg 1
 14869                                  ;       Arg 2
 14870                                  ;         .
 14871                                  ;         .
 14872                                  ;         .
 14873                                  ;       Arg n-1
 14874                                  ;       Arg n
 14875                                  ;
 14876                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 14877                                  ;   or character.
 14878                                  ;
 14879                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 14880                                  
 14881                                  
 14882                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 14883                                  
 14884                                  ; =============== S U B	R O U T	I N E =======================================
 14885                                  
 14886                                  PRINTF_INIT:
 14887 000034BF E81100                  		call	STD_PRINTF
 14888 000034C2 CB                      		retf
 14889                                  
 14890                                  ; =============== S U B	R O U T	I N E =======================================
 14891                                  
 14892                                  PRINTF_CRLF:
 14893 000034C3 E80D00                  		call	STD_PRINTF
 14894 000034C6 E8A3E4                  		call	CRLF2
 14895 000034C9 C3                      		retn
 14896                                  
 14897                                  ; =============== S U B	R O U T	I N E =======================================
 14898                                  
 14899                                  STD_EPRINTF:
 14900 000034CA 2EC706[393F]0200        		mov	word [cs:PRINTF_HANDLE],2
 14901 000034D1 EB07                    		jmp	short NEW_PRINTF
 14902                                  
 14903                                  ; =============== S U B	R O U T	I N E =======================================
 14904                                  
 14905                                  STD_PRINTF:
 14906                                  
 14907                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 14908                                  
 14909 000034D3 2EC706[393F]0100        		mov	word [cs:PRINTF_HANDLE],1
 14910                                  
 14911                                  NEW_PRINTF:				;Save the callers' registers
 14912 000034DA FC                      		cld
 14913 000034DB 52                      		push	dx
 14914 000034DC 55                      		push	bp
 14915 000034DD 89E5                    		mov	bp,sp
 14916 000034DF 51                      		push	cx
 14917 000034E0 53                      		push	bx
 14918 000034E1 50                      		push	ax
 14919 000034E2 57                      		push	di
 14920 000034E3 56                      		push	si
 14921 000034E4 06                      		push	es
 14922 000034E5 1E                      		push	ds
 14923 000034E6 0E                      		push	cs
 14924 000034E7 07                      		pop	es		;ES points to Printf segment
 14925 000034E8 BF[3B3F]                		mov	di,PRINTF_BUF	;DI points to the output buffer
 14926 000034EB 8B6E02                  		mov	bp,[bp+2]  ; dx ;BP points to the argument list
 14927                                  		;mov	si,[ds:bp+0]	;SI points to the control string
 14928 000034EE 3E8B7600                		mov	si,[ds:bp] ; bp
 14929 000034F2 83C502                  		add	bp,2
 14930 000034F5 31DB                    		xor	bx,bx
 14931 000034F7 E8F901                  		call	CLEAR_FLAGS	; initialize the world
 14932                                  
 14933                                  GET_CHAR:
 14934 000034FA AC                      		lodsb			;Get a character
 14935 000034FB 3C25                    		cmp	al,'%'		;Is it a conversion specifier?
 14936 000034FD 7416                    		jz	short CONV_CHAR	;Yes - find out which one
 14937 000034FF 08C0                    		or	al,al		;Is it the end of the control string?
 14938 00003501 7405                    		jz	short PRINTF_DONE ;Yes - then we're done
 14939                                  PRINTF_PERCENT:				
 14940 00003503 E88801                  		call	OUTCHR		;Otherwise store the character
 14941 00003506 EBF2                    		jmp	short GET_CHAR	;And go get another
 14942                                  
 14943                                  PRINTF_DONE:
 14944 00003508 E88B01                  		call	FLUSH
 14945 0000350B 1F                      		pop	ds
 14946 0000350C 07                      		pop	es
 14947 0000350D 5E                      		pop	si
 14948 0000350E 5F                      		pop	di
 14949 0000350F 58                      		pop	ax
 14950 00003510 5B                      		pop	bx
 14951 00003511 59                      		pop	cx
 14952 00003512 5D                      		pop	bp
 14953 00003513 5A                      		pop	dx
 14954 00003514 C3                      		retn
 14955                                  
 14956                                  CONV_CHAR:
 14957 00003515 2EC606[303F]00          		mov	byte [cs:PRINTF_LEFT],0
 14958                                  
 14959                                  NXT_CONV_CHAR:	
 14960                                  		;Look for any format specifiers preceeding the conversion character
 14961 0000351B AC                      		lodsb
 14962 0000351C 3C25                    		cmp	al,'%'			;Just print the %
 14963 0000351E 74E3                    		jz	short PRINTF_PERCENT
 14964 00003520 2E3A06[FE3E]            		cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 14965 00003525 7448                    		jz	short LEFT_ADJ
 14966 00003527 2E3A06[FF3E]            		cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 14967 0000352C 74E7                    		jz	short CONV_CHAR
 14968 0000352E 2E3A06[003F]            		cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 14969 00003533 7442                    		jz	short LONG_INT
 14970 00003535 2E3A06[013F]            		cmp	al,[cs:char_l]	 ; "l"		
 14971 0000353A 743B                    		jz	short LONG_INT
 14972 0000353C 3C30                    		cmp	al,'0'			;Is it a precision specification
 14973 0000353E 723F                    		jb	short LOOK_CONV_CHAR
 14974 00003540 3C39                    		cmp	al,'9'
 14975 00003542 773B                    		ja	short LOOK_CONV_CHAR
 14976 00003544 3C30                    		cmp	al,'0'
 14977 00003546 750F                    		jnz	short NOT_PAD
 14978 00003548 2E833E[343F]00          		cmp	word [cs:PRINTF_WIDTH],0
 14979 0000354E 7507                    		jnz	short NOT_PAD
 14980 00003550 B430                    		mov	ah,'0'
 14981 00003552 2E8826[383F]            		mov	[cs:PAD_CHAR],ah
 14982                                  NOT_PAD:					;Adjust decimal place on precision
 14983 00003557 50                      		push	ax
 14984 00003558 2EA1[343F]              		mov	ax,[cs:PRINTF_WIDTH]
 14985 0000355C B90A00                  		mov	cx,10
 14986 0000355F F7E1                    		mul	cx
 14987 00003561 5A                      		pop	dx
 14988 00003562 30F6                    		xor	dh,dh
 14989 00003564 80EA30                  		sub	dl,'0'
 14990 00003567 01D0                    		add	ax,dx
 14991 00003569 2EA3[343F]              		mov	[cs:PRINTF_WIDTH],ax	;And save the total
 14992 0000356D EBAC                    		jmp	short NXT_CONV_CHAR
 14993                                  
 14994                                  LEFT_ADJ:
 14995 0000356F 2EC606[303F]01          		mov	byte [cs:PRINTF_LEFT],1
 14996 00003575 EBA4                    		jmp	short NXT_CONV_CHAR
 14997                                  
 14998                                  LONG_INT:
 14999 00003577 2E800E[313F]01          		or	byte [cs:PRINTF_LONG],1
 15000 0000357D EB9C                    		jmp	short NXT_CONV_CHAR
 15001                                  
 15002                                  LOOK_CONV_CHAR:
 15003 0000357F 24DF                    		and	al,0DFh
 15004 00003581 2E3A06[073F]            		cmp	al,[cs:CHAR_X]	 ; "X"
 15005 00003586 741B                    		jz	short HEX_UP
 15006 00003588 2E3A06[043F]            		cmp	al,[cs:CHAR_D]	 ; "D"
 15007 0000358D 741D                    		jz	short DECIMAL
 15008 0000358F 2E3A06[053F]            		cmp	al,[cs:CHAR_C]	 ; "C"
 15009 00003594 741F                    		jz	short C_PUT_CHAR
 15010 00003596 2E3A06[063F]            		cmp	al,[cs:CHAR_S]	 ; "S"
 15011 0000359B 7426                    		jz	short S_PUT_STRG
 15012 0000359D E85301                  		call	CLEAR_FLAGS
 15013 000035A0 E957FF                  		jmp	GET_CHAR
 15014                                  
 15015                                  HEX_UP:
 15016 000035A3 2EC706[363F]1000        		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 15017 000035AA EB6C                    		jmp	short CONV_TO_NUM
 15018                                  DECIMAL:
 15019 000035AC 2EC706[363F]0A00        		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 15020 000035B3 EB63                    		jmp	short CONV_TO_NUM
 15021                                  
 15022                                  C_PUT_CHAR:
 15023 000035B5 E82E01                  		call	NEXT_CHRS
 15024 000035B8 88D0                    		mov	al,dl
 15025 000035BA E8D100                  		call	OUTCHR
 15026 000035BD E83301                  		call	CLEAR_FLAGS
 15027 000035C0 E937FF                  		jmp	GET_CHAR
 15028                                  
 15029                                  S_PUT_STRG:
 15030 000035C3 56                      		push	si			;Save pointer to control string
 15031 000035C4 E81F01                  		call	NEXT_CHRS
 15032 000035C7 89D6                    		mov	si,dx
 15033                                  S_PUT_1:
 15034 000035C9 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15035 000035CE 09C9                    		or	cx,cx
 15036 000035D0 740B                    		jz	short S_PUT_2
 15037 000035D2 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15038 000035D8 7503                    		jnz	short S_PUT_2
 15039 000035DA E82700                  		call	PAD_STRING
 15040                                  S_PUT_2:
 15041 000035DD 56                      		push	si
 15042                                  S_PUT_3:
 15043 000035DE AC                      		lodsb
 15044 000035DF 08C0                    		or	al,al
 15045 000035E1 7405                    		jz	short S_PUT_4
 15046 000035E3 E8A800                  		call	OUTCHR			;Put it into our buffer
 15047 000035E6 EBF6                    		jmp	short S_PUT_3
 15048                                  S_PUT_4:
 15049 000035E8 5E                      		pop	si
 15050 000035E9 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15051 000035EF 740C                    		jz	short C_S_END
 15052 000035F1 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15053 000035F6 09C9                    		or	cx,cx
 15054 000035F8 7403                    		jz	short C_S_END
 15055 000035FA E80700                  		call	PAD_STRING
 15056                                  C_S_END:
 15057 000035FD 5E                      		pop	si			;Restore control string pointer
 15058 000035FE E8F200                  		call	CLEAR_FLAGS
 15059 00003601 E9F6FE                  		jmp	GET_CHAR		;Go get another character	
 15060                                  
 15061                                  
 15062                                  ; =============== S U B	R O U T	I N E =======================================
 15063                                  
 15064                                  PAD_STRING:
 15065 00003604 31D2                    		xor	dx,dx
 15066 00003606 56                      		push	si
 15067                                  
 15068                                  COUNT_LOOP:
 15069 00003607 AC                      		lodsb
 15070 00003608 08C0                    		or	al,al
 15071 0000360A 7403                    		jz	short COUNT_DONE
 15072 0000360C 42                      		inc	dx
 15073 0000360D EBF8                    		jmp	short COUNT_LOOP
 15074                                  
 15075                                  COUNT_DONE:
 15076 0000360F 5E                      		pop	si
 15077 00003610 29D1                    		sub	cx,dx
 15078 00003612 7603                    		jbe	short COUNT_RET
 15079 00003614 E86700                  		call	PAD
 15080                                  
 15081                                  COUNT_RET:
 15082 00003617 C3                      		retn
 15083                                  
 15084                                  ; ---------------------------------------------------------------------------
 15085                                  
 15086                                  CONV_TO_NUM:
 15087 00003618 E8CB00                  		call	NEXT_CHRS
 15088 0000361B 89D0                    		mov	ax,dx
 15089 0000361D 31D2                    		xor	dx,dx
 15090 0000361F 2E803E[313F]00          		cmp	byte [cs:PRINTF_LONG],0 
 15091                                  				;Is this is a short or long integer?
 15092 00003625 7403                    		jz	short NOT_LONG_INT
 15093 00003627 E8BC00                  		call	NEXT_CHRS
 15094                                  
 15095                                  NOT_LONG_INT:
 15096 0000362A 53                      		push	bx
 15097 0000362B 56                      		push	si
 15098 0000362C 2E8B36[363F]            		mov	si,[cs:PRINTF_BASE]
 15099 00003631 2E8B0E[343F]            		mov	cx,[cs:PRINTF_WIDTH]
 15100 00003636 E80B00                  		call	PNUM
 15101 00003639 5E                      		pop	si
 15102 0000363A 5B                      		pop	bx
 15103 0000363B E84000                  		call	PAD
 15104 0000363E E8B200                  		call	CLEAR_FLAGS
 15105 00003641 E9B6FE                  		jmp	GET_CHAR
 15106                                  
 15107                                  
 15108                                  ; =============== S U B	R O U T	I N E =======================================
 15109                                  
 15110                                  PNUM:
 15111 00003644 49                      		dec	cx
 15112 00003645 50                      		push	ax
 15113 00003646 89D0                    		mov	ax,dx
 15114 00003648 31D2                    		xor	dx,dx
 15115 0000364A F7F6                    		div	si
 15116 0000364C 89C3                    		mov	bx,ax
 15117 0000364E 58                      		pop	ax
 15118 0000364F F7F6                    		div	si
 15119 00003651 87DA                    		xchg	bx,dx
 15120 00003653 50                      		push	ax
 15121 00003654 09D0                    		or	ax,dx
 15122 00003656 58                      		pop	ax
 15123 00003657 7407                    		jz	short DO_PAD
 15124 00003659 53                      		push	bx
 15125 0000365A E8E7FF                  		call	PNUM
 15126 0000365D 5B                      		pop	bx
 15127 0000365E EB0B                    		jmp	short REM
 15128                                  
 15129                                  DO_PAD:
 15130 00003660 2E803E[303F]00          		cmp	byte [cs:PRINTF_LEFT],0
 15131 00003666 7503                    		jnz	short REM
 15132 00003668 E81300                  		call	PAD
 15133                                  REM:
 15134 0000366B 80FB0A                  		cmp	bl,10
 15135 0000366E 7203                    		jb	short NOT_HEX
 15136 00003670 83C306                  		add	bx,6
 15137                                  NOT_HEX:
 15138 00003673 2E8A87[1037]            		mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 15139 00003678 51                      		push	cx
 15140 00003679 E81200                  		call	OUTCHR
 15141 0000367C 59                      		pop	cx
 15142 0000367D C3                      		retn
 15143                                  
 15144                                  ; =============== S U B	R O U T	I N E =======================================
 15145                                  
 15146                                  PAD:
 15147 0000367E 09C9                    		or	cx,cx
 15148 00003680 7E0B                    		jle	short PAD_DONE
 15149 00003682 2EA0[383F]              		mov	al,[cs:PAD_CHAR]
 15150                                  PAD_LOOP:
 15151 00003686 51                      		push	cx
 15152 00003687 E80400                  		call	OUTCHR
 15153 0000368A 59                      		pop	cx
 15154 0000368B E2F9                    		loop	PAD_LOOP
 15155                                  PAD_DONE:
 15156 0000368D C3                      		retn
 15157                                  
 15158                                  ; =============== S U B	R O U T	I N E =======================================
 15159                                  
 15160                                  OUTCHR:
 15161 0000368E AA                      		stosb
 15162 0000368F 81FF[9F3F]              		cmp	di,PRINTF_BUF_END ; SRCXNAME
 15163 00003693 7401                    		je	short FLUSH
 15164                                  OUTCHR_RETN:
 15165 00003695 C3                      		retn
 15166                                  
 15167                                  ; =============== S U B	R O U T	I N E =======================================
 15168                                  
 15169                                  FLUSH:
 15170 00003696 B9[3B3F]                		mov	cx,PRINTF_BUF
 15171 00003699 87CF                    		xchg	cx,di
 15172 0000369B 29F9                    		sub	cx,di
 15173 0000369D 74F6                    		jz	short OUTCHR_RETN
 15174                                  WRITE_CHARS:
 15175 0000369F 53                      		push	bx
 15176 000036A0 2E8B1E[393F]            		mov	bx,[cs:PRINTF_HANDLE]
 15177 000036A5 1E                      		push	ds
 15178 000036A6 0E                      		push	cs
 15179 000036A7 1F                      		pop	ds
 15180 000036A8 BA[3B3F]                		mov	dx,PRINTF_BUF
 15181 000036AB B440                    		mov	ah,WRITE ; 40h
 15182 000036AD CD21                    		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 15183                                  					; BX = file handle, CX = number	of bytes to write,
 15184                                  					; DS:DX -> buffer
 15185 000036AF 730A                    		jnb	short FOOB2_1
 15186 000036B1 E816E8                  		call	GET_EXT_ERR_NUMBER
 15187 000036B4 83F806                  		cmp	ax,6
 15188 000036B7 742A                    		jz	short FOOB2_4
 15189 000036B9 EB04                    		jmp	short FOOB2_2
 15190                                  
 15191                                  FOOB2_1:
 15192 000036BB 39C1                    		cmp	cx,ax
 15193 000036BD 7424                    		jz	short FOOB2_4
 15194                                  FOOB2_2:
 15195 000036BF 89D3                    		mov	bx,dx
 15196 000036C1 01C3                    		add	bx,ax
 15197 000036C3 803F1A                  		cmp	byte [bx],1Ah
 15198 000036C6 741B                    		jz	short FOOB2_4
 15199 000036C8 1F                      		pop	ds
 15200 000036C9 5B                      		pop	bx
 15201 000036CA 2E8E06[7142]            		mov	es,[cs:RESSEG]
 15202 000036CF BA[3938]                		mov	dx,NOSPACEPTR
 15203 000036D2 26F6065A0CFF            		test	byte [es:PIPEFLAG],0FFh
 15204 000036D8 7406                    		jz	short PRINT_ERR_EXIT
 15205 000036DA E8AFEC                  		call	PIPEOFF
 15206 000036DD BA[D23C]                		mov	dx,PIPEEMESPTR
 15207                                  PRINT_ERR_EXIT:	
 15208 000036E0 E946E5                  		jmp	CERROR
 15209                                  
 15210                                  FOOB2_4:
 15211 000036E3 1F                      		pop	ds
 15212 000036E4 5B                      		pop	bx
 15213 000036E5 C3                      		retn
 15214                                  
 15215                                  ; =============== S U B	R O U T	I N E =======================================
 15216                                  
 15217                                  NEXT_CHRS:
 15218 000036E6 56                      		push	si		;Save pointer to control string
 15219 000036E7 89DE                    		mov	si,bx		;Get index into argument list
 15220 000036E9 83C302                  		add	bx,2		;Increment the index
 15221 000036EC 3E8B32                  		mov	si,[ds:bp+si]	; Get pointer to next argument
 15222 000036EF 8B14                    		mov	dx,[si]		; Get (address of the) next argument			
 15223 000036F1 5E                      		pop	si
 15224 000036F2 C3                      		retn
 15225                                  
 15226                                  ; =============== S U B	R O U T	I N E =======================================
 15227                                  
 15228                                  CLEAR_FLAGS:
 15229 000036F3 31C0                    		xor	ax,ax
 15230 000036F5 2EA2[303F]              		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 15231 000036F9 2EA2[313F]              		mov	[cs:PRINTF_LONG],al	;Reset long flag
 15232 000036FD 2EA3[343F]              		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 15233 00003701 B020                    		mov	al,' '			
 15234 00003703 2EA2[383F]              		mov	[cs:PAD_CHAR],al 	;Reset padding character
 15235 00003707 C3                      		retn
 15236                                  
 15237                                  ; ---------------------------------------------------------------------------
 15238                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 15239                                  
 15240                                  		; times 7 db 0
 15241                                  
 15242                                  ;============================================================================
 15243                                  ; TDATA.ASM, MSDOS 6.0, 1991
 15244                                  ;============================================================================
 15245                                  ; 30/09/2018 - Retro DOS v3.0
 15246                                  
 15247                                  ; TITLE	COMMAND Transient Initialized DATA
 15248                                  
 15249                                  ;The TRANDATA segment contains data that is assumed to have predefined
 15250                                  ;initial values at the beginning of each command cycle. It is
 15251                                  ;included in the transient checksum area. If values in TRANDATA
 15252                                  ;change, the transient will be reloaded for the next command cycle.
 15253                                  
 15254 00003708 90<rep 8h>              align 16
 15255                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 15256                                  
 15257 00003710 303132333435363738-     PRINTF_TABLE:	db '0123456789ABCDEF'
 15257 00003719 39414243444546     
 15258 00003720 255300                  _3740h:		db '%S',0
 15259 00003723 [2037]                  ARG_BUF_PTR:	dw _3740h
 15260 00003725 [2737]                  		dw _3747h
 15261 00003727 [C843]                  _3747h:		dw ARG_BUF ; _43E8h
 15262 00003729 25532000                _3749h:		db '%S ',0
 15263 0000372D [2937]                  STRINGBUF1PTR:	dw _3749h
 15264 0000372F [4844]                  		dw STRING_PTR_1 ; _4468h
 15265 00003731 25396C6400              _3751h:		db '%9ld',0
 15266 00003736 [3137]                  FSIZEMESPTR:	dw _3751h
 15267 00003738 [4A44]                  		dw FILESIZE_L ; _446Ah
 15268 0000373A [4C44]                  		dw FILESIZE_H ; _446Ch
 15269 0000373C 255300                  _375Ch:		db '%S',0
 15270 0000373F [3C37]                  STRINGBUF2PTR:	dw _375Ch
 15271 00003741 [4E44]                  		dw STRING_PTR_2 ; _446Eh
 15272 00003743 0900                    _3763h:		db 9,0
 15273 00003745 [4337]                  TABPTR:		dw _3763h
 15274 00003747 0D0A                    _3767h:		db 0Dh,0Ah
 15275 00003749 42617463682066696C-     		db 'Batch file missing',0Dh,0Ah,0
 15275 00003752 65206D697373696E67-
 15275 0000375B 0D0A00             
 15276 0000375E [4737]                  BADPATHPTR:	dw _3767h
 15277 00003760 0D0A                    _3780h:		db 0Dh,0Ah
 15278 00003762 496E73657274206469-     		db 'Insert disk with batch file',0Dh,0Ah
 15278 0000376B 736B20776974682062-
 15278 00003774 617463682066696C65-
 15278 0000377D 0D0A               
 15279 0000377F 616E64207072657373-     		db 'and press any key when ready',0Dh,0Ah,0
 15279 00003788 20616E79206B657920-
 15279 00003791 7768656E2072656164-
 15279 0000379A 790D0A00           
 15280 0000379E [6037]                  INSERTDSKPTR:	dw _3780h
 15281 000037A0 42616420636F6D6D61-     _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 15281 000037A9 6E64206F722066696C-
 15281 000037B2 65206E616D650D0A00 
 15282 000037BB [A037]                  BADNAMPTR:	dw _37C0h
 15283 000037BD 4475706C6963617465-     _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 15283 000037C6 2066696C65206E616D-
 15283 000037CF 65206F722046696C65-
 15283 000037D8 206E6F7420666F756E-
 15283 000037E1 640D0A00           
 15284 000037E5 [BD37]                  RENERRPTR:	dw _37DDh
 15285 000037E7 46696C65206E6F7420-     _3807h:		db 'File not found',0Dh,0Ah,0
 15285 000037F0 666F756E640D0A00   
 15286 000037F8 [E737]                  FNOTFOUNDPTR:	dw _3807h
 15287 000037FA 50617468206E6F7420-     _381Ah:		db 'Path not found',0Dh,0Ah,0
 15287 00003803 666F756E640D0A00   
 15288 0000380B [FA37]                  PNOTFOUNDPTR:	dw _381Ah
 15289 0000380D 416363657373206465-     _382Dh:		db 'Access denied',0Dh,0Ah,0
 15289 00003816 6E6965640D0A00     
 15290 0000381D [0D38]                  ACCDENPTR:	dw _382Dh
 15291 0000381F 496E73756666696369-     _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 15291 00003828 656E74206469736B20-
 15291 00003831 73706163650D0A00   
 15292 00003839 [1F38]                  NOSPACEPTR:	dw _383Fh
 15293 0000383B 4F7574206F6620656E-     _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 15293 00003844 7669726F6E6D656E74-
 15293 0000384D 2073706163650D0A00 
 15294 00003856 [3B38]                  ENVERRPTR:	dw _385Bh
 15295 00003858 46696C652063726561-     _3878h:		db 'File creation error',0Dh,0Ah,0
 15295 00003861 74696F6E206572726F-
 15295 0000386A 720D0A00           
 15296 0000386E 7838                    FULDIRPTR:	dw 3878h
 15297 00003870 46696C652063616E6E-     _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 15297 00003879 6F7420626520636F70-
 15297 00003882 696564206F6E746F20-
 15297 0000388B 697473656C660D0A00 
 15298 00003894 [7038]                  OVERWRPTR:	dw _3890h
 15299 00003896 436F6E74656E74206F-     _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 15299 0000389F 662064657374696E61-
 15299 000038A8 74696F6E206C6F7374-
 15299 000038B1 206265666F72652063-
 15299 000038BA 6F70790D0A00       
 15300 000038C0 [9638]                  LOSTERRPTR:	dw _38B6h
 15301 000038C2 496E76616C69642066-     _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 15301 000038CB 696C656E616D65206F-
 15301 000038D4 722066696C65206E6F-
 15301 000038DD 7420666F756E640D0A-
 15301 000038E6 00                 
 15302 000038E7 [C238]                  INORNOTPTR:	dw _38E2h
 15303 000038E9 2539642046696C6528-     _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 15303 000038F2 732920636F70696564-
 15303 000038FB 0D0A00             
 15304 000038FE [E938]                  COPIEDPTR:	dw _3909h
 15305 00003900 [5044]                  		dw COPY_NUM ; _4470h
 15306 00003902 2539642046696C6528-     _3922h:		db '%9d File(s) ',0
 15306 0000390B 73292000           
 15307 0000390F [0239]                  DIRMESPTR:	dw _3922h
 15308 00003911 [5744]                  		dw DIR_NUM  ; _4477h
 15309 00003913 25396C642062797465-     _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 15309 0000391C 7320667265650D0A00 
 15310 00003925 [1339]                  BYTEMESPTR:	dw _3933h
 15311 00003927 [5944]                  		dw BYTES_FREE   ; _4479h
 15312 00003929 [5B44]                  		dw BYTES_FREE+2 ; _447Bh
 15313 0000392B 496E76616C69642064-     _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 15313 00003934 726976652073706563-
 15313 0000393D 696669636174696F6E-
 15313 00003946 0D0A00             
 15314 00003949 [2B39]                  BADDRVPTR:	dw _394Bh
 15315 0000394B 0D0A                    _396Bh:		db 0Dh,0Ah
 15316 0000394D 436F64652070616765-     		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 15316 00003956 20253564206E6F7420-
 15316 0000395F 707265706172656420-
 15316 00003968 666F72207379737465-
 15316 00003971 6D0D0A00           
 15317 00003975 [4B39]                  CPNOTSETPTR:	dw _396Bh
 15318 00003977 [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15319 00003979 0D0A                    _3999h:		db 0Dh,0Ah
 15320 0000397B 436F64652070616765-     		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 15320 00003984 20253564206E6F7420-
 15320 0000398D 707265706172656420-
 15320 00003996 666F7220616C6C2064-
 15320 0000399F 6576696365730D0A00 
 15321 000039A8 [7939]                  CPNOTALLPTR:	dw _3999h
 15322 000039AA [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15323 000039AC 0D0A                    _39CCh:		db 0Dh,0Ah
 15324 000039AE 41637469766520636F-     		db 'Active code page: %5d',0Dh,0Ah,0
 15324 000039B7 646520706167653A20-
 15324 000039C0 2535640D0A00       
 15325 000039C6 [AC39]                  CPACTIVEPTR:	dw _39CCh
 15326 000039C8 [0F3F]                  		dw SYSTEM_CPAGE ; _3F2Fh
 15327 000039CA 43757272656E742064-     _39EAh:		db 'Current drive is no longer valid',0
 15327 000039D3 72697665206973206E-
 15327 000039DC 6F206C6F6E67657220-
 15327 000039E5 76616C696400       
 15328 000039EB [CA39]                  BADCURDRVPTR:	dw _39EAh
 15329 000039ED 537472696B65206120-     _3A0Dh:		db 'Strike a key when ready . . . ',0
 15329 000039F6 6B6579207768656E20-
 15329 000039FF 7265616479202E202E-
 15329 00003A08 202E2000           
 15330 00003A0C [ED39]                  PAUSEMESPTR:	dw _3A0Dh
 15331 00003A0E 496E76616C69642070-     _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 15331 00003A17 6172616D657465720D-
 15331 00003A20 0A00               
 15332 00003A22 [0E3A]                  BADPARMPTR:	dw _3A2Eh
 15333 00003A24 53756E4D6F6E547565-     WEEKTAB:	db 'SunMonTueWedThuFriSat'
 15333 00003A2D 576564546875467269-
 15333 00003A36 536174             
 15334 00003A39 0D0A                    _3A59h:		db 0Dh,0Ah
 15335 00003A3B 496E76616C69642064-     		db 'Invalid date',0
 15335 00003A44 61746500           
 15336 00003A48 [393A]                  BADDATPTR:	dw _3A59h
 15337 00003A4A 43757272656E742064-     _3A6Ah:		db 'Current date is ',0
 15337 00003A53 6174652069732000   
 15338 00003A5B [4A3A]                  CURDATPTR:	dw _3A6Ah
 15339 00003A5D 0D0A                    _3A7Dh:		db 0Dh,0Ah
 15340 00003A5F 456E746572206E6577-     		db 'Enter new date ',0
 15340 00003A68 20646174652000     
 15341 00003A6F [5D3A]                  NEWDATPTR:	dw _3A7Dh
 15342 00003A71 286D6D2D64642D7979-     _3A91h:		db '(mm-dd-yy): ',0
 15342 00003A7A 293A2000           
 15343 00003A7E [713A]                  USADATPTR:	dw _3A91h
 15344 00003A80 2864642D6D6D2D7979-     _3AA0h:		db '(dd-mm-yy): ',0
 15344 00003A89 293A2000           
 15345 00003A8D [803A]                  EURDATPTR:	dw _3AA0h
 15346 00003A8F 2879792D6D6D2D6464-     _3AAFh:		db '(yy-mm-dd): ',0
 15346 00003A98 293A2000           
 15347 00003A9C [8F3A]                  JAPDATPTR:	dw _3AAFh
 15348 00003A9E 0D0A                    _3ABEh:		db 0Dh,0Ah
 15349 00003AA0 496E76616C69642074-     		db 'Invalid time ',0
 15349 00003AA9 696D652000         
 15350 00003AAE [9E3A]                  BADTIMPTR:	dw _3ABEh
 15351 00003AB0 43757272656E742074-     _3AD0h:		db 'Current time is ',0
 15351 00003AB9 696D652069732000   
 15352 00003AC1 [B03A]                  CURTIMPTR:	dw _3AD0h
 15353 00003AC3 0D0A                    _3AE3h:		db 0Dh,0Ah
 15354 00003AC5 456E746572206E6577-     		db 'Enter new time: ',0
 15354 00003ACE 2074696D653A2000   
 15355 00003AD6 [C33A]                  NEWTIMPTR:	dw _3AE3h
 15356 00003AD8 41726520796F752073-     _3AF8h:		db 'Are you sure (Y/N)?',0
 15356 00003AE1 7572652028592F4E29-
 15356 00003AEA 3F00               
 15357 00003AEC [D83A]                  SUREMESPTR:	dw _3AF8h
 15358 00003AEE 203C4449523E202020-     _3B0Eh:		db ' <DIR>   ',0
 15358 00003AF7 00                 
 15359 00003AF8 [EE3A]                  DMESPTR:	dw _3B0Eh
 15360 00003AFA 4D532D444F53205665-     _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 15360 00003B03 7273696F6E20253164-
 15360 00003B0C 2E2530326420202020-
 15360 00003B15 202020202020202020-
 15360 00003B1E 202020202020202000 
 15361 00003B27 [FA3A]                  VERMESPTR:	dw _3B1Ah
 15362 00003B29 [5D44]                  		dw MAJOR_VER_NUM ; _447Dh
 15363 00003B2B [5F44]                  		dw MINOR_VER_NUM ; _447Fh
 15364 00003B2D 254300                  _3B4Dh:		db '%C',0
 15365 00003B30 [2D3B]                  ONECHRVALPTR:	dw _3B4Dh
 15366 00003B32 [6144]                  		dw ONE_CHAR_VAL	; _4481h
 15367 00003B34 20566F6C756D652069-     _3B54h:		db ' Volume in drive %c %s',0
 15367 00003B3D 6E2064726976652025-
 15367 00003B46 6320257300         
 15368 00003B4B [343B]                  VOLMESPTR:	dw _3B54h
 15369 00003B4D [6444]                  		dw VOL_DRV ; _4484h
 15370 00003B4F [6244]                  		dw VOLNAME_ADDR ; _4482h
 15371 00003B51 69732000                IS:		db 'is ',0
 15372 00003B55 686173206E6F206C61-     NOVOL:		db 'has no label',0
 15372 00003B5E 62656C00           
 15373 00003B62 496E76616C69642064-     _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 15373 00003B6B 69726563746F72790D-
 15373 00003B74 0A00               
 15374 00003B76 [623B]                  BADCDPTR:	dw _3B82h
 15375 00003B78 556E61626C6520746F-     _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 15375 00003B81 206372656174652064-
 15375 00003B8A 69726563746F72790D-
 15375 00003B93 0A00               
 15376 00003B95 [783B]                  BADMKDPTR:	dw _3B98h
 15377 00003B97 496E76616C69642070-     _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 15377 00003BA0 6174682C206E6F7420-
 15377 00003BA9 6469726563746F7279-
 15377 00003BB2 2C0D0A             
 15378 00003BB5 6F7220646972656374-     		db 'or directory not empty',0Dh,0Ah,0
 15378 00003BBE 6F7279206E6F742065-
 15378 00003BC7 6D7074790D0A00     
 15379 00003BCE [973B]                  BADRMDPTR:	dw _3BB7h
 15380 00003BD0 4D7573742073706563-     _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 15380 00003BD9 696679204F4E206F72-
 15380 00003BE2 204F46460D0A00     
 15381 00003BE9 [D03B]                  BADONOFFPTR:	dw _3BF0h
 15382 00003BEB 204469726563746F72-     _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 15382 00003BF4 79206F66202025530D-
 15382 00003BFD 0A00               
 15383 00003BFF [EB3B]                  DIRHEADPTR:	dw _3C0Bh
 15384 00003C01 [6544]                  		dw VOL_DIR ; _4485h
 15385 00003C03 4E6F205061746800        _3C23h:		db 'No Path',0
 15386 00003C0B [033C]                  NULLPATHPTR:	dw _3C23h
 15387 00003C0D 504154483D              PATH_TEXT:	db 'PATH='
 15388 00003C12 50524F4D50543D          PROMPT_TEXT:	db 'PROMPT='
 15389 00003C19 434F4D535045433D        COMSPEC_TEXT:	db 'COMSPEC='
 15390 00003C21 496E76616C69642064-     _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 15390 00003C2A 7269766520696E2073-
 15390 00003C33 656172636820706174-
 15390 00003C3C 680D0A00           
 15391 00003C40 [213C]                  BADPMESPTR:	dw _3C41h
 15392 00003C42 496E76616C69642064-     _3C62h:		db 'Invalid device',0Dh,0Ah,0
 15392 00003C4B 65766963650D0A00   
 15393 00003C53 [423C]                  BADDEVPTR:	dw _3C62h
 15394 00003C55 4C6162656C206E6F74-     _3C75h:		db 'Label not found',0Dh,0Ah,0
 15394 00003C5E 20666F756E640D0A00 
 15395 00003C67 [553C]                  BADLABPTR:	dw _3C75h
 15396 00003C69 53796E746178206572-     _3C89h:		db 'Syntax error',0Dh,0Ah,0
 15396 00003C72 726F720D0A00       
 15397 00003C78 [693C]                  SYNTMESPTR:	dw _3C89h
 15398 00003C7A 0D464F522063616E6E-     _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 15398 00003C83 6F74206265206E6573-
 15398 00003C8C 7465640D0A00       
 15399 00003C92 [7A3C]                  FORNESTMESTR:	dw _3C9Ah
 15400 00003C94 496E73756666696369-     _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 15400 00003C9D 656E74206D656D6F72-
 15400 00003CA6 790D0A00           
 15401 00003CAA [943C]                  INSFMEMMESPTR:	dw _3CB4h
 15402 00003CAC 496E7465726D656469-     _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 15402 00003CB5 6174652066696C6520-
 15402 00003CBE 6572726F7220647572-
 15402 00003CC7 696E6720706970650D-
 15402 00003CD0 0A00               
 15403 00003CD2 [AC3C]                  PIPEEMESPTR:	dw _3CCCh
 15404 00003CD4 43616E6E6F7420646F-     _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 15404 00003CDD 2062696E6172792072-
 15404 00003CE6 656164732066726F6D-
 15404 00003CEF 206120646576696365-
 15404 00003CF8 0D0A00             
 15405 00003CFB [D43C]                  INBDEVPTR:	dw _3CF4h
 15406 00003CFD 425245414B20697320-     _3D1Dh:		db 'BREAK is ',0
 15406 00003D06 00                 
 15407 00003D07 [FD3C]                  CTRLMESPTR:	dw _3D1Dh
 15408 00003D09 564552494659206973-     _3D29h:		db 'VERIFY is ',0
 15408 00003D12 2000               
 15409 00003D14 [093D]                  VERIMESPTR:	dw _3D29h
 15410 00003D16 4543484F2069732000      _3D36h:		db 'ECHO is ',0
 15411 00003D1F [163D]                  ECHOMESPTR:	dw _3D36h
 15412 00003D21 6F66660D0A00            _3D41h:		db 'off',0Dh,0Ah,0
 15413 00003D27 [213D]                  OFFMESPTR:	dw _3D41h
 15414 00003D29 6F6E0D0A00              _3D49h:		db 'on',0Dh,0Ah,0
 15415 00003D2E [293D]                  ONMESPTR:	dw _3D49h
 15416 00003D30 496E76616C69642070-     _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 15416 00003D39 617468206F72206669-
 15416 00003D42 6C65206E616D650D0A-
 15416 00003D4B 00                 
 15417 00003D4C [303D]                  BADCPMESPTR:	dw _3D50h
 15418 00003D4E 496E76616C6964206E-     _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 15418 00003D57 756D626572206F6620-
 15418 00003D60 706172616D65746572-
 15418 00003D69 730D0A00           
 15419 00003D6D [4E3D]                  BADARGSPTR:	dw _3D6Eh
 15420 00003D6F 4572726F7220777269-     _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 15420 00003D78 74696E6720746F2064-
 15420 00003D81 65766963650D0A00   
 15421 00003D89 [6F3D]                  DEVWMESPTR:	dw _3D8Fh
 15422 00003D8B 0D0A00                  _3DABh:		db 0Dh,0Ah,0
 15423 00003D8E [8B3D]                  ACRLFPTR:	dw _3DABh
 15424 00003D90 08                      _3DB0h:		db 8
 15425 00003D91 20                      		db 20h
 15426 00003D92 08                      		db 8
 15427 00003D93 00                      		db 0
 15428 00003D94 [903D]                  DBACKPTR:	dw _3DB0h
 15429 00003D96 79                      small_y:	db 'y'
 15430 00003D97 6E                      small_n:	db 'n'
 15431 00003D98 59                      CAPITAL_Y:	db 'Y'
 15432 00003D99 4E                      CAPITAL_N:	db 'N'
 15433 00003D9A 041B5B324A              CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 15434                                  PROMPT_TABLE:
 15435 00003D9F 42                      		db 'B' ; 42h
 15436 00003DA0 [F813]                  		dw PRINT_B
 15437 00003DA2 44                      		db 'D' ; 44h
 15438 00003DA3 [9F29]                  		dw PRINT_DATE
 15439 00003DA5 45                      		db 'E' ; 45h
 15440 00003DA6 [EA13]                  		dw PRINT_ESC
 15441 00003DA8 47                      		db 'G' ; 47h
 15442 00003DA9 [EE13]                  		dw PRINT_G
 15443 00003DAB 48                      		db 'H' ; 48h
 15444 00003DAC [E013]                  		dw PRINT_BACK
 15445 00003DAE 4C                      		db 'L' ; 4Ch
 15446 00003DAF [F313]                  		dw PRINT_L
 15447 00003DB1 4E                      		db 'N' ; 4Eh
 15448 00003DB2 [0E14]                  		dw PRINT_DRIVE
 15449 00003DB4 50                      		db 'P' ; 50h
 15450 00003DB5 [1A14]                  		dw BUILD_DIR_FOR_PROMPT
 15451 00003DB7 51                      		db 'Q' ; 51h
 15452 00003DB8 [E613]                  		dw PRINT_EQ
 15453 00003DBA 54                      		db 'T' ; 54h
 15454 00003DBB [2C22]                  		dw PRINT_TIME
 15455 00003DBD 56                      		db 'V' ; 56h
 15456 00003DBE [7213]                  		dw PRINT_VERSION
 15457 00003DC0 5F                      		db '_' ; 5Fh
 15458 00003DC1 [6C19]                  		dw CRLF2
 15459 00003DC3 24                      		db '$' ; 24h
 15460 00003DC4 [FB13]                  		dw PRINT_CHAR
 15461 00003DC6 00                      		db 0
 15462                                  
 15463                                  		; Table of IF conditionals
 15464                                  IFTAB:
 15465 00003DC7 03                      		db 3	; First byte is count
 15466 00003DC8 4E4F54                  		db 'NOT'
 15467 00003DCB [7F09]                  		dw IFNOT
 15468 00003DCD 0A                      		db 10
 15469 00003DCE 4552524F524C455645-     		db 'ERRORLEVEL'
 15469 00003DD7 4C                 
 15470 00003DD8 [420A]                  		dw IFERLEV
 15471 00003DDA 05                      		db 5
 15472 00003DDB 4558495354              		db 'EXIST'
 15473 00003DE0 [D609]                  		dw IFEXISTS
 15474 00003DE2 00                      		db 0
 15475                                  
 15476                                  		; Table for internal command names
 15477                                  
 15478 00003DE3 03                      COMTAB:		db 3
 15479 00003DE4 444952                  		db 'DIR'
 15480 00003DE7 03                      		db 3
 15481 00003DE8 [C20E]                  		dw CATALOG
 15482 00003DEA 04                      		db 4
 15483 00003DEB 43414C4C                		db 'CALL'
 15484 00003DEF 02                      		db 2
 15485 00003DF0 [B70A]                  		dw _$CALL
 15486 00003DF2 04                      		db 4
 15487 00003DF3 43484350                		db 'CHCP'
 15488 00003DF7 02                      		db 2
 15489 00003DF8 [C115]                  		dw CHCP
 15490 00003DFA 06                      		db 6
 15491 00003DFB 52454E414D45            		db 'RENAME'
 15492 00003E01 01                      		db 1
 15493 00003E02 [0212]                  		dw CRENAME
 15494 00003E04 03                      		db 3
 15495 00003E05 52454E                  		db 'REN'
 15496 00003E08 01                      		db 1
 15497 00003E09 [0212]                  		dw CRENAME
 15498 00003E0B 05                      		db 5
 15499 00003E0C 4552415345              		db 'ERASE'
 15500 00003E11 01                      		db 1
 15501 00003E12 [9911]                  		dw ERASE
 15502 00003E14 03                      		db 3
 15503 00003E15 44454C                  		db 'DEL'
 15504 00003E18 01                      		db 1
 15505 00003E19 [9911]                  		dw ERASE
 15506 00003E1B 04                      		db 4
 15507 00003E1C 54595045                		db 'TYPE'
 15508 00003E20 01                      		db 1
 15509 00003E21 [7612]                  		dw TYPEFIL
 15510 00003E23 03                      		db 3
 15511 00003E24 52454D                  		db 'REM'
 15512 00003E27 02                      		db 2
 15513 00003E28 [0401]                  		dw TCOMMAND
 15514 00003E2A 04                      		db 4
 15515 00003E2B 434F5059                		db 'COPY'
 15516 00003E2F 03                      		db 3
 15517 00003E30 [F529]                  		dw COPY
 15518 00003E32 05                      		db 5
 15519 00003E33 5041555345              		db 'PAUSE'
 15520 00003E38 02                      		db 2
 15521 00003E39 [8C11]                  		dw PAUSE
 15522 00003E3B 04                      		db 4
 15523 00003E3C 44415445                		db 'DATE'
 15524 00003E40 02                      		db 2
 15525 00003E41 [0221]                  		dw DATE
 15526 00003E43 04                      		db 4
 15527 00003E44 54494D45                		db 'TIME'
 15528 00003E48 00                      		db 0
 15529 00003E49 [1922]                  		dw CTIME
 15530 00003E4B 03                      		db 3
 15531 00003E4C 564552                  		db 'VER'
 15532 00003E4F 00                      		db 0
 15533 00003E50 [6913]                  		dw VERSION
 15534 00003E52 03                      		db 3
 15535 00003E53 564F4C                  		db 'VOL'
 15536 00003E56 01                      		db 1
 15537 00003E57 [1313]                  		dw VOLUME
 15538 00003E59 02                      		db 2
 15539 00003E5A 4344                    		db 'CD'
 15540 00003E5C 01                      		db 1
 15541 00003E5D [A818]                  		dw _$CHDIR
 15542 00003E5F 05                      		db 5
 15543 00003E60 4348444952              		db 'CHDIR'
 15544 00003E65 01                      		db 1
 15545 00003E66 [A818]                  		dw _$CHDIR
 15546 00003E68 02                      		db 2
 15547 00003E69 4D44                    		db 'MD'
 15548 00003E6B 01                      		db 1
 15549 00003E6C [EB18]                  		dw _$MKDIR
 15550 00003E6E 05                      		db 5
 15551 00003E6F 4D4B444952              		db 'MKDIR'
 15552 00003E74 01                      		db 1
 15553 00003E75 [EB18]                  		dw _$MKDIR
 15554 00003E77 02                      		db 2
 15555 00003E78 5244                    		db 'RD'
 15556 00003E7A 01                      		db 1
 15557 00003E7B [2F19]                  		dw _$RMDIR
 15558 00003E7D 05                      		db 5
 15559 00003E7E 524D444952              		db 'RMDIR'
 15560 00003E83 01                      		db 1
 15561 00003E84 [2F19]                  		dw _$RMDIR
 15562 00003E86 05                      		db 5
 15563 00003E87 425245414B              		db 'BREAK'
 15564 00003E8C 00                      		db 0
 15565 00003E8D [D528]                  		dw CNTRLC
 15566 00003E8F 06                      		db 6
 15567 00003E90 564552494659            		db 'VERIFY'
 15568 00003E96 00                      		db 0
 15569 00003E97 [0729]                  		dw VERIFY
 15570 00003E99 03                      		db 3
 15571 00003E9A 534554                  		db 'SET'
 15572 00003E9D 02                      		db 2
 15573 00003E9E [9816]                  		dw ADD_NAME_TO_ENVIRONMENT
 15574 00003EA0 06                      		db 6
 15575 00003EA1 50524F4D5054            		db 'PROMPT'
 15576 00003EA7 02                      		db 2
 15577 00003EA8 [7E16]                  		dw ADD_PROMPT
 15578 00003EAA 04                      		db 4
 15579 00003EAB 50415448                		db 'PATH'
 15580 00003EAF 02                      		db 2
 15581 00003EB0 [8314]                  		dw PATH
 15582 00003EB2 04                      		db 4
 15583 00003EB3 45584954                		db 'EXIT'
 15584 00003EB7 00                      		db 0
 15585 00003EB8 [5016]                  		dw _$EXIT
 15586 00003EBA 04                      		db 4
 15587 00003EBB 43545459                		db 'CTTY'
 15588 00003EBF 03                      		db 3
 15589 00003EC0 [5D15]                  		dw CTTY
 15590 00003EC2 04                      		db 4
 15591 00003EC3 4543484F                		db 'ECHO'
 15592 00003EC7 02                      		db 2
 15593 00003EC8 [9228]                  		dw ECHO
 15594 00003ECA 04                      		db 4
 15595 00003ECB 474F544F                		db 'GOTO'
 15596 00003ECF 02                      		db 2
 15597 00003ED0 [EB0A]                  		dw GOTO
 15598 00003ED2 05                      		db 5
 15599 00003ED3 5348494654              		db 'SHIFT'
 15600 00003ED8 02                      		db 2
 15601 00003ED9 [700A]                  		dw SHIFT
 15602 00003EDB 02                      		db 2
 15603 00003EDC 4946                    		db 'IF'
 15604 00003EDE 02                      		db 2
 15605 00003EDF [2F09]                  		dw _$IF
 15606 00003EE1 03                      		db 3
 15607 00003EE2 464F52                  		db 'FOR'
 15608 00003EE5 02                      		db 2
 15609 00003EE6 [460D]                  		dw _$FOR
 15610 00003EE8 03                      		db 3
 15611 00003EE9 434C53                  		db 'CLS'
 15612 00003EEC 00                      		db 0
 15613 00003EED [F214]                  		dw CLS
 15614 00003EEF 00                      		db 0
 15615                                  
 15616 00003EF0 41                      CAPITAL_A:	db 'A'
 15617 00003EF1 7C                      VBAR:		db '|'
 15618 00003EF2 3C                      LABRACKET:	db '<' ; 3Ch
 15619 00003EF3 3E                      RABRACKET:	db '>' ; 3Eh
 15620 00003EF4 24                      DOLLAR:		db '$'
 15621 00003EF5 28                      LPAREN:		db '('
 15622 00003EF6 29                      RPAREN:		db ')'
 15623 00003EF7 29                      NULLRPAREN:	db ')' ; 29h
 15624 00003EF8 00                      		db 0
 15625 00003EF9 494E                    IN_WORD:	db 'I','N'
 15626 00003EFB 444F                    DO_WORD	:	db 'D','O'
 15627 00003EFD 2A                      STAR:		db '*'
 15628 00003EFE 2D                      CHAR_SUB:	db '-' 
 15629 00003EFF 2B                      PLUS_CHR:	db '+'
 15630 00003F00 4C                      CHAR_L:		db 'L'
 15631 00003F01 6C                      char_l:		db 'l'
 15632 00003F02 61                      small_a:	db 'a'
 15633 00003F03 7A                      small_z:	db 'z'
 15634 00003F04 44                      CHAR_D:		db 'D'
 15635 00003F05 43                      CHAR_C:		db 'C'
 15636 00003F06 53                      CHAR_S:		db 'S'
 15637 00003F07 58                      CHAR_X:		db 'X'
 15638 00003F08 2E                      DOT_CHR:	db '.' 
 15639 00003F09 3F2E                    DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 15640 00003F0B 2C                      		db ','
 15641 00003F0C 3A2E                    TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 15642 00003F0E 70                      MNCHR:		db 'p'
 15643 00003F0F 00                      SYSTEM_CPAGE:	db 0
 15644 00003F10 00                      		db 0
 15645                                  
 15646 00003F11 2E434F4D                COMEXT:		db '.COM'
 15647 00003F15 2E455845                EXEEXT:		db '.EXE'
 15648 00003F19 2E424154                BATEXT:		db '.BAT'
 15649 00003F1D 5642415057              SWITCH_LIST:	db 'VBAPW'
 15650 00003F22 2000                    BATBUFLEN:	dw BATLEN ; 32
 15651                                  
 15652                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 15653                                  
 15654                                  TRANDATAEND:
 15655                                  
 15656                                  ;============================================================================
 15657                                  ; TSPC.ASM, MSDOS 6.0, 1991
 15658                                  ;============================================================================
 15659                                  ; 29/09/2018 - Retro DOS v3.0
 15660                                  
 15661                                  ;TITLE	COMMAND Transient Uninitialized DATA
 15662                                  
 15663                                  ;The TRANSPACE segment contains variable data that is considered
 15664                                  ;volatile between command cycles, and therefore is not included in the
 15665                                  ;transient checksum area. Contents of these variables MUST be
 15666                                  ;initialized before use, and must not be relied upon from command
 15667                                  ;cycle to command cycle.
 15668                                  ;
 15669                                  ;No constant data values should be stored here.
 15670                                  
 15671                                  ; ---------------------------------------------------------------------------
 15672                                  ; START OF UNITIALIZED DATA
 15673                                  ; ---------------------------------------------------------------------------	
 15674                                  
 15675                                  ;	times 12 db 0
 15676                                  
 15677 00003F24 90<rep Ch>              align 16
 15678                                  
 15679                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 15680                                  
 15681 00003F30 00                      PRINTF_LEFT:	db 0
 15682 00003F31 00                      PRINTF_LONG:	db 0
 15683 00003F32 00                      PRINTF_HEX:	db 0
 15684 00003F33 00                      TABLE_INDEX:	db 0
 15685 00003F34 0000                    PRINTF_WIDTH:	dw 0
 15686 00003F36 0000                    PRINTF_BASE:	dw 0
 15687 00003F38 00                      PAD_CHAR:	db 0
 15688 00003F39 0000                    PRINTF_HANDLE:	dw 0
 15689 00003F3B 00<rep 64h>             PRINTF_BUF: times 100 db 0
 15690                                  PRINTF_BUF_END: ; 30/09/2018
 15691                                  
 15692                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 15693                                  
 15694 00003F9F 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15695 00003FF6 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 15696 0000404D 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 15697 000040D0 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 15698 00004153 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 15699 00004199 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 15700 0000421C 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 15701                                  
 15702                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 15703 0000426F 0000                    HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 15704 00004271 0000                    RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 15705 00004273 0000                    TPA:		dw 0			; LTPA	    (dw 0)	
 15706 00004275 00                      SWITCHAR:	db 0			; RSWITCHAR (db '-')
 15707 00004276 00                      DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 15708 00004277 00000000                EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 15709                                  					; MYSEG1    (dw 0)	
 15710 0000427B 00000000                RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 15711                                  					; MYSEG2    (dw 0)	
 15712 0000427F 0000                    		dw 0			; RESTEST   (dw 0)	
 15713 00004281 0000                    TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 15714                                  
 15715 00004283 00                      CHKDRV:		db 0
 15716                                  IFNOTFLAG:
 15717                                  FILTYP:
 15718 00004284 00                      RDEOF:		db 0			; Misc flags
 15719 00004285 00                      CURDRV:		db 0
 15720                                  PARM1:
 15721 00004286 00                      CONCAT:		db 0
 15722                                  PARM2:
 15723 00004287 00                      ARGC:		db 0
 15724 00004288 0000                    COMSW:		dw 0			; Switches between command and 1st arg
 15725 0000428A 0000                    ARG1S:		dw 0			; Switches between 1st and 2nd arg
 15726                                  ARG2S:					; Switches after 2nd arg		
 15727 0000428C 0000                    DESTSWITCH:	dw 0
 15728                                  ARGTS:
 15729 0000428E 0000                    ALLSWITCH:	dw 0			; ALL switches except for COMSW
 15730 00004290 00                      CFLAG:		db 0
 15731                                  DESTCLOSED:
 15732 00004291 00                      SPECDRV:	db 0
 15733 00004292 0000                    BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 15734 00004294 0000                    NXTADD:		dw 0
 15735 00004296 00                      FRSTSRCH:	db 0
 15736                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 15737                                  ;PerLine:	db 0			; entries/line u.b. DIR
 15738 00004297 00                      LINCNT:		db 0
 15739 00004298 00                      LINLEN:		db 0
 15740                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 15741 00004299 0000                    FILECNT:	dw 0			; file count u.b. DIR
 15742                                  ;FileSiz:	dd 0			; file size u.b. DIR
 15743                                  
 15744                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 15745                                  ;
 15746                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 15747                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 15748                                  
 15749                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 15750                                  
 15751 0000429B 00<rep 50h>             CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 15752                                  DESTFCB2:
 15753 000042EB 00                      IDLEN:		db 0
 15754 000042EC 00<rep 8h>              ID:	  times	8  db 0
 15755 000042F4 00<rep 3h>              COM:	  times	3  db 0 
 15756 000042F7 00<rep 25h>             DEST:	  times 37 db 0
 15757 0000431C 00<rep Bh>              DESTNAME: times 11 db 0
 15758                                  DESTDIR:
 15759 00004327 00<rep 43h>             DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 15760                                  GOTOLEN:	; word
 15761                                  BWDBUF: 	; byte
 15762                                  EXEFCB: 	; word
 15763 0000436A 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 15764                                  
 15765                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 15766                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 15767                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 15768                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 15769                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 15770                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 15771                                  
 15772 000043B0 00<rep Ch>              SDIRBUF:  times 12 db 0	
 15773 000043BC 0000                    _BITS:		dw 0
 15774 000043BE 0000                    PATHCNT:	dw 0
 15775 000043C0 0000                    PATHPOS:	dw 0
 15776 000043C2 0000                    PATHSW:		dw 0
 15777                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 15778                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 15779 000043C4 00                      LINPERPAG:	db 0
 15780 000043C5 00                      		db 0
 15781 000043C6 00                      COMMA:		db 0			; flag set if +,, occurs
 15782 000043C7 00                      PLUS_COMMA:	db 0			; flag set if +,, occurs
 15783                                  
 15784                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 15785                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 15786                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 15787                                  
 15788 000043C8 00<rep 80h>             ARG_BUF:  times 128 db 0   ; _43E8h	
 15789 00004448 0000                    STRING_PTR_1:	dw 0	   ; _4468h	
 15790 0000444A 0000                    FILESIZE_L:	dw 0	   ; _446Ah		
 15791 0000444C 0000                    FILESIZE_H:	dw 0	   ; _446Ch	
 15792 0000444E 0000                    STRING_PTR_2:	dw 0	   ; _446Eh	
 15793                                  
 15794 00004450 0000                    COPY_NUM:	dw 0
 15795 00004452 00<rep 4h>              	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 15796 00004456 00                      CPYFLAG:	db 0
 15797 00004457 0000                    DIR_NUM:	dw 0
 15798 00004459 0000                    BYTES_FREE:	dw 0
 15799 0000445B 0000                    		dw 0
 15800 0000445D 0000                    MAJOR_VER_NUM:	dw 0
 15801 0000445F 0000                    MINOR_VER_NUM:	dw 0
 15802 00004461 00                      ONE_CHAR_VAL:	db 0
 15803                                  		;db 0
 15804 00004462 0000                    VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 15805 00004464 00                      VOL_DRV:	db 0
 15806 00004465 0000                    VOL_DIR:	dw 0 ; MSDOS 3.3
 15807                                  
 15808 00004467 00                      ROM_CALL:	db 0			; flag for rom function
 15809 00004468 0000                    ROM_IP:		dw 0
 15810 0000446A 0000                    ROM_CS:		dw 0
 15811                                  
 15812                                  DESTVARS:
 15813 0000446C 00                      DESTISDIR:	db 0
 15814 0000446D 00                      DESTSIZ:	db 0
 15815 0000446E 0000                    DESTTAIL:	dw 0
 15816 00004470 00                      DESTINFO:	db 0
 15817 00004471 00<rep 57h>             DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 15818                                  ENDDESTBUF:
 15819                                  
 15820 000044C8 0000                    DESTHAND:	dw 0
 15821 000044CA 00                      DESTISDEV:	db 0
 15822 000044CB 00                      FIRSTDEST:	db 0
 15823 000044CC 00                      MELCOPY:	db 0
 15824 000044CD 0000                    MELSTART:	dw 0
 15825                                  
 15826                                  SRCVARS:
 15827 000044CF 00                      SRCISDIR:	db 0
 15828 000044D0 00                      SRCSIZ:		db 0
 15829 000044D1 0000                    SRCTAIL:	dw 0
 15830 000044D3 00                      SRCINFO:	db 0
 15831 000044D4 00<rep 57h>             SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87
 15832                                  
 15833 0000452B 0000                    SRCHAND:	dw 0
 15834 0000452D 00                      SRCISDEV:	db 0
 15835                                  
 15836 0000452E 00<rep 57h>             SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 15837                                  
 15838 00004585 0000                    SRCPT:		dw 0
 15839 00004587 00                      INEXACT:	db 0
 15840 00004588 00                      		db 0 ; MSDOS 3.3 
 15841 00004589 00                      NOWRITE:	db 0
 15842 0000458A 00                      BINARY:		db 0
 15843 0000458B 0000                    WRITTEN:	dw 0
 15844 0000458D 00                      TERMREAD:	db 0
 15845 0000458E 00                      ASCII:		db 0
 15846 0000458F 00                      PLUS:		db 0
 15847 00004590 00                      OBJCNT:		db 0			; Used in copy
 15848 00004591 0000                    CPDATE:		dw 0
 15849 00004593 0000                    CPTIME:		dw 0
 15850                                  
 15851                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 15852                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 15853                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 15854                                  
 15855 00004595 0000                    BATHAND:	dw 0			; Batch handle
 15856 00004597 0000                    STARTEL:	dw 0
 15857 00004599 00                      ELCNT:		db 0
 15858 0000459A 00                      ELPOS:		db 0
 15859 0000459B 00<rep Bh>              SOURCE:   times	11 db 0
 15860                                  
 15861 000045A6 00                      ext_entered:	db 0			;AN005;
 15862                                  
 15863                                  ;display_ioctl	db 0			;AN000; info level
 15864                                  ;		db 0			;AN000; reserved
 15865                                  ;		dw crt_ioctl_ln		;AN000; length of data
 15866                                  ;		dw 0			;AN000; control flags
 15867                                  ;display_mode:	db 0			;AN000; display mode, colors
 15868                                  ;		db 0			;AN000; reserved
 15869                                  ;		dw 0			;AN023; colors
 15870                                  ;		dw 0			;AN000; display width (PELS)
 15871                                  ;		dw 0			;AN000; display length (PELS)
 15872                                  ;display_width:	dw 0			;AN000; display width
 15873                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 15874                                  ;
 15875                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 15876                                  ;		dw 0			;AN000; info level
 15877                                  ;vol_serial:	dd 0			;AN000; volume serial number
 15878                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 15879                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 15880                                  
 15881 000045A7 00                      EXPAND_STAR:	db 0
 15882                                  
 15883                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 15884                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 15885                                  ;append_exec:	db 0			;AN041; set if internal append executed
 15886                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 15887                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 15888                                  
 15889 000045A8 00                      COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 15890                                  
 15891                                  ; Data declarations taken out of parse.asm
 15892                                  
 15893                                  ; MSDOS 6.0
 15894                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 15895                                  ;argbufptr	dw	?		; index for argv[].argpointer
 15896                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 15897                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 15898                                  ;comptr		dw	?		; ptr into combuf
 15899                                  
 15900                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 15901                                  ARG:
 15902                                  ARG_ARGV:
 15903 000045A9 0000                    ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 15904 000045AB 00                      ARGV0_ARG_FLAGS:  db 0
 15905 000045AC 0000                    ARGV0_ARGSTARTEL: dw 0
 15906 000045AE 0000                    ARGV0_ARGLEN:	  dw 0
 15907 000045B0 0000                    ARGV0_ARGSW_WORD: dw 0
 15908 000045B2 0000                    ARGV0_OCOMPTR:	  dw 0
 15909                                  
 15910 000045B4 0000                    ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 15911 000045B6 00<rep 5h>              	  times 5 db 0
 15912 000045BB 0000                    ARGV1_ARGSW_WORD: dw 0
 15913 000045BD 0000                    		  dw 0
 15914                                  
 15915 000045BF 0000                    ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 15916 000045C1 00<rep 5h>              	  times 5 db 0
 15917 000045C6 0000                    ARGV2_ARGSW_WORD: dw 0
 15918 000045C8 0000                    		  dw 0
 15919                                  
 15920 000045CA 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 15921                                  	
 15922 00004869 0000                    ARG_ARGVCNT:	dw 0
 15923 0000486B 0000                    ARG_ARGSWINFO:	dw 0
 15924                                  
 15925 0000486D 0000<rep 100h>          ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 15926 00004A6D 00<rep 80h>             ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 15927                                  
 15928                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 15929                                  
 15930 00004AED 0000                    ARGBUFPTR:	dw 0			; index for argv[].argpointer
 15931 00004AEF 00<rep 80h>             TPBUF:    times 128 db 0		; temporary buffer
 15932 00004B6F 0000                    LASTARG:	dw 0			; point at which to accumulate switch info
 15933 00004B71 0000                    COMPTR:		dw 0			; ptr into combuf
 15934                                  
 15935                                  ; Data declarations taken out of path.asm
 15936                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 15937                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 15938                                  ;psep_char	DB	?			; '/' or '\'
 15939                                  ;search_best	DB	(?)			; best code, best filename so far
 15940                                  ;fname_max_len	equ	13
 15941                                  ;search_best_buf DB	fname_max_len DUP (?)
 15942                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 15943                                  ;search_error	DW	(?)			; address of error message to be printed
 15944                                  
 15945                                  FINDBUFLEN equ FIND_BUF.size ; 43
 15946                                  
 15947                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 15948                                  
 15949 00004B73 00<rep 2Bh>             FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 15950                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 15951                                  PATHINFO:
 15952 00004B9E 0000                    PATHINFO_0:	dw 0
 15953 00004BA0 0000                    PATHINFO_2:	dw 0
 15954 00004BA2 0000                    PATHINFO_4:	dw 0
 15955 00004BA4 00                      PSEP_CHAR:	db 0
 15956 00004BA5 00                      SEARCH_BEST:	db 0
 15957                                  ;FNAME_MAX_LEN equ 13
 15958 00004BA6 00<rep Dh>              SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 15959 00004BB3 00<rep 40h>             SEARCH_CURDIR_BUF: times 64 db 0
 15960 00004BF3 0000                    SEARCH_ERROR:	dw 0
 15961                                  
 15962                                  ; Data declarations taken out of tbatch.asm
 15963                                  
 15964                                  ;if_not_count	DW	?
 15965                                  ;
 15966                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 15967                                  ;
 15968                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 15969                                  ;STACK		LABEL	WORD
 15970                                  
 15971                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 15972                                  
 15973 00004BF5 0000                    IF_NOT_COUNT:	dw 0
 15974 00004BF7 00                      ZFLAG:		db 0
 15975 00004BF8 00<rep 100h>            	  times 256 db 0 	
 15976                                  STACK:
 15977                                  
 15978                                  ;INTERNATVARS	internat_block <>
 15979                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 15980                                  ;
 15981                                  ;;		Buffer for DOS function 64h (Get extended country information)
 15982                                  ;;		subfunctions 2, 4, 6, or 7:
 15983                                  ;
 15984                                  ;CountryPtrInfo	label	byte
 15985                                  ;CountryPtrId	db	?
 15986                                  ;CountryPtr	dd	?
 15987                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 15988                                  
 15989                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 15990                                  
 15991                                  INTERNATVARS:	
 15992 00004CF8 0000                    DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 15993 00004CFA 0000000000              CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 15994 00004CFF 0000                    THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 15995 00004D01 0000                    DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 15996 00004D03 0000                    DATE_SEP:	db 0,0			; Date separator 2 bytes
 15997 00004D05 0000                    TIME_SEP:	db 0,0			; Time separator 2 bytes	
 15998 00004D07 00                      BIT_FIELD:	db 0			; Bit values
 15999                                  					;   Bit 0 = 0 if currency symbol first
 16000                                  					;	  = 1 if currency symbol last
 16001                                  					;   Bit 1 = 0 if No space after currency symbol
 16002                                  					;	  = 1 if space after currency symbol
 16003 00004D08 00                      CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 16004 00004D09 00                      TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 16005 00004D0A 00000000                MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 16006                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 16007                                  					;  in pieces.
 16008 00004D0E 0000                    DATA_SEP:	db 0,0			; Data list separator character		
 16009                                  
 16010 00004D10 00<rep 8h>              		times 8 db 0
 16011                                  ;
 16012                                  ; Max size of the block returned by the INTERNATIONAL call
 16013                                  ;
 16014                                  INTERNAT_BLOCK_SIZE EQU	32
 16015                                  
 16016                                  BATLEN equ 32
 16017                                  	
 16018                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 16019                                  
 16020 00004D18 0000                    BATBUFPOS:	dw 0			; integer position in buffer of next byte
 16021                                  
 16022 00004D1A 00<rep 20h>             BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 16023                                  
 16024 00004D3A 0000                    BATBUFEND:	dw 0
 16025                                  
 16026                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 16027                                  
 16028                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
