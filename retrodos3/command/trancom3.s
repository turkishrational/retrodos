; TRANSIENT PART OF COMMAND.COM
; ****************************************************************************
; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
; ----------------------------------------------------------------------------
; Last Update: 25/02/2023 ((Prev: 20/10/2018))
; ----------------------------------------------------------------------------
; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.11  
; ----------------------------------------------------------------------------
;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
; ----------------------------------------------------------------------------
; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
; by Microsoft, 18/08/1983
; ****************************************************************************
; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
; in NASM syntax (by Erdogan Tan), 05/05/2018
; ----------------------------------------------------------------------------
;; 11/09/2018 - Erdogan Tan
; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
; ----------------------------------------------------------------------------
; MSDOS 6.0 source files:
;;============================================================================
; This MSDOS source code is verified & modified by using IDA Pro Disassembler
; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
;;============================================================================
;
; COMMAND.COM v6.0 source files:
;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
;
; COMMAND.COM v2.11 source files:
;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
;

; ***************************************************************************
; *	This file is generated by The Interactive Disassembler (IDA)	    *
; *	Copyright (c) 2010 by Hex-Rays SA,<support@hex-rays.com>	    *
; *			 Licensed to: Freeware version			    *
; ***************************************************************************
;
; Input	MD5   :	4A83EECE0CFAF68D62F627D71F5D1FAF

; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\command3t.bin
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 4D5Ch Loaded length: 4D5Ch

; ***************************************************************************

; (command3.s -> COMTRANS: INCBIN "TRANCOM3.BIN") ; 24/09/2018

; ----------------------------------------------------------------------------
;	    ((nasm trancom3.s -l trancom3.lst -o TRANCOM3.BIN)) 	
; ----------------------------------------------------------------------------

;============================================================================
; SYSCALL.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;	SCCSID = @(#)syscall.asm	1.1 85/04/10
;BREAK <system call definitions>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;SUBTTL	system call definitions
;PAGE

Abort				EQU 0	;  0	  0
STD_CON_INPUT			EQU 1	;  1	  1
Std_Con_Output			EQU 2	;  2	  2
Std_Aux_Input			EQU 3	;  3	  3
Std_Aux_Output			EQU 4	;  4	  4
Std_Printer_Output		EQU 5	;  5	  5
RAW_CON_IO			EQU 6	;  6	  6
RAW_CON_INPUT			EQU 7	;  7	  7
STD_CON_INPUT_NO_ECHO		EQU 8	;  8	  8
STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
STD_CON_STRING_INPUT		EQU 10	; 10	  A
Std_Con_Input_Status		EQU 11	; 11	  B
STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
DISK_RESET			EQU 13	; 13	  D
SET_DEFAULT_DRIVE		EQU 14	; 14	  E
FCB_Open			EQU 15	; 15	  F
FCB_Close			EQU 16	; 16	 10
DIR_SEARCH_FIRST		EQU 17	; 17	 11
DIR_SEARCH_NEXT 		EQU 18	; 18	 12
FCB_DELETE			EQU 19	; 19	 13
FCB_Seq_Read			EQU 20	; 20	 14
FCB_Seq_Write			EQU 21	; 21	 15
FCB_Create			EQU 22	; 22	 16
FCB_RENAME			EQU 23	; 23	 17
GET_DEFAULT_DRIVE		EQU 25	; 25	 19
SET_DMA 			EQU 26	; 26	 1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_Default_DPB 		EQU 31	; 31	 1F
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_Random_Read 		EQU 33	; 33	 21
FCB_Random_Write		EQU 34	; 34	 22
Get_FCB_File_Length		EQU 35	; 35	 23
Get_FCB_Position		EQU 36	; 36	 24
SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
Create_Process_Data_Block	EQU 38	; 38	 26
FCB_Random_Read_Block		EQU 39	; 39	 27
FCB_Random_Write_Block		EQU 40	; 40	 28
PARSE_FILE_DESCRIPTOR		EQU 41	; 41	 29
GET_DATE			EQU 42	; 42	 2A
SET_DATE			EQU 43	; 43	 2B
GET_TIME			EQU 44	; 44	 2C
SET_TIME			EQU 45	; 45	 2D
SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
; Extended functionality group
Get_DMA 			EQU 47	; 47	 2F
GET_VERSION			EQU 48	; 48	 30
Keep_Process			EQU 49	; 49	 31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_DPB 			EQU 50	; 50	 32
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
SET_CTRL_C_TRAPPING		EQU 51	; 51	 33
Get_InDOS_Flag			EQU 52	; 52	 34
GET_INTERRUPT_VECTOR		EQU 53	; 53	 35
GET_DRIVE_FREESPACE		EQU 54	; 54	 36
CHAR_OPER			EQU 55	; 55	 37
INTERNATIONAL			EQU 56	; 56	 38
;   Directory Group
MKDIR				EQU 57	; 57	 39
RMDIR				EQU 58	; 58	 3A
CHDIR				EQU 59	; 59	 3B
;   File Group
CREAT				EQU 60	; 60	 3C
OPEN				EQU 61	; 61	 3D
CLOSE				EQU 62	; 62	 3E
READ				EQU 63	; 63	 3F
WRITE				EQU 64	; 64	 40
UNLINK				EQU 65	; 65	 41
LSEEK				EQU 66	; 66	 42
CHMod				EQU 67	; 67	 43
IOCTL				EQU 68	; 68	 44
XDUP				EQU 69	; 69	 45
XDup2				EQU 70	; 70	 46
CURRENT_DIR			EQU 71	; 71	 47
;    Memory Group
ALLOC				EQU 72	; 72	 48
DEALLOC				EQU 73	; 73	 49
SETBLOCK			EQU 74	; 74	 4A
;    Process Group
EXEC				EQU 75	; 75	 4B
EXIT				EQU 76	; 76	 4C
WAITPROCESS			EQU 77	; 77	 4D
FIND_FIRST			EQU 78	; 78	 4E
;   Special Group
FIND_NEXT			EQU 79	; 79	 4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SET_CURRENT_PDB 		EQU 80	; 80	 50
GET_CURRENT_PDB 		EQU 81	; 81	 51
Get_In_Vars			EQU 82	; 82	 52
SetDPB				EQU 83	; 83	 53
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GET_VERIFY_ON_WRITE		EQU 84	; 84	 54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
DUP_PDB 			EQU 85	; 85	 55
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Rename				EQU 86	; 86	 56
FILE_TIMES			EQU 87	; 87	 57
AllocOper			EQU 88	; 88	 58
; Network extention system calls
GETEXTENDEDERROR		EQU 89	; 89	 59
CREATETEMPFILE			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
XNAMETRANS			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63
ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Printer_Flag		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GetExtCntry			EQU 101 ; 101	 65
GETSETCDPG			EQU 102 ; 102	 66
ExtHandle			EQU 103 ; 103	 67
Commit				EQU 104 ; 104	 68
GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;ifdef ROMEXEC
;ROM_FIND_FIRST			EQU 109 ; 109    6D
;ROM_FIND_NEXT			EQU 110 ; 110    6E
;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
;endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;
;
Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

;============================================================================
; DOSSYM.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;BREAK <Control character definitions>

c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
c_BS	    EQU     08h 		; ^H ASCII backspace
c_CR	    EQU     0Dh 		; ^M ASCII carriage return
c_LF	    EQU     0Ah 		; ^J ASCII linefeed
c_ETB	    EQU     17h 		; ^W ASCII end of transmission
c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 		; ^C ASCII end of text
c_HT	    EQU     09h 		; ^I ASCII tab

;============================================================================
; DIRENT.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;Break <Directory entry>

; (-*-) Same with MSDOS 2.11 & MSDOS 6.0

;	NOTE:  These offsets are also used in the DTA for
;	extended FCB SearchFirst/Next. DIR_NAME lines up
;	with the FCB filename field, and the rest of the
;	DIR_ENTRY fields follow. -DavidOls

;**	DIRENT.INC - FAT Directory Entry Definition
;
;	+---------------------------+
;	|  (12 BYTE) filename/ext   |	    0	    0
;	+---------------------------+
;	|     (BYTE) attributes     |	    11	    B
;	+---------------------------+
;	|    (10 BYTE) reserved     |	    12	    C
;	+---------------------------+
;	| (WORD) time of last write |	    22	    16
;	+---------------------------+
;	| (WORD) date of last write |	    24	    18
;	+---------------------------+
;	|   (WORD) First cluster    |	    26	    1A
;	+---------------------------+
;	|     (DWORD) file size     |	    28	    1C
;	+---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;			    = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;

STRUC DIR_ENTRY
.DIR_NAME:	RESB  11	; file name
.DIR_ATTR:	RESB  1		; attribute bits
.DIR_CODEPG:	RESW  1		; code page DOS 4.00
.DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
.DIR_ATTR2:	RESB  1		; reserved
.DIR_PAD:	RESB  5		; reserved for expansion
.DIR_TIME:	RESW  1		; time of last write
.DIR_DATE:	RESW  1		; date of last write
.DIR_FIRST:	RESW  1		; first allocation unit of file
.DIR_SIZE_L:	RESW  1		; low 16 bits of file size
.DIR_SIZE_H:	RESW  1		; high 16 bits of file size
.size:

;	    Caution: An extended FCB SearchFirst/Next on a network
;	    drive under Novell Netware 286 or 386 returns the time/date
;	    in the SIZE fields for subdirectory files. Ordinarily,
;	    this field is zero for subdirectory files.

ENDSTRUC

ATTR_READ_ONLY	equ	 1h
ATTR_HIDDEN	equ	 2h
ATTR_SYSTEM	equ	 4h
ATTR_VOLUME_ID	equ	 8h
ATTR_DIRECTORY	equ	10h
ATTR_ARCHIVE	equ	20h
ATTR_DEVICE	equ	40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
				; OR of hard attributes for FINDENTRY

ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
				; ignore this(ese) attribute(s) during
				; search first/next

ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
				; changeable via CHMOD

DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot

;============================================================================
; ERROR.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX.	If an error occurred then
;    the carry bit will be set and the error code is in AX.	If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.	The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.


;	2.0 error codes

error_invalid_function		EQU	1
ERROR_FILE_NOT_FOUND		EQU	2
error_path_not_found		EQU	3
ERROR_TOO_MANY_OPEN_FILES	EQU	4
ERROR_ACCESS_DENIED		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
ERROR_NOT_ENOUGH_MEMORY 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
ERROR_BAD_FORMAT		EQU	11
error_invalid_access		EQU	12
ERROR_INVALID_DATA		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
error_no_more_files		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

ERROR_WRITE_PROTECT		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
ERROR_GEN_FAILURE		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
ERROR_FCB_UNAVAILABLE		EQU	35
ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;

;============================================================================
; DEVSYM.INC, MSDOS 6.0, 1991
;============================================================================
; 22/09/2018 - Retro DOS v3.0

;**	DevSym.inc - Device Symbols

;	THE DEVICE TABLE LIST HAS THE FORM:

STRUC SYSDEV
.NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
.ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
.STRAT:	RESW 1			;STRATEGY ENTRY POINT
.INT:	RESW 1			;INTERRUPT ENTRY POINT
.NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
.size:
ENDSTRUC

; 24/09/2018
DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK

;============================================================================
; CURDIR.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings

;============================================================================
; COMEQU.ASM, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;*************************************
; COMMAND EQUs which are not switch dependant

;		include	curdir.inc	; to get DIRSTRLEN
;		Note dossym.inc must already have been included!

GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND

SYM		EQU	">"

LINESPERPAGE	EQU	25		;AC000; default lines per page

NORMPERLIN	EQU	1
WIDEPERLIN	EQU	5
COMBUFLEN	EQU	128		; Length of commmand buffer
BatLen		EQU	32		; buffer for batch files
YES_ECHO	EQU	1		; echo line
NO_ECHO 	EQU	0		; don't echo line
NO_ECHO_CHAR	EQU	"@"             ; don't echo line if this is first char
call_in_progress EQU	1		; indicate we're in the CALL command
length_call	EQU	4		; length of CALL
max_nest	EQU    10		; max # levels of batch nesting allowed
FAIL_ALLOWED	EQU    00001000b	; critical error
RETRY_ALLOWED	EQU    00010000b	; critical error
IGNORE_ALLOWED	EQU    00100000b	; critical error
nullcommand	EQU    1		; no command on command line
end_of_line	EQU    -1		;AN000; end of line return from parser
end_of_line_out EQU	0		;AN000; end of line for output
end_of_line_in	EQU	0dh		;AN000; end of line for input
result_number	EQU	1		;AN000; number returned from parser
result_string	EQU	3		;AN000; string returned from parser
result_filespec EQU	5		;AN000; filespec returned from parser
result_drive	EQU	6		;AN000; drive returned from parser
result_date	EQU	7		;AN000; date returned from parser
result_time	EQU	8		;AN000; time returned from parser
result_no_error EQU	0		;AN000; no error returned from parser
no_cont_flag	EQU	0		;AN000; no control flags for message
util_msg_class	EQU	-1		;AN000; message class for utility
ext_msg_class	EQU	1		;AN000; message class for extended error
parse_msg_class EQU	2		;AN000; message class for parse error
crit_msg_class	EQU	3		;AN000; message class for critical error
ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
colon_char	EQU	":"             ;AN000; colon character
crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
text_mode	EQU	1		;AN000; text mode return from ioctl
get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
%define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
parm_block_size equ	11		;AN000; size of message subst block
blank		equ	" "             ;AN000; blank character
no_subst	equ	0		;AN000; no substitutions for messages
one_subst	equ	1		;AN000; one substitution for messages
no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
res_subst	equ	2		;AN000; offset from start of message definition to number of subst
read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
capital_A	equ	'A'             ;AC000;
vbar		equ	'|'             ;AC000;
labracket	equ	'<'             ;AC000;
rabracket	equ	'>'             ;AC000;
dollar		equ	'$'             ;AC000;
lparen		equ	'('             ;AC000;
rparen		equ	')'             ;AC000;
nullrparen	equ	29h		;AC000;
in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
star		equ	'*'             ;AC000;
plus_chr	equ	'+'             ;AC000;
;small_a 	equ	'a'             ;AC000;
;small_z 	equ	'z'             ;AC000;
dot_chr 	equ	'.'             ;AC000;
tab_chr 	equ	9		;AN032;
equal_chr	equ	'='             ;AN032;
semicolon	equ	';'             ;AN049;
dot_qmark	equ	2e3fh		;AC000; '.?'
dot_colon	equ	2e3ah		;AC000; '.:'
capital_n	equ	0		;AC000; result from Y/N call if N entered
capital_y	equ	1		;AC000; result from Y/N call if Y entered
AppendInstall	equ	0B700H		;AN020; append install check
AppendDOS	equ	0B702H		;AN020; append DOS version check
AppendGetState	equ	0B706H		;AN020; append get current state
AppendSetState	equ	0B707H		;AN020; append set current state
AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
SEARCH_ATTR	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;

;*************************************
;* PARSE ERROR MESSAGES
;*************************************

MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number

;*************************************
;* EQUATES FOR MESSAGE RETRIEVER
;*************************************

GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever

;*********************************
;* EQUATES FOR INT 10H
;*********************************

VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white

ALTPIPECHR	equ	"|"             ; alternate pipe character

FCB		EQU	5CH

STRUC VARSTRUC
.ISDIR:		RESB	1
.SIZ:		RESB	1
.TTAIL:		RESW	1
.INFO:		RESB	1
.BUF:		RESB	DIRSTRLEN + 20
.size:
ENDSTRUC
;
; Flags for internal command parsing
;
FCHECKDRIVE	equ	00000001b	; validate drive letter
FSWITCHALLOWED	equ	00000010b	; switches allowed
FLIMITHELP	equ	00000100b	; /? must appear alone

;
; Test switches
;
fParse		EQU	0001h		; display results of parseline

;
; Batch segment structure
;
;   BYTE    type of segment
;   BYTE    echo state of parent on entry to batch file
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;

BATCHTYPE   equ 0

STRUC BATCHSEGMENT
.BatType:	RESB	1		; signature
.BatEchoFlag:	RESB	1		; G state of echo
;.BatchEOF:	RESB	1		; records if EOF reached on file
.BatLast: 	RESW	1		; G segment of last batch file
.BatForPtr:	RESW	1		; G segment for FOR command
.BatForFlag:	RESB	1		; G state of FOR
.BatSeek:	RESD	1		; lseek position of next char
.BatParm:	RESW	10		; pointers to parameters
.BatFile:	RESB	1		; beginning of batch file name
.SIZE:
ENDSTRUC

ANULL		equ	0		; terminates an argv string
ARGMAX		equ	64		; max args on a command line
ARGBLEN 	equ	2*128		; 1char each plus term NUL
tplen		equ	64		; max size of one argument
arg_cnt_error	equ	1		; number of args > MAXARG
arg_buf_ovflow	equ	2		; overflowed argbuffer

STRUC ARGV_ELE				; elements in the argv array
.argpointer:	RESW	1		; pointer to the argstring
.argflags:	RESB	1		; cparse flags for this argstring
.argstartel:	RESW	1		; the result of cparse's [STARTEL]
.arglen:	RESW	1		; cparse's char count + one (for null)
.argsw_word:	RESW	1		; any switches after this? what kinds?
.arg_ocomptr:	RESW	1		; pointer into original command string
.SIZE:
ENDSTRUC

STRUC ARG_UNIT
.argv:		RESB	ARGMAX * ARGV_ELE.SIZE
.argvcnt:	RESW	1		; number of arguments
.argswinfo:	RESW	1		; Switch information for entire line
.argbuf:	RESW	ARGBLEN		; storage for argv strings
.argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
.SIZE:
ENDSTRUC

; Parse flags - 13/10/2018
special_delim	equ	128
path_sep 	equ	4
wildcard 	equ	2
sw_flag		equ	1

SWITCHQUES 	EQU	20h
SWITCHV 	EQU	10h
SWITCHB 	EQU	08h
SWITCHA 	EQU	04h
SWITCHP 	EQU	02h
SWITCHW 	EQU	01h
FSWITCH 	EQU	8000h
FBADSWITCH	EQU	4000h

SWITCHDIR	EQU	SWITCHP+SWITCHW+FSWITCH
SWITCHCOPY	EQU	SWITCHV+SWITCHA+SWITCHB+FSWITCH
; 13/10/2018
;SWITCHCOPY	EQU	801Ch
NOT_SWITCHCOPY	EQU	7FE3h

; Equates for initialization
;
INITINIT	equ	01h		; initialization in progress
INITSPECIAL	equ	02h		; in initialization time/date routine
INITCTRLC	equ	04h		; already in ^C handler

;============================================================================
; FIND.INC (MSDOS 3.3, 1987)
;============================================================================
; 13/10/2018 - Retro DOS v3.0

;Break	<find first/next buffer>

	; MSDOS 3.3 & MSDOS 6.0

struc FIND_BUF
.DRIVE:	    resb 1	; drive of search
.NAME:	    resb 11	; formatted name
.SATTR:	    resb 1	; attribute of search
.LASTENT:   resw 1	; LastEnt
.DIRSTART:  resw 1	; DirStart
.NETID:	    resb 4	; Reserved for NET
.ATTR:	    resb 1	; attribute found
.TIMR:	    resw 1	; time
.DATE:	    resw 1	; date
.SIZE_L:    resw 1	; low(size)
.SIZE_H:    resw 1	; high(size)
.PNAME:	    resb 13	; packed name
.size:
endstruc

;=============================================================================
; PDB.INC, MSDOS 6.0, 1991
;=============================================================================
; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')

;**	Process data block (otherwise known as program header)

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever. Reserved areas are probably safe
;	for use.

FILPERPROC	EQU     20

struc PDB	; Process_data_block
.EXIT_CALL:	resw 1   	; INT int_abort system terminate
.BLOCK_LEN:	resw 1		; size of execution block
                resb 1
.CPM_CALL:	resb 5		; ancient call to system
.EXIT:		resd 1		; pointer to exit routine
.CTRL_C:	resd 1		; pointer to ^C routine
.FATAL_ABORT:	resd 1		; pointer to fatal error
.PARENT_PID:	resw 1		; PID of parent (terminate PID)
.JFN_TABLE:     resb FILPERPROC ; indices into system table
.ENVIRON:	resw 1		; seg addr of environment
.USER_STACK:	resd 1		; stack of self during system calls
.JFN_Length:	resw 1		; number of handles allowed
.JFN_Pointer:	resd 1		; pointer to JFN table
.Next_PDB:	resd 1		; pointer to nested PDB's
.InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
.Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
.Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
.Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
.PAD1:		resb 14 ; 0Eh
.CALL_SYSTEM:	resb 5		; portable method of system call
.PAD2:		resb 7		; reserved so FCB 1 can be used as
				;  an extended FCB
;endstruc 	; MSDOS 3.3
	  	; MSDOS 6.0
.FCB1:		resb 16 ; 10h	; default FCB 1
.FCB2:		resb 16 ; 10h	; default FCB 2
.PAD3:		resb 4		; not sure if this is used by PDB_FCB2
.TAIL:		resb 128	; command tail and default DTA
endstruc

;============================================================================
; SF.INC, MSDOS 6.0, 1991
;============================================================================
; 13/10/2018 - Retro DOS v3.0

; structure of devid field as returned by IOCTL is:
;
;	BIT	7   6	5   4	3   2	1   0
;	      |---|---|---|---|---|---|---|---|
;	      | I | E | R | S | I | I | I | I |
;	      | S | O | A | P | S | S | S | S |
;	      | D | F | W | E | C | N | C | C |
;	      | E |   |   | C | L | U | O | I |
;	      | V |   |   | L | K | L | T | N |
;	      |---|---|---|---|---|---|---|---|
;	ISDEV = 1 if this channel is a device
;	      = 0 if this channel is a disk file
;
;	If ISDEV = 1
;
;	      EOF = 0 if End Of File on input
;	      RAW = 1 if this device is in Raw mode
;		  = 0 if this device is cooked
;	      ISCLK = 1 if this device is the clock device
;	      ISNUL = 1 if this device is the null device
;	      ISCOT = 1 if this device is the console output
;	      ISCIN = 1 if this device is the console input
;
;	If ISDEV = 0
;	      EOF = 0 if channel has been written
;	      Bits 0-5	are  the  block  device  number  for
;		  the channel (0 = A, 1 = B, ...)

devid_ISDEV	EQU	80h
devid_EOF	EQU	40h
devid_RAW	EQU	20h
devid_SPECIAL	EQU	10H
devid_ISCLK	EQU	08h
devid_ISNUL	EQU	04h
devid_ISCOT	EQU	02h
devid_ISCIN	EQU	01h

devid_block_dev EQU	1Fh		; mask for block device number

;============================================================================
; INTNAT.INC, MSDOS 3.3, 1987
;============================================================================
; 09/07/2018 - Retro DOS 3.0

; Current structure of the data returned by the international call

struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
.Date_tim_format: RESW 1	; 0-USA, 1-EUR, 2-JAP
.Currency_sym:	  RESB 5	; Currency Symbol 5 bytes
.Thous_sep:	  RESB 2	; Thousands separator 2 bytes
.Decimal_sep:	  RESB 2	; Decimal separator 2 bytes
.Date_sep:	  RESB 2	; Date separator 2 bytes
.Time_sep:	  RESB 2	; Time separator 2 bytes
.Bit_field:	  RESB 1	; Bit values
                                ;   Bit 0 = 0 if currency symbol first
                                ;         = 1 if currency symbol last
                                ;   Bit 1 = 0 if No space after currency symbol
                                ;         = 1 if space after currency symbol
.Currency_cents:  RESB 	1	; Number of places after currency dec point
.Time_24:	  RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
.Map_call:	  RESW	1	; Address of case mapping call (DWORD)
                  RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
				;  in pieces.
.Data_sep:	  RESB	2	; Data list separator character
.size:		
endstruc

;
; Max size of the block returned by the INTERNATIONAL call
;
internat_block_max	EQU	32

;============================================================================
; VECTOR.INC, MSDOS 3.3, 1987
;============================================================================
; 13/10/2018 - Retro DOS 3.0

;BREAK <interrupt definitions>	

; (-*-) Same with MSDOS 2.11 & MSDOS 6.0

INTTAB		EQU	20H
INTBASE 	EQU	4 * INTTAB
ENTRYPOINT	EQU	INTBASE+40H

;
; interrupt assignments
;

INT_ABORT	    EQU     INTTAB	; abort process
INT_COMMAND	    EQU     INT_ABORT+1 ; call MSDOS
INT_TERMINATE	    EQU     INT_ABORT+2 ; int to terminate address
INT_CTRL_C	    EQU     INT_ABORT+3 ; ^c trapper
INT_FATAL_ABORT	    EQU     INT_ABORT+4 ; hard disk error
INT_DISK_READ	    EQU     INT_ABORT+5 ; logical sector disk read
INT_DISK_WRITE	    EQU     INT_ABORT+6 ; logical sector disk write
INT_KEEP_PROCESS    EQU     INT_ABORT+7 ; terminate program and stay
					; resident
INT_SPOOLER	    EQU     INT_ABORT+8 ; spooler call
INT_FASTCON	    EQU     INT_ABORT+9 ; fast CON interrupt
; MSDOS 3.3 (& MSDOS 6.0)
INT_IBM 	    EQU     INT_ABORT+10; critical section maintenance

;============================================================================
; ARENA.INC, MSDOS 3.3, 1987
;============================================================================
; 13/10/2018 - Retro DOS 3.0

;BREAK <Memory arena structure>

; (-*-) Same with MSDOS 2.11 & MSDOS 6.0

;
; arena item
;

struc ARENA
  .signature:	resb 1		; 4D for valid item, 5A for last item
  .owner:	resw 1		; owner of arena item
  .size:	resw 1		; size in paragraphs of item
endstruc

; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
; and arena_owner_system are all equal to zero and are contained in DI.
; Change them and change ALLOC.ASM.

arena_owner_system  EQU 0		; free block indication

arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
arena_signature_end	EQU 5Ah 	; valid signature, last block in arena

;============================================================================
; FILEMODE.INC, MSDOS 3.3, 1987
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;BREAK <FILEMODE.INC - Misc. File API Values>

; (-*-) Same with MSDOS 2.11 & MSDOS 6.0

;**	Standard I/O file handles
;

STDIN	equ	0
STDOUT	equ	1
STDERR	equ	2
STDAUX	equ	3
STDPRN	equ	4

;**	File Modes

ACCESS_MASK	    equ 0Fh
OPEN_FOR_READ	    equ 00h
OPEN_FOR_WRITE	    equ 01h
OPEN_FOR_BOTH	    equ 02h
EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
				; made from exec

;=============================================================================
; COMMAND.COM Resident Portion Addresses - 13/10/2018
;=============================================================================

; Transient portion loader code offset in resident code segment
;LODCOM1   equ	0318h	; 13/10/2018
LODCOM1    equ	0319h	; 24/02/2023

; EXEC call adressses in resident portion for calling from transient portion
EXEC_WAIT  equ 	0131h	; 13/10/2018

; Putbackmsg ("Insert disk ..." msg) disk drive letter in resident portion
;PUTBACKDRV equ	0A21h	; 14/10/2018
PUTBACKDRV equ	0A23h	; 24/02/2023

; Note: Following offset addresses are in data section of 'command3.s' file.
; They must be verified by using assembly list (command3.lst) of COMMAND.COM.

; Resident portion stack address  
;RSTACK	   equ	083Ch
RSTACK	   equ	083Eh	; 24/02/2023 

;RETRABASE equ  0B86h	; 13/10/2018 (Base addr for following common params.)
RETRABASE  equ  0B88h	; 24/02/2023	

; RESGROUP       [RESSEG]
; DATA		  offset
; --------     	------------
PARENT	  equ	RETRABASE+6	; 0B8Ch
OLDTERM	  equ	RETRABASE+8	; 0B9Eh
BATCH	  equ	RETRABASE+17	; 0B97h
COMSPEC	  equ	RETRABASE+19	; 0B99h
PUTBACKSUBSTPTR equ RETRABASE+83 ; 0BD9h
COMSPEC_END equ	RETRABASE+85	; 0BDBh
IN_BATCH  equ	RETRABASE+92	; 0BE2h
BATCH_ABORT equ	RETRABASE+93	; 0BE3h
COMDRV	  equ	RETRABASE+94	; 0BE4h
EXTCOM	  equ	RETRABASE+99	; 0BE9h
RETCODE	  equ	RETRABASE+100	; 0BEAh
ECHOFLAG  equ	RETRABASE+103	; 0BEDh
SUPPRESS  equ	RETRABASE+104	; 0BEEh
IO_SAVE	  equ	RETRABASE+105	; 0BEFh
RESTDIR	  equ	RETRABASE+107	; 0BF1h
PERMCOM	  equ	RETRABASE+108	; 0BF2h
SINGLECOM equ	RETRABASE+109	; 0BF3h
VERVAL	  equ	RETRABASE+111	; 0BF5h
IFFLAG	  equ	RETRABASE+114	; 0BF8h	
FORFLAG	  equ	RETRABASE+115	; 0BF9h
FORPTR	  equ	RETRABASE+116	; 0BFAh 	
NEST	  equ	RETRABASE+118	; 0BFCh
CALL_FLAG equ	RETRABASE+120	; 0BFEh
CALL_BATCH_FLAG equ RETRABASE+121 ; 0BFFh
NEXT_BATCH equ	RETRABASE+122 	; 0C00h
NULLFLAG  equ	RETRABASE+124	; 0C02h
UPPERCASETBL equ RETRABASE+126	; 0C04h
RE_OUT_APP equ	RETRABASE+130	; 0C08h
RE_OUTSTR equ	RETRABASE+131	; 0C09h
INITFLAG  equ	RETRABASE+211	; 0C59h	
PIPEFLAG  equ	RETRABASE+212	; 0C5Ah
PIPEFILES equ	RETRABASE+213	; 0C5Bh
PIPE1	  equ	RETRABASE+214	; 0C5Ch	
PIPE2	  equ	RETRABASE+230	; 0C6Ch
PIPEPTR	  equ	RETRABASE+246	; 0C7Ch
PIPESTR	  equ	RETRABASE+248	; 0C7Eh
INPIPEPTR equ	RETRABASE+377	; 0CFFh
OUTPIPEPTR equ	RETRABASE+379	; 0D01h
ENVIRSEG  equ	RETRABASE+381	; 0D03h
EXEC_BLOCK equ	RETRABASE+381 	; 0D03h  ; ENVIRSEG
LTPA	  equ	RETRABASE+399	; 0D15h
RES_TPA	  equ	RETRABASE+413	; 0D23h

;=============================================================================
					
; (command3.s -> offset TRANGOUP)

TRANGROUP:

; ----------------------------------------------------------------------------
; START OF TRANSIENT PORTION
; ----------------------------------------------------------------------------
; SEGMENT - TRANSCODE
; ----------------------------------------------------------------------------
; 13/10/2018 - Retro DOS v3.0

;[BITS 16]
;[ORG 0]
		times 256 db 0

;============================================================================
; TCODE.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

;[ORG 100h]

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h

; ---------------------------------------------------------------------------

SETDRV:					; Allow for 100H parameter area
		mov	ah,SET_DEFAULT_DRIVE ; 0Eh
		int	21h	; DOS -	SELECT DISK
				; DL = new default drive number	(0 = A,	1 = B,etc.)
				; Return: AL = number of logical drives

; ---------------------------------------------------------------------------

; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
; No registers (CS:IP) no flags, nothing.

TCOMMAND:
		mov	ds,[cs:RESSEG]
		mov	ax,-1
		xchg	ax,word [VERVAL]
		cmp	ax,-1
		jz	short NOSETVER2
		mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
		int	21h	; DOS -	SET VERIFY FLAG
				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
NOSETVER2:
		call	far [cs:HEADCALL]   ; Make sure header fixed
		xor	bp,bp		    ; Flag transient not read
		cmp	word [SINGLECOM],-1
		jnz	short COMMAND
_$EXITPREP:
		push	cs
		pop	ds
		jmp	_$EXIT		; Have finished the single command

; ---------------------------------------------------------------------------
;
; Main entry point from resident portion.
;
;   If BP <> 0, then we have just loaded transient portion otherwise we are
;   just beginning the processing of another command.
;
; ---------------------------------------------------------------------------

; We are not always sure of the state of the world at this time. We presume
; worst case and initialize the relevant registers: segments and stack.

COMMAND:
		cld
		mov	ax,cs
		cli
		mov	ss,ax
		;MOV	SP,OFFSET TRANGROUP:STACK
		mov	sp,STACK
		sti
		
		MOV	ES,AX
		
		; MSDOS 6.0
		;MOV	DS,AX		;AN000; set DS to transient
		;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
		;invoke	TSYSLOADMSG	;AN000; preload messages
		;mov	append_exec,0	;AN041; set internal append state off

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	ds,[ss:RESSEG]
		mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
		mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)

; If we have just loaded the transient, then we do NOT need to initialize the
; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
; I guess not:  the only circumstances in which we reload the command processor
; is after a transient program execution. In this case, we let the current
; directory lie where it may.

		or	bp,bp		; See if just read
		jz	short TESTRDIR	; Not read, check user directory
		mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
		jmp	short NOSETBUF
TESTRDIR:
		cmp	byte [RESTDIR],0
		jz	short NOSETBUF	; User directory OK
		push	ds

; We have an unusual situation to handle. The user *may* have changed his
; directory as a result of an internal command that got aborted. Restoring it
; twice may not help us: the problem may never go away. We just attempt it
; once and give up.

		mov	byte [RESTDIR],0 ; Flag users dirs OK

		; Restore users directory
		push	cs
		pop	ds
		mov	dx,USERDIR1
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		pop	ds
NOSETBUF:
		cmp	byte [PIPEFILES],0
		jz	short NOPCLOSE	; Don't bother if they don't exist
		cmp	byte [PIPEFLAG],0
		jnz	short NOPCLOSE	; Don't del if still piping
		call	PIPEDEL
NOPCLOSE:
		;mov	byte [0BE9h],0	; MSDOS 3.3
		mov	byte [EXTCOM],0 ; Flag internal command
		mov	ax,cs		; Get segment we're in
		mov	ds,ax
		push	ax
		mov	dx,INTERNATVARS
		mov	ax,INTERNATIONAL*256 ; 3800h
		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
				; get current-country info
				; DS:DX	-> buffer for returned info
		pop	ax
		sub	ax,[TPA]	; AX=size of TPA in paragraphs
		push	bx
		mov	bx,16
		mul	bx		; DX:AX=size of TPA in bytes
		pop	bx
		or	dx,dx		; See if over 64K
		jz	short SAVSIZ	; OK if not
		mov	ax,-1		; If so, limit to 65535 bytes
SAVSIZ:

; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1. We round this down to a multiple of 512.

		cmp	ax,512
		jbe	short GOTSIZE
		;and	ax,~1FFh
		and	ax,0FE00h	; NOT 511 = NOT 1FF
GOTSIZE:
		mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
		mov	ds,[RESSEG]	; All batch work must use resident seg.

		test	byte [ECHOFLAG],1 
		jz	short GETCOM	; Don't do the CRLF
		call	SINGLETEST
		jb	short GETCOM
		test	byte [PIPEFLAG],0FFh ; -1
		jnz	short GETCOM
					; G  Don't print prompt in FOR
		test	byte [FORFLAG],0FFh ; -1
		jnz	short GETCOM
					; G  Don't print prompt if in batch
		test	word [BATCH],0FFFFh ; -1
		jnz	short GETCOM
		call	CRLF2
GETCOM:
		mov	byte [CALL_FLAG],0 ; G Reset call flags
		mov	byte [CALL_BATCH_FLAG],0
		mov	ah,GET_DEFAULT_DRIVE ; 19h
		int	21h	; DOS -	GET DEFAULT DISK NUMBER
		mov	[ss:CURDRV],al
		test	byte [PIPEFLAG],0FFh ; -1 ; Pipe has highest presedence
		jz	short NOPIPE
		jmp	PIPEPROC	; Continue the pipeline
NOPIPE:
		test	byte [ECHOFLAG],1
		jz	short NOPDRV	; No prompt if echo off
		call	SINGLETEST
		jb	short NOPDRV
		test	byte [FORFLAG],0FFh ; G  Don't print prompt in FOR	
		jnz	short NOPDRV
		test	word [BATCH],0FFFFh ; G  Don't print prompt if in batch
		jnz	short TESTFORBAT
		call	PRINT_PROMPT	; Prompt the user
NOPDRV:
		test	byte [FORFLAG],0FFh ; FOR has next highest precedence
		jz	short TESTFORBAT
		jmp	FORPROC		; Continue the FOR

TESTFORBAT:
		mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
		mov	byte [RE_OUTSTR],0  ; [0C09h] for MSDOS 3.3 
		mov	byte [RE_OUT_APP],0 ; [0C08h] for MSDOS 3.3
		mov	byte [IFFLAG],0	; no more ifs...
		test	word [BATCH],0FFFFh ; Batch has lowest precedence
		jz	short ISNOBAT

		; MSDOS 6.0

;	Bugbug:	MULT_SHELL_GET no longer used?

		;push	es			;AN000; save ES
		;push	ds			;AN000; save DS
		;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
		;mov	es,[batch]		;AN000; get batch segment
		;mov	di,batfile		;AN000; get batch file name
		;push	cs			;AN000; get local segment to DS
		;pop	ds			;AN000;
		;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
		;int	2fh			;AN000; call the shell
		;cmp	al,shell_action 	;AN000; does shell have a commmand?
		;pop	ds			;AN000; restore DS
		;pop	es			;AN000; restore ES
		;jz	jdocom1 		;AN000; yes - go process command

		; MSDOS 3.3 (& MSDOS 6.0)
		push	ds
		call	READBAT			; Continue BATCH
		pop	ds
		mov	byte [NULLFLAG],0	;G reset no command flag
		test	word [BATCH],0FFFFh
		jnz	short JDOCOM1		;G if batch still in progress continue
		mov	bx,word [NEXT_BATCH]
		cmp	bx,0			;G see if there is a new batch file
		jz	short JDOCOM1		;G no - go do command
		mov	word [BATCH],bx		;G get segment of next batch file
		mov	word [NEXT_BATCH],0	;G reset next batch
JDOCOM1:
		push	cs
		pop	ds
		jmp	short DOCOM1

ISNOBAT:	cmp	word [SINGLECOM],0
		jz	short REGCOM
		;MOV	SI,[SEMIPERMCOM] ;  MSDOS 6.0
		mov	si,0FFFFh 	 ;  MSDOS 3.3
		xchg	si,word [SINGLECOM]
		mov	di,COMBUF+2
		xor	cx,cx
SINGLELOOP:
		lodsb
		stosb
		inc	cx
		cmp	al,0Dh
		jnz	short SINGLELOOP
		dec	cx
		push	cs
		pop	ds
		mov	[COMBUF+1],cl

; do NOT issue a trailing CRLF...

		jmp	short DOCOM1

		;nop

; We have a normal command.  
; Printers are a bizarre quantity. Sometimes they are a stream and
; sometimes they aren't. At this point, we automatically close all spool
; files and turn on truncation mode.

REGCOM:
		;MOV	AX,(ServerCall SHL 8) + 9
		;mov	ax,5D09h
		mov	ax,(SERVERCALL<<8)+9
		int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
		;MOV	AX,(ServerCall SHL 8) + 8
		;mov	ax,5D08h
		mov	ax,(SERVERCALL<<8)+8
		mov	dl,1
		int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
				; DL = 00h redirected output is	combined
				;      01h redirected output placed in separate	jobs
				; start	new print job now
		push	cs
		pop	ds	; Need local segment to point to buffer
		mov	dx,UCOMBUF

		; MSDOS 6.0
;	Try to read interactive command line via DOSKey.
;	If that fails, use DOS Buffered Keyboard Input.

		;mov	ax,4810h	; AX = DOSKey Read Line function
		;int	2fh
		;or	ax,ax
		;jz	GOTCOM		; DOSKey gave us a command line

		;mov	ah,0Ah
		mov	ah,STD_CON_STRING_INPUT	; AH = DOS Buffered Keyboard Input
		int	21h	; DOS -	BUFFERED KEYBOARD INPUT
				; DS:DX	-> buffer
;GOTCOM:
		mov	cl,[UCOMBUF]
		xor	ch,ch
		add	cx,3
		mov	si,UCOMBUF
		mov	di,COMBUF
		rep movsb		; Transfer it to the cooked buffer
DOCOM:
		call	CRLF2
DOCOM1:
		call	PRESCAN		; Cook the input buffer
		jz	short NOPIPEPROC
		jmp	PIPEPROCSTRT	; Fire up the pipe

NULLCOMJ:
		jmp	NULLCOM

NOPIPEPROC:
		call	PARSELINE
		jnb	short OKPARSE	; user error?  or maybe we goofed?
BADPARSE:
		push	cs
		pop	ds
		mov	dx,BADNAMPTR
		call	STD_EPRINTF
		jmp	TCOMMAND

OKPARSE:
		;test	byte [ARGV0_ARG_FLAGS],2
		test	byte [ARG+ARGV_ELE.argflags],wildcard
		jnz	short BADPARSE	; ambiguous commands not allowed
		;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
		cmp	word [ARG+ARG_UNIT.argvcnt],0
		jz	short NULLCOMJ
		;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
		cmp	word [ARG+ARGV_ELE.arglen],0
		jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>

		mov	si,COMBUF+2
		mov	di,IDLEN
		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
					; Make FCB with blank scan-off
		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
		;mov	ax,2901h
		int	21h	; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
		;mov	bx,[ARG_ARGV]
		mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
		cmp	byte [bx+1],':'	; was a drive specified?
		jne	short DRVGD	; no, use default of zero...
		mov	dl,[bx]		; pick-up drive letter
		;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
		;and	dl,~20h
		and	dl,0DFh		; uppercase the sucker
		sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
		cmp	al,-1		; See what PARSE said about our drive letter.
		jz	short DRVBADJ	; It was invalid.
		;mov	di,[ARGV0_ARGSTARTEL]
		mov	di,[ARG+ARGV_ELE.argstartel]
		cmp	byte [di],0	; is there actually a command there?
		jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
		jmp	SETDRV		; and set drive to new drive spec
DRVBADJ:
		jmp	DRVBAD
DRVGD:
		mov	al,[di]
		mov	[SPECDRV],al
		mov	al,' '
		mov	cx,9
		inc	di
		repne scasb		; Count number of letters in command name
		mov	al,8
		sub	al,cl
		mov	[IDLEN],al	; IDLEN is truly the length
		mov	di,81h
		push	si
		mov	si,COMBUF+2	; Skip over all leading delims
		call	SCANOFF

		; MSDOS 6.0
;SR;
; We are going to skip over the first char always. The logic is that the
;command tail can never start from the first character. The code below is 
;trying to figure out the command tail and copy it to the command line 
;buffer in the PSP. However, if the first character happens to be a switch
;character and the user given command line is a full 128 bytes, we try to
;copy 128 bytes to the PSP while it can take only 127 chars. This extra
;char overwrites the code and leads to a crash on future commands.
;
		;inc	si ;  MSDOS 6.0
DO_SKIPCOM:
		lodsb			; move command line pointer over
		call	DELIM		; pathname -- have to do it ourselves
		jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
		cmp	al,0Dh		; can't always depend on argv[0].arglen
		jz	short DO_SKIPPED ; to be the same length as the user-
		cmp	al,[SWITCHAR]	; specified command string
		jnz	short DO_SKIPCOM 
DO_SKIPPED:
		dec	si
		xor	cx,cx
COMTAIL:
		lodsb
		stosb			; Move command tail to 80h
		cmp	al,0Dh
		loopne	COMTAIL
		dec	di
		mov	bp,di
		not	cl
		mov	[80h],cl
		pop	si
;-----
; Some of these comments are sadly at odds with this brave new code.
;-----
; If the command has 0 parameters must check here for
; any switches that might be present.
; SI -> first character after the command.

		;mov	di, arg.argv[0].argsw_word
		;mov	di,[ARGV0_ARGSW_WORD]
		mov	di,[ARG+ARGV_ELE.argsw_word]
		mov	[COMSW],di	; ah yes, the old addressing mode problem...
		;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
					; s = argv[1];
		;mov	si,[ARGV1_ARGPOINTER]
		mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
		or	si,si		;   if (s == NULL)
		jnz	short DOPARSE	;	s = bp; (buffer end)
		mov	si,bp
DOPARSE:
		mov	di,FCB ; 5Ch
		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
		;mov	ax,2901h
		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
		int	21h	; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
		mov	[PARM1],al	; Save result of parse
		;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
		;mov	di,[ARGV1_ARGSW_WORD]
		mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
		mov	[ARG1S],di
		;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
					; s = argv[2];
		;mov	si,[ARGV2_ARGPOINTER]
		mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
		or	si,si		;   if (s == NULL)
		jnz	short DOPARSE2
		mov	si,bp		;	s = bp; (buffer end)
DOPARSE2:			
		mov	di,FCB+10H ; 6Ch
		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 01H
		;mov	ax,2901h
		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h
		int	21h	; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
		mov	[PARM2],al	; Save result
		;mov	di,[ARGV2_ARGSW_WORD]
		;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
		mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
		mov	[ARG2S],di
		;mov	di,[ARGV0_ARGSW_WORD]
		;mov	di,arg.argv[0].argsw_word
		mov	di,[ARG+ARGV_ELE.argsw_word]
		not	di		; ARGTS doesn't include the flags
		;and	di,[ARG_ARGSWINFO]	; from COMSW...
		;and	di,arg.argswinfo	
		and	di,[ARG+ARG_UNIT.argswinfo]
		mov	[ARGTS],di

		mov	al,[IDLEN]
		mov	dl,[SPECDRV]
		or	dl,dl		; if a drive was specified...
		jnz	short EXTERNALJ1 ; it MUST be external, by this time
		dec	al		; (I don't know why -- old code did it)
		jmp	FNDCOM		; otherwise, check internal com table
EXTERNALJ1:
		jmp	EXTERNAL
NULLCOM:
		mov	ds,[RESSEG]
		test	word [BATCH],0FFFFh ; -1 ;G Are we in a batch file?
		jz	short NOSETFLAG	  ;G only set flag if in batch
		;mov	byte [NULLFLAG],1 ;G set flag to indicate no command
		mov	byte [NULLFLAG],nullcommand ; 1
NOSETFLAG:
		cmp	word [SINGLECOM],0FFFFh ; -1
		jz	short EXITJ
		jmp	GETCOM
EXITJ:
		jmp	_$EXITPREP

;============================================================================
; MSHALO.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
;   there is a header that describes a block of rom program.  This header
;   contains information needed to initialize a module and to provide PCDOS
;   with a set of reserved names for execution.
;
;   This header has the following format:
;
;   rom_header	STRUC
;	Signature1  DB	55h
;	Signature2  DB	AAh
;	rom_length  DB	?		; number of 512 byte pieces
;	init_jmp    DB	3 dup (?)
;	name_list   name_struc <>
;   rom_header	ENDS
;
;   name_struc	STRUC
;	name_len    DB	?
;	name_text   DB	? DUP (?)
;	name_jmp    DB	3 DUP (?)
;   name_struc	ENDS
;
;   The name list is a list of names that are reserved by a particular section
;   of a module.  This list of names is terminated by a null name (length
;   is zero).
;
;   Consider now, the PCDOS action when a user enters a command:
;
;	COMMAND.COM has control.
;	o   If location FFFFEh has FDh then
;	o	Start scanning at C0000h, every 800h for a byte 55h followed
;		    by AAh, stop scan if we get above or = F0000H
;	o	When we've found one, compare the name entered by the user
;		    with the one found in the rom.  If we have a match, then
;		    set up the environment for execution and do a long jump
;		    to the near jump after the found name.
;	o	If no more names in the list, then continue scanning the module
;		    for more 55h followed by AAh.
;	o   We get to this point only if there is no matching name in the
;		rom.  We now look on disk for the command.
;
;   This gives us the flexibility to execute any rom cartridge without having
;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
;   want to be invisible to the DOS should not have any names in their lists
;   (i.e. they have a single null name).
;
;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
;   Clearly this version will be available on disk.  How does a user actually
;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
;   EXEC loader will execute the ROM before it even looks at the disk!	Only
;   solution:
;
;   o	Keep things consistent and force the user to have his software named
;	differently from the ROM names (BASIC1, BASIC2, etc).

struc ROM_HEADER
    .signature1: resb 1
    .signature2: resb 1
    .rom_length: resb 1
    .init_jmp:	 resb 3
    .name_list:	 resb 1
    .size:
endstruc

struc NAME_STRUC
    .name_len:	resb 1
    .name_text:	resb 1
    .name_jmp:	resb 3
    .size:	
endstruc

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h

; =============== S U B	R O U T	I N E =======================================

;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name

ROM_SCAN:
		push	es
		push	si
		push	di
		push	cx
		push	ax
		push	bx

		; check for PC Jr signature in rom

		mov	ax,0F000h
		mov	es,ax
		cmp	byte [es:0FFFEh],0FDh
		je	short SCAN_IT
NO_ROM:
		clc
ROM_RET:
		pop	bx
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	es
		retn

SCAN_IT:	; start scanning at C000h

		mov	ax,0C000h
SCAN_ONE:
		mov	es,ax
		xor	di,di

SCAN_MODULE:	; check for a valid header

		cmp	word [es:di],0AA55h
		jz	short SCAN_LIST
		add	ax,80h
SCAN_END:
		cmp	ax,0F000h
		jb	short SCAN_ONE
		jmp	short NO_ROM

		; trundle down list of names
SCAN_LIST:
		;mov	bl,[es:di+2]
					; number of 512-byte jobbers
		mov	bl,[es:di+ROM_HEADER.rom_length]
		xor	bh,bh		; nothing in the high byte
		shl	bx,1
		shl	bx,1		; number of paragraphs
		add	bx,7Fh
		and	bx,0FF80h	; round to 2k	
		;mov	di,6
		mov	di,ROM_HEADER.rom_length

		;nop
SCAN_NAME:
		mov	cl,[es:di]	; length of name
		inc	di		; point to name
		xor	ch,ch
		or	cx,cx		; zero length name
		jnz	short SCAN_TEST	; nope... compare
		add	ax,bx		; yep, skip to next block
		jmp	short SCAN_END

SCAN_TEST:	; compare a single name

		mov	si,dx
		inc	si
		repe cmpsb		 ; compare name
		jz	short SCAN_FOUND ; success!
SCAN_NEXT:
		add	di,cx		; failure, next name piece
		add	di,3
		jmp	short SCAN_NAME

SCAN_FOUND:	; found a name. save entry location

		cmp	byte [si],'?'
		jz	short SCAN_SAVE
		cmp	byte [si],' '
		jnz	short SCAN_NEXT
SCAN_SAVE:
		mov	[cs:ROM_CS],es
		mov	[cs:ROM_IP],di
		stc
		jmp	short ROM_RET

; ---------------------------------------------------------------------------

; execute a rom-placed body of code. allocate largest block

ROM_EXEC:
		mov	bx,0FFFFh
		mov	ah,ALLOC ; 48h
		int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
		mov	ah,ALLOC ; 48h
		int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
		push	bx
		push	ax

		; set terminate addresses

		;mov	ax,2522h
		;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
		mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
		push	ds
		mov	ds,[cs:RESSEG]
		;mov	dx,offset RESGROUP:EXEC_WAIT
		;mov	dx,131h ; MSDOS 3.3
		mov	dx,EXEC_WAIT
		int	21h	; DOS -	SET INTERRUPT VECTOR
				; AL = interrupt number
				; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx,ds
		mov	es,dx
		pop	ds
		
		; and create program header and dup all jfn's

		pop	dx
		mov	ah,DUP_PDB ; 55h
		int	21h	; DOS -	2+ internal - CREATE PSP
				; DX = segment number at which to set up PSP
				; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
		
		; set up dma address

		mov	ds,dx
		mov	dx,80h
		mov	ah,SET_DMA ; 1Ah
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer

		; copy in environment info

		mov	ax,word [es:ENVIRSEG]
		mov	[PDB.ENVIRON],	ax

		; set up correct size of block

		pop	bx		; BX has size, DS has segment
		mov	dx,ds
		add	dx,bx
		;mov	[2],dx
		mov	word [PDB.BLOCK_LEN],dx

		; change ownership of block

		mov	dx,ds
		dec	dx
		mov	ds,dx
		inc	dx	
		;mov	[1],dx
		mov	word [ARENA.owner],dx
		mov	ds,dx

		; set up correct stack

		cmp	bx,1000h
		jb	short GOT_STACK
		xor	bx,bx
GOT_STACK:
		mov	cl,4
		shl	bx,cl
		mov	dx,ds
		mov	ss,dx
		mov	sp,bx
		xor	ax,ax
		push	ax

		; set up initial registers and go to the guy

		not	ax
		push	word [cs:ROM_CS]
		push	word [cs:ROM_IP]
		mov	es,dx
		retf	; far return

;============================================================================
; TBATCH.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h

; =============== S U B	R O U T	I N E =======================================

;Break	<PromptBat - Open or wait for batch file>

; Open the batch file. If we cannot find the batch file. If the media is
; changeable, we prompt for the change. Otherwise, we terminate the batch
; file. Leave segment registers alone.

PROMPTBAT:
		call	BATOPEN
		jc	short PROMPTBAT1
		retn
PROMPTBAT1:
		; MSDOS 6.0 COMMAND.COM
		;cmp	dx,error_file_not_found ;AN022; Ask for diskette if file not found
		;jz	Bat_Remcheck		;AN022;
		;cmp	dx,error_path_not_found ;AN022; Ask for diskette if path not found
		;jz	Bat_Remcheck		;AN022;    Otherwise, issue message and exit
		;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
		;jmp	short BatDie		;AN022;
;Bat_Remcheck:					;AN022; Go see if media is removable
		;call	[RCH_ADDR]		; DX has error number
		;jz	AskForBat		; Media is removable

		; MSDOS 3.3 COMMAND.COM
		cmp	dx,ACCDENPTR
		jz	short BATDIE

		; MSDOS 3.3 (& MSDOS 6.0)
BAT_REMCHECK:				; Go see if media is removable
		call	far [cs:RCH_ADDR] ; DX has error number
		jz	short ASKFORBAT	; Media is removable

; The media is not changeable. Turn everything off.

		call	FOROFF
		call	PIPEOFF
		mov	byte [IFFLAG],al ; No If in progress.	
		mov	dx,BADPATHPTR
BATDIE:
		call	BATCHOFF
		push	cs
		pop	ds
		;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
		call	STD_PRINTF	; MSDOS 3.3

; TCOMMAND resets the stack. This is the equivalent of a non-local goto.

		jmp	TCOMMAND

; Ask the user to reinsert the batch file

ASKFORBAT:
		push	ds
		push	cs
		pop	ds

		; MSDOS 6.0
		;MOV	DX,OFFSET TRANGROUP:NEEDBAT_ptr  ;AN022;
		;invoke	std_eprintf	 	;Prompt for batch file on stderr
		;mov	dx,offset trangroup:pausemes_ptr 
		;;invoke std_eprintf		;AN000; get second part of message
						;AN000; print it to stderr
		; MSDOS 3.3 (& MSDOS 6.0)
		call	STD_EPRINTF
		call	GETKEYSTROKE
		pop	ds
		jmp	short PROMPTBAT


; MSDOS 6.0
;****************************************************************
;*
;* ROUTINE:	Output_batch_name
;*
;* FUNCTION:	Sets up batch name to be printed on extended error
;*
;* INPUT:	DX - extended error number
;*
;* OUTPUT:	Ready to call print routine
;*
;****************************************************************
;
;public	output_batch_name			;AN022;
;
;Output_batch_name    proc near			;AN022;
;
;		push	ds			;AN022; save resident segment
;		mov	ds,[batch]		;AN022; get batch file segment
;	assume	DS:nothing			;AN022;
;		mov	SI,BatFile		;AN022; get offset of batch file
;		invoke	dstrlen 		;AN022; get length of string
;		mov	di,offset Trangroup:bwdbuf ;AN022; target for batch name
;		rep	movsb			;AN022; move the name
;
;		push	cs			;AN022; get local segment
;		pop	ds			;AN022;
;	assume	DS:trangroup			;AN022;
;		mov	extend_buf_ptr,dx	;AN022; put message number in block
;		mov	msg_disp_class,ext_msg_class
;						;AN022; set up extended error msg class
;		mov	dx,offset TranGroup:Extend_Buf_ptr
;						;AN022; get extended message pointer
;		mov	string_ptr_2,offset trangroup:bwdbuf 
;						;AN022; point to substitution
;		mov	extend_buf_sub,one_subst ;AN022; set up for one subst
;		pop	ds			;AN022; restore data segment
;
;		ret				;AN022; return
;
;Output_batch_name    endp			;AN022;


; =============== S U B	R O U T	I N E =======================================

;Break	<GetKeystroke - get a keystroke and flush queue>

; Read the next keystroke. Since there may be several characters in the queue
; after the one we ask for (function keys/Kanji), we need to flush the queue
; AFTER waiting.

GETKEYSTROKE:
		; MSDOS 3.3
		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
		;mov	ax,0C08h
		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
				; AL must be 01h,06h,07h,08h,or 0Ah.
		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
		;mov	ax,0C00h
		mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
				; AL must be 01h,06h,07h,08h,or 0Ah.
		retn

		; MSDOS 6.0
		;PUSH	DX				;AN000;  3/3/KK
		;MOV	AX,(ECS_call SHL 8) OR GetInterimMode ;AN000;  3/3/KK
		;INT	21h				;AN000;  3/3/KK
		;PUSH	DX				;AN000;  save interim state 3/3/KK
		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
		;MOV	DL,InterimMode			;AN000;  3/3/KK
		;INT	21h				;AN000;  3/3/KK
		;
		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
		;INT	21h		; Get character with KB buffer flush
		;MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
		;INT	21h
		;
		;MOV	AX,(ECS_call SHL 8) OR SetInterimMode ;AN000;  3/3/KK
		;POP	DX				;AN000;  restore interim state 3/3/KK
		;INT	21h				;AN000;  3/3/KK
		;POP	DX				;AN000;  3/3/KK
		;
		;return

; =============== S U B	R O U T	I N E =======================================

; Break	<ReadBat - read 1 line from batch file>

; ReadBat - read a single line from the batch file. 
; Perform all substitutions as appropriate.

READBAT:
		;ASSUME	DS:ResGroup,ES:TranGroup
		
		;mov	byte [SUPPRESS],1
					; initialize line suppress status
		mov	byte [SUPPRESS],YES_ECHO 
		test	byte [BATCH_ABORT],-1 ; 0FFh
		jnz	short TRYING_TO_ABORT
		mov	byte [IN_BATCH],1 ; set flag to indicate batch job

		; MSDOS 6.0
;
;M037; Start of changes
; We check here if we have set the flag indicating that the batchfile is at
;EOF. In this case, we do not want to continue with the normal processing.
;We call GetBatByt once more so that the batch segment gets freed up, the
;batch file gets closed etc. and then return as if everything is done.
;
		;push	ds
		;mov	ds,Batch
		;cmp	ds:BatchEOF,0	; are we at EOF in batchfile
		;pop	ds
		;jz	contbat		; no, continue normal processing
		;invoke	GetBatByt	; frees up batchseg
		;mov	es:ComBuf+2,al	; stuff CR into command buffer
		;			; as a dummy command
		;invoke CrLf2		; print a CR-LF
		;return			; done batch processing

;M037; End of changes
		
		; MSDOS 3.3 (& MSDOS 6.0)
CONTBAT:
		call	PROMPTBAT

TRYING_TO_ABORT:
		mov	di,COMBUF+2

; Save position and try to scan for first non delimiter.

TESTNOP:
		mov	ax,ds
		mov	ds,word [BATCH]
		push	word [BATCHSEGMENT.BatSeek]
		push	word [BATCHSEGMENT.BatSeek+2] ; save current location.
		mov	ds,ax
		call	SKIPDELIM	; skip to first non-delim

; If the first non-delimiter is not a : (label), we reseek back to the
; beginning and read the line.

		cmp	al,':'		; is it a label?
		pop	cx
		pop	dx		; restore position in bat file
		jz	short NOPLINE	; yes, resync everything.
		test	word [BATCH],-1 ; are we done with the batch file?
		jz	short RDBAT	; no, go read batch file

		;cmp	al,'@'
		cmp	al,NO_ECHO_CHAR	; see if user wants to suppress line
		jnz	short SET_BAT_POS ; no - go and set batch file position
		;mov	byte [SUPPRESS],0
		mov	byte [SUPPRESS],NO_ECHO ; yes set flag to indicate
		jmp	short RDBAT	; go read batch file

		;nop
SET_BAT_POS:
		push	ds
		mov	ds,word [BATCH]
		mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
		mov	[BATCHSEGMENT.BatSeek+2],cx
		pop	ds
		;MOV	AX,(LSEEK SHL 8) + 0
		mov	ax,(LSEEK*256) ; 4200h ; ; seek back
		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
				; AL = method: offset from beginning of	file
		;mov	word [cs:BATBUFPOS],0FFFFh
		mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
		xor	cx,cx		; Initialize line length to zero
		jmp	short RDBAT

		;nop

; The first non-delimiter is a :. This line is not echoed and is ignored.
; We eat characters until a CR is seen.

NOPLINE:
		call	SKIPTOEOL
		call	GETBATBYT	; eat trailing LF
		;test	word [BATCH],0FFFFh
		test	word [BATCH],-1 ; are we done with the batch file?
		jnz	short TESTNOP	; no, go get another line
READBAT_RETN:				; Hit EOF			
		retn

; ---------------------------------------------------------------------------

; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
; input, we are to consider two special cases:
;
;   %0 to %9	These represent replaceable parameters from the batch segment
;   %sym%	This is a symbol from the environment

RDBAT:
		call	GETBATBYT
		inc	cx		; Inc the line length
RDBAT1:
		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
		jnb	short TOOLONG	   ; Yes - handle it, handle it

; See if we have a parameter character.

		cmp	al,'%'		; Check for parameter
		jz	short NEEDPARM

; no parameter character. Store it as usual and see if we are done.

SAVBATBYT:
		stosb			; End of line found?
		cmp	al,0Dh
		jnz	short RDBAT	; no, go for more

; We have read in an entire line. 
; Decide whether we should echo the command line or not.

FOUND_EOL:
		sub	di,COMBUF+3
		mov	ax,di		; remember that we've not counted the CR
		mov	[es:COMBUF+1],al ; Set length of line
		call	GETBATBYT	; Eat linefeed
		call	BATCLOSE
		cmp	byte [SUPPRESS],NO_ECHO ; 0
		jz	short RESET
		test	byte [ECHOFLAG],1  ; To echo or not to echo, that is the
		jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
RESET:
		push	cs
		pop	ds		; Go back to local segment
		jz	short READBAT_RETN ; no echoing here...
TRY_NEXTFLAG:
		cmp	byte [NULLFLAG],nullcommand ; 1
					;G was there a command last time?
		jz	short NO_CRLF_PRINT ;G no - don't print crlf
		call	CRLF2		;G  Print out prompt
NO_CRLF_PRINT:
		call	PRINT_PROMPT
		push	cs		;G change data segment
		pop	ds
		mov	dx,COMBUF+2	; get command line for echoing
		call	CRPRINT
		call	CRLF2
		retn

; The line was too long. Eat remainder of input text up until the CR

TOOLONG:
		cmp	al,0Dh		; Has the end of the line been reached?
		jz	short LTLCONT	; Yes, continue
		call	SKIPTOEOL	; Eat remainder of line	
LTLCONT:
		stosb			; Terminate the command
		jmp	short FOUND_EOL	; Go process the valid part of the line

; We have found a parameter lead-in character. Check for the 0-9 case first

NEEDPARM:
		call	GETBATBYT	; get next character
		cmp	al,'%'		; Check for two consecutive %
		jz	short SAVBATBYT	; if so, replace with a single %
		cmp	al,0Dh		; Check for end-of-line
		jz	short SAVBATBYT	; yes, treat it normally

; We have found %<something>. If the <something> is in the range 0-9, we
; retrieve the appropriate parameter from the batch segment. Otherwise we
; see if the <something> has a terminating % and then look up the contents
; in the environment.

PAROK:
		sub	al,'0'
		jb	short NEEDENV	; look for parameter in the environment
		cmp	al,9
		ja	short NEEDENV

; We have found %<number>. This is taken from the parameters in the
; allocated batch area.

		cbw
		mov	bx,ax		; move index into AX
		shl	bx,1		; convert word index into byte ptr
		push	es
		mov	es,word [BATCH]
;
; The structure of the batch area is:
;
;   BYTE    type of segment
;   DWORD   offset for next line
;   10 WORD pointers to parameters. -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; Get pointer to BX'th argument
;
		;mov	si,[es:bx+0Bh]
		mov	si,[es:bx+BATCHSEGMENT.BatParm]
		pop	es

; Is there a parameter here?

		cmp	si,-1		; Check if parameter exists
		jnz	short YES_THERE_IS ; Yes go get it
		jmp	RDBAT		; Ignore if it doesn't

; Copy in the found parameter from batch segment

YES_THERE_IS:
		push	ds
		mov	ds,word [BATCH]
		dec	cx		; Don't count '%' in line length
COPYPARM:
		lodsb			; From resident segment
		cmp	al,0Dh		; Check for end of parameter
		jz	short ENDPARAM
		inc	cx		; Inc the line length
		cmp	cx,COMBUFLEN ; 128 ; Is it too long?
		jnb	short LINETOOL	; Yes - handle it, handle it
		stosb
		jmp	short COPYPARM

; We have copied up to the limit. Stop copying and eat remainder of batch
; line. We need to make sure that the tooLong code isn't fooled into
; believing that we are at EOL. Clobber AL too.

LINETOOL:
		xor	al,al
		pop	ds
		jmp	short TOOLONG

; We have copied in an entire parameter. Go back for more

ENDPARAM:
		pop	ds
		jmp	RDBAT

; We have found % followed by something other than 0-9. We presume that there
; will be a following % character. In between is an environment variable that
; we will fetch and replace in the batch line with its value.

NEEDENV:
		; MSDOS 6.0 COMMAND.COM 
		;dec     cx 		;AN070; Don't count "%"

		; MSDOS 3.3 (& MSDOS 6.0)
		push	ds
		push	di
					; temp spot for name
		mov	di,ID
		add	al,'0'		; reconvert character
		stosb			; store it in appropriate place

; loop getting characters until the next % is found or until EOL

GETENV1:
		call	GETBATBYT	; get the byte
		stosb			; store it
		cmp	al,0Dh		; EOL?
		jnz	short GETENV15	; no, see if it the term char

; The user entered a string with a % but no trailing %. We copy the string.

		mov	byte [es:di-1],0 ; nul terminate the string
		mov	si,ID 		; point to buffer
		pop	di		; point to line buffer
		push	cs
		pop	ds
		call	STRCPY
		;jc	short LineTooL	;  MSDOS 6.0 COMMAND.COM
		dec	di  		;  MSDOS 3.3 COMMAND.COM	
		pop	ds
		jmp	SAVBATBYT
GETENV15:
		cmp	al,'%'		; terminating %?
		jnz	short GETENV1	; no, go suck out more characters

; M017 - following DEC is wrong, because we replace the % with a = here.
; This was the source of bug #1.
;		dec	cx		;AN070; Don't count "%"

		mov	al,'='		; terminate  with =
		mov	[es:di-1],al

; ID now either has a =-terminated string which we are to find in the
; environment or a non =-terminated string which will not be found in the
; environment.

GETENV2:
		mov	si,ID
		push	cs
		pop	ds		; DS:SI points to name
		push	cx
		call	FIND_NAME_IN_ENVIRONMENT
		pop	cx
		push	es
		pop	ds
		push	cs
		pop	es
		mov	si,di
		pop	di		; get back pointer to command line

; If the parameter was not found, there is no need to perform any replacement.
; We merely pretend that we've copied the parameter.

		jc	short GETENV6

; ES:DI points to command line being built
; DS:SI points either to nul-terminated environment object AFTER =

		call	STRCPY		; (let RdBat handle overflow)
		dec	di 	; MSDOS 3.3 COMMAND.COM
GETENV6:
		pop	ds
		jmp	RDBAT		; go back to batch file

; =============== S U B	R O U T	I N E =======================================

;   SkipToEOL - read from batch file until end of line

SKIPTOEOL:
		test	word [BATCH],-1 ; 0FFFFh
		
		;jnz	short SKIPTOEOL1  	
		;retn			; no batch file in effect
		
		jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
SKIPTOEOL1:
		call	GETBATBYT
		cmp	al,0Dh		; eol character?
		jnz	short SKIPTOEOL	; no, go eat another
SKIPTOEOL2:
		retn

; =============== S U B	R O U T	I N E =======================================

;Break	<Allocate and deallocate the transient portion>

; Free Transient. Modify ES,AX,flags

FREE_TPA:
		push	es
		mov	es,[RESSEG]
		mov	es,word [es:RES_TPA]
		mov	ah,DEALLOC ; 49h
		int	21h	; DOS -	2+ - FREE MEMORY
				; ES = segment address of area to be freed
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

; Allocate transient.  Modify AX,BX,DX,flags

ALLOC_TPA:
		push	es
		mov	es,[RESSEG]
		mov	bx,0FFFFh 	; Re-allocate the transient	
		mov	ah,ALLOC ; 48h
		int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
		push	bx	  	; Save size of block
		mov	ah,ALLOC ; 48h
		int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired

; Attempt to align TPA on 64K boundary

		pop	bx		; Restore size of block
		mov	word [es:RES_TPA],ax ; Save segment to beginning of block
		mov	[TRAN_TPA],ax

; Is the segment already aligned on a 64K boundary

		mov	dx,ax		; Save segment
		and	ax,0FFFh	; Test if above boundary
		jnz	short CALC_TPA
		mov	ax,dx
		and	ax,0F000h	; Test if multiple of 64K
		jnz	short NOROUND
CALC_TPA:
		mov	ax,dx
		and	ax,0F000h
		add	ax,1000h	; Round up to next 64K boundary
		jc	short NOROUND	; Memory wrap if carry set

; Make sure that new boundary is within allocated range

		mov	dx,word [es:RES_TPA]
		add	dx,bx		; Compute maximum address
		cmp	dx,ax		; Is 64K address out of range?
		jb	short NOROUND

; Make sure that we won't overwrite the transient

		mov	bx,cs		; CS is beginning of transient
		cmp	bx,ax
		jb	short NOROUND

; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.

		sub	bx,ax
		;cmp	bx,4096
		cmp	bx,1000h	; Size greater than 64K?	
		jnb	short ROUNDDONE
NOROUND:
		mov	ax,word [es:RES_TPA]
ROUNDDONE:
		mov	word [es:LTPA],ax ; Re-compute everything
		mov	[TPA],ax
		mov	bx,ax
		mov	ax,cs
		sub	ax,bx
		push	bx
		mov	bx,16
		mul	bx
		pop	bx
		or	dx,dx
		jz	short SAVSIZ2
		mov	ax,-1
SAVSIZ2:

; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1. We round this down to a multiple of 512.

		cmp	ax,512
		jbe	short GOTSIZE2
		;and	ax,~1FFh
		and	ax,0FE00h	; NOT 511 = NOT 1FFh
GOTSIZE2:
		mov	[BYTCNT],ax
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

;Break	<BatCom - enter a batch file>

; The exec search has determined that the user has requested a batch file for
; execution. We parse the arguments, create the batch segment, and signal
; batch processing.

BATCOM:	

;ASSUME	DS:TRANGROUP, ES:NOTHING

; Batch parameters are read with ES set to segment of resident part

		; MSDOS 6.0
		;mov	es,[RESSEG]
		;ASSUME	ES:RESGROUP
		;cmp	es:[call_batch_flag],call_in_progress
		;				;AN043; If in CALL,
		;jz	skip_ioset		;AN043; redirection was already set up
		;invoke	IOSET			; Set up any redirection
;skip_ioset:					;AN043;
		;call	FREE_TPA		; G
		;cmp	es:[call_batch_flag],call_in_progress ;G
		;jz	getecho 		; G if we're in a call, don't execute

		; MSDOS 3.3
		call	IOSET
		mov	es,[RESSEG]
		call	FREE_TPA
		;cmp	byte [es:CALL_BATCH_FLAG],1
		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
		jz	short GETECHO		; G if we're in a call, don't execute

		; MSDOS 3.3 (& MSDOS 6.0)

; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
; being started it MUST be true that no FOR or PIPE is currently in progress.
; Don't execute if in call

		call	FOROFF
GETECHO:
		call	PIPEOFF
		mov	al,byte [es:ECHOFLAG] ; preserve echo state for chaining
		and	al,1		; Save current echo state

		push	ax
		xor	ax,ax
		test	word [es:BATCH],-1 ; Are we in a batch file?
		jz	short LEAVEBAT	   ; No, nothing to save
		mov	ax,word [es:BATCH] ; Get current batch segment
		;cmp	byte [es:CALL_BATCH_FLAG],1
		cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
		jz	short LEAVEBAT

;  We are in a chained batch file, save batlast from previous batch segment
;  so that if we're in a CALL, we will return to the correct batch file.

		push	es
		mov	es,ax		; Get current batch segment
		;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
					; Get previous batch segment
		mov	ax,word [es:BATCHSEGMENT.BatLast]
		pop	es
LEAVEBAT:
		push	ax		; Keep segment until new one created
		cmp	byte [es:CALL_BATCH_FLAG],1
		jz	short STARTBAT
		call	BATCHOFF

; Find length of batch file

STARTBAT:
		mov	byte [es:CALL_BATCH_FLAG],0 ; Reset call flag
		mov	si,EXECPATH

		; MSDOS 6.0
		;mov	ax,AppendTruename ;AN042; Get the real path where the batch file
		;int	2fh		;AN042;    was found with APPEND
		;mov	ah,Find_First	;AN042; The find_first will return it
		;mov	dx,si		;AN042; Get the string
		;mov	cx,search_attr	;AN042; filetypes to search for
		;int	21h		;AN042;

		; MSDOS 3.3 (& MSDOS 6.0)
		call	DSTRLEN
;
; Allocate batch area:
;   BYTE    type of segment
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; We allocate the maximum size for the command line and use setblock to shrink
; later when we've squeezed out the extra
;
		mov	bx,cx		; length of file name.
		;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
		add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
					; structure + max len + round up
		push	cx
		mov	cl,4
		shr	bx,cl		; convert to paragraphs
		push	bx		; Save size of batch segment
		mov	ah,ALLOC ; 48h ; Allocate batch segment
		int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
		pop	bx		; Get size of batch segment

; This should *NEVER* return an error. The transient is MUCH bigger than
; the batch segment. This may not be true, however, in a multitasking system.
; G This error will occur with nesting of batch files. We also need to
; G make sure that we don't overlay the transient.

		jc	short MEM_ERROR	;G not enough memory - exit

		push	ax		;G save batch segment
		add	ax,bx		;G get end of batch segment
		add	ax,20h		;G add some tpa work area
		mov	bx,cs		;G get the transient segment

		; MSDOS 6.0
; M006; We cant check just for above. If the batchseg goes into a UMB, the
; M006; batchseg is always above the transient. We need to change this code
; M006; to only check for an overlap
;
		;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
		;add	dx,15		;round up para; M006
		;shr	dx,cl		;para size of transient; M006
		;add	dx,bx		;dx = top of transient; M006

		;cmp	ax,bx		; M006
		;jb	enough_mem	; Batchseg below transient
					; enough memory ; M006
		;cmp	ax,dx		; M006
		;ja	enough_mem	; Batchseg above transient
					; enough memory ; M006
;
; M006; Batchseg overlaps transient -- insufficient memory
;
		;pop	ax		; restore ax; M006

;M006;		cmp	ax,bx		;G do we end before the transient
;M006;		pop	ax		;G get batch segment back
;M006;		jb	enough_mem	;G we have enough memory - continue

		; MSDOS 3.3
		cmp	ax,bx		; do we end before the transient ?
		pop	ax		; get batch segment back
		jb	short ENOUGH_MEM ; we have enough memory - continue

		; MSDOS 3.3 (& MSDOS 6.0)
		push	es		;G no we're hitting the transient
		mov	es,ax
		mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
		int	21h	; DOS -	2+ - FREE MEMORY
				; ES = segment address of area to be freed
		pop	es
MEM_ERROR:
		jmp	NO_MEMORY	;G Set up for message and exit

ENOUGH_MEM:
		; MSDOS 6.0
		;pop	ax		; restore ax; M006

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	word [es:BATCH],ax
		call	ALLOC_TPA

; Initialize batch segment

		pop	dx		; length of name
		pop	ax		;G get saved batch segment back
		inc	word [es:NEST]	;G increment # batch files in progress
		push	es
		mov	es,word [es:BATCH]
		;mov	byte [ES:0],0
					; signal batch file type
		mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
		;mov	byte [ES:2],ax ; MSDOS 3.3
					;G save segment of last batch file
		mov	word [es:BATCHSEGMENT.BatLast],ax
		push	ds
		mov	ds,[RESSEG]	;G set to resident data

		xor	ax,ax
		mov	bl,byte [FORFLAG] ;G get the current FOR state
		;mov	[es:6],bl ;  MSDOS 3.3
					;G save it in the batch segment
		mov	[es:BATCHSEGMENT.BatForFlag],bl
		test	bl,-1		;G are we in a FOR?
		jz	short FOR_NOT_ON ;G no, for segment set to 0	
		mov	ax,word [FORPTR] ;G yes, get current FOR segment	
		mov	byte [FORFLAG],0 ;G reset forflag
FOR_NOT_ON:
		;mov	[es:4],ax ; MSDOS 3.3
					;G save FOR segment in batch segment
		mov	[es:BATCHSEGMENT.BatForPtr],ax	
		xor	ax,ax
		mov	word [FORPTR],ax ;G make sure for segment is not active
		mov	bl,byte [ECHOFLAG]
		pop	ds
		;mov	[es:1],bl 
					 ;G save echo state of parent
		mov	[es:BATCHSEGMENT.BatEchoFlag],bl
;SR;
; Initialize the new BatchEOF flag we have added to 0
;
		;mov	es:BatchEOF,0  ; MSDOS 6.0

		mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
		mov	[es:BATCHSEGMENT.BatSeek+2],ax

; Initialize pointers

		dec	ax		; put -1 into AX
		;mov	di,0Bh  ; MSDOS 3.3
					; point to parm area
		mov	di,BATCHSEGMENT.BatParm
		mov	bx,di
		mov	cx,10
		rep stosw		; Init to no parms

; Move in batch file name

		mov	cx,dx
		rep movsb

; Now copy the command line into batch segment, parsing the arguments along
; the way. Segment will look like this:
;
;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
;
; or, in the case of fewer arguments:
;
;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
;
		mov	si,COMBUF+2
		mov	cx,10		; at most 10 arguments
EACHPARM:
		call	SCANOFF		; skip to argument

; AL is first non-delimiter. DS:SI points to char = AL

		cmp	al,0Dh		; end of road?
		jz	short HAVPARM	; yes, no more arguments

; If CX = 0 then we have stored the most parm we can. Skip store

		jcxz	MOVPARM		; Only first 10 parms get pointers

; Go into allocated piece and stick in new argument pointer.

		mov	[es:bx],di	; store batch pointer
		add	bx,2		; advance arg counter

; Move the parameter into batch segment

MOVPARM:
		lodsb			; get byte
		call	DELIM		; if delimiter
		jz	short ENDPARM	; then done with parm
		stosb			; store byte
		cmp	al,0Dh		; if CR then not delimiter
		jz	short HAVPARM	; but end of parm list, finish
		jmp	short MOVPARM

; We have copied a parameter up until the first separator.
; Terminate it with CR.

ENDPARM:
		mov	al,0Dh
		stosb
		jcxz	EACHPARM	; if no parameters, don't dec
		dec	cx		; remember that we've seen one.	
		jmp	short EACHPARM

; We have parsed the entire line. Terminate the arg list

HAVPARM:
		xor	al,al		; Nul terminate the parms
		stosb

; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
; into paragraphs and setblock to the appropriate size

		lea	bx,[di+15]
		mov	cl,4
		shr	bx,cl
		mov	ah,SETBLOCK ; 4Ah
		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
				; ES = segment address of block	to change
				; BX = new size	in paragraphs
		pop	es
		push	es
		pop	ds		; Simply batch FCB setup
		cmp	word [SINGLECOM],-1 ; 0FFFFh
		jnz	short NOBATSING
		mov	word [SINGLECOM],0FFF0h ; Flag single command BATCH job
NOBATSING:

; Enter the batch file with the current echo state

		pop	ax		; Get original echo state
		mov	byte [ECHOFLAG],al ; restore it
		jmp	TCOMMAND

; The following is executed if there isn't enough memory for batch segment

NO_MEMORY:
		pop	dx		; even up our stack 
		pop	ax
		pop	ax
		call	ALLOC_TPA	; reallocate memory

		; MSDOS 3.3
		mov	dx,INSFMEMMESPTR
		jmp	CERROR

		; MSDOS 6.0
		;mov	msg_disp_class,ext_msg_class
		;			;AN000; set up extended error msg class
		;mov	dx,offset TranGroup:Extend_Buf_ptr
		;			;AC000; get extended message pointer
		;mov	Extend_Buf_ptr,error_not_enough_memory
		;			;AN000; get message number in control block
		;jmp	cerror		;g print error message and go...

; =============== S U B	R O U T	I N E =======================================

BATCHOFF:
		push	ax
		push	es
		push	ds
		push	bx

		mov	es,[cs:RESSEG]
		mov	ds,[cs:RESSEG]
		mov	ax,word [BATCH]	; Free the batch segment
		or	ax,ax
		jz	short NOTFREE

		push	es
		mov	es,ax
		test	byte [ECHOFLAG],1 ;G Is echo on?
		jnz	short ECHO_LAST_LINE ;G Yes - echo last line in file
		;mov	byte [SUPPRESS],0
		mov	byte [SUPPRESS],NO_ECHO ;G no - don't echo last line in file	
ECHO_LAST_LINE:
		;mov	bl,[es:1]
		mov	bl,[es:BATCHSEGMENT.BatEchoFlag] ; G get echo state
		mov	byte [ECHOFLAG],bl		 ; G and restore it
		;mov	bx,[es:4] ;  MSDOS 3.3
		mov	bx,[es:BATCHSEGMENT.BatForPtr]	;G  Get FOR segment
		mov	word [FORPTR],bx		;G  and restore it
		;mov	bl,[es:6]
		mov	bl,[es:BATCHSEGMENT.BatForFlag] ;G  Get FOR flag
		mov	byte [FORFLAG],bl		;G  and restore it
		;mov	bx,word [es:2] ; MSDOS 3.3
		mov	bx,[es:BATCHSEGMENT.BatLast]	;G  Get old batch segment

		mov	ah,DEALLOC ; 49h
		int	21h	; DOS -	2+ - FREE MEMORY
				; ES = segment address of area to be freed
		pop	es
		mov	word [NEXT_BATCH],bx ;G  reset batch segment	
		dec	word [es:NEST]
		xor	ax,ax
		mov	word [BATCH],ax	; No batch in progress
NOTFREE:
		pop	bx
		pop	ds
		pop	es
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; StrCpy - copy string, checking count in CX against COMBUFLEN
;	Entry : DS:SI ==> source string
;		ES:DI ==> destination string
;		CX = current length of destination string
;	Exit  : string copied, CX updated, Carry set if length limit exceeded

		; MSDOS 3.3
STRCPY:
		push	ax
CCYCLE:
		lodsb
		stosb
		or	al,al
		jnz	short CCYCLE
		pop	ax
		retn

		; MSDOS 6.0
;Procedure StrCpy,NEAR
		;push	ax
;ccycle:
		;lodsb
		;inc	cx
		;cmp	cx,COMBUFLEN
		;jb	ccopy
		;stc			; set carry to signal error
		;jmp	short ccend
;ccopy:
		;stosb
		;or	al,al
		;jnz	ccycle
;ccend:
		;dec	cx		; discount extra byte
		;dec	di		; back up pointer
		;pop	ax
		;return			; return carry clear
;EndProc StrCpy

;============================================================================
; TBATCH2.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h

; =============== S U B	R O U T	I N E =======================================

;Break	<GetBatByt - retrieve a byte from the batch file>

; Get one byte from the batch file and return it in AL. End-of-file returns
; <CR> and ends batch mode. DS must be set to resident segment.
; AH, DX destroyed.

GETBATBYT:
		push	bx
		push	cx
		push	ds
		test	byte [BATCH_ABORT],-1
		jnz	short BATEOF
		test	word [BATCH],-1
		jz	short BATEOF
		push	es
		mov	es,word [BATCH]

		; MSDOS 6.0
;M020;
;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
;try to read from the batchfile again.
;
		;cmp	es:BatchEOF,0	;already reached EOF?	;M020
		;jz	not_eof		;no, read batch file	;M020
		;jmp	At_EOF		;yes, no more reads	;M020
;not_eof:							;M020
		; MSDOS 3.3 (& MSDOS 6.0)
		add	word [es:BATCHSEGMENT.BatSeek],1
		adc	word [es:BATCHSEGMENT.BatSeek+2],0
		pop	es

; See if we have bytes buffered...

		mov	ax,cs
		mov	ds,ax
		mov	bx,[BATBUFPOS]
		cmp	bx,-1
		jnz	short UNBUF

; There are no bytes in the buffer. Let's try to fill it up.

		mov	dx,BATBUF
		mov	cx,[BATBUFLEN] ; max to read.
		mov	bx,[BATHAND]
		mov	ah,READ ; 3Fh	; Get one more byte from batch file
		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
				; BX = file handle,CX = number	of bytes to read
				; DS:DX	-> buffer
		; MSDOS 6.0
		;jnc	bat_read_ok		;AN022; if no error - continue
		;invoke	get_ext_error_number	;AN022; get the error
		;push	ds			;AN022; save local segment
		;mov	ds,[resseg]		;AN022; get resident segment
		;assume ds:resgroup		;AN022;
		;mov	dx,ax			;AN022; put error in DX
		;invoke	output_batch_name	;AN022; set up to print the error
		;pop	ds			;AN022;
		;assume	ds:trangroup		;AN022;
		;invoke	std_eprintf		;AN022; print out the error
		;mov	byte ptr combuf+2,end_of_line_in
		;				;AN022; terminate the batch line for parsing
		;mov	byte ptr combuf+3,end_of_line_out 
		;				;AN022; terminate the batch line for output
;M020;
;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
;error is never hit (and it shouldn't be)
;
		;mov	ds,ResSeg		; ds = RESGROUP ; M020
		;
		;jmp	short bateof		;AN022; terminate the batch file
;bat_read_ok:					;AN022;

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	cx,ax
		jcxz	TURN_OFF ; MSDOS 3.3
		;jcxz	BATEOFDS ; MSDOS 6.0
		mov	[BATBUFEND],cx
		xor	bx,bx
		mov	[BATBUFPOS],bx

; Buffered bytes!

UNBUF:
		mov	al,[BATBUF+bx]		; get next byte
		inc	bx
		cmp	bx,[BATBUFEND]		; beyond end of buffer?
		jb	short SETBUFPOS
		mov	bx,-1
SETBUFPOS:
		mov	[BATBUFPOS],bx
		cmp	al,1Ah			; ^Z for termination?
		jnz	short GETBYTEDONE

;We get here only when we hit an EOF
		
		; MSDOS 6.0
;BatEOFDS:
;SR;
; HACK!!! A massive hack being put in here to get batch processing to work
;properly on EOF. Previously, a CR was returned and batch processing turned
;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
;batch processing is turned off before the last line is processed and so 
;this line would never be executed. 
;   	To fix this, a new flag BatchEOF has been introduced. This flag is
;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
;at the buffer contents. If there is no LF ( we assume that presence of LF
;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
;fake CR to the caller. This decrements BatchEOF. On the next call to this
;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
;third call, BatchEOF becomes zero and batch processing is turned off,
;now that the last line has been processed. If the EOF is the first char read into the buffer 
;during this call, and there was a CR-LF previously, we are going to fake
;another redundant CR-LF. There is no work-around I can think of.
; 	I would love to restructure this entire routine and its caller to
;make the flow really easy to understand but I guess this will have to wait.
;
		;push	es
		;mov	es,ResSeg
;SR;
; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
;or BatchEOF == 1 now), then do not do the LF check.
;
		;mov	es,es:Batch
		;cmp	es:BatchEOF,0
		;jnz	crpresent

		;inc	es:BatchEOF		;match the dec following
		;mov	bx,BatBufEnd
		;cmp	BatBuf[bx-1],0ah	;was a LF present?
		;je	crpresent		;yes, no need to fake it

		;add	es:BatchEOF,3		;BatchEOF == 4 to fake CR-LF

;crpresent:
;;;		;pop	es

		;ASSUME	DS:TranGroup
		;MOV	DS,ResSeg
		;ASSUME	DS:ResGroup

;SR;
; The shift operation is done here to replace the decrement. This is because
;we can jump to this label directly from above when bogus calls are made to
;this routine even after batch processing is turned off. The shift ensures
;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
;it is used as a decrement and also as a NOP to just fall through on bogus 
;calls.
;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
;turning batch processing off.

;At_EOF:						;new label added ;M020
		;shr	es:BatchEOF,1		;decrement the flag
		;jz	turn_off		;zero,turn batch off
		;cmp	es:BatchEOF,1				
		;jz	ret_lf			;BatchEOF was 2, return LF
;
;BatchEOF == 4, indicates return fake CR now and fake LF next.
;
		;mov	al,0dh			;return fake CR.
		;pop	es
		;jmp	short GetByteDone
;ret_lf:
		;mov	al,0ah			;return fake LF
		;pop	es
		;jmp	short	GetByteDone			
;turn_off:
		;pop	es

;BATEOF:

		; MSDOS 3.3
TURN_OFF:
		mov	ds,[RESSEG]

		; MSDOS 3.3 (& MSDOS 6.0)
BATEOF:
		call	BATCHOFF
		call	BATCLOSE
;;;		mov	BatchEOF,0	;make sure BatchEOF = 0

;SR; BugBug
; There is a good reason why this carriage return is being returned here. 
;This was part of the old code, thanks to some brain-damaged coding. Because,
;of the way the caller is structured, a fake CR has to be returned again on
;EOF to ensure the termination of the caller's loop. If echo is on, this
;results in an extra linefeed after the batchfile is run if the last line of
;the batchfile already had a CR-LF. 
;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
;the end-of-line. This CR is to mark the end-of-file.

		mov	al,0Dh		; If end-of-file, then end of line
		test	byte [BATCH_ABORT],-1
		mov	byte [BATCH_ABORT],0
		jz	short CONT_GET_BYT
		mov	di,COMBUF+2	; reset pointer to beginning of buffer
		xor	cx,cx		; zero line length
		jmp	short GETBYTEDONE
CONT_GET_BYT:
		cmp	word [SINGLECOM],0FFF0h ; See if we need to set SINGLECOM
		jnz	short GETBYTEDONE
		cmp	word [NEST],0	;G See if we have nested batch files
		jnz	short GETBYTEDONE ;G Yes - don't exit just yet
		mov	word [SINGLECOM],0FFFFh ; -1 ; Cause termination
GETBYTEDONE:
		pop	ds
		pop	cx
		pop	bx
		retn

; ---------------------------------------------------------------------------

;break	<$If - conditional execution>

IFERRORP:
		pop	ax
IFERROR:
FORERROR:
		mov	dx,SYNTMESPTR
		jmp	CERROR

; ---------------------------------------------------------------------------

_$IF:
		; MSDOS 6.0
; Turn off any pipes in progress.
		;push	ds			;AN004; save local DS
		;mov	ds,[resseg]		;AN004; get resident segment
		;assume	ds:resgroup		;AN004;
		;cmp	[PIPEFILES],0		;AN004; Only turn off if present.
		;jz	IFNoPipe		;AN004; no pipe - continue
		;invoke	PipeDel 		;AN004; turn off piping
;IFNoPipe:					;AN004;
		;pop	ds			;AN004; get local DS back
		;assume	ds:trangroup		;AN004;

		; MSDOS 3.3 (&MSDOS 6.0)
		mov	byte [IFNOTFLAG],0
		mov	word [IF_NOT_COUNT],0
		mov	si,81h
IFREENT:
		call	SCANOFF
		cmp	al,0Dh
		jz	short IFERROR
		mov	bp,si
		mov	di,IFTAB	; Prepare to search if table	
		mov	ch,0
IFINDCOM:
		mov	si,bp
		mov	cl,[di]
		inc	di
		jcxz	IFSTRING
		jmp	short FIRSTCOMP

IFCOMP:
		jnz	short IF_DIF
FIRSTCOMP:
		lodsb
		mov	ah,[es:di]
		inc	di
		cmp	al,ah
		jz	short IFLP
		or	ah,20h		; Try lower case
		cmp	al,ah
IFLP:
		loop	IFCOMP
IF_DIF:
		lahf
		add	di,cx		; Bump to next position without affecting flags
		mov	bx,[di]		; Get handler address
		inc	di
		inc	di
		sahf
		jnz	short IFINDCOM
		lodsb
		cmp	al,0Dh
IFERRJ:
		jz	short IFERROR
		call	DELIM
		jnz	short IFINDCOM
		call	SCANOFF
		jmp	bx

IFNOT:
		not	byte [IFNOTFLAG]
		inc	word [IF_NOT_COUNT]
		jmp	short IFREENT

; We are comparing two strings for equality. First, find the end of the
; first string.

IFSTRING:
		push	si		; save away pointer for later compare
		xor	cx,cx		; count of chars in first string
FIRST_STRING:
		lodsb			; get character
		cmp	al,0Dh		; end of line?
		jz	short IFERRORP	; yes => error
		call	DELIM		; is it a delimiter?
		jz	short EQUAL_CHECK ; yes, go find equal sign
		inc	cx		; remember 1 byte for the length
		jmp	short FIRST_STRING ; go back for more
EQUAL_CHECK:
		cmp	al,'='		; is char we have an = sign?
		jz	short EQUAL_CHECK2 ; yes, go find second one.
		cmp	al,0Dh		; end of line?
		jz	short IFERRORP	; yes, syntax error
		lodsb			; get next char
		jmp	short EQUAL_CHECK

; The first = has been found. The next char had better be an = too.

EQUAL_CHECK2:
		lodsb			; get potential = char
		cmp	al,'='		; is it good?	
		jnz	short IFERRPJ	; no, error

; Find beginning of second string.

		call	SCANOFF
		cmp	al,0Dh
		jz	short IFERRPJ
		pop	di

; DS:SI points to second string
; CX has number of chars in first string
; ES:DI points to first string

		repe cmpsb
		jz	short MATCH	; match found!

; No match.  Let's find out what was wrong. The character that did not match
; has been advanced over. Let's back up to it.

		dec	si

; If it is EOL, then syntax error

		cmp	byte [si],0Dh
		jz	short IFERRJ

; Advance pointer over remainder of unmatched text to next delimiter

SKIPSTRINGEND:
		lodsb
NOTMATCH:
		cmp	al,0Dh
IFERRORJ2:
		jz	short IFERRJ
		call	DELIM
		jnz	short SKIPSTRINGEND

; Signal that we did NOT have a match

		mov	al,-1
		jmp	short IFRET
IFERRPJ:
		jmp	IFERRORP

; The compare succeeded. Was the second string longer than the first?
; We do this by seeing if the next char is a delimiter.

MATCH:
		lodsb
		call	DELIM
		jnz	short NOTMATCH ; not same.
		xor	al,al
		jmp	short IFRET

; ---------------------------------------------------------------------------

IFEXISTS:

IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6

;MOREDELIM:
		lodsb
		call	DELIM
		jnz	short IFEXISTS
		;jnz	short MOREDELIM

		mov	dx,DIRBUF
		mov	ax,SET_DMA*256 ; 1A00h
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
		mov	bx,2		; if(0) [|not](|1) exist[1|2] file(2|3)
		add	bx,[IF_NOT_COUNT]
		;mov	ax,ARG_ARGV
		;mov	ax,ARG+ARG_UNIT.argv
		mov	ax,ARG
		call	ARGV_CALC	; convert arg index to pointer
		mov	dx,[bx]
		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
		;mov	cx,6
		mov	cx,IFEXIST_ATTR ; filetypes to search for
		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
				; CX = search attributes
				; DS:DX	-> ASCIZ filespec
				; (drive,path, and wildcards allowed)
		jc	short IF_EX_C ; carry is how to determine error
		xor	al,al
		jmp	short IFRET

		;nop
IF_EX_C:
		mov	al,-1		; false 'n' fall through...
IFRET:
		test	byte [IFNOTFLAG],-1 ; 0FFh
		jz	short REALTEST
		not	al
REALTEST:
		or	al,al
		jz	short IFTRUE
		jmp	TCOMMAND

IFTRUE:
		call	SCANOFF
		mov	cx,si
		sub	cx,81h
		sub	[80h],cl
		mov	cl,[80h]
		mov	[COMBUF+1],cl
		mov	di,COMBUF+2
		cld
		rep movsb
		mov	al,0Dh
		stosb

; Signal that an IF was done. 
; This prevents the redirections from getting lost.

		push	ds
		mov	ds,[RESSEG]
		mov	byte [IFFLAG],-1
		pop	ds

; Go do the command

		jmp	DOCOM1

; ---------------------------------------------------------------------------

IFERRORJ3:
		jmp	IFERRORJ2

IFERLEV:
		mov	bh,10
		xor	bl,bl
GETNUMLP:
		lodsb
		cmp	al,0Dh
		jz	short IFERRORJ3
		call	DELIM
		jz	short GOTNUM
		sub	al,'0'
		xchg	al,bl
		mul	bh
		add	al,bl
		xchg	al,bl
		jmp	short GETNUMLP
GOTNUM:
		push	ds
		mov	ds,[RESSEG]
		mov	ah,byte [RETCODE]  ; [0BEAh] in MSDOS 3.3 COMMAND.COM 
		pop	ds
		xor	al,al
		cmp	ah,bl
		jnb	short IFRET
		dec	al
		jmp	short IFRET

; ---------------------------------------------------------------------------

; Shift the parameters in the batch structure by 1 and set up the new argument.
; This is a NOP if no batch in progress.

SHIFT:
		mov	ds,[RESSEG]
		mov	ax,word [BATCH]	; get batch pointer
		or	ax,ax		; in batch mode?
		jnz	short SHIFT1	; yes, operate in batch segment	
SHIFT_RETN:				; no, done.
		retn
SHIFT1:
		mov	es,ax
		mov	ds,ax

; Now move the batch args down by 1 word

		;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
		mov	di,BATCHSEGMENT.BatParm ; point to parm table
		lea	si,[di+2]	; make source = dest + 2
		mov	cx,9		; move 9 parameters
		rep movsw		; SHIFT down

; If the last parameter (the one not moved) is empty (= -1) then we are done.
; We have copied it into the previous position.

		cmp	word [di],-1	; if last one was not in use then
		jz	short SHIFT_RETN ; No new parm

; This last pointer is NOT nul. Get it and scan to find the next argument.
; Assume, first, that there is no next argument.
 
		mov	si,[di]
		mov	word [di],-1	; Assume no parm

; The parameters are CR separated. Scan for end of this parm.

SKIPCRLP:
		lodsb
		cmp	al,0Dh
		jnz	short SKIPCRLP

; We are now pointing at next arg. If it is 0 (end of original line) then we
; are finished. There are no more parms and the pointer has been previously
; initialized to indicate it.

		cmp	byte [si],0
		jz	short SHIFT_RETN ; End of parms
		mov	[di],si		; Pointer to next parm as %9
		retn

; =============== S U B	R O U T	I N E =======================================

; Skip delim reads bytes from the batch file until a non-delimiter is seen.
; returns char in AL, carry set -> eof

SKIPDELIM:
		test	word [BATCH],-1	; batch file empty.  OOPS!
		jz	short SKIPERR
		call	GETBATBYT	; get a char
		call	DELIM		; check for ignoreable chars
		jz	short SKIPDELIM	; ignore this char.
		clc
		retn
SKIPERR:
		stc
GOTO_RETN:
		retn

; ---------------------------------------------------------------------------

;  CALL is an internal command that transfers control to a .bat, .exe, or
;  .com file. This routine strips the CALL off the command line, sets
;  the CALL_FLAG to indicate a call in progress, and returns control to
;  DOCOM1 in TCODE to reprocess the command line and execute the file
;  being CALLed.

_$CALL:

;  strip off CALL from command line

		;ASSUME DS:trangroup,ES:trangroup

		push	si
		push	di
		push	ax
		push	cx
		mov	si,COMBUF+2
		call	SCANOFF		;get to first non-delimeter
		;add	si,4
		add	si,length_call	;point to char past CALL
		mov	di,COMBUF+2
		;mov	cx,124		
		mov	cx,COMBUFLEN-length_call ;get length of buffer
		rep movsb		;move it
		pop	cx
		pop	ax
		pop	di
		pop	si

;  set call flag to indicate call in progress

		push	ds
		mov	ds,[RESSEG]
		mov	byte [CALL_FLAG],call_in_progress ; 1
		mov	byte [CALL_BATCH_FLAG],call_in_progress ; 1

; Turn off any pipes in progress.

		cmp	byte [PIPEFILES],0 ; Only turn off if present.
		jz	short _NOPIPE
		call	PIPEDEL
_NOPIPE:
		pop	ds
		retn

; ---------------------------------------------------------------------------

GOTO:
		mov	ds,[RESSEG]
		test	word [BATCH],-1	; If not in batch mode, a nop
		jz	short GOTO_RETN
		xor	dx,dx
		push	ds
		mov	ds,word [BATCH]
		mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
		mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start

		; MSDOS 6.0
;M037
; Clear EOF indicator because we have reseeked to the beginning of the file.
;
		;mov	ds:BatchEOF,0	; clear eof indicator ;M037

		; MSDOS 3.3 (& MSDOS 6.0)

		pop	ds
GOTOOPEN:
		call	PROMPTBAT
		;mov	di,5Dh
		mov	di,FCB+1	; Get the label
		mov	cx,11
		mov	al,' '
		repne scasb
		jnz	short NOINC
		inc	cx
NOINC:
		sub	cx,11
		neg	cx
		mov	[cs:GOTOLEN],cx

; At beginning of file. Skip to first non-delimiter char

		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al,':'
		jz	short CHKLABEL
LABLKLP:				; Look for the label
		call	GETBATBYT
		cmp	al,0Ah
		jnz	short LABLKTST

; At beginning of line.  Skip to first non-delimiter char

		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al,':'
		jz	short CHKLABEL
LABLKTST:
		test	word [BATCH],0FFFFh ; -1
		jnz	short LABLKLP
BADGOTO:
		call	BATCLOSE

		; MSDOS 6.0
;SR;
; At this point we are terminating without freeing up any nested batch 
;segments i.e if the error occurred within a called batch file. This routine
;will traverse the linked list of batch segments and free all of them.
;
		;call	free_batch	;free up nested batch segments

		; MSDOS 3.3 (& MSDOS 6.0)
		push	cs
		pop	ds
		mov	dx,BADLABPTR
		jmp	CERROR

; Found the :.	Skip to first non-delimiter char

CHKLABEL:
		call	SKIPDELIM
		jb	short BADGOTO
		mov	di,FCB+1 ; 5Dh
		mov	cx,[cs:GOTOLEN]
		jmp	short GOTBYTE

NEXTCHRLP:
		push	cx
		call	GETBATBYT
		pop	cx
GOTBYTE:
		or	al,20h
		cmp	al,[es:di]
		jnz	short TRYUPPER
		jmp	short NEXTLABCHR
TRYUPPER:
		sub	al,20h
		cmp	al,[es:di]
		jnz	short LABLKTST
NEXTLABCHR:
		inc	di
		loop	NEXTCHRLP
		call	GETBATBYT
		cmp	word [cs:GOTOLEN],8 ; Is the label atleast 8 chars long?
		jge	short GOTOCONT	; Yes, then the next char doesn't matter
		cmp	al,' '
		ja	short LABLKTST
GOTOCONT:
		cmp	al,0Dh
		jz	short SKIPLFEED
TONEXTBATLIN:
		call	GETBATBYT
		cmp	al,0Dh
		jnz	short TONEXTBATLIN
SKIPLFEED:
		call	GETBATBYT

		; MSDOS 6.0
;SR;
; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
;CR-LF for the last line. On a goto, this flag has to be cleared, because
;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
;to get the EOF has not been made yet because we encountered the Goto. On
;all other cases, EOF will be hit while trying to read the next line and
;we are fine. I know, I know, what a massive hack from hell!! God help us!!
;
		;push	es
		;mov	es,Batch
		;mov	es:BatchEOF,0	;invalidate fake CR-LF flag
		;pop	es

		; MSDOS 3.3 (& MSDOS 6.0)
		call	BATCLOSE
		retn

; =============== S U B	R O U T	I N E =======================================

BATCLOSE:
		mov	bx,[cs:BATHAND]
		cmp	bx,5
		jb	short CLOSERETURN
		mov	ah,CLOSE ; 3Eh
		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
CLOSERETURN:
		mov	byte [IN_BATCH],0 ; reset flag	
		retn

; =============== S U B	R O U T	I N E =======================================

; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
; Also, fills internal batch buffer. If access denied, then AX = -1

BATOPEN:
		push	ds
		mov	ds,word [BATCH]
		;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
		mov	dx,BATCHSEGMENT.BatFile
		mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
				; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 0 - read
		jb	short SETERRDL
		mov	dx,[BATCHSEGMENT.BatSeek]
		mov	cx,[BATCHSEGMENT.BatSeek+2]
		pop	ds
		mov	[cs:BATHAND],ax
		mov	bx,ax
		mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
				; AL = method: offset from beginning of	file

		mov	word [cs:BATBUFPOS],-1 ; 0FFFFh ; nuke batch buffer position
BATOPEN_RETN:
		retn

SETERRDL:
		mov	bx,dx
		; MSDOS 6.0
		;invoke	get_ext_error_number ;AN022; get the extended error
		;mov	dx,ax		     ;AN022; save extended error in DX

		; MSDOS 3.3
		mov	dx,INSERTDSKPTR
		call	GET_EXT_ERR_NUMBER

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	al,[bx]		; Get drive spec
		sub	al,'@'		; A = 1
		pop	ds
		stc			; SUB mucked over carry
		retn

;============================================================================
; TFOR.ASM, MSDOS 6.0, 1991
;============================================================================
; 10/10/2018 - Retro DOS v3.0

; All batch proccessing has DS set to segment of resident portion
;ASSUME DS:RESGROUP,ES:TRANGROUP

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0BE9h

; ---------------------------------------------------------------------------

FORTERM:
		; MSDOS 6.0
		;push	cs		;AN037; Get local segment into
		;pop	ds		;AN037;    DS, ES
		;push	cs		;AN037;
		;pop	es		;AN037;

		; MSDOS 3.3 (& MSDOS 6.0)
		call	FOROFF
		mov	ds,[cs:RESSEG]
		cmp	word [SINGLECOM],0FF00h
		jne	short BAT_CRLF
		cmp	word [NEST],0	;See if we have nested batch files
		jne	short BAT_CRLF	;Yes - don't exit just yet
		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause a terminate
		jmp	short NOFORP2
BAT_CRLF:
		test	byte [ECHOFLAG],1 ; Is echo on?
		jz	short NOFORP2	; no - exit
		test	word [BATCH],-1 ; 0FFFFh ; ; print CRLF if in batch
		jz	short NOFORP2
		call	CRLF2
NOFORP2:
		jmp	TCOMMAND

; ---------------------------------------------------------------------------

;------
;   For-loop processing.  For loops are of the form:
;	    for %<loop-variable> in (<list>) do <command>
; where <command> may contain references of the form %<variable>, which are
; later substituted with the items in <list>. The for-loop structure is
; set-up by the procedure '$for'; successive calls to 'forproc' execute
; <command> once for each item in <list>. All of the information needed for
; loop processing is stored on a piece of memory gotten from 'alloc'. This
; structure is actually fairly large, on the order of 700 bytes, and includes
; a complete copy of the original command-line structure as parsed by
; 'parseline', loop control variables, and a dma buffer for the
; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
; processing has completed, this chunk of memory is returned to the system.
;
;   All of the previously defined variables, in 'datares', used for loop
; processing may be erased.  Only one, (DW) ForPtr, need be allocated.
;
;   The error message, 'for_alloc_mes', should be moved into the file
; containing all of the other error messages.
;
;   Referencing the allocated for-loop structure is a little tricky.
; At the moment, a byte is defined as part of a new segment, 'for_segment'.
; When 'forproc' actually runs, ES and DS are set to point to the base of the
; new chunk of memory.	References to this byte, 'f', thus assemble correctly
; as offsets of ES or DS. 'f' would not be necessary, except that the
; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
; immediate move of the offset of 'for_minarg' into AX. In other words, in
; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
;	mov  AX, #for_minarg 	; AX := 02CA (for example)
; instead of
;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
; By using 'f', we pretend that we are actually referencing an allocated
; structure, and the assembler coughs up the code we want. Notice that it
; doesn't matter whether we put brackets around the location or not -- the
; assembler is "smart" enough to know that we want an address instead of the
; contents of that location.
;
;   Finally, there now exists the potential to easily implement nested loops.
; One method would be to have a link field in each for-structure pointing to
; its parent.  Variable references that couldn't be resolved in the local
; frame would cause a search of prior frames. For-structures would still be
; allocated and released in exactly the same fashion. The only limit on the
; number of nested loops would be memory size (although at 700 bytes a pop,
; memory wouldn't last THAT long). Alternately, a small structure could be
; maintained in the resident data area. This structure would be an array of
; control-variable names and pointers to for-structure blocks. This would
; greatly speed up the resolution of non-local variable references. However,
; since space in the resident is precious, we would have to compromise on a
; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
; allocation and de-allocation would have to be modified slightly to take this
; new structure into account.
;
;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
; It could just as well be one structure allocated in 'transpace'. Actually,
; it may be easier to allocate it as part of 'for_segment'.
;------

		; include fordata.asm

; Data structure definitions included by tfor.asm

struc FOR_INFO
  .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  .FOR_COM_START: resb  1		; beginning of <command>
  .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  .FOR_MINARG:	  resw  1		; beginning of <list>
  .FOR_MAXARG:	  resw  1		; end of <list>
  .FORBUF:	  resw  64		; temporary buffer
  .FORDMA:	  resw  64		; FindFirst/Next buffer
  .FOR_VAR:	  resb  1		; loop control variable
  .size:
endstruc
					; ARG_UNIT.SIZE = 1348 (544h)

_$FOR_EXIT:
		jmp	short FORTERM	; exceeding maxarg means all done

; ---------------------------------------------------------------------------

FORPROC:
		mov	ax,word [FORPTR]
		mov	ds,ax
		mov	es,ax		; operate in for-info area
		mov	dx,FOR_INFO.FORDMA
		mov	ax,SET_DMA*256 ; 1A00h
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
FOR_BEGIN:
		cmp	word [FOR_INFO.FOR_EXPAND],0	; [545h]
		jz	short FOR_BEGIN1
					; non-zero for_expand equals FALSE
		inc	word [FOR_INFO.FOR_MINARG]	; [547h]

FOR_BEGIN1:
		mov	bx,word [FOR_INFO.FOR_MINARG]
					; current item in <list> to examine
		cmp	bx,word [FOR_INFO.FOR_MAXARG]	; [549h]
		jg	short _$FOR_EXIT ; exceeding maxarg means all done	
		;mov	ax,0
		mov	ax,FOR_INFO.FOR_ARGS
		call	ARGV_CALC	; compute argv[x] address
		;mov	cx,[bx+3]
		mov	cx,[bx+ARGV_ELE.argstartel]
		mov	dx,[bx]
		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
		;test	byte [bx+2],4	; Is there a path separator in this arg?
		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
		jnz	short FORSUB	; Yes, argstartel should be correct
		mov	si,[bx]
		;mov	si,[bx+ARGV_ELE.argpointer]

		mov	al,[cs:LPAREN]
		cmp	[si-1],	al	; If the current token is the first
		jnz	short FORSUB	;  one in the list and originally had
		inc	cx		;  the opening paren as its first char,
					;  the argstartel ptr needs to be
					;  advanced passed it before the prefix
					;  length is computed.
		mov	al,':'
		cmp	[si+1],	al	; If the token begins with "(d:",
		jnz	short FORSUB	;  argstartel has to be moved over the
		add	cx,2		;  rest of the prefix as well.
FORSUB:
		sub	cx,dx		; compute length of pathname prefix
		cmp	word [FOR_INFO.FOR_EXPAND],0 ; are we still expanding a name?
		jz	short FOR_FIND_NEXT ; if so, get next matching filename
		;test	byte [bx+2],2
		test	byte [bx+ARGV_ELE.argflags],wildcard ; 2
		jnz	short FOR_FIND_FIRST ; should we expand THIS (new) arg?
		;mov	cx,[bx+5]	     ; else, just copy all of it directly	
		mov	cx,[bx+ARGV_ELE.arglen]
		jmp	short FOR_SMOOSH

		;nop
FOR_FIND_FIRST:
		push	cx
		xor	cx,cx
		mov	ax,FIND_FIRST*256 ; 4E00h
		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
				; CX = search attributes
				; DS:DX	-> ASCIZ filespec
				; (drive,path, and wildcards allowed)
		pop	cx
		jmp	short FOR_RESULT

		;nop
FOR_FIND_NEXT:
		mov	ax,FIND_NEXT*256 ;4F00h
		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
				; [DTA]	= data block from
				; last AH = 4Eh/4Fh call
FOR_RESULT:
		mov	ax,-1 ; 0FFFFh	; assume worst case
		jc	short FOR_CHECK
		mov	ax,0		; Find* returns 0 for SUCCESS
FOR_CHECK:				; record success of findfirst/next
		mov	word [FOR_INFO.FOR_EXPAND],ax
		or	ax,ax	; anything out there?
		jnz	short FOR_BEGIN	; if not, try next arg
FOR_SMOOSH:
		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
		mov	si,[bx] 	; copy argv[arg][0,CX] into destbuf
		mov	di,FOR_INFO.FORBUF ; some days this will be the entire
		rep movsb		; arg, some days just the path prefix
					
		cmp	word [FOR_INFO.FOR_EXPAND],0
					; if we're not expanding, we can
		jnz	short FOR_MAKE_COM ; skip the following	

		;mov	si,05E9h ; MSDOS 3.3 COMMAND.COM
		mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
FOR_MORE:
		cmp	byte [si],0	; tack on matching filename
		jz	short FOR_MAKE_COM
		movsb
		jnz	short FOR_MORE
FOR_MAKE_COM:
		xor	al,al		; tack a null byte onto the end
		stosb			; of the substitute string
		xor	cx,cx		; character count for command line
		not	cx		; negate it -- take advantage of loopnz
		xor	bx,bx		; argpointer
		mov	di,COMBUF+2
		mov	bl,byte [FOR_INFO.FOR_COM_START] ; argindex
		mov	dh,byte [FOR_INFO.FOR_VAR] 
					; %<for-var> is replaced by [forbuf]
		push	cs		; time to form the <command> string
		pop	es
		;assume ES:trangroup
		;mov	ax,FOR_INFO.FOR_ARGS
		mov	ax,0		; translate offset to pointer
		call	ARGV_CALC
		;mov	si,[bx+9]
		mov	si,[bx+ARGV_ELE.arg_ocomptr] 
					; mov ptr passed beginning space
		inc	si
FOR_MAKE_LOOP:
		mov	al,[si]		; the <command> arg, byte by byte
		inc	si
		cmp	al,'%'		; looking for %<control-variable>
		jnz	short FOR_STOSB ; no % ... add byte to string
		cmp	[si],dh		; got the right <variable>?
		jnz	short FOR_STOSB	; got a %, but wrong <variable>
		inc	si		; skip over <for-variable>

		push	si
		mov	si,FOR_INFO.FORBUF ; substitute the <item> for <variable>
					; to make a final <command> to execute
SLOOP:					
		lodsb			; grab all those <item> bytes, and
		stosb			; add 'em to the <command> string,
		or	al,al		; until we run into a null
		loopne	SLOOP
		dec	di		; adjust length and <command> pointer
		inc	cx		; so we can overwrite the null
		pop	si
		jmp	short FOR_MAKE_LOOP ; got back for more <command> bytes

FOR_STOSB:
		stosb			; take a byte from the <command> arg
		dec	cx		; and put it into the <command> to be
					; executed (and note length, too)
		cmp	al,0Dh		
		jnz	short FOR_MAKE_LOOP ; If not done, loop.
FOR_MADE_COM:
		not	cl
		mov	[cs:COMBUF+1],cl

		mov	ds,[cs:RESSEG]
		;assume DS:resgroup
		test	byte [ECHOFLAG],1 ; shall we echo this <command>, dearie?
		jz	short NOECHO3
		;cmp	byte [NULLFLAG],nullcommand
		cmp	byte [NULLFLAG],1 ;G was there a command last time?
		jz	short NO_CRLF_PR  ;G no - don't print crlf	 	

		call	CRLF2		  ;G  Print out prompt
NO_CRLF_PR:
		mov	byte [NULLFLAG],0 ;G reset no command flag
		push	cs
		pop	ds
		push	di
		call	PRINT_PROMPT	  ;G Prompt the user
		pop	di

		mov	byte [es:di-1],0  ; yeah, PRINT it out...	
		mov	word [STRING_PTR_2],COMBUF+2
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
		mov	byte [es:di-1],0Dh
		jmp	DOCOM		  ; run silent, run deep...
NOECHO3:
		mov	byte [NULLFLAG],0
		push	cs
		pop	ds
		jmp	DOCOM1

FORNESTERRJ:				; no multi-loop processing... yet!		
		call	FOROFF
		jmp	FORNESTERR

; ---------------------------------------------------------------------------

FORERRORJ:
		jmp	FORERROR

; ---------------------------------------------------------------------------

_$FOR:
		mov	es,[RESSEG]
		cmp	byte [es:FORFLAG],0 ; is another one already running?
		jnz	short FORNESTERRJ   ; if flag is set.... boom!

; Turn off any pipes in progress.

		cmp	byte [es:PIPEFILES],0 ; Only turn off if present.
		jz	short NO_PIPE
		call	PIPEDEL
NO_PIPE:
		xor	dx,dx		; counter (0 <= DX < argvcnt)
		call	NEXTARG		; move to next argv[n]
		jc	short FORERRORJ	; no more args -- bad forloop
		cmp	al,'%'		; next arg MUST start with '%'...
		jnz	short FORERRORJ
		mov	bp,ax		; save forloop variable
		lodsb
		or	al,al		; and MUST end immediately...
		jnz	short FORERRORJ
		call	NEXTARG		; let's make sure the next arg is 'in'
		jb	short FORERRORJ
		;and	ax,0DFDFh
		and	ax,~2020h	; uppercase the letters
		cmp	ax,word [IN_WORD]
		jnz	short FORERRORJ
		lodsb

		; MSDOS 3.3
		or	al,al		; it, too, must end right away
		jz	short CHECKLPAREN
		cmp	al,[LPAREN]
		jnz	short FORERRORJ
		;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
		add	word [bx],2
		;add	word [bx+9],2
		add	word [bx+ARGV_ELE.arg_ocomptr],2
		;sub	word [bx+5],2
		sub	word [bx+ARGV_ELE.arglen],2
		mov	ax,[si-1]
		jmp	short LPCHECK

		; MSDOS 6.0
;; Compaq bug fix -- exit from this loop on error
;
;		or	al,al
;		jne	forerrorj	; jump on error
;
;;;		je	CheckLParen
;;
;; Not null.  Perhaps there are no spaces between this and the (:
;;   FOR %i in(foo bar...
;; Check for the Lparen here
;;
;;;		CMP	AL,lparen
;;;		JNZ	forerrorj
;;
;; The token was in(...	We strip off the "in" part to simulate a separator
;; being there in the first place.
;;
;;;		ADD	[BX].argpointer,2  ; advance source pointer
;;;		ADD	[BX].arg_ocomptr,2 ; advance original string
;;;		SUB	[BX].arglen,2	   ; decrement the appropriate length
;;
;; SI now points past the in(.  Simulate a nextarg call that results in the
;; current value.
;;
;;;		MOV	ax,[si-1]	; get lparen and next char
;;;		jmp	short lpcheck
;;
;; end of Compaq bug fix

; ---------------------------------------------------------------------------

		; MSDOS 3.3 (& MSDOS 6.0)
CHECKLPAREN:
		call	NEXTARG		; lparen delimits beginning of <list>
		jc	short FORERRORJ
LPCHECK:
		cmp	al,[LPAREN]
		jne	short FORERRORJ
		cmp	ah,0
		je	short FOR_PAREN_TOKEN
		cmp	ah,byte [RPAREN] ; special case:  null list	
		jne	short FOR_LIST_NOT_EMPTY
		jmp	FORTERM
FOR_LIST_NOT_EMPTY:
		;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
		inc	word [bx]	; Advance ptr past "("
		;dec	word [bx+5]	; Adjust the rest of this argv entry	
		dec	word [bx+ARGV_ELE.arglen] 	;  to agree.
		inc	si		; Inc si so check for ")" works
		jmp	short FOR_LIST

		;nop
FOR_PAREN_TOKEN:
		call	NEXTARG		; what have we in our <list>?
		jc	short FORERRORJ
		;cmp	ax,[RPAREN+1]	
		cmp	ax,[NULLRPAREN]	; special case:  null list
		jne	short FOR_LIST
		jmp	FORTERM

FORERORJJ:
		jmp	FORERROR

FOR_LIST:				; skip over rest of <list>
		mov	cx,dx		; first arg of <list>

SKIP_LIST:
		;add	si,[bx+5]
		add	si,[bx+ARGV_ELE.arglen]
		sub	si,3		; si = ptr to last char of token
		mov	al,byte [RPAREN]
		cmp	[si],al		; Is this the last element in <list>
		je	short FOR_END_LIST ; Yes, exit loop.
		call	NEXTARG		; No, get next arg <list>
		jc	short FORERORJJ	; If no more and no rparen, error.
		jmp	short SKIP_LIST

FOR_END_LIST:
		mov	di,dx		; record position of last arg in <list>
		mov	byte [si],0	; Zap the rparen
		;cmp	ax,[RPAREN+1]	
		cmp	ax,[NULLRPAREN] ; Was this token only a rparen
		je	short FOR_DO	; Yes, continue
		inc	di		; No, inc position of last arg
FOR_DO:
		call	NEXTARG		; now we had BETTER find a 'do'...
		jc	short FORERORJJ
		;and	ax,0DFDFh	
		and	ax,~2020h	; uppercase the letters
		cmp	ax,word [DO_WORD]
		jne	short FORERORJJ
		lodsb
		or	al,al		; and it had BETTER be ONLY a 'do'...
		jnz	short FORERORJJ
		
		call	NEXTARG		; on to the beginning of <command>
		jc	short FORERORJJ	; null <command> not legal

		push	ax
		push	bx
		push	cx
		push	dx		; preserve registers against disaster
		push	di
		push	si
		push	bp
		call	FREE_TPA	; need to make free memory, first
		call	FOROFF
		;mov	bx,264
		mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
		call	SAVE_ARGS	; extra bytes needed for for-info
		pushf
		mov	word [es:FORPTR],ax
		call	ALLOC_TPA	; ALLOC_TPA clobbers registers...
		popf
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jc	short FOR_ALLOC_ERR

		push	es		; save resgroup seg...
		push	word [es:FORPTR]
		pop	es
		;assume ES:for_segment	
		dec	cx		; forproc wants min pointing before
		dec	di		; first arg, max right at last one
		mov	word [es:FOR_INFO.FOR_MINARG],cx
		mov	word [es:FOR_INFO.FOR_MAXARG],di
		mov	byte [es:FOR_INFO.FOR_COM_START],dl
		mov	word [es:FOR_INFO.FOR_EXPAND],-1 ; non-zero means FALSE
		mov	ax,bp
		mov	byte [es:FOR_INFO.FOR_VAR],ah
		pop	es
		;assume ES:resgroup	
		inc	byte [es:FORFLAG]
		cmp	word [es:SINGLECOM],-1
		jne	short FOR_RET
		mov	word [es:SINGLECOM],0FF00h
FOR_RET:
		retn

FOR_ALLOC_ERR:
		; MSDOS 3.0
		mov	dx,INSFMEMMESPTR
		jmp	CERROR

		; MSDOS 6.0
		;mov	msg_disp_class,ext_msg_class	
		;			;AN000; set up extended error msg class
		;mov	dx,offset TranGroup:Extend_Buf_ptr     
		;			;AC000; get extended message pointer
		;mov	Extend_Buf_ptr,error_not_enough_memory 
		;			;AN000; get message number in control block
		;jmp	cerror


; =============== S U B	R O U T	I N E =======================================

NEXTARG:
		inc	dx		; next argv[n]
		;cmp	dx,[ARG_ARGVCNT]
		cmp	dx,[ARG+ARG_UNIT.argvcnt] ; make sure we don't run off end
		jge	short NEXTARG_ERR ; of argv[]...	
		mov	bx,dx
		;mov	ax,ARG_ARGV
		;mov	ax,ARG+ARG_UNIT.argv
		mov	ax,ARG
		call	ARGV_CALC	; convert array index to pointer
		mov	si,[bx]		; load pointer to argstring
		;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
		lodsw			; and load first two chars
		clc
		retn
NEXTARG_ERR:
		stc
		retn

; ---------------------------------------------------------------------------

FORNESTERR:
		push	ds
		mov	ds,[RESSEG]
		;ASSUME DS:RESGROUP
		mov	dx,FORNESTMESTR
		cmp	word [SINGLECOM],0FF00h
		jnz	short NOFORP3
		mov	word [SINGLECOM],-1 ; 0FFFFh ; Cause termination
NOFORP3:
		pop	ds
		jmp	CERROR

; =============== S U B	R O U T	I N E =======================================

; General routine called to free the for segment. We also clear the forflag
; too. Change no registers.

FOROFF:
		push	ax
		push	es
		mov	es,[cs:RESSEG]
		mov	ax,word [es:FORPTR]
		or	ax,ax
		jz	short FREEDONE
		push	es
		mov	es,ax
		mov	ah,DEALLOC ; 49h
		int	21h	; DOS -	2+ - FREE MEMORY
				; ES = segment address of area to be freed
		pop	es
FREEDONE:
		mov	word [es:FORPTR],0
		mov	byte [es:FORFLAG],0
		pop	es
		pop	ax
		retn

;============================================================================
; TCMD1A.ASM, MSDOS 6.0, 1991
;============================================================================
; 09/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh

; ---------------------------------------------------------------------------

; The DIR command displays the contents of a directory.
;
; ****************************************************************
; *
; * ROUTINE:	 CATALOG - display file(s) in directory
; *
; * FUNCTION:	 PARSE command line for drive, file, or path name.
; *		 DIR allows two switches, /P (pause) and /W (wide).
; *		 If an error occurs issue and error message and
; *		 transfer control to CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CATALOG:
		; MSDOS 3.3

		;mov	ax,ARG_ARGV
		;mov	ax,ARG+ARG_UNIT.argv
		mov	ax,ARG
		mov	dx,0FFFFh
		xor	cx,cx
		xor	si,si

DIR1:
		;cmp	cx,[ARG_ARGVCNT]
		cmp	cx,[ARG+ARG_UNIT.argvcnt]
		jnb	short DIR6 ; No more arguments
		mov	bx,cx
		call	ARGV_CALC
		;or	si,[bx+7]
		or	si,[bx+ARGV_ELE.argsw_word]
		test	si,7FFCh  ; test si,~8003
		jnz	short DIR2  ; /A,/B,/V switches (are invalid)
		;test	byte [bx+2],1
		test	byte [bx+ARGV_ELE.argflags],sw_flag ; 1
		jz	short DIR3
		jmp	short DIR5
DIR2:
		mov	dx,BADPARMPTR
		jmp	CERROR
DIR3:
		or	cx,cx
		jnz	short DIR4	
		;cmp	word [bx+5],3
		cmp	word [bx+ARGV_ELE.arglen],3
		jz	short DIR5
		;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
		add	word [bx],3
		;add	word [bx+9],3
		add	word [bx+ARGV_ELE.arg_ocomptr],3
		;add	word [bx+3],3
		add	word [bx+ARGV_ELE.argstartel],3
		;sub	word [bx+5],3
		sub	word [bx+ARGV_ELE.arglen],3
DIR4:
		cmp	dx,0FFFFh
		jnz	short DIR2
		mov	dx,bx

DIR5:		inc	cx
		jmp	short DIR1
DIR6:
		mov	[COMSW],si
		push	dx
		xor	al,al
		cmp	dx,0FFFFh
		jz	short DIR7
		mov	bx,dx
		;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
		mov	di,[bx]
		cmp	byte [di+1],':'
		jnz	short DIR7
		mov	al,[di]
		or	al,20h		; Lowercase drive name	
		sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
DIR7:
		;mov	[5CH],al
		mov	[FCB],al
		call	OKVOLARG
		mov	al,'?'		; *.* is default file spec.
		;mov	di,5Dh
		mov	di,FCB+1
		mov	cx,11
		rep stosb

; Begin by processing any switches that may have been specified.
; BITS will contain any information about switches that was
; found when the command line was parsed.

		mov	ax,[COMSW]	; Get switches from command
		mov	word [_BITS],ax	; initialize switches
		mov	word [COMSW],0	; initialize flags
		mov	byte [LINPERPAG],23 ; Set default for lines per page
		;test	al,1
		test	al,SWITCHW	; /W ?
		;mov	al,1
		mov	al,NORMPERLIN
		jz	short DIR8
		;mov	al,5
		mov	al,WIDEPERLIN
DIR8:
		mov	[LINLEN],al	; Set number of entries per line
		mov	[LINCNT],al
		mov	word [FILECNT],0 ; Keep track of how many files found
		mov	dx,DIRBUF
		mov	ah,SET_DMA ; 1Ah
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
		;mov	dl,[5Ch]
		mov	dl,[FCB]
		call	SAVUDIR
		pop	bx
		cmp	bx,0FFFFh
		jz	short DIR9
		;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
		mov	dx,[bx]

; The user may have specified a device. Search for the path and see if the
; attributes indicate a device.

		mov	ah,FIND_FIRST ; 4Eh
		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
				; CX = search attributes
				; DS:DX	-> ASCIZ filespec
				; (drive,path, and wildcards allowed)
		jc	short DIR10
				; Check device atrribute..
		;test	byte [DIRBUF_ATTRIB2],40h
		;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
		; 14/10/2018
		;test	byte [DIRBUF+21],40h
		test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
		jz	short DIR10	; no, go do normal operation
		mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
DIR9:
		jmp	short DOHEADER
DIR10:
		;mov	dx,[bx+ARGV_ELE.argpointer]
		mov	dx,[bx]
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		jnc	short DOHEADER
		;mov	si,[bx+3]
		mov	si,[bx+ARGV_ELE.argstartel]
		cmp	dx,si
		jz	short DIR_NO_DRIVE
		xor	cl,cl
		xchg	cl,[si]
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		xchg	cl,[si]
		jnc	short DIR_NO_DRIVE
		mov	al,[si-1]
		call	PATHCHRCMP
		jnz	short DIR11
		mov	al,[si-2]
		call	PATHCHRCMP
		jz	short DIR12
		xchg	cl,[si-1]
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		xchg	cl,[si-1]
		jnc	short DIR_NO_DRIVE
DIR11:
		mov	ch,':'
		cmp	ch,[si-1]
		jnz	short DIR12
		;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
		mov	cx,[bx]
		xchg	cx,si
		sub	cx,si
		cmp	cx,2
		jz	short DIR_NO_DRIVE
DIR12:
		mov	dx,BADCDPTR
		;test	byte [bx+2],4
		test	byte [bx+ARGV_ELE.argflags],path_sep ; 4
		jnz	short DIRERROR
DIRNF:
		mov	dx,FNOTFOUNDPTR
DIRERROR:
		jmp	CERROR
DIR_NO_DRIVE:
		cmp	word [si],'..'
		jnz	short DOREALPARSE
		cmp	byte [si+2],0
		jnz	short DOREALPARSE
		inc	word [COMSW]
		jmp	short DOHEADER
DOREALPARSE:
		mov	di,FCB ; 5Ch	
		;mov	ax,290Eh
		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|0Eh
		int	21h	; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
		cmp	byte [si],0
		jz	short DOHEADER
		dec	word [COMSW]
DOHEADER:

; Display the header

		push	bx
		call	BUILD_DIR_STRING
		mov	dx,DIRBUF
		mov	[VOL_DIR],dx
		mov	dx,DIRHEADPTR
		call	PRINTF_CRLF
		pop	bx
		cmp	bx,0FFFFh
		jz	short DOSEARCH

; If there were chars left after parse or device, then invalid file name

		cmp	word [COMSW],0
		jz	short DOSEARCH	; nothing left; good parse
		jl	short DIRNFFIX	; not .. => error file not found
		call	RESTUDIR
		mov	dx,BADCDPTR
		jmp	CERROR		; was .. => error directory not found
DIRNFFIX:
		call	RESTUDIR
		jmp	short DIRNF

; We are assured that everything is correct. Let's go and search. Use
; attributes that will include finding directories. Perform the first search
; and reset our directory afterward.

DOSEARCH:
		;mov	byte [55h],0FFh
		mov	byte [FCB-7],0FFh
		;mov	byte [5Bh],10h
		mov	byte [FCB-1],10h

; Caution! Since we are using an extended FCB, we will *also* be returning
; the directory information as an extended FCB. We must bias all fetches into
; DIRBUF by 8 (Extended FCB part + drive)

		mov	ah,DIR_SEARCH_FIRST ; 11h
		mov	dx,FCB-7 ; 55h
		int	21h	; DOS -	SEARCH FIRST USING FCB
				; DS:DX	-> FCB

; Restore the user's directory. We preserve, though, the return from the
; previous system call for later checking.

FOUND_FIRST_FILE:
		push	ax		; save return state
		call	RESTUDIR	; restore user's dir	
		pop	ax		; get return state back

; Main scanning loop. Entry has AL = Search first/next error code. Test for
; no more.

DIRSTART:
		inc	al		; 0FFh = file not found
		jnz	short DISPLAY	; Either an error or we are finished
		jmp	CHKCNT
DISPLAY:
		inc	word [FILECNT]	; Keep track of how many we find
		mov	si,DIRBUF+8	; SI -> information returned by sys call
		;call	SHONAME
		call	DISPLAYNAME
		;test	byte [_BITS],1
		test	byte [_BITS],SWITCHW ; W switch set?
		jz	short DIRTEST	; If so, no size, date, or time
		jmp	NEXENT
DIRTEST:
		;test	byte [DIRBUF_ATTRIB1],10h
		; 14/10/2018
		;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
		;test	byte [DIRBUF+19],10h
		test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
		jz	short FILEENT
		mov	dx,DMESPTR
		call	STD_PRINTF
		jmp	short NOFSIZ
FILEENT:
		;mov	dx,[DIRBUF_FSIZ_L]
		;mov	dx,[DIRBUF+36]
		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
		mov	[FILESIZE_L],dx
		;mov	dx,[DIRBUF_FSIZ_H]
		;mov	dx,[DIRBUF+38]
		mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
		mov	[FILESIZE_H],dx
		mov	dx,FSIZEMESPTR
		call	STD_PRINTF	; Print size of file
NOFSIZ:
		;mov	ax,[DIRBUF_FDATE]  ; Get date
		;mov	ax,[DIRBUF+32]
		mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
		or	ax,ax
		jz	short NEXENT	; Skip if no date
		mov	di,CHARBUF
		push	ax
		mov	ax,'  '
		stosw
		pop	ax
		mov	bx,ax
		and	ax,1Fh		; Get day
		mov	dl,al
		mov	ax,bx
		mov	cl,5
		shr	ax,cl		; Align month
		and	al,0Fh		; Get month
		mov	dh,al
		mov	cl,bh
		shr	cl,1		; Align year
		xor	ch,ch
		add	cx,80		; Relative 1980
		cmp	cl,100
		jb	short MILLENIUM
		sub	cl,100
MILLENIUM:
		call	DATE_CXDX
		;mov	cx,[DIRBUF_FTIME]
		;mov	cx,[DIRBUF+30]
		mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
		jcxz	PRBUF		; Time field present?
		mov	ax,2020h
		stosw
		shr	cx,1
		shr	cx,1
		shr	cx,1
		shr	cl,1
		shr	cl,1		; Hours in CH, minutes in CL
		mov	bl,[TIME_24]
		or	bl,80h		; Tell P_TIME called from DIR
		call	P_TIME		; Don't care about DX, never used with DIR
PRBUF:
		xor	ax,ax
		stosb
		mov	dx,CHARBUF
		mov	[STRING_PTR_2],dx
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
NEXENT:
		dec	byte [LINCNT]
		jnz	short SAMLIN
NEXLIN:
		mov	al,[LINLEN]
		mov	[LINCNT],al
		call	CRLF2
		dec	byte [LINPERPAG]
		jnz	short SCROLL
		;test	byte [_BITS],2
		test	byte [_BITS],SWITCHP ; P switch present?
		jz	short SCROLL	; If not, just continue
		mov	byte [LINPERPAG],23
		call	PAUSE
		jmp	short SCROLL
SAMLIN:
		mov	dx,TABPTR	; Output a tab
		call	STD_PRINTF
SCROLL:
		mov	ah,DIR_SEARCH_NEXT ; 12h
		;mov	dx,55h
		mov	dx,FCB-7	; DX -> Unopened FCB
		int	21h	; DOS -	SEARCH NEXT USING FCB
				; DS:DX	-> FCB
				; Return: AL = status
		jmp	DIRSTART
CHKCNT:
		test	word [FILECNT],0FFFFh ; -1
		jnz	short TRAILER
		jmp	DIRNF
TRAILER:
		mov	al,[LINLEN]
		cmp	al,[LINCNT]
		jz	short MMESSAGE
		call	CRLF2
MMESSAGE:
		mov	dx,DIRMESPTR
		mov	si,[FILECNT]
		mov	[DIR_NUM],si
		call	STD_PRINTF
DTFREE:
		mov	ah,GET_DRIVE_FREESPACE ; 36h
		;mov	dl,[5Ch]
		mov	dl,[FCB]
		int	21h	; DOS -	2+ - GET DISK SPACE
				; DL = drive code (0 = default,	1 = A,2 = B,etc.)
		cmp	ax,-1
		jnz	short DTFREE1
DTRET:
		retn
DTFREE1:
		mul	cx
		mul	bx
		mov	[BYTES_FREE],ax
		mov	[BYTES_FREE+2],dx
		mov	dx,BYTEMESPTR
		jmp	STD_PRINTF


	; MSDOS 6.0
;CATALOG:

;;
;; Set up DTA for dir search firsts
;;
;	mov	dx,offset trangroup:Dirbuf	;AC000; Set Disk transfer address
;	mov	ah,Set_DMA			;AC000;
;	int	int_command			;AC000;
;;
;; Set up defaults for switches and parse the command line.
;;
;	mov	msg_numb,0			;AN022; initialize message flag
;	mov	di,offset trangroup:srcbuf	;AN000; get address of srcbuf
;	mov	[pathpos],di			;AN000; this is start of path
;	mov	[pathcnt],1			;AN000; initialize length to 1 char
;	mov	al,star 			;AN000; initialize srcbuf to *,0d
;	stosb					;AN000;
;	mov	al,end_of_line_in		;AN000;
;	stosb					;AN000;
;	mov	si,81H				;AN000; Get command line
;	mov	di,offset trangroup:parse_dir	;AN000; Get adderss of PARSE_DIR
;	xor	cx,cx				;AC000; clear counter for positionals
;	mov	ComSw,cx			;AC000; initialize flags
;	mov	bits,cx 			;AC000; initialize switches
;	mov	linperpag,linesperpage		;AC000; Set default for lines per page
;	mov	linlen,normperlin		;AC000; Set number of entries per line
;	mov	lincnt,normperlin		;AC000;
;
;dirscan:
;	xor	dx,dx				;AN000;
;	invoke	parse_with_msg			;AC018; call parser
;	cmp	ax,end_of_line			;AN000; are we at end of line?
;	jne	dirscan_cont			;AN000; No - continue parsing
;	jmp	scandone			;AN000; yes - go process
;
;dirscan_cont:
;	cmp	ax,result_no_error		;AN000; did we have an error?
;	jz	dirscan_cont2			;AN000; No - continue parsing
;	jmp	badparm 			;AN000; yes - exit
;
;dirscan_cont2:
;	cmp	parse1_syn,offset trangroup:dir_w_syn ;AN000; was /W entered?
;	je	set_dir_width			;AN000; yes - go set wide lines
;	cmp	parse1_syn,offset trangroup:slash_p_syn ;AN000; was /P entered?
;	je	set_dir_pause			;AN000; yes - go set pause at end of screen
;;
;; Must be filespec since no other matches occurred. Move filename to srcbuf
;;
;	push	si				;AC000; save position in line
;	lds	si,parse1_addr			;AC000; get address of filespec
;	push	si				;AN000; save address
;	invoke	move_to_srcbuf			;AC000; move to srcbuf
;	pop	dx				;AC000; get address in DX
;
;;
;; The user may have specified a device. Search for the path and see if the
;; attributes indicate a device.
;;
;	mov	ah,Find_First			;AC000; find the file
;	int	int_command			;AC000;
;	jnc	Dir_check_device		;AN022; if no error - check device
;	invoke	get_ext_error_number		;AN022; get the extended error
;	cmp	ax,error_no_more_files		;AN022; was error no file found
;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
;	cmp	ax,error_path_not_found 	;AN022; was error no file found
;	jz	Dir_fspec_end			;AC022; yes -> obviously not a device
;	jmp	dir_err_setup			;AN022; otherwise - go issue error message
;
;dir_check_device:				;AN022;
;	test	byte ptr (DirBuf+find_buf_attr),ATTR_DEVICE ;AC000;
;	jz	Dir_fspec_end			;AC000; no, go do normal operation
;	mov	ComSw,-2			;AC000; signal device
;
;dir_fspec_end:
;	pop	si				;AC000; restore position in line
;	jmp	short dirscan			;AC000; keep parsing
;
;set_dir_width:
;	test	byte ptr[bits],SwitchW		;AN018; /W already set?
;	jz	ok_set_width			;AN018; no - okay to set width
;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
;	invoke	setup_parse_error_msg		;AN018; set up an error message
;	jmp	badparm 			;AN018; exit
;
;ok_set_width:
;	or	bits,switchw			;AC000; indicate /w was selected
;	mov	linlen,wideperlin		;AC000; Set number of entries per line
;	mov	lincnt,wideperlin		;AC000;
;	jmp	short dirscan			;AC000; keep parsing
;
;set_dir_pause:
;	test	byte ptr[bits],SwitchP		;AN018; /p already set?
;	jz	ok_set_pause			;AN018; no - okay to set width
;	mov	ax,moreargs_ptr 		;AN018; set up too many arguments
;	invoke	setup_parse_error_msg		;AN018; set up an error message
;	jmp	badparm 			;AN018; exit
;
;ok_set_pause:
;	or	bits,switchp			;AC000; indicate /p was selected
;	push	cx				;AN000; save necessary registers
;	push	si				;AN000;
;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ;AN000; get lines per page on display
;	mov	bx,stdout			;AN000; lines for stdout
;	mov	ch,ioc_sc			;AN000; type is display
;	mov	cl,get_generic			;AN000; get information
;	mov	dx,offset trangroup:display_ioctl ;AN000;
;	int	int_command			;AN000;
;
;lines_set:
;	dec	linperpag			;AN000; lines per actual page should
;	dec	linperpag			;AN000;     two less than the max
;	mov	ax,linperpag			;AN000; get number of lines into
;	mov	[fullscr],ax			;AC000;    screen line counter
;	pop	si				;AN000; restore registers
;	pop	cx				;AN000;
;	jmp	dirscan 			;AC000; keep parsing
;
;;
;; The syntax is incorrect. Report only message we can.
;;
;BadParm:
;	jmp	cerror				;AC000; invalid switches get displayed
;
;ScanDone:
;
;;
;; Find and display the volume ID on the drive.
;;
;
;	invoke	okvolarg			;AC000;
;;
;; OkVolArg also disables APPEND, which will be re-enabled
;; in the HeadFix routine, after we're done.
;;
;	mov	[filecnt],0			;AC000; Keep track of how many files found
;	cmp	comsw,0 			;AC000; did an error occur?
;	jnz	doheader			;AC000; yes - don't bother to fix path
;
;	mov	dirflag,-1			;AN015; set pathcrunch called from DIR
;	invoke	pathcrunch			;AC000; set up FCB for dir
;	mov	dirflag,0			;AN015; reset dirflag
;	jc	DirCheckPath			;AC015; no CHDIRs worked.
;	jz	doheader			;AC015; chdirs worked - path\*.*
;	mov	si,[desttail]			;AN015; get filename back
;	jmp	short DoRealParse		;AN015; go parse it
;
;DirCheckPath:
;	mov	ax,[msg_numb]			;AN022; get message number
;	cmp	ax,0				;AN022; Is there a message?
;	jnz	dir_err_setup			;AN022; yes - there's an error
;	cmp	[destisdir],0			;AC000; Were pathchars found?
;	jz	doparse 			;AC000; no - no problem
;	inc	comsw				;AC000; indicate error
;	jmp	short doheader			;AC000; go print header
;
;DirNF:
;	mov	ax,error_file_not_found 	;AN022; get message number in control block
;
;dir_err_setup:
;	mov	msg_disp_class,ext_msg_class	;AN000; set up extended error msg class
;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC000; get extended message pointer
;	mov	extend_buf_ptr,ax		;AN022;
;
;DirError:
;	jmp	Cerror
;
;;
;; We have changed to something. We also have a file. Parse it into a
;; reasonable form, leaving drive alone, leaving extention alone and leaving
;; filename alone. We need to special case ... If we are at the root, the
;; parse will fail and it will give us a file not found instead of file not
;; found.
;;
;DoParse:
;	mov	si,offset trangroup:srcbuf	;AN000; Get address of source
;	cmp	byte ptr [si+1],colon_char	;AN000; Is there a drive?
;	jnz	dir_no_drive			;AN000; no - keep going
;	lodsw					;AN000; bypass drive
;
;dir_no_drive:
;	cmp	[si],".."
;	jnz	DoRealParse
;	cmp	byte ptr [si+2],0
;	jnz	DoRealParse
;	inc	ComSw
;	jmp	short DoHeader
;
;DoRealParse:
;	mov	di,FCB			; where to put the file name
;	mov	ax,(Parse_File_Descriptor SHL 8) OR 0EH
;	int	int_command
;
;;
;; Check to see if APPEND installed. If it is installed, set all flags
;; off.	This will be reset in the HEADFIX routine
;;
;
;DoHeader:
;; ORIGINAL APPEND CHECK CODE LOCATION ******************************
;
;;
;; Display the header
;;
;
;DoHeaderCont:
;	mov	al,blank			;AN051; Print out a blank
;	invoke	print_char			;AN051;   before DIR header
;	invoke	build_dir_string		; get current dir string
;	mov	dx,offset trangroup:Dirhead_ptr
;	invoke	printf_crlf			; bang!
;
;;
;; If there were chars left after parse or device, then invalid file name
;;
;	cmp	ComSw,0
;	jz	DoSearch			; nothing left; good parse
;	jl	DirNFFix			; not .. => error file not found
;	invoke	RestUDir
;	mov	dx,offset TranGroup:BadCD_ptr
;	jmp	Cerror				; was .. => error directory not found
;DirNFFix:
;	invoke	RestUDir
;	jmp	DirNF
;;
;; We are assured that everything is correct.  Let's go and search.  Use
;; attributes that will include finding directories.  perform the first search
;; and reset our directory afterward.
;;
;DoSearch:
;	mov	byte ptr DS:[FCB-7],0FFH
;	mov	byte ptr DS:[FCB-1],010H
;;
;; Caution!  Since we are using an extended FCB, we will *also* be returning
;; the directory information as an extended FCB. We must bias all fetches into
;; DIRBUF by 8 (Extended FCB part + drive)
;;
;	mov	ah,Dir_Search_First
;	mov	dx,FCB-7
;	int	int_command
;
;	push	ax				;AN022; save return state
;	inc	al				;AN022; did an error occur?
;	pop	ax				;AN022; get return state back
;	jnz	found_first_file		;AN022; no error - start dir
;	invoke	set_ext_error_msg		;AN022; yes - set up error message
;	push	dx				;AN022; save message
;	invoke	restudir			;AN022; restore user's dir
;	pop	dx				;AN022; restore message
;	cmp	word ptr Extend_Buf_Ptr,Error_No_More_Files ;AN022; convert no more files to
;	jnz	DirCerrorJ			;AN022; 	file not found
;	mov	Extend_Buf_Ptr,Error_File_Not_Found  ;AN022;
;
;DirCerrorJ:					;AN022;
;	jmp	Cerror				;AN022; exit
;
;;
;; Restore the user's directory.  We preserve, though, the return from the
;; previous system call for later checking.
;;
;
;found_first_file:
;	push	ax
;	invoke	restudir
;	pop	ax
;;
;; Main scanning loop. Entry has AL = Search first/next error code. Test for
;; no more.
;;
;DIRSTART:
;	inc	al				; FF = file not found
;	jnz	Display
;	jmp	DirDone 			; Either an error or we are finished
;;
;; Note that we've seen a file and display the found file.
;;
;
;Display:
;	inc	[filecnt]			; Keep track of how many we find
;	mov	si,offset trangroup:dirbuf+8	; SI -> information returned by sys call
;	call	shoname
;;
;; If we are displaying in wide mode, do not output the file info
;;
;	test	byte ptr[bits],SwitchW		; W switch set?
;	jz	DirTest
;	jmp	nexent				; If so, no size, date, or time
;
;;
;; Test for directory.
;;
;DirTest:
;	test	[dirbuf+8].dir_attr,attr_directory
;	jz	fileent
;;
;; We have a directory.	Display the <DIR> field in place of the file size
;;
;	mov	dx,offset trangroup:Dmes_ptr
;	call	std_printf
;	jmp	short nofsiz
;;
;; We have a file.  Display the file size
;;
;fileent:
;	mov	dx,[DirBuf+8].dir_size_l
;	mov	file_size_low,dx
;	mov	dx,[DirBuf+8].dir_size_h
;	mov	file_size_high,dx
;	mov	dx,offset trangroup:disp_file_size_ptr
;	call	std_printf
;;
;; Display time and date of last modification
;;
;nofsiz:
;	mov	ax,[DirBuf+8].dir_date		; Get date
;;
;; If the date is 0, then we have found a 1.x level diskette.  We skip the
;; date/time fields as 1.x did not have them.
;;
;	or	ax,ax
;	jz	nexent				; Skip if no date
;	mov	bx,ax
;	and	ax,1FH				; get day
;	mov	dl,al
;	mov	ax,bx
;	mov	cl,5
;	shr	ax,cl				; Align month
;	and	al,0FH				; Get month
;	mov	dh,al
;	mov	cl,bh
;	shr	cl,1				; Align year
;	xor	ch,ch
;	add	cx,80				; Relative 1980
;	cmp	cl,100
;	jb	millenium
;	sub	cl,100
;
;millenium:
;	xchg	dh,dl				;AN000; switch month & day
;	mov	DirDat_yr,cx			;AC000; put year into message control block
;	mov	DirDat_mo_day,dx		;AC000; put month and day into message control block
;	mov	cx,[DirBuf+8].dir_time		; Get time
;	jcxz	prbuf				; Time field present?
;	shr	cx,1
;	shr	cx,1
;	shr	cx,1
;	shr	cl,1
;	shr	cl,1				; Hours in CH, minutes in CL
;	xchg	ch,cl				;AN000; switch hours & minutes
;	mov	DirTim_hr_min,cx		;AC000; put hours and minutes into message subst block
;
;prbuf:
;	mov	dx,offset trangroup:DirDatTim_ptr
;	call	std_printf
;	invoke	crlf2				;AC066;end the line
;	dec	byte ptr [fullscr]		;AC066;count the line
;	jnz	endif04 			;AN066;IF the last on the screen THEN
;	   call    check_for_P			;AN066;   pause if /P requested
;	endif04:				;AN066;
;	jmp	scroll				; If not, just continue
;;AD061; mov	DirDat_yr,0			;AC000; reset year, month and day
;;AD061; mov	DirDat_mo_day,0 		;AC000;     in control block
;;AD061; mov	DirTim_hr_min,0 		;AC000; reset hour & minute in control block
;;
;; We are done displaying an entry.  The code between "noexent:" and "scroll:"
;; is only for /W case.
;;
;nexent:
;	mov	bl,[lincnt]			;AN066;save for check for first entry on line
;	dec	[lincnt]			      ;count this entry on the line
;	jnz	else01				;AX066;IF last entry on line THEN
;	   mov	   al,[linlen]
;	   mov	   [lincnt],al
;	   invoke  crlf2
;	   cmp	   [fullscr],0			;AC066;IF have filled the screen THEN
;	   jnz	   endif02			;AN066;
;	      call    check_for_P		;AN066;   reinitialize fullscr,
;	   endif02:				;AN066;   IF P requested THEN pause
;	   jmp	   short endif01		;AN066;
;	else01: 				;AN066;ELSE since screen not full
;	   cmp	   bl,[linlen]			;AN066;   IF starting new line THEN
;	   jne	   endif03			;	     count the line
;	      dec     byte ptr [fullscr]	;AN066;   ENDIF
;	   endif03:				;AC066;We are outputting on the same line, between fields, we tab.
;	   mov	   dx,offset trangroup:tab_ptr	;Output a tab
;	   call    std_printf
;	endif01:				;AX066;
;;
;; All we need to do now is to get the next directory entry.
;;
;scroll:
;	mov	ah,Dir_Search_Next
;	mov	dx,FCB-7			; DX -> Unopened FCB
;	int	int_command			; Search for a file to match FCB
;	jmp	DirStart
;;
;; If no files have been found, display a not-found message
;;
;DirDone:
;	invoke	get_ext_error_number		;AN022; get the extended error number
;	cmp	ax,error_no_more_files		;AN022; was error file not found?
;	jnz	dir_err_setup_jmp		;AN022; no - setup error message
;	test	[filecnt],-1
;	jnz	Trailer
;	mov	ax,error_file_not_found 	;AN022;
;
;dir_err_setup_jmp:				;AN022;
;	jmp	dir_err_setup			;AN022; go setup error msg & print it
;;
;; If we have printed the maximum number of files per line, terminate it with
;; CRLF.
;;
;Trailer:
;	mov	al,[linlen]
;	cmp	al,[lincnt]			; Will be equal if just had CR/LF
;	jz	mmessage
;	invoke	crlf2
;	cmp	[fullscr],0			;AN066;IF on last line of screen THEN
;	jnz	endif06 			;AN066;   pause before going on
;	   call    check_for_P			;AN066;   to number and freespace
;	endif06:				;AN066;   displays
;
;mmessage:
;	mov	dx,offset trangroup:Dirmes_ptr
;	mov	si,[filecnt]
;	mov	dir_num,si
;	call	std_printf
;	mov	ah,Get_Drive_Freespace
;	mov	dl,byte ptr DS:[FCB]
;	int	int_command
;	cmp	ax,-1
;	retz
;	mul	cx				; AX is bytes per cluster
;	mul	bx
;	mov	bytes_free,ax			;AC000;
;	mov	bytes_free+2,dx 		;AC000;
;	MOV	DX,OFFSET TRANGROUP:BYTMES_ptr
;	jmp	std_printf
;
;shoname:
;	mov	di,offset trangroup:charbuf
;	mov	cx,8
;	rep	movsb
;	mov	al,' '
;	stosb
;	mov	cx,3
;	rep	movsb
;	xor	ax,ax
;	stosb
;	push	dx
;	mov	dx,offset trangroup:charbuf
;	mov	string_ptr_2,dx
;	mov	dx,offset trangroup:string_buf_ptr
;	call	std_printf
;	pop	DX
;	return
;
;check_for_P    PROC  NEAR		;AN066;
;
;	test	byte ptr[bits],SwitchP	;P switch present?
;	jz	endif05 		;AN066;
; 	 mov	   ax,linperpag 	;AN000;  transfer lines per page
; 	 mov	   [fullscr],ax 	;AC000;	to fullscr
;   	invoke  Pause
;endif05:
;	ret				;AN066;
;
;check_for_P    ENDP			;AN066;

; =============== S U B	R O U T	I N E =======================================

SHONAME:
DISPLAYNAME:
		; MSDOS 3.3
		mov	di,CHARBUF
		mov	cx,8
		rep movsb
		mov	al,' '
		stosb
		mov	cx,3
		rep movsb
		xor	ax,ax
		stosb
		push	dx
		mov	dx,CHARBUF
		mov	[STRING_PTR_2],dx
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
		pop	dx
		retn

;============================================================================
; TCMD1B.ASM, MSDOS 6.0, 1991
;============================================================================
; 09/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h


; =============== S U B	R O U T	I N E =======================================

PAUSE:
		mov	dx,PAUSEMESPTR
		call	STD_PRINTF
		call	GETKEYSTROKE
		call	CRLF2
		retn

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	DEL/ERASE - erase file(s)
;*
;* FUNCTION:	PARSE command line for file or path name and /P
;*		and invoke PATHCRUNCH.	If an error occurs, set
;*		up an error message and transfer control to CERROR.
;*		Otherwise, transfer control to NOTEST2 if /P not
;*		entered or SLASHP_ERASE if /P entered.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	if no error:
;*		FCB at 5ch set up with filename(s) entered
;*		Current directory set to entered directory
;*
;****************************************************************

ERASE:
		; MSDOS 6.0

;assume	ds:trangroup,es:trangroup

;		mov	si,81H		;AC000; get command line
;		mov	comsw,0 	;AN000; clear switch indicator
;		mov	di,offset trangroup:parse_erase
;					;AN000; Get adderss of PARSE_erase
;		xor	cx,cx		;AN000; clear cx,dx
;
;erase_scan:
;		xor	dx,dx		;AN000;
;		invoke	parse_with_msg	;AC018; call parser
;		cmp	ax,end_of_line	;AN000; are we at end of line?
;		jz	good_line	;AN000; yes - done parsing
;		cmp	ax,result_no_error ;AC000; did we have an error?
;		jnz	errj2		;AC000; yes exit
;
;		cmp	parse1_syn,offset trangroup:slash_p_syn 
;					;AN000; was /P entered?
;		je	set_erase_prompt ;AN000; yes - go set prompt
;
;;
;; Must be filespec since no other matches occurred. move filename to srcbuf
;;
;		push	si		;AC000; save position in line
;		lds	si,parse1_addr	;AC000; get address of filespec
;		cmp	byte ptr[si+1],colon_char ;AC000; drive specified?
;		jnz	Erase_drive_ok	;AC000; no - continue
;		cmp	byte ptr[si+2],end_of_line_out	
;					;AC000; was only drive entered?
;		jnz	erase_drive_ok	;AC000; no - continue
;		mov	ax,error_file_not_found 
;					;AN022; get message number in control block
;		jmp	short extend_setup ;AC000; exit
;
;erase_drive_ok:
;		invoke	move_to_srcbuf	;AC000; move to srcbuf
;		pop	si		;AC000; get position back
;		jmp	short erase_scan ;AN000; continue parsing
;
;set_erase_prompt:
;		cmp	comsw,0 	;AN018; was /P already entered?
;		jz	ok_to_set_erase_prompt ;AN018; no go set switch
;		mov	ax,moreargs_ptr ;AN018; set up too many arguments
;		invoke	setup_parse_error_msg ;AN018; set up an error message
;		jmp	short errj2	;AN018; exit
;
;ok_to_set_erase_prompt: 		;AN018;
;		inc	comsw		;AN000; indicate /p specified
;		jmp	short erase_scan ;AN000; continue parsing
;
;good_line:				;G  We know line is good
;		invoke	pathcrunch
;		jnc	checkdr
;		mov	ax,[msg_numb]	;AN022; get message number
;		cmp	ax,0		;AN022; was message flag set?
;		jnz	extend_setup	;AN022; yes - print out message
;		cmp	[destisdir],0	; No CHDIRs worked
;		jnz	badpath_err	;AC022; see if they should have
;
;checkdr:
;		cmp	comsw,0 	;AN000; was /p specified
;		jz	notest2j	;AN000; no - go to notest2
;		jmp	slashp_erase	;AN000; yes - go to slashp_erase
;
;notest2j:
;		jmp	notest2
;
;badpath_err:				;AN022; "Path not found" message
;		mov	ax,error_path_not_found ;AN022; set up error number
;
;extend_setup:				;AN022;
;		mov	msg_disp_class,ext_msg_class
;					;AN022; set up extended error msg class
;		mov	dx,offset TranGroup:Extend_Buf_ptr
;					;AC022; get extended message pointer
;		mov	Extend_Buf_ptr,ax
;					;AN022; get message number in control block
;errj2:					;AC022; exit jump
;		jmp	Cerror		;AN022;

		; MSDOS 3.3
		mov	dx,BADARGSPTR
		mov	si,80h
		lodsb
		or	al,al
		jz	short ERRJ2
		call	SCANOFF
		cmp	al,0Dh		; Return key
		jz	short ERRJ2	; If so no parameters specified
		push	dx
		push	si
		mov	dx,FNOTFOUNDPTR
ERASE_SCAN:
		lodsb
		call	DELIM
		jz	short ERASE_CHKDELIMCHR
		cmp	al,0Dh
		jz	short GOOD_LINE
		jmp	short ERASE_SCAN
ERASE_CHKDELIMCHR:
		cmp	al,20h
		jg	short ERRJ2
		lodsb
		call	DELIM
		jz	short ERASE_CHKDELIMCHR
		cmp	al,0Dh
		jz	short GOOD_LINE
		mov	dx,BADARGSPTR
		jmp	short ERRJ2
GOOD_LINE:
		pop	si
		pop	dx
		push	si
		call	PATHCRUNCH
		jnc	short CHECKDR
		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
		jz	short CHECKDR	   ; see if they should have
BADCDERR:
		pop	si
		mov	dx,BADCDPTR
ERRJ2:
		jmp	CERROR
CHECKDR:
		mov	dx,FNOTFOUNDPTR
		pop	cx
		mov	al,' '
		;cmp	[5Dh],al
		cmp	[FCB+1],al
		jz	short ERRJ2
		add	cx,3
		cmp	si,cx
		jnz	short NOTEST2J
		mov	al,':'
		cmp	[si-2],al
		jz	short ERRJ2
NOTEST2J:
		jmp	NOTEST2

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 CRENAME - rename file(s)
; *
; * FUNCTION:	 PARSE command line for one full filespec and one
; *		 filename.  Invoke PATHCRUNCH on the full filespec.
; *		 Make sure the second filespec only contains a
; *		 filename.  If both openands are valid, attempt
; *		 to rename the file.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CRENAME:
		; MSDOS 6.0
		;assume	ds:trangroup,es:trangroup
;
;		mov	si,81H		;AC000; Point to command line
;		mov	di,offset trangroup:parse_rename
;					;AN000; Get adderss of PARSE_RENAME
;		xor	cx,cx		;AN000; clear cx,dx
;		xor	dx,dx		;AN000;
;		invoke	parse_with_msg	;AC018; call parser
;		cmp	ax,result_no_error ;AC000; did we have an error?
;;		jz	crename_no_parse_error ;AC000; no - continue
;		jnz	crename_parse_error ;AC000; Yes, fail. (need long jump)
;;
;;  Get first file name returned from parse into our buffer
;;
;crename_no_parse_error:
;		push	si		;AN000; save position in line
;		lds	si,parse1_addr	;AN000; get address of filespec
;		invoke	move_to_srcbuf	;AN000; move to srcbuf
;		pop	si		;AN000; restore position in line
;
;		xor	dx,dx		;AN000; clear dx
;		invoke	parse_with_msg	;AC018; call parser
;		cmp	ax,result_no_error ;AN000; did we have an error?
;		JNZ	crename_parse_error ;AN000; Yes, fail.
;;
;;  Check the second file name for drive letter colon
;;
;		push	si		;AN000; save position in line
;		lds	si,parse1_addr	;AC000; get address of path
;
;		mov	al,':'		;AC000;
;		cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
;		jnz	ren_no_drive	;AN000; Yes, error
;		mov	msg_disp_class,parse_msg_class
;					;AN000; set up parse error msg class
;		mov	dx,offset TranGroup:Extend_Buf_ptr
;					;AC000; get extended message pointer
;		mov	Extend_Buf_ptr,BadParm_ptr
;					;AN000; get "Invalid parameter" message number
;		pop	si		;AN000;
;crename_parse_error:			;AC022;
;		jmp	short errj	;AC000;
;
;;  Get second file name returned from parse into the fCB. Save
;;  character after file name so we can later check to make sure it
;;  isn't a path character.
;
;
;ren_no_drive:
;		mov	di,FCB+10H	;AC000; set up to parse second file name
;		mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
;		int	21h		;AC000; do the function
;		lodsb			;AC000; Load char after filename
;		mov	one_char_val,al ;AN000; save char after filename
;		pop	si		;AN000; get line position back
;
;;
;; We have source and target.  See if any args beyond.
;;
;
;		mov	di,offset trangroup:parse_rename
;					;AC000; get address of parse_rename
;		invoke	parse_check_eol ;AC000; are we at end of line?
;		jnz	crename_parse_error ;AN000; no, fail.
;
;		invoke	pathcrunch
;		mov	dx,offset trangroup:badcpmes_ptr
;		jz	errj2		; If 1st parm a dir, print error msg
;		jnc	notest3
;		mov	ax,[msg_numb]	;AN022; get message number
;		cmp	ax,0		;AN022; was message flag set?
;		jnz	extend_setup	;AN022; yes - print out message
;		cmp	[destisdir],0	; No CHDIRs worked
;		jz	notest3 	; see if they should have
;		Jmp	badpath_err	;AC022; set up error
;
;notest3:
;		mov	al,one_char_val ;AN000; move char into AX
;		mov	dx,offset trangroup:inornot_ptr 
;					; Load invalid fname error ptr
;		invoke	pathchrcmp	; Is the char in al a path sep?
;		jz	errj		; Yes, error - 2nd arg must be
;					;  filename only.
;		mov	ah,FCB_Rename
;		mov	dx,FCB
;		int	21h
;		cmp	al, 0FFH	; Did an error occur??
;		jnz	renameok
;
;		invoke	get_ext_error_number ;AN022; get extended error
;		SaveReg <AX>		;AC022; Save results
;		mov	al, 0FFH	; Restore original error state
;
;renameok:
;		push	ax
;		invoke	restudir
;		pop	ax
;		inc	al
;		retnz
;
;		RestoreReg  <AX>	;AC022; get the error number back
;		cmp	ax,error_file_not_found 
;					;AN022; error file not found?
;		jz	use_renerr	;AN022; yes - use generic error message
;		cmp	ax,error_access_denied
;					;AN022; error file not found?
;		jz	use_renerr	;AN022; yes - use generic error message
;		jmp	extend_setup	;AN022; need long jump - use extended error
;
;use_renerr:
;		mov	dx,offset trangroup:RenErr_ptr	;AC022;
;ERRJ:
;		jmp	Cerror
;
;ret56:		ret

		; MSDOS 3.3
		mov	dx,BADARGSPTR
		call	SCANOFF
		cmp	al,0Dh
		jz	short ERRJ2
		call	PATHCRUNCH
		mov	dx,BADCPMESPTR
		jz	short ERRJ2
		jnb	short CRENAME_NO_PARSE_ERROR
		cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
		jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
		jmp	short BADCDERR

;  Get first file name returned from parse into our buffer

CRENAME_NO_PARSE_ERROR:
		mov	si,[PATHPOS]
		call	SCANOFF
		cmp	al,0Dh
		mov	dx,BADARGSPTR
		jz	short ERRJ
		mov	al,':'
		mov	dx,BADPARMPTR
		cmp	[si+1],al
		jz	short ERRJ

;  Get second file name returned from parse into the FCB. Save
;  character after file name so we can later check to make sure it
;  isn't a path character.

REN_NO_DRIVE:
		;mov	di,6Ch
		mov	di,FCB+10h
		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|01h ; 2901h
		int	21h	; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
		mov	al,' '
		;cmp	[6Dh],al
		cmp	[FCB+10h+1],al	; Check if parameter exists
		jz	short ERRJ	; Error if missing parameter
		lodsb
		mov	dx,INORNOTPTR
		call	PATHCHRCMP
		jz	short ERRJ
		mov	ah,FCB_RENAME ; 17h
		mov	dx,FCB ; 5Ch
		int	21h	; DOS -	RENAME FILE via	FCB
				; DS:DX	-> FCB
				; FCB contains new name	starting at byte 17h.
		cmp	al,0FFh		; Did an error occur??	
		jnz	short RENAMEOK
		stc
		mov	dx,RENERRPTR
		call	GET_EXT_ERR_NUMBER ; get extended error
		push	dx
		mov	al,0FFh		; Restore original error state
RENAMEOK:
		push	ax
		call	RESTUDIR
		pop	ax
		inc	al
		jz	short RENAME_ERR
RENAME_RETN:
TYPELP_RET:
		retn
RENAME_ERR:
		pop	dx
ERRJ:					; Retro DOS v3.0
		call	STD_EPRINTF
		jmp	TCOMMAND

; ---------------------------------------------------------------------------

;ERRJ:
;		jmp	CERROR

; ---------------------------------------------------------------------------

;TYPELP_RET:
;		retn

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	TYPEFIL - Display the contents of a file to the
;*		standard output device
;*
;* SYNTAX:	TYPE filespec
;*
;* FUNCTION:	If a valid filespec is found, read the file until
;*		1Ah and display the contents to STDOUT.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

TYPEFIL:
		; MSDOS 6.0	
		;assume	ds:trangroup,es:trangroup

;		mov	si,81H
;		mov	di,offset trangroup:parse_mrdir 
;					;AN000; Get adderss of PARSE_MRDIR
;		xor	cx,cx		;AN000; clear cx,dx
;		xor	dx,dx		;AN000;
;		invoke	parse_with_msg	;AC018; call parser
;		cmp	ax,result_no_error ;AC000; did we have an error?
;		jnz	typefil_parse_error ;AN000; yes - issue error message
;
;		push	si		;AC000; save position in line
;		lds	si,parse1_addr	;AC000; get address of filespec
;		invoke	move_to_srcbuf	;AC000; move to srcbuf
;		pop	si		;AC000; get position back
;		mov	di,offset trangroup:parse_mrdir 
;					;AC000; get address of parse_mrdir
;		invoke	parse_check_eol ;AC000; are we at end of line?
;		jz	gottarg 	;AC000; yes - continue
;
;typefil_parse_error:			;AN000; no - set up error message and exit
;		jmp	Cerror
;
;gottarg:
;		invoke	setpath
;		test	[destinfo],00000010b ; Does the filespec contain wildcards
;		jz	nowilds 	; No, continue processing
;		mov	dx,offset trangroup:inornot_ptr ; Yes, report error
;		jmp	Cerror
;nowilds:
;		mov	ax,ExtOpen SHL 8 ;AC000; open the file
;		mov	bx,read_open_mode ;AN000; get open mode for TYPE
;		xor	cx,cx		;AN000; no special files
;		mov	dx,read_open_flag ;AN000; set up open flags
;		mov	si,offset trangroup:srcbuf ;AN030; get file name
;		int	21h
;		jnc	typecont	; If open worked, continue. Otherwise load
;
;Typerr: 				;AN022;
;		push	cs		;AN022; make sure we have local segment
;		pop	ds		;AN022;
;		invoke	set_ext_error_msg ;AN022;
;		mov	string_ptr_2,offset trangroup:srcbuf 
;					;AC022; get address of failed string
;		mov	Extend_buf_sub,one_subst
;					;AC022; put number of subst in control block
;		jmp	cerror		;AC022; exit
;
;typecont:
;		mov	bx,ax		;AC000; get  Handle
;;M043
;; We should do the LSEEK for filesize only if this handle belongs to a file
;;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
;;indicate it is a device.
;;
;		mov	ax,(IOCTL shl 8) or 0
;		int	21h
;
;		test	dl,80h		;is it a device?
;		jz	not_device	;no, a file
;
;		mov	word ptr TypeFilSiz+2,-1 ;indicate it is a device
;		jmp	short dotype
;not_device:
;
;;SR;
;; Find the filesize by seeking to the end and then reset file pointer to
;;start of file
;;
;		mov	ax,(LSEEK shl 8) or 2
;		xor	dx,dx
;		mov	cx,dx		;seek  to end of file
;		int	21h
;
;		mov	word ptr TypeFilSiz,ax
;		mov	word ptr TypeFilSiz+2,dx ;store filesize
;
;		mov	ax,(LSEEK shl 8) or 0
;		xor	dx,dx
;		int	21h	        ;reset file pointer to start
;dotype:					;M043
;		mov	zflag,0 	; Reset ^Z flag
;		mov	ds,[TPA]
;		xor	dx,dx
;		;ASSUME	DS:NOTHING
;
;typelp:
;		cmp	cs:[zflag],0	;AC050; Is the ^Z flag set?
;		retnz			; Yes, return
;		mov	cx,cs:[bytcnt]	;AC056; No, continue
;;
;;Update the filesize left to read
;;
;		cmp	word ptr cs:TypeFilSiz+2,-1 ;is it a device? M043
;		je	typ_read	;yes, just read from it; M043
;
;		cmp	word ptr cs:TypeFilSiz+2,0 ;more than 64K left?
;		jz	lt64k		;no, do word subtraction
;		sub	word ptr cs:TypeFilSiz,cx
;		sbb	word ptr cs:TypeFilSiz+2,0 ;update filesize
;      		jmp	short typ_read	;do the read
;lt64k:
;		cmp	cx,word ptr cs:TypeFilSiz ;readsize <= buffer?
;		jbe	gtbuf		; yes, just update readsize
;;
;;Buffer size is larger than bytes to read
;;
;		mov	cx,word ptr cs:TypeFilSiz
;		jcxz	typelp_ret
;		mov	word ptr cs:TypeFilSiz,0
;		jmp	short typ_read
;gtbuf:
;		sub	word ptr cs:TypeFilSiz,cx ;update filesize remaining
;typ_read:
;		mov	ah,read
;		int	21h		
;		jnc	@f		;M043
;		jmp	typerr		;M043
;@@:					;M043
;;M043;		jc	typerr		;AN022; Exit if error
;
;		mov	cx,ax
;		jcxz	typelp_ret	;AC000; exit if nothing read
;		push	ds
;		pop	es		; Check to see if a ^Z was read.
;		;assume es:nothing
;		xor	di,di
;		push	ax
;		mov	al,1ah
;		repnz	scasb
;		pop	ax
;		xchg	ax,cx
;		cmp	ax,0
;		jnz	foundz		; Yes, handle it
;		cmp	byte ptr [di-1],1ah ; No, double check
;		jnz	typecont2	; No ^Z, continue
;
;foundz:
;		sub	cx,ax		; Otherwise change cx so that only those
;		dec	cx		;  bytes up to but NOT including the ^Z
;		push	cs		;  will be typed.
;		pop	es
;		;assume es:trangroup
;		not	zflag		; Turn on ^Z flag so that the routine
;typecont2:				;  will quit after this write.
;		push	bx
;		mov	bx,1
;		mov	ah,write
;		int	21h
;		pop	bx
;		jc	Error_outputj
;		cmp	ax,cx
;		jnz	@f		;M043
;		jmp	typelp		;M043
;@@:					;M043
;;M043;		jz	typelp
;		dec	cx
;		cmp	ax,cx
;		retz			; One less byte OK (^Z)
;Error_outputj:
;		mov	bx,1
;		mov	ax,IOCTL SHL 8
;		int	21h
;		test	dl,devid_ISDEV
;		retnz			; If device, no error message
;		jmp	error_output
;typelp_ret:
;		ret

		; MSDOS 3.3
		mov	si,81h
		call	SCANOFF		; Skip to first non-delim
		cmp	al,0Dh
		jnz	short GOTTARG
		mov	dx,BADARGSPTR

		;jmp	CERROR
		jmp	short ERRJ	; No args
GOTTARG:
		call	SETPATH
		test	byte [DESTINFO],2
		jz	short NOWILDS
		mov	dx,INORNOTPTR

		;jmp	CERROR
		jmp	short ERRJ
NOWILDS:
		mov	ax,OPEN*256 ; 3D00h
		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
				; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 0 - read
		jnc	short TYPECONT
		mov	dx,FNOTFOUNDPTR
		cmp	ax,2
		jz	short ERRJ
		mov	dx,BADCPMESPTR
		stc
		call	GET_EXT_ERR_NUMBER

		;jmp	CERROR
		jmp	short ERRJ
TYPECONT:
		mov	byte [ZFLAG],0	; Reset ^Z flag
		mov	bx,ax		; Handle
		mov	ds,[TPA]
		xor	dx,dx
TYPELP:
		cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
		jnz	short RENAME_RETN ; Yes, return	
		mov	cx,[cs:BYTCNT]	; No, continue
		mov	ah,READ ; 3Fh
		int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
				; BX = file handle,CX = number	of bytes to read
				; DS:DX	-> buffer
		mov	cx,ax
		jcxz	TYPELP_RET	; exit if nothing read
					; Check to see if a ^Z was read.
		push	ds
		pop	es		
		xor	di,di
		push	ax
		mov	al,1Ah
		repne scasb
		pop	ax
		xchg	ax,cx
		cmp	ax,0
		jnz	short FOUNDZ	; Yes, handle it
		cmp	byte [di-1],1Ah	; No, double check
		jnz	short TYPECONT2	; No ^Z, continue
FOUNDZ:
		sub	cx,ax		; Otherwise change cx so that only those
		dec	cx		;  bytes up to but NOT including the ^Z
		push	cs		;  will be typed.
		pop	es
		not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
					;  will quit after this write.
TYPECONT2:
		push	bx
		mov	bx,1
		mov	ah,WRITE ; 40h
		int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
				; BX = file handle, CX = number of bytes to write,
				; DS:DX -> buffer
		pop	bx
		jc	short ERROR_OUTPUTJ
		cmp	ax,cx
		jz	short TYPELP
		dec	cx
		cmp	ax,cx		; One less byte OK (^Z)
		jnz	short ERROR_OUTPUTJ
TYPEFIL_RETN:
		retn
ERROR_OUTPUTJ:
		mov	bx,1
		mov	ax,IOCTL*256 ; 4400h
		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
				; BX = file or device handle
		;test	dl,devid_ISDEV
		test	dl,80h
		jnz	short TYPEFIL_RETN ; If device, no error message
		jmp	ERROR_OUTPUT

; ---------------------------------------------------------------------------

; VOLUME command displays the volume ID on the specified drive

VOLUME:
		; MSDOS 6.0
		;mov	si,81H
		;mov	di,offset trangroup:parse_vol
		;			;AN000; Get adderss of PARSE_VOL
		;xor	cx,cx		;AN000; clear cx,dx
		;xor	dx,dx		;AN000;
		;invoke	parse_with_msg	;AC018; call parser
		;cmp	ax,end_of_line	;AC000; are we at end of line?
		;jz	OkVolArg	;AC000; Yes, display default volume ID
		;cmp	ax,result_no_error ;AC000; did we have an error?
		;jnz	BadVolArg	;AC000; Yes, fail.

; We have parsed off the drive. See if there are any more chars left

		;mov	di,offset trangroup:parse_vol	
					;AC000; get address of parse_vol
		;xor	dx,dx		;AC000;
		;invoke	parse_check_eol ;AC000; call parser
		;jz	OkVolArg	;AC000; yes, end of road

; The line was not interpretable. Report an error.

;badvolarg:
		;jmp	Cerror

		; MSDOS 3.3
		mov	si,81h
		call	SCANOFF		; Skip to first non-delim
		;mov	ah,[5Ch]
		mov	ah,[FCB]
		;mov	byte [5Ch],0
		mov	byte [FCB],0
		cmp	al,0Dh		; are we at end of line?
		jz	short OKVOLARG	; Yes, display default volume ID
		;mov	[5Ch],ah
		mov	[FCB],ah
		lodsb
		lodsb
		cmp	al,':'
		jnz	short VOLUME_ERR
		call	SCANOFF
		cmp	al,0Dh
		jz	short OKVOLARG
VOLUME_ERR:
		mov	dx,BADDRVPTR
		jmp	CERROR

; ---------------------------------------------------------------------------

OKVOLARG:
		call	CRLF2
		push	ds
		pop	es
		;mov	di,55h
		mov	di,FCB-7	; Set up extended FCB
		mov	al,-1
		stosb
		xor	ax,ax
		stosw
		stosw
		stosb
		mov	al,8		; Look for volume label
		stosb
		inc	di		; Skip drive byte
		mov	cx,11
		mov	al,'?'
		rep stosb
		mov	dx,DIRBUF
		mov	ah,SET_DMA ; 1Ah
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
		;mov	dx,55h
		mov	dx,FCB-7
		mov	ah,DIR_SEARCH_FIRST ; 11h
		int	21h	; DOS -	SEARCH FIRST USING FCB
				; DS:DX	-> FCB
		jmp	PRINTVOL

;============================================================================
; TCMD2A.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h

; ---------------------------------------------------------------------------

; MSDOS 6.0
;***	Version - display DOS version
;
;	SYNTAX	ver [/debug]
;
;		/debug - display additional DOS configuration info
;
;	ENTRY	command-line tail is in PSP
;
;	EXIT	if successful, nothing
;		if parse fails,
;		  parse error message is set up (for Std_EPrintf)
;		    AX = system parser error code
;		    DX = ptr to message block
;		  we jump to CError
;
;	EFFECTS
;	  If parse fails, a parse error message is displayed.
;	  Otherwise, version message is displayed.
;	  If /debug is specified, additional DOS info is displayed.

;	assume	ds:TRANGROUP,es:TRANGROUP
;
;;	Parse command line for /debug switch.
;
;	mov	si,81h				; DS:SI = ptr to command tail
;	mov	di,offset TRANGROUP:Parse_Ver	; ES:DI = ptr to parse block
;	xor	cx,cx				; CX = # positional param's found
;	invoke	Parse_With_Msg
;
;	mov	bl,1			; BL = flag = /debug present
;	cmp	ax,RESULT_NO_ERROR
;	je	verPrintVer		; something parsed - must be /debug
;	dec	bl			; BL = flag = no /debug present
;	cmp	ax,END_OF_LINE
;	je	verPrintVer		; reached end of line - ok
;
;;	The parse failed.  Error message has been set up.
;
;	jmp	CError
;
;verPrintVer:
;	push	bx			; save /debug flag
;	call	Crlf2
;	call	Print_Version
;	call	Crlf2
;	pop	bx   			; BL = /debug flag
;	or	bl,bl
;	jz	verDone			; /debug is false - we're done
;
;;*	For /debug, display DOS internal revision and DOS location
;;	(low memory, HMA, or ROM).
;
;;	Bugbug:	use symbols for bitmasks below.
;
;	mov	ax,(SET_CTRL_C_TRAPPING shl 8) + 6 ; M013
;	int	21h
;	mov	al,dl			;revision number in dl; M013
;	mov	bh,dh			;flags in dh now; M013
;;M032	and	al,7			; AL = DOS internal revision
;	cmp	al,'Z'-'A'	;M032	; revision in A-to-Z range?
;	jbe	@f		;M032	; A-to-Z revision ok
;	mov	al,'*'-'A'	;M032	; beyond Z, just say revision *
;@@:	add	al,'A'			; AL = DOS internal rev letter
;	mov	One_Char_Val,al
;	mov	dx,offset TRANGROUP:DosRev_Ptr
;	invoke	Std_Printf		; print DOS internal revision
;
;	mov	cl,4
;	shr	bh,cl			; CY = DOS in ROM
;	jc	verRom
;	shr	bh,1			; CY = DOS in HMA
;	jc	verHma
;
;;	DOS isn't in ROM or HMA, so it must be in lower memory.
;
;	mov	dx,offset TRANGROUP:DosLow_Ptr
;	jmp	short verPrintLoc
;verRom: mov	dx,offset TRANGROUP:DosRom_Ptr
;	jmp	short verPrintLoc
;verHma: mov	dx,offset TRANGROUP:DosHma_Ptr
;verPrintLoc:
;	invoke	Std_Printf
;verDone:
;	jmp	Crlf2

		; MSDOS 3.3
VERSION:
		call	CRLF2
		call	PRINT_VERSION
		jmp	CRLF2

; =============== S U B	R O U T	I N E =======================================

PRINT_VERSION:
		mov	ah,GET_VERSION ; 30h
		int	21h	; DOS -	GET DOS	VERSION
				; Return: AL = major version number (00h for DOS 1.x)
		push	ax
		xor	ah,ah
		mov	[MAJOR_VER_NUM],ax
		pop	ax
		xchg	ah,al
		xor	ah,ah
		mov	[MINOR_VER_NUM],ax
		mov	dx,VERMESPTR
		jmp	STD_PRINTF

; =============== S U B	R O U T	I N E =======================================

PRINT_PROMPT:
		push	ds
		push	cs
		pop	ds		; Make sure Ds is in TRANGROUP
		push	es
		call	FIND_PROMPT	; Look for prompt string
		jc	short PP0	; Can't find one	
		cmp	byte [es:di],0
		jnz	short PP1
PP0:					; Use default prompt
		call	PRINT_DRIVE
		;mov	al,'>'
		mov	al,SYM
		call	PRINT_CHAR
		jmp	short PP5
PP1:
		mov	al,[es:di]	; Get a char
		inc	di
		or	al,al
		jz	short PP5	; Nul terminated
		cmp	al,[DOLLAR]	; Meta character
		jz	short PP2	; Nope
		call	PRINT_CHAR
		jmp	short PP1
PP2:
		mov	al,[es:di]
		inc	di
		;mov	bx,CLSSTRING+2	; "[2J"
		mov	bx,PROMPT_TABLE-3
		or	al,al
		jz	short PP5
PP3:
		add	bx,3
		;call	UPCONV
		call	UPCONV_MAPCALL
		cmp	al,[bx]
		jz	short PP4
		cmp	byte [bx],0
		jnz	short PP3
		jmp	short PP1
PP4:
		push	es
		push	di
		push	cs
		pop	es
		call	word [bx+1]
		pop	di
		pop	es
		jmp	short PP1
PP5:
		pop	es		; Restore segments
		pop	ds
		retn

; ---------------------------------------------------------------------------

PRINT_BACK:
		mov	dx,DBACKPTR
		jmp	STD_PRINTF

; ---------------------------------------------------------------------------

PRINT_EQ:
		mov	al,'='
		jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

PRINT_ESC:
		mov	al,1Bh
		jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

PRINT_G:
		mov	al,[RABRACKET]
		jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

PRINT_L:
		mov	al,[LABRACKET]
		jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

PRINT_B:
		mov	al,[VBAR]

; =============== S U B	R O U T	I N E =======================================

PRINT_CHAR:
		; MSDOS 6.0

;	Bugbug:	Why bother with ds,es here?
		
		;push	es
		;push	ds
		;pop	es
		;push	di
		;push	dx
		;mov	dl,al		;AC000; Get char into al
		;mov	ah,STD_CON_OUTPUT ;AC000; print the char to stdout
		;int	21h		;AC000;
		;pop	dx
		;pop	di
		;pop	es
		;retn

		; MSDOS 3.3
		push	es
		push	ds
		pop	es
		push	di
		push	dx
		mov	di,ONE_CHAR_VAL	
		stosb
		mov	dx,ONECHRVALPTR
		call	STD_PRINTF
		pop	dx
		pop	di
		pop	es
		retn

; ---------------------------------------------------------------------------

PRINT_DRIVE:
		mov	ah,GET_DEFAULT_DRIVE ; 19h
		int	21h	; DOS -	GET DEFAULT DISK NUMBER
		;add	al,'A'
		add	al,[CAPITAL_A]
		call	PRINT_CHAR
		retn

; ---------------------------------------------------------------------------

BUILD_DIR_FOR_PROMPT:
		xor	dl,dl
		mov	si,BWDBUF
		mov	di,si
		mov	al,[CURDRV]
		add	al,'A'
		mov	ah,':'
		stosw
		mov	al,[DIRCHAR]
		stosb
		xchg	si,di
		mov	[STRING_PTR_2],di
		mov	ah,CURRENT_DIR ; 47h
		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
				; DL = drive (0=default,1=A,etc.)
				; DS:SI	points to 64-byte buffer area
		mov	dx,STRINGBUF2PTR
		jnc	short DOPRINT
		mov	dx,BADCURDRVPTR
DOPRINT:
		call	STD_PRINTF
		retn

; =============== S U B	R O U T	I N E =======================================

BUILD_DIR_FOR_CHDIR:
		call	BUILD_DIR_STRING
		mov	dx,DIRBUF
		mov	[STRING_PTR_2],dx
		;mov	dx,offset trangroup:string_buf_ptr  ; MSDOS 6.0
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
		retn


; =============== S U B	R O U T	I N E =======================================

BUILD_DIR_STRING:
		mov	dl,[FCB] ; mov dl,[5Ch]
		mov	al,dl
		add	al,'@'
		cmp	al,'@'
		jnz	short GOTDRIVE
		add	al,[CURDRV]
		inc	al
GOTDRIVE:
		push	ax
		mov	si,BWDBUF+3
		mov	ah,CURRENT_DIR ; 47h
		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
				; DL = drive (0=default,1=A,etc.)
				; DS:SI	points to 64-byte buffer area
		jnc	short DPBISOK
		push	cs
		pop	ds
		jmp	DRVBAD
DPBISOK:
		mov	di,BWDBUF
		mov	dx,di
		pop	ax
		mov	ah,':'
		stosw
		mov	al,[DIRCHAR]
		stosb
		retn

; ---------------------------------------------------------------------------

PATH:
		; MSDOS 6.0
		;xor	al,al		;AN049; Set up holding buffer
		;mov	di,offset Trangroup:srcxname
					;AN049;   for PATH while parsing
		;stosb				;AN049; Initialize PATH to null
		;dec	di			;AN049; point to the start of buffer
		;invoke	PGetarg 		; Pre scan for arguments
		;jz	disppath		; Print the current path
		;cmp	al,semicolon		;AC049; NUL path argument?
		;jnz	pathslp 		;AC049;
		;inc	si			;AN049; point past semicolon
		;jmp	short scan_white	;AC049; Yes - make sure nothing else on line
;pathslp:					; Get the user specified path
		;lodsb				; Get a character
		;cmp	al,end_of_line_in	;AC049; Is it end of line?
		;jz	path_eol		;AC049; yes - end of command
		;invoke	testkanj		;See if DBCS
		;jz	notkanj2		;No - continue
		;stosb				;AC049; Yes - store the first byte
		;lodsb				;skip second byte of DBCS
;path_hold:					;AN049;
		;stosb				;AC049; Store a byte in the PATH buffer
		;jmp	short pathslp		;continue parsing
;notkanj2:
		;invoke	upconv			;upper case the character
		;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
		;jz	path_hold		;AC049; go store it
		;invoke	delim			;delimiter?
		;jnz	path_hold		;AC049; no - go store character
;scan_white:					;AN049; make sure were at EOL
		;lodsb				;AN049; get a character
		;cmp	al,end_of_line_in	;AN049; end of line?
		;jz	path_eol		;AN049; yes - go set path
		;cmp	al,blank		;AN049; whitespace?
		;jz	scan_white		;AN049; yes - continue scanning
		;cmp	al,tab_chr		;AN049; whitespace?
		;jz	scan_white		;AN049; yes - continue scanning

		;mov	dx,offset TranGroup:Extend_Buf_ptr 
						;AN049; no - set up error message
		;mov	Extend_Buf_ptr,MoreArgs_ptr
						;AN049; get "Too many parameters" message number
		;mov	msg_disp_class,parse_msg_class
						;AN049; set up parse error msg class
		;jmp	cerror			;AN049;
;path_eol:					;AN049; Parsing was clean
		;xor	al,al			;AN049; null terminate the PATH
		;stosb				;AN049;    buffer
		;invoke	find_path		;AN049; Find PATH in environment
		;invoke	delete_path		;AC049; Delete any offending name
		;invoke	scan_double_null	;AC049; Scan to end of environment
		;invoke	move_name		;AC049; move in PATH=
		;mov	si,offset Trangroup:srcxname	
						;AN049; Set up source as PATH buffer
;store_path:					;AN049; Store the PATH in the environment
		;lodsb				;AN049; Get a character
		;cmp	al,end_of_line_out	;AN049; null character?
		;jz	got_paths		;AN049; yes - exit
		;invoke	store_char		;AN049; no - store character
		;jmp	short store_path	;AN049; continue
;got_paths:					;AN049; we're finished
		;xor	ax,ax			;	null terminate the PATH in
		;stosw				;    	the environment
		;return
;disppath:
		;invoke	find_path		;AN049;
		;call	print_path
		;call	crlf2
		;retn

		; MSDOS 3.3
		call	FIND_PATH		; Find PATH in environment
		call	PGETARG			; Pre scan for arguments
		jz	short DISPPATH		; Print the current path
		call	DELETE_PATH		; Delete any offending name
		call	SCAN_DOUBLE_NULL	; Scan to end of environment	
		call	MOVE_NAME		; Move in PATH=
		call	PGETARG
		cmp	al,';'
		jz	short GOTPATHS
PATHSLP:
		lodsb
		cmp	al,0Dh			; End of line (CR) ?		
		jz	short GOTPATHS		; yes - exit
		;call	UPCONV
		call	UPCONV_MAPCALL		; convert to uppercase
		cmp	al,';'			; ';' not a delimiter on PATH
		jz	short NOTDELIM		; go set path
		call	DELIM			; is it delim/null char ?
		jz	short GOTPATHS		; yes - exit
NOTDELIM:
		call	STORE_CHAR		; no - store character
		jmp	short PATHSLP
GOTPATHS:
		xor	ax,ax			; null terminate the PATH
		stosw				; in the environment
		retn
DISPPATH:
		call	PRINT_PATH
		call	CRLF2
		retn

; =============== S U B	R O U T	I N E =======================================

PRINT_PATH:
		cmp	byte [es:di],0
		jnz	short PATH1
PATH0:
		mov	dx,NULLPATHPTR
		push	cs
		pop	es
		push	cs
		pop	ds
		jmp	STD_PRINTF
PATH1:
		push	es
		pop	ds
		sub	di,5
		mov	si,di
		call	SCASB2		; Look for null
		cmp	cx,0FFh
		jz	short PATH0
		push	cs
		pop	es
		mov	di,ARG_BUF
		mov	dx,100h
		sub	dx,cx
		xchg	dx,cx
		rep movsb
		mov	dx,ARG_BUF_PTR
		push	cs
		pop	ds
		jmp	STD_PRINTF

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 CLS
; *
; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
; *		 installed, send a control string to clear the
; *		 screen.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

; MSDOS 3.3

CLS:
		mov	bx,STDOUT ; 1
		mov	ax,IOCTL*256 ; 4400h
		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
				; BX = file or device handle
		test	dl,80h	; devid_ISDEV
		jz	short ANSICLS	; If a file put out ANSI
		test	dl,10h  ; devid_SPECIAL
		jz	short ANSICLS	; If not special CON, do ANSI

		mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
				; AL = interrupt number
				; Return: ES:BX	= value	of interrupt vector
		mov	dx,es
		mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
		int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
				; AL = interrupt number
				; Return: ES:BX	= value	of interrupt vector
		mov	ax,es
		cmp	dx,ax	; If not default driver, do ANSI
		ja	short ANSICLS

		mov	ah,0Fh
		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
				; Return: AH = number of columns on screen
				; AL = current video mode
				; BH = current active display page
		cmp	al,3
		jbe	short DOALPHA
		cmp	al,7
		jz	short DOALPHA
		mov	ah,0
		int	10h	; - VIDEO - SET	VIDEO MODE
				; AL = mode
		retn

DOALPHA:
		mov	ah,0Bh	; Set overscan to black
		xor	bx,bx
		int	10h	; - VIDEO - SET	COLOR PALETTE
				; BH = 00h, BL = border color
				; BH = 01h, BL = palette (0-3)
		mov	ah,0Fh
		int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
				; Return: AH = number of columns on screen
				; AL = current video mode
				; BH = current active display page
		mov	dl,ah
		dec	dl
		mov	dh,24
		xor	ax,ax
		mov	cx,ax
		mov	bx,700h
		mov	ah,6
		int	10h	; - VIDEO - SCROLL PAGE	UP
				; AL = number of lines to scroll window	
				;	(0 = blank whole window)
				; BH = attributes to be	used on	blanked	lines
				; CH,CL	= row,column of	upper left corner of window 
				;	  to scroll
				; DH,DL	= row,column of	lower right corner of window
		xor	dx,dx
		mov	bh,0
		mov	ah,2
		int	10h	; - VIDEO - SET	CURSOR POSITION
				; DH,DL	= row,column (0,0 = upper left)
				; BH = page number
		retn

ANSICLS:
		mov	si,CLSSTRING
		lodsb
		mov	cl,al
		xor	ch,ch
		mov	ah,RAW_CON_IO ; 6
CLRLOOP:
		lodsb
		mov	dl,al
		int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
				; DL = character <> FFh
				;  Return: ZF set = no character
				;   ZF clear = character recieved, AL = character
		loop	CLRLOOP
		retn

; ---------------------------------------------------------------------------

; MSDOS 6.0

;ANSI_installed		equ    0ffh
;
;CLS:
;	mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
;	mov	al,0			;AN000;
;	int	2fh			;AN000;
;	cmp	al,ANSI_installed	;AN000;
;	jz	ansicls 		;AN000; installed - go do ANSI CLS
;
;check_lines:
;	mov	ax,(IOCTL SHL 8) + generic_ioctl_handle 
;					;AN000; get lines per page on display
;	mov	bx,stdout		;AN000; lines for stdout
;	mov	ch,ioc_sc		;AN000; type is display
;	mov	cl,get_generic		;AN000; get information
;	mov	dx,offset trangroup:display_ioctl ;AN000;
;	int	21h			;AN000;
;	jc	no_variable		;AN000; function had error, use default
;	mov	ax,linperpag		;AN000; get number of rows returned
;	mov	dh,al			;AN000; set number of rows
;	mov	ax,display_width	;AN000; get number of columns returned
;	mov	dl,al			;AN000; set number of columns
;	jmp	short regcls		;AN000; go do cls
;
;no_variable:
;	mov	bx,stdout		;AC000; set handle as stdout
;	mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
;	int	21h			;AC000;
;	test	dl,devid_ISDEV		;AC000; is handle a device
;	jz	ANSICLS 		;AC000; If a file put out ANSI
;	test	dl,devid_SPECIAL	;AC000;
;	jnz	cls_normal		;AC000; If not special CON, do ANSI
;
;ansicls:
;	call	ansi_cls		;AN000; clear the screen
;	jmp	short cls_ret		;AN000; exit
;
;;
;; Get video mode
;;
;
;cls_normal:				;AC000;
;
;	mov	ah,get_video_state	;AC000; set up to get video state
;	int	video_io_int		;AC000; do int 10h - BIOS video IO
;	cmp	al,video_alpha		;AC000; see if in text mode
;	jbe	DoAlpha
;	cmp	al,video_bw		;AC000; see if black & white card
;	jz	DoAlpha
;;
;; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
;; be just as bogus and set the mode that we just got. This will blank the
;; screen too.
;;
;	mov	ah,set_video_mode	;AC000; set video mode call
;	int	video_io_int		;AC000; do int 10h - BIOS video IO
;	jmp	short cls_ret		;AC000; exit
;
;DoAlpha:
;;
;; Get video mode and number of columns to scroll
;;
;
;;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
;;M01   adaptors. We circumvent this by reaching directly into the BIOS data
;;M01   area
;;M01   Commented out code here is the original
;;M01	mov	ah,get_video_state		;AC000; set up to get current video state
;;M01	int	video_io_int			;AC000; do int 10h - BIOS video IO
;;M01	mov	dl,ah
;;M01	mov	dh,linesperpage 		;AC000; have 25 rows on the screen
;
;;M01   Following code lifted from a fix Compaq applied to ANSI
;
;	push	ds
;	MOV	AX,ROMBIOS_DATA 	; GET ROM Data segment	M01
;	MOV	DS,AX			;  *			M01
;	Assume	DS:ROMBIOS_DATA
;
;	mov	dx,CRT_Cols		; Get Columns - assume < 256 M01
;	MOV	dh,CRT_Rows		; GET MAX NUM OF ROWS	M01
;	pop	ds			;			M01
;	Assume	DS:Trangroup
;
;	or	dh,dh			; Q:ZERO		M01
;	jnz	regcls			;  *JMP IF NO		M01
;
;	MOV	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
;
;regcls:
;	inc	dh			; height+1		M018
;	call	reg_cls 		; go clear the screen
;
;cls_ret:
;	ret				; exit

; ---------------------------------------------------------------------------

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 REG_CLS
; *
; * FUNCTION:	 Clear the screen using INT 10H.
; *
; * INPUT:	 DL = NUMBER OF COLUMNS
; *		 DH = NUMBER OF ROWS
; *
; * OUTPUT:	 none
; *
; ****************************************************************

;reg_cls proc	near
;
;;
;; Set overscan to black.
;;
;	dec	dh			;  decrement rows and columns
;	dec	dl			;     to zero base
;	push	dx			;  save rows,columns
;	mov	ah,set_color_palette	;  set up to set the color to blank
;	xor	bx,bx
;	int	video_io_int		; do int 10h - BIOS video IO
;	pop	dx			;  retore rows,colums
;
;	xor	ax,ax			;  zero out ax
;	mov	CX,ax			;     an cx
;;
;; Scroll active page
;;
;	mov	ah,scroll_video_page	; set up to scroll page up
;	mov	bh,video_attribute	; attribute for blank line
;	xor	bl,bl			; set BL to 0
;	int	video_io_int		; do int 10h - BIOS video IO
;;
;; Seek to cursor to 0,0
;;
;;M022 following two lines added
;	mov	ah,get_video_state	; get current video page in BH
;	int	video_io_int
;	mov	ah,set_cursor_position	; set up to set cursor position
;	xor	dx,dx			; row and column 0
;;M022	mov	bh.0
;	int	video_io_int		; do into 10h - BIOS video IO
;
;	ret
;
;reg_cls endp

; ---------------------------------------------------------------------------

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 ANSI_CLS
; *
; * FUNCTION:	 Clear the screen using by writing a control code
; *		 to STDOUT.
; *
; * INPUT:	 none
; *
; * OUTPUT:	 none
; *
; ****************************************************************

;ansi_cls proc	near			;AC000;
;
;	mov	si,offset trangroup:clsstring
;	lodsb
;	mov	cl,al
;	xor	ch,ch
;	mov	ah,Raw_CON_IO
;clrloop:
;	lodsb
;	mov	DL,al
;	int	21h
;	loop	clrloop
;	return
;
;ansi_cls	endp			;AC000;

;============================================================================
; TCMD2B.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 CTTY - Change console
; *
; * SYNTAX:	 CTTY device
; *
; * FUNCTION:	 If a valid console device is specified, CTTY will
; *		 duplicate the device handle to STDIN, STDOUT and
; *		 STDERR.  This routine returns to LODCOM1.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CTTY:
		; MSDOS 6.0
		;push	ds			;AN000; Get local ES
		;pop	es			;AN000;
		;mov	si,81H			;AC000; Get command argument for CTTY

		;mov	di,offset trangroup:parse_ctty	
						;AC000; Get adderss of PARSE_CTTY
		;xor	cx,cx			;AC000; clear cx,dx
		;xor	dx,dx			;AC000;
		;invoke	cmd_parse		;AC000; call parser
		;cmp	ax,end_of_line		;AN000; are we at end of line?
		;jz	ctty_error		;AN000; yes - error
		;cmp	ax,result_no_error	;AN000; did an error occur
		;jnz	ctty_error		;AN000; YES -ERROR

		;push	si			;AN000; save position in line
		;lds	si,parse1_addr		;AN000; get address of filespec
		;mov	di,offset trangroup:srcbuf ;AN000; get address of srcbuf

;ctty_move_filename:				;AN000; put filespec in srcbuf
		;lodsb				;AN000; get a char from buffer
		;stosb				;AN000; store in srcbuf
		;cmp	al,end_of_line_out	;AN000; it char a terminator?
		;jnz	ctty_move_filename	;AN000; no - keep moving
		;pop	si			;AN000; get line position back
		;mov	di,offset trangroup:parse_ctty	
						;AC000; Get adderss of PARSE_CTTY
		;call	parse_check_eol 	;AN000; are we at end of line?
		;jz	nocolon 		;AN000; yes - continue

;ctty_error:
		;jmp	short isbaddev		;AC000; yes - exit

		; MSDOS 3.3
		call	SETPATH
		dec	si
		dec	si
		cmp	byte [si],':'
		jnz	short NOCOLON
		mov	byte [si],0
NOCOLON:
		; MSDOS 3.3 (& MSDOS 6.0)
		;MOV	AX,(OPEN SHL 8) OR 2 ; Read and write
		mov	ax,(OPEN<<8)|2 ; 3D02h
		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
				; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 2 - read & write
		jc	short ISBADDEV
			mov	bx,ax
		mov	ax,IOCTL*256 ; 4400h
		int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
				; BX = file or device handle
		test	dl,80h
		jnz	short DEVISOK
CLOSEDEV:
		mov	ah,CLOSE ; 3Eh ; Close initial handle
		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
ISBADDEV:
		mov	dx,BADDEVPTR
		call	STD_PRINTF
		jmp	short RESRET

		;nop
DEVISOK:
		; MSDOS 6.0
		;push	dx		;AN007; save device info
		;mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
		;mov	dh,util_msg_class ;AN021; this is a utility message
		;push	bx		;AN021; save handle
		;invoke	Tsysgetmsg	;AN021; get the address of the message
		;mov	dx,si		;AN021; get address into dx
		;mov	ax,(write shl 8) ;AN007; write to device
		;mov	cx,2		;AN007; write two bytes
		;int	21h		;AN007;
		;pop	bx		;AN021; get back handle
		;pop	dx		;AN007; get back device info
		;jc	closedev	;AN007; if error, quit

		; MSDOS 3.3 (& MSDOS 6.0)
		xor	dh,dh
		or	dl,3
		;MOV	AX,(IOCTL SHL 8) OR 1
		mov	ax,(IOCTL<<8)|1 ; 4401h
		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
				; BX = device handle,DH = 0
				; DL = device information to set 
				;		(bits 0-7 from	function 0)
		push	bx
		mov	cx,3
		xor	bx,bx

ICLLOOP:				; Close basic handles
		mov	ah,CLOSE ; 3Eh
		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
		inc	bx
		loop	ICLLOOP
		pop	bx		; Get handle
		mov	ah,XDUP ; 45h
		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
				; BX = file handle to duplicate
		mov	ah,XDUP ; 45h
		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
				; BX = file handle to duplicate
		mov	ah,XDUP ;45h
		int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
				; BX = file handle to duplicate
		mov	ah,CLOSE ; 3Eh
		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
RESRET:
		mov	ds,[RESSEG]
		push	ds
		mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
		mov	word [IO_SAVE],ax
		;MOV	AX,OFFSET DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
		;mov	ax,31Eh ;  MSDOS 3.3
		mov	ax,LODCOM1
		push	ax

		retf		; Far return

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	CHCP - Change code page internal command
;*		(added DOS 3.30 07/21/86)
;*
;* SYNTAX:	CHCP [xxx]
;*		where xxx is a valid code page
;*
;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
;*		6402H to set the code page to xxxx. If no parameters
;*		are specified, CHCP will use INT 21H function 6401H
;*		to get global code page and display it to the user.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

;NLSFUNC_installed equ  0FFh
set_global_cp	  equ   2
get_global_cp	  equ   1

CHCP:
		; MSDOS 6.0
		;push	ds		;AN000; Get local ES
		;pop	es		;AN000;
		;mov	si,81H		;AC000; Get command argument for CHCP

		;mov	di,offset trangroup:parse_chcp	
					;AN000; Get adderss of PARSE_CHCP
		;xor	cx,cx		;AC000; clear cx,dx
		;xor	dx,dx		;AC000;
		;call	parse_with_msg	;AC018; call parser
		;cmp	ax,end_of_line	;AN000; are we at end of line?

		;;jnz	setcp		;AC000; no go get number & set code page
		;jz	getcp		;AC000; yes - no parm - get code page
;setcp:
		;cmp	ax,result_no_error ;AN000; did we have an error?
		;jne	cp_error	;AC018; yes - go issue message

		;push	cx		;AN000; save positional count
		;mov	bx,offset trangroup:parse1_addr 
					;AN000; get number returned
		;mov	cx,word ptr [bx] ;AN000;     into cx
		;mov	system_cpage,cx ;AN000; save user input number
		;pop	cx		;AC000; restore positional count
		;mov	di,offset trangroup:parse_chcp	
					;AN000; Get adderss of PARSE_CHCP
		;call	parse_check_eol ;AN000; are we at end of line?
		;jnz	cp_error	;AC000; no - exit
;okset:
		;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
		;mov	al,0		;AN000;
		;int	2fh		;AN000;
		;cmp	al,NLSFUNC_installed ;AN000;
		;jz	got_NLS 	;AN000; Yes - continue
		;mov	dx,offset trangroup:NLSFUNC_ptr
					;AN000; no - set up error message
		;jmp	short cp_error	;AN000; error exit
;got_NLS:

		; MSDOS 3.3
		mov	si,81h
		call	SCANOFF
		cmp	al,0Dh ; CR
		jnz	short SETCP
		jmp	short GETCP

		;nop
SETCP:
		xor	bx,bx
		mov	cx,bx
		mov	ax,bx
GET_CP_DIGIT:
		lodsb
		cmp	al,'0'
		jb	short CHRNOTNUMBER
		cmp	al,'9'
		ja	short CHRNOTNUMBER
		sub	al,'0'
		inc	cl
		cmp	cl,4
		ja	short CHCP_BADPARM
		mov	dx,bx
		shl	dx,1
		shl	dx,1
		add	bx,dx
		shl	bx,1
		add	bx,ax
		jmp	short GET_CP_DIGIT
CP_NEXTCHR:
		lodsb
CHRNOTNUMBER:
		cmp	al,' '		; SPACE
		jz	short CP_NEXTCHR
		cmp	al,9		; TAB
		jz	short CP_NEXTCHR
		cmp	al,0Dh		; CR
		jz	short SET_CP_TBL_NUM
CHCP_BADPARM:
		mov	dx,BADPARMPTR
		jmp	CERROR
;GOT_NLS:
SET_CP_TBL_NUM:
		; MSDOS 3.3 (& MSDOS 6.0)
		mov	word [SYSTEM_CPAGE],bx
		mov	ah,GETSETCDPG  ; 66h
		mov	al,set_global_cp ; 2
		int	21h	; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
				; BX = active code page
				; DX = system code page	(active	page at	boot time)
		jnc	short CHCP_RETURN

		cmp	ax,ERROR_FILE_NOT_FOUND ; 2
		jnz	short CHCP_OTHER_ERROR

		mov	ah,GETEXTENDEDERROR ; 59h
		xor	bx,bx
		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
				; BX = version code (0000h for DOS 3.x)
		cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
		jz	short NONE_SET
		mov	dx,FNOTFOUNDPTR
		jmp	CERROR
CHCP_OTHER_ERROR:			; end of p716
		mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
		xor	bx,bx
		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
				; BX = version code (0000h for DOS 3.x)
		cmp	ax,65		;was it access denied?
		jnz	short NONE_SET	;no - assume all failed
		mov	dx,CPNOTALLPTR	;set up message
		jmp	CERROR		;AC000; error exit
NONE_SET:
		mov	dx,CPNOTSETPTR	;set up message
CP_ERROR:
		jmp	CERROR		;exit
GETCP:
		mov	ah,GETSETCDPG ; 66h  ;get/set global code page function	
		mov	al,get_global_cp ; 1 ;minor - get
		int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
		mov	word [SYSTEM_CPAGE],bx ;get active cp for output
		mov	dx,CPACTIVEPTR
		call	STD_PRINTF	;print it out
CHCP_RETURN:
		retn

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 TRUENAME
; *
; * FUNCTION:	 Entry point for the internal TRUENAME command.
; *		 Parses the command line. If a path is found, set
; *		 SRCXNAME to path.  If only a drive letter is
; *		 found, set SRCXNAME to the drive letter.  If
; *		 no path is found, set the path of SRCXNAME to
; *		 dot (.) for current directory.  Use the NAME
; *		 TRANSLATE system call to get the real name and
; *		 then display the real name.  If an error occurs
; *		 issue an error message and transfer control to
; *		 CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

;assume	ds:trangroup,es:trangroup		;AN000;
;
;TRUENAME:					;AN000; TRUENAME entry point
;	push	ds				;AN000; Get local ES
;	pop	es				;AN000;
;	mov	si,81H				;AN000; Get command line
;	mov	di,offset trangroup:parse_chdir ;AN000; Get adderss of PARSE_CHDIR
;	xor	cx,cx				;AN000; clear cx,dx
;	xor	dx,dx				;AN000;
;	call	parse_with_msg			;AC018; call parser
;
;	mov	di,offset trangroup:srcxname	;AN000; get address of srcxname
;	cmp	ax,end_of_line			;AN000; are we at end of line?
;	je	tn_eol				;AN000; yes - go process
;	cmp	ax,result_no_error		;AN000; did we have an error?
;	jne	tn_parse_error			;AN000; yes - go issue message
;	cmp	parse1_type,result_drive	;AN000; was a drive entered?
;	je	tn_drive			;AN000; yes - go process
;	jmp	short tn_filespec		;AN000; nothing else - must be filespec
;
;tn_eol: 					;AN000; no parameters on line
;	mov	ah,end_of_line_out		;AN000; set buffer to .
;	mov	al,dot_chr			;AN000;     for current dir
;	stosw					;AN000; store in srcxname
;	jmp	short tn_doit			;AN000; go do command
;
;tn_drive:					;AN000; a drive was entered
;	push	si				;AN000; save position in line
;	mov	si,offset trangroup:parse1_addr ;AN000; get address of drive
;	lodsb					;AN000; get the drive number
;	add	al,"A"-1                        ;AN000; convert it to char
;	stosb					;AN000; store it in srcxname
;	mov	ax,dot_colon			;AN000; get colon and . and
;	stosw					;AN000;    store in srcxname
;	mov	al,end_of_line_out		;AN000; put a terminator char
;	stosb					;AN000;
;	pop	si				;AN000; get line position back
;	jmp	short tn_check_eol		;AN000; check to make sure eol
;
;tn_filespec:					;AN000; a filespec was entered
;	push	si				;AN000; save position in line
;	lds	si,parse1_addr			;AN000; get address of filespec
;
;tn_move_filename:				;AN000; put filespec in srcxname
;	lodsb					;AN000; get a char from buffer
;	stosb					;AN000; store in srcxname
;	cmp	al,end_of_line_out		;AN000; it char a terminator?
;	jnz	tn_move_filename		;AN000; no - keep moving
;	pop	si				;AN000; get line position back
;
;tn_check_eol:					;AN000; make sure no extra parms
;	mov	di,offset trangroup:parse_chdir ;AN000; get address of parse_chdir
;	call	parse_check_eol 		;AN000; are we at end of line?
;	je	tn_doit 			;AN000; Yes - do the command
;
;tn_parse_error: 				;AN000; A parse error occurred
;	jmp	cerror				;AN000; Go to error routine
;
;tn_doit:					;AN000;
;	mov	si,offset trangroup:srcxname	;AN000; set up srcxname as source
;	mov	di,offset trangroup:combuf	;AN000; set up combuf as target (need big target)
;	mov	ah,xnametrans			;AN000; do name translate call
;	int	21h			;AN000;
;	jnc	tn_print_xname			;AN000; If no error - print result
;
;	invoke	Set_ext_error_msg		;AN000; get extended message
;	mov	string_ptr_2,offset trangroup:srcxname ;AN000; get address of failed string
;	mov	Extend_buf_sub,one_subst	;AN000; put number of subst in control block
;	jmp	cerror				;AN000; Go to error routine
;
;tn_print_xname: 				;AN000;
;	mov	string_ptr_2,offset Trangroup:combuf ;AN000; Set up address of combuf
;	mov	dx,offset trangroup:string_buf_ptr   ;AN000; Set up address of print control block
;	invoke	crlf2				;AN000; print a crlf
;	invoke	printf_crlf			;AN000; print it out
;
;	ret					;AN000;
;

; ---------------------------------------------------------------------------

_$EXIT:
		; MSDOS 3.3
		mov	es,[RESSEG]
		mov	ax,word [es:PARENT]
		;mov	[es:16h],ax
		mov	[es:PDB.PARENT_PID],ax
		mov	ax,word [es:OLDTERM]
		;mov	[es:0Ah],ax
		mov	[es:PDB.EXIT],ax
		mov	ax,word [es:OLDTERM+2]
		;mov	[es:0Ch],ax
		mov	[es:PDB.EXIT+2],ax
		push	es
		mov	es,[TRAN_TPA]
		mov	ah,DEALLOC ; 49h
		int	21h	; DOS -	2+ - FREE MEMORY
				; ES = segment address of area to be freed
		pop	es
		mov	ah,EXIT ; 4Ch
		;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
		mov	al,byte [es:RETCODE]
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)

;;here:
;;		jmp	short here

		; MSDOS 6.0
		;push	ds			;AN000; save data segment
		;mov	ds,[resseg]		;AN000; get resident data segment

		;assume	ds:resgroup		;AN000;

		;cmp	[permcom],0		;AN045; is this a permanent COMMAND?
		;jz	free_com		;AN045; no - free everything

;	We're a permanent command.
;	Unless this is a singlecom (int 2Eh), don't deallocate transient.

		;cmp	[singlecom],-1		;M034
		;je	no_reset		;M034	;exit singlecom

		;jmp	TCommand		;permanent command, recycle

;free_com:
		;mov	ax,(multdos shl 8 or message_2f)
						;AN060; reset parse message pointers
		;mov	dl,set_critical_msg	;AN000; set up critical error message address
		;mov	di,crit_msg_off 	;AN000; old offset of critical messages
		;mov	es,crit_msg_seg 	;AN000; old segment of critical messages
		;int	2fh			;AN000; go set it
;no_reset:					;AN045;
		;pop	ds			;AN000; restore local data segment

		;assume	ds:trangroup		;AN000;
;
;M040
; Restore user directory if the restore flag is set. RestUDir1 checks for
;this, restores user dir if flag is set and resets the flag.
;
		;invoke	RestUDir1		;restore user dir if needed ;M040
		;MOV	ES,[RESSEG]

		;assume	es:resgroup

		;MOV	AX,[PARENT]
		;MOV	WORD PTR ES:[PDB_Parent_PID],AX
		;MOV	AX,WORD PTR OldTerm
		;MOV	WORD PTR ES:[PDB_Exit],AX
		;MOV	AX,WORD PTR OldTerm+2
		;MOV	WORD PTR ES:[PDB_Exit+2],AX

		;PUSH	ES
		;MOV	ES,[TRAN_TPA]
		;MOV	AH,DEALLOC
		;INT	21h			; Now running in "free" space
		;POP	ES

		;MOV	AH,Exit
		;MOV	AL,BYTE PTR RetCode
		;INT	21h

; ---------------------------------------------------------------------------

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 PARSE_CHECK_EOL
; *
; * FUNCTION:	 Calls parser to see if end of line occurred.
; *		 If not end of line, set up to print parse
; *		 error message.  ASSUMES NO MORE PARAMETERS ARE
; *		 EXPECTED!
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if end of line found
; *		     zero flag set
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *
; ****************************************************************

;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN000;
;
;parse_check_eol Proc near			;AN000;
;
;	xor	dx,dx				;AN000;
;	mov	[parse_last],si 		;AN018; save start of parameter
;	invoke	cmd_parse			;AN000; call parser
;	cmp	al,end_of_line			;AN000; Are we at end of line?
;	jz	parse_good_eol			;AN000; yes - no problem
;
;	cmp	ax,result_no_error		;AN018; was any error found?
;	jnz	ok_to_setup_pmsg		;AN018; yes - continue
;	inc	ax				;AN018; set AX to 1 and turn off zero flag
;
;ok_to_setup_pmsg:
;	call	setup_parse_error_msg		;AN018; go set up error message
;
;parse_good_eol:
;	ret					;AN000;
;
;parse_check_eol endp				;AN000;

; ---------------------------------------------------------------------------

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 PARSE_WITH_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if no error
; *		     outputs from parser
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *		     error message set up for STD_PRINTF
; *
; ****************************************************************

;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
;
;parse_with_msg	Proc near			;AN018;
;
;	mov	[parse_last],si 		;AN018; save start of parameter
;	invoke	cmd_parse			;AN018; call parser
;	cmp	al,end_of_line			;AN018; Are we at end of line?
;	jz	parse_msg_good			;AN018; yes - no problem
;	cmp	ax,result_no_error		;AN018; did an error occur
;	jz	parse_msg_good			;AN018; yes - no problem
;
;	call	setup_parse_error_msg		;AN018; go set up error message
;
;parse_msg_good:
;	ret					;AN018;
;
;parse_with_msg endp				;AN018;

; ---------------------------------------------------------------------------

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 AX	     Parse error number
; *		 SI	     Set to past last parameter
; *		 Parse_last  Set to start of last parameter
; *
; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
; *		 error message set up for STD_PRINTF
; *
; ****************************************************************

;ASSUME	CS:TRANGROUP,DS:TRANGROUP,ES:NOTHING	;AN018;
;
;SETUP_PARSE_ERROR_MSG	Proc near		;AN018;
;
;	mov	msg_disp_class,parse_msg_class	;AC018; Set up parse message class
;	mov	dx,offset TranGroup:Extend_Buf_ptr  ;AC018; get extended message pointer
;	mov	byte ptr [si],end_of_line_out	;AC018; terminate the parameter string
;	mov	Extend_Buf_ptr,ax		;AC018; get message number in control block
;	cmp	ax,lessargs_ptr 		;AC018; if required parameter missing
;	jz	Setup_parse_msg_ret		;AN018;    no subst
;	mov	si,[parse_last] 		;AC018; get start of parameter
;	mov	string_ptr_2,si 		;AC018; get address of failed string
;	mov	Extend_buf_sub,one_subst	;AC018; put number of subst in control block
;
;setup_parse_msg_ret:
;	inc	si				;AN018; make sure zero flag not set
;
;	ret					;AC018;
;
;SETUP_PARSE_ERROR_MSG	Endp			;AN018;

;============================================================================
; TENV.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/10/2018 - Retro DOS v3.0

; TITLE	Part6 COMMAND Transient routines.

;	Environment utilities and misc. routines

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h

; ---------------------------------------------------------------------------

ADD_PROMPT:
		call	DELETE_PROMPT	; Delete any existing prompt
		call	SCAN_DOUBLE_NULL

ADD_PROMPT2:
		push	si
		call	GETARG
		pop	si
		jnz	short ADD_PROMPT3
ADD_PROMPT_RETN:
		retn
ADD_PROMPT3:				; Pre scan for arguments
		call	MOVE_NAME	 ;Move in name
		call	GETARG
		push	si
		jmp	short ADD_NAME

;break	The SET command

; Input: DS:SI points to a CR terminated string
; Output: carry flag is set if no room
;	  otherwise name is added to environment

DISP_ENVJ:
		jmp	DISP_ENV

ADD_NAME_TO_ENVIRONMENT:
		call	GETARG
		jz	short DISP_ENVJ

; check if line contains exactly one equals sign

		xor	bx,bx		; = count is 0
		push	si		; Save pointer to beginning of line
EQLP:
		lodsb			; Get a char
		cmp	al,13		; IF CR we're all done
		jz	short QUEQ	
		cmp	al,'='		; Look for = sign	
		jnz	short EQLP	; not there, get next char
		inc	bl		; Otherwise increment EQ count
		cmp	byte [si],13	; Look for CR following = sign
		jnz	short EQLP
		inc	bh		; Set BH=1 means no parameters
		jmp	short EQLP	; And look for more
QUEQ:
		pop	si		; Restore beginning of line
		dec	bl		; Zero flag means only one EQ
		jz	short ONEQ	; Good line
		mov	dx,SYNTMESPTR
		jmp	CERROR
ONEQ:
		push	bx
		call	DELETE_NAME_IN_ENVIRONMENT
		pop	bx
		dec	bh
		jz	short ADD_PROMPT_RETN
		call	SCAN_DOUBLE_NULL
		mov	bx,di		; Save ptr to beginning of env var name
		call	MOVE_NAME
		push	si
		xchg	bx,di		; Switch ptrs to beginning and end of
					;  env var name
		
; We want to special-case COMSPEC. This is to reduce the amount of code
; necessary in the resident for re-reading the transient. Let's look for
; COMSPEC=

		;mov	byte [COMSPEC_FLAG],0 ; MSDOS 6.0 ; clear flag ; M024
		mov	si,COMSPEC_TEXT	; "COMSPEC="
		mov	cx,4
		repe cmpsw
		jnz	short NOT_COMSPEC
					; Zero set => exact match
		;inc byte [COMPREC_FLAG] ; MSDOS 6.0 ; comspec is changing ; M024
		mov	byte [COMSPEC_FLAG],1
NOT_COMSPEC:
		mov	di,bx		; Load ptr to end of env var name
ADD_NAME:
		pop	si		; Add the value of the new env var
		push	si		;  to the environment.
ADD_NAME1:
		lodsb
		cmp	al,13
		jz	short ADD_NAME_RET
		call	STORE_CHAR
		jmp	short ADD_NAME1
ADD_NAME_RET:
		pop	si
		cmp	byte [COMSPEC_FLAG],0 ; If the new env var is comspec,	
ADD_NAME_JZ_RET:
		jz	short ADD_PROMPT_RETN 
					;  copy the value into the
					;  comspec var in the resident

; We have changed the COMSPEC variable. We need to update the resident
; pieces necessary to reread in the info. First, skip all delimiters

		call	SCANOFF
		mov	es,[RESSEG]	;  comspec var in the resident

; Make sure that the printer knows where the beginning of the string is

		mov	di,COMSPEC
		mov	bx,di

; Generate drive letter for display

		xor	ax,ax		;g assume no drive first
		mov	byte [es:COMDRV],al ;g
		cmp	byte [si+1],':'	 ; drive specified?
		jnz	short _GOTDRIVE
		mov	al,[si]		; get his specified drive
		;call	UPCONV
		call	UPCONV_MAPCALL	; convert to uppercase
		sub	al,'A'		; convert to 0-based
		add	di,2
		inc	al		; convert to 1-based number
		mov	byte [es:COMDRV],al

; Stick the drive letter in the prompt message. Nothing special needs to be
; done here..
		;add	al,40h
		add	al,'A'-1
_GOTDRIVE:
		;mov	word [es:0BD9h],di ; MSDOS 3.3 COMMAND.COM offset 1734h
		mov	word [es:PUTBACKSUBSTPTR],di
					;g point to beginning of name after drive
		;mov	byte [es:0A21h],al ; MSDOS 3.3 COMMAND.COM offset 1739h
		mov	byte [es:PUTBACKDRV],al ; MSDOS 3.3 COMMAND

; Copy chars until delim      	

		mov	di,bx
COPY_COMSPEC:
		lodsb
		call	DELIM
		jz	short COPYDONE
		cmp	al,13
		jz	short COPYDONE
		stosb
		jmp	short COPY_COMSPEC
COPYDONE:
		xor	al,al		; Null terminate the string and quit
		stosb
		mov	byte [COMSPEC_FLAG],0
		dec	di
		mov	word [es:COMSPEC_END],di
		retn
DISP_ENV:
		mov	ds,[RESSEG]
		mov	ds,word [ENVIRSEG]
		; assume ds:nothing
		xor	si,si
PENVLP:
		cmp	byte [si],0
		jz	short ADD_NAME_JZ_RET
		mov	di,ARG_BUF
PENVLP2:
		lodsb
		stosb
		or	al,al
		jnz	short PENVLP2
		mov	dx,ARG_BUF_PTR
		push	ds
		push	es
		pop	ds
		; assume ds:nothing
		call	PRINTF_CRLF
		pop	ds
		jmp	short PENVLP

; =============== S U B	R O U T	I N E =======================================

DELETE_PATH:
		mov	si,PATH_TEXT ; "PATH="
		jmp	short DELETE_NAME_IN_ENVIRONMENT

; =============== S U B	R O U T	I N E =======================================

DELETE_PROMPT:
		mov	si,PROMPT_TEXT ; "PROMPT="

; ---------------------------------------------------------------------------

DELETE_NAME_IN_ENVIRONMENT:

; Input: DS:SI points to a "=" terminated string
; Output: carry flag is set if name not found
;	  otherwise name is deleted

		push	si
		push	ds
		call	FIND		; ES:DI points to name
		jc	short DEL1
		mov	si,di		; Save it
		call	SCASB2		; Scan for the nul
		xchg	si,di
;SR;
; If we have only one env string, then the double null is lost when the last
;string is deleted and we have an invalid empty environment with only a 
;single null. To avoid this, we will look for the double null case and then
;move an extra null char.
; Bugbug: The only possible problem is that the last pathstring 
;will be followed by a triple null. Is this really a problem?

		; MSDOS 6.0
		;cmp	byte ptr es:[si],0 ;null char?
		;jnz	not_dnull	   ;no, we are at a double null
		;dec	si		   ;point at the double null
;not_dnull:
		; MSDOS 3.3 (& MSDOS 6.0)
		call	GETENVSIZ
		sub	cx,si
		push	es
		pop	ds		; ES:DI points to name
					; DS:SI points to next name
		rep movsb
DEL1:
		pop	ds
		pop	si
FIND_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

FIND_PATH:
		mov	si,PATH_TEXT ; "PATH="
		jmp	short FIND_NAME_IN_ENVIRONMENT


; =============== S U B	R O U T	I N E =======================================

FIND_PROMPT:
		mov	si,PROMPT_TEXT ; "PROMPT="

; ---------------------------------------------------------------------------

FIND_NAME_IN_ENVIRONMENT:

; Input: DS:SI points to a "=" terminated string
; Output: ES:DI points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format

		call	FIND		; Find the name
		jc	short FIND_RETN	; Carry means not found	
		jmp	short SCASB1	; Scan for = sign

; ---------------------------------------------------------------------------
		;nop

; =============== S U B	R O U T	I N E =======================================

; On return of FIND1, ES:DI points to beginning of name

FIND:
		cld
		call	COUNT0		; CX = Length of name
		mov	es,[RESSEG]
		; assume es:RESGROUP
		mov	es,word [es:ENVIRSEG]
		; assume es:NOTHING
		xor	di,di
FIND1:	
		push	cx
		push	si
		push	di
FIND11:
		lodsb
		;call	UPCONV
		call	UPCONV_MAPCALL
		inc	di
		cmp	al,[es:di-1]
		jnz	short FIND12
		loop	FIND11
FIND12:
		pop	di
		pop	si
		pop	cx
		jz	short FIND_RETN
		push	cx
		call	SCASB2		; Scan for a nul
		pop	cx
		cmp	byte [es:di],0
		jnz	short FIND1
		stc			; Indicate not found
		retn

; =============== S U B	R O U T	I N E =======================================

COUNT0:
		push	ds
		pop	es
		; assume es:nothing
		mov	di,si
;COUNT1:
		push	di		; Count number of chars until "="
		call	SCASB1
		; 24/02/2023
		;jmp	short COUNTX
;COUNT2:
;		push	di		; Count number of chars until nul
;		call	SCASB2
;COUNTX:
		pop	cx
		sub	di,cx
		xchg	di,cx
MOVE_NAME_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

MOVE_NAME:
		cmp	byte [si],13
		jz	short MOVE_NAME_RETN
		lodsb
		;call	UPCONV
		call	UPCONV_MAPCALL
		call	STORE_CHAR
		cmp	al,'='
		jnz	short MOVE_NAME
GETARG_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

GETARG:
		mov	si,80h
		lodsb
		or	al,al
		jz	short GETARG_RETN
		call	SCANOFF
		cmp	al,13
SDN_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

; Point ES:DI to the final NULL string. Note that in an empty environment,
; there is NO double NULL, merely a string that is empty.

SCAN_DOUBLE_NULL:
		mov	es,[RESSEG]
		; ASSUME ES:RESGROUP
		mov	es,word [es:ENVIRSEG]
		; ASSUME ES:NOTHING
		xor	di,di

; Top cycle-point. If the string here is empty, then we are done

SDN1:
		cmp	byte [es:di],0	; nul string?
		jz	short SDN_RETN	; yep, all done
		call	SCASB2
		jmp	short SDN1

; =============== S U B	R O U T	I N E =======================================

SCASB1:
		mov	al,'='		; Scan for an =
		jmp	short SCASBX

; =============== S U B	R O U T	I N E =======================================

SCASB2:
		xor	al,al		; Scan for a nul

; ---------------------------------------------------------------------------

SCASBX:
		mov	cx,256
		repne scasb
		retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************

;assume	ds:trangroup			;AN000;
;
;upconv	proc	near			;AN000;
;
;	cmp	al,80h			;AN000;  see if char is > ascii 128
;	jb	oth_fucase		;AN000;  no - upper case math
;	sub	al,80h			;AN000;  only upper 128 chars in table
;	push	ds			;AN000;
;	push	bx			;AN000;
;	mov	ds,[resseg]		;AN000;  get resident data segment
;assume	ds:resgroup			;AN000;
;	lds	bx,dword ptr fucase_addr+1 ;AN000;  get table address
;	add	bx,2			;AN000;  skip over first word
;	xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
;	pop	bx			;AN000;
;	pop	ds			;AN000;
;assume	ds:trangroup			;AN000;
;	jmp	short upconv_end	;AN000;  we finished - exit
;
;oth_fucase:				;AN000;
;	cmp	al,small_a		;AC000; if between "a" and "z",
;	jb	upconv_end		;AC000;     subtract 20h to get
;	cmp	al,small_z		;AC000;    upper case equivalent.
;	ja	upconv_end		;AC000;
;	sub	al,20h			;AC000; Change lower-case to upper
;
;upconv_end:				;AN000;
;	ret
;
;upconv	endp				;AN000;

; ---------------------------------------------------------------------------

; MSDOS 3.3

UPCONV_MAPCALL:
					; If between "a" and "z"
		cmp	al,[small_a]
		jb	short UPCONV_END
		cmp	al,[small_z]
		ja	short UPCONV_END
		sub	al,20h		; Change lower-case to upper
UPCONV_END:
		call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
					  ; 	  for (current) country
		retn

; =============== S U B	R O U T	I N E =======================================

; STORE A CHAR IN environment, GROWING IT IF NECESSARY

STORE_CHAR:
		push	cx
		push	bx

		; 16/10/2018
		; MSDOS 6.0
		;PUSH	ES		;AN056;*
		;PUSH	DS		;AN056; Save local DS
		;MOV	DS,[RESSEG]	;AN056; Get resident segment
		;;ASSUME DS:RESGROUP	;AN056;
		;MOV	ES,[ENVIRSEG]	;AN056; Get environment segment
		;; ASSUME ES:NOTHING	;AN056;
		;POP	DS		;AN056; Get local segment back
		;; ASSUME DS:TRANGROUP	;AN056;

		; MSDOS 3.3 (& MSDOS 6.0)
		call	GETENVSIZ
		mov	bx,cx		; Save room for double nul	
		sub	bx,2
		cmp	di,bx
		jb	short STORE1

		push	ax
		push	cx
		push	bx		; Save Size of environment
		call	FREE_TPA
		pop	bx
		add	bx,2		; Recover true environment size

		cmp	bx,8000h	; Don't let environment grow > 32K	
		jb	short ENVSIZ_OK
BAD_ENV_SIZE:				;AN056;
		stc
		jmp	short ENVNOSET

		;nop
ENVSIZ_OK:
		mov	cl,4
		shr	bx,cl		; Convert back to paragraphs
		inc	bx

		; MSDOS 6.0
		;MOV	CX,ES		;AN056; Get environment segment
		;ADD	CX,BX		;AN056; Add in size of environment
		;ADD	CX,020H 	;AN056; Add in some TPA
		;MOV	AX,CS		;AN056; Get the transient segment
		;CMP	CX,AX		;AN056; Are we hitting the transient?
		;JNB	BAD_ENV_SIZE	;AN056; Yes - don't do it!!!

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	ah,SETBLOCK ; 4Ah
		int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
				; ES = segment address of block	to change
				; BX = new size	in paragraphs
ENVNOSET:
		pushf
		push	es
		mov	es,[RESSEG]
		;ASSUME ES:RESGROUP
		call	ALLOC_TPA
		pop	es
		popf
		pop	cx
		pop	ax
		;POP	ES	; MSDOS 6.0 ;AN056;*	
		jnc	short STORE1
		mov	dx,ENVERRPTR
		jmp	CERROR

STORE1:	
		stosb
		mov	word [es:di],0	; NULL IS AT END
		;POP	ES	; MSDOS 6.0 ;AN056;*
		pop	bx
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

GETENVSIZ:

;Get size of environment in bytes, rounded up to paragraph boundry
;ES has environment segment
;Size returned in CX, all other registers preserved

		push	es
		push	ax
		mov	ax,es
		dec	ax	;Point at arena	
		mov	es,ax
		mov	ax,word [es:ARENA.size]
		mov	cl,4
		shl	ax,cl	;Convert to bytes
		mov	cx,ax
		pop	ax
		pop	es
GETENVSIZ_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

RESTUDIR1:
		push	ds
		mov	ds,[RESSEG]
		;ASSUME	DS:RESGROUP
		cmp	byte [RESTDIR],0
		pop	ds
		;ASSUME	DS:TRANGROUP
		jz	short GETENVSIZ_RETN

; =============== S U B	R O U T	I N E =======================================

RESTUDIR:
		mov	dx,USERDIR1
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		xor	al,al
		call	SETREST
		retn

;============================================================================
; TENV2.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/10/2018 - Retro DOS v3.0

; TITLE	Part6 COMMAND Transient routines.

;	Environment utilities and misc. routines

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 $CHDIR
; *
; * FUNCTION:	 Entry point for CHDIR command. Parse the command
; *		 line. If path is found, CHDIR to path. If a drive
; *		 letter is found, get and display the current dir
; *		 of the specified drive. If nothing is found, get
; *		 and display the current dir of the default drive.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

_$CHDIR:
		; MSDOS 6.0
		;mov	si,81H
		;mov	di,offset trangroup:parse_chdir 
		;			;AN000; Get address of PARSE_CHDIR
		;xor	cx,cx		;AN000; clear cx,dx
		;xor	dx,dx		;AN000;
		;invoke	parse_with_msg	;AC018; call parser

		;cmp	ax,end_of_line	;AC000; are we at end of line?
		;jz	bwdJ		; No args
		;cmp	ax,result_no_error ;AC000; did we have an error?
		;jnz	ChDirErr	;AC018; yes - exit

		;cmp	parse1_type,result_drive ;AC000; was a drive entered?
		;jnz	REALCD		; no
;;
;; D: was found. See if there is anything more.
;;
		;mov	di,offset trangroup:parse_chdir 
					;AC000; get address of parse_chdir
		;xor	dx,dx		;AC000;
		;invoke	parse_check_eol ;AC000; call parser
		;jnz	ChDirErr	;AC000;
	;bwdJ:
		;invoke	build_dir_for_chdir ; Drive only specified
		;call	crlf2
		;return

		; MSDOS 3.3
		mov	ax,[COMSW]
		or	ax,[ALLSWITCH]
		mov	dx,BADPARMPTR
		jnz	short CHDIR_ERR
		mov	si,81h
		call	SCANOFF
		cmp	al,0Dh		; are we at end of line?
		je	short BWDJ	; No args
		inc	si
		lodsb
		cmp	al,':'
		jne	short REALCD
		push	si
		call	SCANOFF
		pop	si
		cmp	al,0Dh		; was a drive entered?
		jne	short REALCD	; no
BWDJ:
		call	BUILD_DIR_FOR_CHDIR ; Drive only specified
		call	CRLF2
CHDIR_RETN:
		retn

		; MSDOS 6.0
;REALCD:
		;push	si		;AN000; save position in line
		;lds	si,parse1_addr	;AN000; get address of filespec
		;invoke	move_to_srcbuf	;AN000; move to srcbuf
		;pop	si		;AN000; restore position in line
		;mov	di,offset trangroup:parse_chdir 
		;			;AC000; get address of parse_chdir
		;xor	dx,dx		;AC000;
		;invoke	parse_check_eol ;AC000; call parser
		;jnz	ChDirErr	;AC000;
		;
		;invoke	SETPATH
		;TEST	[DESTINFO],2
		;JNZ	BadChdir
		;MOV	AH,CHDIR
		;INT	21h
		;retnc
		;
		;invoke	get_ext_error_number
		;			;AN022; get the extended error
		;cmp	ax,error_path_not_found
		;			;AN022; see if path not found
		;jz	BadChDir	;AN022; yes - issue old message
;;SR;
;; We want to issue "Invalid Directory" message even if the path is valid
;;but is not a directory. The extended error returns "Access denied" which
;;is kind of confusing. Issue the old message if access denied error is 
;;returned
;;
		;cmp	ax,error_access_denied
		;jz	BadChDir
		;
		;call	Set_Ext_Error_Subst ;AN022;
		;jmp	short  chdirerr ;AN022;
;BadChDir:
		;MOV	DX,OFFSET TRANGROUP:BADCD_ptr
;ChDirErr:
		;invoke	Std_Eprintf
		;return

		; MSDOS 3.3
REALCD:
		call	SETPATH
		test	byte [DESTINFO],2
		jnz	short BADCHDIR
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		jnc	short CHDIR_RETN
BADCHDIR:
		mov	dx,BADCDPTR
CHDIR_ERR:
		call	STD_EPRINTF
MKDIR_RETN:
		retn

; ---------------------------------------------------------------------------

_$MKDIR:
		; MSDOS 6.0
		;CALL	SETRMMK
		;JC	MkDirErr
		;MOV	AH,MKDIR
		;INT	21h
		;retnc

		;invoke	get_ext_error_number	
		;			;AN022; get the extended error
		;cmp	ax,error_path_not_found 
		;			;AN022; see if path not found
		;jz	MD_other_err	;AN022; yes - issue old message
		;cmp	ax,error_access_denied
		;			;AN022; access denied?
		;jz	badmderr	;AN022; yes - see if file exists
		
		;call	Set_Ext_Error_Subst ;AN022;
		;jmp	short MkDirerr	;AC022; yes - go print it
;BADMDERR:
		;mov	dx,offset trangroup:srcxname	
		;			;AN006; Set Disk transfer address
		;mov	ah,Set_DMA	;AN006;
		;int	21h		;AN006;
		;MOV	AH,Find_First	;AN006; see if file/dir exists
		;mov	cx,attr_directory ;AN006;   search for directory
		;INT	21h		;AN006;
		;jc	MD_other_err	;AN006; doesn't exist - must be something else
		;mov	dl,srcxname.find_buf_attr ;AN006; we found a file/dir
		;test	dl,attr_directory ;AN006; was it a directory?
		;jz	MD_other_err	;AN006; no - must have been a file
		;mov	dx,offset trangroup:MD_exists_ptr 
		;			;AN006; set up already exists error
		;jmp	short MkDirErr	;AN006; make sure we didn't have network error
;MD_other_err:				;AN006;
		;MOV	DX,OFFSET TRANGROUP:BADMKD_ptr
;MkDirErr:
		;invoke	Std_Eprintf
		;return

		; MSDOS 3.3
		call	SETRMMK
		jb	short MKDIRERR
		mov	ah,MKDIR ; 39h
		int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
				; DS:DX	-> ASCIZ pathname (may include drive)
		jnc	short MKDIR_RETN
		mov	dx,BADMKDPTR
		call	GET_EXT_ERR_NUMBER
MKDIRERR:
		call	STD_EPRINTF
		retn

; =============== S U B	R O U T	I N E =======================================

; 	<Common MkDir/RmDir set up code>
;****************************************************************
;*
;* ROUTINE:	SETRMMK
;*
;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
;*		commands. Parses the command line for a required
;*		filespec.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	carry clear
;*		    DS:DX points to ASCIIZ argument
;*		carry set
;*		    DS:DX has error message pointer
;*
;****************************************************************

		; MSDOS 6.0
		;mov	si,81H
		;mov	di,offset trangroup:parse_mrdir 
					;AN000; Get adderss of PARSE_MRDIR
		;xor	cx,cx		;AN000; clear cx,dx
		;xor	dx,dx		;AN000;
		;invoke	parse_with_msg	;AC000; call parser
		;cmp	ax,result_no_error ;AC000; did we have an error?
		;jnz	 NOARGERR	;AC000; yes - exit

		;mov	di,offset trangroup:srcxname
		;			;AN000; get address of srcxname
		;push	di		;AN000; save address
		;push	si		;AN000; save position in line
		;lds	si,parse1_addr	;AN000; get address of path

;mrdir_move_filename:			;AN000; put filespec in srcxname
		;lodsb			;get a char from buffer
		;stosb			;AN000; store in srcxname
		;cmp	al,end_of_line_out ;AC000; it char a terminator?
		;jnz	mrdir_move_filename ;AC000; no - keep moving
		;pop	si		;AN000; get line position back
;;
;; we have scanned an argument.	See if any args beyond.
;;
		;mov	di,offset trangroup:parse_mrdir 
		;			;AC000; get address of parse_mrdir
		;invoke	parse_check_eol ;AC000; are we at end of line?
		;pop	dx		;AC000; get address of SRCXNAME
		;retz			;yes - return no error
;NOARGERR:
		;mov	dx,offset TranGroup:Extend_Buf_ptr
		;			;AC000; get extended message pointer
		;XOR	AX,AX
		;STC
		;return

		; MSDOS 3.3
SETRMMK:
		mov	si,81h
		call	SCANOFF
		cmp	al,0Dh
		je	short NOARGERR
		mov	dx,si
SETRMMK1:
		lodsb
		call	DELIM
		jz	short SETRMMK3
		cmp	al,0Dh
		jne	short SETRMMK1
		mov	byte [si-1],0
SETRMMK2:
		retn
SETRMMK3:
		mov	byte [si-1],0
		push	si
		call	SCANOFF
		pop	si
		cmp	al,0Dh
		je	short SETRMMK2
NOARGERR:
		mov	dx,BADARGSPTR
		xor	ax,ax
		stc
SETRMMK_RETN:
		retn

; ---------------------------------------------------------------------------

_$RMDIR:
		call	SETRMMK
		jb	short RMDIRERR
		jnz	short BADRDERR
		mov	ah,RMDIR ; 3Ah
		int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
				; DS:DX	-> ASCIZ pathname (may include drive)
		jnc	short SETRMMK_RETN

		; MSDOS 6.0
		;invoke	get_ext_error_number ;AN022; get the extended error
		;cmp	ax,error_path_not_found ;AN022; see if path not found
		;jz	badrderr	;AN022; yes - issue old message
		;cmp	ax,error_access_denied 	;AN022; access denied?
		;jz	badrderr	;AN022; yes - issue old message

		;call	Set_Ext_Error_Subst ;AN022;
		;jmp	short RmDirerr	;AC022; yes - go print it

		; MSDOS 3.3 (& MSDOS 6.0)
BADRDERR:
		mov	dx,BADRMDPTR
		call	GET_EXT_ERR_NUMBER
RMDIRERR:
		call	STD_EPRINTF
RMDIR_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;****************************************************************
;*
;* ROUTINE:	Set_ext_error_subst
;*
;* FUNCTION:	Sets up substitution for extended error
;*
;* INPUT:	AX - extended error number
;*		DX - offset of string
;*
;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
;*
;****************************************************************

;Set_ext_error_subst  proc near		;AN022;
;
;	mov	msg_disp_class,ext_msg_class
;					;AN022; set up extended error msg class
;	mov	string_ptr_2,dx 	;AN022; get address of failed string
;	mov	Extend_buf_sub,one_subst 
;					;AN022; put number of subst in control block
;	mov	dx,offset TranGroup:Extend_Buf_ptr 
;					;AN022; get extended message pointer
;	mov	Extend_Buf_ptr,ax	;AN022; get message number in control block
;
;	ret				;AN022; return
;
;Set_ext_error_subst  endp		;AN022;

; =============== S U B	R O U T	I N E =======================================

; <SavUDir - preserve the users current directory on a particular drive>

; SavUDir - move the user's current directory on a drive into UserDir1
; SavUDir1 - move the user's current directory on a drive into a specified
;   buffer
;
;   Inputs:	DL has 1-based drive number
;		ES:DI has destination buffer (SavUDir1 only)
;   Outputs:	Carry Clear
;		    DS = TranGroup
;		Carry Set
;		    AX has error code
;   Registers Modified: AX, SI

SAVUDIR:
		mov	di,USERDIR1

; ---------------------------------------------------------------------------

SAVUDIR1:
		mov	al,dl
		add	al,'@'
		cmp	al,'@'
		jnz	short GOTUDRV
		add	al,[CURDRV]
		inc	al		; A = 1
GOTUDRV:
		stosb
		mov	ah,[DIRCHAR]
		mov	al,':'
		stosw
		push	es
		pop	ds
		mov	si,di
		mov	ah,CURRENT_DIR	; 47h
		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
				; DL = drive (0=default,1=A,etc.)
				; DS:SI	points to 64-byte buffer area
		jc	short RMDIR_RETN
		push	cs
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

CRLF2:
		push	dx
		mov	dx,ACRLFPTR
		push	ds
		push	cs
		pop	ds
		call	STD_PRINTF
		pop	ds
		pop	dx
		retn

; =============== S U B	R O U T	I N E =======================================

; These routines (SCANOFF, DELIM) are called in batch processing when DS
; may NOT be TRANGROUP

SCANOFF:
		lodsb
		call	DELIM
		jz	short SCANOFF
		dec	si		; Point to first non-delimiter
SCANOFF_RETN:
		retn

; ---------------------------------------------------------------------------

; Input:    AL is character to classify
; Output:   Z set if delimiter
;	    NZ set otherwise
; Registers modified: none

DELIM:
		cmp	al,' '
		jz	short SCANOFF_RETN
		cmp	al,'='
		jz	short SCANOFF_RETN
		cmp	al,','
		jz	short SCANOFF_RETN
		cmp	al,';'
		jz	short SCANOFF_RETN
		cmp	al,9		; Check for TAB character
		jz	short SCANOFF_RETN
		cmp	al,0Ah		; Check for line feed character - BAS
		retn


; =============== S U B	R O U T	I N E =======================================

FCB_TO_ASCZ:				; Convert DS:SI to ASCIZ ES:DI
		mov	cx,8
MAINNAME:
		lodsb
		cmp	al,' '
		jz	short SKIPSPC
		stosb
SKIPSPC:
		loop	MAINNAME
		lodsb
		cmp	al,' '
		jz	short GOTNAME
		mov	ah,al
		;mov	al,'.'
		mov	al,[DOT_CHR]
		stosb
		xchg	al,ah
		stosb
		mov	cl,2
EXTNAME:
		lodsb
		cmp	al,' '
		jz	short GOTNAME
		stosb
		loop	EXTNAME
GOTNAME:
		xor	al,al
		stosb
STRCOMP_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

; Compare ASCIZ DS:SI with ES:DI.
; SI,DI destroyed.

STRCOMP:	
		cmpsb
		jnz	short STRCOMP_RETN ; Strings not equal
		cmp	byte [si-1],0	; Hit NUL terminator?	
		jz	short STRCOMP_RETN ; Yes, strings equal
		jmp	short STRCOMP	; Equal so far, keep going

; =============== S U B	R O U T	I N E =======================================

CRPRINT:
		push	ax
		;mov	al,13
		mov	al,0Dh
		push	cx
		push	di
		mov	di,dx
		mov	cx,65535
		push	es
		push	ds
		pop	es
		repne scasb		; LOOK FOR TERMINATOR
		mov	byte [di-1],0	; nul terminate the string
		pop	es
		mov	[STRING_PTR_2],dx
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
		;mov	byte [di-1],13
		mov	byte [di-1],0Dh	; now put the CR back
		jb	short ERROR_OUTPUT
		pop	di
		pop	cx
		pop	ax
		retn

; ---------------------------------------------------------------------------

ERROR_OUTPUT:
		push	cs
		pop	ds
		mov	es,[RESSEG]
		mov	dx,NOSPACEPTR
		cmp	byte [es:PIPEFLAG],0
		jz	short GO_TO_ERROR
		call	PIPEOFF
		mov	dx,PIPEEMESPTR
GO_TO_ERROR:
		jmp	CERROR

; =============== S U B	R O U T	I N E =======================================

;---- Mod for path invocation ----

PATHCHRCMP:
		push	ax
		mov	ah,'/'
		cmp	[SWITCHAR],ah
		jz	short NOSLASHT
		cmp	al,'/'
		jz	short PCCONT
NOSLASHT:
		cmp	al,'\'
PCCONT:	
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; PATHCRUNCH -
;
; ENTRY FCB (in PSP) contains drive # to crunch on
;       PathPos = ptr to string with pathname in it
;       PathCnt = length of string
;
; EXIT  PathPos = ptr after pathname (w/ NULL) in string
;       PathCnt = length left in string
;       DestIsDir = nonzero if pathname delimiter char's found in pathname
;       DestInfo<bit1> = set if wildcard char's found in pathname
;       If path crunched successfully,
;         CY = clear
;         Current directory is changed to directory in pathname
;         UserDir1 contains previous directory for use by RestUDir
;         RestDir = nonzero to flag later restoration of user's dir
;         DestTail = ptr to beginning of filename
;         If filename found in pathname,
;           ZR = clear
;           FCB filename fields contain filename
;         If filename not found (pure directory path),
;           ZR = set
;           FCB filename fields are wildcarded with ?'s
;       If pathcrunch failed (no ChDir's worked),
;         CY = set
;         Msg_Numb = extended error code
;
; NOTE  DIR asks PathCrunch to forego parsing the filename into the
;       FCB by setting DirFlag.  In this case, the FCB is returned
;       with the filename wildcarded.

PATHCRUNCH:
		; MSDOS 6.0
		;mov     [msg_numb],0	;AN022; Set up message flag
		; MSDOS 3.3 (& MSDOS 6.0)
		;mov	dl,[5CH]
		mov	dl,[FCB]	; DL = drive # (1 = A)
		call	SAVUDIR		; save current directory in UserDir1
		call	SETPATH
		; MSDOS 6.0
 		;jc	pcrunch_cderrJ	;AN022; if error on current dir - report

;       DX = ptr to pathname, NULL-terminated
;       PathPos = ptr to byte after NULL at end of pathname

		; MSDOS 3.3 (& MSDOS 6.0)
		test	byte [DESTINFO],2 ; test if wildcards (? or *) seen
		jnz	short TRYPEEL	; wildcard seen, peel filename

		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		; MSDOS 6.0
		;jnc	chdir_worked            ;AN022; no error - continue
		;
		;invoke	get_ext_error_number    ;AN022; get the extended error
		;cmp	ax,error_path_not_found ;AN022; if path not found
		;jz	trypeel                 ;AC022;     keep trying
		;cmp	ax,error_access_denied  ;AN022; if access denied
		;jz	trypeel                 ;AC022;     keep trying
		;mov	[msg_numb],ax           ;AN022; set up message flag
		;jmp	peelfail                ;AN022; exit with other error

		; MSDOS 3.3
		jc	short TRYPEEL
;chdir_worked:
		; MSDOS 3.3 (& MSDOS 6.0)
		call	SETREST1	; set 'Restore Directory' flag true
		mov	al,'?'		; if pure dir, wildcard filename in FCB
		mov	di,5Dh
		mov	cx,11
		rep stosb
		xor	al,al		; return carry clear, zero set
		retn
;pcrunch_cderrj: 			;AN022; need this for long jmp
		;jmp	pcrunch_cderr	;AN022;
TRYPEEL:
		mov	si,[PATHPOS]
		dec	si		; SI = ptr to NULL at end of pathname
		mov	al,[si-1]	; AL = last char of pathname	
		call	PATHCHRCMP
		jz	short PEELFAIL
DELLOOP:
		cmp	si,dx
		jz	short BADRET
		mov	al,[si]
		call	PATHCHRCMP
		jz	short TRYCD
		dec	si
		jmp	short DELLOOP
TRYCD:
		push	ax
		;mov	al,'.'
		mov	al,[DOT_CHR]	; AL = '.'
		; MSDOS 6.0
		;cmp	byte ptr [SI+1],al ; check for '.' after path delim
					;M019; allow continuation if '. ' or 
					;M019; '..' is not found.
		;jnz	@f		;M019; '.' not found
		;cmp	byte ptr [SI+2],al ;M019; check for '..'
		;jz	@f		;M019; found '..'
		;cmp	byte ptr [SI+2],0 ;M019; check for '. ' (null terminated)
;@@:		;pop     ax
		;jz      PEELFAIL	; if . or .., pure cd should have worked

		; MSDOS 3.3
		cmp	[si+1],	al	; check for '.' after path delim
		pop	ax
		jz	short PEELFAIL	; if . or .., pure cd should have worked

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	al,[si-1]	; Special case d:\file	
		cmp	al,':'
		jz	short BADRET
		call	PATHCHRCMP
		jnz	short NODOUBLESL
PEELFAIL:
		stc
		retn
NODOUBLESL:
		mov	byte [si],0
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		jnc	short CDSUCC

		; MSDOS 6.0
;pcrunch_cderr:
		;invoke	get_ext_error_number ;AN022; get the extended error
		;mov	[msg_numb],ax	;AN022; set up message flag
		;or	si,si		;AN022; set up zero flag to not zero
		;stc			;AN022; set up carry flag
		;return
		
		; MSDOS 3.3
PATHCRUNCH_RETN:
		retn

BADRET:
		mov	al,[si]
		call	PATHCHRCMP
		stc
		jnz	short PATHCRUNCH_RETN
		xor	bl,bl
		xchg	bl,[si+1]
		mov	ah,CHDIR ; 3Bh
		int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short PATHCRUNCH_RETN
		mov	[si+1],	bl
CDSUCC:
		call	SETREST1
		inc	si
		mov	[DESTTAIL],si
		; MSDOS 6.0
		;pushf			;AN015; save flags
		;cmp	dirflag,-1	;AN015; don't do parse if in DIR
		;jz	pcrunch_end	;AN015;
		;MOV	DI,FCB
		;MOV	AX,(PARSE_FILE_DESCRIPTOR SHL 8) OR 02H 
					; Parse with default drive
		;INT	21h
;pcrunch_end:
		;popf			;AN015; get flags back
		;return

		; MSDOS 3.3
		mov	di,FCB ; 5Ch
		mov	ax,(PARSE_FILE_DESCRIPTOR<<8)|2 ; 2902h
		int	21h	; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
		retn

;============================================================================
; TMISC1.ASM, MSDOS 6.0, 1991
;============================================================================
; 05/10/2018 - Retro DOS v3.0

;TITLE	Part7 COMMAND Transient Routines

;	More misc routines

;---------------------------
; We can get rid of this switch processing code if we can take
; care of the remaining two calls to switch, later in the file.
; However, I have not checked whether or not any other files use
; switch -- after all, it IS public!
;---------------------------

;SWCOUNT EQU  6  ; MSDOS 6.0		; Length of switch_list
SWCOUNT	 EQU  5  ; MSDOS 3.3	

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h

; ---------------------------------------------------------------------------

RETSW:		xchg	ax,bx		; Put switches in AX
		retn

; =============== S U B	R O U T	I N E =======================================

SWITCH:
		xor	bx,bx		; Initialize - no switches set
SWLOOP:
		call	SCANOFF		; Skip any delimiters
		cmp	al,[SWITCHAR]	; Is it a switch specifier?
		jnz	short RETSW	; No -- we're finished
		;or	bx,8000h
		or	bx,FSWITCH	; Indicate there is a switch specified
		inc	si		; Skip over the switch character
		call	SCANOFF
		cmp	al,0Dh
		je	short RETSW	; Oops
		inc	si

		; Convert lower case input to upper case

		;call	UPCONV
		call	UPCONV_MAPCALL

		mov	di,SWITCH_LIST	; "VBAPW" (for MSDOS 3.3)
					; ("?VBAPW" (for MSDOS 6.0))				
		;mov	cx,5  ; MSDOS 3.3
		mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
		
		;nop
		
		repne scasb		; Look for matching switch
		jnz	short BADSW
		mov	ax,1
		shl	ax,cl		; Set a bit for the switch
		or	bx,ax
BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
		jmp	short SWLOOP

;BADSW:
		;jmp	short SWLOOP

DRVBAD:
		mov	dx,BADDRVPTR
		jmp	CERROR

EXTERNALJ:
		jmp	EXTERNAL

FNDCOM:					; search the internal command table
		or	al,al		; Get real length of first arg
		jz	short EXTERNALJ	; If 0, it must begin with "\" so has
					;  to be external.
; barryf code starts here

		call	TEST_APPEND	; see if APPEND installed
		jz	short CONTCOM	; not loaded

APPEND_INTERNAL:			; CODE XREF: PROMPTBAT+16FCj
		mov	cl,[IDLEN]
		mov	ch,0
		mov	[PATHPOS],cx
		
		; MSDOS 6.0
		;inc 	append_exec	;AN041; set APPEND to ON

		call	IOSET		; re-direct the o'l io

		mov	si,IDLEN	; address command name, DS already set	
		mov	dx,-1 ; 0FFFFh	; set invoke function
		
		; MSDOS 6.0
		;mov	di,offset TRANGROUP:APPEND_PARSE
					;AN010; Get the entry point for PARSE for APPEND
		; MSDOS 3.3 (& MSDOS 6.0)
		mov	ax,0AE01h
		int	2Fh	; - Multiplex -	DOS 3.3+ internal
				; - INSTALLABLE	COMMAND	- EXECUTE
				; DX = FFFFh,[SI -> buffer
				; Return: buffer at DS:SI filled with a	length byte
				;		 followed by the uppercase
				; internal command to execute (if length not 0)
		cmp	byte [IDLEN],0 ; execute requested
		jne	short CONTCOM
		jmp	short CMD_DONE

		;nop
CONTCOM:				; continue with internal scan
		mov	di,COMTAB
		xor	cx,cx
FINDCOM:
		mov	si,ID		; pointer to command argument
		mov	cl,[di]		; load length of internal command
		inc	di		; advance past length
		jcxz	EXTERNALJ 	; if it's zero, we're out of internals
		cmp	cl,[IDLEN]	; that of the command argument
		jne	short ABCD	; lengths not equal ==> strings not eq
		mov	[PATHPOS],cx	; store length of command
		repe cmpsb
ABCD:					
		lahf			; save the good ol' flags
		add	di,cx		; skip over remaining internal, if any
		mov	al,[di]		; load drive-check indicator byte (DCIB)
		mov	[CHKDRV],al	; save command flag byte in chkdrv
		inc	di		; increment DI (OK, OK, I'll stop)
		mov	bx,[di]		; load internal command address
		inc	di		; skip over the puppy
		inc	di
		
		; MSDOS 6.0
		;mov     DX, WORD PTR [DI] ; load ptr to help msg #s
		;inc     DI
		;inc     DI
		;sahf			; remember those flags?
		;jnz     findcom	; well, if all the cmps worked...
;;
;; All messages get redirected.
;;
		;cmp     append_exec,0	;AN041; APPEND just executed?
		;jnz     dont_set_io 	;AN041; Yes - this junk is already set
		;invoke  ioset		; re-direct the ol' i/o

;dont_set_io:					;AN041;
;;
;; Check for /?.  Certain commands, flagged fLimitHelp,
;; respond to /? only if it is the only command-line argument.
;;
		;mov     ax,[COMSW]	; AX = switches after command
		;or      ax,[ALLSWITCH]	; AX = all switches
		;and     ax,SwitchQues	
		;jz      drive_check	; /? not in command line
		;	
		;test    [CHKDRV],fLimitHelp
		;jz      do_help	; /? allowed in combination
;;
;; Make sure /? is the only argument on the command line.
;;
		;cmp     [arg.argvcnt],2
		;jne     drive_check	; /? not only arg - ignore
;;
;; Note:  this is all the check we need, even against things like /??.
;; Our argv parser breaks /?? into two args, /? and ?.
;;

;do_help:
;
; DX = ptr to word list of msg #s, terminated by zero word

		;mov     si,dx		; SI = ptr to list of msg #s
    		;mov     ax,NO_SUBST	; AL = no subst's code
		;push    ax		; build subst block on stack

;next_help_msg:
		;lodsw			; AX = help msg # or zero
		;or      ax,ax
		;jz      help_done
		;push    ax		; SS:SP = ptr to subst block
					;  (msg # and no_subst byte)
;; We assume DS = SS.

    		;mov     dx,sp		; DS:DX = ptr to subst block
    		;invoke  Std_PrintF	; display help message
    		;pop     ax		; remove msg # from stack
   		;jmp     next_help_msg

;help_done:
		;pop     ax		; clean up stack
		;jmp     TCommand	

		; MSDOS 3.3
		sahf			; remember those flags?
		jnz	short FINDCOM	; well, if all the cmps worked...
		call	IOSET		; re-direct the ol' i/o

DRIVE_CHECK:
		;test	byte [CHKDRV],1
		test	byte [CHKDRV],FCHECKDRIVE 
					; did we wanna check those drives?
		jz	short NOCHECK
		mov	al,[PARM1]	; parse_file_descriptor results tell
		or	al,[PARM2]	; us whether those drives were OK
		cmp	al,-1
		jnz	short NOCHECK
		jmp	short DRVBAD

; The user may have omitted the space between the command and its arguments.
; We need to copy the remainder of the user's command line into the buffer.
; Note that thisdoes not screw up the arg structure; it points into COMBUF not
; into the command line at 80.

NOCHECK:
		call	CMD_COPY
SWITCHECK:
		;test	byte [CHKDRV],2
		test	byte [CHKDRV],FSWITCHALLOWED 
					; Does the command take switches
		jnz	short REALWORK	; Yes, process the command
		call	NOSWIT		; No, check to see if any switches
		jnz	short REALWORK	; None, process the command

		; MSDOS 6.0
		;mov	msg_disp_class,parse_msg_class	
		;			;AN000; set up parse error msg class
		;MOV	DX,OFFSET TranGroup:Extend_Buf_ptr	
		;			;AC000; get extended message pointer
		;mov	Extend_Buf_ptr,BadSwt_ptr		
		;			;AN000; get "Invalid switch" message number
		;jmp	CERROR		; Print error and chill out...

		; MSDOS 3.0
		mov	dx,BADPARMPTR
		jmp	CERROR

REALWORK:
		call	bx		; do some real work, at last

; See if we're in a batch CALL command. If we are, reprocess the command line,
; otherwise, go get another command.

CMD_DONE:
		push	cs		; g  restore data segment
		pop	ds		; g
		push	ds
		mov	ds,[RESSEG]	; g  save data segment
		;cmp	byte [CALL_FLAG],1 ; G  Is a call in progress?
		cmp	byte [CALL_FLAG],call_in_progress
		mov	byte [CALL_FLAG],0 ; G  Either way, reset flag
		pop	ds		; g  get data segment back
		jz	short INCALL	; G
		jmp	TCOMMAND	; chill out...
INCALL:
		jmp	DOCOM1

; =============== S U B	R O U T	I N E =======================================

NOSWIT:
		push	di		; Save di
		mov	di,81h		; di = ptr to command args
		mov	si,80h		; Get address of length of command args
		lodsb			; Load length
		mov	cl,al		; Move length to cl
		xor	ch,ch		; Zero ch
		mov	al,[cs:SWITCHAR] ; al = switch character
		cmp	al,0		; Turn off ZF
		repne scasb		; Scan for a switch character and return
		pop	di		;  with ZF set if one was found
		retn

; ---------------------------------------------------------------------------

EXTERNAL:
		call	TEST_APPEND	; check to see if append installed
		jz	short NOT_BARRYF ; no - truly external command
		jmp	APPEND_INTERNAL	; yes - go to Barryf code

		; 25/02/2023
BATCOMJ:
		jmp	BATCOM

NOT_BARRYF:
		mov	byte [cs:FILTYP],0
		mov	dl,[cs:SPECDRV]
		mov	[cs:IDLEN],dl
		mov	byte [cs:ROM_CALL],0
		push	dx
		mov	dx,IDLEN
		call	ROM_SCAN
		pop	dx
		;jnc	short POSTSAVE
		jnc	short DO_SCAN
		inc	byte [cs:ROM_CALL]
		;jmp	short POSTSAVE

		;nop
DO_SCAN:
POSTSAVE:
		mov	di,EXECPATH
		mov	byte [di],0	; Initialize to current directory
	
		cmp	byte [cs:ROM_CALL],0
		;jz	short RESEARCH
		;jmp	short NEOEXECUTE
		; 25/02/2023
		jnz	short NEOEXECUTE		

		;nop
RESEARCH:
		call	PATH_SEARCH	; find the mother (result in execpath)
		or	ax,ax		; did we find anything?
		;jz	short BADCOMJ45	; null means no (sob)
		; 25/02/2023
		jz	short BADCOM
		cmp	ax,4		; 04H and 08H are .exe and .com
					; fuckin' sixteen-bit machine ought
		jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
					; DISPLACEMENT!!
		; 25/02/2023
		;;jmp	short NEOEXECUTE
		;jmp	short EXECUTE	


		; 02H is .bat

		;nop

		; 25/02/2023
;BATCOMJ:
;		jmp	BATCOM
;
;BADCOMJ45:
;		jmp	short BADCOM

		;nop
EXECUTE:
NEOEXECUTE:
		call	IOSET

; MSDOS 6.0
;M051
; Previously LoadHigh was jumping to the execute label above. This was wrong
;because IOSET was getting invoked twice resulting in 2 sets of redirections.
;After a close, this would still leave one open active resulting in sharing
;errors on subsequent opens of the redirected file.
;
;LH_EXECUTE:				;M051	
		mov	es,[TRAN_TPA]
		mov	ah,DEALLOC ; 49h
		int	21h	; DOS -	2+ - FREE MEMORY
				; ES = segment address of area to be freed
					; Now running in "free" space
		mov	es,[RESSEG]
		inc	byte [es:EXTCOM] ; Indicate external command
		mov	byte [es:RESTDIR],0 
					; Since USERDIR1 is in transient, insure
					; this flag value for re-entry to COMMAND
		; MSDOS 6.0
		;MOV	SI,OFFSET TRANGROUP:EXECPATH
		;MOV	DI,OFFSET RESGROUP:SAFEPATHBUFFER
		;MOV	CX,LenMsgOrPathBuf
		;CLD
		;REP	MOVSB		; copy program pathname to resident

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	di,FCB ; 5Ch
		mov	si,di
		mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
		rep movsw		; Transfer parameters to resident header
		mov	dx,EXECPATH
		;MOV	BX,OFFSET RESGROUP:EXEC_BLOCK
		mov	bx,EXEC_BLOCK
		mov	ax,EXEC*256 ; 4B00h
		test	byte [ROM_CALL],-1 ; 0FFh
		jz	short OK_EXEC
		jmp	ROM_EXEC
OK_EXEC:
;
; we are now running in free space. Anything we do from here on may get
; trashed. Move the stack (also in free space) to allocated space because
; since EXEC restores the stack, somebody may trash what is on the stack.
;
		mov	cx,es
		mov	ss,cx
		mov	sp,RSTACK
		jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident

; ---------------------------------------------------------------------------

BADCOM:
		push	cs
		pop	ds
		mov	dx,BADNAMPTR
CERROR:		
		call	STD_EPRINTF
		jmp	TCOMMAND


; =============== S U B	R O U T	I N E =======================================

; Prescan converts the input buffer into a canonicalized form.
; All redirections and pipes are removed.

PRESCAN:
		xor	cx,cx
		mov	es,[RESSEG]
		mov	si,COMBUF+2
		mov	di,si
COUNTQUOTES:
		lodsb			; get a byte
		cmp	al,22h		; is it a quote?
		jne	short COUNTEND	; no, try for end of road
		inc	ch		; bump count
		jmp	short COUNTQUOTES ; go get next char
COUNTEND:
		cmp	al,0Dh		; end of road?
		jne	short COUNTQUOTES ; no, go back for next char
		mov	si,di		; restore pointer to begining
PRESCANLP:
		lodsb
		cmp	al,'"'		; " character
		jne	short TRYGREATER
		dec	ch
		jz	short TRYGREATER
QLOOP:
		mov	[di],al
		inc	di
		inc	cl
		lodsb
		cmp	al,'"'		; " character
		jne	short QLOOP
		dec	ch
TRYGREATER:
		cmp	al,[RABRACKET]
		jne	short NOOUT

; We have found a ">" char. We need to see if there is another ">"
; following it.

		cmp	[si],al
		jnz	short NOAPPND
		lodsb
		inc	byte [es:RE_OUT_APP] ; Flag >>
NOAPPND:
; Now we attempt to find the file name. First, scan off all whitespace

		call	SCANOFF

		; MSDOS 6.0
		;CMP	AL,[LABRACKET]	   ;AN040; was there no filename?
		;Je	short REOUT_ERRSET ;AN040; yes - set up error

		; MSDOS 3.3 (& MSDOS 6.0)
		cmp	al,0Dh
		jnz	short GOTREOFIL

; There was no file present.  Set us up at end-of-line.

REOUT_ERRSET:				;AN040; set up for an error
		mov	byte [di],0Dh	; Clobber first ">"
		mov	word [es:RE_OUTSTR],9 ; Cause an error later
		jmp	PRESCANEND

GOTREOFIL:
		push	di
		;MOV	DI,OFFSET RESGROUP:RE_OUTSTR
		mov	di,RE_OUTSTR
		mov	bx,di
		push	es

		; MSDOS 6.0
SETREOUTSTR:				; Get the output redirection name
					; MSKK06 07/14/89
		;push	cx		; save cx
		;mov	cx,64+13	; CX = max string length
;SETREOUTSTR_LOOP:
		;LODSB
		;CMP	AL,0DH
		;JZ	GOTRESTR_J
		;INVOKE	DELIM
		;JZ	GOTRESTR_J
		;CMP	AL,[SWITCHAR]
		;JZ	GOTRESTR_J
		;CMP	AL,'"'		;AN033; Is the character a quote?
		;JZ	PIPEERRSYNJ5_J	;AN033; Yes - get out quick - or system crashes
		;CMP	AL,labracket	;AN002; Is char for input redirection
		;JZ	ABRACKET_TERM	;AN002; yes - end of string
		;CMP	AL,rabracket	;AN002; Is char for output redirection
		;JNZ	NO_ABRACKET	;AN002; no - not end of string
;ABRACKET_TERM:				;AN002; have end of string by < or >
		;DEC	SI		;AN002; back up over symbol
		;MOV	AL,BLANK	;AN002; show delimiter as char
;GOTRESTR_J:
		;pop	cx		; MSKK06 07/14/89
		;JMP	SHORT GOTRESTR	;AN002; go process it
;NO_ABRACKET:				;AN002; NOT AT END OF STRING
		;STOSB			; store it into resgroup
		;LOOP	SETREOUTSTR_LOOP ; MSKK06 07/14/89
		;jmp	GOTRESTR_j
;PIPEERRSYNJ5_J:
		;pop	cx		; recover CX
		;jmp	short PIPEERRSYNJ5

		; MSDOS 3.3
SETREOUTSTR_LOOP:			; Get the output redirection name
		lodsb
		cmp	al,0Dh
		jz	short GOTRESTR
		call	DELIM
		jz	short GOTRESTR
		cmp	al,[SWITCHAR]
		je	short GOTRESTR
		cmp	al,'"'
		jne	short NO_ABRACKET
		dec	ch
NO_ABRACKET:
		stosb
		jmp	short SETREOUTSTR_LOOP
NOOUT:
		; MSDOS 3.3 (& MSDOS 6.0)
		cmp	al,[LABRACKET]
		jnz	short CHKPIPE
		mov	bx,si		; Save loc of "<"
		call	SCANOFF
		; MSDOS 6.0
		;CMP	AL,[RABRACKET]	;AN040; was there no filename?
		;jz	short REIN_ERRSET ;AN040; yes - set up error
		; MSDOS 3.3 (& MSDOS 6.0)
		cmp	al,0Dh
		jnz	short GOTREIFIL
REIN_ERRSET:				;AN040; set up for error
		mov	byte [di],0Dh		; Clobber "<"
		mov	word [RE_INSTR],9	; Cause an error later
		jmp	short PRESCANEND
GOTREIFIL:
		push	di
		mov	di,RE_INSTR
		mov	bx,di
		push	es
		push	cs
		pop	es		; store in TRANGROUP
		jmp	short SETREOUTSTR_LOOP 
					; Get the input redirection name
CHKPIPE:
		mov	ah,al
		;cmp	ah,'|'
		cmp	ah,ALTPIPECHR
		je	short ISPIPE3
		cmp	ah,[VBAR]
		jne	short CONTPRESCAN
ISPIPE3:
; Only push the echo flag if we are entering the pipe for the first time.

		cmp	byte [es:PIPEFLAG],0
		jne	short NOECHOPUSH
		shl	byte [es:ECHOFLAG],1 ; push echo state and turn it off
NOECHOPUSH:
		inc	byte [es:PIPEFLAG]
		call	SCANOFF
		cmp	al,0Dh
		jz	short PIPEERRSYNJ5
		;cmp	al,'|'
		cmp	al,ALTPIPECHR
		jz	short PIPEERRSYNJ5
		cmp	al,[VBAR]	; Double '|'?	
		jnz	short CONTPRESCAN

PIPEERRSYNJ5:
		push	es
		pop	ds
		jmp	PIPEERRSYN

; Trailing :s are allowed on devices. Check to be sure that there is more
; than just a : in the redir string.

GOTRESTR:
		xchg	ah,al
		mov	al,':'
		sub	bx,di		; compute negative of number of chars
		cmp	bx,-1		; is there just a :?
		je	short NOTRAILCOL ; yep, don't change
		cmp	[es:di-1],al	; Trailing ':' OK on devices
		jne	short NOTRAILCOL
		dec	di		; Back up over trailing ':'
NOTRAILCOL:
		xor	al,al
		stosb			; NUL terminate the string
		pop	es
		pop	di		; Remember the start
CONTPRESCAN:
		mov	[di],ah		; "delete" the redirection string
		inc	di
		cmp	ah,0Dh
		je	short PRESCANEND
		inc	cl
		jmp	PRESCANLP
PRESCANEND:
		cmp	byte [es:PIPEFLAG],0
		je	short ISNOPIPE
		;MOV	DI,OFFSET RESGROUP:PIPESTR
		mov	di,PIPESTR
		mov	word [es:PIPEPTR],di
		mov	si,COMBUF+2
		call	SCANOFF
PIPESETLP:				; Transfer the pipe into the resident
		lodsb			; pipe buffer
		stosb
		cmp	al,0Dh
		jnz	short PIPESETLP
ISNOPIPE:
		mov	[COMBUF+1],cl
		cmp	byte [es:PIPEFLAG],0
		push	cs
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

CMD_COPY:
		mov	si,COMBUF+2
		call	SCANOFF		; advance past separators...
		add	si,[PATHPOS]
		mov	di,81h
		xor	cx,cx
CMDCOPY:
		lodsb
		stosb
		cmp	al,0Dh
		je	short COPY_DONE
		inc	cx
		jmp	short CMDCOPY
COPY_DONE:
		mov	[80h],cl
		retn

; =============== S U B	R O U T	I N E =======================================

TEST_APPEND:
		mov	bx,COMBUF	; barry can address
		mov	si,IDLEN	; address command name, DS already set 	
		mov	dx,-1
		mov	ax,0AE00h
		int	2Fh	; - Multiplex -	DOS 3.3+ internal 
				; - INSTALLABLE	COMMAND	- INSTALL CHECK
				; DX = FFFFh,[BX -> command line
				; Return: AL = FFh if this command is a TSR extension 
				;		   to COMMAND.COM
				; AL = 00h if the command should be executed as	usual
		cmp	al,0
		retn

;============================================================================
; TMISC2.ASM, MSDOS 6.0, 1991
;============================================================================
; 05/10/2018 - Retro DOS v3.0

;	More misc routines

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh

; =============== S U B	R O U T	I N E =======================================

SETPATH:

; ENTRY PathPos = ptr to string
;       PathCnt = length of string
;
; EXIT  PathPos = ptr to string after pathname
;       PathCnt = length of rest of string
;       DX = ptr to pathname in string, made ASCIIZ
;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
;
;       A null character is dropped at the end of the pathname. If the
;       character in that spot previously was CR, it is copied into the
;       following byte. So there must be at least two two character 
;       positions in the buffer following the pathname.

		; MSDOS 6.0
		;mov	ax,[PATHCNT]	;AC000; get length of string
		;mov	si,[PATHPOS]	;AC000; get start of source buffer

		; MSDOS 3.3
		mov	si,80h
		lodsb
		xor	ah,ah
		mov	[PATHCNT],ax
		mov	[PATHPOS],si
GETPATH:
		; MSDOS 3.3 (& MSDOS 6.0)
		mov	byte [DESTINFO],0
		mov	byte [DESTVARS],0
		mov	si,[PATHPOS]	; SI = ptr to string
		mov	cx,[PATHCNT]	; CX = string length
		mov	dx,si		; DX = ptr to string
		jcxz	PATHDONE	; string length is zero, we're done
		push	cx		; save string length
		push	si		; save ptr to string
		call	SWITCH

;       After Switch, SI has been scanned past any switches, and
;       switches that COMMAND intrinsically recognizes are recorded in AX.

		mov	[PATHSW],ax	; PathSw = switch occurrence mask
		pop	bx		; BX = ptr to original string
		sub	bx,si		; BX = -(# chars scanned by Switch)
		pop	cx		; CX = string length
		add	cx,bx		; CX = string length from current SI
		mov	dx,si		; DX = ptr to current string
SKIPPATH:
		jcxz	PATHDONE	; string length is zero, we're done
		dec	cx		; CX = length left after next char
		lodsb			; AL = next char of string
					; SI = ptr to char after this one
		call	PATHCHRCMP	; compare AL to path delimiter char
		jnz	short TESTPMETA	; it's not a path delim
		inc	byte [DESTVARS]	; DestIsDir = 1, signalling path char
TESTPMETA:
		cmp	al,'?'
		jne	short TESTPSTAR	; char is not '?'
		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
TESTPSTAR:
		;cmp	al,'*'
		cmp	al,[STAR]
		jne	short TESTPDELIM ; char is not '*'
		or	byte [DESTINFO],2 ; DestInfo = 2, signalling wildcard
TESTPDELIM:
		call	DELIM		; compare AL to all delimiters
		jz	short PATHDONEDEC ; delimiter found, back up & leave
		cmp	al,[SWITCHAR]
		jne	short SKIPPATH	; char isn't switch, go get next char
PATHDONEDEC:
		dec	si		; SI = ptr to char after pathname
PATHDONE:
		xor	al,al		; AL = NULL
		xchg	al,[si]		; place NULL after pathname
		inc	si		; SI = ptr to byte after NULL
		cmp	al,0Dh		; were we at end of line?
		jne	short NOPSTORE	; not EOL, finish up
		mov	[si],al		; save EOL after NULL
NOPSTORE:
		mov	[PATHPOS],si	; PathPos = ptr to char after NULL
		mov	[PATHCNT],cx	; PathCnt = length of string left
SETPATH_RETN:
		retn

; ---------------------------------------------------------------------------

PGETARG:
		mov	si,80h
		lodsb
		or	al,al
		jz	short SETPATH_RETN
		call	PSCANOFF
		cmp	al,0Dh
		retn

; ---------------------------------------------------------------------------

PSCANOFF:
		lodsb
		call	DELIM
		jnz	short PSCANOFFD
		cmp	al,';'
		jne	short PSCANOFF	; ';' is not a delimiter
PSCANOFFD:
		dec	si		; Point to first non-delimiter
		retn

; =============== S U B	R O U T	I N E =======================================

IOSET:
		; ALL REGISTERS PRESERVED
		push	ds
		push	dx
		push	ax
		push	bx
		push	cx
		mov	ds,[cs:RESSEG]
		cmp	byte [PIPEFLAG],0
		jne	short NOREDIR
		test	byte [IFFLAG],0FFh
		jnz	short NOREDIR
		call	TESTDOREIN
		call	TESTDOREOUT
NOREDIR:
		pop	cx
		pop	bx
		pop	ax
		pop	dx
		pop	ds
IOSET_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

TESTDOREIN:
		cmp	byte [cs:RE_INSTR],0
		jz	short IOSET_RETN
		push	ds
		push	cs
		pop	ds
		mov	dx,RE_INSTR
		mov	ax,OPEN*256 ; 3D00h
		mov	bx,ax
		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
				; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 0 - read
		pop	ds
		jb	short REDIRERR
		mov	bx,ax
		mov	al,0FFh

; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
; spot. We invalidate the new JFN we got.

		;xchg	al,[bx+18h]
		xchg	al,[bx+PDB.JFN_TABLE]
		mov	byte [PDB.JFN_TABLE],al
		retn

; ---------------------------------------------------------------------------

; We had some kind of error on the redirection. Figure out what the
; appropriate message should be; BX has the system call that failed

REDIRERR:
		push	cs
		pop	ds
		;call	TriageError
		call	GET_EXT_ERR_NUMBER

; At this point, we have recognized the network-generated access denied error.
; The correct message is in DX

		cmp	ax,65
		jz	short _CERRORJ	;AC000; just issue message returned
		cmp	bh,OPEN ; 3Dh
		jz	short OPENERR
		mov	dx,FULDIRPTR
_CERRORJ:
		jmp	CERROR

OPENERR:
; The system call was an OPEN. Report either file not found or path not found.

		; MSDOS 6.0
		;mov	msg_disp_class,ext_msg_class 
		;			;AN000; set up extended error msg class
		;mov	dx,offset TranGroup:Extend_Buf_ptr 
		;			;AC000; get extended message pointer
		;mov	Extend_Buf_ptr,ax	
		;			;AN000; get message number in control block
		;JMP	CERROR

		; MSDOS 3.3
		mov	dx,FNOTFOUNDPTR
		;cmp	ax,2
		cmp	ax,ERROR_FILE_NOT_FOUND
		je	short _CERRORJ
		mov	dx,ACCDENPTR
		;cmp	ax,5 ; Access denied error
		cmp	ax,ERROR_ACCESS_DENIED
		je	short _CERRORJ
			; ERROR_PATH_NOT_FOUND
		mov	dx,PNOTFOUNDPTR
		jmp	CERROR

; =============== S U B	R O U T	I N E =======================================

TESTDOREOUT:
		cmp	byte [RE_OUTSTR],0
		je	short NOREOUT

REOUTEXISTS:
		cmp	byte [RE_OUT_APP],0
		je	short REOUTCRT

		mov	dx,RE_OUTSTR

		; MSDOS 6.0
		;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
		;mov	ax,3D02h

		; MSDOS 3.3
		mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
	
		; MSDOS 3.3 (& MSDOS 6.0)
		push	ax
		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
				; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 1 - write
		pop	bx
		jc	short OPENWRITEERROR

		; MSDOS 6.0
		;MOV	BX,AX
		;MOV	AX,IOCTL SHL 8		;AN035; Get attributes of handle
		;INT	21h			;AN035;
		;TEST	DL,devid_ISDEV		;AN035; Is it a device?
		;JNZ	SET_REOUT		;AN035; Yes, don't read from it
		;
		;MOV	AX,(LSEEK SHL 8) OR 2
		;MOV	CX,-1			;AC011; MOVE TO EOF -1
		;MOV	DX,CX			;AC011;
		;INT	21h
		;PUSH	CS			;AN011; Get transient seg to DS
		;POP	DS			;AN011;
		;assume	DS:Trangroup		;AN011;
		;MOV	AX,(READ SHL 8) 	;AN011; Read one byte from the
		;MOV	CX,1			;AN011;   file into one_char_val
		;MOV	DX,OFFSET Trangroup:ONE_CHAR_VAL;AN011;
		;INT	21h			;AN011;
		;JC	OpenWriteError		;AN011; If error, exit
		;cmp	ax,cx			;AN017; Did we read 1 byte?
		;jnz	reout_0_length		;AN017; No - file must be 0 length
		;
		;cmp	one_char_val,01ah	;AN011; Was char an eof mark?
		;mov	DS,[resseg]		;AN011; Get resident segment back
		;assume	DS:Resgroup		;AN011;
		;JNZ	SET_REOUT		;AN011; No, just continue
		;MOV	AX,(LSEEK SHL 8) OR 1	;AN011; EOF mark found
		;MOV	CX,-1			;AN011; LSEEK back one byte
		;MOV	DX,CX			;AN011;
		;INT	21h			;AN011;
		;JMP	SHORT SET_REOUT
;reout_0_length: 				;AN017; We have a 0 length file
		;mov	DS,[resseg]		;AN017; Get resident segment back
		;assume	DS:Resgroup		;AN017;
		;MOV	AX,(LSEEK SHL 8)	;AN017; Move to beginning of file
		;XOR	CX,CX			;AN017; Offset is 0
		;MOV	DX,CX			;AN017;
		;INT	21h			;AN017;
		;JMP	SHORT SET_REOUT 	;AN017; now finish setting up redirection

		; MSDOS 3.3
		xor	dx,dx
		xor	cx,cx
		mov	bx,ax
		mov	ax,(LSEEK<<8)|2 ; 4202h
		int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
				; AL = method: offset from end of file
		jmp	short SET_REOUT
		
		; MSDOS 3.3 (& MSDOS 6.0)
OPENWRITEERROR:	
		;cmp	ax,5
		cmp	ax,ERROR_ACCESS_DENIED
		stc
		je	short REDIRERR
REOUTCRT:	
		mov	dx,RE_OUTSTR
		xor	cx,cx
		mov	ah,CREAT ; 3Ch
		push	ax
		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
				; CX = attributes for file
				; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	bx
		jc	short REDIRERR
NOREDIRERR:
		mov	bx,ax
SET_REOUT:

; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
; spot. We invalidate the new JFN we got.

		mov	al,0FFh
		;xchg	al,[bx+18h]
		xchg	al,[bx+PDB.JFN_TABLE]
		mov	byte [PDB.JFN_TABLE+1],al
NOREOUT:
		retn

; =============== S U B	R O U T	I N E =======================================

; Compute length of string (including NUL) in DS:SI into CX.  Change no other
; registers

DSTRLEN:
		push	ax
		xor	cx,cx
		cld
DLOOP:
		lodsb
		inc	cx
		or	al,al
		jnz	short DLOOP
		sub	si,cx
		pop	ax
TRIAGEERR_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

;Break	<Extended error support>

TriageError:  ; MSDOS 6.0

;
; TriageError will examine the return from a carry-set system call and
; return the correct error if applicable.
;
;   Inputs:	outputs from a carry-settable system call
;		No system calls may be done in the interrim
;   Outputs:	If carry was set on input
;		    carry set on output
;		    DX contains trangroup offset to printf message
;		else
;		    No registers changed
;

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh

GET_EXT_ERR_NUMBER:
		jnc	short TRIAGEERR_RETN ; no carry => do nothing...
		pushf
		push	bx
		push	cx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		push	ax
		push	dx
		;mov	ah,59h
		mov	ah,GETEXTENDEDERROR
		int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
				; BX = version code (0000h for DOS 3.x)
		pop	cx
		pop	bx		; restore original AX
		mov	dx,ACCDENPTR
		cmp	ax,65		; network access denied?
		je	short NOMOVE	; Yes, return it.
		mov	ax,bx
		mov	dx,cx
NOMOVE:
		pop	ds
		pop	es
		pop	bp
		pop	di
		pop	si
		pop	cx
		pop	bx
		popf
		retn

; =============== S U B	R O U T	I N E =======================================

		; Far call from resident portion/segment of COMMAND.COM

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h

TRIAGE_INIT:
		;call	TriageError
		call	GET_EXT_ERR_NUMBER
		retf

;============================================================================
; TPIPE.ASM, MSDOS 6.0, 1991 (1)
;============================================================================
; 03/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h

; =============== S U B	R O U T	I N E =======================================

SINGLETEST:
		push	ds
		mov	ds,[cs:RESSEG]
		cmp	word [SINGLECOM],0
		jz	short TESTDONE
		cmp	word [SINGLECOM],0EFFFh
TESTDONE:
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

SETREST1:
		mov	al,1

; ---------------------------------------------------------------------------

SETREST:
		push	ds
		mov	ds,[RESSEG]
		mov	byte [RESTDIR],al
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

; Note that we need to handle the same thing that RestDir handles: the
; requirement that we try only once to restore the user's environment after
; and INT 24 or the like. If the condition that causes the INT 24 does not
; disappear, we just give up.

PIPEDEL:
		push	ds
		push	dx
		mov	ds,[cs:RESSEG]
		mov	dx,PIPE1	; Clean up in case ^C
		mov	ah,UNLINK ; 41h 
		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
				; DS:DX	-> ASCIZ pathname of file to delete 
				;		(no wildcards allowed)
		mov	dx,PIPE2
		mov	ah,UNLINK ; 41h
		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
				; DS:DX	-> ASCIZ pathname of file to delete 
				;		(no wildcards allowed)
		pop	dx
		call	PIPEOFF
		mov	byte [PIPEFILES],0
		pop	ds
		retn

; ---------------------------------------------------------------------------

PIPEERRSYN:
		mov	dx,SYNTMESPTR
		call	PIPEDEL
		push	cs
		pop	ds
		jmp	CERROR

; ---------------------------------------------------------------------------

PIPERR:
		pushf
		;invoke	TRIAGEERROR
		call	GET_EXT_ERR_NUMBER
		push	ax		; Save results from TriageError
		push	dx
		mov	dx,PIPEEMESPTR
		call	PIPEDEL
		push	cs
		pop	ds
		call	STD_EPRINTF
		pop	dx		; Restore results from TriageError
		pop	ax
		popf
		cmp	ax,65
		jnz	short TCOMMANDJ
		jmp	CERROR

TCOMMANDJ:
		jmp	TCOMMAND

PIPEPROCSTRT:
		mov	ds,[RESSEG]
		inc	byte [PIPEFILES] ; Flag that the pipe files exist

		; MSDOS 6.0
		;push	es
		;push	di
		;push	ds
		;push	si
		;
		;push	ds
		;push	es
		;pop	ds				;ds = TRANGROUP
		;mov	si,offset TRANGROUP:TempVarName	;ds:si = "TEMP="
;
;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
;so the routine is not really general
;
		;call	Find_Name_In_Environment	;es:di points at path
		;pop	ds				;ds = DATARES again
		;jc	no_temp_path
		;
		;push	ds
		;push	es
		;pop	ds
		;pop	es				;swap ds and es
		;mov	si,di				;ds:si points at path
		;
		;call	skip_white			;skip white space chars
;
;This copies the path into both buffers -- Pipe1 & Pipe2
;
		;call	copy_pipe_path			;copy the pipe path
		;
;
;Check if the TEMP path is valid
;
		;push	es
		;pop	ds				;ds = DATARES
		;mov	dx,offset DATARES:Pipe1		;ds:dx = path to look for
		;mov	ax, (CHMOD shl 8) or 0
		;int	21h
		;jc	no_temp_path
		;
		;test	cx,10h				;is it a directory?
		;jnz	no_temp_path			;yes, continue (carry clear)
		;
		;stc					;no, indicate fail
no_temp_path:
		;pop	si
		;pop	ds
		;pop	di
		;pop	es
		;jnc	crt_temp			;path found, create tempfiles

		; MSDOS 3.3
		mov	ah,GET_DEFAULT_DRIVE ; 19h	; Get current drive
		int	21h ; DOS - GET DEFAULT DISK NUMBER
		add	al,[cs:CAPITAL_A]
		mov	byte [PIPE2],al		; Make pipe files in root of def drv
		mov	bx,PIPE1
		mov	[bx],al
		xor	ah,ah			; nul terminate path names
		mov	byte [PIPE1+3],ah
		mov	byte [PIPE2+3],ah

		; MSDOS 6.0
;SR;
; We want to create temp files in the current directory rather than in the 
;root of the drive. This is because the number of files that can be present
;in the root directory is fixed, whereas it is not so in subdirectories.
;
		;mov	ah,'.'
		;mov	Pipe1,ah
		;mov	Pipe2,ah
		;xor	ah,ah
		;mov	Pipe1+1,ah
		;mov	Pipe2+1,ah		;create files in current dir

;crt_temp:
		; MSDOS 6.0
		;mov	dx,offset DATARES:Pipe1
		;mov	dx,PIPE1
	
		; MSDOS 3.3 (& MSDOS 6.0)
		mov	dx,bx
		xor	cx,cx
		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
		int	21h	; DOS -	3+ - CREATE UNIQUE FILE
			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
			; receive generated filename
			; CX = file attributes (only bits 0,1,2,5 may be set)
		jc	short PIPERR	; Couldn't create
		mov	bx,ax
		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
		int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
		mov	dx,PIPE2
		mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
			; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
			; receive generated filename
			; CX = file attributes (only bits 0,1,2,5 may be set)
		jc	short PIPERR
		mov	bx,ax
		mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		;call	near ptr TESTDOREIN ; Set up a redirection if specified
		call	TESTDOREIN
		mov	si,word [PIPEPTR]
		cmp	word [SINGLECOM],-1
		jne	short NOSINGP
		mov	word [SINGLECOM],0F000h ; Flag single command pipe
NOSINGP:
		jmp	short FIRSTPIPE

; ---------------------------------------------------------------------------

PIPEPROC:
		and	byte [ECHOFLAG],0FEh  ; force current echo to be off
		mov	si,word [PIPEPTR]
		lodsb
		;cmp	al,'|'		
		cmp	al,ALTPIPECHR	; Alternate pipe char? 	
		je	short ISPIPE1	; Yes
		cmp	al,[cs:VBAR]
		je	short ISPIPE1
		jmp	PIPEEND		; Pipe done
ISPIPE1:
		mov	dx,word [INPIPEPTR] ; Get the input file name
		mov	ax,OPEN*256 ; 3D00h
		int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
				; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 0 - read
PIPEERRJ:
		jnc	short NO_PIPEERR
		jmp	PIPERR		; Lost the pipe file
NO_PIPEERR:
		mov	bx,ax
		mov	al,0FFh
		;xchg	al,[bx+18h]
		xchg	al,[bx+PDB.JFN_TABLE]
		mov	byte [PDB.JFN_TABLE],al	; Redirect
FIRSTPIPE:
		mov	di,COMBUF+2
		xor	cx,cx
		cmp	byte [si],0Dh	; '|<CR>'
		jne	short PIPEOK1
PIPEERRSYNJ:
		jmp	PIPEERRSYN
PIPEOK1:
		mov	al,[cs:VBAR]
		cmp	[si],al		; '||'
		je	short PIPEERRSYNJ
		;cmp	byte [si],'|'
		cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
		je	short PIPEERRSYNJ
PIPECOMLP:
		lodsb
		stosb
		cmp	al,0Dh
		je	short LASTPIPE
		inc	cx
		;cmp	al,'|'
		cmp	al,ALTPIPECHR
		je	short ISPIPE2
		cmp	al,[cs:VBAR]
		jne	short PIPECOMLP
ISPIPE2:
		mov	byte [es:di-1],0Dh
		dec	cx
		mov	[cs:COMBUF+1],cl
		dec	si
		mov	word [PIPEPTR],si	; On to next pipe element
		mov	dx,word [OUTPIPEPTR]
		push	cx
		xor	cx,cx
		mov	ax,CREAT*256 ; 3C00h
		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
				; CX = attributes for file
				; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	cx
		jc	short PIPEERRJ		; Lost the file
		mov	bx,ax
		mov	al,0FFh
		;xchg	al,[bx+18h]
		xchg	al,[bx+PDB.JFN_TABLE]
		mov	byte [PDB.JFN_TABLE+1],al
		xchg	dx,word [INPIPEPTR]	; Swap for next element of pipe
		mov	word [OUTPIPEPTR],dx
		jmp	short PIPECOM
LASTPIPE:
		mov	[cs:COMBUF+1],cl 
		dec	si
		mov	word [PIPEPTR],si ; Point at the CR (anything not '|' will do)
		call	TESTDOREOUT	; Set up the redirection if specified
PIPECOM:
		push	cs
		pop	ds
		jmp	NOPIPEPROC	; Process the pipe element
PIPEEND:
		call	PIPEDEL
		cmp	word [SINGLECOM],0F000h
		jnz	short NOSINGP2
		mov	word [SINGLECOM],-1 ; 0FFFFh ; Make it return
NOSINGP2:
		jmp	TCOMMAND

; =============== S U B	R O U T	I N E =======================================

; Date and time are set during initialization and use
; this routines since they need to do a long return

DATINIT:
		mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
		push	es
		push	ds		; Going to use the previous stack
		mov	ax,cs		; Set up the appropriate segment registers
		mov	es,ax
		mov	ds,ax
		;invoke TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
		mov	dx,INTERNATVARS
		mov	ax,INTERNATIONAL*256 ; 3800h
		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
				; get current-country info
				; DS:DX	-> buffer for returned info
		; 20/10/2018
		mov	word [81H],0Dh ; Want to prompt for date during initialization
		mov	byte [COMBUF],128 ; Init COMBUF
		mov	word [COMBUF+1],0D01h
		call	DATE
		call	CTIME
		pop	ds
		pop	es
		retf

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 DATE - Set system date
; *
; * FUNCTION:	 If a date is specified, set the system date,
; *		 otherwise display the current system date and
; *		 prompt the user for a new date.  If an invalid
; *		 date is specified, issue an error message and
; *		 prompt for a new date.  If the user enters
; *		 nothing when prompted for a date, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

;assume	ds:trangroup,es:trangroup
;
;DATE:
;	MOV	SI,81H				; Accepting argument for date inline
;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
;	xor	cx,cx				;AN000; clear counter for positionals
;	xor	dx,dx				;AN000;
;	invoke	cmd_parse			;AC000; call parser
;	cmp	ax,end_of_line			;AC000; are we at end of line?
;	JZ	PRMTDAT 			;AC000; yes - go ask for date
;	cmp	ax,result_no_error		;AN000; did we have an error?
;	jne	daterr				;AN000; yes - go issue message
;	JMP	short COMDAT			;AC000; we have a date
;
;PRMTDAT:
;	; Print "Current date is
;
;	invoke	GetDate 			;AN000; get date  for output
;	xchg	dh,dl				;AN000; switch month & day
;	mov	CurDat_yr,cx			;AC000; put year into message control block
;	mov	CurDat_mo_day,dx		;AC000; put month and day into message control block
;	mov	dx,offset trangroup:CurDat_ptr	;AC000; set up message for output
;	invoke	std_printf
;;AD061; mov	CurDat_yr,0			;AC000; reset year, month and day
;;AD061; mov	CurDat_mo_day,0 		;AC000;     pointers in control block
;
;GET_NEW_DATE:					;AN000;
;	call	getdat				;AC000; prompt user for date
;	cmp	ax,end_of_line			;AC000; are we at end of line?
;	jz	date_end			;AC000; yes - exit
;	cmp	ax,result_no_error		;AN000; did we have an error?
;	jne	daterr				;AN000; yes - go issue message
;COMDAT:
;	mov	cx,date_year			;AC000; get parts of date in
;	mov	dh,date_month			;AC000;    cx and dx for set
;	mov	dl,date_day			;AC000;    date function call.
;	push	cx				;AC000; save date
;	push	dx				;AC000;
;	mov	cx,1				;AC000; set 1 positional entered
;	xor	dx,dx				;AN029;
;	invoke	cmd_parse			;AN029; call parser
;	cmp	al,end_of_line			;AN029; Are we at end of line?
;	pop	dx				;AC000; retrieve date
;	pop	cx				;AC000;
;	jnz	daterr				;AC000; extra stuff on line - try again
;	MOV	AH,SET_DATE			;yes - set date
;	INT	21h
;	OR	AL,AL
;	JNZ	DATERR
;date_end:
;	ret
;
;DATERR:
;	invoke	crlf2				;AN028; print out a blank line
;	MOV	DX,OFFSET TRANGROUP:BADDAT_ptr
;	invoke	std_printf
;	JMP	GET_NEW_DATE			;AC000; get date again

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; TIME gets and sets the time

; ****************************************************************
; *
; * ROUTINE:	 TIME - Set system time
; *
; * FUNCTION:	 If a time is specified, set the system time,
; *		 otherwise display the current system time and
; *		 prompt the user for a new time.  If an invalid
; *		 time is specified, issue an error message and
; *		 prompt for a new time.  If the user enters
; *		 nothing when prompted for a time, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

;assume	ds:trangroup,es:trangroup
;
;CTIME:
;	MOV	SI,81H				; Accepting argument for time inline
;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_time
;	xor	cx,cx				;AN000; clear counter for positionals
;	xor	dx,dx				;AN000;
;	invoke	cmd_parse			;AC000; call parser
;	cmp	ax,end_of_line			;AC000; are we at end of line?
;	JZ	PRMTTIM 			;AC000; yes - prompt for time
;	cmp	ax,result_no_error		;AN000; did we have an error?
;	jne	timerr				;AN000; yes - go issue message
;	JMP	short COMTIM			;AC000; we have a time
;
;PRMTTIM:
;	;Printf "Current time is ... "
;
;	MOV	AH,GET_TIME			;AC000; get the current time
;	INT	21h				;AC000;    Get time in CX:DX
;	xchg	ch,cl				;AN000; switch hours & minutes
;	xchg	dh,dl				;AN000; switch seconds & hundredths
;	mov	CurTim_hr_min,cx	;AC000; put hours and minutes into message subst block
;	mov	CurTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
;	mov	dx,offset trangroup:CurTim_ptr	;AC000; set up message for output
;	invoke	std_printf
;;AD061; mov	CurTim_hr_min,0 		;AC000; reset hour, minutes, seconds, and hundredths
;;AD061; mov	CurTim_sec_hn,0 		;AC000;     pointers in control block
;
;GET_NEW_TIME:
;	call	gettim				;AC000;
;	cmp	ax,end_of_line			;AC000; are we at end of line?
;	jz	time_end			;AC000;
;	cmp	ax,result_no_error		;AN000; did we have an error?
;	jne	timerr				;AN000; yes - go issue message
;
;COMTIM:
;	mov	ch,time_hour			;AC000; get parts of time in
;	mov	cl,time_minutes 		;AC000;    cx and dx for set
;	mov	dh,time_seconds 		;AC000;    time function call
;	mov	dl,time_fraction		;AC000;
;	push	cx				;AC000; save time
;	push	dx				;AC000;
;	mov	cx,1				;AC000; set 1 positional parm entered
;	xor	dx,dx				;AN029;
;	invoke	cmd_parse			;AN029; call parser
;	cmp	al,end_of_line			;AN029; Are we at end of line?
;	pop	dx				;AC000; retieve time
;	pop	cx				;AC000;
;	jnz	timerr				;AC000; extra stuff on line - try again
;
;SAVTIM:
;	MOV	AH,SET_TIME
;	INT	21h
;	OR	AL,AL
;	JNZ	TIMERR				;AC000; if an error occured, try again
;
;TIME_END:
;
;	ret
;
;TIMERR:
;	invoke	crlf2				;AN028; print out a blank line
;	MOV	DX,OFFSET TRANGROUP:BADTIM_ptr
;	invoke	std_printf			; Print error message
;	JMP	GET_NEW_TIME			;AC000; Try again

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;
; Set the special flag in the INIT flag to the value in CX.
;

;SetInitFlag:
;	mov	ds,[RESSEG]
;assume ds:resgroup
;	and	InitFlag,NOT initSpecial
;	or	InitFlag,cL
;	push	cs
;	pop	ds
;	return
;
;Public	PipeOff
;PipeOff:
;	ASSUME	DS:NOTHING,ES:NOTHING
;	SaveReg <DS,AX>
;	MOV	DS,ResSeg
;	ASSUME	DS:RESGroup
;	XOR	AL,AL
;	XCHG	PipeFlag,AL
;	OR	AL,AL
;	JZ	PipeOffDone
;	SHR	EchoFlag,1
;PipeOffDone:
;	RestoreReg  <AX,DS>
;	return

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;PRINT_TIME:
;
;	MOV	AH,GET_TIME
;	INT	21h			; Get time in CX:DX
;
;	PUSH	ES
;	PUSH	CS
;	POP	ES
;	xchg	ch,cl			;AN000; switch hours & minutes
;	xchg	dh,dl			;AN000; switch seconds & hundredths
;	mov	promTim_hr_min,cx	;AC000; put hours and minutes into message subst block
;	mov	promTim_sec_hn,dx	;AC000; put seconds and hundredths into message subst block
;	mov	dx,offset trangroup:promTim_ptr ;AC000; set up message for output
;	invoke	std_printf
;;AD061; mov	promTim_hr_min,0	;AC000; reset hour, minutes, seconds, and hundredths
;;AD061; mov	promTim_sec_hn,0	;AC000;     pointers in control block
;
;	POP	ES
;	return

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 GETDAT - Prompt user for date
; *
; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new date"
; *		 message with the proper date format.  COMBUF
; *		 is reset to get a date from the command line.
; *		 The PARSE_DATE blocks are then reset and the
; *		 PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************

;GETDAT	proc	near				;AC000;
;
;	mov	ax,(International SHL 8)	; Determine what format the date
;	mov	dx,5ch				;  should be entered in and
;	int	21h			;  print a message describing it
;	mov	si,dx
;	lodsw
;	mov	dx,usadat_ptr			;AC000; get mm-dd-yy
;	dec	ax
;	js	printformat
;	mov	dx,eurdat_ptr			;AC000; get dd-mm-yy
;	jz	printformat
;	mov	dx,japdat_ptr			;AC000; get yy-mm-dd
;printformat:
;	mov	ax,dx				;AN000; get message number of format
;	mov	dh,util_msg_class		;AN000; this is a utility message
;	call	Tsysgetmsg			;AN000; get the address of the message
;	mov	newdat_format,si		;AN000; put the address in subst block
;	MOV	DX,OFFSET TRANGROUP:NEWDAT_ptr	;AC000; get address of message to print
;	invoke	std_printf
;	mov	newdat_format,no_subst		;AN000; reset subst block
;
;	MOV	AH,STD_CON_STRING_INPUT
;	MOV	DX,OFFSET TRANGROUP:COMBUF
;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
;	call	SetInitFlag			;  prompting for date.
;	INT	21h			; Get input line
;	xor	cx,cx				; Reset bit in InitFlag that indicates
;	call	SetInitFlag			;  prompting for date.
;	invoke	CRLF2
;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
;	mov	di,offset trangroup:parse_date	;AN000; Get adderss of PARSE_DATE
;	xor	cx,cx				;AN000; clear counter for positionals
;	xor	dx,dx				;AN000;
;	invoke	cmd_parse			;AC000; call parser
;
;	ret
;
;GETDAT	endp					;AC000;

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 GETTIME - Prompt user for time
; *
; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new time"
; *		 message. COMBUF is reset to get a time from the
; *		 command line.	The PARSE_TIME blocks are then
; *		 reset and the PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************

;GETTIM	proc	near				;AC000;
;
;	XOR	CX,CX				; Initialize hours and minutes to zero
;	MOV	DX,OFFSET TRANGROUP:NEWTIM_ptr
;	invoke	std_printf
;	MOV	AH,STD_CON_STRING_INPUT
;	MOV	DX,OFFSET TRANGROUP:COMBUF
;	mov	cx,initSpecial			; Set bit in InitFlag that indicates
;	call	SetInitFlag			;  prompting for time.
;	INT	21h			; Get input line
;	xor	cx,cx				; Reset bit in InitFlag that indicates
;	call	SetInitFlag			;  prompting for time.
;	invoke	CRLF2
;	MOV	SI,OFFSET TRANGROUP:COMBUF+2
;	mov	di,offset trangroup:parse_time	;AN000; Get adderss of PARSE_TIME
;	xor	cx,cx				;AN000; clear counter for positionals
;	xor	dx,dx				;AN000;
;	invoke	cmd_parse			;AC000; call parser
;
;	ret
;
;GETTIM	endp					;AC000;

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;Skip_white: Skips over the whitespace chars that could be present after
;the '=' sign in the environment variable before the actual path.
;
;	ENTRY:	ds:si = arguments of the environment variable
;
;	EXIT:	ds:si = start of the path
;
;	REGISTERS AFFECTED: ax
;

;Skip_white	proc	near
;
;	cld
;skw_lp:
;	lodsb
;	cmp	al,' '				;blank char?
;	jz	skw_lp				;yes, skip it
;	cmp	al,09				;tab char?
;	jz	skw_lp				;yes, skip it
;
;	dec	si				;point at first non-white
;
;	ret
;
;Skip_white	endp

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;Copy_pipe_path:	This routine copies the path from the TEMP environment
;variable into the path buffers Pipe1 & Pipe2.
;
;	ENTRY:	ds:si = path to be copied
;		es = RESGROUP
;
;	EXIT:	Path copied into Pipe1 and Pipe2.
;
;	REGISTERS AFFECTED: si, di, cx, ax
;

;Copy_pipe_path	proc	near
;
;	mov	cx,0ffffh
;	xor	al,al
;
;	mov	di,si
;	push	es			;save es
;	push	ds
;	pop	es			;es:di = path to be copied
;	
;	cld
;	push	di
;	repnz	scasb			;look for the null char
;	pop	di
;
;	pop	es			;es = RESGROUP again
;
;	not	cx			;length including the null
;
;	mov	di,offset DATARES:Pipe1	
;	push	di
;	push	cx			
;	rep	movsb			;copy path into Pipe1
;	pop	cx
;	pop	di
;
;	push	ds
;	push	es
;	pop	ds			;ds:si = Pipe1
;	mov	si,di
;	mov	di,offset DATARES:Pipe2	;es:di = Pipe2
;	rep	movsb			;copy path into Pipe2
;	pop	ds
;
;	ret				;
;
;Copy_pipe_path	endp

;============================================================================
; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
;============================================================================
; 05/10/2018 - Retro DOS v3.0

; DATE - Gets and sets the time

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h

; =============== S U B	R O U T	I N E =======================================

DATE_CXDX:
		mov	bx,cx

; =============== S U B	R O U T	I N E =======================================

P_DATE:
		mov	ax,bx
		mov	cx,dx
		mov	dl,100
		div	dl
		xchg	al,ah
		xchg	ax,dx
		mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
		;mov	ax,[INTERNATVARS]
		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
		or	ax,ax
		jz	short USPDAT
		dec	ax
		jz	short EUPDAT
		mov	bh,0	 ; Disable leading zero suppression	
		call	P_YR
		call	P_DSEP
		call	P_MON
		call	P_DSEP
		call	P_DAY
		retn

USPDAT:
		call	P_MON
		call	P_DSEP
		call	P_DAY
PLST:
		call	P_DSEP
		call	P_YR
		retn

EUPDAT:
		call	P_DAY
		call	P_DSEP
		call	P_MON
		jmp	short PLST

; ---------------------------------------------------------------------------

P_MON:
		mov	al,ch
		call	OUT2
		retn

; ---------------------------------------------------------------------------

P_DSEP:
		;mov	al,[DATE_SEP] ; INTERNATVARS+11
		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
		stosb
		retn

; ---------------------------------------------------------------------------

P_DAY:
		mov	al,cl
		call	OUT2
		retn

; ---------------------------------------------------------------------------

P_YR:
		mov	al,dh
		or	al,al
		jz	short TWODIGYR	; Two instead of 4 digit year
		call	OUT2
TWODIGYR:
		mov	al,dl
		call	OUT2
DATE_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

DATE:				 	; Accepting argument for date inline
		mov	si,81h
		call	SCANOFF
		cmp	al,0Dh
		jz	short PRMTDAT
		jmp	short COMDAT

		;nop

PRMTDAT:
		; MSDOS 3.3
		mov	dx,CURDATPTR
		call	STD_PRINTF	; Print "Current date is "	
		call	PRINT_DATE

GETDAT:	
		mov	dx,NEWDATPTR
		call	STD_PRINTF	 ; Print "Enter new date: "

		mov	ax,INTERNATIONAL*256 ; 3800h 
					; Determine what format the date
		mov	dx,5Ch		;  should be entered in and
		int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
				; get current-country info
				; DS:DX	-> buffer for returned info
		mov	si,dx		;  print a message describing it
		lodsw
		mov	dx,USADATPTR	; get mm-dd-yy
		dec	ax
		js	short PRINTFORMAT
		mov	dx,EURDATPTR	; get dd-mm-yy
		jz	short PRINTFORMAT
		mov	dx,JAPDATPTR	; get yy-mm-dd
PRINTFORMAT:
		call	STD_PRINTF
		mov	ah,STD_CON_STRING_INPUT	; 0Ah
		mov	dx,COMBUF
		mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
		call	SETINITFLAG	;  prompting for date.
		int	21h		; Get input line
		xor	cx,cx		; Reset bit in InitFlag that indicates
		call	SETINITFLAG	;  prompting for date.
		call	CRLF2
		mov	si,COMBUF+2
		cmp	byte [si],0Dh
		jz	short DATE_RETN
COMDAT:
		;mov	ax,[INTERNATVARS]
		mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
		or	ax,ax
		jz	short USSDAT
		dec	ax
		jz	short EUSDAT
		call	GET_YR
		jc	short DATERRJ
		call	GET_DSEP
		jc	short DATERRJ
		call	GET_MON
		jc	short DATERRJ
		call	GET_DSEP
		jc	short DATERRJ
		call	GET_DAY
DAT_SET:
		jnc	short DATSET
		jmp	DATERR

; ---------------------------------------------------------------------------

DATSET:
		lodsb
		cmp	al,' '
		jz	short DATSET
		cmp	al,9
		jz	short DATSET
		cmp	al,0Dh
		jnz	short DATERR
		mov	ah,SET_DATE ; 2Bh
		int	21h	; DOS -	SET CURRENT DATE
				; DL = day,DH = month,	CX = year
				; Return: AL = 00h if no error 
				; 	     = FFh if bad value sent to routine
		or	al,al
		jnz	short DATERR
DAT_SET_RETN:
		retn

; ---------------------------------------------------------------------------

USSDAT:
		call	GET_MON
		jb	short DATERR
		call	GET_DSEP
DATERRJ:
		jc	short DATERR
		call	GET_DAY
TGET:
		jc	short DATERR
		call	GET_DSEP
		jc	short DATERR
		call	GET_YR
		jmp	short DAT_SET

; ---------------------------------------------------------------------------

EUSDAT:
		call	GET_DAY
		jc	short DATERR
		call	GET_DSEP
		jc	short DATERR
		call	GET_MON
		jmp	short TGET


; =============== S U B	R O U T	I N E =======================================

GET_MON:
		call	GETNUM		; Get one or two digit number
		jc	short DAT_SET_RETN
		mov	dh,ah		; Put in position
		retn


; =============== S U B	R O U T	I N E =======================================

GET_DAY:
		call	GETNUM
		mov	dl,ah		; Put in position
GET_DAY_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

GET_YR:
		call	GETNUM
		jc	short GET_DAY_RETN
		mov	cx,1900
		call	GET_DSEP
		pushf
		dec	si
		popf
		jz	short BIAS
		cmp	byte [si],0Dh
		je	short BIAS
		cmp	byte [si],' '
		je	short BIAS
		cmp	byte [si],9
		je	short BIAS
		push	bx
		mov	bl,100
		mov	al,ah
		mul	bl
		pop	bx
		mov	cx,ax
		call	GETNUM
		jc	short GET_DAY_RETN
BIAS:
		mov	al,ah
		mov	ah,0
		add	cx,ax
BIAS_RETN:
		retn

; ---------------------------------------------------------------------------

DATERR:
		mov	dx,BADDATPTR
		call	STD_PRINTF
		jmp	GETDAT

; =============== S U B	R O U T	I N E =======================================

GET_DSEP:
		lodsb
		cmp	al,'/'
		je	short BIAS_RETN
		;cmp	al,'.'
		cmp	al,[DOT_CHR]
		je	short BIAS_RETN
		;cmp	al,'-'
		cmp	al,[CHAR_SUB]
		je	short BIAS_RETN
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

; TIME gets and sets the time

CTIME:
		mov	si,81h		; Accepting argument for time inline
		call	SCANOFF
		cmp	al,0Dh
		je	short PRMTTIM
		mov	bx,2E3Ah ; ":."
		call	INLINE
		jmp	COMTIM

; =============== S U B	R O U T	I N E =======================================

PRINT_TIME:
		mov	ah,GET_TIME ; 2Ch ; Get time in CX:DX
		int	21h	; DOS -	GET CURRENT TIME
				; Return: CH = hours,CL = minutes,DH = seconds
				; DL = hundredths of seconds
		push	di
		push	es
		push	cs
		pop	es
		mov	di,CHARBUF
		mov	bl,1	; Always 24 hour time
		call	P_TIME
		xor	ax,ax
		stosb
		mov	dx,CHARBUF
		mov	[STRING_PTR_2],dx
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
		pop	es
		pop	di
P_TIME_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

P_TIME:
		mov	al,ch	
		test	bl,7Fh		; Ignore high bit
		jnz	short T24	; 24 hr time?
		mov	bh,'a'		; Assume A.M.
		cmp	al,12		; In the afternoon?
		jb	short MORN
		mov	bh,'p'
		jz	short MORN
		sub	al,12		; Keep it to 12 hours or less
MORN:
		or	al,al		; Before 1 am?
		jnz	short T24
		mov	al,12
T24:
		push	bx
		mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
		call	OUT2
		call	P_TSEP
		mov	al,cl
		call	OUT2
		pop	bx
		push	bx
		test	bl,80h
		jnz	short PAP	; If from DIR, go directly to am pm
		mov	bh,0		; Disable leading zero suppression
		call	P_TSEP
		mov	al,dh
		call	OUT2
		;mov	al,'.'
		mov	al,[DECIMAL_SEP]
		stosb
		mov	al,dl
		call	OUT2
PAP:
		pop	bx
		test	bl,7Fh		; Ignore high bit
		jnz	short P_TIME_RETN
		mov	al,bh
		stosb
		retn

; =============== S U B	R O U T	I N E =======================================

P_TSEP:
		;mov	al,[TIME_SEP]
		mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
		stosb
P_TSEP_RETN:
		retn

; ---------------------------------------------------------------------------

PRMTTIM:
		mov	dx,CURTIMPTR
		call	STD_PRINTF	; Print "Current time is "
		call	PRINT_TIME
GETTIM:
		xor	cx,cx		; Initialize hours and minutes to zero
		mov	dx,NEWTIMPTR
		call	STD_PRINTF
		;mov	bx,':.'
		mov	bx,[TIMECHARS] 
		call	GETBUF
COMTIM:
		jz	short P_TSEP_RETN ; If no time present, don't change it	
		jc	short TIMEERR
		mov	cx,dx
		xor	dx,dx
		lodsb
		cmp	al,0Dh
		je	short SAVTIM
		cmp	al,' '
		je	short GOTSEC2
		cmp	al,9
		je	short GOTSEC2
		cmp	al,bl
		je	short GOTSEC
		cmp	al,bh
		jne	short TIMEERR
GOTSEC:
		call	GETNUM
		jc	short TIMEERR
		mov	dh,ah		; Position seconds
		lodsb
		cmp	al,0Dh
		je	short SAVTIM
		cmp	al,' '
		je	short GOTSEC2
		cmp	al,9
		je	short GOTSEC2
		;cmp	al,'.'
		cmp	al,[DECIMAL_SEP]
		jne	short TIMEERR
		call	GETNUM
		jc	short TIMEERR
		mov	dl,ah
GOTSEC2:
		lodsb
		cmp	al,' '
		je	short GOTSEC2
		cmp	al,9
		je	short GOTSEC2
		cmp	al,0Dh
		jne	short TIMEERR
SAVTIM:
		mov	ah,SET_TIME ; 2Dh
		int	21h	; DOS -	SET CURRENT TIME
				; CH = hours,CL = minutes,DH = seconds,
				;		DL = hundredths of seconds
				; Return: AL = 00h if no error 
				;	     = FFh if bad value sent to routine
		or	al,al
P_TSEP_JRETN:
		jz	short P_TSEP_RETN ; Error in time?
TIMEERR:
		mov	dx,BADTIMPTR
		call	STD_PRINTF	; Print "Enter new time: "
		jmp	short GETTIM

; =============== S U B	R O U T	I N E =======================================

GETBUF:
		mov	ah,STD_CON_STRING_INPUT ; 0Ah
		mov	dx,COMBUF
		mov	cx,2
		call	SETINITFLAG
		int	21h		; Get input line
		xor	cx,cx
		call	SETINITFLAG
		call	CRLF2
		mov	si,COMBUF+2
		cmp	byte [si],0Dh	; Check if new time entered
		jz	short P_TSEP_JRETN

; =============== S U B	R O U T	I N E =======================================

INLINE:
		call	GETNUM		; Get one or two digit number
		jnb	short INLINE1
		retn
INLINE1:
		mov	dh,ah		; Put in position
		lodsb
		cmp	al,bl
		jz	short NEXT
		cmp	al,bh
		jz	short NEXT
		dec	si		; Clears zero flag
		clc
		mov	dl,0
		retn			; Time may have only an hour specified
NEXT:
		call	GETNUM
		mov	dl,ah		; Put in position
INLINE_RETN:
		retn

;============================================================================
; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
;============================================================================
; 05/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h

; =============== S U B	R O U T	I N E =======================================

GETNUM:
		call	INDIG
		jb	short INLINE_RETN
		mov	ah,al		; Save first digit
		call	INDIG		; Another digit?
		jb	short OKRET
		aad			; Convert unpacked BCD to decimal
		mov	ah,al
OKRET:
		or	al,1
GETNUM_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

INDIG:
		mov	al,[si]
		sub	al,'0'
		jc	short GETNUM_RETN
		cmp	al,10
		cmc
		jc	short GETNUM_RETN
		inc	si
		retn

; =============== S U B	R O U T	I N E =======================================

OUT2:					; Output binary number as two ASCII digits
		aam			; Convert binary to unpacked BCD
		xchg	al,ah
		or	ax,3030h	; Add "0" bias to both digits
		cmp	al,'0'		; Is MSD zero?
		jnz	short NOSUP
		sub	al,bh		; Suppress leading zero if enabled
NOSUP:
		mov	bh,0		; Disable zero suppression
		stosw
		retn

; ---------------------------------------------------------------------------
		;stosb
		;retn

;============================================================================
; TPIPE.ASM, MSDOS 6.0, 1991 (2)
;============================================================================
; 03/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h

; =============== S U B	R O U T	I N E =======================================

; Set the special flag in the INIT flag to the value in CX.

SETINITFLAG:
		mov	ds,[RESSEG]
		;and	byte [INITFLAG],0FDh
		and	byte [INITFLAG],~INITSPECIAL
		or	byte [INITFLAG],cl
		push	cs
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

PIPEOFF:
		push	ds
		push	ax
		mov	ds,[cs:RESSEG]
		xor	al,al
		xchg	al,byte [PIPEFLAG]
		or	al,al
		jz	short PIPEOFFDONE
		shr	byte [ECHOFLAG],1
PIPEOFFDONE:
		pop	ax
		pop	ds
		retn

; ---------------------------------------------------------------------------
		;db    0,0,0,0,0
		;times 5 db 0
align 16

;============================================================================
; PARSE2.ASM, MSDOS 6.0, 1991
;============================================================================
; 03/10/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
; argv[argvcnt] array. The most important difference between this array and
; the tradition UNIX format is the extra cparse information included with
; each argument element.
;---------------
; ENTRY:
;	BL	     special delimiter for cparse -- not implemented)
;---------------
; EXIT:
;	CF	    set if error
;	AL	    error code (carry set). Note AH clobbered in any event.
;	argv[]	    array of cparse flags and pointers to arguments
;	argvcnt     argument count
;---------------
; NOTE(S):
;	*   BL (special delimiter) is ignored, for now (set to space).
;	*   Parseflags record contains cparse flags, as follows:
;		sw_flag 	--	was this arg a switch?
;		wildcard	--	whether or not it contained a * or ?
;		path_sep	--	maybe it was a pathname
;		unused		--	for future expansion
;		special_delim	--	was there an initial special delimiter?
;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
;	*   Relationship between input, cparse output, and comtail can be
;	    found in the following chart.  Despite the claim of the cparse
;	    documentation that, "Token buffer always starts d:  for non switch
;	    tokens", such is not the case (see column two, row two).
;	    Similarly, [STARTEL] is not null when the command line is one of
;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
;	    STARTEL addresses) will be null. This is clearly just a
;	    documentation error.
;	*   cparse also returns a switch code in BP for each switch it
;	    recognizes on the command line.
;	*   arglen for each token does NOT include the terminating null.
;	*   Finally, note that interesting constructions like 'foodir/*.exe'
;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
;	    line parsing may result in slightly different behavior than
;	    previously observed with the old COMMAND.COM command-line parser.
;
;	    Input		    Cparse		Command Line (80H)
;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
;	alan\foo.bat		alan\foo.bat		alan\foo.bat
;	foo.bat 		foo.bat 		foo.bat
;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
;	c:foo.bat		c:foo.bat		c:foo.bat

; =============== S U B	R O U T	I N E =======================================

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h

PARSELINE:
		push	ax			; most of these are clobbered
		push	bx			; by cparse...
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	byte [CPYFLAG],0  ; Turn "CPARSE called from COPY flag" off
		mov	word [LASTARG],-1 ; last argument at which to accumulate
		xor	ax,ax
		;mov	cx,1348
		mov	cx,ARG_UNIT.SIZE
		mov	di,ARG
		rep stosb
		;mov	word [ARGBUFPTR],ARG_ARGBUF
		mov	word [ARGBUFPTR],ARG+ARG_UNIT.argbuf
		;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
		mov	word [ARG+ARG_UNIT.argswinfo],0
		;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
		mov	word [ARG+ARG_UNIT.argvcnt],0
		mov	si,COMBUF+2	; prescan leaves cooked input in combuf

; This next section of code (up to pcont:)  makes sure that si is set up for
; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
; otherwise. This is done so that commands can get arg pointers into their
; original command line (or an exact copy of it) in arg_ocomptr.
; Arg.argforcombuf is used so that the for loop processor will always be able
; to get a hold of its original command line; even after COMBUF is blasted by
; the command to be repeated or the transient part of command has been
; reloaded.

		push	ds
		mov	ds,[RESSEG]
		cmp	byte [FORFLAG],0
		pop	ds
		jnz	short PCONT
		;mov	di,ARG_ARGFORCOMBUF
		mov	di,ARG+ARG_UNIT.argforcombuf 
		xor	ch,ch
		mov	cl,[COMBUF+1]
		inc	cl
		rep movsb
		;mov	si,ARG_ARGFORCOMBUF
		mov	si,ARG+ARG_UNIT.argforcombuf 
PCONT:
		mov	di,TPBUF	; destination is temporary token buffer	
		mov	bl,' '		; no special delimiter, for now
PARSELOOP:
		mov	[COMPTR],si	; save ptr into original command buffer
		xor	bp,bp		; switch information put here by cparse
		mov	byte [EXPAND_STAR],0 ; don't expand *'s to ?'s
		call	SCANOFF		; skip leading blanks...
		call	CPARSE		; byte off a token (args in SI, DI, BL)
		jnb	short MORE_PRSE
		or	bp,bp		; Check for trailing switch character
		jz	short PARSEDONE
		call	NEWARG		; We hit CR but BP is non-zero. The
					;   typical cause of this is that a
					;   switch char IMMEDIATELY preceeds
					;   the CR. We have an argument, but it
					;   is sort of an error.
		jmp	short PARSEDONE	; We're done (found the CR).

MORE_PRSE:
		mov	byte [CPYFLAG],2 ; tell CPARSE that 1st token is done
		call	NEWARG		; add to argv array (CX has char count)
		jnb	short PARSELOOP	; was everything OK?
		jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)

PARSEDONE:
		popf
		clc
		jmp	short PARSE_EXIT

PARSE_ERROR:				; error entry (er, exit) point
		popf
		stc
PARSE_EXIT:				; depend on not changing CF
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; NEWARG adds the supplied argstring and cparse data to arg.argv[].
;
; ENTRY:
;   BH			argflags
;   CX			character count in argstring
;   DI			pointer to argstring
;   comptr		ptr to starting loc of current token in original command
;   [STARTEL]		cparse's answer to where the last element starts
; EXIT:
;   argbufptr		points to next free section of argbuffer
;   arg.argbuf		contains null-terminated argument strings
;   arg.argvcnt 	argument count
;   arg.argv[]		array of flags and pointers
;   arg.arg_ocomptr	ptr to starting loc of current token in original command
;   CF			set if error
;   AL			carry set:  error code; otherwise, zero

NEWARG:
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	ARG_SWITCH	; if it's a switch, record switch info
					; LEAVE SWITCH ON COMMAND LINE!!
		;;;jc	short newarg_done ; previous arg's switches -- and leave

		;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
		cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
		jge	short TO_MANY_ARGS	; exceeded array limits
		mov	dh,bh			
		;mov	bx,[ARG_ARGVCNT]	; save argflags	
		mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
		;inc	word [ARG_ARGVCNT]
		inc	word [ARG+ARG_UNIT.argvcnt]
		;mov	ax,ARG_ARGV
		mov	ax,ARG+ARG_UNIT.argv
		call	ARGV_CALC	; convert offset to pointer
		;mov	[BX].argsw_word,0 ; no switch information, yet...
		;mov	word [bx+7],0
		mov	word [bx+ARGV_ELE.argsw_word],0
		;mov	[BX].arglen,CX	; argv[argvcnt].arglen = arg length
		;mov	[bx+5],cx
		mov	[bx+ARGV_ELE.arglen],cx 
		;mov	[BX].argflags,DH ; argv[argvcnt].argflags = cparse flags
		;mov	[bx+2],dh
		mov	[bx+ARGV_ELE.argflags],dh
		mov	si,[ARGBUFPTR]
		;mov	[BX].argpointer,SI ; argv[argvcnt].argpointer = [argbufptr]
		;mov	[bx+ARGV_ELE.argpointer],si
		mov	[bx],si			
		add	si,[STARTEL]		; save startel from new location
		sub	si,di			; form pointer into argbuf
		;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
		;mov	[bx+3],si
		mov	[bx+ARGV_ELE.argstartel],si
		mov	si,[COMPTR]
		;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
		;mov	[bx+9],si
		mov	[bx+ARGV_ELE.arg_ocomptr],si

		mov	si,di			; now save argstring in argbuffer
		mov	di,[ARGBUFPTR]		; load the argbuf pointer and make
		add	di,cx			; sure we're not about to run off
		;cmp	DI, OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
		;cmp	di,ARG_ARGBUF+255
		cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
		jge	short BUF_OVFLOW     ; the end of the buffer (plus null byte)	
		sub	di,cx
		cld
		rep movsb
		mov	al,ANULL ; 0		; tack a null byte on the end
		stosb
		mov	[ARGBUFPTR],di		; update argbufptr after copy

NEWARG_DONE:
		popf
		clc
		jmp	short NEWARG_EXIT

TO_MANY_ARGS:
		mov	ax,1
		jmp	short NEWARG_ERROR

BUF_OVFLOW:
		mov	ax,2
NEWARG_ERROR:
		popf
		stc
NEWARG_EXIT:
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

; ARG_SWITCH decides if an argument might really be a switch. In the
; event that it is, and we can recognize
;
; ENTRY:
;   As in <newarg>.
; EXIT:
;   CF	    --	    clear (wasn't a switch); set (was a switch)
; NOTE(S):
;   *	The mechanism mapping a switch into a bit-value depends entirely
;	on the order of definition in the <switch_list> variable and the
;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
;	this mechanism. This code taken from CMDT:TCODE.ASM.
;   *	The <switch_list> declared below is redundant to one declared in
;	TDATA.ASM, and used in TCODE.ASM.
;   *	An ugly routine.

ARG_SWITCH:
		push	ax
		push	bx
		push	cx
		push	di
		pushf
		test	bh,sw_flag ; 1	; is it a switch? (preserve flag word)
		jz	short ARG_NO_SWITCH0
		cmp	word [LASTARG],-1 ; have we encountered any REAL args yet?
		je	short ARG_NO_SWITCH1 ; no, so leading switches don't matter
		mov	bx,[LASTARG]	; yes, add switch info to last REAL arg
		;mov	ax,offset TRANGROUP:arg.argv
		;mov	ax,ARG_ARGV
		mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
		call	ARGV_CALC
		;or	[BX].argsw_word,BP
		;or	[bx+7],bp
		or	[bx+ARGV_ELE.argsw_word],bp
		;or	arg.argswinfo,BP
		;or	[ARG_ARGSWINFO],bp
		or	[ARG+ARG_UNIT.argswinfo],bp
ARG_YES_SWITCH:
		popf
		stc
		jmp	short ARG_SWITCH_EXIT

ARG_NO_SWITCH0:
		;mov	ax,[ARG_ARGVCNT]
		mov	ax,[ARG+ARG_UNIT.argvcnt]
		mov	[LASTARG],ax
ARG_NO_SWITCH1:
		popf
		clc
ARG_SWITCH_EXIT:
		pop	di
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; ARGV_CALC maps an array index into a byte-offset from the base of
; the supplied array.  Method used for computing the address is:
;	Array Index * Array Elt Size + Base Addr = Elt Addr
; ENTRY:
;   AX	    --	    base of array
;   BX	    --	    array index
; EXIT:
;   BX	    --	    byte offset

ARGV_CALC:
		push	ax		; Save base
		mov	al,bl		; al = array index
		;mov	bl,11
		mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
		mul	bl		; ax = base offset
		pop	bx		; Get base
		add	ax,bx		; Add in base offset
		xchg	ax,bx		; Restore ax and put byte offset in bx
		retn

; ---------------------------------------------------------------------------
	
		;db 0Ah dup(0)
		;times 10 db 0
align 16

;============================================================================
; PATH1.ASM, MSDOS 6.0, 1991
;============================================================================
; 03/10/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation. Path and
;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk. Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>. Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory. This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about. This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;----------------------------------------------------------------------------

; =============== S U B	R O U T	I N E =======================================

; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
; of *argv[0].argstartel == 0 implies that there is no command (empty line
; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
; have a match, either in the current working directory if we were handed
; a filename, or in the specified directory, given a pathname. If this call
; fails, and we were given a pathname, then Path_Search fails. Otherwise,
; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
; prefix, we want to skip it) for each pathstring in userpath. Success on
; either the first invocation of search or on one of the succeeding calls
; sets up the appropriate information for copying the successful pathname
; prefix (if any) into the result buffer, followed by the successful filename
; match (from [search_best_buf]). The result is returned in in EXECPATH.
;
; ENTRY:
;   argv[0]		--	command name and associated information
; EXIT:
;   AX			--	non-zero indicates type of file found
;   EXECPATH		--	successful pathname (AX non-zero)
; NOTE(S):
;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
;   2)	Some files are more equal than others.	See search: for rankings.
;   3)	Path_Search terminates as soon as a call to search succeeds, even
;	if search returns an .exe or .bat.
;   5)	Clobbers dma address.

PBUFLEN 	EQU	128		; length of EXECPATH
PATH_SEP_CHAR	EQU	';'

;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1

		;special_delim equ 128
		;path_sep equ 4
		;wildcard equ 2
		;sw_flag  equ 1

;----------------------------------------------------------------------------

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h

PATH_SEARCH:
		push	bx
		push	cx
		push	dx		; could use a "stack 'em" instruction
		push	si
		push	di
		push	bp
		pushf

		;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
		;test	byte [ARGV0_ARG_FLAGS],3
		test	byte [ARG+ARGV_ELE.argflags],wildcard+sw_flag ; 3
		jz	short PATH_SEARCH_OK

PATH_FAILURE_JMP:
		jmp	PATH_FAILURE	; ambiguous commands not allowed

PATH_SEARCH_OK:
		call	STORE_PCHAR	; figure out the pathname separator
		mov	dx,FBUF		; clobber old dma value with
		mov	ax,SET_DMA*256 ; 1A00h ; a pointer to our dma buffer
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
		push	es
		call	FIND_PATH	; get a handle (ES:DI) on user path
		mov	[PATHINFO+0],es	; and squirrel it away
		mov	[PATHINFO+2],di	; "old" pathstring pointer
		mov	[PATHINFO+4],di	; "new" pathstring pointer
		pop	es
		
		mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
		mov	si,EXECPATH
		call	STRIP
		jc	short PATH_FAILURE_JMP ; if possible, of course
		
		mov	dx,si		; search (EXECPATH, error_message)
		mov	word [SEARCH_ERROR],BADDRVPTR
		call	PSEARCH		; must do at least one search
		or	ax,ax		; find anything?
		jz	short PATH_NOINIT ; failure ... search farther	
		
		mov	bp,ax		; success... save filetype code	
		mov	di,EXECPATH
		;mov	si,ds:arg.argv[0].argpointer
		;mov	si,[ARG_ARGV]
		mov	si,[ARG+ARGV_ELE.argpointer]
		;mov	cx,ds:arg.argv[0].argstartel
		;mov	cx,[ARGV0_ARGSTARTEL]
		mov	cx,[ARG+ARGV_ELE.argstartel]
		sub	cx,si		; compute prefix bytes to copy

; We have the number of bytes in the prefix (up to the final component).
; We need to form the complete pathname including leading drive and current
; directory.
;
; Is there a drive letter present?

		mov	ah,':'
		cmp	cx,2		; room for drive letter?
		jb	short ADDDRIVE	; no, stick it in
		cmp	[si+1],	ah	; colon present?
		jz	short MOVEDRIVE	; yes, just move it
ADDDRIVE:
		mov	al,[CURDRV]	; get current drive
		add	al,'A'		; convert to uppercase letter
		stosw			; store d:
		jmp	short CHECKPATH

MOVEDRIVE:
		lodsw			; move d:
		stosw
		sub	cx,2		; 2 bytes less to move
CHECKPATH:
		or	al,20h
		mov	dl,al		
		;sub	dl,60h
		sub	dl,'a'-1	; convert to 1-based for current dir

; Stick in beginning path char

		mov	al,[PSEP_CHAR]
		stosb

; Is there a leading /? If so, then no current dir copy is necessary.
; Otherwise, get current dir for DL.

		cmp	cx,1		; is there room for path char?
		jb	short ADDPATH	; no, go add path
		lodsb
		dec	cx
		cmp	al,[PSEP_CHAR]	; is there a path separator?
		jz	short MOVEPATH	; yes, go move remainder of path
		inc	cx
		dec	si		; undo the lodsb
ADDPATH:
		push	si
		mov	si,di		; remainder of buffer
		mov	ax,CURRENT_DIR*256 ; 4700h
		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
				; DL = drive (0=default,1=A,etc.)
				; DS:SI	points to 64-byte buffer area

; The previous current dir will succeed a previous find_first already worked.
;
; Find end of string.

		mov	di,si
		pop	si
		mov	al,[PSEP_CHAR]
		cmp	byte [di],0	; root (empty dir string)?
		jz	short MOVEPATH	; yes, no need for path char
SCANEND:
		cmp	byte [di],0	; end of string?
		jz	short FOUNDEND
		inc	di
		jmp	short SCANEND

; Stick in a trailing path char.

FOUNDEND:
		stosb

; Move remaining part of path.	Skip leading path char if present.

MOVEPATH:
		cmp	[si],al		; first char a path char?
		jnz	short COPYPATH
		inc	si		; move past leading char
		dec	cx		; drop from count
COPYPATH:
		jcxz	_COPYDONE	; no chars to move!	
		rep movsb
_COPYDONE:
		jmp	PATH_SUCCESS	; run off and form complete pathname

PATH_NOINIT:
		;test	ds:arg.argv[0].argflags, MASK path_sep
		;test	byte [ARGV0_ARG_FLAGS],4
		test	byte [ARG+ARGV_ELE.argflags],path_sep
		jnz	short PATH_FAILURE ; complete pathname specified ==> fail
		;mov	bh,';'
		mov	bh,PATH_SEP_CHAR ; semicolon terminates pathstring
		;mov	dx,ds:arg.argv[0].argstartel
					; this is where the last element starts
		;mov	dx,[ARGV0_ARGSTARTEL]
		mov	dx,[ARG+ARGV_ELE.argstartel]
		;sub	dx,ds:arg.argv[0].argpointer
					; form pointer into EXECPATH,
		;sub	dx,[ARG_ARGV]
		sub	dx,[ARG+ARGV_ELE.argpointer]
		add	dx,EXECPATH	; skipping over drive spec, if any
PATH_LOOP:
		call	PATH_CRUNCH	; pcrunch (EXECPATH, pathinfo)
		mov	bp,ax		; save filetype code
		lahf			; save flags, just in case
		or	bp,bp		; did path_crunch find anything?		
		jnz	short PATH_FOUND 
		sahf			; see?	needed those flags, after all!
		jnb	short PATH_LOOP	; is there anything left to the path?
PATH_FAILURE:
		xor	ax,ax
		jmp	short PATH_EXIT

PATH_FOUND:				; pathinfo[] points to winner
		mov	di,EXECPATH
		;mov	cx,pathinfo[4] 
		mov	cx,[PATHINFO+4]	; "new" pointer -- end of string
		;mov	SI,pathinfo[2]
		mov	si,[PATHINFO+2]	; "old" pointer -- beginning of string

;	BAS Nov 20/84
;   Look at the pathname and expand . and .. if they are the first element
;   in the pathname (after the drive letter)

		push	es
		;push	pathinfo[0]
		push	word [PATHINFO+0]
		pop	es
;SR;
; Oops! Gets fooled if path= \;..
; We should also check if a drive letter is really present
;
		cmp	byte [es:si+2],'.' ; Look for Current dir at start of path
		jnz	short PATH_CPY

		; MSDOS 6.0
		;cmp	byte ptr es:[si+1],':' ;does path have drive letter?
		;jnz	path_cpy	       ;no, copy the path string

		push	cx		; Save pointer to end of string
		mov	al,[es:si]
		mov	[di],al		; Copy drive letter, :, and root char
		mov	al,[es:si+1]	; to EXECPATH
		mov	[di+1],al
		mov	al,[PSEP_CHAR]
		mov	[di+2],	al
		push	si		; Save pointer to begining of string
		mov	dl,[es:si]	; Convert device letter for cur dir
		or	dl,20h
		;sub	dl,60h
		sub	dl,'a'-1
		mov	si,di		; pointer to EXECPATH
		add	si,3		; Don't wipe out drive and root info
		mov	ax,CURRENT_DIR*256 ; 4700h
		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
				; DL = drive (0=default,1=A,etc.)
				; DS:SI	points to 64-byte buffer area
		call	DSTRLEN		; Determine length of present info
		add	si,cx		; Don't copy over drive and root info
		dec	si
		mov	di,si		; Point to end of target string
		pop	si		; Restore pointer to begining of string
		add	si,3		; Point past drive letter, :, .
		pop	cx		; Restore pointer to end of string
PATH_CPY:
		pop	es
		sub	cx,si		; yields character count
		push	ds		; time to switch segments
		push	word [PATHINFO+0] ; string lives in this segment
		pop	ds
		cld
		rep movsb
		pop	ds		; return to our segment
		dec	di		; overwrite terminator
		mov	al,[PSEP_CHAR]	; with a pathname separator
		cmp	al,[di-1]
		jz	short PATH_SUCCESS
		stosb
PATH_SUCCESS:
		mov	si,SEARCH_BEST_BUF
		xor	cx,cx
PATH_SUCC_LOOP:
		lodsb			; append winning filename to path
		stosb			; (including terminating null)	
		or	al,al
		jnz	short PATH_SUCC_LOOP
		mov	ax,bp		; retrieve filetype code
PATH_EXIT:
		popf
		pop	bp
		pop	di
		pop	si		; chill out...
		pop	dx
		pop	cx
		pop	bx
		retn


; =============== S U B	R O U T	I N E =======================================

; STORE_PCHAR determines the pathname-element separator and squirrels
; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
;
; ENTRY:
; EXIT:
; NOTE(S):
;   *	Uses <psep_char>, defined in <path_search>.

STORE_PCHAR:
		push	ax
		mov	al,'/'		; is the pathname-element separator
		call	PATHCHRCMP	; a regular slash?
		jz	short STORE_SLASH ; if yes, remember slash
		mov	al,'\'
		mov	[PSEP_CHAR],al	; otherwise, remember back-slash
		pop	ax
		retn
STORE_SLASH:
		mov	[PSEP_CHAR],al
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
; EXECPATH, and smooshes them into tpbuf. The caller may supply an
; additional separator to use for breaking up the path-string. Null is the
; default. Once the user-string has been formed, search is invoked to see
; what's out there.
;
; ENTRY:
;   BH			--	additional terminator character
;   SI			--	pointer into pathstring to be dissected
;   DX			--	pointer to stripped filename
; EXIT:
;   AX			--	non-zero (file type), zero (nothing found)
;   SI			--	moves along pathstring from call to call
;   [search_best_buf]	--	name of best file (AX non-zero)
;   [tpbuf]		--	clobbered
; NOTE(S):
;   *	Implicit in this code is the ability to specify when to search
;	the current directory (if at all) through the PATH defined by
;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
;	current directory before the bin and etc directories of drive c).

PATH_CRUNCH:
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	STORE_PCHAR	; figure out pathname separator
		mov	di,TPBUF	; destination of concatenated string
		mov	si,[PATHINFO+4]	; "new" pointer to start with
		mov	[PATHINFO+2],si	; becomes "old" pointer
		push	ds		; save old segment pointer
		push	word [PATHINFO+0] ; replace with pointer to userpath's
		pop	ds		; segment		
PATH_CR_COPY:
		lodsb			; get a pathname byte
		or	al,al		; check for terminator(s)
		jz	short PATH_SEG	; null terminates segment & pathstring
		cmp	al,bh
		jz	short PATH_SEG	; BH terminates a pathstring segment
		stosb
		jmp	short PATH_CR_COPY

PATH_SEG:
		pop	ds		; restore old data segment
		mov	[PATHINFO+4],si	; save "new" pointer for next time
		mov	bl,al		; remember if we saw null or not...
					;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
		xor	ax,ax		; in case nothing in pathstr...
		cmp	di,TPBUF	; was there really anything in pathstr?		
		jz	short PATH_CR_LEAVE 
					; if nothing was copied, pathstr empty
PATH_CR_LOOK:
		mov	al,[PSEP_CHAR]	; form complete pathname
		cmp	al,[di-1]	; add pathname separator for suffix
		jz	short PATH_CR_L1
		stosb
PATH_CR_L1:
		mov	si,dx
PATH_CR_L2:
		lodsb			; tack the stripped filename onto
		stosb			; the end of the path, up to and
		or	al,al		; including the terminating null
		jnz	short PATH_CR_L2
		mov	dx,TPBUF	; and look for an appropriate file...	
		mov	word [SEARCH_ERROR],BADPMESPTR
		;invoke search
		call	PSEARCH		; results are in AX & search_best_buf

PATH_CR_LEAVE:
		or	bl,bl		; did we finish off the pathstring?
		jz	short PATH_CR_EMPTY ; null in BL means all gone...
		popf			; otherwise, plenty left
		clc
		jmp	short PATH_CR_EXIT

PATH_CR_EMPTY:
		popf
		stc
PATH_CR_EXIT:
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn

;============================================================================
; PATH2.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/10/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions: .com, .exe, .bat (highest to
; lowest priority). Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   fbuf	--	dma buffer for findfirst/next
; EXIT:
;   AX		--	8)  file found with .com extension
;			4)  file found with .exe extension
;			2)  file found with .bat extension
;			0)  no such file to be found
;   (if AX is non-zero:)
;   [search_best]	identical to AX
;   [search_best_buf]	null-terminated filename
; NOTES:
;   1)	Requires caller to have allocated a dma buffer and executed a setdma.
;---------------
; CONSTANTS:
;---------------
SEARCH_FILE_NOT_FOUND	EQU	0
SEARCH_COM		EQU	8
SEARCH_EXE		EQU	4
SEARCH_BAT		EQU	2
FNAME_LEN		EQU	8
FNAME_MAX_LEN		EQU	13
DOT			EQU	'.'
WILDCHAR		EQU	'?'


; =============== S U B	R O U T	I N E =======================================

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h

PSEARCH:
		push	cx
		push	dx
		push	di
		push	si
		pushf
		push	dx		; check drivespec (save pname ptr)
		mov	di,dx		; working copy of pathname
		mov	si,SEARCH_CURDIR_BUF
		xor	dx,dx		; zero means current drive
		cmp	byte [di+1],':'	; is there a drive spec?
		jne	short SEARCH_DIR_CHECK
		mov	dl,[di]		; get the drive byte
		and	dl,0DFh ; ~20h	; uppercase the sucker
		sub	dl,'@'		; and convert to drive number
SEARCH_DIR_CHECK:
		mov	ax,CURRENT_DIR*256 ; 4700h
		int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
				; DL = drive (0=default,1=A,etc.)
				; DS:SI	points to 64-byte buffer area
		pop	dx		; directory? If we can't we'll		
		jc	short SEARCH_INVALID_DRIVE ; assume it's a bad drive...
		mov	cx,SEARCH_ATTR ; 13h 	; filetypes to search for
		mov	ax,FIND_FIRST*256 ; 4E00h ; request first match, if any
		int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
				; CX = search attributes
				; DS:DX	-> ASCIZ filespec
				; (drive,path,	and wildcards allowed)
		jc	short SEARCH_NO_FILE
		mov	byte [SEARCH_BEST],SEARCH_FILE_NOT_FOUND ; 0
		mov	byte [SEARCH_BEST_BUF],ANULL ; 0 ; nothing's been found, yet
SEARCH_LOOP:
		call	SEARCH_FTYPE	; determine if .com, &c...
		cmp	al,[SEARCH_BEST] ; better than what we've found so far?
		jle	short SEARCH_NEXT ; no, look for another	
		mov	[SEARCH_BEST],al ; found something... save its code	
		;mov	si,offset TRANGROUP:fbuf.find_buf_pname
		;mov	si,FBUF_PNAME
		mov	si,FBUF+FIND_BUF.PNAME
		mov	di,SEARCH_BEST_BUF
		mov	cx,FNAME_MAX_LEN ; 13
		cld
		rep movsb		; save complete pathname representation
		cmp	al,SEARCH_COM ; 8 ; have we found the best of all?	
		je	short SEARCH_DONE
SEARCH_NEXT:				; keep on looking
		mov	cx,SEARCH_ATTR ; 13h
		mov	ax,FIND_NEXT*256 ; 4F00h ; next match
		int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
				; [DTA]	= data block from
				; last AH = 4Eh/4Fh call
		jnc	short SEARCH_LOOP
SEARCH_DONE:				; it's all over with...
		mov	al,[SEARCH_BEST] ; pick best to return with
		; MSDOS 6.0
		;cmp	ext_entered,1	;AN005; Did user request a specific ext?
		;jz	search_exit	;AN005; no - exit
		;mov	al,ext_entered	;AN005; yes - get the real file type back
		;mov	search_best,al	;AN005; save the real file type
		;
		jmp	short SEARCH_EXIT

SEARCH_INVALID_DRIVE:			 ; Tell the user path/drive
		mov	dx,[SEARCH_ERROR] ; appropriate error message
		call	STD_PRINTF	 ; and pretend no file found

SEARCH_NO_FILE:				; couldn't find a match
		mov	ax,SEARCH_FILE_NOT_FOUND ; 0

SEARCH_EXIT:
		popf
		pop	si
		pop	di
		pop	dx
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

; SEARCH_FTYPE determines the type of a file by examining its extension.
;
; ENTRY:
;   fbuf    --	    dma buffer containing filename
; EXIT:
;   AX	    --	    file code, as given in search header
; NOTE(S):
;   *	Implicit assumption that NULL == search_file_not_found

SEARCH_FTYPE:
		push	di
		push	si
		mov	ax,ANULL ; 0	; find the end of the filename
		;mov	di,offset TRANGROUP:fbuf.find_buf_pname
		;mov	di,FBUF_PNAME
		mov	di,FBUF+FIND_BUF.PNAME
		mov	cx,FNAME_MAX_LEN ; 13
		cld
		repnz scasb		; search for the terminating null
		jnz	short FTYPE_EXIT ; weird... no null byte at end
		sub	di,5		; . + E + X + T + NULL

		; Compare .COM

		mov	si,COMEXT ; ".COM"
		mov	ax,di
		cmpsw
		jnz	short FTYPE_EXE
		cmpsw
		jnz	short FTYPE_EXE
		;mov	ax,8
		mov	ax,SEARCH_COM	; success!
		jmp	short FTYPE_EXIT

		; Compare .EXE
FTYPE_EXE:				; still looking... now for '.exe'
		mov	di,ax
		mov	si,EXEEXT ; ".EXE"
		cmpsw
		jnz	short FTYPE_BAT
		cmpsw
		jnz	short FTYPE_BAT
		;mov	ax,4
		mov	ax,SEARCH_EXE	; success!
		jmp	short FTYPE_EXIT

		; Compare .BAT
FTYPE_BAT:				; still looking... now for '.bat'
		mov	di,ax
		mov	si,BATEXT ; ".BAT"
		cmpsw
		jnz	short FTYPE_FAIL
		cmpsw
		jnz	short FTYPE_FAIL
		;mov	ax,2
		mov	ax,SEARCH_BAT	; success!
		jmp	short FTYPE_EXIT

FTYPE_FAIL:				; file doesn't match what we need
		mov	ax,ANULL ; 0

FTYPE_EXIT:
		; MSDOS 6.0
		;cmp	ext_entered,1	;AN005; was an extension entered?
		;jz	ftype_done	;AN005; no - exit
		;cmp	ax,ANULL	;AN005; was any match found
		;jz	ftype_done	;AN005; no - exit
		;mov	ext_entered,al	;AN005; save the match type found
		;mov	AX,search_com	;AN005; send back best was found to stop search
;ftype_done:
		pop	si
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

; STRIP copies the source string (argv[0]) into the destination buffer,
; replacing any extension with wildcards.
;
; ENTRY:
;	BX		--		maximum length of destination buffer
;	DS:SI		--		address of destination buffer
;	argv[0] 	--		command name to be stripped
; EXIT:
;	CF		--		set if failure, clear if successful
; NOTE(S):


STRIP:
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		
		; MSDOS 6.0
		;mov	ext_entered,1	;AN005; assume no extension on file name

		; MSDOS 3.3 (& MSDOS 6.0)
		;mov	dx,[ARG_ARGV]
		;mov	dx,ds:arg.argv[0].argpointer
					; save pointer to beginning of argstring
		;mov	dx,[ARGV0_ARGPOINTER]
		mov	dx,[ARG+ARGV_ELE.argpointer]
		;mov	di,ds:arg.argv[0].argstartel
					; beginning of last pathname element
		;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
		mov	di,[ARG+ARGV_ELE.argstartel]
		cmp	byte [di],0	; *STARTEL == NULL means no command
		je	short STRIP_ERROR
		mov	cx,dx		; compute where end of argstring lies
		;add	cx,ds:arg.argv[0].arglen
		;add	cx,[ARGV0_ARGLEN]
		add	cx,[ARG+ARGV_ELE.arglen]
		sub	cx,di		; and then find length of last element
		inc	cx		; include null as well
		;mov	al,'.'
		mov	al,DOT		; let's find the filetype extension
		cld
		repnz scasb		; wind up pointing to either null or dot

		; MSDOS 6.0
		;jcxz	process_ext	;AN005; if no extension found, just continue
		;mov	ext_entered,0	;AN005; we found an extension
		;mov	al,ANULL	;AN005; continue scanning until the
		;repnz	scasb		;AN005;    end of line is reached.
PROCESS_EXT:
		; MSDOS 3.3 (& MSDOS 6.0)
		mov	cx,di		; pointer to end of argstring yields
		sub	cx,dx		; number of bytes to be copied
		sub	bx,4		; can argstring fit into dest. buffer?
		cmp	cx,bx
		jg	short STRIP_ERROR ; if not, we must have a bad pathname
		mov	di,si		; destination buffer
		mov	si,dx		; source is beginning of pathname
		cld
		rep movsb		; SI=arg,DI=buffer,CX=argend-argbeg

		; MSDOS 6.0
		;cmp	ext_entered,1	;AN005; if an extension was entered
		;jne	skip_wilds	;AN005;    don't set up wildcard ext.

		; MSDOS 3.3 (& MSDOS 6.0)
		dec	di		; overwrite null or dot
		stosb			; with a dot
		;mov	al,'?'
		mov	al,WILDCHAR	; now add wildcards
		stosb
		stosb
		stosb
		;mov	al,0
		mov	al,ANULL	; and a terminating null	
		stosb
SKIP_WILDS:
		popf
		clc
		jmp	short STRIP_EXIT ; chill out...

STRIP_ERROR:
		popf
		stc
STRIP_EXIT:
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
;
; structure in newly allocated memory. The argv[] structure is found at the
; beginning of this area. The caller indicates how much extra space is
; needed in the resulting structure; Save_Args returns a segment number and
; an offset into that area, indicating where the caller may preserve its own
; data. Note that <argvcnt> can be found at <offset-2>.
; ENTRY:
;   BX	    --	    size (in bytes) of extra area to allocate
; EXIT:
;   AX	    --	    segment of new area.
;   CF	    --	    set if unable to save a copy.
; NOTE(S):
;   1)	The allocated area will be AT LEAST the size requested -- since
;	the underlying MSDOS call, <alloc> returns an integral number of
;	paragraphs.
;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
;	as the caller of Save_Args requests.
;   3)	AX is undefined if CF indicates an error.

SAVE_ARGS:
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		pushf
		;add	bx,1363		; space for arg structure, round up
		add	bx,ARG_UNIT.SIZE+15 ; 1348+15
		mov	cl,4		; to paragraph size and convert
		shr	bx,cl		; size in bytes to size in paragraphs
		mov	ax,ALLOC*256 ; 4800h
		int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
		jc	short SAVE_ERROR
		mov	bp,ax		; save segment id
		push	es		; save TRANGROUP address
		mov	es,ax		; switch to new memory segment
		; assume es:nothing
		;mov	cx,1348		; get back structure size
		mov	cx,ARG_UNIT.SIZE
		xor	di,di		; destination is new memory area
		;mov	si,ARG_ARGV
		mov	si,ARG		; source is arg structure
		rep movsb		; move that sucker!
		;mov	cx,arg.argvcnt 	; adjust argv pointers
		;mov	cx,[ARG_ARGVCNT]
		mov	cx,[ARG+ARG_UNIT.argvcnt]
		xor	ax,ax		; base address for argv_calc

	;	Bugbug:	What did they mean by this?
	;	Note that the replacement line produces exactly the same code.
	;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
	;	mov	SI, OFFSET TRANGROUP:arg

		;mov	si,ARG_ARGV
		mov	si,ARG	
SAVE_PTR_LOOP:
		dec	cx		; exhausted all args?
		jl	short SAVE_DONE
		mov	bx,cx		; get arg index and
		call	ARGV_CALC	; convert to a pointer
		;mov	dx,ds:arg.argv[bx].argpointer
		;mov	dx,[ARG_ARGV+bx]
		mov	dx,[ARG+ARGV_ELE.argpointer+bx]
		sub	dx,si		; adjust argpointer
		;mov	es:argv[BX].argpointer,dx
		;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
		mov	[es:bx],dx
		;mov	dx,ds:arg.argv[bx].argstartel
		;mov	dx,[ARGV0_ARGSTARTEL+bx]
		mov	dx,[ARG+ARGV_ELE.argstartel+bx]
		sub	dx,si		; and adjust argstartel
		;mov	es:argv[bx].argstartel,dx
		;mov	[es:bx+3],dx
		mov	[es:bx+ARGV_ELE.argstartel],dx
		;mov	dx,ds:arg.argv[bx].arg_ocomptr
		;mov	dx,[ARGV0_OCOMPTR+bx]
		mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
		sub	dx,si		; and adjust arg_ocomptr
		;mov	es:argv[bx].arg_ocomptr,dx
		;mov	[es:bx+9],dx
		mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
		jmp	short SAVE_PTR_LOOP
SAVE_DONE:
		pop	es		; back we go to TRANGROUP
		; assume es:nothing
		mov	ax,bp		; restore segment id
		jmp	short SAVE_OK

SAVE_ERROR:
		popf
		stc
		jmp	short SAVE_EXIT

SAVE_OK:
		popf
		clc
SAVE_EXIT:
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn

;============================================================================
; TUCODE.ASM, MSDOS 6.0, 1991 (1)
;============================================================================
; 02/10/2018 - Retro DOS v3.0

; Title	COMMAND Language midifiable Code Transient

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h

; =============== S U B	R O U T	I N E =======================================

; ****************************************************************
; *
; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
; *
; * FUNCTION:	 Delete files based on user parsed input. Prompt
; *		 user for Y/N if necessary. If an error occurs,
; *		 set up an error message and go to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************
;
; ARE YOU SURE prompt when deleting *.*

NOTEST2:
		mov	cx,11
		mov	si,FCB+1 ; 5Dh
AMBSPEC:
		lodsb
		cmp	al,'?'
		jnz	short ALLFIL
		loop	AMBSPEC
ALLFIL:
		cmp	cx,0
		jnz	short NOPRMPT
ASKAGN:	
		mov	dx,SUREMESPTR	; "Are you sure (Y/N)?"
		call	STD_PRINTF
		mov	si,80h
		mov	dx,si
		mov	word [si],120	; zero length
		;mov	ax,0C0Ah
		mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_STRING_INPUT
		int	21h	; DOS -	CLEAR KEYBOARD BUFFER
				; AL must be 01h,06h,07h,08h or 0Ah.
		lodsw
		or	ah,ah
		jz	short ASKAGN
		call	SCANOFF
		; MSDOS 6.0
		;call	char_in_xlat	; Convert to upper case
		;retc			; return if function not supported
		; MSDOS 3.3
		call	UPCONV
		
		;; MSDOS 3.3 (& MSDOS 6.0)
		cmp	al,[CAPITAL_N]
		jne	short CHECK_Y
		retn
CHECK_Y:
		cmp	al,[CAPITAL_Y]
		pushf
		call	CRLF2
		popf
		jne	short ASKAGN
NOPRMPT:
		mov	ah,FCB_DELETE ; 13h
		mov	dx,FCB ; 5Ch
		int	21h	; DOS -	DELETE FILE via	FCB
				; DS:DX	-> FCB with filename field filled with
				; template for	deletion ('?' wildcard allowed,but not '*')
				; Return: AL = 00h file	found,FFh file	not found
		inc	al
		jz	short ERAERR
		call	RESTUDIR
		retn

		; MSDOS 6.0
;eraerr:
		;invoke	set_ext_error_msg	;AN022; set up the extended error
		;push	dx			;AN022; save message
		;invoke	RESTUDIR
		;pop	dx			;AN022; restore message
		;
		;cmp	word ptr extend_buf_ptr,error_no_more_files 
		;				;AN022; convert no more files to
		;jnz	cerrorj2		;AN022; 	file not found
		;mov	Extend_Buf_ptr,error_file_not_found  
		;			;AN000; get message number in control block
;cerrorj2:
		;jmp	cerror
	
		; MSDOS 3.3
ERAERR:	
		mov	ah,SET_DMA ; 1Ah
		mov	dx,FCB ; 5Ch
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah,DIR_SEARCH_FIRST ; 11h
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		push	ax
		call	RESTUDIR
		pop	ax
		mov	dx,FNOTFOUNDPTR
		inc	al
		jz	short CERRORJ
		mov	dx,ACCDENPTR
		jmp	CERROR

; =============== S U B	R O U T	I N E =======================================

; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"

ECHO:
		call	ON_OFF
		jb	short DOEMES
		mov	ds,[RESSEG]
		jnz	short ECH_OFF
		or	byte [ECHOFLAG],1
		retn

ECH_OFF:
		and	byte [ECHOFLAG],0FEh
		retn

; There was no discrenable ON or OFF after the ECHO. If there is nothing but
; delimiters on the command line, we issue the ECHO is ON/OFF message.

DOEMES:
		; MSDOS 6.0
		;cmp	cl,0		;AC000; was anything on the line?
		;jz	PECHO		; just display current state.
		;MOV	DX,82H		; Skip one char after "ECHO"
		;invoke	CRPRINT
		;JMP	CRLF2

		; MSDOS 3.3
		call	MOVE_TO_FIRST_ARG
		jz	short PECHO
		mov	dx,82h
		call	CRPRINT
		jmp	CRLF2

PECHO:
		; MSDOS 3.3 (& MSDOS 6.0)
		mov	ds,[RESSEG]
		mov	bl,byte [ECHOFLAG]
		push	cs
		pop	ds
		and	bl,1
		mov	dx,ECHOMESPTR
		jmp	short PYN

; ---------------------------------------------------------------------------

		; MSDOS 3.3
CERRORJ:
		jmp	CERROR


; =============== S U B	R O U T	I N E =======================================

MOVE_TO_FIRST_ARG:
		mov	si,81h
		call	SCANOFF
		cmp	al,0Dh
		retn

; =============== S U B	R O U T	I N E =======================================

CNTRLC:
		call	ON_OFF
		mov	ax,(SET_CTRL_C_TRAPPING<<8)|1 ;3301h
		jc	short PCNTRLC
		jnz	short CNTRLC_OFF
		mov	dl,1
		int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
				; AL = 00h get state / 01h set state / 02h set AND get
				; DL = 00h for OFF or 01h for ON
		retn

; ---------------------------------------------------------------------------

CNTRLC_OFF:
		xor	dl,dl
		int	21h		; Turn off ^C check
		retn

; ---------------------------------------------------------------------------

PCNTRLC:
		; MSDOS 6.0
		;CMP	CL,0		;AC000; rest of line blank?
		;JNZ	CERRORJ 	; no, oops!

		; MSDOS 3.3
		call	MOVE_TO_FIRST_ARG
		jnz	short CERRORJ
;pccont:
		; MSDOS 3.3 (& MSDOS 6.0)
		xor	al,al
		int	21h		; get Ctrl-Break state (ah=33h)
		mov	bl,dl
		mov	dx,CTRLMESPTR

; ---------------------------------------------------------------------------

PYN:		; write "ON" or "OFF" state 

		call	STD_PRINTF
		mov	dx,ONMESPTR	;AC000; get ON pointer
		or	bl,bl
		jnz	short PRINTVAL
		mov	dx,OFFMESPTR	;AC000; get OFF pointer

PRINTVAL:
		; MSDOS 3.3
		jmp	STD_PRINTF

		; MSDOS 6.0
		;push	dx		;AN000; save offset of message block
		;mov	bx,dx		;AN000; save offset value
		;lodsw			;AN000; get message number of on or off
		;mov	dh,util_msg_class ;AN000; this is a utility message
		;invoke	Tsysgetmsg	;AN000; get the address of the message
		;add	bx,ptr_off_pos	;AN000; point to offset of ON/OFF
		;mov	word ptr [bx],si ;AN000; put the offset in the message block
		;pop	dx		;AN000; get message back
		;invoke	std_printf	;AC000; go print message
		;mov	word ptr [bx],0 ;AN000; zero out message pointer
		;
		;ret			;AN000; exit

; =============== S U B	R O U T	I N E =======================================

VERIFY:
		call	ON_OFF
		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
		jc	short PVERIFY
		jnz	short VER_OFF
		int	21h	; DOS -	SET VERIFY FLAG
				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
		retn

; ---------------------------------------------------------------------------

VER_OFF:
		dec	al
		int	21h		; Turn off verify after write
		retn

; ---------------------------------------------------------------------------

PVERIFY:
		; MSDOS 6.0
		;CMP	CL,0		;AC000; is rest of line blank?
		;JNZ	CERRORJ 	; nope...

		; MSDOS 3.3
		call	MOVE_TO_FIRST_ARG
		jnz	short CERRORJ

		mov	ah,GET_VERIFY_ON_WRITE ; 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		mov	bl,al
		mov	dx,VERIMESPTR
		jmp	short PYN

; =============== S U B	R O U T	I N E =======================================

; ****************************************************************
; *
; * ROUTINE:	 ON_OFF
; *
; * FUNCTION:	 Parse the command line for an optional ON or
; *		 OFF string for the BREAK, VERIFY, and ECHO
; *		 routines.
; *
; * INPUT:	 command line at offset 81H
; *		 PARSE_BREAK control block
; *
; * OUTPUT:	 If carry is clear
; *		    If ON is found
; *		       Zero flag set
; *		    If OFF is found
; *		       Zero flag clear
; *		 If carry set
; *		    If nothing on command line
; *		       CL set to zero
; *		    If error
; *		       CL contains error value from parse
; *
; ****************************************************************

ON_OFF:
		mov	si,81h

		; MSDOS 3.3
		call	SCANOFF		; scan off leading blanks & equal
		cmp	al,0Dh		; are we at end of line?
		je	short BAD_ONF	; yes, return error
		lodsw
		or	ax,2020h	; convert to lowercase
		cmp	ax,6E6Fh ;'on'
		je	short ON_CHECK
		cmp	ax,666Fh ;'of'
		jne	short BAD_ONF
		lodsb
		or	al,20h		; convert to lowercase		
		cmp	al,66h	 ; 'f'
		jne	short BAD_ONF	
		or	al,66h ; or al,'f'
		jmp	short OFF_CHECK
ON_CHECK:
		xor	al,al
OFF_CHECK:
		lahf
		mov	bx,ax
		call	SCANOFF		; scan off leading blanks & equal
		cmp	al,0Dh		; are we at end of line?	
		jne	short BAD_ONF	; no, return error
		mov	ax,bx
		sahf
		clc
		retn

		; MSDOS 6.0
;scan_on_off:				;AN032; scan off leading blanks & equal
;		lodsb			;AN032; get a char
;		cmp	al,blank	;AN032; if whitespace
;		jz	scan_on_off	;AN032;    keep scanning
;		cmp	al,tab_chr	;AN032; if tab
;		jz	scan_on_off	;AN032;    keep scanning
;		cmp	al,equal_chr	;AN032; if equal char
;		jz	parse_on_off	;AN032;    start parsing
;		dec	si		;AN032; if none of above - back up
;
;parse_on_off:				;AN032;    and start parsing
;		mov	di,offset trangroup:parse_break ;AN000; Get adderss of PARSE_BREAK
;		xor	cx,cx		;AN000; clear cx,dx
;		xor	dx,dx		;AN000;
;		invoke	cmd_parse	;AC000; call parser
;		cmp	ax,end_of_line	;AC000; are we at end of line?
;		jz	BADONF		;AC000; yes, return error
;		cmp	ax,result_no_error ;AN000; did an error occur
;		jz	on_off_there	;AN000; no - continue
;		mov	cx,ax		;AN000; yes - set cl to error code
;		jmp	short BADONF	;AN000; return error
;
;on_off_there:
;		cmp	parse1_code,-1	;AN014; was a valid positional present?
;		jnz	good_on_off	;AN014; yes - continue
;		mov	cx,badparm_ptr	;AN014; something other than ON/OFF
;		jmp	short BADONF	;AN014; return error
;
;good_on_off:				;AN014;
;		xor	ax,ax		;AC000; set up return code for
;		or	al,parse1_code	;AC000;    ON or OFF in AX
;		pushf			;AN000; save flags
;		mov	di,offset trangroup:parse_break
;					;AN000; Get adderss of PARSE_BREAK
;		xor	dx,dx		;AN000;
;		invoke	cmd_parse	;AN000; call parser
;		cmp	ax,end_of_line	;AN000; are we at end of line?
;		jnz	BADONF_flags	;AN000; NO, return error
;		popf			;AN000; restore flags
;		clc			;AC000; no error
;		jmp	short on_off_end ;AN000; return to caller
;
;BADONF_flags:
;		mov	cx,ax
;		popf

; ---------------------------------------------------------------------------

; No discernable ON or OFF has been found. Put an error message pointer in DX
; and return the error

BAD_ONF:
		mov	dx,BADONOFFPTR
		stc
;on_off_end:
		retn

;============================================================================
; TCMD1B.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/10/2018 - Retro DOS v3.0

; Print volume ID info

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h

; ---------------------------------------------------------------------------

PRINTVOL:
		push	ax		; AX return from SEARCH_FIRST for VOL ID
		mov	al,[FCB] ; 5Ch	; get drive letter
		add	al,'@'
		cmp	al,'@'
		jnz	short DRVOK
		mov	al,[CURDRV]
		add	al,[CAPITAL_A]
DRVOK:
		mov	[VOL_DRV],al	; get drive letter into argument
		pop	ax		; get return code back
		mov	dx,NOVOL ; "has	no label" 
		or	al,al		; volume label found?
		jnz	short PRINTVOL2	; print no volume message
GOODVOL:
		; MSDOS 3.3
		mov	di,CHARBUF
		mov	dx,di
		mov	si,IS	; "is "
		call	STRCPY
		dec	di
		mov	si,DIRBUF+8
		mov	cx,11
		rep movsb
		xor	ax,ax
		;xor	al,al  ; MSDOS 6.0
		stosb			; store a zero to terminate the string
PRINTVOL2:
		mov	[VOLNAME_ADDR],dx
		mov	dx,VOLMESPTR
		jmp	PRINTF_CRLF

		; MSDOS 6.0
;drvok:
;		mov	vol_drv,al	;AC000; get drive letter into argument
;		pop	ax		;AC000; get return code back
;		or	al,al		;AC000; volume label found?
;		jz	Get_vol_name	;AC000; volume label exists - go get it
;		mov	dx,offset trangroup:VolMes_ptr_2 
;					;AC000; set up no volume message
;		jmp	short print_serial	;AC000; go print it
;
;Get_vol_name:
;		mov	di,offset trangroup:charbuf
;		mov	dx,di
;		mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
;		mov	cx,11				;AN000;  3/3/KK
;		rep	movsb				;AN000;  3/3/KK
;
;		xor	al,al		;AC000; store a zero to terminate the string
;		stosb
;		mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
;
;PRINT_SERIAL:
;
;; Attempt to get the volume serial number from the disk.  If an error
;; occurs, do not print volume serial number.
;
;		push	dx		;AN000; save message offset
;		mov	ax,(GetSetMediaID SHL 8) 
;					;AC036; Get the volume serial info
;		mov	bl,DS:[FCB]	;AN000; get drive number from FCB
;		mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
;		int	21h		;AN000; do the call
;		pop	dx		;AN000; get message offset back
;		jc	printvol_end	;AN000; if error, just go print label
;		call	std_printf	;AC000; go print volume message
;		mov	al,blank	;AN051; Print out a blank
;		invoke	print_char	;AN051;   before volume message
;		mov	dx,offset trangroup:VolSerMes_ptr 
;					;AN000; get serial number message
;printvol_end:
;		jmp	std_printf	;AC000; go print and exit

;============================================================================
; TUCODE.ASM, MSDOS 6.0, 1991 (2)
;============================================================================
; 02/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh

; =============== S U B	R O U T	I N E =======================================

PRINT_DATE:
		; MSDOS 3.3
		push	es
		push	di
		push	cs
		pop	es
		mov	di,ARG_BUF
		mov	ah,GET_DATE ; 2Ah
		int	21h	; DOS -	GET CURRENT DATE
				; Return: DL = day,DH = month,	CX = year
				; AL = day of the week (0=Sunday,1=Monday,etc.)
		cbw
		call	GETDATE
		call	P_DATE
		xor	al,al
		stosb
		mov	dx,ARG_BUF_PTR
		call	STD_PRINTF
		pop	es
		pop	di
		retn

		; MSDOS 6.0
		;PUSH	ES
		;PUSH	DI
		;PUSH	CS
		;POP	ES
		;CALL	GetDate 		; get date
		;xchg	dh,dl			;AN000; switch month & day
		;mov	promptDat_yr,cx 	;AC000; put year into message control block
		;mov	promptDat_moday,dx	;AC000; put month and day into message control block
		;mov	dx,offset trangroup:promptDat_ptr ;AC000; set up message for output
		;invoke	std_printf
	;;AD061; mov	promptDat_yr,0		;AC000; reset year, month and day
	;;AD061; mov	promptDat_moday,0	;AC000;     pointers in control block
		;POP	DI			;AC000; restore di,es
		;POP	ES			;AC000;
		;return

; ---------------------------------------------------------------------------

GETDATE:
		; MSDOS 3.3
		mov	si,ax
		shl	si,1
		add	si,ax
		add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
		mov	bx,cx
		mov	cx,3
		rep movsb
		mov	al,' '
		stosb
		retn

		; MSDOS 6.0

; Do GET DATE system call and set up 3 character day of week in ARG_BUF
; for output.  Date will be returned in CX,DX.

;GetDate:
		;mov	di,offset trangroup:arg_buf ;AC000; target for day of week
		;MOV	AH,GET_DATE		;AC000; get current date
		;INT	21h			;AC000; Get date in CX:DX
		;CBW				;AC000;
		;
		;push	cx			;AN000; save date returned in
		;push	dx			;AN000;      CX:DX
		;MOV	SI,AX
		;
		;SHL	SI,1
		;ADD	SI,AX			; SI=AX*3
		;
		;mov	cx,si			;AN000; save si
		;mov	ax,weektab		;AN000; get message number of weektab
		;mov	dh,util_msg_class	;AN000; this is a utility message
		;push	di			;AN000; save argument buffer
		;invoke	Tsysgetmsg		;AN000; get the address of the message
		;pop	di			;AN000; retrieve argument buffer
		;add	si,cx			;AC000; get day of week
		;
		;MOV	CX,3
  		;REP	MOVSB
		;mov	al,end_of_line_out	;AC000; terminate the string
		;stosb
		;pop	dx			;AN000; get back date
		;pop	cx			;AN000;
		;
		;return

; =============== S U B	R O U T	I N E =======================================

		; MSDOS 6.0

; This routine determines whether the character in AL is a
; Yes or No character. On return, if AL=0, the character is
; No, if AL=1, the character is Yes.

;		assume	ds:trangroup

;char_in_xlat	proc	near
;
;		mov	dl,al			;AC000; get character into DX
;		xor	dh,dh			;AC000;
;		mov	ax,(getextcntry SHL 8) + 35 ;AC000; Yes/No char call
;		int	21h			;AC000;
;
;		ret
;
;char_in_xlat	endp

;============================================================================
; TENV.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/10/2018 - Retro DOS v3.0

;	Environment utilities and misc. routines

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************
;
;assume	ds:trangroup				;AN000;
;
;upconv	proc	near				;AN000;
;
;	cmp	al,80h				;AN000;  see if char is > ascii 128
;	jb	oth_fucase			;AN000;  no - upper case math
;	sub	al,80h				;AN000;  only upper 128 chars in table
;	push	ds				;AN000;
;	push	bx				;AN000;
;	mov	ds,[resseg]			;AN000;  get resident data segment
;assume	ds:resgroup				;AN000;
;	lds	bx,dword ptr fucase_addr+1	;AN000;  get table address
;	add	bx,2				;AN000;  skip over first word
;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
;	pop	bx				;AN000;
;	pop	ds				;AN000;
;assume	ds:trangroup				;AN000;
;	jmp	short upconv_end		;AN000;  we finished - exit
;
;oth_fucase:					;AN000;
;	cmp	al,small_a			;AC000; if between "a" and "z",
;	jb	upconv_end			;AC000;     subtract 20h to get
;	cmp	al,small_z			;AC000;    upper case equivalent.
;	ja	upconv_end			;AC000;
;	sub	al,20h				;AC000; Change lower-case to upper
;
;upconv_end:					;AN000;
;	ret
;
;upconv	endp					;AN000;


; =============== S U B	R O U T	I N E =======================================

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h

UPCONV:
		cmp	al,80h
		jb	short OTH_UCASE
		sub	al,80h
		push	ds
		push	bx
		mov	ds,[RESSEG]
		lds	bx,[UPPERCASETBL]
		add	bx,2
		xlat
		pop	bx
		pop	ds
		jmp	short UPCONV_RETN

OTH_UCASE:
		cmp	al,'a'
		jb	short UPCONV_RETN
		cmp	al,'z'
		ja	short UPCONV_RETN
		sub	al,20h

UPCONV_RETN:
		retn

;============================================================================
; COPY.ASM, MSDOS 6.0, 1991
;============================================================================
; 01/10/2018 - Retro DOS v3.0

;	title	COMMAND COPY routines.

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;***	COPY.ASM

;Source files:  copy.asm, copypr1.asm, copypr2.asm


;***	MODIFICATION HISTORY

;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
;11/02/83 EE  Commented out the code in CPARSE which added drive designators
;	     to tokens which begin with path characters so that PARSELINE
;	     will work correctly.
;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
;	     individual tokens.  That distinction is no longer needed for
;	     FOR loop processing.
;11/17/83 EE  CPARSE upper case conversion is now flag dependent.  Flag is
;	     1 when Cparse is called from COPY.
;11/17/83 EE  Took out the comment chars around code described in 11/04/83
;	     mod.  It now is conditional on flag like previous mod.
;11/21/83 NP  Added printf
;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
;	     be added to a token.
;05/30/84 MZ  Initialize all copy variables.  Fix confusion with destclosed
;	     NOTE: DestHand is the destination handle.  There are two
;	     special values:  -1 meaning destination was never opened and
;	     0 which means that the destination has been openned and
;	     closed.
;06/01/84 MZ  Above reasoning totally specious.  Returned things to normal
;06/06/86 EG  Change to fix problem of source switches /a and /b getting
;	     lost on large and multiple file (wildcard) copies.
;06/09/86 EG  Change to use xnametrans call to verify that source and
;	     destination are not equal.
;
;06/24/90 DO  If the destination of a file concatenation is the same as
;	     first source file AND we run out of disk space before
;	     completing the concatenation, restore the first source
;	     file as best we can.  See SeekEnd and CopErr.  Bug #859.
;
;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
;		instead of compatibility mode. This gives lesser sharing
;		violations when files are opened for read on a copy.

; ---------------------------------------------------------------------------
;***	COPY CODE
; ---------------------------------------------------------------------------

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h

COPY:
	; 	Initialize internal variables.

		xor	ax,ax		; AX = 0
		mov	[COPY_NUM],ax	; # files copied (destinations) = 0
		mov	[SRCPT],ax	; cmd line ptr for source scan = 0
		mov	[SRCTAIL],ax	; ptr to last element of source pathname = 0
		mov	[CFLAG],al	; 'destination file created' = false
		mov	[NXTADD],ax	; ptr into TPA buffer = 0
		mov	[DESTSWITCH],ax	; destination switches = none
		mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
		mov	[DESTTAIL],ax	; ptr to last element of dest pathname = 0
		mov	[DESTCLOSED],al	; 'destination file closed' = false
		mov	[DESTSIZ],al	; length of destination pathname = 0
		mov	[SRCSIZ],al	; length of source pathname = 0
		mov	[DESTINFO],al	; destination pathname flags = none
		mov	[SRCINFO],al	; source pathname flags = none
		mov	[INEXACT],al	; 'inexact copy' = false
		mov	[DESTVARS],al	; 'dest pathname is directory' = false  ;*!*
		mov	[SRCVARS],al	; 'source pathname is directory' = false
		mov	[USERDIR1],al	; saved working directory = null
		mov	[NOWRITE],al	; 'no write' (source = dest) = false
		mov	[RDEOF],al	; 'read end of file' = false
		mov	[SRCHAND],ax	; source handle = 0
		mov	[CPDATE],ax	; copy date = 0
		mov	[CPTIME],ax	; copy time = 0
		mov	[SRCISDEV],al	; 'source is device' = false
		;mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
		;mov	[OFilePtr_Lo],ax
		;mov	[OFilePtr_Hi],ax ; original destination file ptr = null
		mov	[TERMREAD],al	; 'terminate read' = false
		mov	[COMMA],al	; '"+,," found' = false
		mov	[PLUS_COMMA],al ; '"+,," found last time' = false (?)
		mov	[ALLSWITCH],ax	; all switches = none
		mov	[ARGC],al	; source/dest argument count = 0
		mov	[PLUS],al	; '"+" in command line' = false
		mov	[BINARY],al	; 'binary copy' = false
		mov	[ASCII],al	; 'ascii copy' = false
		mov	[FILECNT],ax	; # files copied (destinations) = 0
		mov	[WRITTEN],ax	; 'destination written to' = false
		mov	[CONCAT],al	; 'concatenating' = false
		mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
		mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,

	;	Initialize buffers with double-nulls.

		mov	[SCANBUF],ax
		mov	[DESTBUF],ax
		mov	[SRCBUF],ax
		mov	[SDIRBUF],ax
		mov	[DIRBUF],ax
		mov	[DESTFCB],ax

		mov	[OBJCNT],al	; # CParse cmd-line objects found = 0
		
		dec	ax		; AX = 0FFFFh
		mov	[DESTHAND],ax	; destination handle = 'never opened'
		mov	[FRSTSRCH],al	; 'first search for source' = true
		mov	[FIRSTDEST],al	; 'first time for dest' = true
		mov	[DESTISDIR],al	; 'haven't analyzed destination' ; *!*
		
		mov	si,81h		; SI = ptr to command line
		mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
		inc	byte [EXPAND_STAR] ; CParse 'expand * to ?s' = true
		mov	byte [CPYFLAG],1 ; CParse 'called from COPY' = true

	;*	Scan the command line for destination information.

DESTSCAN:
		xor	bp,bp			; BP = switch flag accumulator
		mov	di,SCANBUF		; ES:DI = ptr to pathname buf
		;mov	[Parse_Last],si		;AN018; save cmd line ptr
		call	CPARSE			; parse next object
		pushf				; save CParse flags
		inc	byte [OBJCNT]		; count object
		test	bh,80h
		jz	short NOCOPY		; no "+" delimiter
		mov	byte [PLUS],1		; "+" delimiter occurred
NOCOPY:
		test	bh,1
		jz	short TESTP2		; not a switch

	;	Found a switch.

		; MSDOS 6.0
		;test	bp,SwitchV		;AN038; Verify requested?
		;jz	Not_SlashV		;AN038; No - set the switch
		;test	AllSwitch,SwitchV	;AN038; Verify already entered?
		;jz	Not_SlashV		;AN038; No - set the switch
;AD018; 	;or	AllSwitch,FBadSwitch	;AN038; Set up bad switch
		;or	bp,FBadSwitch		;AN018; Set up bad switch

NOT_SLASHV:
		or	[DESTSWITCH],bp		; assume destination
		or	[ALLSWITCH],bp		; keep tabs on all switches

		; MSDOS 6.0
		;test	bp,not SwitchCopy	;AN018; Bad switch?
		;jz	Not_Bad_Switch		;AN018; Switches are okay
		;popf				;AN018; fix up stack
		;mov	ax,BadSwt_ptr		;AN018; get "Invalid switch" message number
		;invoke	Setup_Parse_Error_Msg	;AN018; setup to print the message
		;jmp	CError			;AC018; exit

NOT_BAD_SWITCH:
		popf				; restore CParse flags
		jc	short CHECKDONE		; found CR
		jmp	short DESTSCAN		; continue scanning for destination

TESTP2:
		popf				; restore CParse flags
		jc	short CHECKDONE		; found CR
		test	bh,80h
		jnz	short GOTPLUS		; found a "+pathname" argument
		inc	byte [ARGC]		; count independent pathname args
GOTPLUS:
		push	si			; save cmd line ptr
		mov	ax,[STARTEL]		; AX = ptr to last path element
		mov	si,SCANBUF		; SI = ptr to path string
		sub	ax,si			; AX = offset of last element
		mov	di,DESTBUF		; DI = ptr to destination buf
		add	ax,di			; AX = ptr to last element in
						;  destination path buffer
		mov	[DESTTAIL],ax		; save ptr to last element
		mov	[DESTSIZ],cl		; save path string length
		inc	cx			; CX = mov length (incl null)
		rep movsb			; DestBuf = possible destination path
		mov	[DESTINFO],bh		; save CParse info flags
		mov	word [DESTSWITCH],0	; clear destination switches
		pop	si			; SI = ptr into cmd line again
		jmp	short DESTSCAN		;AC018; continue scanning for dest

CHECKDONE:

	;	We reached the CR. The destination scan is finished.

	;	Disallow "copy file1+" as file overwriting itself.
	;
	;	(Note that "copy file1+file2+" will be accepted, and
	;	equivalent to "copy file1+file2".)

	;	Bugbug: it looks like "copy /x file1+" would slip
	;	through this check, since the switch would count
	;	as another object in ObjCnt.

		cmp	byte [PLUS],1		; "+" with
		jnz	short CDCONT
		cmp	byte [ARGC],1		; one arg,
		jnz	short CDCONT
		cmp	byte [OBJCNT],2		; two objects..
		jnz	short CDCONT
		mov	dx,OVERWRPTR
		jmp	COPYERR			; is file overwrite

CDCONT:
		mov	al,[PLUS]		; AL = '"+" occurred'
		mov	[CONCAT],al		; if "+" occurred, we're concatenating
		shl	al,1
		shl	al,1
		mov	[INEXACT],al		; therefore making an inexact copy
		mov	dx,BADARGSPTR
		mov	al,[ARGC]		; AL = # independent arguments
		or	al,al
		jz	short CERROR4J

		; MSDOS 6.0
		;or	al,al
		;jnz	Try_Too_Many		; more than 0 args; check if too many
		
		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
		;mov	Extend_Buf_Ptr,LessArgs_Ptr	; set msg # "param missing"
		;jmp	short CError_ParseJ		; take parse error exit		

	; more than 0 args; check if too many

TRY_TOO_MANY:
		cmp	al,2
		jbe	short ACOUNTOK		; <= 2 arguments - ok

		; MSDOS 6.0
		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr ; DX = ptr to msg block
		;mov	Extend_Buf_Ptr,MoreArgs_Ptr	; set msg # "too many params"
;CError_ParseJ:
		;mov	Msg_Disp_Class,PARSE_MSG_CLASS	; parse error message	

CERROR4J:
		jmp	CERROR

ACOUNTOK:
		mov	bp,DESTVARS		; BP = base of dest variables

		cmp	al,1
		jnz	short GOT2ARGS

	;	Only one independent pathname argument on command line.
	;	Set destination to d:*.*, where d: is current drive.

	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
	;	The two files would be appended as d:file1, rather than x:file1.

		mov	al,[CURDRV]		; AL = current drive (0 = A)
		add	al,[CAPITAL_A]		; AL = current drive letter
		mov	ah,':'			; AX = "d:"
		;mov	byte [bp+1],2
		mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2

		mov	di,DESTBUF		; ES:DI = ptr to dest path buf
		stosw				; store "d:"
		
		mov	word [DESTSWITCH],0	; clear destination switches
		;mov	byte [bp+4],2		
		mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
		;mov	byte [bp+0],0		
		mov	byte [bp],0
		call	SETSTARS		; add wildcards
GOT2ARGS:

	;	If destination pathname is "d:", add full wildcard filename

		;cmp	byte [bp+1],2
		cmp	byte [bp+VARSTRUC.SIZ],2
		jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
		mov	al,':'
		cmp	byte [DESTBUF+1],al
		jnz	short NOTSHORTDEST	; it's just a 2-character filename
		;or	byte [bp+4],2
		or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
		mov	di,DESTBUF+2		; ES:DI = ptr after "d:"
		;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
		;mov	byte [bp+0],0		
		mov	byte [bp],0
		call	SETSTARS		; add wildcards

NOTSHORTDEST:

	;	If destination pathname ends with "\", try to make
	;	sure it's "d:\".

		;mov	di,[bp+2]
		mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
		cmp	byte [di],0
		jnz	short CHKSWTCHES	; not a null, so last char not "\"

		mov	dx,BADCDPTR
		mov	al,':'
		cmp	[di-2],al
		jne	short CERROR4J		; it's not "d:\", exit with error msg
		;mov	byte [bp+0],2
		;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
		mov	byte [bp],2
		;or	byte [bp+4],6
		or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
						  ;  path character
		call	SETSTARS		; add wildcards

CHKSWTCHES:

	;	We have enough information about the destination for now.

	;	Turn on verify if requested. Save the current verify flag.

		mov	dx,BADPARMPTR
		mov	ax,[ALLSWITCH]		; AX = all switch flags

		; MSDOS 3.3
		;test	ax,~SWITCHCOPY ; 7FE3h
		test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
		jnz	short CERROR4J
		; MSDOS 3.3 (& MSDOS 6.0)
		test	ax,SWITCHV ; 10h
		jz	short NOVERIF		; no /v, no verify

		mov	ah,GET_VERIFY_ON_WRITE ; 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		push	ds
		mov	ds,[RESSEG]
		xor	ah,ah
		mov	word [VERVAL],ax	; save current verify flag
		pop	ds
		mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
NOVERIF:
		;*	Scan for first source.

		xor	bp,bp			; BP = switch flags accumulator
		mov	si,81h			; SI = ptr into command line
		mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
SCANFSRC:
		mov	di,SCANBUF		; DI = ptr to pathname buf
		call	CPARSE			; parse first source pathname
		test	bh,1			; switch?
		jnz	short SCANFSRC		; yes, try again
		or	[DESTSWITCH],bp		; include copy-wide switches on dest

;	Set ascii copying mode if concatenating, unless /b is specified.

		;test	bp,8
		test	bp,SWITCHB
		jnz	short NOSETCASC		; /b - explicit binary copy
		cmp	byte [CONCAT],0
		je	short NOSETCASC		; we're not concatenating
		;mov	byte [ASCII],4
		mov	byte [ASCII],SWITCHA	; set ascii copy
NOSETCASC:
		call	SOURCE_SET		; set source variables
		call	FRSTSRC			; set up first source copy
		jmp	FIRSTENT		; jump into the copy loop

; ---------------------------------------------------------------------------

ENDCOPY:

	;*	End of the road. Close destination, display # files
	;	copied (meaning # destinations), and go back to main
	;	transient COMMAND code.

		call	CLOSEDEST
ENDCOPY2:
		mov	dx,COPIEDPTR
		mov	si,[FILECNT]
		mov	[COPY_NUM],si
		call	STD_PRINTF
		jmp	TCOMMAND		; stack could be messed up

; ---------------------------------------------------------------------------

SRCNONEXIST:

	;*	Source doesn't exist.  If concatenating, ignore and continue.
	;	Otherwise, say 'file not found' and quit.

		cmp	byte [CONCAT],0
		jne	short NEXTSRC	; concatenating - go on to next source

		; MSDOS 3.3
		mov	dx,SRCBUF
		mov	[STRING_PTR_1],dx
		mov	dx,STRINGBUF1PTR
		call	STD_PRINTF
		mov	dx,FNOTFOUNDPTR
		jmp	COPYERR

		; MSDOS 6.0
	;	Set up error message.
		;mov	Msg_Disp_Class,EXT_MSG_CLASS	     ; extended error msg
		;mov	dx,offset TRANGROUP:Extend_Buf_Ptr   ; DX = ptr to msg block
		;mov	Extend_Buf_Ptr,ERROR_FILE_NOT_FOUND  ; 'file not found' msg#
		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ; point at bad pathname
		;mov	Extend_Buf_Sub,ONE_SUBST	     ; 1 substitution
		;
		;jmp	CopErr			; print msg and clean up

; ---------------------------------------------------------------------------

SOURCEPROC:

	;*	Preparatory processing for each source file.
	;	Called at FrstSrc for first source file.

		call	SOURCE_SET		; set source variables & ascii/binary
		cmp	byte [CONCAT],0
		jne	short LEAVECFLAG	; concatenating - leave CFlag alone

; ---------------------------------------------------------------------------

FRSTSRC:
		xor	ax,ax
		mov	[CFLAG],al		; 'destination not created'
		mov	[NXTADD],ax		; copy buffer ptr = 0
		mov	[DESTCLOSED],al		; 'destination not closed'

LEAVECFLAG:
		mov	[SRCPT],si		; save cmd-line ptr
		mov	di,USERDIR1		; DI = ptr to buf for user's 
						;   current dir
		mov	bp,SRCVARS		; BP = base of source variables
		call	BUILDPATH		; cd to source dir, figure
						;   out stuff about source
		mov	si,[SRCTAIL]		; SI = ptr to source filename
		retn

; ---------------------------------------------------------------------------

NEXTSRC:

	;*	Next source. Come here after handling each pathname.
	;	We're done unless there are additional source pathnames
	;	to be appended.
	;
	;	Note that all files matching an ambiguous pathname
	;	are processed before coming here.

		cmp	byte [PLUS],0
		jne	short MORECP		; copying "+" sources - keep going

ENDCOPYJ2:
		jmp	short ENDCOPY

MORECP:
		xor	bp,bp			; BP = switch flags accumulator
		mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
		mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"

SCANSRC:
		mov	di,SCANBUF		; DI = ptr to pathname buf
		call	CPARSE			; parse first source name
		jb	short ENDCOPYJ2		; CR found - we're done

		test	bh,80h
		jz	short ENDCOPYJ2		; no "+" delimiter - we're done

		test	bh,1
		jnz	short SCANSRC		; switch found - keep looking

	;	ScanBuf contains the next source pathname.

		call	SOURCEPROC		; prepare this source
		cmp	byte [COMMA],1		; was +,, found last time?
		jnz	short NOSTAMP		;  no - try for a file
		mov	byte [PLUS_COMMA],1	; yes - set flag
		jmp	short SRCNONEXIST	; we know we won't find it

NOSTAMP:
		mov	byte [PLUS_COMMA],0	; reset +,, flag

; ---------------------------------------------------------------------------

FIRSTENT:

;M047
; The only case we need to worry about is when the source is wildcarded and
;the destination is not. For this case, ConCat is not yet set to indicate
;concatenation. We check for this case.
;
;NB: This change has been backed out and replaced by M048. This is not the
;right place to do this check.

	;	This is where we enter the loop with the first source.

		mov	di,FCB ; 5Ch		; DI = ptr to FCB
		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	byte [si],0		; did we parse the whole thing?
		jne	short SRCHDONE		; no, error, simulate 'not found'
		mov	ax,[SRCBUF]		; AX = possible "d:"
		cmp	ah,':'
		je	short DRVSPEC1		; AX = definite "d:"
		mov	al,'@'			; AL = drive 'letter' for current drive
DRVSPEC1:
		or	al,20h			; AL = lowercase drive letter
		sub	al,60h			; AL = drive id (0=current,1=A,..)
		;mov	[5Ch],al
		mov	[FCB],al		; put drive id in FCB

	;	FCB contains drive and filename to search.
		
		mov	ah,DIR_SEARCH_FIRST ; 11h  ; AH = 'Find First File'	
		call	SEARCH
SRCHDONE:
		pushf				; save flags from Search
		call	RESTUDIR1		; restore users current directory
		popf				; restore flags from search
		jz	short NEXTAMBIG0	; found the source - continue
		jmp	SRCNONEXIST		; didn't find the source

NEXTAMBIG0:
		xor	al,al
		xchg	al,[FRSTSRCH]
		or	al,al
		jz	short NEXTAMBIG
SETNMEL:
		mov	cx,12
		mov	di,SDIRBUF
		mov	si,DIRBUF
		rep movsb			; save very first source name
NEXTAMBIG:
		xor	al,al
		mov	[NOWRITE],al		; turn off nowrite
		mov	di,[SRCTAIL]
		mov	si,DIRBUF+1
		call	FCB_TO_ASCZ		; SrcBuf has complete name
MELDO:
		cmp	byte [CONCAT],0
		jnz	short SHOWCPNAM		; concatenating - show name
		test	byte [SRCINFO],2	; wildcard - show name
		jz	short DOREAD
SHOWCPNAM:
		mov	dx,SRCBUF
		mov	[STRING_PTR_2],dx
		mov	dx,STRINGBUF2PTR
		call	STD_PRINTF
		call	CRLF2
DOREAD:
		call	DOCOPY
		cmp	byte [CONCAT],0
		jnz	short NODCLOSE		; concatenating - don't close dest

		call	CLOSEDEST		; close current destination
		jc	short NODCLOSE		; concatenating - dest not closed

		mov	byte [CFLAG],0		; 'destination not created'
NODCLOSE:
		cmp	byte [CONCAT],0		
		jz	short NOFLUSH

;	Concatenating - flush output between source files so LostErr
;	stuff works correctly.

		;invoke	FlshFil  ; MSDOS 6.0

		call	FLUSHFIL ; MSDOS 3.3
		test	byte [MELCOPY],0FFh
		jz	short NOFLUSH
		jmp	short DOMELCOPY
NOFLUSH:
		call	SEARCHNEXT		; try next match
		jnz	short NEXTSRCJ		; not found - finished with 
						;   this source spec
		mov	byte [DESTCLOSED],0	; 'destination not closed'

		jmp	short NEXTAMBIG		; do next ambig match

DOMELCOPY:
		cmp	byte [MELCOPY],0FFh
		je	short CONTMEL
		mov	si,[SRCPT]
		mov	[MELSTART],si
		mov	byte [MELCOPY],0FFh

CONTMEL:
		xor	bp,bp
		mov	si,[SRCPT]
		mov	bl,[PLUS_CHR]
SCANSRC2:
		mov	di,SCANBUF
		call	CPARSE
		test	bh,80h
		jz	short NEXTMEL		; no "+" - go back to start
		test	bh,1
		jnz	short SCANSRC2		; switch - keep scanning
		call	SOURCEPROC
		call	RESTUDIR1
		mov	di,DESTFCB2
		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx,SDIRBUF+1
		mov	si,DESTFCB2+1
		mov	di,[SRCTAIL]

		call	BUILDNAME

		cmp	byte [CONCAT],0
		je	short MELDOJ		; not concatenating - continue

	;	Yes, turn off nowrite because this part of the code 
	;	is only reached after the first file has been dealt with.

		mov	byte [NOWRITE],0
MELDOJ:
		jmp	MELDO

NEXTSRCJ:
		jmp	NEXTSRC

NEXTMEL:
		call	CLOSEDEST
		xor	ax,ax
		mov	[CFLAG],al
		mov	[NXTADD],ax
		mov	[SPECDRV],al
		mov	si,[MELSTART]
		mov	[SRCPT],si
		call	SEARCHNEXT
		jz	short SETNMELJ
		jmp	ENDCOPY2

SETNMELJ:
		jmp	SETNMEL

; ---------------------------------------------------------------------------

SEARCHNEXT:
		mov	ah,DIR_SEARCH_NEXT ; 12h
		test	byte [SRCINFO],2
		jnz	short SEARCH		; do search-next if ambig
		or	ah,ah			; reset zero flag
		retn

; ---------------------------------------------------------------------------

SEARCH:
		push	ax
		mov	ah,SET_DMA ; 1Ah
		mov	dx,DIRBUF	; put result of search in dirbuf
		int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
		pop	ax		; restore search first/next command
		mov	dx,FCB ; 5Ch
		int	21h		; Do the search
		or	al,al
		retn

; ---------------------------------------------------------------------------

DOCOPY:
		mov	si,SRCBUF	; do name translate of source
		mov	di,SRCXNAME	; save for name comparison
		mov	ah,XNAMETRANS ; 60h
		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
				; DS:SI	-> ASCIZ relative path string or directory name
				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	byte [RDEOF],0	; no EOF yet

		; MSDOS 6.0
		;mov	ax,EXTOPEN shl 8		; open the file
;M046
; For reads, the sharing mode should be deny none so that any process can
;open this file again in any other sharing mode. This is mainly to allow
;multiple command.com's to access the same file without getting sharing
;violations
;
		;mov	bx,DENY_NONE or READ_OPEN_MODE ; open mode for COPY ;M046
		;xor	cx,cx				; no special files
		;mov	dx,READ_OPEN_FLAG		; set up open flags
		;int	21h
		;
		;jnc	OpenOk

	;	Bogosity:  IBM wants us to issue Access Denied in this case.
	;	They asked for it...

		;jmp	short Error_On_Source 		;AC022; clean up and exit

		; MSDOS 3.3
		mov	dx,SRCBUF
		mov	ax,OPEN*256 ; 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jnc	short OPENOK
		call	GET_EXT_ERR_NUMBER
		pushf
		cmp	ax,65
		jnz	short DOCOPY_ERR
		mov	dx,ACCDENPTR
		call	STD_PRINTF
DOCOPY_ERR:
		popf
		retn

		; MSDOS 3.3 (& MSDOS 6.0)
OPENOK:
		mov	bx,ax
		mov	[SRCHAND],bx		; save handle
		mov	ax,FILE_TIMES*256 ; 5700h
		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
					; BX = file handle

		;jc	Error_On_Source  ; MSDOS 6.0

		mov	[CPDATE],dx		; save date
		mov	[CPTIME],cx		; save time

		; MSDOS 6.0
		;jmp	short No_Copy_Xa  ; (xa copy code removed)

;Error_On_Source:				;AN022; we have a BAD error
		;invoke	Set_Ext_Error_Msg	;AN022; set up the error message
		;mov	String_Ptr_2,offset TRANGROUP:SrcBuf ;AN022; get address of failed string
		;mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
		;invoke	Std_EprintF		;AN022; print it
		;cmp	SrcHand,0		;AN022; did we open the file?
		;je	No_Close_Src		;AN022; no - don't close
		;call	CloseSrc		;AN022; clean up
;No_Close_Src:					;AN022;
		;cmp	CFlag,0			;AN022; was destination created?
		;je	EndCopyJ3		;AN022; no - just cleanup and exit
		;jmp	EndCopy			;AN022; clean up concatenation and exit
;EndCopyJ3:					;AN022;
		;jmp	EndCopy2		;AN022;
;No_Copy_Xa:
		;mov	bx,SrcHand		;AN022; get handle back

		; MSDOS 3.3 (& MSDOS 6.0)
		mov	ax,(IOCTL<<8) ; 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		and	dl,devid_ISDEV ; 80h
		mov	[SRCISDEV],dl		; set source info
		jz	short COPYLP		; source not a device
		cmp	byte [BINARY],0
		je	short COPYLP		; ascii device ok
		mov	dx,INBDEVPTR		; cannot do binary input
		jmp	COPYERR

COPYLP:
		mov	bx,[SRCHAND]
		mov	cx,[BYTCNT]
		mov	dx,[NXTADD]
		sub	cx,dx			; compute available space
		jnz	short GOTROOM
		;invoke	FlshFil   ; MSDOS 6.0
		call	FLUSHFIL  ; MSDOS 3.3
		cmp	byte [TERMREAD],0
		jne	short CLOSESRC		; give up
		mov	cx,[BYTCNT]
GOTROOM:
		push	ds
		mov	ds,[TPA]
		mov	ah,READ ; 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle,CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		jc	short CLOSESRC	; MSDOS 3.3
		;jc	Error_On_Source ; MSDOS 6.0
		mov	cx,ax			; get count
		jcxz	CLOSESRC		; no more to read
		cmp	byte [SRCISDEV],0
		jne	short NOTESTA		; is a device, ascii mode
		cmp	byte [ASCII],0
		je	short BINREAD
NOTESTA:
		mov	dx,cx
		mov	di,[NXTADD]
		mov	al,1Ah
		push	es
		mov	es,[TPA]		; scan for EOF
		repne scasb
		pop	es
		jnz	short USEALL
		inc	byte [RDEOF]
		inc	cx
USEALL:
		sub	dx,cx
		mov	cx,dx
BINREAD:
		add	cx,[NXTADD]
		mov	[NXTADD],cx
		cmp	cx,[BYTCNT]		; is buffer full?
		jb	short TESTDEV		; if not, we may have found eof
		;invoke	FlshFil
		call	FLUSHFIL
		cmp	byte [TERMREAD],0
		jne	short CLOSESRC		; give up
		jmp	short COPYLP
TESTDEV:
		cmp	byte [SRCISDEV],0	; if file then EOF
		je	short CLOSESRC
		cmp	byte [RDEOF],0
		je	short COPYLP		; on device, go till ^Z
CLOSESRC:
		mov	bx,[SRCHAND]
		mov	ah,CLOSE ; 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
CLOSESRCDEST_RETN:
		retn

; ---------------------------------------------------------------------------

CLOSEDEST:

	;	We are called to close the destination.
	;	We need to note whether or not there is any internal data left
	;	to be flushed out.

		cmp	byte [DESTCLOSED],0
		jne	short CLOSESRCDEST_RETN	; don't double close
		mov	al,byte [DESTSWITCH]
		call	SETASC			; check for b or a switch
		jz	short BINCLOS		;   on destination
		mov	bx,[NXTADD]
;
;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
;^Z, let's always flush out. This way if the ConCat flag changes, we will
;just return without appending a ^Z incorrectly for the first file (since we
;are concatenating now). Also, in case it is a single file copy, we will
;anyway write the ^Z out separately. The only drawback is that there is a
;performance overhead on single ASCII file copies which now always involve
;2 writes instead of 1 before. Is this really that important?
;
;M048;	cmp	bx,BytCnt		; is memory full?
;M048;	jne	PutZ

		; MSDOS 3.3
		cmp	bx,[BYTCNT]	; is memory full?
		jne	short PUTZ

		call	TRYFLUSH	; flush (and double-check for concat)	
		jz	short NOCONC
CONCHNG:
		stc
		retn

NOCONC:	
		xor	bx,bx
PUTZ:
		push	ds
		mov	ds,[TPA]
		mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
		pop	ds
		inc	word [NXTADD]	; make sure our ^z gets written	
		mov	byte [NOWRITE],0
		mov	ax,[WRITTEN]
		add	ax,[NXTADD]
		jc	short BINCLOS	; > 1
		cmp	ax,1
		je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
BINCLOS:
		call	TRYFLUSH
		jnz	short CONCHNG

		cmp	byte [WRITTEN],0
FORGETITJ:
		jz	short FORGETIT	; never wrote nothing
NO_FORGET:				; wrote something
		mov	bx,[DESTHAND]
		mov	cx,[CPTIME]
		mov	dx,[CPDATE]
		cmp	byte [INEXACT],0 ; copy not exact?
		je	short DODCLOSE	; if no, copy date & time
		mov	ah,GET_TIME ; 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours,CL = minutes,DH = seconds
					; DL = hundredths of seconds
		shl	cl,1
		shl	cl,1		; left justify min in cl
		shl	cx,1
		shl	cx,1
		shl	cx,1		; hours to high 5 bits, min to 5-10
		shr	dh,1		; divide seconds by 2 (now 5 bits)
		or	cl,dh		; and stick into low 5 bits of cx
		push	cx		; save packed time
		mov	ah,GET_DATE ; 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day,DH = month,	CX = year
					; AL = day of the week (0=Sunday,1=Monday,etc.)
		sub	cx,1980
		xchg	ch,cl
		shl	cx,1		; year to high 7 bits
		shl	dh,1		; month to high 3 bits
		shl	dh,1
		shl	dh,1
		shl	dh,1
		shl	dh,1		; most sig bit of month in carry
		adc	ch,0		; put that bit next to year
		or	dl,dh		; or low three of month into day
		mov	dh,ch		; get year and high bit of month
		pop	cx
DODCLOSE:
		cmp	bx,0
		jle	short CLOSEDONE
		mov	ax,(FILE_TIMES<<8)|1 ; 5701h
		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
					; BX = file handle,CX = time to be set
					; DX = date to be set
		; MSDOS 6.0
		;jc	Cleanup_Err	;AN022; handle error

	;	See if the destination has *anything* in it.
	;	If not, just close and delete it.

		mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
		xor	dx,dx
		mov	cx,dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
	;	DX:AX is file size

		or	dx,ax
		pushf
		mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		push	dx			; save them away
		mov	ah,CLOSE ; 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	dx

		; MSDOS 6.0
		;jnc	Close_Cont	;AN022; handle error on close
		;popf			;AN022; get the flags back
;Cleanup_Err: 				;AN022;
		;call	CleanUpErr	;AN022; attempt to delete the target
		;call	DestDelete	;AN022; attempt to delete the target
		;jmp	short FileClosed ;AN022; close the file
;Close_Cont:				;AN022; no error - co
		; MSDOS 3.3 (& MSDOS 6.0)
		popf
		jnz	short CLOSEDONE
		test	dx,80h		; is the destination a device?
		jnz	short CLOSEDONE	; yes, copy succeeded
		call	DESTDELETE
		jmp	short FILECLOSED
CLOSEDONE:
		inc	word [FILECNT]
FILECLOSED:
		inc	byte [DESTCLOSED]
RET50:
		clc
		retn

FORGETIT:
		mov	bx,[DESTHAND]
		call	DODCLOSE	 ; close the dest	
		call	DESTDELETE
		mov	word [FILECNT],0 ; no files transferred
		jmp	short RET50

; ---------------------------------------------------------------------------

DESTDELETE:
		mov	dx,DESTBUF
		mov	ah,UNLINK ; 41h
		int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
				; DS:DX	-> ASCIZ pathname of file to delete 
				;		(no wildcards allowed)
		retn

; ---------------------------------------------------------------------------

SOURCE_SET:
		push	si
		mov	ax,[STARTEL]
		mov	si,SCANBUF	; adjust to copy
		sub	ax,si
		mov	di,SRCBUF
		add	ax,di
		mov	[SRCTAIL],ax
		mov	[SRCSIZ],cl	; save its size
		inc	cx		; include the nul
		rep movsb		; save this source
		mov	[SRCINFO],bh	; save info about it
		pop	si
		mov	ax,bp		; switches so far
		call	SETASC		; set a,b switches accordingly
		call	SWITCH		; get any more switches on this arg
		call	SETASC		; set
		retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;****************************************************************
;*
;* ROUTINE:	CleanupErr
;*
;* FUNCTION:	Issues extended error message for destination
;*		if not alreay issued
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	none
;*
;****************************************************************

;CleanupErr	proc	near		;AN022;
;
;	cmp	Msg_Flag,0		;AN022; have we already issued a message?
;	jnz	CleanupErr_Cont 	;AN022; yes - don't issue duplicate error
;	invoke	Set_Ext_Error_Msg	;AN022; set up error message
;	mov	String_Ptr_2,offset TRANGROUP:DestBuf 
;					;AN022; get address of failed string
;	mov	Extend_Buf_Sub,ONE_SUBST ;AN022; put number of subst in control block
;	invoke	Std_EPrintF		;AN022; issue the error message
;
;CleanupErr_Cont:			;AN022;
;	ret				;AN022; return to caller
;
;CleanupErr	endp			;AN022;

;============================================================================
; COPYPR1.ASM, MSDOS 6.0, 1991
;============================================================================
; 01/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh

; =============== S U B	R O U T	I N E =======================================

;***	TryFlush - flush copy buffer, double-check for concatenation
;
;	EXIT	ZR set if concatenate flag unchanged

TRYFLUSH:
		mov	al,[CONCAT]
		push	ax
		call	FLUSHFIL
		pop	ax
		cmp	al,[CONCAT]
		retn

; =============== S U B	R O U T	I N E =======================================

FLUSHFIL:
		mov	al,[BINARY]
		mov	ah,[ASCII]
		push	ax
		call	FLSHFIL
		pop	ax
		mov	[ASCII],ah
		mov	[BINARY],al
		retn

; =============== S U B	R O U T	I N E =======================================

;***	Flshfil - write out any data remaining in copy buffer.
;
;	Inputs:
;	  [NXTADD] = No. of bytes to write
;	  [CFLAG] <> 0 if file has been created
;	Outputs:
;	  [NXTADD] = 0

FLSHFIL:
		mov	byte [TERMREAD],0
		cmp	byte [CFLAG],0
		jz	short NOTEXISTS
		jmp	EXISTS

NOTEXISTS:
		call	BUILDDEST	; find out all about the destination
		call	COMPNAME	; source and dest. the same?
		jnz	short PROCDEST	; if not, go ahead
		cmp	byte [SRCISDEV],0
		jnz	short PROCDEST	; same name on device ok
		cmp	byte [CONCAT],0	; concatenation?
		mov	dx,OVERWRPTR
		je	short COPERR	; not concatenating - overwrite error
		
;No_Concat_Err:	; concatenating
		mov	byte [NOWRITE],1 ; flag not writing (just seeking)
PROCDEST:
		; MSDOS 6.0
		;mov	ax,EXTOPEN shl 8		; open the file
		;mov	si,offset TRANGROUP:DestBuf	; get file name
;M046
; For writes, we want to deny writes by anyone else at the same time that we
;are writing to it. For instance, on a network, 2 workstations could try
;writing to the same file. Also, because we opened the source file with
;DENY NONE, it is fine if the source and destination files are the same as
;would happen when we append to an existing file.
;
		;mov	bx,DENY_WRITE or WRITE_OPEN_MODE;get open mode for copy; M046
		;xor	cx,cx				; no special files
		;mov	dx,WRITE_OPEN_FLAG		; set up open flags
		;
		;cmp	NoWrite,0
		;jne	DoDestOpen		; don't actually create if nowrite set
		;mov	dx,CREAT_OPEN_FLAG	; set up create flags

		mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
		cmp	byte [NOWRITE],0
		jne	short DODESTOPEN
		mov	ah,CREAT ; 3Ch
		xor	cx,cx
DODESTOPEN:
		mov	dx,DESTBUF
		int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
				; CX = attributes for file
				; DS:DX	-> ASCIZ filename (may include drive and path)
		
		; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
		;mov	dx,FULDIRPTR
		;call	GET_EXT_ERR_NUMBER
		;jc	short COPERR

		; 01/10/2018
		;jnc	short DEST_OPEN_OKAY
		
		;mov	dx,FULDIRPTR
		;call	GET_EXT_ERR_NUMBER
		;jmp	short COPERR

		jc	short DEST_OPEN_ERROR

;DEST_OPEN_OKAY:
		mov	[DESTHAND],ax	; save handle
		mov	byte [CFLAG],1	; destination now exists
		mov	bx,ax
		mov	ax,IOCTL*256 ; 4400h ; get device stuff
		int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
				   	; BX = file or device handle

		mov	[DESTISDEV],dl	; set dest info
		;test	dl,80h
		test	dl,devid_ISDEV
		jz	short EXISTS	; Dest not a device

;	Destination is device.

		mov	al,byte [DESTSWITCH]
		;and	al,0Ch
		and	al,SWITCHA+SWITCHB
		jnz	short TESTBOTH
		mov	al,[ASCII]	; neither set, use current setting
		or	al,[BINARY]
		jz	short EXSETA	; neither set, default to ascii
TESTBOTH:
		jpe	short EXISTS	; both are set, ignore
		;test	al,8
		test	al,SWITCHB
		jz	short EXISTS
		;mov	ax,(IOCTL shl 8) or 1
		mov	ax,(IOCTL<<8)|1 ; 4401h
		xor	dh,dh
		;or	dl,20h
		or	dl,devid_RAW
		mov	[DESTISDEV],dl
		int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
				; BX = device handle,DH = 0
				; DL = device information to set (bits 0-7 from	function 0)
		jmp	short EXISTS

		; 01/10/2018 - Retro DOS v3.0 modification
DEST_OPEN_ERROR:
		mov	dx,FULDIRPTR
		call	GET_EXT_ERR_NUMBER
COPERR:
		jmp	short COPYERR

EXSETA:

;	What we read in may have been in binary mode, flag zapped write OK

		;mov	byte [ASCII],4
		mov	byte [ASCII],SWITCHA	; set ascii mode
		;or	byte [INEXACT],4
		or	byte [INEXACT],SWITCHA	; ascii -> inexact
EXISTS:
		cmp	byte [NOWRITE],0
		jnz	short NOCHECKING	; if nowrite don't bother with name check
		cmp	byte [PLUS_COMMA],1	; don't check if just doing +,,
		jz	short NOCHECKING
		call	COMPNAME		; source and dest. the same?
		jnz	short NOCHECKING	; if not, go ahead
		cmp	byte [SRCISDEV],0
		jne	short NOCHECKING	; same name on device ok

;	At this point we know in append (would have gotten overwrite error
;	on first destination create otherwise), and user trying to specify
;	destination which has been scribbled already (if dest had been named
;	first, NoWrite would be set).

		mov	dx,LOSTERRPTR		; tell him he's not going to get it
		;invoke	Std_EprintF		;ac022;
		call	STD_PRINTF
		mov	word [NXTADD],0		; set return
		inc	byte [TERMREAD]		; tell read to give up
RET60:
		retn

NOCHECKING:
		mov	bx,[DESTHAND]		; get handle
		xor	cx,cx
		xchg	cx,[NXTADD]
		jcxz	RET60			; if nothing to write, forget it
		inc	word [WRITTEN]		; flag that we wrote something
		cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
		jnz	short SEEKEND
		xor	dx,dx
		push	ds
		mov	ds,[TPA]
		mov	ah,WRITE ; 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
		pop	ds
		mov	dx,NOSPACEPTR
		jc	short COPERRP		; failure
		sub	cx,ax
		jz	short RET60		; wrote all supposed to
		test	byte [DESTISDEV],devid_ISDEV ;80h
		jz	short COPYERR		; is a file, error
		test	byte [DESTISDEV],devid_RAW ; 20h
		jnz	short DEVWRTERR		; is a raw device, error
		cmp	byte [INEXACT],0
		jnz	short RET60		; inexact so ok
		dec	cx
RETZ60:
		jz	short RET60		; wrote one byte less (the ^z)		

DEVWRTERR:
		mov	dx,DEVWMESPTR

COPYERR:
		;invoke	Std_EPrintF		;AC022;
		call	STD_PRINTF
COPERRP:
		inc	byte [DESTCLOSED]
		cmp	byte [CFLAG],0
		jz	short ENDCOPYJ		; never actually got it open
		mov	bx,[DESTHAND]
		cmp	bx,0
		jle	short NOCLOSE

;	Check to see if we should save part of the destination file.

		; MSDOS 6.0
		;mov	cx,OFilePtr_Hi		; CX = hi word of original file ptr
		;mov	dx,OFilePtr_Lo		; DX = lo word of original file ptr
			
		;mov	ax,cx
		;or	ax,dx
		;jz	ceClose			; null file ptr means nothing to save

;	Destination was also the first source.  Do the best we can to
;	restore it.  Truncate it back to the size we took from it (which
;	may have been due to a Ctrl-Z, so may not have included the whole
;	file).  If a Ctrl-Z was originally read, put it back.

		;mov	ax,LSEEK shl 8
		;int	21h

		;xor	cx,cx			; CX = # bytes to write = 0
		;mov	ah,WRITE
		;int	21h			; truncate file

		;cmp	OCtrlZ,0
		;je	@f			; no ctrl-z removed from original
		;inc	cx			; CX = # bytes to write = 1
		;mov	dx,offset TRANGROUP:OCtrlZ  ; DS:DX = ptr to original ctrl-z
		;mov	ah,WRITE
		;int	21h			; write ctrl-z
;@@:
		;mov	ah,CLOSE
		;int	21h			; close it
;;		;mov	CFlag,0
		;jmp	EndCopy			; and go home

		; MSDOS 3.3 (& MSDOS 6.0)
CECLOSE:
		mov	ah,CLOSE ; 3Eh		; close the file
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
NOCLOSE:
		mov	dx,DESTBUF
		mov	ah,UNLINK ; 41h 	; and delete it
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		mov	byte [CFLAG],0
ENDCOPYJ:
		jmp	ENDCOPY

SEEKEND:
		xor	dx,dx
		xchg	dx,cx
		;mov	ax,(LSEEK shl 8) or 1
		mov	ax,(LSEEK<<8)|1 ; 4201h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		cmp	byte [RDEOF],0
		jz	short RETZ60

;	^Z has been read - we must set the file size to the current
;	file pointer location

		mov	ah,WRITE ; 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer

		; MSDOS 6.0
		;jc	Xa_Set_Error_Jmp	;AC022; failure

;	Make note that ^Z was removed, in case the
;	copy should fail and we need to restore the file.

		;mov	OCtrlZ,1Ah

		retn

;============================================================================
; COPYPR2.ASM, MSDOS 6.0, 1991
;============================================================================
; 01/10/2018 - Retro DOS v3.0

; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh

; =============== S U B	R O U T	I N E =======================================

;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
;
;	Given switch vector in AX,
;	  Set Ascii flag if /a is set
;	  Clear Ascii flag if /b is set
;	  Binary set if /b specified
;	  Leave Ascii unchanged if neither or both are set
; 	Also sets Inexact if Ascii is ever set. 
;	AL = Ascii on exit, flags set

SETASC:
		and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
		jpe	short LOADSW	; even parity - both or neither
		push	ax
		and	al,SWITCHB  ; 8
		mov	[BINARY],al
		pop	ax
		and	al,4
		mov	[ASCII],al
		or	[INEXACT],al
LOADSW:
		mov	al,[ASCII]
		or	al,al
		retn

; =============== S U B	R O U T	I N E =======================================

BUILDDEST:
		cmp	byte [DESTISDIR],-1 ; 0FFh
		jnz	short KNOWABOUTDEST	; figuring already done
		mov	di,USERDIR1
		mov	bp,DESTVARS
		call	BUILDPATH
		call	RESTUDIR1

;	We now know all about the destination

KNOWABOUTDEST:
		xor	al,al
		xchg	al,[FIRSTDEST]
		or	al,al
		jnz	short FIRSTDST
		jmp	NOFIRSTDEST
FIRSTDST:

;	Create an fcb of the original dest.

		mov	si,[DESTTAIL]
		mov	di,DESTFCB
		mov	ax,PARSE_FILE_DESCRIPTOR*256 ; 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	byte [si],0
		jz	short GOODPARSE
		mov	byte [di+1],'|'
		; MSDOS 6.0
	;;AD052; mov	byte ptr [di+1],"|"	; must be illegal file name character
		;mov	dx,offset TRANGROUP:FulDir_Ptr	;AN052; issue "file creation error"
		;jmp	CopErr				;AN052;
GOODPARSE:
		mov	ax,[DESTBUF]		; AX = possible "d:"
		cmp	ah,':'
		jz	short DRVSPEC4
		mov	al,'@'
DRVSPEC4:

;	AX = "d:" for following FCB drive computation

		mov	cl,[ASCII]		; CL = saved Ascii flag
		or	al,20h
		sub	al,60h
		mov	byte [DESTFCB],al	; store drive # in FCB

;*	Figure out what copy mode we're in.
;	Letters stand for unambiguous, * for ambiguous pathnames.
;	+n stands for additional sources delimited by +'s.
;
;	copy a b	not concatenating
;	copy a *	not concatenating
;	copy * a	concatenating
;	copy * *	not concatenating
;	copy a+n b	concatenating
;	copy *+n a	concatenating
;	copy *+n *	concatenating, Mel Hallerman style

;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
;		 copy a.b+*.a *.t  picks up all *.a files.

		mov	al,[DESTINFO]	; AL = destination CParse flags
		mov	ah,[SRCINFO]	; AH = source CParse flags
		and	ax,202h		; AH,AL = source,dest wildcard flags
		or	al,al
		jz	short NOTMELCOPY ; no destination wildcard

;	Destination is wildcarded.
	
		cmp	al,ah
		jnz	short NOTMELCOPY ; no source wildcard

;	Source and destination are both wildcarded.

		cmp	byte [PLUS],0
		jz	short NOTMELCOPY ; no +'s in source

;	Source and destination are wildcarded, and source includes +'s.
;	It's Mel Hallorman copy time.

		inc	byte [MELCOPY]	; 'Mel copy' = true
		xor	al,al
		jmp	short SETCONC

NOTMELCOPY:
		xor	al,2	; AL=0 -> ambiguous destination, 2 otherwise
		and	al,ah
		shr	al,1	; AL=1 -> ambiguous source, unambiguous dest
				;   (implies concatenation)
SETCONC:
		or	al,[PLUS]	; "+" always infers concatenation

;	Whew. AL = 1 if concatenating, 0 if not.

		mov	[CONCAT],al
		shl	al,1
		shl	al,1
		mov	[INEXACT],al	; concatenation -> inexact copy
		cmp	byte [BINARY],0
		jne	short NOFIRSTDEST ; explicit binary copy	

		mov	[ASCII],al	; otherwise, concatenate in ascii mode	
		or	cl,cl
		jnz	short NOFIRSTDEST ; Ascii flag set before, data read correctly	
		or	al,al
		jz	short NOFIRSTDEST ; Ascii flag did not change state

;	At this point there may already be binary read data in the read
;	buffer. We need to find the first ^Z (if there is one) and trim the
;	amount of data in the buffer correctly.

		mov	cx,[NXTADD]
		jcxz	NOFIRSTDEST	; no data, everything ok
		mov	al,1Ah
		push	es
		xor	di,di
		mov	es,[TPA]
		repne scasb		; scan for EOF
		pop	es
		jnz	short NOFIRSTDEST ; no ^z in buffer, everything ok
		dec	di		; point at ^z
		mov	[NXTADD],di	; new buffer length

NOFIRSTDEST:
		mov	bx,DIRBUF+1	; Source of replacement chars
		cmp	byte [CONCAT],0
		jz	short GOTCHRSRC	; Not a concat
		mov	bx,SDIRBUF+1	; Source of replacement chars
GOTCHRSRC:
		mov	si,DESTFCB+1	; Original dest name
		mov	di,[DESTTAIL]	; Where to put result

; --------------- S U B	R O U T	I N E --------------------------------------- 

BUILDNAME:
		mov	cx,8
BUILDMAIN:
		lodsb
		cmp	al,'?'
		jnz	short NOTAMBIG
		mov	al,[bx]
NOTAMBIG:
		cmp	al,' '
		jz	short NOSTORE
		stosb
NOSTORE:
		inc	bx
		loop	BUILDMAIN
		mov	cl,3
		mov	al,' '
		cmp	[si],al
		jz	short ENDDEST	; No extension
		mov	al,[DOT_CHR]
		stosb
BUILDEXT:
		lodsb
		cmp	al,'?'
		jnz	short NOTAMBIGE
		mov	al,[bx]
NOTAMBIGE:
		cmp	al,' '
		jz	short NOSTOREE
		stosb
NOSTOREE:
		inc	bx
		loop	BUILDEXT
ENDDEST:
		xor	al,al
		stosb			; NUL terminate
		retn

; =============== S U B	R O U T	I N E =======================================

BUILDPATH:
		test	byte [bp+VARSTRUC.INFO],2  ; test byte [bp+4],2
		jnz	short NOTPFILE	; If ambig don't bother with open
		mov	dx,bp		; Set DX to spec
		add	dx,VARSTRUC.BUF ; add dx,5

		; MSDOS 6.0
		;push	di				;AN000;
		;mov	ax,EXTOPEN SHL 8		;AC000; open the file
		;mov	bx,DENY_NONE or READ_OPEN_MODE	; open mode for COPY ;M046
		;xor	cx,cx				;AN000; no special files
		;mov	si,dx				;AN030; get file name offset
		;mov	dx,read_open_flag		;AN000; set up open flags
		;INT	21h
		;pop	di				;AN000;
		;jnc	pure_file			;AN022; is pure file
		;invoke	get_ext_error_number		;AN022; get the extended error
		;cmp	ax,error_file_not_found 	;AN022; if file not found - okay
		;jz	notpfile			;AN022;
		;cmp	ax,error_path_not_found 	;AN022; if path not found - okay
		;jz	notpfile			;AN022;
		;cmp	ax,error_access_denied		;AN022; if access denied - okay
		;jz	notpfile			;AN022;
		;jmp	extend_setup			;AN022; exit with error
;pure_file:
		; MSDOS 3.3
		mov	ax,OPEN*256 ; 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jc	short NOTPFILE
;PURE_FILE:
		mov	bx,ax
		mov	ax,IOCTL*256 ; 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	ah,CLOSE ;3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		test	dl,devid_ISDEV ; test dl, 80h
		jnz	short ISADEV
		test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
		jz	short ISADEV

NOTPFILE:
		mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
		
		;MSDOS 6.0
		;cmp	dl,0		     	;AN034; If no drive specified, get
		;je	short SET_DRIVE_SPEC	;AN034;    default drive dir

		cmp	dh,':'
		je	short DRVSPEC5

SET_DRIVE_SPEC:
		mov	dl,'@'

DRVSPEC5:
		or	dl,20h
		sub	dl,60h		; A = 1
		call	SAVUDIR1
	
		; MSDOS 6.0
		;jnc	short curdir_ok		;AN022; if error - exit
		;invoke	get_ext_error_number	;AN022; get the extended error
		;jmp	extend_setup		;AN022; exit with error

CURDIR_OK:
		mov	dx,bp
		;add	dx,5
		add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
		;mov	bh,[bp+4]
		mov	bh,[bp+VARSTRUC.INFO]
		and	bh,6
		cmp	bh,6			; Ambig and path ?
		jne	short CHECKAMB		; jmp if no
		;mov	si,[bp+2]
		mov	si,[bp+VARSTRUC.TTAIL]
		mov	bl,':'
		cmp	[si-2],bl
		jne	short KNOWNOTSPEC
		;mov	byte [bp+VARSTRUC.ISDIR],2 ; Know is d:/file
		;mov	byte [bp+0],2
		mov	byte [bp],2
		jmp	short DOPCDJ

KNOWNOTSPEC:
		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know is path/file
		;mov	byte [bp+0],1		
		mov	byte [bp],1
		dec	si
DOPCDJ:
		jmp	short DOPCD

CHECKAMB:
		cmp	bh,2
		jnz	short CHECKCD
ISSIMPFILE:
ISADEV:
		;mov	byte [bp+VARSTRUC.ISDIR],0
		;mov	byte [bp+0],0		
		mov	byte [bp],0
		retn

CHECKCD:
		call	SETREST1
		mov	ah,CHDIR ; 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short NOTPDIR
		mov	di,dx
		xor	ax,ax
		mov	cx,ax
		dec	cx
		repne scasb
DONE:
		dec	di
		mov	al,[DIRCHAR]
		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
		;mov	byte [bp+0],2
		mov	byte [bp],2
		cmp	al,[di-1]
		jz	short GOTSRCSLSH
_STORE_PCHAR:
		stosb
		;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
		;mov	byte [bp+0],1
		mov	byte [bp],1
GOTSRCSLSH:
		;or	byte [bp+4],6
		or 	byte [bp+VARSTRUC.INFO],6 
		call	SETSTARS
NOTPDIR_RETN:
		retn

NOTPDIR:
		; MSDOS 6.0
		;invoke	get_ext_error_number	;AN022; get the extended error
		;cmp	ax,error_path_not_found ;AN022; if path not found - okay
		;jz	notpdir_try		;AN022;
		;cmp	ax,error_access_denied	;AN022; if access denied - okay
		;jnz	extend_setupj		;AN022; otherwise - exit error
;notpdir_try:
		; MSDOS 3.3 (& MSDOS 6.0)
		;mov	byte [bp+VARSTRUC.ISDIR],0
		;mov	byte [bp+0],0
		mov	byte [bp],0
		;mov	bh,[bp+4]
		mov	bh,[bp+VARSTRUC.INFO]
		test	bh,4
		jz	short NOTPDIR_RETN	; Know pure file, no path seps
		;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
		;mov	byte [bp+0],2		
		mov	byte [bp],2
		;mov	si,[bp+2]
		mov	si,[bp+VARSTRUC.TTAIL]
		cmp	byte [si],0
		je	short BADCDERRJ2	; Trailing '/'	
		mov	bl,[DOT_CHR]
		cmp	[si],bl
		je	short BADCDERRJ2	; If . or .. pure cd should have worked
		mov	bl,':'
		cmp	[si-2],bl
		je	short DOPCD		   ; Know d:/file
		;mov	byte [bp+VARSTRUC.ISDIR],1 ; Know path/file
		;mov	byte [bp+0],1
		mov	byte [bp],1
		dec	si			; Point at last '/'
DOPCD:
		xor	bl,bl
		xchg	bl,[si]			; Stick in a NUL
		call	SETREST1
		cmp	bl,[si-1]		; if double slash, then complain.
		je	short BADCDERRJ2
		mov	ah,CHDIR ; 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xchg	bl,[si]
		jnc	short NOTPDIR_RETN
		
		; MSDOS 3.3
BADCDERRJ2:
		stc
		jmp	BADCDERR

		; MSDOS 6.0
		;invoke	get_ext_error_number	;AN022; get the extended error
;EXTEND_SETUPJ:					;AN022;
		;JMP	EXTEND_SETUP		;AN022; go issue the error message
;BADCDERRJ2:
		;jmp	badpath_err		;AC022; go issue path not found message

; =============== S U B	R O U T	I N E =======================================

SETSTARS:
		;mov	[bp+2],di
		mov	[bp+VARSTRUC.TTAIL],di
		;add	byte [bp+1],12
		add	byte [bp+VARSTRUC.SIZ],12
		mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
		mov	cx,8
		rep stosb
		xchg	al,ah
		stosb
		xchg	al,ah
		mov	cl,3
		rep stosb
		xor	al,al
		stosb
		retn

; =============== S U B	R O U T	I N E =======================================

COMPNAME:
		mov	si,DESTBUF	; do name translate of target
		mov	di,TRGXNAME	; save for name comparison
		mov	ah,XNAMETRANS ; 60h
		int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
				; DS:SI	-> ASCIZ relative path string or directory name
				; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	si,SRCXNAME	; get name translate of source
		mov	di,TRGXNAME	; get name translate of target
		call	STRCOMP
		retn

;============================================================================
; CPARSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/09/2018 - Retro DOS v3.0

;-----------------------------------------------------------------------;
; ENTRY:								;
;	DS:SI	Points input buffer					;
;	ES:DI	Points to the token buffer				;
;	BL	Special delimiter for this call 			;
;		    Always checked last 				;
;		    set it to space if there is no special delimiter	;
; EXIT: 								;
;	DS:SI	Points to next char in the input buffer 		;
;	ES:DI	Points to the token buffer				;
;	[STARTEL] Points to start of last element of path in token	;
;		points to a NUL for no element strings 'd:' 'd:/'       ;
;	CX	Character count 					;
;	BH	Condition Code						;
;			Bit 1H of BH set if switch character		;
;				Token buffer contains char after	;
;				switch character			;
;				BP has switch bits set (ORing only)	;
;			Bit 2H of BH set if ? or * in token		;
;				if * found element ? filled		;
;			Bit 4H of BH set if path sep in token		;
;			Bit 80H of BH set if the special delimiter	;
;			   was skipped at the start of this token	;
;		Token buffer always starts d: for non switch tokens	;
;	CARRY SET							;
;	    if CR on input						;
;		token buffer not altered				;
;									;
;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
; MODIFIES:								;
;	CX, SI, AX, BH, DX and the Carry Flag				;
;									;
;-----------------------------------------------------------------------;

; Modifications to cparse: recognition of right and left parentheses
; as integral tokens, and removal of automatic upper-case conversion code.
;
; Both modifications were installed in the course of adding a coherent
; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
; structure for command-line arguments. This parser relies on cparse to
; recognize individual tokens.
;
; To process for-loops correctly, parentheses must therefore be
; recognized as tokens. The upper-case conversion code was removed so
; that commands (such as for and echo) would be able to use the "original"
; text of the command line.
;
; Note also the modification to prevent the automatic conversion of colons
; into spaces WITHIN THE SOURCE TEXT!
;
; Also note that BP is also clobbered if cparse recognizes any switches
; on the command line.
;
; Alan L, OS/MSDOS				    14 August 1983

; ---------------------------------------------------------------------------

; COMEQU.ASM (MSDOS 6.0, 1991)

;FSWITCH	EQU	8000h
;FBADSWITCH	EQU	4000h

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h

; =============== S U B	R O U T	I N E =======================================

CPARSE:
		xor	ax,ax
		mov	[STARTEL],di		; No path element (Is DI correct?)
		mov	[ELPOS],al		; Start in 8 char prefix
		mov	[SOURCE],al		; No skip delimiter yet
		mov	bh,al			; Init nothing
		pushf				; save flags
		push	di			; save the token buffer addrss
		xor	cx,cx			; no chars in token buffer
		mov	[COMMA],cl		; reset comma flag

MOREDELIM:
		lodsb
		call	DELIM
		jnz	short SCANCDONE
		cmp	al,' '
		jz	short MOREDELIM
		cmp	al,9
		jz	short MOREDELIM
		xchg	al,[SOURCE]
		or	al,al
		jz	short MOREDELIM		; One non space/tab delimiter allowed
		test	bh,80h			; has a special char been found?
		jz	short NO_COMMA		; no - just exit
		mov	byte [COMMA],1		; set comma flag

NO_COMMA:
		jmp	X_DONE			; Nul argument

SCANCDONE:
		cmp	byte [CPYFLAG],1
		jnz	short CPCONT1
		call	UPCONV_MAPCALL
CPCONT1:
		cmp	al,bl			; Special delimiter?
		jnz	short NOSPEC
		or	bh,80h
		jmp	short MOREDELIM

NOSPEC:
		cmp	al,0Dh			; a CR?
		jnz	short NCPERROR
		jmp	CPERROR

NCPERROR:
		cmp	al,[SWITCHAR]		; is the char the switch char?
		jnz	short NA_SWITCH		; yes, process...
		jmp	A_SWITCH

NA_SWITCH:
		mov	dl,':'
		cmp	[si],dl
		jnz	short ANUM_CHARD	; Drive not specified
		call	MOVE_CHAR
		lodsb				; Get the ':'
		call	MOVE_CHAR
		mov	[STARTEL],di
		mov	byte [ELCNT],0
		jmp	ANUM_TEST

ANUM_CHARD:
		mov	[STARTEL],di
		mov	byte [ELCNT],0		; Store of this char sets it to one
		cmp	byte [CPYFLAG],1	; Was CPARSE called from COPY?
		jnz	short ANUM_CHAR		; No, don't add drive spec.
		call	PATHCHRCMP		; Starts with a pathchar?
		jnz	short ANUM_CHAR		; no
		push	ax
		mov	al,[CURDRV]		; Insert drive spec
		add	al,[CAPITAL_A]
		call	MOVE_CHAR
		mov	al,':'
		call	MOVE_CHAR
		pop	ax
		mov	[STARTEL],di
		mov	byte [ELCNT],0

ANUM_CHAR:
		cmp	al,[DOT_CHR]
		jnz	short TESTQUEST
		inc	byte [ELPOS]		; flag in extension
		mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
TESTQUEST:
		cmp	al,'?'
		jnz	short TESTSPLAT
		or	bh,2
TESTSPLAT:
		cmp	al,[STAR]
		jnz	short TESTPATH
		or	bh,2
		cmp	byte [EXPAND_STAR],0
		jnz	short EXPAND_FILENAME
		jmp	short TESTPATH

BADPERR2J:
		jmp	BADPERR2

		;db	0E9h
		;db	7Eh	
		;db	0

EXPAND_FILENAME:
		mov	ah,7
		cmp	byte [ELPOS],0
		jz	short GOTELCNT
		mov	ah,2
GOTELCNT:
		mov	al,'?'
		sub	ah,[ELCNT]
		jb	short BADPERR2J
		xchg	ah,cl
		jcxz	TESTPATHX
QMOVE:
		xchg	ah,cl
		call	MOVE_CHAR
		xchg	ah,cl
		loop	QMOVE
TESTPATHX:
		xchg	ah,cl
TESTPATH:
		call	PATHCHRCMP
		jnz	short NOTSPECIAL
		or	bh,4
		cmp	byte [EXPAND_STAR],0
		jz	short NO_ERR_CHECK
		test	bh,2		; If just hit a '/', cannot have ? or * yet
		jnz	short BADPERR
NO_ERR_CHECK:
		mov	[STARTEL],di	  ; New element
		inc	word [STARTEL]	  ; Point to char after /
		mov	byte [ELCNT],0FFh ; Store of '/' sets it to 0
		mov	byte [ELPOS],0
NOTSPECIAL:
		call	MOVE_CHAR	; just an alphanum string
ANUM_TEST:
		lodsb
		cmp	byte [CPYFLAG],1
		jnz	short CPCONT3
		call	UPCONV_MAPCALL
CPCONT3:
		call	DELIM
		jz	short X_DONE
		cmp	al,0Dh
		jz	short X_DONE
		cmp	al,[SWITCHAR]
		jz	short X_DONE
		cmp	al,bl
		jz	short X_DONE
		cmp	al,':'		; ':' allowed as trailer because of devices
		jnz	short ANUM_CHARJ

; Modification made for parseline.
; Why would it be necessary to change colons to spaces? In this
; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
; but so does 'echo foo:bar' yield 'echo foo bar'.

		cmp	byte [CPYFLAG],2
		jnz	short CPCONT4
		call	MOVE_CHAR
		jmp	short ANUM_TEST

CPCONT4:
		inc	si		;Skip the ':'
		jmp	short X_DONE

ANUM_CHARJ:
		jmp	ANUM_CHAR

BADPERR2:
		mov	dx,BADCPMESPTR
		jmp	CERROR

BADPERR:
		jmp	BADCDERR  ; MSDOS 3.3	

CPERROR:
		dec	si		; adjust the pointer
		pop	di		; retrive token buffer address
		popf			; restore flags
		stc			; set the carry bit
		retn

X_DONE:
		dec	si		; adjust for next round

; Mod to recognize right and left parens as integral tokens.
;X_DONE2:
		jmp	short OUT_TOKEN

A_SWITCH:
		or	bh,1		; Indicate switch
		or	bp,FSWITCH ; 8000h
		call	SCANOFF
		inc	si
		cmp	al,0Dh
		jnz	short STORE_SWT
		mov	al,0
		stosb
		or	bp,FBADSWITCH ; 4000h
		jmp	short CPERROR	; Trailing switch character error
					;   BP = fSwitch but no switch
					;   bit is set (unknown switch)

STORE_SWT:
		call	MOVE_CHAR	; store the character

; This upconv call must stay.  It is used to identify copy-switches
; on the command line, and won't store anything into the output buffer.

		call	UPCONV_MAPCALL
		push	es
		push	di
		push	cx
		push	cs
		pop	es
		mov	di,SWITCH_LIST ; "VBAPW"
		mov	cx,SWCOUNT ; 5
		or	bp,FBADSWITCH  ; 4000h
		repne scasb
		jnz	short OUT_TOKENP
		and	bp,~FBADSWITCH ; 0BFFFh
		mov	ax,1
		shl	ax,cl
		or	bp,ax
OUT_TOKENP:
		pop	cx
		pop	di
		pop	es
OUT_TOKEN:
		mov	al,0		; null at the end
		stosb
		pop	di		; restore token buffer pointer	
		popf
		clc			; clear carry flag
		retn

; =============== S U B	R O U T	I N E =======================================

MOVE_CHAR:
		stosb			; store char in token buffer
		inc	cx		; increment char count
		inc	byte [ELCNT]	; increment element count for * substi
		retn

;============================================================================
; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
;============================================================================
; 30/09/2018 - Retro DOS v3.0

; BREAK	<Message Printing Routine>

;
;	MSDOS V3.00 PRINT
;
;	Message Printing Routine
;

;PRINTF.ASM (MSDOS 3.3, LIBC)
;
;TITLE   PRINTF ROUTINE FOR MS-DOS
;
; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
;
; Characters are output to PFHandle according to the
; specifications contained in the Control String.
;
; The conversion characters are as follow:
;
;               %c - output the next argument as a character
;               %s - output the next argument as a string
;               %x - output the next argument as a hexidecimal number
;                    using abcedf
;               %X - output the next argument as a hexidecimal number
;                    using ABCDEF
;               %d - output the next argument as a decimal number
;
;
; Other format specifiers that may precede the conversion character are:
;
;               - (minus sign) - causes the field to be left-adjusted
;               + (plus sign)  - causes the field to be right-adjusted (default)
;               n - digit specifing the minimum field width (default to 1)
;               L - specifing a long integer
;
;   On entry to PRINTF the stack contains the return address and a pointer
;   to an argument list.
;
;   ____________________
;   |   Ret Addr       |      <= SP
;   --------------------
;   |  Ptr to Arg List |
;   --------------------
;
;   And the argument list contains the following:
;
;       String_ptr                  (a pointer to the control string)
;       Arg 1
;       Arg 2
;         .
;         .
;         .
;       Arg n-1
;       Arg n
;
;   If the argument is a %s or %c the arg contains a pointer to the string
;   or character.
;
;   The arguments are used in one-to-one correspondence to % specifiers.


		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h

; =============== S U B	R O U T	I N E =======================================

PRINTF_INIT:
		call	STD_PRINTF
		retf

; =============== S U B	R O U T	I N E =======================================

PRINTF_CRLF:
		call	STD_PRINTF
		call	CRLF2
		retn

; =============== S U B	R O U T	I N E =======================================

STD_EPRINTF:
		mov	word [cs:PRINTF_HANDLE],2
		jmp	short NEW_PRINTF

; =============== S U B	R O U T	I N E =======================================

STD_PRINTF:

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h

		mov	word [cs:PRINTF_HANDLE],1

NEW_PRINTF:				;Save the callers' registers
		cld
		push	dx
		push	bp
		mov	bp,sp
		push	cx
		push	bx
		push	ax
		push	di
		push	si
		push	es
		push	ds
		push	cs
		pop	es		;ES points to Printf segment
		mov	di,PRINTF_BUF	;DI points to the output buffer
		mov	bp,[bp+2]  ; dx ;BP points to the argument list
		;mov	si,[ds:bp+0]	;SI points to the control string
		mov	si,[ds:bp] ; bp
		add	bp,2
		xor	bx,bx
		call	CLEAR_FLAGS	; initialize the world

GET_CHAR:
		lodsb			;Get a character
		cmp	al,'%'		;Is it a conversion specifier?
		jz	short CONV_CHAR	;Yes - find out which one
		or	al,al		;Is it the end of the control string?
		jz	short PRINTF_DONE ;Yes - then we're done
PRINTF_PERCENT:				
		call	OUTCHR		;Otherwise store the character
		jmp	short GET_CHAR	;And go get another

PRINTF_DONE:
		call	FLUSH
		pop	ds
		pop	es
		pop	si
		pop	di
		pop	ax
		pop	bx
		pop	cx
		pop	bp
		pop	dx
		retn

CONV_CHAR:
		mov	byte [cs:PRINTF_LEFT],0

NXT_CONV_CHAR:	
		;Look for any format specifiers preceeding the conversion character
		lodsb
		cmp	al,'%'			;Just print the %
		jz	short PRINTF_PERCENT
		cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
		jz	short LEFT_ADJ
		cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
		jz	short CONV_CHAR
		cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
		jz	short LONG_INT
		cmp	al,[cs:char_l]	 ; "l"		
		jz	short LONG_INT
		cmp	al,'0'			;Is it a precision specification
		jb	short LOOK_CONV_CHAR
		cmp	al,'9'
		ja	short LOOK_CONV_CHAR
		cmp	al,'0'
		jnz	short NOT_PAD
		cmp	word [cs:PRINTF_WIDTH],0
		jnz	short NOT_PAD
		mov	ah,'0'
		mov	[cs:PAD_CHAR],ah
NOT_PAD:					;Adjust decimal place on precision
		push	ax
		mov	ax,[cs:PRINTF_WIDTH]
		mov	cx,10
		mul	cx
		pop	dx
		xor	dh,dh
		sub	dl,'0'
		add	ax,dx
		mov	[cs:PRINTF_WIDTH],ax	;And save the total
		jmp	short NXT_CONV_CHAR

LEFT_ADJ:
		mov	byte [cs:PRINTF_LEFT],1
		jmp	short NXT_CONV_CHAR

LONG_INT:
		or	byte [cs:PRINTF_LONG],1
		jmp	short NXT_CONV_CHAR

LOOK_CONV_CHAR:
		and	al,0DFh
		cmp	al,[cs:CHAR_X]	 ; "X"
		jz	short HEX_UP
		cmp	al,[cs:CHAR_D]	 ; "D"
		jz	short DECIMAL
		cmp	al,[cs:CHAR_C]	 ; "C"
		jz	short C_PUT_CHAR
		cmp	al,[cs:CHAR_S]	 ; "S"
		jz	short S_PUT_STRG
		call	CLEAR_FLAGS
		jmp	GET_CHAR

HEX_UP:
		mov	word [cs:PRINTF_BASE],16 ;Hex conversion
		jmp	short CONV_TO_NUM
DECIMAL:
		mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
		jmp	short CONV_TO_NUM

C_PUT_CHAR:
		call	NEXT_CHRS
		mov	al,dl
		call	OUTCHR
		call	CLEAR_FLAGS
		jmp	GET_CHAR

S_PUT_STRG:
		push	si			;Save pointer to control string
		call	NEXT_CHRS
		mov	si,dx
S_PUT_1:
		mov	cx,[cs:PRINTF_WIDTH]
		or	cx,cx
		jz	short S_PUT_2
		cmp	byte [cs:PRINTF_LEFT],0
		jnz	short S_PUT_2
		call	PAD_STRING
S_PUT_2:
		push	si
S_PUT_3:
		lodsb
		or	al,al
		jz	short S_PUT_4
		call	OUTCHR			;Put it into our buffer
		jmp	short S_PUT_3
S_PUT_4:
		pop	si
		cmp	byte [cs:PRINTF_LEFT],0
		jz	short C_S_END
		mov	cx,[cs:PRINTF_WIDTH]
		or	cx,cx
		jz	short C_S_END
		call	PAD_STRING
C_S_END:
		pop	si			;Restore control string pointer
		call	CLEAR_FLAGS
		jmp	GET_CHAR		;Go get another character	


; =============== S U B	R O U T	I N E =======================================

PAD_STRING:
		xor	dx,dx
		push	si

COUNT_LOOP:
		lodsb
		or	al,al
		jz	short COUNT_DONE
		inc	dx
		jmp	short COUNT_LOOP

COUNT_DONE:
		pop	si
		sub	cx,dx
		jbe	short COUNT_RET
		call	PAD

COUNT_RET:
		retn

; ---------------------------------------------------------------------------

CONV_TO_NUM:
		call	NEXT_CHRS
		mov	ax,dx
		xor	dx,dx
		cmp	byte [cs:PRINTF_LONG],0 
				;Is this is a short or long integer?
		jz	short NOT_LONG_INT
		call	NEXT_CHRS

NOT_LONG_INT:
		push	bx
		push	si
		mov	si,[cs:PRINTF_BASE]
		mov	cx,[cs:PRINTF_WIDTH]
		call	PNUM
		pop	si
		pop	bx
		call	PAD
		call	CLEAR_FLAGS
		jmp	GET_CHAR


; =============== S U B	R O U T	I N E =======================================

PNUM:
		dec	cx
		push	ax
		mov	ax,dx
		xor	dx,dx
		div	si
		mov	bx,ax
		pop	ax
		div	si
		xchg	bx,dx
		push	ax
		or	ax,dx
		pop	ax
		jz	short DO_PAD
		push	bx
		call	PNUM
		pop	bx
		jmp	short REM

DO_PAD:
		cmp	byte [cs:PRINTF_LEFT],0
		jnz	short REM
		call	PAD
REM:
		cmp	bl,10
		jb	short NOT_HEX
		add	bx,6
NOT_HEX:
		mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
		push	cx
		call	OUTCHR
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

PAD:
		or	cx,cx
		jle	short PAD_DONE
		mov	al,[cs:PAD_CHAR]
PAD_LOOP:
		push	cx
		call	OUTCHR
		pop	cx
		loop	PAD_LOOP
PAD_DONE:
		retn

; =============== S U B	R O U T	I N E =======================================

OUTCHR:
		stosb
		cmp	di,PRINTF_BUF_END ; SRCXNAME
		je	short FLUSH
OUTCHR_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

FLUSH:
		mov	cx,PRINTF_BUF
		xchg	cx,di
		sub	cx,di
		jz	short OUTCHR_RETN
WRITE_CHARS:
		push	bx
		mov	bx,[cs:PRINTF_HANDLE]
		push	ds
		push	cs
		pop	ds
		mov	dx,PRINTF_BUF
		mov	ah,WRITE ; 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write,
					; DS:DX -> buffer
		jnb	short FOOB2_1
		call	GET_EXT_ERR_NUMBER
		cmp	ax,6
		jz	short FOOB2_4
		jmp	short FOOB2_2

FOOB2_1:
		cmp	cx,ax
		jz	short FOOB2_4
FOOB2_2:
		mov	bx,dx
		add	bx,ax
		cmp	byte [bx],1Ah
		jz	short FOOB2_4
		pop	ds
		pop	bx
		mov	es,[cs:RESSEG]
		mov	dx,NOSPACEPTR
		test	byte [es:PIPEFLAG],0FFh
		jz	short PRINT_ERR_EXIT
		call	PIPEOFF
		mov	dx,PIPEEMESPTR
PRINT_ERR_EXIT:	
		jmp	CERROR

FOOB2_4:
		pop	ds
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

NEXT_CHRS:
		push	si		;Save pointer to control string
		mov	si,bx		;Get index into argument list
		add	bx,2		;Increment the index
		mov	si,[ds:bp+si]	; Get pointer to next argument
		mov	dx,[si]		; Get (address of the) next argument			
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================

CLEAR_FLAGS:
		xor	ax,ax
		mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
		mov	[cs:PRINTF_LONG],al	;Reset long flag
		mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
		mov	al,' '			
		mov	[cs:PAD_CHAR],al 	;Reset padding character
		retn

; ---------------------------------------------------------------------------
		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h

		; times 7 db 0

;============================================================================
; TDATA.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/09/2018 - Retro DOS v3.0

; TITLE	COMMAND Transient Initialized DATA

;The TRANDATA segment contains data that is assumed to have predefined
;initial values at the beginning of each command cycle. It is
;included in the transient checksum area. If values in TRANDATA
;change, the transient will be reloaded for the next command cycle.

align 16
		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h

PRINTF_TABLE:	db '0123456789ABCDEF'
_3740h:		db '%S',0
ARG_BUF_PTR:	dw _3740h
		dw _3747h
_3747h:		dw ARG_BUF ; _43E8h
_3749h:		db '%S ',0
STRINGBUF1PTR:	dw _3749h
		dw STRING_PTR_1 ; _4468h
_3751h:		db '%9ld',0
FSIZEMESPTR:	dw _3751h
		dw FILESIZE_L ; _446Ah
		dw FILESIZE_H ; _446Ch
_375Ch:		db '%S',0
STRINGBUF2PTR:	dw _375Ch
		dw STRING_PTR_2 ; _446Eh
_3763h:		db 9,0
TABPTR:		dw _3763h
_3767h:		db 0Dh,0Ah
		db 'Batch file missing',0Dh,0Ah,0
BADPATHPTR:	dw _3767h
_3780h:		db 0Dh,0Ah
		db 'Insert disk with batch file',0Dh,0Ah
		db 'and press any key when ready',0Dh,0Ah,0
INSERTDSKPTR:	dw _3780h
_37C0h:		db 'Bad command or file name',0Dh,0Ah,0
BADNAMPTR:	dw _37C0h
_37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
RENERRPTR:	dw _37DDh
_3807h:		db 'File not found',0Dh,0Ah,0
FNOTFOUNDPTR:	dw _3807h
_381Ah:		db 'Path not found',0Dh,0Ah,0
PNOTFOUNDPTR:	dw _381Ah
_382Dh:		db 'Access denied',0Dh,0Ah,0
ACCDENPTR:	dw _382Dh
_383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
NOSPACEPTR:	dw _383Fh
_385Bh:		db 'Out of environment space',0Dh,0Ah,0
ENVERRPTR:	dw _385Bh
_3878h:		db 'File creation error',0Dh,0Ah,0
FULDIRPTR:	dw 3878h
_3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
OVERWRPTR:	dw _3890h
_38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
LOSTERRPTR:	dw _38B6h
_38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
INORNOTPTR:	dw _38E2h
_3909h:		db '%9d File(s) copied',0Dh,0Ah,0
COPIEDPTR:	dw _3909h
		dw COPY_NUM ; _4470h
_3922h:		db '%9d File(s) ',0
DIRMESPTR:	dw _3922h
		dw DIR_NUM  ; _4477h
_3933h:		db '%9ld bytes free',0Dh,0Ah,0
BYTEMESPTR:	dw _3933h
		dw BYTES_FREE   ; _4479h
		dw BYTES_FREE+2 ; _447Bh
_394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
BADDRVPTR:	dw _394Bh
_396Bh:		db 0Dh,0Ah
		db 'Code page %5d not prepared for system',0Dh,0Ah,0
CPNOTSETPTR:	dw _396Bh
		dw SYSTEM_CPAGE ; _3F2Fh
_3999h:		db 0Dh,0Ah
		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
CPNOTALLPTR:	dw _3999h
		dw SYSTEM_CPAGE ; _3F2Fh
_39CCh:		db 0Dh,0Ah
		db 'Active code page: %5d',0Dh,0Ah,0
CPACTIVEPTR:	dw _39CCh
		dw SYSTEM_CPAGE ; _3F2Fh
_39EAh:		db 'Current drive is no longer valid',0
BADCURDRVPTR:	dw _39EAh
_3A0Dh:		db 'Strike a key when ready . . . ',0
PAUSEMESPTR:	dw _3A0Dh
_3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
BADPARMPTR:	dw _3A2Eh
WEEKTAB:	db 'SunMonTueWedThuFriSat'
_3A59h:		db 0Dh,0Ah
		db 'Invalid date',0
BADDATPTR:	dw _3A59h
_3A6Ah:		db 'Current date is ',0
CURDATPTR:	dw _3A6Ah
_3A7Dh:		db 0Dh,0Ah
		db 'Enter new date ',0
NEWDATPTR:	dw _3A7Dh
_3A91h:		db '(mm-dd-yy): ',0
USADATPTR:	dw _3A91h
_3AA0h:		db '(dd-mm-yy): ',0
EURDATPTR:	dw _3AA0h
_3AAFh:		db '(yy-mm-dd): ',0
JAPDATPTR:	dw _3AAFh
_3ABEh:		db 0Dh,0Ah
		db 'Invalid time ',0
BADTIMPTR:	dw _3ABEh
_3AD0h:		db 'Current time is ',0
CURTIMPTR:	dw _3AD0h
_3AE3h:		db 0Dh,0Ah
		db 'Enter new time: ',0
NEWTIMPTR:	dw _3AE3h
_3AF8h:		db 'Are you sure (Y/N)?',0
SUREMESPTR:	dw _3AF8h
_3B0Eh:		db ' <DIR>   ',0
DMESPTR:	dw _3B0Eh
_3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
VERMESPTR:	dw _3B1Ah
		dw MAJOR_VER_NUM ; _447Dh
		dw MINOR_VER_NUM ; _447Fh
_3B4Dh:		db '%C',0
ONECHRVALPTR:	dw _3B4Dh
		dw ONE_CHAR_VAL	; _4481h
_3B54h:		db ' Volume in drive %c %s',0
VOLMESPTR:	dw _3B54h
		dw VOL_DRV ; _4484h
		dw VOLNAME_ADDR ; _4482h
IS:		db 'is ',0
NOVOL:		db 'has no label',0
_3B82h:		db 'Invalid directory',0Dh,0Ah,0
BADCDPTR:	dw _3B82h
_3B98h:		db 'Unable to create directory',0Dh,0Ah,0
BADMKDPTR:	dw _3B98h
_3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
		db 'or directory not empty',0Dh,0Ah,0
BADRMDPTR:	dw _3BB7h
_3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
BADONOFFPTR:	dw _3BF0h
_3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
DIRHEADPTR:	dw _3C0Bh
		dw VOL_DIR ; _4485h
_3C23h:		db 'No Path',0
NULLPATHPTR:	dw _3C23h
PATH_TEXT:	db 'PATH='
PROMPT_TEXT:	db 'PROMPT='
COMSPEC_TEXT:	db 'COMSPEC='
_3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
BADPMESPTR:	dw _3C41h
_3C62h:		db 'Invalid device',0Dh,0Ah,0
BADDEVPTR:	dw _3C62h
_3C75h:		db 'Label not found',0Dh,0Ah,0
BADLABPTR:	dw _3C75h
_3C89h:		db 'Syntax error',0Dh,0Ah,0
SYNTMESPTR:	dw _3C89h
_3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
FORNESTMESTR:	dw _3C9Ah
_3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
INSFMEMMESPTR:	dw _3CB4h
_3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
PIPEEMESPTR:	dw _3CCCh
_3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
INBDEVPTR:	dw _3CF4h
_3D1Dh:		db 'BREAK is ',0
CTRLMESPTR:	dw _3D1Dh
_3D29h:		db 'VERIFY is ',0
VERIMESPTR:	dw _3D29h
_3D36h:		db 'ECHO is ',0
ECHOMESPTR:	dw _3D36h
_3D41h:		db 'off',0Dh,0Ah,0
OFFMESPTR:	dw _3D41h
_3D49h:		db 'on',0Dh,0Ah,0
ONMESPTR:	dw _3D49h
_3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
BADCPMESPTR:	dw _3D50h
_3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
BADARGSPTR:	dw _3D6Eh
_3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
DEVWMESPTR:	dw _3D8Fh
_3DABh:		db 0Dh,0Ah,0
ACRLFPTR:	dw _3DABh
_3DB0h:		db 8
		db 20h
		db 8
		db 0
DBACKPTR:	dw _3DB0h
small_y:	db 'y'
small_n:	db 'n'
CAPITAL_Y:	db 'Y'
CAPITAL_N:	db 'N'
CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
PROMPT_TABLE:
		db 'B' ; 42h
		dw PRINT_B
		db 'D' ; 44h
		dw PRINT_DATE
		db 'E' ; 45h
		dw PRINT_ESC
		db 'G' ; 47h
		dw PRINT_G
		db 'H' ; 48h
		dw PRINT_BACK
		db 'L' ; 4Ch
		dw PRINT_L
		db 'N' ; 4Eh
		dw PRINT_DRIVE
		db 'P' ; 50h
		dw BUILD_DIR_FOR_PROMPT
		db 'Q' ; 51h
		dw PRINT_EQ
		db 'T' ; 54h
		dw PRINT_TIME
		db 'V' ; 56h
		dw PRINT_VERSION
		db '_' ; 5Fh
		dw CRLF2
		db '$' ; 24h
		dw PRINT_CHAR
		db 0

		; Table of IF conditionals
IFTAB:
		db 3	; First byte is count
		db 'NOT'
		dw IFNOT
		db 10
		db 'ERRORLEVEL'
		dw IFERLEV
		db 5
		db 'EXIST'
		dw IFEXISTS
		db 0

		; Table for internal command names

COMTAB:		db 3
		db 'DIR'
		db 3
		dw CATALOG
		db 4
		db 'CALL'
		db 2
		dw _$CALL
		db 4
		db 'CHCP'
		db 2
		dw CHCP
		db 6
		db 'RENAME'
		db 1
		dw CRENAME
		db 3
		db 'REN'
		db 1
		dw CRENAME
		db 5
		db 'ERASE'
		db 1
		dw ERASE
		db 3
		db 'DEL'
		db 1
		dw ERASE
		db 4
		db 'TYPE'
		db 1
		dw TYPEFIL
		db 3
		db 'REM'
		db 2
		dw TCOMMAND
		db 4
		db 'COPY'
		db 3
		dw COPY
		db 5
		db 'PAUSE'
		db 2
		dw PAUSE
		db 4
		db 'DATE'
		db 2
		dw DATE
		db 4
		db 'TIME'
		db 0
		dw CTIME
		db 3
		db 'VER'
		db 0
		dw VERSION
		db 3
		db 'VOL'
		db 1
		dw VOLUME
		db 2
		db 'CD'
		db 1
		dw _$CHDIR
		db 5
		db 'CHDIR'
		db 1
		dw _$CHDIR
		db 2
		db 'MD'
		db 1
		dw _$MKDIR
		db 5
		db 'MKDIR'
		db 1
		dw _$MKDIR
		db 2
		db 'RD'
		db 1
		dw _$RMDIR
		db 5
		db 'RMDIR'
		db 1
		dw _$RMDIR
		db 5
		db 'BREAK'
		db 0
		dw CNTRLC
		db 6
		db 'VERIFY'
		db 0
		dw VERIFY
		db 3
		db 'SET'
		db 2
		dw ADD_NAME_TO_ENVIRONMENT
		db 6
		db 'PROMPT'
		db 2
		dw ADD_PROMPT
		db 4
		db 'PATH'
		db 2
		dw PATH
		db 4
		db 'EXIT'
		db 0
		dw _$EXIT
		db 4
		db 'CTTY'
		db 3
		dw CTTY
		db 4
		db 'ECHO'
		db 2
		dw ECHO
		db 4
		db 'GOTO'
		db 2
		dw GOTO
		db 5
		db 'SHIFT'
		db 2
		dw SHIFT
		db 2
		db 'IF'
		db 2
		dw _$IF
		db 3
		db 'FOR'
		db 2
		dw _$FOR
		db 3
		db 'CLS'
		db 0
		dw CLS
		db 0

CAPITAL_A:	db 'A'
VBAR:		db '|'
LABRACKET:	db '<' ; 3Ch
RABRACKET:	db '>' ; 3Eh
DOLLAR:		db '$'
LPAREN:		db '('
RPAREN:		db ')'
NULLRPAREN:	db ')' ; 29h
		db 0
IN_WORD:	db 'I','N'
DO_WORD	:	db 'D','O'
STAR:		db '*'
CHAR_SUB:	db '-' 
PLUS_CHR:	db '+'
CHAR_L:		db 'L'
char_l:		db 'l'
small_a:	db 'a'
small_z:	db 'z'
CHAR_D:		db 'D'
CHAR_C:		db 'C'
CHAR_S:		db 'S'
CHAR_X:		db 'X'
DOT_CHR:	db '.' 
DOT_QMARK:	dw '?.'  ; dw 2E3Fh
		db ','
TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
MNCHR:		db 'p'
SYSTEM_CPAGE:	db 0
		db 0

COMEXT:		db '.COM'
EXEEXT:		db '.EXE'
BATEXT:		db '.BAT'
SWITCH_LIST:	db 'VBAPW'
BATBUFLEN:	dw BATLEN ; 32

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h

TRANDATAEND:

;============================================================================
; TSPC.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/09/2018 - Retro DOS v3.0

;TITLE	COMMAND Transient Uninitialized DATA

;The TRANSPACE segment contains variable data that is considered
;volatile between command cycles, and therefore is not included in the
;transient checksum area. Contents of these variables MUST be
;initialized before use, and must not be relied upon from command
;cycle to command cycle.
;
;No constant data values should be stored here.

; ---------------------------------------------------------------------------
; START OF UNITIALIZED DATA
; ---------------------------------------------------------------------------	

;	times 12 db 0

align 16

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h

PRINTF_LEFT:	db 0
PRINTF_LONG:	db 0
PRINTF_HEX:	db 0
TABLE_INDEX:	db 0
PRINTF_WIDTH:	dw 0
PRINTF_BASE:	dw 0
PAD_CHAR:	db 0
PRINTF_HANDLE:	dw 0
PRINTF_BUF: times 100 db 0
PRINTF_BUF_END: ; 30/09/2018

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh

SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection

; Variables passed up from resident	; in the Resident portion: (initial values)	
HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
TPA:		dw 0			; LTPA	    (dw 0)	
SWITCHAR:	db 0			; RSWITCHAR (db '-')
DIRCHAR:	db 0			; RDIRCHAR  (db '/')
EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
					; MYSEG1    (dw 0)	
RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
					; MYSEG2    (dw 0)	
		dw 0			; RESTEST   (dw 0)	
TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	

CHKDRV:		db 0
IFNOTFLAG:
FILTYP:
RDEOF:		db 0			; Misc flags
CURDRV:		db 0
PARM1:
CONCAT:		db 0
PARM2:
ARGC:		db 0
COMSW:		dw 0			; Switches between command and 1st arg
ARG1S:		dw 0			; Switches between 1st and 2nd arg
ARG2S:					; Switches after 2nd arg		
DESTSWITCH:	dw 0
ARGTS:
ALLSWITCH:	dw 0			; ALL switches except for COMSW
CFLAG:		db 0
DESTCLOSED:
SPECDRV:	db 0
BYTCNT:		dw 0			; Size of buffer between RES and TRANS
NXTADD:		dw 0
FRSTSRCH:	db 0
;LeftOnLine:	db 0			; entries left on line u.b. DIR
;PerLine:	db 0			; entries/line u.b. DIR
LINCNT:		db 0
LINLEN:		db 0
;LeftOnPage:	dw 0			; lines left on page u.b. DIR
FILECNT:	dw 0			; file count u.b. DIR
;FileSiz:	dd 0			; file size u.b. DIR

;		Note:  keep FileCntTotal through csecUsedTotal together!
;
;FileCntTotal:	dd 0			; total file count u.b. DIR
;FileSizTotal:	dd 0			; total file size u.b. DIR

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh

CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
DESTFCB2:
IDLEN:		db 0
ID:	  times	8  db 0
COM:	  times	3  db 0 
DEST:	  times 37 db 0
DESTNAME: times 11 db 0
DESTDIR:
DESTFCB:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
GOTOLEN:	; word
BWDBUF: 	; byte
EXEFCB: 	; word
DIRBUF:	times DIRSTRLEN+3 db 0 ; 70

DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
DIRBUF_FTIME   equ DIRBUF+30  ; word
DIRBUF_FDATE   equ DIRBUF+32  ; word	
DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
DIRBUF_FSIZ_H  equ DIRBUF+38  ; word

SDIRBUF:  times 12 db 0	
_BITS:		dw 0
PATHCNT:	dw 0
PATHPOS:	dw 0
PATHSW:		dw 0
;AttrSpecified:	db 0			; attribute bits u.b. DIR
;AttrSelect:	db 0			; attribute bits u.b. DIR
LINPERPAG:	db 0
		db 0
COMMA:		db 0			; flag set if +,, occurs
PLUS_COMMA:	db 0			; flag set if +,, occurs

;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
;parse_last:	dw 0			;AN018; used to hold parsing position
;system_cpage:	dw 0			;AC001; used for CHCP variable

ARG_BUF:  times 128 db 0   ; _43E8h	
STRING_PTR_1:	dw 0	   ; _4468h	
FILESIZE_L:	dw 0	   ; _446Ah		
FILESIZE_H:	dw 0	   ; _446Ch	
STRING_PTR_2:	dw 0	   ; _446Eh	

COPY_NUM:	dw 0
	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
CPYFLAG:	db 0
DIR_NUM:	dw 0
BYTES_FREE:	dw 0
		dw 0
MAJOR_VER_NUM:	dw 0
MINOR_VER_NUM:	dw 0
ONE_CHAR_VAL:	db 0
		;db 0
VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
VOL_DRV:	db 0
VOL_DIR:	dw 0 ; MSDOS 3.3

ROM_CALL:	db 0			; flag for rom function
ROM_IP:		dw 0
ROM_CS:		dw 0

DESTVARS:
DESTISDIR:	db 0
DESTSIZ:	db 0
DESTTAIL:	dw 0
DESTINFO:	db 0
DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
ENDDESTBUF:

DESTHAND:	dw 0
DESTISDEV:	db 0
FIRSTDEST:	db 0
MELCOPY:	db 0
MELSTART:	dw 0

SRCVARS:
SRCISDIR:	db 0
SRCSIZ:		db 0
SRCTAIL:	dw 0
SRCINFO:	db 0
SRCBUF:   times	DIRSTRLEN+20 db 0 ; 87

SRCHAND:	dw 0
SRCISDEV:	db 0

SCANBUF:  times DIRSTRLEN+20 db 0 ; 87

SRCPT:		dw 0
INEXACT:	db 0
		db 0 ; MSDOS 3.3 
NOWRITE:	db 0
BINARY:		db 0
WRITTEN:	dw 0
TERMREAD:	db 0
ASCII:		db 0
PLUS:		db 0
OBJCNT:		db 0			; Used in copy
CPDATE:		dw 0
CPTIME:		dw 0

;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
;OFilePtr_Hi:	dw 0			; 1st source is also destination
;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto

BATHAND:	dw 0			; Batch handle
STARTEL:	dw 0
ELCNT:		db 0
ELPOS:		db 0
SOURCE:   times	11 db 0

ext_entered:	db 0			;AN005;

;display_ioctl	db 0			;AN000; info level
;		db 0			;AN000; reserved
;		dw crt_ioctl_ln		;AN000; length of data
;		dw 0			;AN000; control flags
;display_mode:	db 0			;AN000; display mode, colors
;		db 0			;AN000; reserved
;		dw 0			;AN023; colors
;		dw 0			;AN000; display width (PELS)
;		dw 0			;AN000; display length (PELS)
;display_width:	dw 0			;AN000; display width
;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
;
;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
;		dw 0			;AN000; info level
;vol_serial:	dd 0			;AN000; volume serial number
;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
;	    times 8  db 20h ; " "       ;AN000; file system type

EXPAND_STAR:	db 0

;msg_flag:	db 0			;AN022; flag set if non-utility message issued
;msg_numb:	dw 0			;AN022; set with extended error message issued
;append_exec:	db 0			;AN041; set if internal append executed
;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
;subst_buffer: times parm_block_size*2 db 0 ;AN061;

COMSPEC_FLAG:	db 0 ; MSDOS 3.3

; Data declarations taken out of parse.asm

; MSDOS 6.0
;arg	arg_unit	<>		; pointers, arg count, string buffer
;argbufptr	dw	?		; index for argv[].argpointer
;tpbuf		db	128   DUP (?)	; temporary buffer
;LAST_ARG	dw	?		; point at which to accumulate switch info
;comptr		dw	?		; ptr into combuf

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
ARG:
ARG_ARGV:
ARGV0_ARGPOINTER: dw 0	; ARGV[0]
ARGV0_ARG_FLAGS:  db 0
ARGV0_ARGSTARTEL: dw 0
ARGV0_ARGLEN:	  dw 0
ARGV0_ARGSW_WORD: dw 0
ARGV0_OCOMPTR:	  dw 0

ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
	  times 5 db 0
ARGV1_ARGSW_WORD: dw 0
		  dw 0

ARGV2_ARGPOINTER: dw 0	; ARGV[2]
	  times 5 db 0
ARGV2_ARGSW_WORD: dw 0
		  dw 0

	times 671 db 0  ; ARGV[3] to ARGV[63]
	
ARG_ARGVCNT:	dw 0
ARG_ARGSWINFO:	dw 0

ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh

ARGBUFPTR:	dw 0			; index for argv[].argpointer
TPBUF:    times 128 db 0		; temporary buffer
LASTARG:	dw 0			; point at which to accumulate switch info
COMPTR:		dw 0			; ptr into combuf

; Data declarations taken out of path.asm
;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
;psep_char	DB	?			; '/' or '\'
;search_best	DB	(?)			; best code, best filename so far
;fname_max_len	equ	13
;search_best_buf DB	fname_max_len DUP (?)
;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
;search_error	DW	(?)			; address of error message to be printed

FINDBUFLEN equ FIND_BUF.size ; 43

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h

FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
PATHINFO:
PATHINFO_0:	dw 0
PATHINFO_2:	dw 0
PATHINFO_4:	dw 0
PSEP_CHAR:	db 0
SEARCH_BEST:	db 0
;FNAME_MAX_LEN equ 13
SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
SEARCH_CURDIR_BUF: times 64 db 0
SEARCH_ERROR:	dw 0

; Data declarations taken out of tbatch.asm

;if_not_count	DW	?
;
;zflag		db	?		; Used by typefil to indicate ^Z's
;
;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
;STACK		LABEL	WORD

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h

IF_NOT_COUNT:	dw 0
ZFLAG:		db 0
	  times 256 db 0 	
STACK:

;INTERNATVARS	internat_block <>
;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
;
;;		Buffer for DOS function 64h (Get extended country information)
;;		subfunctions 2, 4, 6, or 7:
;
;CountryPtrInfo	label	byte
;CountryPtrId	db	?
;CountryPtr	dd	?
;		.erre	(($ - CountryPtrInfo) GE 5)

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h

INTERNATVARS:	
DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
DATE_SEP:	db 0,0			; Date separator 2 bytes
TIME_SEP:	db 0,0			; Time separator 2 bytes	
BIT_FIELD:	db 0			; Bit values
					;   Bit 0 = 0 if currency symbol first
					;	  = 1 if currency symbol last
					;   Bit 1 = 0 if No space after currency symbol
					;	  = 1 if space after currency symbol
CURRENCY_CENTS:	db 0			; Number of places after currency dec point
TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
					;  in pieces.
DATA_SEP:	db 0,0			; Data list separator character		

		times 8 db 0
;
; Max size of the block returned by the INTERNATIONAL call
;
INTERNAT_BLOCK_SIZE EQU	32

BATLEN equ 32
	
		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		

BATBUFPOS:	dw 0			; integer position in buffer of next byte

BATBUF:	  times	BATLEN db 0 ; times 32 db 0

BATBUFEND:	dw 0

;TypeFilSiz:	dd 0			; stores size of file to be typed

TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion