     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 02/03/2023 ((Previous: 20/10/2018))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11 
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  
    43                                  ;============================================================================
    44                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    45                                  ;============================================================================
    46                                  ; 21/09/2018 - Retro DOS v3.0
    47                                  
    48                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    49                                  ;BREAK <system call definitions>
    50                                  
    51                                  ;
    52                                  ;	Microsoft Confidential
    53                                  ;	Copyright (C) Microsoft Corporation 1991
    54                                  ;	All Rights Reserved.
    55                                  ;
    56                                  
    57                                  ;SUBTTL	system call definitions
    58                                  ;PAGE
    59                                  
    60                                  Abort				EQU 0	;  0	  0
    61                                  STD_CON_INPUT			EQU 1	;  1	  1
    62                                  Std_Con_Output			EQU 2	;  2	  2
    63                                  Std_Aux_Input			EQU 3	;  3	  3
    64                                  Std_Aux_Output			EQU 4	;  4	  4
    65                                  Std_Printer_Output		EQU 5	;  5	  5
    66                                  Raw_Con_IO			EQU 6	;  6	  6
    67                                  RAW_CON_INPUT			EQU 7	;  7	  7
    68                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    69                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    70                                  Std_Con_String_Input		EQU 10	; 10	  A
    71                                  Std_Con_Input_Status		EQU 11	; 11	  B
    72                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    73                                  DISK_RESET			EQU 13	; 13	  D
    74                                  Set_Default_Drive		EQU 14	; 14	  E
    75                                  FCB_Open			EQU 15	; 15	  F
    76                                  FCB_Close			EQU 16	; 16	 10
    77                                  Dir_Search_First		EQU 17	; 17	 11
    78                                  Dir_Search_Next 		EQU 18	; 18	 12
    79                                  FCB_Delete			EQU 19	; 19	 13
    80                                  FCB_Seq_Read			EQU 20	; 20	 14
    81                                  FCB_Seq_Write			EQU 21	; 21	 15
    82                                  FCB_Create			EQU 22	; 22	 16
    83                                  FCB_Rename			EQU 23	; 23	 17
    84                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    85                                  Set_DMA 			EQU 26	; 26	 1A
    86                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    87                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    88                                  ;									   ;
    89                                  Get_Default_DPB 		EQU 31	; 31	 1F
    90                                  ;									   ;
    91                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    92                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    93                                  FCB_Random_Read 		EQU 33	; 33	 21
    94                                  FCB_Random_Write		EQU 34	; 34	 22
    95                                  Get_FCB_File_Length		EQU 35	; 35	 23
    96                                  Get_FCB_Position		EQU 36	; 36	 24
    97                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
    98                                  Create_Process_Data_Block	EQU 38	; 38	 26
    99                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   100                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   101                                  Parse_File_Descriptor		EQU 41	; 41	 29
   102                                  Get_Date			EQU 42	; 42	 2A
   103                                  Set_Date			EQU 43	; 43	 2B
   104                                  Get_Time			EQU 44	; 44	 2C
   105                                  Set_Time			EQU 45	; 45	 2D
   106                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   107                                  ; Extended functionality group
   108                                  Get_DMA 			EQU 47	; 47	 2F
   109                                  GET_VERSION			EQU 48	; 48	 30
   110                                  Keep_Process			EQU 49	; 49	 31
   111                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;									   ;
   114                                  Get_DPB 			EQU 50	; 50	 32
   115                                  ;									   ;
   116                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   117                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   118                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   119                                  Get_InDOS_Flag			EQU 52	; 52	 34
   120                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   121                                  Get_Drive_Freespace		EQU 54	; 54	 36
   122                                  CHAR_OPER			EQU 55	; 55	 37
   123                                  International			EQU 56	; 56	 38
   124                                  ;   Directory Group
   125                                  MKDir				EQU 57	; 57	 39
   126                                  RMDir				EQU 58	; 58	 3A
   127                                  CHDir				EQU 59	; 59	 3B
   128                                  ;   File Group
   129                                  Creat				EQU 60	; 60	 3C
   130                                  OPEN				EQU 61	; 61	 3D
   131                                  CLOSE				EQU 62	; 62	 3E
   132                                  READ				EQU 63	; 63	 3F
   133                                  Write				EQU 64	; 64	 40
   134                                  Unlink				EQU 65	; 65	 41
   135                                  LSEEK				EQU 66	; 66	 42
   136                                  CHMod				EQU 67	; 67	 43
   137                                  IOCTL				EQU 68	; 68	 44
   138                                  XDUP				EQU 69	; 69	 45
   139                                  XDup2				EQU 70	; 70	 46
   140                                  Current_Dir			EQU 71	; 71	 47
   141                                  ;    Memory Group
   142                                  ALLOC				EQU 72	; 72	 48
   143                                  DEALLOC				EQU 73	; 73	 49
   144                                  SETBLOCK			EQU 74	; 74	 4A
   145                                  ;    Process Group
   146                                  Exec				EQU 75	; 75	 4B
   147                                  EXIT				EQU 76	; 76	 4C
   148                                  WAITPROCESS			EQU 77	; 77	 4D
   149                                  Find_First			EQU 78	; 78	 4E
   150                                  ;   Special Group
   151                                  Find_Next			EQU 79	; 79	 4F
   152                                  ; SPECIAL SYSTEM GROUP
   153                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   154                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   155                                  ;									   ;
   156                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   157                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   158                                  Get_In_Vars			EQU 82	; 82	 52
   159                                  SetDPB				EQU 83	; 83	 53
   160                                  ;									   ;
   161                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   162                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   163                                  Get_Verify_On_Write		EQU 84	; 84	 54
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   166                                  ;									   ;
   167                                  Dup_PDB 			EQU 85	; 85	 55
   168                                  ;									   ;
   169                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   170                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   171                                  Rename				EQU 86	; 86	 56
   172                                  File_Times			EQU 87	; 87	 57
   173                                  AllocOper			EQU 88	; 88	 58
   174                                  ; Network extention system calls
   175                                  GetExtendedError		EQU 89	; 89	 59
   176                                  CreateTempFile			EQU 90	; 90	 5A
   177                                  CreateNewFile			EQU 91	; 91	 5B
   178                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   179                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   180                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   181                                  ;									   ;
   182                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   183                                  					;	    CloseByName, CloseUser,
   184                                  					;	    CloseUserProcess,
   185                                  					;	    GetOpenFileList
   186                                  ;									   ;
   187                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   188                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   189                                  UserOper			EQU 94	; 94	 5E Get and Set
   190                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   191                                  xNameTrans			EQU 96	; 96	 60
   192                                  PathParse			EQU 97	; 97	 61
   193                                  GetCurrentPSP			EQU 98	; 98	 62
   194                                  Hongeul 			EQU 99	; 99	 63
   195                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   196                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   197                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   198                                  ;									   ;
   199                                  Set_Printer_Flag		EQU 100 ; 100	 64
   200                                  ;									   ;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   203                                  GetExtCntry			EQU 101 ; 101	 65
   204                                  GetSetCdPg			EQU 102 ; 102	 66
   205                                  ExtHandle			EQU 103 ; 103	 67
   206                                  Commit				EQU 104 ; 104	 68
   207                                  GetSetMediaID			EQU 105 ; 105	 69
   208                                  IFS_IOCTL			EQU 107 ; 107	 6B
   209                                  ExtOpen 			EQU 108 ; 108	 6C
   210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   211                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   212                                  ;                                                                          ;
   213                                  ;ifdef ROMEXEC
   214                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   215                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   216                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   217                                  ;endif
   218                                  ;                                                                          ;
   219                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   220                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   221                                  ;
   222                                  ;
   223                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   224                                  OEM_C1				EQU 249 ; 249	 F9
   225                                  OEM_C2				EQU 250 ; 250	 FA
   226                                  OEM_C3				EQU 251 ; 251	 FB
   227                                  OEM_C4				EQU 252 ; 252	 FC
   228                                  OEM_C5				EQU 253 ; 253	 FD
   229                                  OEM_C6				EQU 254 ; 254	 FE
   230                                  OEM_C7				EQU 255 ; 255	 FF
   231                                  
   232                                  ;============================================================================
   233                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   234                                  ;============================================================================
   235                                  ; 21/09/2018 - Retro DOS v3.0
   236                                  
   237                                  ;BREAK <Control character definitions>
   238                                  
   239                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   240                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   241                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   242                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   243                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   244                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   245                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   246                                  c_HT	    EQU     09h 		; ^I ASCII tab
   247                                  
   248                                  ;============================================================================
   249                                  ; DIRENT.INC, MSDOS 6.0, 1991
   250                                  ;============================================================================
   251                                  ; 21/09/2018 - Retro DOS v3.0
   252                                  
   253                                  ;Break <Directory entry>
   254                                  
   255                                  ;	NOTE:  These offsets are also used in the DTA for
   256                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   257                                  ;	with the FCB filename field, and the rest of the
   258                                  ;	DIR_ENTRY fields follow. -DavidOls
   259                                  
   260                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   261                                  ;
   262                                  ;	+---------------------------+
   263                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   264                                  ;	+---------------------------+
   265                                  ;	|     (BYTE) attributes     |	    11	    B
   266                                  ;	+---------------------------+
   267                                  ;	|    (10 BYTE) reserved     |	    12	    C
   268                                  ;	+---------------------------+
   269                                  ;	| (WORD) time of last write |	    22	    16
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) date of last write |	    24	    18
   272                                  ;	+---------------------------+
   273                                  ;	|   (WORD) First cluster    |	    26	    1A
   274                                  ;	+---------------------------+
   275                                  ;	|     (DWORD) file size     |	    28	    1C
   276                                  ;	+---------------------------+
   277                                  ;
   278                                  ;   First byte of filename  = E5 -> free directory entry
   279                                  ;			    = 00 -> end of allocated directory
   280                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   281                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   282                                  ;
   283                                  
   284                                  STRUC DIR_ENTRY
   285 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   286 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   287 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   288 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   289 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   290 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   291 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   292 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   293 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   294 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   295 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   296                                  .size:
   297                                  
   298                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   299                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   300                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   301                                  ;	    this field is zero for subdirectory files.
   302                                  
   303                                  ENDSTRUC
   304                                  
   305                                  ATTR_READ_ONLY	equ	 1h
   306                                  ATTR_HIDDEN	equ	 2h
   307                                  ATTR_SYSTEM	equ	 4h
   308                                  ATTR_VOLUME_ID	equ	 8h
   309                                  ATTR_DIRECTORY	equ	10h
   310                                  ATTR_ARCHIVE	equ	20h
   311                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   312                                  				;   NO directory entry on a disk EVER
   313                                  				;   has this bit set. It is set non-zero
   314                                  				;   when a device is found by GETPATH
   315                                  
   316                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   317                                  				; OR of hard attributes for FINDENTRY
   318                                  
   319                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   320                                  				; ignore this(ese) attribute(s) during
   321                                  				; search first/next
   322                                  
   323                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   324                                  				; changeable via CHMOD
   325                                  
   326                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   327                                  
   328                                  ;============================================================================
   329                                  ; ERROR.INC, MSDOS 6.0, 1991
   330                                  ;============================================================================
   331                                  ; 21/09/2018 - Retro DOS v3.0
   332                                  
   333                                  ;**	ERROR.INC - DOS Error Codes
   334                                  ;
   335                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   336                                  ;    return error codes through AX.	If an error occurred then
   337                                  ;    the carry bit will be set and the error code is in AX.	If no error
   338                                  ;    occurred then the carry bit is reset and AX contains returned info.
   339                                  ;
   340                                  ;    Since the set of error codes is being extended as we extend the operating
   341                                  ;    system, we have provided a means for applications to ask the system for a
   342                                  ;    recommended course of action when they receive an error.
   343                                  ;
   344                                  ;    The GetExtendedError system call returns a universal error, an error
   345                                  ;    location and a recommended course of action.	The universal error code is
   346                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   347                                  ;    is issued.
   348                                  
   349                                  
   350                                  ;	2.0 error codes
   351                                  
   352                                  error_invalid_function		EQU	1
   353                                  ERROR_FILE_NOT_FOUND		EQU	2
   354                                  error_path_not_found		EQU	3
   355                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   356                                  ERROR_ACCESS_DENIED		EQU	5
   357                                  error_invalid_handle		EQU	6
   358                                  error_arena_trashed		EQU	7
   359                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   360                                  error_invalid_block		EQU	9
   361                                  error_bad_environment		EQU	10
   362                                  ERROR_BAD_FORMAT		EQU	11
   363                                  error_invalid_access		EQU	12
   364                                  error_invalid_data		EQU	13
   365                                  ;**** reserved			EQU	14	; *****
   366                                  error_invalid_drive		EQU	15
   367                                  error_current_directory 	EQU	16
   368                                  error_not_same_device		EQU	17
   369                                  error_no_more_files		EQU	18
   370                                  
   371                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   372                                  
   373                                  ERROR_WRITE_PROTECT		EQU	19
   374                                  error_bad_unit			EQU	20
   375                                  error_not_ready 		EQU	21
   376                                  error_bad_command		EQU	22
   377                                  error_CRC			EQU	23
   378                                  error_bad_length		EQU	24
   379                                  error_Seek			EQU	25
   380                                  error_not_DOS_disk		EQU	26
   381                                  error_sector_not_found		EQU	27
   382                                  error_out_of_paper		EQU	28
   383                                  error_write_fault		EQU	29
   384                                  error_read_fault		EQU	30
   385                                  ERROR_GEN_FAILURE		EQU	31
   386                                  
   387                                  ;	the new 3.0 error codes reported through INT 24
   388                                  
   389                                  error_sharing_violation 	EQU	32
   390                                  error_lock_violation		EQU	33
   391                                  error_wrong_disk		EQU	34
   392                                  ERROR_FCB_UNAVAILABLE		EQU	35
   393                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   394                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   395                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   396                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   397                                  
   398                                  ;	New OEM network-related errors are 50-79
   399                                  
   400                                  error_not_supported		EQU	50
   401                                  
   402                                  error_net_access_denied		EQU	65	;M028
   403                                  
   404                                  ;	End of INT 24 reportable errors
   405                                  
   406                                  error_file_exists		EQU	80
   407                                  error_DUP_FCB			EQU	81	; *****
   408                                  error_cannot_make		EQU	82
   409                                  error_FAIL_I24			EQU	83
   410                                  
   411                                  ;	New 3.0 network related error codes
   412                                  
   413                                  error_out_of_structures 	EQU	84
   414                                  error_Already_assigned		EQU	85
   415                                  error_invalid_password		EQU	86
   416                                  error_invalid_parameter 	EQU	87
   417                                  error_NET_write_fault		EQU	88
   418                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   419                                  
   420                                  ;============================================================================
   421                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   422                                  ;============================================================================
   423                                  ; 22/09/2018 - Retro DOS v3.0
   424                                  
   425                                  ;**	DevSym.inc - Device Symbols
   426                                  
   427                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   428                                  
   429                                  STRUC SYSDEV
   430 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   431 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   432 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   433 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   434 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   435                                  .size:
   436                                  ENDSTRUC
   437                                  
   438                                  ; 24/09/2018
   439                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   440                                  
   441                                  ;============================================================================
   442                                  ; CURDIR.INC, MSDOS 6.0, 1991
   443                                  ;============================================================================
   444                                  ; 21/09/2018 - Retro DOS v3.0
   445                                  
   446                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   447                                  
   448                                  ;============================================================================
   449                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   450                                  ;============================================================================
   451                                  ; 21/09/2018 - Retro DOS v3.0
   452                                  
   453                                  ;/*
   454                                  ; *                      Microsoft Confidential
   455                                  ; *                      Copyright (C) Microsoft Corporation 1991
   456                                  ; *                      All Rights Reserved.
   457                                  ; */
   458                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   459                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   460                                  ;*************************************
   461                                  ; COMMAND EQUs which are not switch dependant
   462                                  
   463                                  ;		include	curdir.inc	; to get DIRSTRLEN
   464                                  ;		Note dossym.inc must already have been included!
   465                                  
   466                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   467                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   468                                  
   469                                  SYM		EQU	">"
   470                                  
   471                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   472                                  
   473                                  NORMPERLIN	EQU	1
   474                                  WIDEPERLIN	EQU	5
   475                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   476                                  BatLen		EQU	32		; buffer for batch files
   477                                  YES_ECHO	EQU	1		; echo line
   478                                  NO_ECHO 	EQU	0		; don't echo line
   479                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   480                                  call_in_progress EQU	1		; indicate we're in the CALL command
   481                                  length_call	EQU	4		; length of CALL
   482                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   483                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   484                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   485                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   486                                  nullcommand	EQU    1		; no command on command line
   487                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   488                                  end_of_line_out EQU	0		;AN000; end of line for output
   489                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   490                                  result_number	EQU	1		;AN000; number returned from parser
   491                                  result_string	EQU	3		;AN000; string returned from parser
   492                                  result_filespec EQU	5		;AN000; filespec returned from parser
   493                                  result_drive	EQU	6		;AN000; drive returned from parser
   494                                  result_date	EQU	7		;AN000; date returned from parser
   495                                  result_time	EQU	8		;AN000; time returned from parser
   496                                  result_no_error EQU	0		;AN000; no error returned from parser
   497                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   498                                  util_msg_class	EQU	-1		;AN000; message class for utility
   499                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   500                                  parse_msg_class EQU	2		;AN000; message class for parse error
   501                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   502                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   503                                  colon_char	EQU	":"             ;AN000; colon character
   504                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   505                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   506                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   507                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   508                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   509                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   510                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   511                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   512                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   513                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   514                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   515                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   516                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   517                                  parm_block_size equ	11		;AN000; size of message subst block
   518                                  blank		equ	" "             ;AN000; blank character
   519                                  no_subst	equ	0		;AN000; no substitutions for messages
   520                                  one_subst	equ	1		;AN000; one substitution for messages
   521                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   522                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   523                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   524                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   525                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   526                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   527                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   528                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   529                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   530                                  capital_A	equ	'A'             ;AC000;
   531                                  vbar		equ	'|'             ;AC000;
   532                                  labracket	equ	'<'             ;AC000;
   533                                  rabracket	equ	'>'             ;AC000;
   534                                  dollar		equ	'$'             ;AC000;
   535                                  lparen		equ	'('             ;AC000;
   536                                  rparen		equ	')'             ;AC000;
   537                                  nullrparen	equ	29h		;AC000;
   538                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   539                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   540                                  star		equ	'*'             ;AC000;
   541                                  plus_chr	equ	'+'             ;AC000;
   542                                  small_a 	equ	'a'             ;AC000;
   543                                  small_z 	equ	'z'             ;AC000;
   544                                  dot_chr 	equ	'.'             ;AC000;
   545                                  tab_chr 	equ	9		;AN032;
   546                                  equal_chr	equ	'='             ;AN032;
   547                                  semicolon	equ	';'             ;AN049;
   548                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   549                                  dot_colon	equ	2e3ah		;AC000; '.:'
   550                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   551                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   552                                  AppendInstall	equ	0B700H		;AN020; append install check
   553                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   554                                  AppendGetState	equ	0B706H		;AN020; append get current state
   555                                  AppendSetState	equ	0B707H		;AN020; append set current state
   556                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   557                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   558                                  
   559                                  ;*************************************
   560                                  ;* PARSE ERROR MESSAGES
   561                                  ;*************************************
   562                                  
   563                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   564                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   565                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   566                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   567                                  
   568                                  ;*************************************
   569                                  ;* EQUATES FOR MESSAGE RETRIEVER
   570                                  ;*************************************
   571                                  
   572                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   573                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   574                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   575                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   576                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   577                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   578                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   579                                  
   580                                  ;*********************************
   581                                  ;* EQUATES FOR INT 10H
   582                                  ;*********************************
   583                                  
   584                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   585                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   586                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   587                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   588                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   589                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   590                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   591                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   592                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   593                                  
   594                                  AltPipeChr	equ	"|"             ; alternate pipe character
   595                                  
   596                                  FCB		EQU	5CH
   597                                  
   598                                  STRUC VARSTRUC
   599 00000000 ??                      .ISDIR:		RESB	1
   600 00000001 ??                      .SIZ:		RESB	1
   601 00000002 ????                    .TTAIL:		RESW	1
   602 00000004 ??                      .INFO:		RESB	1
   603 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   604                                  .size:
   605                                  ENDSTRUC
   606                                  ;
   607                                  ; Flags for internal command parsing
   608                                  ;
   609                                  fCheckDrive	equ	00000001b	; validate drive letter
   610                                  fSwitchAllowed	equ	00000010b	; switches allowed
   611                                  fLimitHelp	equ	00000100b	; /? must appear alone
   612                                  
   613                                  ;
   614                                  ; Test switches
   615                                  ;
   616                                  fParse		EQU	0001h		; display results of parseline
   617                                  
   618                                  ;
   619                                  ; Batch segment structure
   620                                  ;
   621                                  ;   BYTE    type of segment
   622                                  ;   BYTE    echo state of parent on entry to batch file
   623                                  ;   WORD    segment of last batch file
   624                                  ;   WORD    segment for FOR command
   625                                  ;   BYTE    FOR flag state on entry to batch file
   626                                  ;   DWORD   offset for next line
   627                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   628                                  ;   ASCIZ   file name (with . and ..)
   629                                  ;   BYTES   CR-terminated parameters
   630                                  ;   BYTE    0 flag to indicate end of parameters
   631                                  ;
   632                                  
   633                                  BATCHTYPE   equ 0
   634                                  
   635                                  STRUC BATCHSEGMENT
   636 00000000 ??                      .BatType:	RESB	1		; signature
   637 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   638                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   639 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   640 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   641 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   642 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   643 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   644 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   645                                  .SIZE:
   646                                  ENDSTRUC
   647                                  
   648                                  ANULL		equ	0		; terminates an argv string
   649                                  ARGMAX		equ	64		; max args on a command line
   650                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   651                                  tplen		equ	64		; max size of one argument
   652                                  arg_cnt_error	equ	1		; number of args > MAXARG
   653                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   654                                  
   655                                  STRUC ARGV_ELE				; elements in the argv array
   656 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   657 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   658 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   659 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   660 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   661 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   662                                  .SIZE:
   663                                  ENDSTRUC
   664                                  
   665                                  STRUC ARG_UNIT
   666 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   667 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   668 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   669 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   670 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   671                                  .SIZE:
   672                                  ENDSTRUC
   673                                  
   674                                  ; Equates for initialization
   675                                  ;
   676                                  INITINIT	equ	01h		; initialization in progress
   677                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   678                                  INITCTRLC	equ	04h		; already in ^C handler
   679                                  
   680                                  ;=============================================================================
   681                                  ; PDB.INC, MSDOS 6.0, 1991
   682                                  ;=============================================================================
   683                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   684                                  
   685                                  ;**	Process data block (otherwise known as program header)
   686                                  
   687                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   688                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   689                                  ;	for use.
   690                                  
   691                                  FILPERPROC	EQU     20
   692                                  
   693                                  struc PDB	; Process_data_block
   694 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   695 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   696 00000004 ??                                      resb 1
   697 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   698 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   699 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   700 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   701 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   702 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   703 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   704 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   705 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   706 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   707 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   708 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   709 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   710 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   711 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   712 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   713 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   714 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   715                                  				;  an extended FCB
   716                                  ;endstruc 	; MSDOS 3.3
   717                                  	  	; MSDOS 6.0
   718 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   719 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   720 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   721 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   722                                  endstruc
   723                                  
   724                                  ;=============================================================================
   725                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   726                                  ;=============================================================================
   727                                  ; 24/09/2018 - Retro DOS v3.0
   728                                  
   729                                  ;major_version       equ     6       ;Major DOS version
   730                                  ;minor_version       equ     00      ;Minor DOS Version
   731                                  
   732                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   733                                  
   734                                  ; MSDOS 3.3 COMMAND.COM
   735                                  MAJOR_VERSION	EQU 3
   736                                  MINOR_VERSION	EQU 30
   737                                  
   738                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   739                                  
   740                                  ;-----------------------------------------------------------------------------
   741                                  ; 21/09/2018
   742                                  ;-----------------------------------------------------------------------------
   743                                  ; Retro DOS v3.0 NOTE:  
   744                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   745                                  ;	with minor modifications which are done by me (Erdogan Tan).
   746                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   747                                  ;	source code files (written by using MASM syntax).
   748                                  ;-----------------------------------------------------------------------------
   749                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   750                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   751                                  ;----------------------------------------------------------------------------- 	
   752                                  
   753                                  ;=============================================================================
   754                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   755                                  ;=============================================================================
   756                                  ; 21/09/2018 - Retro DOS v3.0
   757                                  
   758                                  ;	page ,132
   759                                  ;	title	COMMAND - resident code for COMMAND.COM
   760                                  ;	name	COMMAND
   761                                  
   762                                  ;/*
   763                                  ; *                      Microsoft Confidential
   764                                  ; *                      Copyright (C) Microsoft Corporation 1991
   765                                  ; *                      All Rights Reserved.
   766                                  ; */
   767                                  
   768                                  ;*****************************************************************************
   769                                  ;
   770                                  ; MODULE:	       COMMAND.COM
   771                                  ;
   772                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   773                                  ;
   774                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   775                                  ;		       parts.  First is the resident portion, which includes
   776                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   777                                  ;		       error), and 2EH (command line execute); it also has
   778                                  ;		       code to test and, if necessary, reload the transient
   779                                  ;		       portion. Following the resident is the init code, which
   780                                  ;		       is overwritten after use.  Then comes the transient
   781                                  ;		       portion, which includes all command processing (whether
   782                                  ;		       internal or external).  The transient portion loads at
   783                                  ;		       the end of physical memory, and it may be overlayed by
   784                                  ;		       programs that need as much memory as possible. When the
   785                                  ;		       resident portion of command regains control from a user
   786                                  ;		       program, a check sum is performed on the transient
   787                                  ;		       portion to see if it must be reloaded.  Thus programs
   788                                  ;		       which do not need maximum memory will save the time
   789                                  ;		       required to reload COMMAND when they terminate.
   790                                  ;
   791                                  ; ENTRY POINT:	       PROGSTART
   792                                  ;
   793                                  ; INPUT:	       command line at offset 81H
   794                                  ;
   795                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   796                                  ;		       from a secondary command processor via the EXIT
   797                                  ;		       internal command.
   798                                  ;
   799                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   800                                  ;		       hang the system.
   801                                  ;
   802                                  ; INTERNAL REFERENCES:
   803                                  ;
   804                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   805                                  ;		       (COMMAND.DOC)
   806                                  ;
   807                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   808                                  ;		       (COMMAND.DOC)
   809                                  ;
   810                                  ; EXTERNAL REFERENCES:
   811                                  ;
   812                                  ;      ROUTINES:       none
   813                                  ;
   814                                  ;      DATA AREAS:     none
   815                                  ;
   816                                  ;*****************************************************************************
   817                                  ;
   818                                  ;			      REVISION HISTORY
   819                                  ;			      ----------------
   820                                  ;
   821                                  ; DOS 1.00 to DOS 3.30
   822                                  ; --------------------------
   823                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   824                                  ;
   825                                  ; REV 1.17
   826                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   827                                  ;	       resident since the EXELOAD may have overwritten the transient.
   828                                  ;
   829                                  ; REV 1.18
   830                                  ;    05/21/82  IBM version always looks on drive A
   831                                  ;	       MSVER always looks on default drive
   832                                  ;
   833                                  ; REV 1.19
   834                                  ;    06/03/82  Drive spec now entered in command line
   835                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   836                                  ;	       (print volume label)
   837                                  ;
   838                                  ; REV 1.20
   839                                  ;    06/09/82  Prints "directory" after directories
   840                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   841                                  ;
   842                                  ; REV 1.50
   843                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   844                                  ;	       do it right.
   845                                  ;
   846                                  ; REV 1.70
   847                                  ;	       EXEC used to fork off new processes
   848                                  ;
   849                                  ; REV 1.80
   850                                  ;	       C switch for single command execution
   851                                  ;
   852                                  ; REV 1.90
   853                                  ;	       Batch uses XENIX
   854                                  ;
   855                                  ; Rev 2.00
   856                                  ;	       Lots of neato stuff
   857                                  ;	       IBM 2.00 level
   858                                  ;
   859                                  ; Rev 2.01
   860                                  ;	       'D' switch for date time suppression
   861                                  ;
   862                                  ; Rev 2.02
   863                                  ;	       Default userpath is NUL rather than BIN
   864                                  ;		       same as IBM
   865                                  ;	       COMMAND split into pieces
   866                                  ;
   867                                  ; Rev 2.10
   868                                  ;	       INTERNATIONAL SUPPORT
   869                                  ;
   870                                  ; Rev 2.50
   871                                  ;	       all the 2.x new stuff -MU
   872                                  ;
   873                                  ; Rev 3.30     (Ellen G)
   874                                  ;	       CALL internal command (TBATCH2.ASM)
   875                                  ;	       CHCP internal command (TCMD2B.ASM)
   876                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   877                                  ;	       @ sign suppression of batch file line
   878                                  ;	       Replaceable environment value support in batch files
   879                                  ;	       INT 2FH calls for APPEND
   880                                  ;	       Lots of PTR fixes!
   881                                  ;
   882                                  ; Beyond 3.30 to forever  (Ellen G)
   883                                  ; ----------------------
   884                                  ;
   885                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   886                                  ;			Use Message Retriever services
   887                                  ;			/MSG switch for resident extended error msg
   888                                  ;			Convert to new capitalization support
   889                                  ;			Better error recovery on CHCP command
   890                                  ;			Code page file tag support
   891                                  ;			TRUENAME internal command
   892                                  ;			Extended screen line support
   893                                  ;			/P switch on DEL/ERASE command
   894                                  ;			Improved file redirection error recovery
   895                                  ;	(removed)	Improved batch file performance
   896                                  ;			Unconditional DBCS support
   897                                  ;			Volume serial number support
   898                                  ;	(removed)	COMMENT=?? support
   899                                  ;
   900                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   901                                  ;
   902                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   903                                  ;			require delimiters.
   904                                  ;
   905                                  ; A003	PTM P5,P9,P111	Included in A000 development
   906                                  ;
   907                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   908                                  ;			executing
   909                                  ;
   910                                  ; A005	DCR D17 	If user specifies an extension on the command
   911                                  ;			line search for that extension only.
   912                                  ;
   913                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   914                                  ;			exists"
   915                                  ;
   916                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   917                                  ;
   918                                  ; A008	PTM P182	Change COPY to set default if invalid function
   919                                  ;			returned from code page call.
   920                                  ;
   921                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   922                                  ;
   923                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   924                                  ;			transient COMMAND.
   925                                  ;
   926                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   927                                  ;			before appending to a file.
   928                                  ;
   929                                  ; A012	PTM P189	Fix redirection error recovery.
   930                                  ;
   931                                  ; A013	PTM P330	Change date format
   932                                  ;
   933                                  ; A014	PTM P455	Fix echo parsing
   934                                  ;
   935                                  ; A015	PTM P517	Fix DIR problem with * vs *.
   936                                  ;
   937                                  ; A016	PTM P354	Fix extended error message addressing
   938                                  ;
   939                                  ; A017	PTM P448	Fix appending to 0 length files
   940                                  ;
   941                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
   942                                  ;			the parser fails on. Fail on duplicate switches.
   943                                  ;
   944                                  ; A019	PTM P542	Fix device name to be printed correctly during
   945                                  ;			critical error
   946                                  ;
   947                                  ; A020	DCR D43 	Set append state off while in DIR
   948                                  ;
   949                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
   950                                  ;
   951                                  ; A022	DCR D209	Enhanced error recovery
   952                                  ;
   953                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
   954                                  ;
   955                                  ; A024	PTM P899	Fix EXTOPEN open modes.
   956                                  ;
   957                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
   958                                  ;
   959                                  ; A026	DCR D191	Change redirection error recovery support.
   960                                  ;
   961                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
   962                                  ;			with a carriage return.
   963                                  ;
   964                                  ; A028	PTM P1076	Print a blank line before printing invalid
   965                                  ;			date and invalid time messages.
   966                                  ;
   967                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
   968                                  ;			and TIME.
   969                                  ;
   970                                  ; A030	DCR D201	New extended attribute format.
   971                                  ;
   972                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
   973                                  ;
   974                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
   975                                  ;
   976                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
   977                                  ;
   978                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
   979                                  ;
   980                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
   981                                  ;			do a read to determine eof.
   982                                  ;
   983                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
   984                                  ;			so that ASSIGN works correctly.
   985                                  ;
   986                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
   987                                  ;
   988                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
   989                                  ;
   990                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
   991                                  ;
   992                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
   993                                  ;			specified.
   994                                  ;
   995                                  ; A041	PTM P1705	Close redirected files after internal APPEND
   996                                  ;			executes.
   997                                  ;
   998                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
   999                                  ;			files causing loss of batch file.
  1000                                  ;
  1001                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1002                                  ;			CALL'ed batch files.
  1003                                  ;
  1004                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1005                                  ;			as an end of line character
  1006                                  ;
  1007                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1008                                  ;			and extended message pointers when we EXIT if
  1009                                  ;			COMMAND /P is the top level process.
  1010                                  ;
  1011                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1012                                  ;			"File not found - fn"
  1013                                  ;
  1014                                  ; A047	PTM P2819	Fix transient reload prompt message
  1015                                  ;
  1016                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1017                                  ;			when DBCS code was added.
  1018                                  ;
  1019                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1020                                  ;			on line.
  1021                                  ;
  1022                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1023                                  ;
  1024                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1025                                  ;
  1026                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1027                                  ;
  1028                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1029                                  ;
  1030                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1031                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1032                                  ;
  1033                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1034                                  ;			problems with breaking out of INT 24h
  1035                                  ;
  1036                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1037                                  ;
  1038                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1039                                  ;			before the "string".  EX: COMMAND /CDIR
  1040                                  ;
  1041                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1042                                  ;			DBCS switch.
  1043                                  ;
  1044                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1045                                  ;			the time.
  1046                                  ;
  1047                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1048                                  ;			messages to be disk based.  Only keep them if /MSG
  1049                                  ;			is used.
  1050                                  ;
  1051                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1052                                  ;			out of internal commands, due to substitution blocks
  1053                                  ;			not being reset.
  1054                                  ;
  1055                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1056                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1057                                  ;			secondary copy of environment.	Change default slash in
  1058                                  ;			default comspec string to backslash.
  1059                                  ;
  1060                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1061                                  ;			text for critical error messages.
  1062                                  ;
  1063                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1064                                  ;	5/20/88 	with Microsoft product already shipped.
  1065                                  ;
  1066                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1067                                  ;	 5/20/88	with Microsoft product already shipped.
  1068                                  ;
  1069                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1070                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1071                                  ;			header and space remaining.
  1072                                  ;
  1073                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1074                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1075                                  ;			environment was putting a "Z block" marker in the old
  1076                                  ;			environment.  The fix is to move to the old environment
  1077                                  ;			to the new environment before doing the SETBLOCK.
  1078                                  ;
  1079                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1080                                  ;        09/19/88       because the check for APPEND needed to be performed
  1081                                  ;                       before the DIR's findfirst.
  1082                                  ;
  1083                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1084                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1085                                  ;                       loading trans w/new comspec with no user change comspec.
  1086                                  ;
  1087                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1088                                  ;        11/05/88       Expansion of environment variables into batch line of
  1089                                  ;                       128 chars was not being counted and "%" which should be
  1090                                  ;                       ignored were being counted.
  1091                                  ;
  1092                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1093                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1094                                  ;                       ing included in checksum and was being overwritten by
  1095                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1096                                  ;                       Also removed fix A069 (because flag now protected).
  1097                                  ;
  1098                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1099                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1100                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1101                                  ;
  1102                                  ;***********************************************************************************
  1103                                  
  1104                                  ;
  1105                                  ;	Revision History
  1106                                  ;	================
  1107                                  ;
  1108                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1109                                  ;					at init time (date/time prompt)
  1110                                  ;
  1111                                  
  1112                                  ;
  1113                                  ;.xcref
  1114                                  ;.xlist
  1115                                  ;	include dossym.inc		; basic DOS symbol set
  1116                                  ;	include syscall.inc		; DOS function names
  1117                                  ;	include comsw.asm		; build version info
  1118                                  ;	include comequ.asm		; common command.com symbols
  1119                                  ;	include resmsg.equ		; resident message names
  1120                                  ;
  1121                                  ;	include comseg.asm		;segment ordering
  1122                                  ;.list
  1123                                  ;.cref
  1124                                  
  1125                                  ;CODERES segment public byte
  1126                                  ;CODERES ends
  1127                                  ;
  1128                                  ;DATARES 	segment public byte
  1129                                  ;		extrn	AccDen:byte
  1130                                  ;		extrn	Batch:word
  1131                                  ;		extrn	EchoFlag:byte
  1132                                  ;		extrn	ExeBad:byte
  1133                                  ;		extrn	ExecEMes:byte
  1134                                  ;		extrn	ExecErrSubst:byte
  1135                                  ;		extrn	ExtCom:byte
  1136                                  ;		extrn	ForFlag:byte
  1137                                  ;		extrn	IfFlag:byte
  1138                                  ;		extrn	InitFlag:BYTE
  1139                                  ;		extrn	Nest:word
  1140                                  ;		extrn	PipeFlag:byte
  1141                                  ;		extrn	RBadNam:byte
  1142                                  ;		extrn	RetCode:word
  1143                                  ;		extrn	SingleCom:word
  1144                                  ;		extrn	TooBig:byte
  1145                                  ;
  1146                                  ;		extrn	OldDS:word
  1147                                  ;
  1148                                  ;DATARES 	ends
  1149                                  ;
  1150                                  ;
  1151                                  ;INIT		segment public para
  1152                                  ;		extrn	ConProc:near
  1153                                  ;		extrn	Init_Contc_SpecialCase:near
  1154                                  ;INIT		ends
  1155                                  
  1156                                  ; ----------------------------------------------------------------------------
  1157                                  ; START OF RESIDENT PORTION
  1158                                  ; ----------------------------------------------------------------------------
  1159                                  ; SEGMENT - CODERES
  1160                                  ; ----------------------------------------------------------------------------
  1161                                  
  1162                                  	;[ORG	0]
  1163                                  
  1164                                  ;ZERO	EQU	$
  1165                                  
  1166                                  	[ORG 100H]
  1167                                  
  1168                                  	; 21/09/2018 - Retro DOS v3.0
  1169                                  StartCode:
  1170 00000000 E9DD0C                  	jmp	CONPROC
  1171                                  
  1172                                  ;***	EXEC error handling
  1173                                  ;
  1174                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  1175                                  ;	We examine the error code and select an appropriate message.
  1176                                  
  1177                                  ;	Bugbug:	optimize reg usage in following code?  Careful of DX!
  1178                                  ;	Condense the error scan?
  1179                                  ;	RBADNAM is checked by transient, no need here?
  1180                                  ;	Move below Ext_Exec.
  1181                                  
  1182                                  EXEC_ERR:
  1183 00000003 BA[D609]                	mov     dx,ACCDEN
  1184 00000006 83F805                  	cmp     ax,ERROR_ACCESS_DENIED	; 5
  1185 00000009 741B                    	jz      short GOTEXECEMES	; access denied
  1186 0000000B BA[BB09]                	mov     dx,RBADNAM
  1187 0000000E 83F802                  	cmp     ax,ERROR_FILE_NOT_FOUND ; 2
  1188 00000011 7413                    	jz      short GOTEXECEMES	; file not found
  1189 00000013 BA[8109]                	mov     dx,TOOBIG
  1190 00000016 83F808                  	cmp     ax,ERROR_NOT_ENOUGH_MEMORY ; 8
  1191 00000019 740B                    	jz      short GOTEXECEMES
  1192 0000001B BA[6D09]                	mov     dx,EXEBAD
  1193 0000001E 83F80B                  	cmp     ax,ERROR_BAD_FORMAT	; 0Bh
  1194 00000021 7403                    	jz      short GOTEXECEMES	; bad exe file
  1195                                  DEFAULT_MESSAGE:
  1196 00000023 BA[5E09]                	mov     dx,EXECEMES
  1197                                  GOTEXECEMES:
  1198 00000026 0E                      	push    cs
  1199 00000027 1F                      	pop     ds
  1200 00000028 E86506                  	call    RDISPMSG
  1201 0000002B EB0C                    	jmp     short NOEXEC
  1202                                  
  1203                                  ;***	EXEC call
  1204                                  ;
  1205                                  ;	The transient has set up everything for an EXEC system call.
  1206                                  ;	For cleanliness, we issue the EXEC here in the resident 
  1207                                  ;	so that we may be able to recover cleanly upon success.
  1208                                  ;
  1209                                  ;	CS,DS,ES,SS = DATARES seg addr
  1210                                  
  1211                                  EXT_EXEC:
  1212                                  ;SR;
  1213                                  ; The words put on the stack by the stub will be popped off when we finally
  1214                                  ;jump to LodCom (by LodCom).
  1215                                  ;
  1216 0000002D CD21                    	int	21h			; do the exec
  1217                                  EXEC_RET:
  1218 0000002F 72D2                    	jc	short EXEC_ERR		; exec failed
  1219                                  
  1220                                  ;	The exec has completed. Retrieve the exit code.
  1221                                  
  1222                                  EXEC_WAIT:
  1223 00000031 B44D                    	mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  1224 00000033 CD21                    	int	21h			; get the return code
  1225 00000035 2EA3[E60A]              	mov     [cs:RETCODE],ax
  1226                                  
  1227                                  ;	See if we can reload the transient. The external command
  1228                                  ;	may have overwritten part of the transient.
  1229                                  
  1230                                  NOEXEC:
  1231                                  ;SR;
  1232                                  ; ds = es = ss = DATARES when we jump to LodCom
  1233                                  ;
  1234 00000039 E97101                  	jmp	LODCOM
  1235                                  
  1236                                  ;***	Int 23 (ctrl-c) handler
  1237                                  ;
  1238                                  ;	This is the default system INT 23 handler.  All processes
  1239                                  ;	(including COMMAND) get it by default.  There are some
  1240                                  ;	games that are played:  We ignore ^C during most of the
  1241                                  ;	INIT code.  This is because we may perform an ALLOC and
  1242                                  ;	diddle the header!  Also, if we are prompting for date/time
  1243                                  ;	in the init code, we are to treat ^C as empty responses.
  1244                                  
  1245                                  ;	Bugbug:	put init ctrl-c handling in init module.
  1246                                  
  1247                                  ;SR;
  1248                                  ; The stub has pushed the previous ds and DATARES onto the stack. We get
  1249                                  ;both these values off the stack now
  1250                                  ;
  1251                                  ;ContC	proc	far
  1252                                  
  1253                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  1254                                  
  1255                                  CONTC:
  1256                                  
  1257                                  ;	pop	ds			;ds = DATARES
  1258                                  ;	assume	ds:DATARES
  1259                                  ;;	pop	word [OldDS]		;OldDS = old ds
  1260                                  
  1261 0000003C 2EF606[550B]01          	test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  1262 00000042 740C                    	jz	short NOTATINIT			; no
  1263 00000044 2EF606[550B]02          	test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  1264 0000004A 7403                    	jz	short CMDIRET			; no, ignore ^C
  1265                                  	;pop	ds			; restore before jumping; M021
  1266 0000004C E98312                  	jmp	INIT_CONTC_SPECIALCASE	; Yes, go handle it
  1267                                  CMDIRET:
  1268                                  ;SR;
  1269                                  ; Restore ds to its previous value
  1270                                  ;
  1271                                  
  1272                                  ;;	mov	ds,[OLdDS]		;
  1273                                  ;	pop	ds
  1274 0000004F CF                      	iret				; yes, ignore the ^C
  1275                                  
  1276                                  NOTATINIT:
  1277 00000050 2EF606[550B]04          	test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  1278 00000056 7411                    	jz	short NOTINIT		; nope too.
  1279                                  
  1280                                  ;*	We are interrupting ourselves in this ^C handler. We need
  1281                                  ;	to set carry and return to the user sans flags only if the
  1282                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  1283                                  
  1284 00000058 80FC01                  	cmp	ah,1
  1285 0000005B 72F2                    	jb	short CMDIRET
  1286 0000005D 80FC0C                  	cmp	ah,12
  1287 00000060 77ED                    	ja	short CMDIRET
  1288                                  
  1289                                  ;	pop	ds			;restore ds to old value
  1290 00000062 83C406                  	add	sp,6			; remove int frame
  1291 00000065 F9                      	stc
  1292                                  
  1293                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  1294 00000066 CA0200                  	retf	2			; remove those flags...
  1295                                  
  1296                                  NOTINIT:
  1297                                  
  1298                                  ;*	We have now received a ^C for some process (maybe ourselves
  1299                                  ;	but not at INIT).
  1300                                  ;	
  1301                                  ;	Note that we are running on the user's stack!!! Bad news if
  1302                                  ;	any of the system calls below go and issue another INT
  1303                                  ;	24... Massive stack overflow! Another bad point is that
  1304                                  ;	SavHand will save an already saved handle, thus losing a
  1305                                  ;	possible redirection...
  1306                                  ;	
  1307                                  ;	All we need to do is set the flag to indicate nested ^C. 
  1308                                  ;	The above code will correctly flag the ^C diring the
  1309                                  ;	message output and prompting while ignoring the ^C the rest
  1310                                  ;	of the time.
  1311                                  ;	
  1312                                  ;	Clean up: flush disk. If we are in the middle of a batch
  1313                                  ;	file, we ask if he wants to terminate it. If he does, then
  1314                                  ;	we turn off all internal flags and let the DOS abort.
  1315                                  
  1316 00000069 2E800E[550B]04          	or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  1317 0000006F FB                      	sti
  1318                                  
  1319 00000070 0E                      	push	cs			; el yucko!  change the user's ds!!
  1320 00000071 1F                      	pop	ds
  1321                                  ;	assume	ds:RESGROUP
  1322                                  
  1323                                  	;pop	ax			;discard the old ds value
  1324                                  
  1325 00000072 A1[EF0A]                	mov	ax,[SINGLECOM]
  1326 00000075 09C0                    	or	ax,ax
  1327 00000077 7506                    	jnz	short NORESET
  1328 00000079 50                      	push	ax
  1329 0000007A B40D                    	mov	ah,DISK_RESET ; 0Dh
  1330 0000007C CD21                    	int	21h			; reset disks in case files were open
  1331 0000007E 58                      	pop	ax
  1332                                  
  1333                                  NORESET:
  1334                                  
  1335                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  1336                                  ;	walk the entire active list and free each segment. Here,
  1337                                  ;	we just free the single batch segment.
  1338                                  
  1339 0000007F F706[930A]FFFF          	test	word [BATCH],-1
  1340 00000085 744B                    	jz	short CONTCTERM
  1341 00000087 09C0                    	or	ax,ax
  1342 00000089 7547                    	jnz	short CONTCTERM
  1343 0000008B E85902                  	call	SAVHAND
  1344 0000008E E89E03                  	call	ASKEND			; ask if user wants to end batch
  1345                                  
  1346                                  ;	If the carry flag is clear, we do NOT free up the batch file
  1347                                  
  1348 00000091 7339                    	jnc	short CONTBATCH
  1349                                  	;mov	cl,[EchoFlag]		; get current echo flag
  1350 00000093 53                      	push	bx
  1351                                  
  1352                                  CLEARBATCH:
  1353 00000094 8E06[930A]              	mov	es,[BATCH]		; get batch segment
  1354                                  	;mov	di,[BatFile]		; get offset of batch file name
  1355                                  	; MSDOS 3.3 ([ES:4])
  1356 00000098 268B1E0400              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  1357                                  	;
  1358 0000009D 83FB00                  	cmp	bx,0			; is a FOR in progress
  1359 000000A0 7408                    	je	short NOT_BAT_FOR	; no - don't deallocate
  1360 000000A2 06                      	push	es			;
  1361 000000A3 8EC3                    	mov	es,bx			; yes - free it up...
  1362 000000A5 B449                    	mov	ah,DEALLOC ; 49h	;
  1363 000000A7 CD21                    	int	21h			;
  1364 000000A9 07                      	pop	es			; restore to batch segment
  1365                                  
  1366                                  NOT_BAT_FOR:
  1367 000000AA 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  1368 000000AF 268B1E0200              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  1369 000000B4 B449                    	mov	ah,DEALLOC ; 49h	; free it up...
  1370 000000B6 CD21                    	int	21h
  1371 000000B8 891E[930A]              	mov	[BATCH],bx		; get ready to deallocate next batch
  1372 000000BC FF0E[F80A]              	dec	WORD [NEST]		; is there another batch file?
  1373 000000C0 75D2                    	jnz	short CLEARBATCH	; keep going until no batch file
  1374                                  
  1375                                  ;	We are terminating a batch file; restore the echo status
  1376                                  
  1377                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  1378 000000C2 5B                      	pop	bx
  1379 000000C3 880E[E90A]              	mov	[ECHOFLAG],cl		; reset echo status
  1380                                  	; 29/05/2018
  1381 000000C7 C606[560B]00            	mov	byte [PIPEFLAG],0	; turn off pipeflag
  1382                                  
  1383                                  CONTBATCH:
  1384 000000CC E8BE05                  	call	CRLF			; print out crlf before returning
  1385 000000CF E83A02                  	call	RESTHAND
  1386                                  
  1387                                  ;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.
  1388                                  
  1389                                  CONTCTERM:
  1390 000000D2 31C0                    	xor	ax,ax			; indicate no read
  1391 000000D4 89C5                    	mov	bp,ax
  1392                                  
  1393                                  ;	The following resetting of the state flags is good for the
  1394                                  ;	generalized batch processing.
  1395                                  
  1396 000000D6 A2[F40A]                	mov	[IFFLAG],al		; turn off iffing
  1397 000000D9 A2[F50A]                	mov	[FORFLAG],al		; turn off for processing
  1398 000000DC E81C00                  	call	RESPIPEOFF
  1399 000000DF 3906[EF0A]              	cmp	[SINGLECOM],ax		; see if we need to set singlecom
  1400 000000E3 7406                    	jz	short NOSETSING
  1401 000000E5 C706[EF0A]FFFF          	mov	word [SINGLECOM],-1	; cause termination on 
  1402                                  					;  pipe, batch, for
  1403                                  NOSETSING:
  1404                                  
  1405                                  ;	If we are doing an internal command, go through the reload process.
  1406                                  ;	If we are doing an external, let DOS abort the process.
  1407                                  ;	In both cases, we are now done with the ^C processing.
  1408                                  
  1409 000000EB 8026[550B]FB            	and	byte [INITFLAG],~INITCTRLC ; 0FBh
  1410 000000F0 3806[E50A]              	cmp	[EXTCOM],al
  1411 000000F4 7503                    	jnz	short DODAB		; internal ^c
  1412 000000F6 E92001                  	jmp	LODCOM1
  1413                                  DODAB:
  1414 000000F9 F9                      	stc				; tell dos to abort
  1415                                  
  1416                                  ;SR;
  1417                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  1418                                  ;by setting carry and leaving flags on the stack
  1419                                  ;
  1420 000000FA CB                      	retf				; Leave flags on stack
  1421                                  
  1422                                  ;ContC	endp
  1423                                  
  1424                                  ;SR;
  1425                                  ; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  1426                                  ;both have ds = DATARES
  1427                                  ;
  1428                                  
  1429                                  RESPIPEOFF:
  1430 000000FB 50                      	push	ax
  1431 000000FC 31C0                    	xor	ax,ax
  1432 000000FE 2E8606[560B]            	xchg	al,[cs:PIPEFLAG]
  1433 00000103 08C0                    	or	al,al
  1434 00000105 7405                    	jz	short NOPIPEPOP
  1435 00000107 2ED02E[E90A]            	shr	byte [cs:ECHOFLAG],1
  1436                                  NOPIPEPOP:
  1437 0000010C 58                      	pop	ax
  1438 0000010D C3                      	retn
  1439                                  
  1440                                  ;CODERES ends
  1441                                  
  1442                                  ;=============================================================================
  1443                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  1444                                  ;=============================================================================
  1445                                  ; 21/09/2018 - Retro DOS v3.0
  1446                                  
  1447                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  1448                                  ;	name	COMMAND2
  1449                                  
  1450                                  ;/*
  1451                                  ; *                      Microsoft Confidential
  1452                                  ; *                      Copyright (C) Microsoft Corporation 1991
  1453                                  ; *                      All Rights Reserved.
  1454                                  ; */
  1455                                  
  1456                                  ;
  1457                                  ;	Revision History
  1458                                  ;	================
  1459                                  ;
  1460                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  1461                                  ;			reserve memory by changing int 12h and then give it
  1462                                  ;			back to DOS by changing arenas in autoexec.bat.
  1463                                  ;			This makes command.com reload transient and this
  1464                                  ;			cannot be done at this stage.
  1465                                  ;
  1466                                  
  1467                                  ;CODERES segment public byte
  1468                                  
  1469                                  ;*	If we cannot allocate enough memory for the transient or there
  1470                                  ;	was some other allocation error, we display a message and
  1471                                  ;	then die.
  1472                                  
  1473                                  ;SR;
  1474                                  ; We will have to make sure that at this entry point and at FatalC, 
  1475                                  ;ds = DATARES. All jumps to these points are made from only within this file
  1476                                  ;and so we should be able to do this
  1477                                  
  1478                                  	;assume	ds:DATARES
  1479                                  BADMEMERR:
  1480 0000010E BA[E609]                	mov	dx,BMEMMES			; DX = ptr to msg
  1481                                  FATALC:
  1482 00000111 0E                      	push	cs
  1483 00000112 1F                      	pop	ds
  1484                                  ;;	assume	ds:ResGroup
  1485                                  ;	invoke	RPrint
  1486                                  
  1487                                  	; MSDOS 3.3
  1488 00000113 E87A05                  	call	RDISPMSG
  1489                                  
  1490                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  1491                                  ;	we can't do anything else!
  1492                                  
  1493 00000116 803E[EE0A]00            	cmp	byte [PERMCOM],0
  1494 0000011B 7410                    	je	short FATALRET
  1495                                  
  1496                                  ;	We are a permanent command. If we are in the process of the
  1497                                  ;	magic interrupt (Singlecom) then exit too.
  1498                                  
  1499 0000011D 833E[EF0A]00            	cmp	word [SINGLECOM],0		; if permcom and singlecom
  1500 00000122 7509                    	jne	short FATALRET			; must take int_2e exit
  1501                                  
  1502                                  ;	Permanent command. We can't do ANYthing except halt.
  1503                                  
  1504 00000124 BA[010A]                	mov	dx,HALTMES			; DX = ptr to msg
  1505                                  	;invoke	RPrint
  1506                                  	; MSDOS 3.3
  1507 00000127 E86605                  	call	RDISPMSG
  1508 0000012A FB                      	sti
  1509                                  STALL:
  1510 0000012B EBFE                    	jmp	short STALL			; crash the system nicely
  1511                                  
  1512                                  FATALRET:
  1513 0000012D BA[260A]                	mov	dx,FRETMES			; DX = ptr to msg
  1514 00000130 E85D05                  	call	RDISPMSG
  1515                                  FATALRET2:
  1516 00000133 803E[EE0A]00            	cmp	byte [PERMCOM],0		; if we get here and permcom,
  1517 00000138 7517                    	jne	SHORT RET_2E			; must be int_2e
  1518                                  
  1519                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  1520                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  1521                                  ;	case we decide to do that.)
  1522 0000013A A1[880A]                	mov	ax,[PARENT]
  1523 0000013D A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  1524 00000140 A1[8A0A]                	mov	ax,[OLDTERM]
  1525 00000143 A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  1526 00000146 A1[8C0A]                	mov	ax,[OLDTERM+2]
  1527 00000149 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  1528 0000014C B8004C                  	mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  1529 0000014F CD21                    	int	21h
  1530                                  RET_2E:
  1531                                  ;SR;
  1532                                  ; We will ensure that ds = DATARES for all entries to this place
  1533                                  ;
  1534                                  
  1535                                  ;;	push	cs
  1536                                  ;;	pop	ds
  1537                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  1538                                    	
  1539                                  ;	assume	ds:DATARES
  1540                                  
  1541                                  	;PUSH	CS
  1542                                  	;POP	DS
  1543                                  
  1544 00000151 C706[EF0A]0000          	mov	word [SINGLECOM],0	; turn off singlecom
  1545 00000157 8E06[1F0C]              	mov	es,[RES_TPA]
  1546 0000015B B449                    	mov	ah,DEALLOC
  1547 0000015D CD21                    	int	21h			; free up space used by transient
  1548 0000015F 8B1E[860A]              	mov	bx,[SAVE_PDB]
  1549 00000163 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  1550 00000165 CD21                    	int	21h			; current process is user
  1551 00000167 A1[E60A]                	mov	ax,[RETCODE]
  1552 0000016A 803E[E50A]00            	cmp	byte [EXTCOM],0
  1553 0000016F 7502                    	jne	short GOTECODE
  1554 00000171 31C0                    	xor	ax,ax			; internals always return 0
  1555                                  GOTECODE:
  1556 00000173 C606[E50A]01            	mov	byte [EXTCOM],1		; force external
  1557                                  
  1558                                  ;SR; This is actually returning to the caller. However, the old code had
  1559                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  1560                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  1561                                  ;
  1562                                  	;jmp	INT_2E_RET		;"iret"
  1563                                  	; 12/01/2023 (BugFix)
  1564 00000178 FF2E[820A]              	jmp	far [INT_2E_RET]
  1565                                  
  1566                                  ;***	Int_2e, magic command executer
  1567                                  
  1568                                  INT_2E:
  1569                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  1570                                  ;SR;
  1571                                  ; We are going to come here from the stub with the old ds and DATARES value
  1572                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  1573                                  ;
  1574                                  	;pop	ds			;ds = DATARES
  1575                                  	;assume	ds:DATARES
  1576                                  	;pop	ax
  1577                                  ;	;pop	ds:OldDS 		;Save old value of ds
  1578                                  
  1579 0000017C 2E8F06[820A]            	pop	word [cs:INT_2E_RET]
  1580 00000181 2E8F06[840A]            	pop	word [cs:INT_2E_RET+2]	; store return address
  1581 00000186 58                      	pop	ax			; chuck flags
  1582                                  	;add	sp,2
  1583                                  
  1584 00000187 0E                      	push	cs
  1585 00000188 07                      	pop	es
  1586                                  
  1587                                  	;push	ds
  1588                                  	;pop	es			;es = DATARES
  1589                                  ;	;mov	ds,OldDS
  1590                                  	;mov	ds,ax
  1591                                  	;assume	ds:nothing		;ds = old value
  1592                                  
  1593 00000189 BF8000                  	mov	di,80h
  1594 0000018C B94000                  	mov	cx,64
  1595                                  ;	Bugbug:	cld
  1596 0000018F F3A5                    	rep	movsw
  1597 00000191 B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1598 00000193 CD21                    	int	21h			; get user's header
  1599                                  	;mov	[es:SAVE_PDB],bx
  1600 00000195 2E891E[860A]            	MOV	[cs:SAVE_PDB],bx
  1601 0000019A B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  1602                                  
  1603                                  ;;	mov	bx,cs
  1604                                  ;SR;
  1605                                  ; Set ds = DATARES because BadMemErr expects this
  1606                                  ;
  1607                                  	;push	es
  1608                                  	;pop	ds
  1609                                  	;assume	ds:DATARES
  1610                                  
  1611                                  	;mov	bx,ds			;es = our PSP now
  1612 0000019C 8CCB                    	mov	bx,cs
  1613                                  
  1614 0000019E CD21                    	int	21h			; current process is me
  1615 000001A0 2EC706[EF0A]8100        	mov	word [cs:SINGLECOM],81h
  1616 000001A7 2EC606[E50A]01          	mov	byte [cs:EXTCOM],1	; make sure this case forced
  1617                                  
  1618                                  ;SR;
  1619                                  ; We can enter LodCom directly after a command shell is terminated or we
  1620                                  ;can fall thru from above. When we enter directly from the stub, the stack
  1621                                  ;has the old ds value and the data seg value on the stack, so that ds can
  1622                                  ;be properly set. To fake this, we push dummy values here.
  1623                                  ;
  1624                                  	;push	ds			;old value of ds
  1625                                  	;push	ds			;data seg value, ds = DATARES
  1626                                  
  1627                                  LODCOM: 				; termination handler
  1628                                  	;pop	ds			;ds = DATARES 
  1629                                  	;assume	ds:DATARES
  1630                                  	;add	sp,2
  1631                                  ;	;pop	OldDS			;store old ds
  1632                                  
  1633                                  	;cmp	EXTCOM,0
  1634 000001AD 2E803E[E50A]00          	cmp	byte [cs:EXTCOM],0
  1635                                  	;jne	@f	 		; internal cmd - memory allocated
  1636                                  	;jne	short LODCOM0 ; 24/09/2018
  1637                                  	;jmp	LODCOM1 		; jz LODCOM1
  1638 000001B3 7464                    	je	short LODCOM1 ; 25/09/2018	
  1639                                  
  1640                                  ;@@:
  1641                                  LODCOM0: ; 24/09/2018
  1642 000001B5 BBFFFF                  	mov	bx,0FFFFh
  1643 000001B8 B448                    	mov	ah,ALLOC ; 48h	
  1644 000001BA CD21                    	int	21h			; DOS - 2+ - ALLOCATE MEMORY
  1645                                  					; BX = number of 16-byte paragraphs desired
  1646 000001BC E80A00                  	call	SETSIZE
  1647 000001BF 83C020                  	add	ax,20h
  1648 000001C2 39C3                    	cmp	bx,ax
  1649 000001C4 730B                    	jnb	short MEMOK		; > 512 byte buffer - good enough
  1650                                  BADMEMERRJ:
  1651 000001C6 E945FF                  	jmp	BADMEMERR		; not enough memory
  1652                                  
  1653                                  ;***	SetSize - get transient size in paragraphs
  1654                                  
  1655                                  SETSIZE:
  1656 000001C9 B85B4C                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh
  1657 000001CC B104                    	mov	cl,4
  1658 000001CE D3E8                    	shr	ax,cl
  1659 000001D0 C3                      	retn
  1660                                  
  1661                                  MEMOK:
  1662                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  1663                                  
  1664 000001D1 B448                    	mov	ah,ALLOC  ; 48h
  1665 000001D3 CD21                    	int	21h
  1666 000001D5 72EF                    	jc	short BADMEMERRJ	; memory arenas probably trashed
  1667 000001D7 2EC606[E50A]00          	mov	byte [cs:EXTCOM],0	; flag not to alloc again
  1668 000001DD 2EA3[1F0C]              	mov	[cs:RES_TPA],ax		; save current tpa segment
  1669 000001E1 2500F0                  	and	ax,0F000h
  1670 000001E4 050010                  	add	ax,01000h		; round up to next 64k boundary
  1671 000001E7 7213                    	jc	short BAD_TPA		; memory wrap if carry set
  1672                                  
  1673                                  ;	Make sure that new boundary is within allocated range
  1674                                  
  1675 000001E9 2E8B16[1F0C]            	mov	dx,[cs:RES_TPA]
  1676 000001EE 01DA                    	add	dx,bx			; compute maximum address
  1677 000001F0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  1678 000001F2 7608                    	jbe	short BAD_TPA
  1679                                  
  1680                                  ;	Must have 64K of usable space.
  1681                                  
  1682 000001F4 29C2                    	sub	dx,ax			; compute the usable space
  1683 000001F6 81FA0010                	cmp	dx,01000h		; is space >= 64k ?
  1684 000001FA 7304                    	jae	short LTPASET
  1685                                  BAD_TPA:
  1686 000001FC 2EA1[1F0C]              	mov	ax,[cs:RES_TPA]
  1687                                  LTPASET:
  1688 00000200 2EA3[110C]              	mov	[cs:LTPA],ax		; usable tpa is 64k buffer aligned
  1689 00000204 2EA1[1F0C]              	mov	ax,[cs:RES_TPA]		; actual tpa is buffer allocated
  1690 00000208 01C3                    	add	bx,ax
  1691 0000020A 2E891E[E10A]            	mov	[cs:MEMSIZ],bx
  1692 0000020F E8B7FF                  	call	SETSIZE
  1693 00000212 29C3                    	sub	bx,ax
  1694                                  
  1695                                  	; MSDOS 6.0
  1696                                  ;;
  1697                                  ;;M038; Start of changes
  1698                                  ;; Changes for Novell RPL. These guys reserve memory for themselves by
  1699                                  ;;reducing int 12h size and add this memory to the system at autoexec time by
  1700                                  ;;running a program that changes arenas. This changes the largest block that
  1701                                  ;;command.com gets and so changes the transient segment. So, command.com does
  1702                                  ;;a checksum at the wrong address and thinks that the transient is destroyed
  1703                                  ;;and tries to reload it. At this point, no Comspec is defined and so the
  1704                                  ;;reload fails, hanging the system. To get around this we just copy the
  1705                                  ;;transient from the previous address to the new address(if changed) and
  1706                                  ;;then let command.com do the checksum. So, if the transient area is not
  1707                                  ;;corrupted, there will not be any reload. In Novell's case, the transient
  1708                                  ;;is not really corrupted and so this should work.
  1709                                  ;;
  1710                                  ;	cmp	bx,[cs:TRNSEG]		;Segment still the same?
  1711                                  ;	je	short LODCOM1		;yes, dont copy
  1712                                  ;;
  1713                                  ;;Check if the new segment is above or below the current move. If the new
  1714                                  ;;segment is above (i.e new block is larger than previous block), then we
  1715                                  ;;have to move in the reverse direction
  1716                                  ;;
  1717                                  ;	mov	cx,TRANSPACEEND		;cx = length to move
  1718                                  ;	ja	short _MOV_DOWN		;new seg > old seg, reverse move
  1719                                  ;	xor	si,si			;normal move
  1720                                  ;	mov	di,si
  1721                                  ;	cld
  1722                                  ;	jmp	short COPY_TRANS
  1723                                  ;_MOV_DOWN:
  1724                                  ;	mov	si,cx			;reverse move, start from end
  1725                                  ;	dec	si
  1726                                  ;	mov	di,si
  1727                                  ;	std
  1728                                  ;COPY_TRANS:
  1729                                  ;	push	ds
  1730                                  ;	push	es
  1731                                  ;	mov	es,bx			;dest segment
  1732                                  ;	mov	ds,[cs:TRNSEG]		;source segment
  1733                                  ;	;assume	ds:nothing
  1734                                  ;
  1735                                  ;	rep	movsb			;copy transient
  1736                                  ;	cld
  1737                                  ;	pop	es
  1738                                  ;	pop	ds
  1739                                  ;	;assume	ds:DATARES
  1740                                  ;;
  1741                                  ;;M038; End of changes
  1742                                  ;;
  1743 00000214 2E891E[DB0A]            	mov	[cs:TRNSEG],bx		;new location of transient
  1744                                  
  1745                                  LODCOM1:
  1746                                  ;;	mov	ax,cs
  1747                                  ;;	mov	ss,ax
  1748                                  ;SR; At this point ds = DATARES which is where the stack is located
  1749                                  ;
  1750                                  	;mov	ax,ds
  1751                                  	;mov	ss,ax
  1752                                  	;assume	ss:DATARES
  1753                                  	;mov	sp,offset DATARES:RStack
  1754                                  
  1755                                  ;;	mov	ds,ax
  1756                                  
  1757                                  	;assume	ds:DATARES
  1758                                  	
  1759                                  	; MSDOS 3.3
  1760 00000219 8CC8                    	mov	ax,cs
  1761 0000021B 8ED0                    	mov	ss,ax
  1762 0000021D BC[3807]                	mov	sp,RSTACK
  1763 00000220 8ED8                    	mov	ds,ax
  1764                                  
  1765 00000222 E88E00                  	call	HEADFIX			; close files, restore stdin, stdout
  1766 00000225 31ED                    	xor	bp,bp			; flag command ok
  1767 00000227 B8FFFF                  	mov	ax,-1
  1768 0000022A 8706[F10A]              	xchg	ax,[VERVAL]
  1769 0000022E 83F8FF                  	cmp	ax,-1
  1770 00000231 7404                    	je	short NOSETVER
  1771 00000233 B42E                    	mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  1772 00000235 CD21                    	int	21h 			; DOS - SET VERIFY FLAG
  1773                                  					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  1774                                  NOSETVER:
  1775 00000237 833E[EF0A]FF            	cmp	word [SINGLECOM],-1
  1776 0000023C 7503                    	jne	short NOSNG
  1777 0000023E E9F2FE                  	jmp	FATALRET2		; we have finished the single command
  1778                                  NOSNG:
  1779 00000241 E87E01                  	call	CHKSUM			; check the transient
  1780 00000244 3B16[E30A]              	cmp	dx,[SUM]
  1781 00000248 7416                    	je	short HAVCOM		; transient ok
  1782                                  BOGUS_COM:
  1783 0000024A C606[920A]01            	mov	byte [LOADING],1	; flag DskErr routine
  1784 0000024F E82101                  	call	LOADCOM
  1785                                  CHKSAME:
  1786 00000252 E86D01                  	call	CHKSUM
  1787 00000255 3B16[E30A]              	cmp	dx,[SUM]
  1788 00000259 7405                    	jz	short HAVCOM		; same command
  1789                                  ALSO_BOGUS:
  1790 0000025B E85C01                  	call	WRONGCOM
  1791 0000025E EBF2                    	jmp	short CHKSAME
  1792                                  
  1793                                  HAVCOM:
  1794                                  	; 25/09/2018
  1795 00000260 B80037                  	mov     ax,(CHAR_OPER*256) ; 3700h
  1796 00000263 CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  1797                                  			; Return: AL = FFh unsupported subfunction
  1798                                  			; DL = current switch character
  1799 00000265 8816[130C]              	mov     [RSWITCHAR],dl
  1800 00000269 80FA2F                  	cmp     dl,'/'
  1801 0000026C 7505                    	jnz     short USESLASH
  1802                                  	;mov	cl,'\'
  1803                                  	;mov	[RDIRCHAR],cl
  1804 0000026E C606[140C]5C            	mov	byte [RDIRCHAR],'\'
  1805                                  USESLASH:
  1806 00000273 C606[920A]00            	mov	byte [LOADING],0		; flag to DskErr
  1807 00000278 BE[0D0C]                	mov	si,TRANVARS
  1808 0000027B BF7F41                  	mov	di,HEADCALL
  1809 0000027E 8E06[DB0A]              	mov	es,[TRNSEG]
  1810 00000282 FC                      	cld
  1811 00000283 B9[210C]                	mov	cx,TRANVAREND
  1812 00000286 29F1                    	sub	cx,si
  1813 00000288 F3A4                    	rep	movsb			; transfer info to transient
  1814 0000028A A1[E10A]                	mov	ax,[MEMSIZ]
  1815 0000028D A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  1816                                  
  1817                                  ;***	TJmp - jump-off to transient
  1818                                  ;
  1819                                  ;	Public label so debugger can find this spot.
  1820                                  
  1821                                  TJMP:
  1822 00000290 FF2E[D90A]              	jmp	far [TRANS]
  1823                                  
  1824                                  ;***	TRemCheck - far version of RemCheck for transient
  1825                                  
  1826                                  TREMCHECK:
  1827                                  	;pop	ds			;ds = DATARES
  1828                                  	;add	sp,2			;discard old value of ds
  1829                                  
  1830 00000294 E80100                  	call	REMCHECK
  1831 00000297 CB                      	retf
  1832                                  
  1833                                  ;***	RemCheck
  1834                                  ;
  1835                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  1836                                  ;
  1837                                  ;	EXIT	ZR set if removeable media
  1838                                  ;		ZR clear if fixed media
  1839                                  ;
  1840                                  ;	USED	none
  1841                                  
  1842                                  REMCHECK:
  1843 00000298 50                      	push	ax
  1844 00000299 53                      	push	bx
  1845 0000029A 89C3                    	mov	bx,ax
  1846 0000029C B80844                  	mov	ax,(IOCTL<<8)+8 ; 4408h
  1847 0000029F CD21                    	int	21h			; DOS - 2+ - IOCTL -
  1848 000002A1 7304                    	jnc	short RCCONT			
  1849                                  
  1850                                  ;	If an error occurred, assume the media is non-removable.
  1851                                  ;	AX contains the non-zero error code from the int 21, so
  1852                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  1853                                  ;	appear to be non-removable.				
  1854                                  					
  1855 000002A3 09C0                    	or	ax,ax			
  1856 000002A5 EB05                    	jmp	short RESREGS
  1857                                  RCCONT:
  1858 000002A7 83E001                  	and	ax,1
  1859 000002AA F7D0                    	not	ax
  1860                                  RESREGS:
  1861 000002AC 5B                      	pop	bx
  1862 000002AD 58                      	pop	ax
  1863 000002AE C3                      	retn
  1864                                  
  1865                                  ;***	THeadFix
  1866                                  ;
  1867                                  ;	Far version of HeadFix, called from transient.
  1868                                  
  1869                                  THEADFIX:
  1870                                  	;pop	ds			;ds = DATARES
  1871                                  	;add	sp,2			;discard old ds value on stack
  1872                                  
  1873 000002AF E80100                  	call	HEADFIX
  1874 000002B2 CB                      	retf
  1875                                  
  1876                                  ;***	HeadFix
  1877                                  
  1878                                  HEADFIX:
  1879 000002B3 E82601                  	call	SETVECT			; set vectors to our values
  1880                                  
  1881                                  ;	Clean up header
  1882                                  
  1883                                  ;	Bugbug:	optimize:
  1884                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  1885                                  
  1886 000002B6 31DB                    	xor	bx,bx				; BX = handle = 0
  1887 000002B8 8B0E[EB0A]              	mov	cx,[IO_SAVE]			; CX = original stdin, stdout
  1888 000002BC 8B161800                	mov	dx,[PDB.JFN_TABLE] ; mov dx,[ds:18h] ; DX = current stdin, stdout
  1889 000002C0 38D1                    	cmp	cl,dl
  1890 000002C2 7408                    	je	short CHK1		; stdin matches
  1891 000002C4 B43E                    	mov	ah,CLOSE  ; 3Eh
  1892 000002C6 CD21                    	int	21h			; close stdin
  1893 000002C8 880E1800                	mov	[PDB.JFN_TABLE],cl ; mov [ds:18h],cl ; restore stdin
  1894                                  CHK1:
  1895 000002CC 43                      	inc	bx			; BX = handle = 1
  1896 000002CD 38F5                    	cmp	ch,dh			
  1897 000002CF 7408                    	je	short CHKOTHERHAND	; stdout matches
  1898 000002D1 B43E                    	mov	ah,CLOSE
  1899 000002D3 CD21                    	int	21h			; close stdout
  1900 000002D5 882E1900                	mov	[PDB.JFN_TABLE+1],ch ; mov [ds:19h],ch	; restore stdout
  1901                                  
  1902                                  CHKOTHERHAND:
  1903 000002D9 83C304                  	add	bx,4			; skip handles 2,3,4
  1904 000002DC B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  1905                                  					;   (handles 0-4 already done)
  1906                                  CLOSELOOP:
  1907 000002DF B43E                    	mov	ah,CLOSE ; 3Eh
  1908 000002E1 CD21                    	int	21h			; close each handle
  1909 000002E3 43                      	inc	bx			; BX = next handle
  1910 000002E4 E2F9                    	loop	CLOSELOOP
  1911                                  
  1912                                  	; MSDOS 6.0
  1913                                  ;;	Bugbug:	since this is for transient code, move it there
  1914                                  ;
  1915                                  ;;	M012: remove this CS -> DS.  Must've been missed during
  1916                                  ;;	purification.
  1917                                  ;;;	push	ds			; save data segment
  1918                                  ;;;	push	cs			; get local segment into DS
  1919                                  ;;;	pop	ds			;
  1920                                  ;	cmp	Append_Flag,-1		; do we need to reset APPEND?
  1921                                  ;	jne	Append_Fix_End		; no - just exit
  1922                                  ;	mov	ax,AppendSetState	; set the state of Append
  1923                                  ;	mov	bx,Append_State 	;     back to the original state
  1924                                  ;	int	2Fh			;
  1925                                  ;	mov	Append_Flag,0		; set append flag to invalid
  1926                                  ;Append_Fix_End: 			;
  1927                                  ;;;	pop	ds			; get data segment back
  1928                                  ;	retn
  1929                                  
  1930                                  	; MSDOS 3.3
  1931 000002E6 C3                      	retn
  1932                                  
  1933                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  1934                                  ;
  1935                                  ;	ENTRY	nothing
  1936                                  ;
  1937                                  ;	EXIT	nothing
  1938                                  ;
  1939                                  ;	USED	flags
  1940                                  ;
  1941                                  ;	EFFECTS
  1942                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  1943                                  ;	  current program's stdin,stdout set to our stderr
  1944                                  ;
  1945                                  
  1946                                  ;SR;
  1947                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  1948                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  1949                                  ;
  1950                                  SAVHAND:
  1951                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  1952                                  
  1953 000002E7 1E                      	push	ds ; MSDOS 3.3
  1954 000002E8 53                      	push	bx			;preserve registers
  1955 000002E9 50                      	push	ax
  1956                                  	;push	es
  1957                                  	;push	ds			; save DATARES value
  1958                                  
  1959 000002EA B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1960 000002EC CD21                    	int	21h			; BX = user's header seg addr
  1961 000002EE 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  1962 000002F0 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h]	; DS:BX = ptr to JFN table
  1963 000002F4 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  1964                                  
  1965                                  	;pop	es			;es = DATARES
  1966                                  	;push	es			;save it back on stack
  1967                                  	;mov	es:Handle01,ax		; save user's stdin, stdout
  1968 000002F6 2EA3[900A]              	mov	[cs:HANDLE01],ax
  1969                                  
  1970                                  ;SR;
  1971                                  ; Use es to address Handle01 & our JFN_Table
  1972                                  ;
  1973                                  
  1974                                  	;mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
  1975 000002FA 2EA01A00                	mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  1976 000002FE 88C4                    	mov	ah,al			; AH = COMMAND stderr
  1977 00000300 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  1978                                  
  1979                                  	;pop	ds			; restore registers
  1980                                  	;pop	es
  1981 00000302 58                      	pop	ax
  1982 00000303 5B                      	pop	bx
  1983 00000304 1F                      	pop	ds ; MSDOS 3.3
  1984 00000305 C3                      	retn
  1985                                  
  1986                                  	;assume	ds:DATARES
  1987                                  GETCOMDSK2:
  1988 00000306 E81F00                  	call	GETCOMDSK
  1989 00000309 E90DFF                  	jmp	LODCOM1			; memory already allocated
  1990                                  
  1991                                  RESTHAND:
  1992 0000030C 1E                      	push	ds
  1993 0000030D 53                      	push	bx			; restore stdin, stdout to user
  1994 0000030E 50                      	push	ax
  1995 0000030F B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1996 00000311 CD21                    	int	21h			; point to user's header
  1997 00000313 A1[900A]                	mov	ax,[HANDLE01]
  1998 00000316 8EDB                    	mov	ds,bx
  1999                                  	;assume ds:NOTHING
  2000 00000318 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h] ; DS:BX = ptr to jfn table
  2001 0000031C 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  2002 0000031E 58                      	pop	ax
  2003 0000031F 5B                      	pop	bx
  2004 00000320 1F                      	pop	ds
  2005 00000321 C3                      	retn
  2006                                  
  2007                                  	;assume ds:DATARES,ss:DATARES
  2008                                  HOPELESS:
  2009 00000322 BA[E908]                	mov	dx,COMBAD
  2010 00000325 E9E9FD                  	jmp	FATALC
  2011                                  
  2012                                  GETCOMDSK:
  2013 00000328 A0[E00A]                	mov	al,[COMDRV]
  2014 0000032B E86AFF                  	call	REMCHECK
  2015 0000032E 75F2                    	jnz	short HOPELESS		; non-removable media
  2016                                  GETCOMDSK3:
  2017 00000330 81FA[E908]              	cmp	dx,COMBAD
  2018 00000334 7503                    	jne	short GETCOMDSK4
  2019                                  	;;mov	dx,offset DATARES:ComBad	; DX = ptr to msg
  2020                                  	;invoke	RPrint				; say COMMAND is invalid
  2021 00000336 E85703                  	call	RDISPMSG
  2022                                  GETCOMDSK4:
  2023                                  ;	Bugbug:	there's always a drive here?  No need to check?
  2024 00000339 803E[1D09]00            	cmp	byte [PUTBACKDRV],0	; is there a drive in the comspec?
  2025 0000033E 7509                    	jne	short USERS_DRIVE	; yes - use it
  2026 00000340 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  2027 00000342 CD21                    	int	21h
  2028 00000344 0441                    	add	al,"A"                  ; convert to ascii
  2029 00000346 A2[1D09]                	mov	[PUTBACKDRV],al		; put in message to print out
  2030                                  
  2031                                  USERS_DRIVE:
  2032                                  	; MSDOS 6.0
  2033                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  2034                                  	;mov	si,offset DATARES:PutBackSubst	;  containing COMMAND
  2035                                  	;invoke	RPrint
  2036                                  	;mov	dx,offset DATARES:Prompt	; "Press any key"
  2037                                  	;invoke	RPrint
  2038                                  
  2039                                  	; MSDOS 3.3
  2040 00000349 BA[0109]                	mov	dx,PUTBACKMSG		; prompt for diskette
  2041 0000034C E84103                  	call	RDISPMSG
  2042 0000034F 8B16[D50A]              	mov	dx,[PUTBACKSUBSTPTR]
  2043 00000353 8B36[D70A]              	mov	si,[COMSPEC_END]
  2044 00000357 C6440124                	mov	byte [si+1],'$'
  2045 0000035B E83203                  	call	RDISPMSG
  2046 0000035E C6440100                	mov	byte [si+1],0
  2047 00000362 BA[1309]                	mov	dx,PROMPT
  2048 00000365 E82803                  	call    RDISPMSG
  2049                                  
  2050                                  	;call	GETRAWFLUSHEDBYTE
  2051                                  	;retn
  2052                                  	; 02/03/2023
  2053                                  	;jmp	short GETRAWFLUSHEDBYTE
  2054                                  
  2055                                  ;***	GetRawFlushedByte - flush world and get raw input
  2056                                  
  2057                                  GETRAWFLUSHEDBYTE:
  2058 00000368 B8070C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  2059 0000036B CD21                    	int	21h			; get char without testing or echo
  2060 0000036D B8000C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  2061 00000370 CD21                    	int	21h
  2062                                  ;	Bugbug:	get rid of this return and the following retz.
  2063                                  LOADCOM_RETN:
  2064 00000372 C3                      	retn
  2065                                  
  2066                                  ;***	LoadCom - load in transient
  2067                                  
  2068                                  LOADCOM:
  2069                                  	;assume	ds:DATARES
  2070                                  	
  2071 00000373 45                      	inc	bp				; flag command read
  2072                                  
  2073 00000374 BA[950A]                	mov	dx,COMSPEC
  2074 00000377 B8003D                  	mov	ax,OPEN<<8	; 3D00h
  2075 0000037A CD21                    	int	21h				; open command.com
  2076 0000037C 7310                    	jnc	short READCOM
  2077 0000037E 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  2078 00000381 7506                    	jnz	short TRYDOOPEN
  2079 00000383 BA[A409]                	mov	dx,NOHANDMES
  2080 00000386 E988FD                  	jmp	FATALC				; will never find a handle
  2081                                  
  2082                                  TRYDOOPEN:
  2083 00000389 E89CFF                  	call	GETCOMDSK
  2084 0000038C EBE5                    	jmp	short LOADCOM
  2085                                  
  2086                                  READCOM:
  2087 0000038E 89C3                    	mov	bx,ax				; BX = handle
  2088 00000390 BA[2015]                	mov	dx,TRANSTART
  2089 00000393 31C9                    	xor	cx,cx				; CX:DX = seek loc
  2090 00000395 B80042                  	mov	ax,LSEEK<<8	; 4200h
  2091 00000398 CD21                    	int	21h
  2092 0000039A 7210                    	jc	short WRONGCOM1
  2093 0000039C B94C4B                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  2094 0000039F 1E                      	push	ds
  2095 000003A0 8E1E[DB0A]              	mov	ds,[TRNSEG]
  2096                                  	;assume	ds:NOTHING
  2097 000003A4 BA0001                  	mov	dx,100h
  2098 000003A7 B43F                    	mov	ah,READ	; 3Fh	
  2099 000003A9 CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  2100                                  			; BX = file handle, CX = number of bytes to read
  2101                                  			; DS:DX -> buffer
  2102 000003AB 1F                      	pop	ds
  2103                                  	;assume	ds:DATARES
  2104                                  WRONGCOM1:
  2105 000003AC 9C                      	pushf
  2106 000003AD 50                      	push	ax
  2107 000003AE B43E                    	mov	ah,CLOSE ; 3Eh
  2108 000003B0 CD21                    	int	21h			; close command.com
  2109 000003B2 58                      	pop	ax
  2110 000003B3 9D                      	popf
  2111 000003B4 7204                    	jc	short WRONGCOM		; error on read
  2112 000003B6 39C8                    	cmp	ax,cx
  2113                                  	;retz				; size matched
  2114 000003B8 74B8                    	jz	short LOADCOM_RETN
  2115                                  WRONGCOM:
  2116 000003BA BA[E908]                	mov	dx,COMBAD
  2117 000003BD E868FF                  	call	GETCOMDSK
  2118 000003C0 EBB1                    	jmp	short LOADCOM		; try again
  2119                                  
  2120                                  ;***	ChkSum - compute transient checksum
  2121                                  
  2122                                  CHKSUM:
  2123 000003C2 1E                      	push	ds
  2124 000003C3 8E1E[DB0A]              	mov	ds,[TRNSEG]
  2125 000003C7 BE0001                  	mov	si,100h
  2126 000003CA B9353D                  	mov	cx,TRANDATAEND-100H	; 3E44h (for original MSDOS 3.3!)
  2127                                  CHECK_SUM:
  2128 000003CD FC                      	cld
  2129 000003CE D1E9                    	shr	cx,1
  2130 000003D0 31D2                    	xor	dx,dx
  2131                                  CHK:
  2132 000003D2 AD                      	lodsw
  2133 000003D3 01C2                    	add	dx,ax
  2134 000003D5 83D200                  	adc	dx,0
  2135 000003D8 E2F8                    	loop	CHK
  2136 000003DA 1F                      	pop	ds
  2137 000003DB C3                      	retn
  2138                                  
  2139                                  ;***	SetVect - set interrupt vectors
  2140                                  
  2141                                  SETVECT:
  2142                                  	;mov	dx,offset DATARES:LodCom_Trap 
  2143 000003DC BA[AD01]                	mov	dx,LODCOM ; MSDOS 3.3
  2144 000003DF B82225                  	mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  2145 000003E2 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  2146 000003E6 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  2147 000003EA CD21                    	int	21h
  2148                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  2149 000003EC BA[3C00]                	mov	dx,CONTC ; MSDOS 3.3
  2150 000003EF FEC0                    	inc	al	; 23h
  2151 000003F1 CD21                    	int	21h
  2152                                  	;mov	dx,offset DATARES:CritErr_Trap
  2153 000003F3 BA[4B04]                	mov	dx,CRITERR ; MSDOS 3.3
  2154 000003F6 FEC0                    	inc	al	; 24h
  2155 000003F8 CD21                    	int	21h
  2156 000003FA C3                      	retn
  2157                                  
  2158                                  	; MSDOS 6.0
  2159                                  ;;SR;
  2160                                  ;; We have this to take care of the extra values pushed on the stack by 
  2161                                  ;;the stub before jumping to LodCom1. We set up ds here and then jump to
  2162                                  ;;Lodcom1
  2163                                  ;;
  2164                                  ;public	TrnLodCom1
  2165                                  ;TrnLodCom1:
  2166                                  ;	pop	ds			;ds = DATARES
  2167                                  ;	add	sp,2
  2168                                  ;;	pop	ds:OldDS
  2169                                  ;	jmp	LodCom1
  2170                                  
  2171                                  ;***	EndInit - end up initialization sequence
  2172                                  ;
  2173                                  ;	Move the environment to a newly allocated segment.
  2174                                  
  2175                                  	; MSDOS 3.3
  2176                                  ENDINIT:
  2177 000003FB 1E                      	push	ds			; save segments
  2178 000003FC 06                      	push	es			;
  2179 000003FD 0E                      	push	cs			; get resident segment to DS
  2180 000003FE 1F                      	pop	ds			;
  2181                                  	;assume	ds:RESGROUP
  2182 000003FF 8B0E[DC14]              	mov	cx,[USEDENV]		; get number of bytes to move
  2183 00000403 8E06[FF0B]              	mov	es,[ENVIRSEG]		; get target environment segment
  2184                                  	;assume	es:NOTHING
  2185                                  
  2186 00000407 803E[E214]01            	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  2187 0000040C 750A                    	jne	short NO_RESET 		; no - we already did it
  2188 0000040E 8B1E[D614]              	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  2189 00000412 06                      	push	es			; save environment - just to be sure
  2190 00000413 B44A                    	mov	ah,SETBLOCK  ; 4Ah	;
  2191 00000415 CD21                    	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2192                                  				; ES = segment address of block to change
  2193                                  				; BX = new size in paragraphs
  2194 00000417 07                      	pop	es
  2195                                  
  2196                                  NO_RESET:
  2197 00000418 8C062C00                	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  2198 0000041C 8E1E[DA14]              	mov	ds,[OLDENV]		; source environment segment
  2199                                  	;assume	ds:NOTHING
  2200 00000420 31F6                    	xor	si,si			; set up offsets to start of segments
  2201 00000422 31FF                    	xor	di,di
  2202 00000424 FC                      	cld
  2203 00000425 F3A4                    	rep	movsb			; move it
  2204 00000427 31C0                    	xor	ax,ax
  2205 00000429 AA                      	stosb				; make sure it ends with double-null
  2206                                  
  2207                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  2208 0000042A 07                      	pop	es
  2209 0000042B 1F                      	pop	ds
  2210 0000042C E97EFD                  	jmp	LODCOM			; allocate transient
  2211                                  
  2212                                  
  2213                                  	; MSDOS 6.0
  2214                                  ;
  2215                                  ;The init code has been changed to take care of the new way in which the
  2216                                  ;environment segment is allocated.
  2217                                  ;NB: We can use all the init variables at this point because they are all in
  2218                                  ;RESGROUP
  2219                                  ;Bugbug: The above approach will not work for ROMDOS
  2220                                  ;
  2221                                  
  2222                                  ;IF 0
  2223                                  ;
  2224                                  ;EndInit:
  2225                                  ;	push	ds
  2226                                  ;	push	es			;save segments
  2227                                  ;	push	cs
  2228                                  ;	pop	ds		
  2229                                  ;	assume	ds:RESGROUP
  2230                                  ;;
  2231                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  2232                                  ;;
  2233                                  ;	mov	bx,ds
  2234                                  ;	mov	es,bx			;es = RESGROUP
  2235                                  ;;
  2236                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2237                                  ;; code + data for low COMMAND
  2238                                  ;;
  2239                                  ;	mov	bx,ResSize		;Total size of resident
  2240                                  ;	mov	ah,SETBLOCK
  2241                                  ;	int	21h			;Set block to resident size
  2242                                  ;;
  2243                                  ;;Allocate the correct size for the environment
  2244                                  ;;
  2245                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  2246                                  ;	mov	ah,ALLOC
  2247                                  ;	int	21h			;get memory
  2248                                  ;	jc	nomem_err		;out of memory,signal error
  2249                                  ;
  2250                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  2251                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  2252                                  ;	mov	es,ax			;es = address of allocated memory
  2253                                  ;	assume	es:nothing
  2254                                  ;
  2255                                  ;;
  2256                                  ;;Copy the environment to the newly allocated segment
  2257                                  ;;
  2258                                  ;	mov	cx,UsedEnv		;number of bytes to move
  2259                                  ;
  2260                                  ;	push	ds
  2261                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  2262                                  ;	assume	ds:nothing
  2263                                  ;
  2264                                  ;	xor	si,si
  2265                                  ;	mov	di,si			;Start transfer from 0
  2266                                  ;
  2267                                  ;	cld
  2268                                  ;	rep	movsb			;Do the copy
  2269                                  ;
  2270                                  ;	xor	ax,ax			
  2271                                  ;	stosb				;Make it end with double-null
  2272                                  ;
  2273                                  ;	pop	ds			;ds = RESGROUP
  2274                                  ;	assume	ds:RESGROUP
  2275                                  ;;
  2276                                  ;;We have to free the old environment block if it was allocated by INIT
  2277                                  ;;
  2278                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  2279                                  ;	je      no_free                 ;no, do not free it
  2280                                  ;
  2281                                  ;	mov	ax,OldEnv		;Get old environment
  2282                                  ;	mov	es,ax
  2283                                  ;	mov	ah,DEALLOC	
  2284                                  ;	int	21h			;Free it
  2285                                  ;no_free:
  2286                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  2287                                  ;	
  2288                                  ;	pop	es
  2289                                  ;	pop	ds
  2290                                  ;	assume	ds:nothing
  2291                                  ;	
  2292                                  ;	jmp	LodCom			;allocate transient
  2293                                  ;
  2294                                  ;nomem_err:
  2295                                  ;;
  2296                                  ;;We call the error routine which will never return. It will either exit
  2297                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  2298                                  ;;message ( if first COMMAND )
  2299                                  ;;
  2300                                  ;
  2301                                  ;	call	Alloc_error
  2302                                  ;ENDIF
  2303                                  ;
  2304                                  ;CODERES ends
  2305                                  
  2306                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2307                                  ;	the resident group which is the location where the transient
  2308                                  ;	segments will be loaded initial.
  2309                                  
  2310                                  ;TAIL		segment public para
  2311                                  ;
  2312                                  ;		org	0
  2313                                  ;TranStart	label	word
  2314                                  ;		public	TranStart
  2315                                  ;
  2316                                  ;TAIL		ends
  2317                                  ;
  2318                                  
  2319                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2320                                  ;	the transient group which is the location where the exec
  2321                                  ;	segments will be loaded initial.
  2322                                  ;
  2323                                  ;	Bugbug:	Is TRANTAIL used anymore?
  2324                                  
  2325                                  ;TRANTAIL	segment public para
  2326                                  ;
  2327                                  ;		org	0
  2328                                  ;ExecStart   	label   word
  2329                                  ;
  2330                                  ;TRANTAIL    	ends
  2331                                  
  2332                                  ;=============================================================================
  2333                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  2334                                  ;=============================================================================
  2335                                  ; 22/09/2018 - Retro DOS v3.0
  2336                                  
  2337                                  ;	title	Localizable code for resident COMMAND
  2338                                  
  2339                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2340                                  
  2341                                  ;***	AskEnd - ask user to confirm batch file termination
  2342                                  ;
  2343                                  ;	Confirm with user before freeing batch ...
  2344                                  ;
  2345                                  ;	ENTRY	nothing
  2346                                  ;
  2347                                  ;	EXIT	CY = set if batch termination is confirmed
  2348                                  ;
  2349                                  ;		CY = clear if batch should continue
  2350                                  ;
  2351                                  ;	USED	AX,DX,...
  2352                                  
  2353                                  ;	Bugbug:	move this to transient, copy to batch segment.
  2354                                  ;	Bugbug:	or move it to command1 1st.
  2355                                  
  2356                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  2357                                  
  2358                                  ASKEND:
  2359                                  	;assume	ds:DATARES
  2360                                  
  2361 0000042F BA[4009]                	mov	dx,ENDBATMES			; DX = message #
  2362                                  	;call	RPrint
  2363 00000432 E85B02                  	call	RDISPMSG  ; MSDOS 3.3
  2364 00000435 B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  2365 00000438 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  2366                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  2367 0000043A E85B02                  	call	CHARTOUPPER			; change to upper case
  2368 0000043D 3A06[780A]              	cmp	al,[NO_CHAR]
  2369 00000441 7407                    	je	short AERET			; answer is no (CY is clear)
  2370 00000443 3A06[770A]              	cmp	al,[YES_CHAR]
  2371 00000447 75E6                    	jne	short ASKEND			; invalid response, try again
  2372 00000449 F9                      	stc					; answer is yes
  2373                                  AERET:	
  2374 0000044A C3                      	retn
  2375                                  
  2376                                  
  2377                                  ;***	DskErr - critical error handler
  2378                                  ;
  2379                                  ;	Default critical error handler unless user intercepts int 24h.
  2380                                  ;
  2381                                  ;	ENTRY	int 24h
  2382                                  ;
  2383                                  ;	EXIT
  2384                                  ;
  2385                                  ;	USED
  2386                                  ;
  2387                                  ;	EFFECTS
  2388                                  
  2389                                  ;
  2390                                  ;SR; 
  2391                                  ; The stub is going to push the old ds value and the resident data segment
  2392                                  ;onto the stack in that order. Get it off the stack
  2393                                  ;
  2394                                  
  2395                                  ;DskErr	proc	far
  2396                                  DSKERRR:
  2397                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2398                                  	;
  2399                                  	;pop	ds			;ds = DATARES
  2400                                  	;assume ds:DATARES
  2401                                  	;pop	OldDS			;save old ds value
  2402                                  
  2403                                  CRITERR: ; MSDOS 3.3
  2404 0000044B FB                      	sti
  2405 0000044C 1E                      	push	ds ; 25/09/2018
  2406 0000044D 06                      	push	es
  2407 0000044E 56                      	push	si
  2408 0000044F 51                      	push	cx
  2409 00000450 57                      	push	di
  2410 00000451 51                      	push	cx
  2411 00000452 50                      	push	ax
  2412                                  
  2413                                  	;push	ds			;save our data segment
  2414 00000453 0E                      	push	cs ; 25/09/2018
  2415 00000454 07                      	pop	es			;es = DATARES
  2416                                  
  2417 00000455 8EDD                    	mov	ds,bp
  2418                                  	;assume	ds:nothing
  2419                                  
  2420                                  	;mov	ax,[si].SDEVATT
  2421 00000457 8B4404                  	MOV	ax,[SI+SYSDEV.ATT] ; mov ax,[si+4]	
  2422 0000045A 268826[CB08]            	mov	[es:CDEVAT],ah
  2423                                  
  2424                                  	;push	cs
  2425                                  	;pop	es
  2426                                  
  2427 0000045F BF[9F08]                	mov	di,DEVNAME
  2428 00000462 B90800                  	mov	cx,8
  2429                                  	;add	si,SDEVNAME  ; add si,10
  2430 00000465 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  2431                                  				
  2432 00000468 FC                      	cld
  2433 00000469 F3A4                    	rep	movsb
  2434 0000046B 58                      	pop	ax
  2435 0000046C 59                      	pop	cx
  2436 0000046D 5F                      	pop	di
  2437                                  
  2438                                  ;	Stack still contains DS and ES.
  2439                                  
  2440                                  ;SR;
  2441                                  ; We need ds = DATARES for SavHand
  2442                                  ;
  2443                                  	;push	es
  2444                                  	;pop	ds
  2445                                  	;assume	ds:DATARES
  2446                                  
  2447                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  2448 0000046E E876FE                  	call	SAVHAND
  2449                                  
  2450                                  	; 25/09/2018
  2451                                  	;push	cs
  2452 00000471 06                      	push	es
  2453 00000472 1F                      	pop	ds		; set up local data segment
  2454                                  	;assume	ds:resgroup
  2455                                  
  2456 00000473 52                      	push	dx
  2457 00000474 E81602                  	call	CRLF
  2458 00000477 5A                      	pop	dx
  2459                                  
  2460                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  2461                                  
  2462 00000478 8826[E80A]              	mov	[CRIT_ERR_INFO],ah	; save critical error flags
  2463                                  
  2464                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  2465                                  
  2466 0000047C 0441                    	add	al,'A'
  2467 0000047E A2[9308]                	mov	[DRVLET],al
  2468                                  
  2469                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  2470                                  
  2471 00000481 F6C480                  	test	ah,80h
  2472 00000484 740A                    	jz	short NOHARDE		; it's a disk-device error
  2473 00000486 F606[CB08]80            	test	byte [CDEVAT],DEVTYP>>8 ; 80h
  2474 0000048B 7503                    	jnz	short NOHARDE		; it's a character device
  2475 0000048D E9ED01                  	jmp	FATERR			; it's a FAT error
  2476                                  
  2477                                  NOHARDE:
  2478 00000490 BE[7408]                	mov	si,MREAD		; SI = "read" msg #
  2479 00000493 F6C401                  	test	ah,1
  2480 00000496 7403                    	jz	short SAVMES		; it's a read error
  2481 00000498 BE[7C08]                	mov	si,MWRITE		; SI = "write" msg #
  2482                                  
  2483                                  SAVMES:
  2484 0000049B 893E[210C]              	mov	[OLDERRNO],di		; save critical error code
  2485                                  
  2486                                  ;	Bugbug:	don't need to save/restore all here?
  2487 0000049F 06                      	push	es
  2488 000004A0 1E                      	push	ds			; GetExtendedError likes to STOMP
  2489 000004A1 55                      	push	bp
  2490 000004A2 56                      	push	si
  2491 000004A3 52                      	push	dx
  2492 000004A4 51                      	push	cx
  2493 000004A5 53                      	push	bx
  2494 000004A6 B459                    	mov	ah,GetExtendedError ; 59h ; get extended error info
  2495 000004A8 CD21                    	int	21h
  2496 000004AA 5B                      	pop	bx
  2497 000004AB 59                      	pop	cx
  2498 000004AC 5A                      	pop	dx
  2499 000004AD 5E                      	pop	si
  2500 000004AE 5D                      	pop	bp
  2501 000004AF 1F                      	pop	ds
  2502 000004B0 893E[7D0A]              	mov	[NEEDVOL],di 	; save possible ptr to volume label
  2503 000004B4 8C06[7F0A]              	mov	[NEEDVOL+2],es
  2504 000004B8 07                      	pop	es
  2505                                  
  2506                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  2507                                  
  2508 000004B9 30E4                    	xor	ah,ah
  2509 000004BB 89C7                    	mov	di,ax			; DI = error code
  2510                                  
  2511                                  ; Bugbug:  somewhat obsolete documentation?
  2512                                  ;
  2513                                  ; DI is now the correct error code. Classify things to see what we are
  2514                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  2515                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  2516                                  ; the like) are contiguous.
  2517                                  ;
  2518                                  
  2519                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  2520                                  ;	Check use of ErrCd_24, though.
  2521                                  
  2522 000004BD 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  2523 000004C0 7303                    	jae	short HAVCOD
  2524                                  
  2525                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  2526                                  ;	even though it's not a critical error?
  2527                                  
  2528 000004C2 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  2529                                  ;
  2530                                  ; DI now has the mapped error code. Old style errors are:
  2531                                  ;   FOOBAR <read|writ>ing drive ZZ.
  2532                                  ; New style errors are:
  2533                                  ;   FOOBAR
  2534                                  ; We need to figure out which the particular error belongs to.
  2535                                  ;
  2536                                  
  2537                                  HAVCOD:
  2538 000004C5 C606[810A]00            	mov	byte [ERRTYPE],0	; assume old style
  2539 000004CA 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  2540 000004CD 7405                    	je	short SETSTYLE
  2541 000004CF 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2542 000004D2 7504                    	jne	short GOTSTYLE
  2543                                  
  2544                                  SETSTYLE:
  2545                                  ;	Bugbug:	use INC
  2546                                  	;mov	byte [ERRTYPE],1		; must be new type
  2547 000004D4 FE06[810A]              	inc	byte [ERRTYPE] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  2548                                  
  2549                                  GOTSTYLE:
  2550 000004D8 893E[8E0A]              	mov	[ERRCD_24],di
  2551                                  	; 25/09/2018
  2552                                  	; MSDOS 6.0
  2553                                  	;cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  2554                                  	; MSDOS 3.3
  2555 000004DC 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2556                                  
  2557                                  						; If the error message is unknown
  2558 000004DF 7641                    	jbe	short NORMALERROR		;  redirector, continue. Otherwise,
  2559                                  ;
  2560                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  2561                                  ; how to handle things
  2562                                  ;
  2563                                  
  2564                                  ;input to IFSFUNC:    AL=1
  2565                                  ;		      BX=extended error number
  2566                                  ;
  2567                                  ;output from IFSFUNC: AL=error type (0 or 1)
  2568                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  2569                                  ;			   Abort, Retry, Ignore
  2570                                  ;			 1=<message>
  2571                                  ;			   Abort, Retry, Ignore
  2572                                  ;		      ES:DI=pointer to message text
  2573                                  ;		      carry set=>no message
  2574                                  
  2575 000004E1 89C7                    	mov	di,ax			; retrieve correct extended error...
  2576 000004E3 B80005                  	mov	ax,0500h		; is the redir there?
  2577 000004E6 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  2578                                  			; Return: AL = 00h not installed, OK to install
  2579                                  			; 01h not installed, can't install
  2580                                  			; FFh installed
  2581 000004E8 3CFF                    	cmp	al,0FFh
  2582 000004EA 7529                    	jne	short NOHANDLER		; no, go to NoHandler
  2583                                  
  2584                                  	; MSDOS 6.0
  2585                                  	;push	bx
  2586                                  	;mov	bx,di			; get ErrType and ptr to error msg
  2587                                  	;mov	ax,0501h
  2588 000004EC CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2589                                  	;pop	bx 
  2590                                  	;jc	short NOHANDLER
  2591                                  	; MSDOS 3.3
  2592 000004EE 89F8                    	mov     ax,di
  2593 000004F0 B405                    	mov     ah,5
  2594 000004F2 CD2F                    	int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2595 000004F4 721F                    	jc      short NOHANDLER
  2596                                  
  2597                                  ;	Bugbug:	need to record error type?
  2598 000004F6 A2[810A]                	mov	[ERRTYPE],al
  2599 000004F9 1E                      	push	ds
  2600 000004FA 06                      	push	es
  2601 000004FB 1F                      	pop	ds
  2602 000004FC 89FA                    	mov	dx,di
  2603 000004FE B9FFFF                  	mov	cx,-1			; find end of msg
  2604 00000501 30C0                    	xor	al,al
  2605                                  
  2606 00000503 FC                      	cld
  2607 00000504 F2AE                    	repnz	scasb
  2608                                  
  2609                                  ;	Bugbug:	we can do better than this.
  2610                                  
  2611 00000506 C645FF24                	mov	byte [di-1],'$'
  2612                                  	
  2613                                  	;CALL	RDISPMSG ; MSDOS 3.3
  2614                                  	
  2615 0000050A B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  2616 0000050C CD21                    	int	21h
  2617                                  
  2618 0000050E C645FF00                	mov	byte [di-1],0			; restore terminal byte
  2619                                  
  2620 00000512 1F                      	pop	ds				; clean up and continue
  2621 00000513 EB18                    	jmp	short CHECKERRTYPE
  2622                                  
  2623                                  ;*	Redir isn't available or doesn't recognize the error.
  2624                                  ;	Restore regs to unextended error.
  2625                                  
  2626                                  NOHANDLER:
  2627 00000515 C606[810A]00            	mov	byte [ERRTYPE],0
  2628                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  2629 0000051A 8B3E[210C]              	mov	di,[OLDERRNO]
  2630 0000051E 893E[8E0A]              	mov	[ERRCD_24],di
  2631                                  
  2632                                  NORMALERROR:
  2633                                  	; MSDOS 6.0
  2634                                  	;add	di,ERROR_WRITE_PROTECT
  2635                                  	;xchg	di,dx			; may need dx later
  2636                                  	;call	RPrintCrit		; print error type
  2637                                  
  2638                                  	; MSDOS 3.3
  2639 00000522 D1E7                    	shl     di,1
  2640 00000524 8BBD[3C07]              	mov     di,[CRMSGTBL+di]
  2641 00000528 87FA                    	xchg    di,dx
  2642 0000052A E86301                  	call    RDISPMSG
  2643                                  
  2644                                  CHECKERRTYPE:
  2645 0000052D 803E[810A]00            	cmp	byte [ERRTYPE],0	; Check error style...
  2646 00000532 7418                    	je	short CONTOLD
  2647 00000534 E85601                  	call	CRLF			; if new style then done printing
  2648 00000537 EB2C                    	jmp	short ASK
  2649                                  
  2650                                  	; 02/03/2023
  2651                                  BLKERR:
  2652                                  	; MSDOS 6.0
  2653                                  	;mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
  2654                                  	;mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
  2655                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  2656                                  	;call	RPrint
  2657                                  
  2658                                  	; MSDOS 3.3
  2659 00000539 BA[8C08]                	mov     dx,BLKDEVERR
  2660 0000053C E85101                  	call    RDISPMSG
  2661                                  
  2662 0000053F 803E[920A]00            	cmp	byte [LOADING],0
  2663 00000544 741F                    	jz	short ASK
  2664 00000546 E8C3FD                  	call	RESTHAND
  2665 00000549 E9BAFD                  	jmp	GETCOMDSK2		; if error loading COMMAND, re-prompt
  2666                                  
  2667                                  CONTOLD:
  2668                                  	; MSDOS 6.0
  2669                                  ;	inc	si			; DS:SI = ptr to asciiz string
  2670                                  ;
  2671                                  ;;	Bugbug:	combine some of the following two sections?
  2672                                  ;
  2673                                  ;	test	[CDevAt],DEVTYP shr 8
  2674                                  ;	jz	BlkErr
  2675                                  ;	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
  2676                                  ;	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
  2677                                  ;	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  2678                                  ;
  2679                                  ;	call	RPrint				; print the message
  2680                                  ;	jmp	short Ask			; don't ralph on command
  2681                                  
  2682                                  	; MSDOS 3.3
  2683 0000054C BA[8408]                	mov	dx,ERRMES
  2684 0000054F E83E01                  	call	RDISPMSG
  2685 00000552 89F2                    	mov	dx,si
  2686 00000554 E83901                  	call	RDISPMSG
  2687                                  	
  2688 00000557 F606[CB08]80            	test	byte [CDEVAT], 80h
  2689 0000055C 74DB                    	jz	short BLKERR
  2690 0000055E BA[9708]                	mov	dx,CHARDEVERR	; " device "
  2691 00000561 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  2692 00000563 CD21                    	int	21h		; DOS - PRINT STRING
  2693                                  				; DS:DX -> string terminated by "$"
  2694                                  	; 02/03/2023
  2695                                  	;jmp	short ASK
  2696                                  
  2697                                  ; 02/03/2023
  2698                                  ;BLKERR:
  2699                                  ;	; MSDOS 6.0
  2700                                  ;	;mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
  2701                                  ;	;mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
  2702                                  ;	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  2703                                  ;	;call	RPrint
  2704                                  ;
  2705                                  ;	; MSDOS 3.3
  2706                                  ;	mov     dx,BLKDEVERR
  2707                                  ;	call    RDISPMSG
  2708                                  ;
  2709                                  ;	cmp	byte [LOADING],0
  2710                                  ;	jz	short ASK
  2711                                  ;	call	RESTHAND
  2712                                  ;	jmp	GETCOMDSK2		; if error loading COMMAND, re-prompt
  2713                                  
  2714                                  ASK:
  2715 00000565 833E[8E0A]0F            	cmp	word [ERRCD_24],15	; error 15 has an extra message
  2716 0000056A 751C                    	jne	short NOT15		; not error 15
  2717                                  
  2718                                  ;*	For error 15, tell the user which volume/serial # are needed.
  2719                                  
  2720 0000056C 51                      	push	cx
  2721                                  
  2722                                  ;	Bugbug:	does this push/pop need to be done?
  2723 0000056D 1E                      	push	ds
  2724 0000056E 07                      	pop	es
  2725 0000056F C536[7D0A]              	lds	si,[NEEDVOL]
  2726                                  	;assume	ds:NOTHING
  2727 00000573 57                      	push	di
  2728 00000574 BF[6608]                	mov	di,VOLNAME
  2729                                  	; MSDOS 6.0
  2730                                  	;mov	cx,16			; copy volume name & serial #
  2731                                  	; MSDOS 3.3
  2732 00000577 B90B00                  	mov	cx,11			; copy volume name
  2733 0000057A FC                      	cld
  2734 0000057B F3A4                    	rep	movsb
  2735 0000057D 5F                      	pop	di
  2736 0000057E 06                      	push	es
  2737 0000057F 1F                      	pop	ds
  2738 00000580 59                      	pop	cx
  2739                                  	;assume	ds:DATARES
  2740                                  	; MSDOS 6.0
  2741                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  2742                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  2743                                  	;call	RPrint
  2744                                  
  2745                                  	; MSDOS 3.3
  2746 00000581 BA[5308]                	mov	dx,NEEDVOLMSG
  2747 00000584 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2748 00000586 CD21                    	int     21h             ; DOS - PRINT STRING
  2749                                  				; DS:DX -> string terminated by "$"
  2750                                  NOT15:
  2751                                  ;*	Print abort, retry, ignore, fail message.
  2752                                  ;	Print only options that are valid.
  2753                                  
  2754                                  ;	Bugbug:	sizzle this.
  2755                                  
  2756 00000588 BA[AA08]                	mov	dx,REQ_ABORT
  2757                                  	;call	RPrint
  2758 0000058B E80201                  	call	RDISPMSG
  2759 0000058E F606[E80A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED  ; 10h
  2760 00000593 7406                    	jz	short TRY_IGNORE
  2761 00000595 BA[B008]                	mov	dx,REQ_RETRY
  2762                                  	;call	RPrint
  2763 00000598 E8F500                  	call	RDISPMSG
  2764                                  TRY_IGNORE:
  2765 0000059B F606[E80A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h
  2766 000005A0 7406                    	jz	short TRY_FAIL
  2767 000005A2 BA[B808]                	mov	dx,REQ_IGNORE
  2768                                  	;call	RPrint
  2769 000005A5 E8E800                  	call	RDISPMSG
  2770                                  TRY_FAIL:
  2771 000005A8 F606[E80A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED   ; 08h
  2772 000005AD 7406                    	jz	short TERM_QUESTION
  2773 000005AF BA[C108]                	mov	dx,REQ_FAIL
  2774                                  	;call	RPrint
  2775 000005B2 E8DB00                  	call	RDISPMSG
  2776                                  TERM_QUESTION:
  2777 000005B5 BA[C808]                	mov	dx,REQ_END
  2778                                  	;call	RPrint
  2779 000005B8 E8D500                  	call	RDISPMSG
  2780                                  
  2781                                  ;	If the /f switch was given, we fail all requests.
  2782                                  
  2783 000005BB F606[F30A]FF            	test	byte [FFAIL],-1
  2784 000005C0 7405                    	jz	short DOPROMPT
  2785 000005C2 B403                    	mov	ah,3				; signal fail
  2786 000005C4 E9AA00                  	jmp	EEXIT
  2787                                  
  2788                                  DOPROMPT:
  2789 000005C7 B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  2790 000005CA CD21                    	int	21h				; get response
  2791                                  
  2792 000005CC E8BE00                  	call	CRLF
  2793 000005CF E8C600                  	call	CHARTOUPPER			; convert to upper case
  2794 000005D2 B400                    	mov	ah,0				; return code for ignore
  2795 000005D4 F606[E80A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  2796 000005D9 7406                    	jz	short USER_RETRY
  2797 000005DB 3A06[7B0A]              	cmp	al,[IGNORE_CHAR]		; ignore?
  2798 000005DF 7429                    	jz	short EEXITJ
  2799                                  
  2800                                  ;	Bugbug:	optimize following code.
  2801                                  
  2802                                  USER_RETRY:
  2803 000005E1 FEC4                    	inc	ah				; return code for retry
  2804 000005E3 F606[E80A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED ; 10h ; is retry allowed?
  2805 000005E8 7406                    	jz	short USER_ABORT
  2806 000005EA 3A06[790A]              	cmp	al,[RETRY_CHAR]			; retry?
  2807 000005EE 741A                    	jz	short EEXITJ
  2808                                  
  2809                                  USER_ABORT:
  2810 000005F0 FEC4                    	inc	ah				; return code for abort
  2811                                  						;  (abort always allowed)
  2812 000005F2 3A06[7A0A]              	cmp	al,[ABORT_CHAR]			; abort?
  2813 000005F6 7414                    	jz	short ABORT_PROCESS			; exit user program
  2814 000005F8 FEC4                    	inc	ah				; return code for fail
  2815 000005FA F606[E80A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED ; 08h ; is fail allowed?
  2816 000005FF 7406                    	jz	short ASKJ
  2817 00000601 3A06[7C0A]              	cmp	al,[FAIL_CHAR]			; fail?
  2818 00000605 7403                    	jz	short EEXITJ
  2819                                  ASKJ:
  2820 00000607 E95BFF                  	jmp	ASK
  2821                                  
  2822                                  EEXITJ:
  2823 0000060A EB65                    	jmp	short EEXIT
  2824                                  
  2825                                  ABORT_PROCESS:
  2826 0000060C F606[550B]01            	test	byte [INITFLAG],INITINIT ; 1	; COMMAND init interrupted?
  2827 00000611 741A                    	jz	short ABORTCONT			; no, handle it normally
  2828 00000613 803E[EE0A]00            	cmp	byte [PERMCOM],0		; are we top level process?
  2829 00000618 7408                    	jz	short JUSTEXIT			; yes, just exit
  2830                                  
  2831 0000061A BA[480A]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  2832                                  	;call	RPrint				; print it
  2833 0000061D E87000                  	call	RDISPMSG
  2834                                  
  2835                                  DEADINTHEWATER:
  2836 00000620 EBFE                    	jmp	short DEADINTHEWATER		; loop until the user reboots
  2837                                  
  2838                                  JUSTEXIT:
  2839                                  	;assume	ds:DATARES
  2840 00000622 A1[880A]                	mov	ax,[PARENT]			; load real parent pid
  2841 00000625 A31600                  	mov	[PDB.PARENT_PID],ax ; mov ds:16h,ax ; put it back where it belongs
  2842 00000628 B8FF4C                  	mov	ax,(EXIT<<8) | 255 ; 4CFFh
  2843 0000062B CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  2844                                  				; AL = exit code
  2845                                  ABORTCONT:
  2846 0000062D F606[DE0A]FF            	test	byte [IN_BATCH],-1		; Are we accessing a batch file?
  2847 00000632 7405                    	jz	short NOT_BATCH_ABORT
  2848 00000634 C606[DF0A]01            	mov	byte [BATCH_ABORT],1		; set flag for abort
  2849                                  NOT_BATCH_ABORT:
  2850 00000639 8A16[560B]              	mov	dl,[PIPEFLAG]
  2851 0000063D E8BBFA                  	call	RESPIPEOFF
  2852 00000640 08D2                    	or	dl,dl
  2853 00000642 740D                    	je	short CHECKFORA
  2854 00000644 833E[EF0A]00            	cmp	word [SINGLECOM],0
  2855 00000649 7406                    	je	short CHECKFORA
  2856 0000064B C706[EF0A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2857                                  CHECKFORA:
  2858 00000651 833E[8E0A]00            	cmp	word [ERRCD_24],0		; write protect?
  2859 00000656 7407                    	je	short ABORTFOR
  2860 00000658 833E[8E0A]02            	cmp	word [ERRCD_24],2		; drive not ready?
  2861 0000065D 7512                    	jne	short EEXIT			; don't abort the FOR
  2862                                  ABORTFOR:
  2863 0000065F C606[F50A]00            	mov	byte [FORFLAG],0		; abort a FOR in progress
  2864 00000664 833E[EF0A]00            	cmp	word [SINGLECOM],0
  2865 00000669 7406                    	je	short EEXIT
  2866 0000066B C706[EF0A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2867                                  EEXIT:
  2868 00000671 88E0                    	mov	al,ah
  2869 00000673 89FA                    	mov	dx,di
  2870                                  RESTHD:
  2871 00000675 E894FC                  	call    RESTHAND
  2872 00000678 59                      	pop	cx
  2873 00000679 5E                      	pop	si				; restore registers
  2874 0000067A 07                      	pop	es
  2875                                  	
  2876                                  ;	; MSDOS 6.0
  2877                                  ;;;	pop	ds
  2878                                  ;;SR;
  2879                                  ;; ds has to be got from the variable we saved it in
  2880                                  ;;
  2881                                  ;
  2882                                  ; 	mov	ds,OldDS			;restore old value of ds
  2883                                  ;;	pop	ds
  2884                                  ;	assume	ds:nothing
  2885                                  
  2886                                  	; MSDOS 3.3
  2887 0000067B 1F                      	pop	ds
  2888                                  
  2889 0000067C CF                      	iret
  2890                                  
  2891                                  FATERR:
  2892                                  	; MSDOS 6.0
  2893                                  	;mov	dx,offset DATARES:BadFatMsg
  2894                                  	;mov	si,offset DATARES:BadFatSubst
  2895                                  	;call	RPrint
  2896                                  
  2897                                  	; MSDOS 3.3
  2898 0000067D BA[CC08]                	mov     dx,BADFATMSG
  2899 00000680 E80D00                  	call    RDISPMSG
  2900 00000683 BA[8C08]                	mov     dx,BLKDEVERR
  2901 00000686 E80700                  	call    RDISPMSG
  2902                                  
  2903 00000689 B002                    	mov	al,2				; abort
  2904 0000068B EBE8                    	jmp	short RESTHD
  2905                                  
  2906                                  ;DskErr	endp
  2907                                  
  2908                                  	; MSDOS 6.0
  2909                                  ;***	RPrint - print message
  2910                                  ;***	Crlf - display cr/lf
  2911                                  ;
  2912                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  2913                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  2914                                  ;		variable fields related to substitution blocks are set
  2915                                  ;
  2916                                  ;	EXIT	nothing
  2917                                  ;
  2918                                  ;	USED	flags
  2919                                  ;
  2920                                  ;	EFFECTS
  2921                                  ;	  Message is displayed on stdout.
  2922                                  ;
  2923                                  ;	NOTE
  2924                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  2925                                  ;	    be greater than number of substition blocks present.
  2926                                  
  2927                                  ;
  2928                                  ;Crlf: 
  2929                                  ;	mov	dx,offset DATARES:Newlin	; cheap newline
  2930                                  ;
  2931                                  ;RPrint	proc
  2932                                  ;
  2933                                  ;	assume	ds:DATARES,ss:DATARES
  2934                                  ;
  2935                                  ;;	Bugbug:	do we need to save all reg's?
  2936                                  ;
  2937                                  ;	push	si			; preserve registers
  2938                                  ;	push	ax
  2939                                  ;	push	bx
  2940                                  ;	push	cx
  2941                                  ;	push	dx
  2942                                  ;
  2943                                  ;	mov	bx,si			; DS:BX = ptr to subst block
  2944                                  ;	mov	si,dx			; DS:SI = ptr to count byte
  2945                                  ;	lodsb				; AL = message length
  2946                                  ;					; DS:SI = ptr to message text
  2947                                  ;	xor	cx,cx
  2948                                  ;	mov	cl,al			; CX = message length
  2949                                  ;	jcxz	rpRet
  2950                                  ;
  2951                                  ;	call	RDispMsg
  2952                                  ;
  2953                                  ;rpRet:	pop	dx
  2954                                  ;	pop	cx
  2955                                  ;	pop	bx
  2956                                  ;	pop	ax
  2957                                  ;	pop	si
  2958                                  ;	ret
  2959                                  ;
  2960                                  ;RPrint	endp
  2961                                  
  2962                                  	; MSDOS 3.3
  2963                                  CRLF:
  2964 0000068D BA[9408]                	mov     dx,NEWLIN
  2965                                  
  2966                                  RDISPMSG: ; Display message/text
  2967                                  	; DS:DX = ($ terminated) Message/Text address 
  2968 00000690 50                      	push    ax
  2969 00000691 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2970 00000693 F8                      	clc
  2971 00000694 CD21                    	int     21h             ; DOS - PRINT STRING
  2972                                  				; DS:DX -> string terminated by "$"
  2973 00000696 58                      	pop     ax
  2974 00000697 C3                      	retn
  2975                                  
  2976                                  	; MSDOS 6.0
  2977                                  
  2978                                  ;***	RPrintCrit - print critical error message
  2979                                  ;
  2980                                  ;	ENTRY	DX = extended error # (19-39)
  2981                                  ;
  2982                                  ;	EXIT	nothing
  2983                                  ;
  2984                                  ;	USED	flags
  2985                                  ;
  2986                                  ;	EFFECTS
  2987                                  ;	  Message is displayed on stdout
  2988                                  
  2989                                  ;RPrintCrit	proc
  2990                                  ;
  2991                                  ;	assume	ds:DATARES,ss:DATARES
  2992                                  ;
  2993                                  ;	push	dx			; preserve DX
  2994                                  ;	xchg	bx,dx			; BX = extended error #
  2995                                  ;					; DX = saved BX
  2996                                  ;	sub	bx,19			; BX = critical error index, from 0
  2997                                  ;	shl	bx,1			; BX = offset in word table
  2998                                  ;	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
  2999                                  ;	xchg	bx,dx			; DX = ptr to error msg
  3000                                  ;					; BX = restored
  3001                                  ;	call	RPrint			; print the message
  3002                                  ;	pop	dx			; restore DX
  3003                                  ;	ret
  3004                                  ;
  3005                                  ;RPrintCrit	endp
  3006                                  
  3007                                  
  3008                                  ;***	RDispMsg - display message
  3009                                  ;
  3010                                  ;	Display message, with substitutions, for RPrint.
  3011                                  ;
  3012                                  ;	ENTRY	DS:SI = ptr to message text
  3013                                  ;		CX = message length
  3014                                  ;		DS:BX = ptr to substitution block, if any
  3015                                  ;
  3016                                  ;	EXIT	nothing
  3017                                  ;
  3018                                  ;	USED	AX,CX,DX,SI
  3019                                  
  3020                                  ;RDispMsg	proc
  3021                                  ;
  3022                                  ;	assume	ds:DATARES,ss:DATARES
  3023                                  ;
  3024                                  ;rdNextChar:
  3025                                  ;	lodsb				; AL = next char
  3026                                  ;	cmp	al,'%'
  3027                                  ;	jne	rdOutChar		; not a substitution
  3028                                  ;	mov	dl,ds:[si]		; DL = possible '1' - '9'
  3029                                  ;	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  3030                                  ;	cmp	dl,9
  3031                                  ;	jae	rdOutChar		; not a substitution
  3032                                  ;
  3033                                  ;;*	A substitution code %1 - %9 has been encountered.
  3034                                  ;;	DL = 0-8, indicating %1-%9
  3035                                  ;;	DS:BX = ptr to substitution block
  3036                                  ;
  3037                                  ;	call	SubstMsg		; display the substitution
  3038                                  ;	inc	si			; SI = ptr past %n
  3039                                  ;	dec	cx			; count extra character in %n
  3040                                  ;	jmp	short rdCharDone
  3041                                  ;
  3042                                  ;;*	Normal character output.
  3043                                  ;
  3044                                  ;rdOutChar:
  3045                                  ;	mov	dl,al			; DL = char
  3046                                  ;	mov	ah,2			; AH = DOS Character Output code
  3047                                  ;	int	21h			; call DOS
  3048                                  ;rdCharDone:
  3049                                  ;	loop	rdNextChar
  3050                                  ;	ret
  3051                                  ;
  3052                                  ;RDispMsg	endp
  3053                                  
  3054                                  ;***	SubstMsg - display message substitution
  3055                                  ;
  3056                                  ;	Display a substitution string within a message.
  3057                                  ;	Substitution can be a char, an ASCIIZ string, or
  3058                                  ;	a word to be displayed as hex digits.
  3059                                  ;
  3060                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  3061                                  ;		DS:BX = ptr to substitution block
  3062                                  ;
  3063                                  ;	EXIT	nothing
  3064                                  ;
  3065                                  ;	USED	AX,DX
  3066                                  
  3067                                  ;SubstMsg	proc
  3068                                  ;
  3069                                  ;	assume	ds:DATARES,ss:DATARES
  3070                                  ;
  3071                                  ;	push	bx			; preserve BX
  3072                                  ;	push	cx			; preserve CX
  3073                                  ;
  3074                                  ;	mov	al,size SUBST		; AL = size of substitution block
  3075                                  ;	mul	dl			; AX = offset of desired subst block
  3076                                  ;	add	bx,ax			; DS:BX = ptr to desired subst block
  3077                                  ;
  3078                                  ;	mov	al,[bx].SubstType	; AX = substitution type flag
  3079                                  ;	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  3080                                  ;
  3081                                  ;;	AL = 1, 2, or 3 for char, string, or hex type
  3082                                  ;
  3083                                  ;	dec	al
  3084                                  ;	jz	smChar
  3085                                  ;	dec	al
  3086                                  ;	jz	smStr
  3087                                  ;
  3088                                  ;;*	Hex number substitution.
  3089                                  ;
  3090                                  ;	mov	ax,ds:[bx]		; AX = word value
  3091                                  ;	mov	cx,4			; CX = # digits to display
  3092                                  ;smDigit:
  3093                                  ;	rol	ax,1
  3094                                  ;	rol	ax,1
  3095                                  ;	rol	ax,1
  3096                                  ;	rol	ax,1			; AL<3:0> = next digit
  3097                                  ;
  3098                                  ;	push	ax			; save other digits
  3099                                  ;	and	al,0Fh			; AL = binary digit
  3100                                  ;	add	al,'0'			; AL = ascii digit if 0-9
  3101                                  ;	cmp	al,'9'
  3102                                  ;	jbe	@F			; it's 0-9
  3103                                  ;	add	al,'A' - '0' - 10	; AL = ascii digit A-F
  3104                                  ;@@:
  3105                                  ;	mov	dl,al			; DL = ascii digit
  3106                                  ;	mov	ah,2
  3107                                  ;	int	21h			; output the ascii digit
  3108                                  ;	pop	ax			; restore all digits
  3109                                  ;
  3110                                  ;	loop	smDigit
  3111                                  ;	jmp	short smRet
  3112                                  ;
  3113                                  ;;*	Char substitution.
  3114                                  ;
  3115                                  ;smChar:
  3116                                  ;	mov	dl,ds:[bx]		; DL = char to output
  3117                                  ;	mov	ah,2
  3118                                  ;	int	21h
  3119                                  ;	jmp	short smRet
  3120                                  ;
  3121                                  ;;*	String substitution.
  3122                                  ;
  3123                                  ;smStr:
  3124                                  ;	mov	dl,ds:[bx]		; DL = next char
  3125                                  ;	or	dl,dl
  3126                                  ;	jz	smRet			; null char - we're done
  3127                                  ;	mov	ah,2
  3128                                  ;	int	21h			; display char
  3129                                  ;	inc	bx			; DS:BX = ptr to next char
  3130                                  ;	jmp	smStr
  3131                                  ;
  3132                                  ;smRet:	pop	cx
  3133                                  ;	pop	bx
  3134                                  ;	ret
  3135                                  ;
  3136                                  ;SubstMsg	endp
  3137                                  
  3138                                  
  3139                                  	; MSDOS 6.0
  3140                                  
  3141                                  ;***	CharToUpper - convert character to uppercase
  3142                                  ;
  3143                                  ;	ENTRY	AL = char
  3144                                  ;
  3145                                  ;	EXIT	AL = uppercase char
  3146                                  ;
  3147                                  ;	USED	AX
  3148                                  
  3149                                  ;CharToUpper	proc
  3150                                  ;
  3151                                  ;	assume	ds:DATARES
  3152                                  ;
  3153                                  ;	push	ax		; put char on stack as arg to int 2F
  3154                                  ;	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  3155                                  ;	int	2Fh
  3156                                  ;	inc	sp		; throw away old char on stack
  3157                                  ;	inc	sp
  3158                                  ;	ret
  3159                                  ;
  3160                                  ;CharToUpper	endp
  3161                                  
  3162                                  	; MSDOS 3.3
  3163                                  CHARTOUPPER:
  3164 00000698 3C80                    	cmp	al,80h
  3165 0000069A 7210                    	jb	short CHARTOUPPER1
  3166 0000069C 2C80                    	sub	al,80h
  3167 0000069E 1E                      	push	ds
  3168 0000069F 53                      	push	bx
  3169 000006A0 C51E[000B]              	lds	bx,[UPPERCASETBL]
  3170 000006A4 83C302                  	add	bx,2
  3171 000006A7 D7                      	xlat
  3172 000006A8 5B                      	pop	bx
  3173 000006A9 1F                      	pop	ds
  3174 000006AA EB0A                    	jmp	short CHARTOUPPER_RETN
  3175                                  CHARTOUPPER1:
  3176 000006AC 3C61                    	cmp	al,'a'
  3177 000006AE 7206                    	jb	short CHARTOUPPER_RETN
  3178 000006B0 3C7A                    	cmp	al,'z'
  3179 000006B2 7702                    	ja	short CHARTOUPPER_RETN
  3180 000006B4 2C20                    	sub	al,20h
  3181                                  CHARTOUPPER_RETN:
  3182 000006B6 C3                      	retn
  3183                                  
  3184                                  ;public	EndCode
  3185                                  ;EndCode label	byte
  3186                                  
  3187                                  ;=============================================================================
  3188                                  ; RDATA.ASM, MSDOS 6.0, 1991
  3189                                  ;=============================================================================
  3190                                  ; 22/09/2018 - Retro DOS v3.0
  3191                                  
  3192                                  ;NOTE: This initialized rezident data is just as rezident data section/portion
  3193                                  ;      of the disassembled MSDOS 3.3 COMMAND.COM code.
  3194                                  ;   (MSDOS 6.0 RDATA.ASM is used for comments & descriptions about the RDATA.) 
  3195                                  
  3196                                  ; RDATA section of Retro DOS v2.0 'command2.s' (05/05/2018) has been modified 
  3197                                  ; for 'command3.s' (22/09/2018), here:
  3198                                  
  3199 000006B7 90                      ALIGN 2
  3200                                  	; 22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3201                                  RSTACK_SPACE:
  3202 000006B8 00<rep 80h>             	times 128 db 0
  3203                                  RSTACK:
  3204 00000738 0000                    	dw 	0
  3205                                  
  3206                                  	; 25/09/2018	
  3207                                  	; (filler)
  3208 0000073A 0000                    	dW	0
  3209                                  
  3210                                  RDATA	EQU	$
  3211                                  
  3212                                  ;TITLE   COMMAND Resident DATA
  3213                                  
  3214                                  ; Data for resident portion
  3215                                  
  3216                                  ;DATARES SEGMENT PUBLIC BYTE
  3217                                  
  3218                                  	;ORG     0
  3219                                  ;ZERO    =       $
  3220                                  
  3221                                  CRMSGTBL:
  3222 0000073C [6007]                  	dw	CRMSG0		; "Write protect$"
  3223 0000073E [6E07]                  	dw	CRMSG1		; "Bad unit$"
  3224 00000740 [7707]                  	dw	CRMSG2		; "Not ready$"
  3225 00000742 [8107]                  	dw	CRMSG3		; "Bad command $"
  3226 00000744 [8E07]                  	dw	CRMSG4		; "Data$"
  3227 00000746 [9307]                  	dw	CRMSG5		; "Bad call format$"
  3228 00000748 [A307]                  	dw	CRMSG6		; "Seek$"
  3229 0000074A [A807]                  	dw	CRMSG7		; "Non-DOS disk$"
  3230 0000074C [B507]                  	dw	CRMSG8		; "Sector not found$"
  3231 0000074E [C607]                  	dw	CRMSG9		; "No paper$"
  3232 00000750 [CF07]                  	dw	CRMSG10		; "Write fault$"
  3233 00000752 [DB07]                  	dw	CRMSG11		; "Read fault$"
  3234 00000754 [E607]                  	dw	CRMSG12		; "General Failure$"
  3235 00000756 [F607]                  	dw	CRMSG13		; "Sharing Violation$"
  3236 00000758 [0808]                  	dw	CRMSG14		; "Lock Violation$"
  3237 0000075A [1708]                  	dw	CRMSG15		; "Invalid Disk Change$"
  3238 0000075C [2B08]                  	dw	CRMSG16		; "FCB unavailable$"
  3239 0000075E [3B08]                  	dw	CRMSG17		; "Sharing buffer exceeded$"
  3240                                  
  3241 00000760 57726974652070726F-     CRMSG0:	 db 'Write protect$'
  3241 00000769 7465637424         
  3242 0000076E 42616420756E697424      CRMSG1:	 db 'Bad unit$'
  3243 00000777 4E6F74207265616479-     CRMSG2:	 db 'Not ready$'
  3243 00000780 24                 
  3244 00000781 42616420636F6D6D61-     CRMSG3:	 db 'Bad command $'
  3244 0000078A 6E642024           
  3245 0000078E 4461746124              CRMSG4:	 db 'Data$'
  3246 00000793 4261642063616C6C20-     CRMSG5:	 db 'Bad call format$'
  3246 0000079C 666F726D617424     
  3247 000007A3 5365656B24              CRMSG6:	 db 'Seek$'
  3248 000007A8 4E6F6E2D444F532064-     CRMSG7:	 db 'Non-DOS disk$'
  3248 000007B1 69736B24           
  3249 000007B5 536563746F72206E6F-     CRMSG8:	 db 'Sector not found$'
  3249 000007BE 7420666F756E6424   
  3250 000007C6 4E6F20706170657224      CRMSG9:	 db 'No paper$'
  3251 000007CF 577269746520666175-     CRMSG10: db 'Write fault$'
  3251 000007D8 6C7424             
  3252 000007DB 52656164206661756C-     CRMSG11: db 'Read fault$'
  3252 000007E4 7424               
  3253 000007E6 47656E6572616C2046-     CRMSG12: db 'General Failure$'
  3253 000007EF 61696C75726524     
  3254 000007F6 53686172696E672056-     CRMSG13: db 'Sharing Violation$'
  3254 000007FF 696F6C6174696F6E24 
  3255 00000808 4C6F636B2056696F6C-     CRMSG14: db 'Lock Violation$'
  3255 00000811 6174696F6E24       
  3256 00000817 496E76616C69642044-     CRMSG15: db 'Invalid Disk Change$'
  3256 00000820 69736B204368616E67-
  3256 00000829 6524               
  3257 0000082B 46434220756E617661-     CRMSG16: db 'FCB unavailable$'
  3257 00000834 696C61626C6524     
  3258 0000083B 53686172696E672062-     CRMSG17: db 'Sharing buffer exceeded$'
  3258 00000844 756666657220657863-
  3258 0000084D 656564656424       
  3259                                  
  3260 00000853 506C6561736520496E-     NEEDVOLMSG:	db 'Please Insert disk '
  3260 0000085C 73657274206469736B-
  3260 00000865 20                 
  3261 00000866 00<rep Bh>              VOLNAME: times 11 db 0	; db 0Bh dup(0)
  3262 00000871 0D0A24                  		db 0Dh,0Ah,'$'
  3263 00000874 72656164696E6724        MREAD:		db 'reading$'
  3264 0000087C 77726974696E6724        MWRITE:		db 'writing$'
  3265 00000884 206572726F722024        ERRMES:		db ' error $'
  3266 0000088C 20647269766520          BLKDEVERR:	db ' drive '
  3267 00000893 41                      DRVLET:		db 'A'
  3268 00000894 0D0A24                  NEWLIN:		db 0Dh,0Ah,'$'
  3269 00000897 2064657669636520        CHARDEVERR:	db ' device '
  3270 0000089F 00<rep 8h>              DEVNAME: times 8 db 0 ; db 8 dup(0)
  3271 000008A7 0D0A24                  		db 0Dh,0Ah,'$'
  3272 000008AA 41626F727424            REQ_ABORT:	db 'Abort$'
  3273 000008B0 2C20526574727924        REQ_RETRY:	db ', Retry$'
  3274 000008B8 2C2049676E6F726524      REQ_IGNORE:	db ', Ignore$'
  3275 000008C1 2C204661696C24          REQ_FAIL:	db ', Fail$'
  3276 000008C8 3F2024                  REQ_END:	db '? $'
  3277 000008CB 00                      CDEVAT:		db 0
  3278 000008CC 0D0A46696C6520616C-     BADFATMSG:	db 0Dh,0Ah,'File allocation table bad,$'
  3278 000008D5 6C6F636174696F6E20-
  3278 000008DE 7461626C6520626164-
  3278 000008E7 2C24               
  3279 000008E9 0D0A496E76616C6964-     COMBAD:		db 0Dh,0Ah,'Invalid COMMAND.COM',0Dh,0Ah,'$'
  3279 000008F2 20434F4D4D414E442E-
  3279 000008FB 434F4D0D0A24       
  3280 00000901 496E73657274206469-     PUTBACKMSG:	db 'Insert disk with $'
  3280 0000090A 736B20776974682024 
  3281 00000913 20696E206472697665-     PROMPT:		db ' in drive '
  3281 0000091C 20                 
  3282 0000091D 200D0A616E64207374-     PUTBACKDRV:	db ' ',0Dh,0Ah, 'and strike any key when ready',0Dh,0Ah,'$'
  3282 00000926 72696B6520616E7920-
  3282 0000092F 6B6579207768656E20-
  3282 00000938 72656164790D0A24   
  3283 00000940 0D0A5465726D696E61-     ENDBATMES:	db 0Dh,0Ah,'Terminate batch job (Y/N)? $'
  3283 00000949 746520626174636820-
  3283 00000952 6A6F622028592F4E29-
  3283 0000095B 3F2024             
  3284 0000095E 45584543206661696C-     EXECEMES:	db 'EXEC failure',0Dh,0Ah,'$'
  3284 00000967 7572650D0A24       
  3285 0000096D 4572726F7220696E20-     EXEBAD:		db 'Error in EXE file',0Dh,0Ah,'$'
  3285 00000976 4558452066696C650D-
  3285 0000097F 0A24               
  3286 00000981 50726F6772616D2074-     TOOBIG:		db 'Program too big to fit in memory',0Dh,0Ah,'$'
  3286 0000098A 6F6F2062696720746F-
  3286 00000993 2066697420696E206D-
  3286 0000099C 656D6F72790D0A24   
  3287 000009A4 0D0A4E6F2066726565-     NOHANDMES:	db 0Dh,0Ah,'No free file handles$'
  3287 000009AD 2066696C652068616E-
  3287 000009B6 646C657324         
  3288 000009BB 42616420436F6D6D61-     RBADNAM:	db 'Bad Command or file name',0Dh,0Ah,'$'
  3288 000009C4 6E64206F722066696C-
  3288 000009CD 65206E616D650D0A24 
  3289 000009D6 416363657373206465-     ACCDEN:		db 'Access denied',0Dh,0Ah,'$'
  3289 000009DF 6E6965640D0A24     
  3290 000009E6 0D0A4D656D6F727920-     BMEMMES:	db 0Dh,0Ah,'Memory allocation error $'
  3290 000009EF 616C6C6F636174696F-
  3290 000009F8 6E206572726F722024 
  3291 00000A01 0D0A43616E6E6F7420-     HALTMES:	db 0Dh,0Ah,'Cannot load COMMAND, system halted$'
  3291 00000A0A 6C6F616420434F4D4D-
  3291 00000A13 414E442C2073797374-
  3291 00000A1C 656D2068616C746564-
  3291 00000A25 24                 
  3292 00000A26 0D0A43616E6E6F7420-     FRETMES:	db 0Dh,0Ah,'Cannot start COMMAND, exiting',0Dh,0Ah,'$'
  3292 00000A2F 737461727420434F4D-
  3292 00000A38 4D414E442C20657869-
  3292 00000A41 74696E670D0A24     
  3293 00000A48 0D0A546F70206C6576-     PATRICIDE:	db 0Dh,0Ah,'Top level process aborted, cannot continue. $'
  3293 00000A51 656C2070726F636573-
  3293 00000A5A 732061626F72746564-
  3293 00000A63 2C2063616E6E6F7420-
  3293 00000A6C 636F6E74696E75652E-
  3293 00000A75 2024               
  3294 00000A77 59                      YES_CHAR:	db 'Y'
  3295 00000A78 4E                      NO_CHAR:	db 'N'
  3296 00000A79 52                      RETRY_CHAR:	db 'R'
  3297 00000A7A 41                      ABORT_CHAR:	db 'A'
  3298 00000A7B 49                      IGNORE_CHAR:	db 'I'
  3299 00000A7C 46                      FAIL_CHAR:	db 'F'
  3300 00000A7D 00000000                NEEDVOL:	dd 0
  3301 00000A81 00                      ERRTYPE:	db 0
  3302                                  
  3303                                  ; 22/09/2018 -  22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3304                                  
  3305                                  RETRABASE: ; 30/04/2018 (Base addr for common params, for transient portion)
  3306                                  	   ; Note: Order of following parameters must not be changed
  3307                                  	   ; without changing address references of them in 'transcom.s').	
  3308                                  
  3309 00000A82 00000000                INT_2E_RET:	DD 0		; Magic command executer return address
  3310 00000A86 0000                    SAVE_PDB:	DW 0
  3311 00000A88 0000                    PARENT:		DW 0
  3312 00000A8A 00000000                OLDTERM:	dd 0
  3313 00000A8E 0000                    ERRCD_24:	DW 0
  3314 00000A90 0000                    HANDLE01:	DW 0
  3315 00000A92 00                      LOADING:	DB 0
  3316 00000A93 0000                    BATCH:		DW 0		; Assume no batch mode initially
  3317                                  
  3318                                  ;		Bugbug:	ComSpec should be 64+3+12+1?
  3319                                  ;		What's this comspec_end about?
  3320 00000A95 00<rep 40h>             COMSPEC: times 64 DB 0
  3321 00000AD5 0000                    PUTBACKSUBSTPTR: dw 0
  3322 00000AD7 0000                    COMSPEC_END:	dw 0
  3323 00000AD9 2C01                    TRANS:		DW COMMAND
  3324 00000ADB 0000                    TRNSEG:		DW 0
  3325 00000ADD 00                      TRNMVFLG:	db 0		; set if transient portion has been moved
  3326 00000ADE 00                      IN_BATCH:	db 0		; set if we are in batch processing mode
  3327 00000ADF 00                      BATCH_ABORT:	db 0		; set if user wants to abort from batch mode
  3328                                  
  3329 00000AE0 00                      COMDRV:		DB 0		; DRIVE SPEC TO LOAD AUTOEXEC AND COMMAND
  3330 00000AE1 0000                    MEMSIZ:		DW 0
  3331 00000AE3 0000                    SUM:		DW 0
  3332 00000AE5 01                      EXTCOM:		DB 1		; For init, pretend just did an external
  3333 00000AE6 0000                    RETCODE:	DW 0
  3334 00000AE8 00                      CRIT_ERR_INFO:	db 0		; hold critical error flags for r,i,f
  3335                                  
  3336                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  3337                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  3338                                  
  3339 00000AE9 01                      ECHOFLAG:	DB 1		; low bit true => echo commands
  3340 00000AEA 01                      SUPPRESS:	db 1		; used for echo, 1=echo line
  3341 00000AEB 0000                    IO_SAVE:	DW 0
  3342 00000AED 00                      RESTDIR:	DB 0
  3343 00000AEE 00                      PERMCOM:	DB 0		; true => permanent command
  3344 00000AEF 0000                    SINGLECOM:	DW 0		; true => single command version
  3345 00000AF1 FFFF                    VERVAL:	        DW -1
  3346 00000AF3 00                      FFAIL:		db 0		; true => fail all int 24s
  3347 00000AF4 00                      IFFLAG:		db 0            ; true => IF statement in progress
  3348 00000AF5 00                      FORFLAG:	DB 0		; true => FOR statement in progress
  3349 00000AF6 0000                    FORPTR:		dw 0		
  3350 00000AF8 0000                    NEST:		dw 0		; nested batch file counter
  3351 00000AFA 00                      CALL_FLAG:	db 0		; no CALL (batch command) in progress
  3352 00000AFB 00                      CALL_BATCH_FLAG: db 0
  3353 00000AFC 0000                    NEXT_BATCH:	dw 0		; address of next batch segment
  3354 00000AFE 00                      NULLFLAG:	db 0		; flag if no command on command line
  3355                                  
  3356 00000AFF 00                      UCASE_ADDR:	db 0
  3357 00000B00 00000000                UPPERCASETBL:	dd 0
  3358                                  
  3359 00000B04 00                      RE_OUT_APP:	db 0
  3360 00000B05 00<rep 50h>             RE_OUTSTR: times (64+3+13) db 0
  3361                                  
  3362 00000B55 01                      INITFLAG:	DB INITINIT ; 1 ; 24/09/2018
  3363                                  
  3364                                  ; Note:  these two bytes are referenced as a word
  3365 00000B56 00                      PIPEFLAG:	DB 0
  3366 00000B57 00                      PIPEFILES:	DB 0
  3367                                  
  3368                                  ;--- 2.x data for piping
  3369                                  ;
  3370                                  ; All the "_" are substituted later, the one before the : is substituted
  3371                                  ; by the current drive, and the others by the CreateTemp call with the
  3372                                  ; unique file name. Note that the first 0 is the first char of the pipe
  3373                                  ; name. -MU
  3374                                  ;
  3375                                  ;--- Order-dependent, do not change
  3376                                  
  3377                                  ; MSDOS 3.3
  3378                                  
  3379 00000B58 5F3A2F                  PIPE1:		db "_:/"
  3380 00000B5B 00                      PIPE1T:		db 0
  3381 00000B5C 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3381 00000B65 5F5F00             
  3382 00000B68 5F3A2F                  PIPE2:		db "_:/"
  3383 00000B6B 00                      PIPE2T		db 0
  3384 00000B6C 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3384 00000B75 5F5F00             
  3385                                  
  3386                                  ; MSDOS 3.3 & MSDOS 6.0
  3387 00000B78 0000                    PIPEPTR:	dw 0
  3388 00000B7A 00<rep 81h>             PIPESTR: times 129 db 0
  3389                                  
  3390                                  ; MSDOS 6.0
  3391                                  
  3392                                  ;SR
  3393                                  ; Pipe1 & Pipe2 now need to store full-fledged pathnames
  3394                                  ;
  3395                                  
  3396                                  ; Bugbug:  can we find any way around maintaining these
  3397                                  ; large buffers?
  3398                                  
  3399                                  ;Pipe1		db	67+12 dup (?)
  3400                                  ;Pipe2		db	67+12 dup (?)
  3401                                  ;PipePtr 	dw	?
  3402                                  ;PipeStr 	db	129 dup (?)
  3403                                  
  3404                                  ;EndPipe	label	byte	; marks end of buffers; M004
  3405                                  
  3406 00000BFB [580B]                  INPIPEPTR:	dw PIPE1
  3407 00000BFD [680B]                  OUTPIPEPTR:	dw PIPE2
  3408                                  
  3409                                  ;EXEC_BLOCK LABEL BYTE		; The data block for EXEC calls
  3410                                  EXEC_BLOCK:
  3411 00000BFF 0000                    ENVIRSEG:	DW 0
  3412                                  ;COM_PTR LABEL	DWORD
  3413 00000C01 8000                    COM_PTR:	DW 80H		; Point at unformatted parameters
  3414 00000C03 0000                    		DW 0
  3415                                  ;COM_FCB1 LABEL	DWORD
  3416 00000C05 5C00                    COM_FCB1:      	DW 5CH
  3417 00000C07 0000                            	DW 0
  3418                                  ;COM_FCB2 LABEL	DWORD
  3419 00000C09 6C00                    COM_FCB2:	DW 6CH
  3420 00000C0B 0000                            	DW 0
  3421                                  
  3422                                  ;TRANVARS LABEL  BYTE		; Variables passed to transient
  3423                                  TRANVARS:
  3424                                  		;DW OFFSET RESGROUP:THEADFIX
  3425 00000C0D [AF02]                  		DW THEADFIX
  3426 00000C0F 0000                    MYSEG:		DW 0		; Put our own segment here
  3427 00000C11 0000                    LTPA:		DW 0		; WILL STORE TPA SEGMENT HERE
  3428 00000C13 2D                      RSWITCHAR:	DB "-"
  3429 00000C14 2F                      RDIRCHAR:	DB "/"
  3430                                          	;DW OFFSET RESGROUP:EXT_EXEC
  3431 00000C15 [2D00]                  		DW EXT_EXEC
  3432 00000C17 0000                    MYSEG1:		DW 0
  3433                                  		;DW OFFSET RESGROUP:TREMCHECK
  3434 00000C19 [9402]                  		DW TREMCHECK
  3435 00000C1B 0000                    MYSEG2:		DW 0
  3436                                  
  3437 00000C1D 0000                    RESTEST:	dw 0
  3438 00000C1F 0000                    RES_TPA:	DW 0		; original tpa (not rounded to 64k)
  3439                                  ;TRANVAREND	label	byte
  3440                                  TRANVAREND:
  3441 00000C21 0000                    OLDERRNO:	dw 0
  3442                                  
  3443                                  		; Here is Offset 0D27h in original MSDOS 3.3 COMMAND.COM
  3444                                  
  3445                                  ;DATARESEND	LABEL   BYTE
  3446                                  DATARESEND:
  3447                                  		; 22/09/2018
  3448                                  
  3449                                  ;DATARES ENDS
  3450                                  ;        END
  3451                                  
  3452                                  ;=============================================================================
  3453                                  ; COMMAND.ASM (MSDOS 2.11), ENVDATA.ASM (MSDOS 6.0)
  3454                                  ;=============================================================================
  3455                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3456                                  
  3457 00000C23 90<rep Dh>              align 16
  3458                                  
  3459                                  	; Here is Offset 0D80h in original MSDOS 3.3 COMMAND.COM
  3460                                  
  3461                                  ;ENVIRONMENT SEGMENT PUBLIC PARA        ; Default COMMAND environment
  3462                                  
  3463                                  ;	PUBLIC  ECOMSPEC,ENVIREND,PATHSTRING
  3464                                  
  3465                                          ;ORG	0
  3466                                  ;ENVARENA	DB 10H DUP (?)	; Pad for mem arena
  3467 00000C30 00<rep 10h>             ENVARENA:	TIMES 16 DB 0		
  3468                                  ENVIRONMENT:			; 30/04/2018 ('command2.s')
  3469                                  	; Here is Offset 0D90h in original MSDOS 3.3 COMMAND.COM
  3470 00000C40 504154483D              PATHSTRING:	DB "PATH="
  3471                                  ;USERPATH LABEL  BYTE
  3472 00000C45 00                      USERPATH:      	DB 0		; Null path
  3473 00000C46 434F4D535045433D                	DB "COMSPEC="
  3474 00000C4E 2F434F4D4D414E442E-     ECOMSPEC:	DB "/COMMAND.COM"
  3474 00000C57 434F4D             
  3475                                          	;DB 134 DUP (0)
  3476 00000C5A 00<rep 86h>             		TIMES	134 DB 0
  3477                                  
  3478                                  ;ENVIREND	LABEL   BYTE
  3479                                  ENVIREND:
  3480                                  	; Here is Offset 0E30h in original MSDOS 3.3 COMMAND.COM
  3481                                  	
  3482                                  ENVIRONSIZ EQU  $-PATHSTRING	; 160 = 0A0h
  3483                                  ENVIRONSIZ2 EQU $-ECOMSPEC	; 146 = 092h
  3484                                  
  3485                                  ;ENVIRONMENT ENDS
  3486                                  
  3487                                  ; ENVDATA.ASM
  3488                                  ;
  3489                                  ;/*
  3490                                  ; *                      Microsoft Confidential
  3491                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3492                                  ; *                      All Rights Reserved.
  3493                                  ; */
  3494                                  ;	SCCSID = @(#)envdata.asm	1.1 85/05/14
  3495                                  ;
  3496                                  ; This file is included by init.asm and is used as the default environment.
  3497                                  ;
  3498                                  ;
  3499                                  ;Environment Struc                       ; Default COMMAND environment
  3500                                  ;
  3501                                  ;Env_PathString  db	"path="
  3502                                  ;Env_PathSpec    db     "c:\msdos"
  3503                                  ;                db     0
  3504                                  ;Env_PrmptString db     "prompt="
  3505                                  ;Env_PrmptSpec   db     "$p$g"
  3506                                  ;                db     0
  3507                                  ;Env_ComString   db     "comspec="
  3508                                  ;Env_ComSpec     db     "\command.com"
  3509                                  ;		 db	134 dup (0)
  3510                                  ;
  3511                                  ;Environment ends
  3512                                  
  3513                                  ;MAX_COMSPEC	equ     SIZE Environment - Env_ComSpec
  3514                                  
  3515                                  MAX_COMSPEC	EQU	ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3516                                  
  3517                                  ;-----------------------------------------------------------------------------
  3518                                  ; 24/09/2018 - RetRo DOS v3.0
  3519                                  ;ENDCODE:
  3520                                  INITSTART:	; End of rezident code and data
  3521                                  		; (Offset 0E30h in original MSDOS 3.3 COMMAND.COM)
  3522                                  ;-----------------------------------------------------------------------------
  3523                                  
  3524                                  ;=============================================================================
  3525                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  3526                                  ;=============================================================================
  3527                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3528                                  
  3529                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  3530                                  
  3531                                  ;TITLE   COMMAND Initialization
  3532                                  
  3533                                  ;ENVIRONSIZ EQU  0A0H		;Must agree with values in ENVIRONMENT segment
  3534                                  ;ENVIRONSIZ2 EQU 092H
  3535                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3536                                  
  3537                                  ; UINIT.ASM, MSDOS 6.0, 1991
  3538                                  ; 23/09/2018
  3539                                  ENVBIG	EQU	32768			;AN000; maximum environment size
  3540                                  ENVSML	EQU	160			;AN000; minimum environment size
  3541                                  
  3542                                  ;-----------------------------------------------------------------------------
  3543                                  ; START OF INIT PORTION
  3544                                  ; This code is deallocated after initialization.
  3545                                  ;-----------------------------------------------------------------------------
  3546                                  
  3547                                  ;INIT    SEGMENT PUBLIC PARA
  3548                                  
  3549                                  ; 	EXTRN   HEADER:BYTE
  3550                                  ;	EXTRN   BADCOMLKMES:BYTE
  3551                                  
  3552                                  ;	PUBLIC  CONPROC
  3553                                  
  3554                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  3555                                  
  3556                                          ;ORG 0
  3557                                  ;ZERO = $
  3558                                  	; 23/09/2018
  3559                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  3560                                  
  3561                                  CONPROC:
  3562                                  	;MOV	SP,OFFSET RESGROUP:RSTACK	; must be first instruction
  3563 00000CE0 BC[3807]                	MOV	SP,RSTACK
  3564                                  ;
  3565                                  ; We need to set the PSP to us right at start because Carousel needs
  3566                                  ; to be lied to and it does not set PSP when it transfers control to
  3567                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  3568                                  ; command.com is also not lied to.
  3569                                  ;
  3570                                  	; MSDOS 6.0
  3571                                          ;mov     ah,SET_CURRENT_PDB
  3572                                          ;mov     bx,es
  3573                                          ;int     21h
  3574                                  
  3575 00000CE3 B80030                          mov     ax,GET_VERSION<<8 ; 30h
  3576 00000CE6 CD21                    	int	21h
  3577 00000CE8 3D031E                  	cmp	ax,EXPECTED_VERSION ; 1E03h
  3578 00000CEB 7412                    	je	short OKDOS			; DOS version is ok
  3579                                  
  3580 00000CED BA[5214]                	mov	dx,BADVERMSG			; DX = ptr to msg
  3581                                  	;call	RPrint
  3582                                  
  3583                                  	; MSDOS 3.3
  3584 00000CF0 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  3585 00000CF2 CD21                    	int	21h             ; DOS - PRINT STRING
  3586                                  				; DS:DX -> string terminated by "$"
  3587 00000CF4 8CC0                    	mov	ax,es
  3588 00000CF6 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  3589                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  3590 00000CFB 74FE                    HERE:	jz	short HERE			;  loop forever
  3591                                  	
  3592 00000CFD CD20                    	int	20h				; otherwise, exit
  3593                                  OKDOS:
  3594                                  	; 23/09/2018
  3595                                  ;
  3596                                  ;  Calculate and save the end of the INIT segment (which is also
  3597                                  ;  the beginning of TRANGROUP).
  3598                                  ;
  3599                                  	; MSDOS 3.3
  3600 00000CFF B465                    	mov	ah,65h
  3601 00000D01 B002                    	mov	al,2
  3602 00000D03 BAFFFF                  	mov	dx,-1
  3603 00000D06 BBFFFF                  	mov	bx,-1
  3604 00000D09 B90500                  	mov	cx,5
  3605 00000D0C BF[FF0A]                	mov	di,UCASE_ADDR
  3606 00000D0F CD21                    	int     21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  3607                                  			; AL = 02h : Get pointer to character translation table
  3608                                  			; BX = code page (-1 = current global code page)
  3609                                  			; DX = country ID (-1 = current country)
  3610                                  			; CX = amount of data to return
  3611                                  	; ES:DI = pointer to output buffer
  3612                                  	; Buffer offset :
  3613                                  	;	00h -  byte,  country Id
  3614                                  	;  	01h -  dword, pointer to uppercase table	
  3615                                  
  3616                                  	; MSDOS 6.0 (& MSDOS 3.3)
  3617 00000D11 BA[2F15]                  	mov	dx,TRANSTART+15			; get end of init code
  3618                                  	; 27/09/2018
  3619                                          ;mov	dx,TRANSTART ; (paragraph aligned address)
  3620 00000D14 B104                    	mov	cl,4				; change to paragraphs
  3621 00000D16 D3EA                            shr	dx,cl				;
  3622 00000D18 8CC8                            mov     ax,cs                           ; get current segment
  3623 00000D1A 01D0                            add     ax,dx                           ; calculate segment of end of init
  3624 00000D1C A3[DE14]                        mov     [INITEND],ax			; save this
  3625                                  
  3626 00000D1F A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h ; Init PARENT so we can exit
  3627 00000D22 A3[880A]                	mov	[PARENT],ax			    ;  correctly.
  3628 00000D25 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  3629 00000D28 A3[8A0A]                	mov	[OLDTERM],ax
  3630 00000D2B A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  3631 00000D2E A3[8C0A]                	mov	[OLDTERM+2],ax
  3632                                  
  3633                                  	;mov	ax,ENDCODE+15
  3634 00000D31 B8[EF0C]                	mov	ax,INITSTART+15 ; 24/09/2018
  3635 00000D34 B104                    	mov	cl,4				; ax = size of resident part of
  3636 00000D36 D3E8                    	shr	ax,cl				;  command in paragraphs. Add
  3637 00000D38 8CC9                    	mov	cx,cs				;  this to CS and you get the
  3638 00000D3A 01C8                    	add	ax,cx				;  segment of the TPA.
  3639                                  	
  3640 00000D3C A3[1F0C]                	mov     [RES_TPA],ax			; Temporarily save the TPA segment
  3641 00000D3F 2500F0                  	and     ax,0F000h
  3642 00000D42 050010                  	add     ax,1000h			; Round up to next 64K boundary
  3643 00000D45 7303                    	jnc     short TPA_SET			; Memory wrap if carry set
  3644 00000D47 A1[1F0C]                	mov     ax,[RES_TPA]
  3645                                  TPA_SET:
  3646 00000D4A A3[110C]                	mov	[LTPA],ax			; Good enough for the moment
  3647 00000D4D A10200                  	mov	ax,[PDB.BLOCK_LEN] ; mov ax,ds:2 ; ax = # of paras given to command
  3648                                  
  3649 00000D50 8C1E[170C]              	mov	[MYSEG1],ds			; These 3 variables are used as part of
  3650 00000D54 8C1E[1B0C]              	mov	[MYSEG2],ds			;  3 long ptrs that the transient will
  3651 00000D58 8C1E[0F0C]              	mov	[MYSEG],ds			;  use to call resident routines.
  3652                                  
  3653 00000D5C A3[E10A]                        mov     [MEMSIZ],ax			; Needed for execing other programs
  3654                                  ;
  3655                                  ; Compute maximum size of environment
  3656                                  ;
  3657                                  	;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  3658 00000D5F C706[D814]4400                  mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  3659                                  ;
  3660                                  ; Compute minimum size of environment
  3661                                  ;
  3662                                  	;mov	word [ENVSIZ],10 ; = 160/16
  3663 00000D65 C706[D614]0A00          	mov	word [ENVSIZ],ENVSML/16; 
  3664                                  
  3665                                  	;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  3666 00000D6B BA5B4C                  	mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  3667 00000D6E B104                    	mov	cl,4				;  in paragraphs.
  3668 00000D70 D3EA                    	shr	dx,cl
  3669 00000D72 8916[E014]                      mov     [TRNSIZE],dx			; save size of transient in paragraphs
  3670                                  
  3671 00000D76 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  3672 00000D78 A3[DB0A]                	mov	[TRNSEG],ax			;  = seg addr to load the transient at.
  3673 00000D7B A12C00                  	mov	ax,[PDB.ENVIRON] ; mov ax,ds:2Ch ; ax = environment segment
  3674                                  
  3675                                          ; MSDOS 6.0
  3676                                  	;mov	EnvirSeg,ax			;
  3677                                          ;or	ax,ax				; if there is no environment segment,
  3678                                          ;jz	buildenv			; make one
  3679                                  	;
  3680                                          ;cmp	FirstCom,0			; if this is the first command.com,
  3681                                  	;je	environpassed			; do a merge job (make sure COMSPEC exists)
  3682                                  
  3683                                  	; MSDOS 3.3
  3684 00000D7E 09C0                    	or	ax,ax
  3685 00000D80 7406                    	jz	short BUILDENV
  3686 00000D82 FE06[CB14]                      inc	byte [CHUCKENV]			; Flag no ENVIRONSEG
  3687 00000D86 EB0B                            jmp	short ENVIRONPASSED
  3688                                  
  3689                                  	; MSDOS 6.0
  3690                                  ;
  3691                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  3692                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  3693                                  ; size and free this buffer. We need this buffer because we no longer have an
  3694                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  3695                                  ; given on the command line before we know the environment size. This routine
  3696                                  ; will not return in case of an allocation error. It will either exit or hang
  3697                                  ; depending on whether or not this is the first COMMAND.COM or not.
  3698                                  ;
  3699                                  ;buildenv:
  3700                                  ;	call	alloc_env                       ; try to allocate buffer
  3701                                  ;environpassed:
  3702                                  ;	mov	es,ax                           ; and it load into es.
  3703                                  ;	assume	es:nothing
  3704                                  ;
  3705                                  ;gottheenvir:
  3706                                  ;;
  3707                                  ;; Initialize the command drive
  3708                                  ;;
  3709                                  	; MSDOS 3.3
  3710                                  BUILDENV:
  3711                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  3712 00000D88 B8[400C]                	mov	ax,PATHSTRING ; "PATH="
  3713 00000D8B B104                    	mov	cl,4
  3714 00000D8D D3E8                    	shr	ax,cl
  3715 00000D8F 8CDA                    	mov	dx,ds
  3716 00000D91 01D0                    	add	ax,dx
  3717                                  
  3718                                  ENVIRONPASSED:
  3719 00000D93 A3[FF0B]                	mov	[ENVIRSEG],ax
  3720                                  
  3721 00000D96 8EC0                    	mov	es,ax
  3722                                  
  3723                                  	;mov	ax,CHAR_OPER<<8
  3724 00000D98 B80037                  	mov	ax,CHAR_OPER*256 ; 3700h
  3725 00000D9B CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3726                                  			; Return: AL = FFh unsupported subfunction
  3727                                  			; DL = current switch character
  3728 00000D9D 8816[130C]              	mov	[RSWITCHAR],dl
  3729                                  
  3730                                  	; 02/03/2023
  3731 00000DA1 80FA2F                  	cmp	dl,'/'
  3732                                  	;cmp	dl,[slash_chr]
  3733 00000DA4 7510                    	jnz	short IUSESLASH
  3734 00000DA6 B05C                    	mov	al,'\'
  3735                                  	;mov	al,[bslash_chr]
  3736 00000DA8 A2[A014]                	mov	[COMSPECT],al
  3737                                  
  3738 00000DAB 803E[CB14]00            	cmp	byte [CHUCKENV],0
  3739 00000DB0 7504                    	jnz	short IUSESLASH
  3740                                  
  3741                                  	;mov	ES:[ECOMSPEC-10h],'\'
  3742                                  	; 30/04/2018
  3743                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  3744                                  	; 23/09/2018
  3745 00000DB2 26A20E00                	mov	[ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  3746                                  
  3747                                  ;gottheenvir:
  3748                                  IUSESLASH:
  3749                                  ;
  3750                                  ; Initialize the command drive
  3751                                  ;
  3752                                  	; MSDOS 3.3 & MSDOS 6.0
  3753 00000DB6 B419                    	mov	ah,GET_DEFAULT_DRIVE	; 19h
  3754 00000DB8 CD21                    	int	21h
  3755 00000DBA FEC0                    	inc	al
  3756 00000DBC A2[E00A]                	mov	[COMDRV],al
  3757                                  
  3758                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  3759 00000DBF A05C00                          mov	al,[FCB]
  3760 00000DC2 08C0                    	or	al,al
  3761 00000DC4 7426                    	jz	short NOCOMDRV		; no drive specified
  3762                                  
  3763 00000DC6 B43A                    	mov	ah,':'
  3764 00000DC8 A2[E00A]                	mov	[COMDRV],al
  3765 00000DCB 0440                    	add	al,40h			; convert number to uppercase character
  3766                                  
  3767 00000DCD FD                      	std
  3768                                  
  3769                                  	; MSDOS 6.0
  3770                                          ;cmp	AllocedEnv,0		; if a new environment is being built,
  3771                                  	;je	notwidenv		;  move the default comspec string in it
  3772                                  	;mov	di,ComspOffset
  3773                                          ;cmp	byte ptr es:[di+1],':'	; drive specifier already exist?
  3774                                          ;je	notwidenv               ; yes, must have been inherited that way
  3775                                  
  3776                                  	; MSDOS 3.3
  3777 00000DCE 803E[CB14]00                    cmp	byte [CHUCKENV],0
  3778 00000DD3 7513                    	jne	short NOTWIDENV
  3779                                  
  3780 00000DD5 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  3781 00000DD6 06                      	push	es			;  the drivespec is in ax and is copied
  3782 00000DD7 1F                      	pop	ds			;  on to the front of the string.
  3783                                  
  3784                                  	; MSDOS 6.0
  3785                                          ;lea	si,[di+MAX_COMSPEC-3]	
  3786                                          ;lea	di,[di+MAX_COMSPEC-1]
  3787                                  
  3788                                  	; MSDOS 3.3
  3789                                  	; 23/09/2018
  3790                                  	; 30/04/2018
  3791                                  	;mov	di,159
  3792                                  	;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  3793 00000DD8 BF9F00                          mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  3794                                  	;mov	si,157
  3795                                  	;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  3796 00000DDB BE9D00                          mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  3797                                  	;mov	cx,144
  3798                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  3799 00000DDE B99000                          mov     cx,MAX_COMSPEC-2
  3800                                  
  3801 00000DE1 F3A4                    	rep	movsb
  3802 00000DE3 1F                      	pop	ds
  3803                                  
  3804                                  	; MSDOS 6.0
  3805                                  	;mov	word ptr es:[di-1],ax
  3806                                  
  3807                                  	; MSDOS 3.3
  3808                                  	;mov	es:0Eh,ax
  3809                                  	;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  3810 00000DE4 26A30E00                	mov	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  3811                                  
  3812                                  	; MSDOS 3.3 & MSDOS 6.0
  3813                                  NOTWIDENV:
  3814 00000DE8 FC                      	cld
  3815                                  
  3816 00000DE9 A3[AE14]                	mov    [AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  3817                                  
  3818                                  NOCOMDRV:
  3819 00000DEC E8EDF5                          CALL    SETVECT         ; Set the vectors
  3820                                  
  3821                                  	; MSDOS 3.3
  3822 00000DEF BE8000                  	mov	si,80h		; get command line
  3823 00000DF2 AC                      	lodsb			; get length of line
  3824 00000DF3 88C1                    	mov	cl,al
  3825 00000DF5 30ED                    	xor	ch,ch		; cx = length of command line
  3826                                  ;
  3827                                  ; insure that the command line correctly ends with a cr
  3828                                  ;
  3829 00000DF7 01CE                    	add	si,cx		; go to end of command line	
  3830 00000DF9 C6040D                  	mov	byte [si], 0Dh	; insert a carriage return
  3831                                  
  3832 00000DFC BE8100                  	mov	si,81h		; Start of parms
  3833                                  CHKARG:
  3834 00000DFF E361                            jcxz	COMRETURNSJ     ; No parameters
  3835 00000E01 49                              dec	cx
  3836 00000E02 AC                      	lodsb
  3837                                  CHECKSWITCHCHR:
  3838                                  	; 02/03/2023
  3839 00000E03 3C20                    	cmp	al,' ' ; 20h
  3840                                  	;cmp	al,[space_chr]	 ;Skip blank spaces
  3841 00000E05 74F8                    	jz	short CHKARG
  3842 00000E07 3C09                    	cmp	al,9		; Skip TAB characters
  3843 00000E09 74F4                    	jz	short CHKARG
  3844 00000E0B 3A06[130C]              	cmp	al,[RSWITCHAR]	; Switch?
  3845 00000E0F 7403                    	jz	short PARSE_CONT ; Yes, get the char after the switch
  3846 00000E11 E9CE00                  	jmp	CHKOTHERARGS	; No
  3847                                  
  3848                                  PARSE_CONT:
  3849                                  ;
  3850                                  ; See if a switch was entered
  3851                                  ;
  3852 00000E14 E34C                    	jcxz	COMRETURNSJ
  3853 00000E16 49                      	dec	cx
  3854 00000E17 AC                      	lodsb
  3855 00000E18 0C20                    	or	al,20h		; Lower case
  3856 00000E1A 3C66                    	cmp	al,'f'		; FAIL switch
  3857 00000E1C 7507                    	jnz     short CHECKPSWITCH
  3858                                  	
  3859                                  	; MSDOS 6.0
  3860                                  ;SetFSwitch:
  3861                                  	;cmp	fFail,-1		; has fail switch been set?
  3862                                  	;jnz	failok			; no - set it
  3863                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3864                                          ;jmp	parse_line_error        ; go issue error 
  3865                                  
  3866                                  	; MSDOS 3.3 & MSDOS 6.0
  3867                                  FAIL_OK:
  3868 00000E1E C606[F30A]FF            	mov	byte [FFAIL],-1	; fail all INT 24s.
  3869                                  	; MSDOS 3.3
  3870 00000E23 EBDA                    	jmp	short CHKARG
  3871                                  
  3872                                  CHECKPSWITCH:
  3873                                  	; 02/03/2023
  3874 00000E25 3C70                    	cmp	al,'p'		; Permanent COMMAND switch
  3875                                  	;cmp	al,[letter_p]
  3876 00000E27 751C                            jnz	short CHECKDSWITCH
  3877                                  
  3878                                  SETPSWITCH:
  3879                                  ;
  3880                                  ; We have a permanent COMMAND switch /P.  Flag this and stash the
  3881                                  ; termination address.
  3882                                  ;
  3883                                  	; MSDOS 6.0
  3884                                  	;cmp	PermCom,0		; has /p switch been set?
  3885                                  	;jz	permcomok		; no - set it
  3886                                          ;mov	ax,moreargs_ptr		; set up too many arguments
  3887                                          ;jmp	parse_line_error 		; go issue error 
  3888                                  ;permcomok:
  3889                                  	; MSDOS 3.3 & MSDOS 6.0
  3890 00000E29 FE06[EE0A]              	inc	byte [PERMCOM]
  3891 00000E2D C706[8A0A][AD01]        	mov     word [OLDTERM],LODCOM
  3892 00000E33 8C1E[8C0A]              	mov     [OLDTERM+2],ds
  3893                                  ;
  3894                                  ; make sure that we display the date and time. if the flag was not
  3895                                  ; initialized, set it to indicate yes, do prompt.
  3896                                  ;
  3897                                  	; MSDOS 3.3
  3898 00000E37 803E[BE14]FF            	cmp     byte [PRDATTM],-1
  3899 00000E3C 75C1                    	jnz     short CHKARG
  3900 00000E3E C606[BE14]00            	mov     byte [PRDATTM],0
  3901 00000E43 EBBA                    	jmp     short CHKARG
  3902                                  
  3903                                  ;COMRETURNSJ:
  3904                                  ;	; MSDOS 3.3
  3905                                  ;	JMP	ARGSDONE
  3906                                  
  3907                                  CHECKDSWITCH:
  3908                                  	; 02/03/2023
  3909 00000E45 3C64                    	cmp	al,'d'
  3910                                          ;cmp	al,[letter_d]
  3911 00000E47 7507                    	jnz     short CHECKCSWITCH
  3912                                  SETDSWITCH:
  3913                                  ;
  3914                                  ; Flag no date/time prompting.
  3915                                  ;
  3916                                  	; MSDOS 6.0
  3917                                  	;cmp	Dswitch,0		; has /D switch been set?
  3918                                  	;jz	setdateok		; no - set it
  3919                                          ;mov	ax,Moreargs_ptr	; set up too many arguments
  3920                                          ;jmp	parse_line_error	; go issue error message
  3921                                  ;setdateok:
  3922                                  	;inc	Dswitch 		; indicate /D entered
  3923                                  
  3924                                  	; MSDOS 3.3 & MSDOS 6.0
  3925 00000E49 C606[BE14]01                    mov	byte [PRDATTM],1  ; User explicitly says no date time
  3926                                  	; MSDOS 3.3
  3927 00000E4E EBAF                    	jmp	short CHKARG
  3928                                  
  3929                                  CHECKCSWITCH:
  3930                                  	; 02/03/2023
  3931 00000E50 3C63                            cmp	al,'c'
  3932                                  	;cmp	al,[letter_c]
  3933 00000E52 7511                            jnz	short CHECKESWITCH
  3934                                  
  3935                                  ;SetSSwitch:
  3936                                  SETCSWITCH:
  3937                                  ;
  3938                                  ; Set up pointer to command line, flag no date/time and turn off singlecom.
  3939                                  ;
  3940 00000E54 C606[EE0A]00            	mov	byte [PERMCOM],0	; A SINGLECOM must not be a PERMCOM
  3941 00000E59 8936[EF0A]              	mov	[SINGLECOM],si		; Point to the rest of the command line
  3942                                  	;mov	byte [PERMCOM],0
  3943 00000E5D C606[BE14]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  3944                                  COMRETURNSJ: ; 24/09/2018
  3945 00000E62 E96301                  	jmp	ARGSDONE
  3946                                  
  3947                                  CHECKESWITCH:
  3948 00000E65 3C65                    	cmp     al,'e'
  3949 00000E67 7596                    	jnz     short CHKARG
  3950                                  ;
  3951                                  ; Look for environment-size setting switch
  3952                                  ;
  3953                                  ; The environment size is represented in decimal bytes and is
  3954                                  ; converted into paragraphs (rounded up to the next paragraph).
  3955                                  ;
  3956                                  SETESWITCH:
  3957                                  	; MSDOS 6.0
  3958                                  	;cmp	Eswitch,0		; has environment size switch been set?
  3959                                  	;jz	eswitchok		; no - set it
  3960                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3961                                          ;jmp	Parse_line_error	; go issue error message
  3962                                  ;eswitchok:
  3963                                  	;inc	Eswitch			; indicate /E entered 	
  3964                                  
  3965                                  	; 23/09/2018 - Retro DOS v3.0
  3966                                  
  3967                                  	; MSDOS 3.3
  3968                                  	; (COMMAND.COM offset 0FC5h)
  3969                                  ESWITCHOK:
  3970 00000E69 E394                    	jcxz    CHKARG
  3971 00000E6B 49                      	dec     cx
  3972 00000E6C AC                      	lodsb
  3973 00000E6D 3C3A                    	cmp     al,':'
  3974 00000E6F 7592                    	jnz     short CHECKSWITCHCHR
  3975 00000E71 31DB                    	xor     bx,bx
  3976 00000E73 89D8                    	mov     ax,bx
  3977                                  GETENVSIZE:
  3978 00000E75 E338                    	jcxz    SETENVSIZE
  3979 00000E77 49                      	dec     cx
  3980 00000E78 AC                      	lodsb
  3981 00000E79 3C30                    	cmp     al,'0'
  3982 00000E7B 7214                    	jb      short NOTDECIMALCHR
  3983 00000E7D 3C39                    	cmp     al,'9'
  3984 00000E7F 7710                    	ja      short NOTDECIMALCHR
  3985 00000E81 2C30                    	sub     al,'0'
  3986 00000E83 89DA                    	mov     dx,bx
  3987 00000E85 D1E2                    	shl     dx,1
  3988 00000E87 D1E2                    	shl     dx,1   ; dx = 4*bx	
  3989 00000E89 01D3                    	add     bx,dx  ; bx = 5*bx
  3990 00000E8B D1E3                    	shl     bx,1   ; bx = 10*bx	
  3991 00000E8D 01C3                    	add     bx,ax
  3992 00000E8F EBE4                    	jmp     short GETENVSIZE
  3993                                  
  3994                                  NOTDECIMALCHR:
  3995                                  	; 02/03/2023
  3996 00000E91 3C20                    	cmp	al,' ' ; 20h
  3997                                  	;cmp	al,[space_chr]
  3998 00000E93 7418                    	jz      short CHECKENVSIZE
  3999                                  	;cmp	al,'/'
  4000 00000E95 3A06[130C]              	cmp     al,[RSWITCHAR]
  4001 00000E99 7412                    	jz      short CHECKENVSIZE
  4002                                  
  4003                                  CHECKNEXTECHR:
  4004 00000E9B E33B                    	jcxz    INVENVSIZE
  4005 00000E9D 49                      	dec     cx
  4006 00000E9E AC                      	lodsb
  4007                                  	; 02/03/2023
  4008 00000E9F 3C20                    	cmp	al,' ' ; 20h
  4009                                  	;cmp	al,[space_chr]
  4010 00000EA1 7406                    	jz      short ENVSIZESPC
  4011                                  	;cmp	al,'/'
  4012 00000EA3 3A06[130C]              	cmp     al,[RSWITCHAR]
  4013 00000EA7 75F2                    	jnz     short CHECKNEXTECHR
  4014                                  
  4015                                  ENVSIZESPC:
  4016 00000EA9 4E                      	dec     si
  4017 00000EAA 41                      	inc     cx
  4018 00000EAB EB2B                    	jmp     short INVENVSIZE
  4019                                  	
  4020                                  	;nop
  4021                                  
  4022                                  CHECKENVSIZE: 
  4023 00000EAD 4E                      	dec     si
  4024 00000EAE 41                      	inc     cx
  4025                                  
  4026                                  SETENVSIZE:
  4027                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  4028 00000EAF C706[D614]0008          	mov	word [ENVSIZ],ENVBIG/16
  4029 00000EB5 81FB0080                	cmp     bx,32768
  4030 00000EB9 771D                    	ja      short INVENVSIZE
  4031                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  4032 00000EBB C706[D614]0A00          	mov	word [ENVSIZ],ENVSML/16
  4033 00000EC1 81FBA000                	cmp     bx,160
  4034 00000EC5 7211                    	jb      short INVENVSIZE
  4035 00000EC7 83C30F                  	add     bx,15
  4036 00000ECA D1EB                    	shr     bx,1
  4037 00000ECC D1EB                    	shr     bx,1
  4038 00000ECE D1EB                    	shr     bx,1
  4039 00000ED0 D1EB                    	shr     bx,1
  4040 00000ED2 891E[D614]              	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  4041 00000ED6 EB07                    	jmp     short NEXTCH2
  4042                                  
  4043                                  	;nop
  4044                                  
  4045                                  INVENVSIZE:
  4046 00000ED8 BA[6A14]                	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  4047 00000EDB B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4048 00000EDD CD21                    	int     21h             ; DOS - PRINT STRING
  4049                                  				; DS:DX -> string terminated by "$"
  4050                                  NEXTCH2:
  4051                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  4052 00000EDF E91DFF                  	jmp     CHKARG
  4053                                  
  4054                                  	;jmp	ARGSDONE
  4055                                  
  4056                                  CHKOTHERARGS:
  4057                                  ;
  4058                                  ; We have a non-switch character here.
  4059                                  ;
  4060                                  	; MSDOS 6.0
  4061                                  ;	push	ds ; ***			;
  4062                                  ;	push	si ; **** 			; save place in command line
  4063                                  ;	lds	si,Comnd1_Addr			; get address of filespec
  4064                                  ;	assume	ds:nothing			;
  4065                                  ;
  4066                                  ;	mov	dx,si				; put in dx also
  4067                                  ;       mov     ax,(OPEN shl 8) or 2            ; Read and write
  4068                                  ;	int	21h
  4069                                  ;	jc	ChkSrchSpec			; Wasn't a file
  4070                                  ;	mov	bx,ax
  4071                                  ;	mov	ax,IOCTL shl 8
  4072                                  ;	int	21h
  4073                                  ;	test	dl,80h
  4074                                  ;	jnz	IsaDevice
  4075                                  ;
  4076                                  ;BadSetCon:					;
  4077                                  ;	mov	ah,CLOSE			; Close initial handle, wasn't a device
  4078                                  ;	int	21h
  4079                                  ;	jmp	short ChkSrchSpec
  4080                                  
  4081                                  	; MSDOS 3.3
  4082                                  	; (COMMAND.COM offset 1047h)
  4083 00000EE2 4E                              dec	si
  4084 00000EE3 41                      	inc	cx
  4085 00000EE4 89F2                    	mov	dx,si
  4086 00000EE6 51                      	push	cx ; *
  4087 00000EE7 56                      	push	si ; **
  4088                                  CONTRLOOP:
  4089 00000EE8 AC                      	lodsb
  4090 00000EE9 49                      	dec	cx
  4091                                  	; 02/03/2023
  4092 00000EEA 3C20                    	cmp	al,' ' ; 20h
  4093                                  	;cmp	al,[space_chr]
  4094 00000EEC 7409                    	jz	short SETCDEV
  4095 00000EEE 3C09                    	cmp	al,9
  4096 00000EF0 7405                    	jz	short SETCDEV
  4097 00000EF2 E302                    	jcxz	SETCDEVA
  4098 00000EF4 EBF2                    	jmp	short CONTRLOOP
  4099                                  
  4100                                  SETCDEVA:
  4101 00000EF6 46                              inc	si
  4102                                  SETCDEV:
  4103 00000EF7 C644FF00                	mov	byte [SI-1],0
  4104                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  4105 00000EFB B8023D                          mov	ax,(OPEN*256) | 2 ; 3D02h
  4106 00000EFE CD21                            int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  4107                                  			; DS:DX -> ASCIZ filename
  4108                                  			; AL = access mode
  4109                                  			; 2 - read & write
  4110 00000F00 7247                            jc	short CHKSRCHSPEC	; Wasn't a file
  4111 00000F02 89C3                            mov	bx,ax
  4112                                          ;mov	ax,IOCTL shl 8
  4113 00000F04 B80044                          mov     ax,IOCTL*256 ; 4400h
  4114 00000F07 CD21                    	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  4115                                  			; BX = file or device handle
  4116 00000F09 F6C280                          test	dl,80H
  4117 00000F0C 7506                    	jnz	short ISADEVICE
  4118                                  BADSETCON: ; MSDOS 6.0
  4119 00000F0E B43E                    	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  4120 00000F10 CD21                            int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  4121                                  			; BX = file handle
  4122 00000F12 EB35                            JMP     short CHKSRCHSPEC
  4123                                  
  4124                                  	;nop
  4125                                  
  4126                                  ISADEVICE:
  4127                                  	; MSDOS 3.3 & MSDOS 6.0
  4128 00000F14 30F6                    	xor	dh,dh
  4129 00000F16 80CA03                  	or	dl,3				; Make sure has CON attributes
  4130                                  	;mov	ax,(IOCTL shl 8) or 1
  4131 00000F19 B80144                  	mov	ax,(IOCTL*256) | 1 ; 4401h
  4132 00000F1C CD21                    	int	21h
  4133                                  	;
  4134                                  	; 25/09/2018
  4135 00000F1E 5A                      	pop	dx ; **
  4136 00000F1F 5A                      	pop	dx ; *
  4137                                  	;
  4138 00000F20 72EC                    	jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  4139 00000F22 89DA                    	mov	dx,bx				; Save new handle
  4140                                  
  4141                                  	; MSDOS 6.0
  4142                                  	;cmp	es:DevFlag,1
  4143                                  	;jz	DevErr
  4144                                  
  4145                                  	; MSDOS 3.3
  4146                                          ;pop	bx ; **				; Throw away saved SI
  4147                                          ;pop	bx ; *				; Throw away saved CX
  4148                                  
  4149                                  	; MSDOS 3.3 & MSDOS 6.0
  4150 00000F24 51                      	push	cx
  4151 00000F25 B90300                  	mov	cx,3
  4152 00000F28 31DB                    	xor	bx,bx
  4153                                  RCCLLOOP:
  4154 00000F2A B43E                    	mov	ah,CLOSE ; 3Eh
  4155 00000F2C CD21                    	int	21h
  4156 00000F2E 43                      	inc	bx
  4157 00000F2F E2F9                    	loop	RCCLLOOP
  4158                                  
  4159 00000F31 89D3                    	mov	bx,dx				; New device handle
  4160 00000F33 B445                    	mov	ah,XDUP ; 45h
  4161 00000F35 CD21                    	int	21h				; Dup to 0
  4162 00000F37 B445                    	mov	ah,XDUP
  4163 00000F39 CD21                    	int	21h				; Dup to 1
  4164 00000F3B B445                    	mov	ah,XDUP
  4165 00000F3D CD21                    	int	21h				; Dup to 2
  4166 00000F3F B43E                    	mov	ah,CLOSE
  4167 00000F41 CD21                    	int	21h				; Close initial handle
  4168                                  	
  4169 00000F43 59                      	pop	cx
  4170                                  	
  4171                                  	; MSDOS 6.0
  4172                                  	;pop	si ; ****			; restore position of command line
  4173                                  	;pop	ds ; ***			;
  4174                                  ;
  4175                                  ; Register the fact that we already have redirected the output and cannot do
  4176                                  ; it again
  4177                                  ;
  4178                                  	;inc	es:DevFlag			;
  4179                                          ;jmp	Parse_command_line		; continue parsing
  4180                                  
  4181                                  	; MSDOS 3.3
  4182 00000F44 E35E                    	jcxz	ARGSDONEJ2
  4183 00000F46 E9B6FE                  	jmp	CHKARG
  4184                                  
  4185                                  	; MSDOS 6.0
  4186                                  ;DevErr:
  4187                                  	;pop	si ; ****
  4188                                  	;pop	ds ; ***
  4189                                  	;mov	dx,1
  4190                                          ;call	RPrintParse                     ; "Too many parameters"
  4191                                          ;call	CrLf
  4192                                  	;jmp	Parse_command_line
  4193                                  
  4194                                  CHKSRCHSPEC:                    ; Not a device, so must be directory spec
  4195                                  
  4196                                  	; MSDOS 6.0
  4197                                          ;cmp	es:PathFlag,1			; already set COMSPEC?
  4198                                          ;jz	DevErr				; yes, error
  4199                                  	;
  4200                                          ;inc	es:PathFlag			; mark that we have a path
  4201                                  ;
  4202                                  ; We have to override the passed environment. Allocate a buffer for use now.
  4203                                  ; This buffer will later be replaced by a proper environment
  4204                                  ;
  4205                                  	;call	alloc_env                       ; environment buffer
  4206                                  	;mov	es,ax
  4207                                  	;assume	es:nothing
  4208                                  	;push	si				; remember location of file
  4209                                  	;xor	cx,cx				; clear cx for counting
  4210                                  
  4211                                  ;countloop:
  4212                                  	;lodsb					; get a character
  4213                                  	;inc	cx				; increment counter
  4214                                          ;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  4215                                  	;jnz	countloop			; no - keep counting
  4216                                  	;
  4217                                  	;mov	al,Space
  4218                                  	;dec	si				; move back one
  4219                                          ;mov	byte ptr [si],al                ; put a space at end of line
  4220                                  ;
  4221                                  ; We now know how long the new pathspec for command.com is.  Time to
  4222                                  ; figure out how long the current COMSPEC setting is, and then to move
  4223                                  ; all the environment data up, throwing that COMSPEC setting away, and
  4224                                  ; preparing to append the new COMSPEC.  ComspOffset (the offset of
  4225                                  ; where the filespec exists in the environment) is updated as well.
  4226                                  ;
  4227                                  	;push	cx                              ;
  4228                                          ;mov	cx,ENVBIG                       ;
  4229                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  4230                                          ;mov	al,0                            ;
  4231                                          ;repne	scasb                           ; find the end of COMSPEC
  4232                                          ;mov	si,di                           ;
  4233                                  ;comp_endenv:                                   ;
  4234                                          ;scasb                                  ; end of env?
  4235                                          ;je	got_endenv                      ; yes
  4236                                          ;repne	scasb                           ;
  4237                                          ;jmp	comp_endenv                     ;
  4238                                  ;got_endenv:                                    ;
  4239                                          ;mov    cx,di                           ;
  4240                                          ;sub    cx,si                           ;
  4241                                          ;mov    di,ComspOffset                  ;
  4242                                          ;sub    di,ComspStrLen                  ;
  4243                                          ;push   ds                              ;
  4244                                          ;push   es                              ;
  4245                                          ;pop    ds                              ;
  4246                                          ;rep    movsb                           ;
  4247                                          ;dec    di                              ; copy in new COMSPEC=
  4248                                          ;push   cs                              ;
  4249                                          ;pop    ds                              ;
  4250                                          ;assume ds:ResGroup                     ;
  4251                                          ;mov    si,offset RESGROUP:ComspString  ;
  4252                                          ;mov    cx,ComspStrLen                  ;
  4253                                          ;rep    movsb                           ;
  4254                                          ;mov    ComspOffset,di                  ;
  4255                                          ;pop    ds                              ;
  4256                                          ;assume ds:nothing                      ;
  4257                                          ;pop    cx                              ;
  4258                                  	;
  4259                                          ;pop    si                              ; get new comspec location back
  4260                                  
  4261                                  	; MSDOS 3.3
  4262 00000F49 C606[CB14]00            	mov     byte [CHUCKENV],0	; If search specified -- no inheritance
  4263 00000F4E B8[400C]                	mov     ax,PATHSTRING ; "PATH="	; Figure environment pointer
  4264 00000F51 B104                    	mov     cl,4
  4265 00000F53 D3E8                    	shr     ax,cl
  4266 00000F55 8CDA                    	mov     dx,ds
  4267 00000F57 01D0                    	add     ax,dx
  4268 00000F59 A3[FF0B]                	mov     [ENVIRSEG],ax
  4269 00000F5C 8EC0                    	mov     es,ax
  4270                                  	; 02/03/2023
  4271 00000F5E B020                    	mov	al,' ' ; 20h
  4272                                  	;mov	al,[space_chr]
  4273 00000F60 8844FF                  	mov     [si-1],al
  4274 00000F63 5E                      	pop     si ; **			; Remember location
  4275 00000F64 59                      	pop     cx ; *			; and count
  4276                                  	;mov	di,[ECOMLOC]
  4277 00000F65 8B3E[CC14]              	mov     di,[COMSPOFFSET]
  4278                                  
  4279                                  COMTRLOOP:
  4280                                  	; MSDOS 3.3 & MSDOS 6.0
  4281 00000F69 AC                      	lodsb
  4282 00000F6A 49                      	dec	cx
  4283                                  	; 02/03/2023
  4284 00000F6B 3C20                    	cmp	al,' ' ; 20h
  4285                                  	;cmp	al,[space_chr]
  4286 00000F6D 7409                    	je	short SETCOMSR
  4287                                  	; MSDOS 3.3
  4288 00000F6F 3C09                    	cmp	al,9
  4289 00000F71 7405                    	je	short SETCOMSR
  4290                                  	; MSDOS 3.3 & MSDOS 6.0
  4291 00000F73 AA                      	stosb
  4292 00000F74 E302                    	jcxz	SETCOMSR
  4293 00000F76 EBF1                    	jmp	short COMTRLOOP
  4294                                  
  4295                                  SETCOMSR:
  4296                                  	; MSDOS 6.0
  4297                                  	;push	cx
  4298                                  	;
  4299                                  	;push	cs				; Get local segment
  4300                                  	;pop	ds				;
  4301                                  	;assume	ds:ResGroup			;
  4302                                  	;
  4303                                  	;push	ds
  4304                                  	;mov	si,offset ResGroup:ComSpect
  4305                                  	;mov	cx,14
  4306                                  	;
  4307                                  	;mov	al,es:[di-1]
  4308                                  	;
  4309                                  	;cmp	al,RDirChar
  4310                                  	;jnz	iNotRoot
  4311                                  	;inc	si				; Don't make a double /
  4312                                  	;dec	cx
  4313                                  	
  4314                                  	; MSDOS 3.3
  4315 00000F78 56                      	push    si
  4316 00000F79 51                      	push    cx
  4317 00000F7A 1E                      	push    ds
  4318 00000F7B BE[A014]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4319 00000F7E B90E00                  	mov     cx,14
  4320 00000F81 268A45FF                	mov     al,[es:di-1]
  4321 00000F85 E8E402                  	call    PATHCHRCMPR
  4322 00000F88 7502                    	jnz     short INOTROOT			
  4323 00000F8A 46                      	inc     si				; Don't make a double /
  4324 00000F8B 49                      	dec     cx
  4325                                  INOTROOT:
  4326                                  	; MSDOS 3.3 & MSDOS 6.0
  4327 00000F8C F3A4                    	rep	movsb
  4328                                  
  4329                                  	;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  4330 00000F8E 8B16[CC14]                      mov     dx,[COMSPOFFSET]
  4331 00000F92 06                      	push	es
  4332 00000F93 1F                      	pop	ds
  4333                                  	;mov	ax,OPEN shl 8
  4334 00000F94 B8003D                  	mov	ax,OPEN*256 ; 3D00h
  4335 00000F97 CD21                    	int	21h				; Open COMMAND.COM
  4336 00000F99 1F                      	pop	ds
  4337 00000F9A 720D                    	jc	short SETCOMSRBAD		; No COMMAND.COM here
  4338 00000F9C 89C3                    	mov	bx,ax				; Handle
  4339 00000F9E B43E                    	mov	ah,CLOSE ; 3Eh
  4340 00000FA0 CD21                    	int	21h				; Close COMMAND.COM
  4341                                  SETCOMSRRET:
  4342 00000FA2 59                      	pop	cx
  4343 00000FA3 5E                      	pop	si
  4344                                  
  4345                                  	; MSDOS 6.0
  4346                                  	;pop	ds				;
  4347                                  	;assume	ds:ResGroup			;
  4348                                  	;
  4349                                  	;push	cs				; Make sure local ES is
  4350                                  	;pop	es				;  restored
  4351                                  	;jmp	Parse_command_line		; continue parsing command line
  4352                                  
  4353                                  	; MSDOS 3.3
  4354                                  ARGSDONEJ2:
  4355 00000FA4 E322                    	jcxz	ARGSDONE
  4356 00000FA6 E956FE                  	jmp	CHKARG
  4357                                  
  4358                                  SETCOMSRBAD:
  4359                                  	; MSDOS 3.3 & MSDOS 6.0
  4360                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  4361 00000FA9 BA[E813]                	mov	dx,BADCOMLKMES
  4362                                  
  4363                                  ;	Note:  we're about to make a near call to TriageError, which
  4364                                  ;	lives in a different segment and group.  Some linkers will
  4365                                  ;	generate a warning like "Possible fix-up overflow".  We're
  4366                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  4367                                  ;	we're still all together.
  4368                                  
  4369 00000FAC E8EA22                  	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  4370                                  				; in original MSDOS 3.3 COMMAND.COM	
  4371 00000FAF 83F841                  	cmp	ax,65
  4372 00000FB2 7503                    	jne	short DOPRT
  4373                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  4374 00000FB4 BA[2114]                	mov	dx,BADCOMACCMSG
  4375                                  DOPRT:
  4376 00000FB7 E8A502                  	call	RPRINT
  4377                                  	;mov	si,offset ResGroup:ComSpect
  4378 00000FBA BE[A014]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4379                                  	;mov	di,[ECOMLOC]
  4380 00000FBD 8B3E[CC14]                      mov     di,[COMSPOFFSET]
  4381 00000FC1 B90E00                  	mov	cx,14
  4382 00000FC4 F3A4                    	rep	movsb				; get my default back
  4383                                  
  4384 00000FC6 EBDA                    	jmp	short SETCOMSRRET
  4385                                  
  4386                                  ARGSDONE:
  4387                                  	; MSDOS 6.0
  4388                                  	;mov	es,EnvirSeg			; get environment back
  4389                                  	;assume	es:nothing			;
  4390                                  
  4391                                  	; MSDOS 3.3 & MSDOS 6.0
  4392 00000FC8 803E[EE0A]00                    cmp	byte [PERMCOM],0
  4393 00000FCD 742E                            jz	short COMRETURNS
  4394                                  
  4395 00000FCF 06                      	push	es				; Save environment pointer
  4396 00000FD0 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  4397 00000FD2 8CDB                    	mov	bx,ds
  4398 00000FD4 8EC3                    	mov	es,bx
  4399 00000FD6 CD21                    	int	21h				; current process is me
  4400 00000FD8 BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  4401                                  	;mov	ax,offset RESGROUP:LODCOM
  4402 00000FDB B8[AD01]                        mov	ax,LODCOM
  4403 00000FDE AB                              stosw
  4404 00000FDF 8CD8                            mov	ax,ds
  4405 00000FE1 AB                              stosw
  4406                                          ;mov	ax,offset RESGROUP:CONTC
  4407 00000FE2 B8[3C00]                        mov	ax,CONTC
  4408 00000FE5 AB                              stosw
  4409 00000FE6 8CD8                            mov	ax,ds
  4410 00000FE8 AB                              stosw
  4411                                  	;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  4412 00000FE9 B8[4B04]                	mov     ax,CRITERR
  4413 00000FEC AB                      	stosw
  4414 00000FED 8CD8                    	mov     ax,ds
  4415 00000FEF AB                      	stosw
  4416                                  	;mov	word ptr ds:16h,ds
  4417                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  4418 00000FF0 8C1E1600                	mov	[PDB.PARENT_PID],ds
  4419                                          ;mov	dx,offset RESGROUP:INT_2E
  4420 00000FF4 BA[7C01]                        mov	dx,INT_2E
  4421                                          ;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  4422 00000FF7 B82E25                  	mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  4423 00000FFA CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  4424                                  			; AL = interrupt number
  4425                                  			; DS:DX = new vector to be used for specified interrupt
  4426 00000FFC 07                              pop	es				; Remember environment
  4427                                  	
  4428                                  COMRETURNS:
  4429                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  4430 00000FFD A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  4431 00001000 A3[880A]                        mov	[PARENT],ax			; Save parent
  4432                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  4433 00001003 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  4434                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  4435 00001007 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax, ds:18h
  4436 0000100A A3[EB0A]                        mov	[IO_SAVE],ax		; Get the default stdin and out
  4437 0000100D 8C1E[030C]                      mov	[COM_PTR+2],ds		; Set all these to resident
  4438 00001011 8C1E[070C]                      mov	[COM_FCB1+2],ds
  4439 00001015 8C1E[0B0C]              	mov	[COM_FCB2+2],ds
  4440                                          ;mov	di,offset ResGroup:ComSpec
  4441 00001019 BF[950A]                        mov	di,COMSPEC
  4442                                  
  4443                                  	;mov	si,[ECOMLOC]
  4444 0000101C 8B36[CC14]              	mov	si,[COMSPOFFSET]
  4445                                  	;cmp	AllocedEnv,0  ; MSDOS 6.0
  4446 00001020 803E[CB14]00                    cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  4447                                  	
  4448 00001025 8CD8                    	mov	ax,ds				; Xchg es,ds
  4449 00001027 06                      	push	es
  4450 00001028 1F                      	pop	ds
  4451 00001029 8EC0                    	mov	es,ax
  4452                                  
  4453                                  	;jne	CopyComsp  ; MSDOS 6.0
  4454 0000102B 741D                            je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  4455                                  
  4456 0000102D 0E                              push	cs
  4457 0000102E 1F                              pop	ds
  4458                                  
  4459                                          ;mov	si,offset ResGroup:ComspString
  4460 0000102F BE[CE14]                	mov	si,COMSPSTRING ; "COMSPEC="
  4461 00001032 06                      	push	es
  4462 00001033 57                      	push	di
  4463 00001034 E84302                  	call	IFINDE
  4464 00001037 89FE                    	mov	si,di
  4465 00001039 06                      	push	es
  4466 0000103A 1F                      	pop	ds
  4467 0000103B 5F                      	pop	di
  4468 0000103C 07                      	pop	es
  4469 0000103D 730B                            jnc	short COPYCOMSP
  4470                                  
  4471                                  	; MSDOS 6.0
  4472                                  ;ComSpecNofnd:
  4473                                          ;mov	si,offset ResGroup:ComspString
  4474                                          ;add	si,ComspStrLen
  4475                                  	;push	cs
  4476                                  	;pop	ds
  4477                                  
  4478                                  COMSPECNOFND:
  4479                                  	; MSDOS 3.3
  4480                                          ;mov	si,[es:ECOMLOC]
  4481 0000103F 268B36[CC14]                    mov	si,[es:COMSPOFFSET]
  4482                                  	;add	si,offset RESGROUP:PATHSTRING
  4483 00001044 81C6[400C]                      add	si,PATHSTRING ; "PATH="
  4484 00001048 0E                      	push	cs
  4485 00001049 1F                              pop	ds
  4486                                  
  4487                                  COPYCOMSP:
  4488                                  	; MSDOS 3.3 & MSDOS 6.0
  4489                                  	;mov	es:PutBackComSpec.SubstPtr,di
  4490 0000104A 26893E[D50A]            	mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  4491 0000104F 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  4492 00001053 7506                    	jne	short COPYCOMSPLOOP		; If not, do not skip over first 2 bytes
  4493                                  	;add	es:PutBackComSpec.SubstPtr,2
  4494 00001055 268306[D50A]02          	add	word [es:PUTBACKSUBSTPTR],2
  4495                                  
  4496                                  COPYCOMSPLOOP:
  4497 0000105B AC                      	lodsb
  4498 0000105C AA                      	stosb
  4499 0000105D 08C0                    	or	al,al
  4500 0000105F 75FA                    	jnz	short COPYCOMSPLOOP
  4501                                  
  4502 00001061 26893E[D70A]            	mov	[es:COMSPEC_END],di		; Save ptr to end of comspec path
  4503 00001066 26FF0E[D70A]            	dec	word [es:COMSPEC_END]
  4504 0000106B 268A26[E00A]            	mov	ah,[es:COMDRV]
  4505 00001070 80C440                  	add	ah,'A'-1 ; 40h
  4506 00001073 268826[1D09]            	mov	[es:PUTBACKDRV],ah		; save drive letter
  4507                                  
  4508                                  	; MSDOS 6.0
  4509                                  	;call	setup_for_messages		; set up parse and extended error messages
  4510                                  ;
  4511                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  4512                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  4513                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  4514                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  4515                                  ; the data otherwise it is just the data.
  4516                                  ; 
  4517                                  	;call	Setup_res_end			;put resident size in ResSize
  4518                                  
  4519                                  	;push	cs
  4520                                  	;pop	ds
  4521                                  	;assume	ds:RESGROUP
  4522                                  
  4523                                  ;Public EnvMaximum
  4524                                  ;EnvMaximum:
  4525                                  
  4526                                  	; MSDOS 3.3
  4527 00001078 0E                      	push	cs
  4528 00001079 1F                              pop	ds
  4529                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  4530 0000107A BB[320C]                	mov	bx,DATARESEND+15
  4531 0000107D B104                            mov	cl,4
  4532 0000107F D3EB                            shr	bx,cl
  4533 00001081 B44A                            MOV     AH,SETBLOCK ; 4Ah
  4534 00001083 CD21                            int	21h			; Shrink me to the resident only
  4535                                  
  4536                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  4537                                  
  4538 00001085 C606[DD0A]01            	mov	byte [TRNMVFLG], 1
  4539 0000108A 06                      	push	es ; *
  4540 0000108B BE[2015]                	mov	si,TRANSTART
  4541 0000108E BF0000                  	mov	di,0
  4542 00001091 8E06[DB0A]              	mov	es,[TRNSEG]
  4543                                  	;mov	cx,4D5Ch
  4544 00001095 B94C4C                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  4545 00001098 51                      	push	cx
  4546 00001099 89C8                    	mov	ax,cx
  4547 0000109B 01F0                    	add	ax,si
  4548 0000109D B104                    	mov	cl,4
  4549 0000109F D3E8                    	shr	ax,cl
  4550 000010A1 40                      	inc	ax
  4551 000010A2 8CD9                    	mov	cx,ds
  4552 000010A4 01C8                    	add	ax,cx
  4553 000010A6 3B06[DB0A]              	cmp	ax,[TRNSEG]
  4554 000010AA 59                      	pop	cx
  4555 000010AB 7205                    	jb	short MOV_DOWN
  4556                                  
  4557 000010AD E8C3F2                  	call	LOADCOM
  4558 000010B0 EB0A                    	jmp	short ICHKSUM
  4559                                  
  4560                                  MOV_DOWN:
  4561 000010B2 01CE                    	add     si,cx
  4562 000010B4 4E                      	dec     si
  4563 000010B5 01CF                    	add     di,cx
  4564 000010B7 4F                      	dec     di
  4565 000010B8 FD                      	std
  4566 000010B9 F3A4                    	rep movsb
  4567 000010BB FC                      	cld
  4568                                  
  4569                                  ICHKSUM:
  4570                                  	; 24/09/2018
  4571                                  ;
  4572                                  ; Compute checksum right now before we can get corrupted and save it
  4573                                  ;
  4574                                  	; MSDOS 6.0
  4575                                  	;mov	si,offset RESGROUP:TranStart
  4576                                  	;add	si,100h
  4577                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  4578                                  	;
  4579                                  	;cld
  4580                                  	;shr	cx,1
  4581                                  	;xor	dx,dx
  4582                                  ;Ichksum:
  4583                                  	;lodsw
  4584                                  	;add	dx,ax
  4585                                  	;adc	dx,0
  4586                                  	;loop	Ichksum
  4587                                  	;
  4588                                          ;mov	Sum,dx			; store checksum
  4589                                  
  4590                                  	; MSDOS 3.3
  4591 000010BC 07                      	pop     es ; *
  4592 000010BD E802F3                  	call    CHKSUM
  4593 000010C0 8916[E30A]              	mov     [SUM],dx
  4594                                  
  4595                                  	; MSDOS 3.3 & MSDOS 6.0
  4596 000010C4 803E[BE14]00                    cmp     byte [PRDATTM],0	;
  4597 000010C9 750C                            jnz     short NOBATCHSEG	; don't do autoexec or date time
  4598                                  ;
  4599                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  4600                                  ;
  4601                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  4602                                  	;mov	bx,3
  4603 000010CB BB0300                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  4604 000010CE B448                            mov     ah,ALLOC ; 48h		;
  4605 000010D0 CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4606                                  			; BX = number of 16-byte paragraphs desired
  4607 000010D2 7203                    	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  4608 000010D4 A3[930A]                        mov     [BATCH],ax		; save batch segment
  4609                                  
  4610                                  NOBATCHSEG:
  4611                                  	; MSDOS 6.0
  4612                                  	;mov	bx,EnvirSeg                     ; get old environment segment
  4613                                  	;mov	OldEnv,bx                       ; save it
  4614                                  	;
  4615                                          ;mov	UsedEnv,0                       ; initialize env size counter
  4616                                  	;mov	ds,bx
  4617                                  	;assume	ds:nothing
  4618                                  	;
  4619                                  	;xor	si,si
  4620                                  	;mov	di,si
  4621                                  ;
  4622                                  ; This is the maximum allowed size for the environment
  4623                                  ;
  4624                                  	;mov	bx,4096 - 1 			; max. allowed env. size
  4625                                  	;mov	EnvMax,bx
  4626                                  				 
  4627                                  	;shl	bx,1
  4628                                  	;shl	bx,1
  4629                                  	;shl	bx,1
  4630                                  	;shl	bx,1
  4631                                  	;mov	EnvMax, bx			; convert envmax to bytes
  4632                                  	;dec	bx				; dec by one to leave room for double 0
  4633                                  	;xor	dx,dx				; use dx to indicate that there was
  4634                                  						; no environment size error.
  4635                                  ;public NxtStr
  4636                                  ;NxtStr:
  4637                                  	;call	GetStrLen			; get the size of the current env string
  4638                                  
  4639                                  ;Bugbug: Can use ss here to address UsedEnv
  4640                                  
  4641                                  	;push	ds                              ; get addressability to environment
  4642                                          ;push	cs                              ;                       counter
  4643                                          ;pop	ds                              ;
  4644                                          ;assume	ds:ResGroup
  4645                                          ;add	UsedEnv,cx                      ; add the string length to env size
  4646                                          ;pop	ds                              ;
  4647                                  	;assume	ds:nothing
  4648                                  	;cmp	cx,1				; end of environment was encountered.
  4649                                  	;jz	EnvExit
  4650                                  	;sub	bx,cx
  4651                                  	;jae	OkCpyStr			; can't fit in all of enviroment.
  4652                                  	;inc	dx				; out of env space msg must be displayed
  4653                                  	;jmp	short EnvExit
  4654                                  ;OkCpyStr:
  4655                                  	;jmp	NxtStr
  4656                                  ;EnvExit:
  4657                                  	;push	cs
  4658                                  	;pop	ds
  4659                                  	;assume	ds:ResGroup
  4660                                  	;or	dx,dx				; dx will be non-zero if error
  4661                                  	;jz	EnvNoErr
  4662                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  4663                                  	;call 	RPrint
  4664                                  	;
  4665                                  ;EnvNoErr:
  4666                                  	;mov	ax,EnvSiz			;env size previously set
  4667                                  	;mov	cl,4
  4668                                  	;shl	ax,cl				;get size in bytes
  4669                                  	;cmp	ax,UsedEnv			;is it a new env?
  4670                                  	;ja	st_envsize			;yes, store the size
  4671                                  	;
  4672                                  	;mov	ax,UsedEnv
  4673                                  	;add	ax,15				;round up
  4674                                  ;st_envsize:	
  4675                                  	;shr	ax,cl
  4676                                  	;mov	EnvSiz,ax			;store env size needed(paras)
  4677                                  ;if MSVER
  4678                                  	;cmp	SingleCom,0
  4679                                  	;jnz	nophead 			; don't print header if singlecom
  4680                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4681                                  	;call	RPrint
  4682                                  ;nophead:
  4683                                  ;endif
  4684                                  
  4685                                  	; MSDOS 3.3
  4686 000010D7 BBFFFF                  	mov     bx,0FFFFh ; 65535
  4687 000010DA B448                    	mov     ah,ALLOC ; 48h
  4688 000010DC CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4689                                  			; BX = number of 16-byte paragraphs desired
  4690 000010DE 2B1E[E014]              	sub     bx,[TRNSIZE]
  4691 000010E2 81EB8000                	sub     bx,128
  4692 000010E6 891E[D814]              	mov     [ENVMAX],bx
  4693                                  
  4694 000010EA 81FB0010                	cmp     bx,4096
  4695 000010EE 7207                    	jb      short ALLOCENVIRSEG
  4696 000010F0 BBFF0F                  	mov     bx,4096-1		; max. allowed environment size
  4697 000010F3 891E[D814]              	mov     [ENVMAX],bx
  4698                                  
  4699                                  ALLOCENVIRSEG:
  4700 000010F7 B448                    	mov     ah,ALLOC ; 48h
  4701 000010F9 CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4702                                  			; BX = number of 16-byte paragraphs desired
  4703 000010FB 8B1E[FF0B]              	mov     bx,[ENVIRSEG]		; get old environment segment
  4704 000010FF 891E[DA14]              	mov     [OLDENV],bx		; save it	
  4705 00001103 C706[DC14]0000          	mov     word [USEDENV],0	; initialize environment size counter
  4706 00001109 8EDB                    	mov     ds,bx
  4707 0000110B 36A3[FF0B]              	mov     [ss:ENVIRSEG], ax	; save new environment segment
  4708 0000110F 8EC0                    	mov     es,ax
  4709 00001111 31F6                    	xor     si,si
  4710 00001113 89F7                    	mov     di,si
  4711 00001115 368B1E[D814]            	mov     bx,[ss:ENVMAX]
  4712 0000111A D1E3                    	shl     bx,1
  4713 0000111C D1E3                    	shl     bx,1
  4714 0000111E D1E3                    	shl     bx,1
  4715 00001120 D1E3                    	shl     bx,1
  4716 00001122 36891E[D814]            	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  4717 00001127 4B                      	dec     bx			; dec by one to leave room for double 0
  4718 00001128 31D2                    	xor     dx,dx			; use dx to indicate that there was
  4719                                  					; no environment size error.
  4720                                  
  4721                                  NXSTR:
  4722 0000112A E80D01                  	call    GETSTRLEN		; get the size of the current env string
  4723                                  
  4724 0000112D 1E                      	push    ds
  4725 0000112E 0E                      	push    cs
  4726 0000112F 1F                      	pop     ds
  4727 00001130 010E[DC14]              	add     [USEDENV],cx		; add the string length to env size
  4728 00001134 1F                      	pop     ds
  4729 00001135 83F901                  	cmp     cx,1			; end of environment was encountered.
  4730 00001138 7409                    	je      short ENVEXIT
  4731 0000113A 29CB                    	sub     bx,cx
  4732 0000113C 7303                    	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  4733 0000113E 42                      	inc     dx			; out of env space msg must be displayed
  4734 0000113F EB02                    	jmp     short ENVEXIT
  4735                                  
  4736                                  	;nop
  4737                                  
  4738                                  OKCPYSTR:
  4739 00001141 EBE7                    	jmp     short NXSTR
  4740                                  
  4741                                  ENVEXIT: 
  4742 00001143 0E                      	push    cs
  4743 00001144 1F                      	pop     ds
  4744 00001145 09D2                    	or      dx, dx			; dx will be non-zero if error
  4745 00001147 7406                    	jz      short ENVNOERR
  4746 00001149 BA[5014]                	mov     dx,OUTENVMSG		; dx = ptr to msg
  4747 0000114C E81001                  	call    RPRINT
  4748                                  
  4749                                  ENVNOERR:
  4750 0000114F 8B0E[D814]              	mov     cx,[ENVMAX]
  4751 00001153 29D9                    	sub     cx,bx			; current environment size in bytes
  4752 00001155 83C110                  	add     cx,16			; add memory arena to the size
  4753 00001158 D1E9                    	shr     cx,1
  4754 0000115A D1E9                    	shr     cx,1
  4755 0000115C D1E9                    	shr     cx,1
  4756 0000115E D1E9                    	shr     cx,1			; convert current env size to paragraphs
  4757 00001160 3B0E[D614]              	cmp     cx,[ENVSIZ]		; compare with env size previously set
  4758                                  	;jb	short SET_ENVSIZE
  4759 00001164 7604                    	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  4760 00001166 890E[D614]              	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  4761                                  
  4762                                  SET_ENVSIZE:
  4763 0000116A 8B1E[D614]              	mov     bx,[ENVSIZ]
  4764 0000116E 8CC0                    	mov     ax,es
  4765 00001170 01D8                    	add     ax,bx			; get end segment of environemnt
  4766 00001172 3B06[DE14]              	cmp     ax,[INITEND]		; compare with init code end segment
  4767 00001176 770E                    	ja      short NOPHEAD
  4768                                  					; free unused paragraghs		
  4769 00001178 8CC0                    	mov     ax,es
  4770 0000117A 8B1E[DE14]              	mov     bx,[INITEND]
  4771 0000117E 29C3                    	sub     bx,ax
  4772                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  4773 00001180 C706[E214]0100          	mov	word [RESETENV],1	; environment segment reset sign
  4774                                  
  4775                                  NOPHEAD:
  4776                                  	; MSDOS 3.3
  4777 00001186 B44A                    	mov     ah,SETBLOCK ; 4Ah
  4778 00001188 CD21                    	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  4779                                  			; ES = segment address of block to change
  4780                                  			; BX = new size in paragraphs
  4781                                  
  4782                                  	; MSDOS 3.3 & 6.0
  4783 0000118A 833E[930A]00            	cmp     word [BATCH],0		; did we set up a batch segment?
  4784 0000118F 7503                    	jnz     short DODATE		; yes - go initialize it
  4785 00001191 E99100                  	jmp     NODTTM			; don't do autoexec or date time
  4786                                  
  4787                                  DODATE:
  4788                                  ;
  4789                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  4790                                  ;
  4791                                  
  4792 00001194 A1[930A]                	mov	ax,[BATCH]		; get batch segment
  4793 00001197 C606[E90A]03            	mov	byte [ECHOFLAG],3	; set batch echo
  4794 0000119C C706[F80A]0100          	mov	word [NEST],1		; set nest flag to 1 batch
  4795 000011A2 8EC0                    	mov	es,ax
  4796                                  ;
  4797                                  ; initialize the segment
  4798                                  ;
  4799 000011A4 31FF                    	xor	di,di
  4800 000011A6 B000                    	mov	al,BATCHTYPE ; 0
  4801 000011A8 AA                      	stosb
  4802 000011A9 B001                    	mov	al,1			; initialize echo for batch exit
  4803 000011AB AA                      	stosb
  4804                                  ;
  4805                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  4806                                  ;
  4807 000011AC 31C0                    	xor	ax,ax			; initialize to zero
  4808                                  	;stosb	; MSDOS 6.0 		; clear out BatchEOF
  4809                                  
  4810 000011AE AB                      	stosw				; batch segment of last job - batlast
  4811 000011AF AB                      	stosw				; segment for FOR
  4812 000011B0 AA                      	stosb				; FOR flag
  4813 000011B1 AB                      	stosw				; position in file - batseek
  4814 000011B2 AB                      	stosw
  4815                                  ;
  4816                                  ; clean out the parameters
  4817                                  ;
  4818 000011B3 B8FFFF                  	mov	ax,-1			; initialize to no parameters
  4819 000011B6 B90A00                  	mov	cx,10
  4820 000011B9 F3AB                    	rep	stosw
  4821                                  ;
  4822                                  ; decide whether we should grab the default drive
  4823                                  ;
  4824 000011BB 803E[AE14]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  4825 000011C0 7509                    	jnz	short NOAUTSET
  4826 000011C2 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h
  4827 000011C4 CD21                    	int	21h
  4828                                  	; 02/03/2023
  4829 000011C6 0441                    	add	al,'A'
  4830                                  	;add	al,[letter_A] ; Ucasea
  4831 000011C8 A2[AE14]                	mov	[AUTOBAT],al
  4832                                  
  4833                                  NOAUTSET:
  4834                                  ;
  4835                                  ; copy in the batch file name (including nul)
  4836                                  ;
  4837                                  	;mov	si,offset ResGroup:AutoBat
  4838 000011CB BE[AE14]                	mov	si,AUTOBAT
  4839 000011CE B90800                  	mov	cx,8
  4840 000011D1 F3A5                    	rep	movsw
  4841                                  	;movsb	; MSDOS 6.0		; move in carriage return to terminate string
  4842                                  
  4843                                  	;mov	dx,offset ResGroup:AutoBat
  4844 000011D3 BA[AE14]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  4845                                  
  4846                                  	;mov	ax,OPEN shl 8
  4847 000011D6 B8003D                  	mov	ax,OPEN*256 ; 3D00h  ; open for read
  4848 000011D9 CD21                    	int	21h			; see if autoexec.bat exists
  4849 000011DB 7208                    	jc	short NOABAT
  4850 000011DD 89C3                    	mov	bx,ax
  4851 000011DF B43E                    	mov	ah,CLOSE  ; 3Eh
  4852 000011E1 CD21                    	int	21h
  4853 000011E3 EB4D                    	jmp	short DRV0		; go process autoexec
  4854                                  NOABAT:
  4855 000011E5 50                      	push	ax
  4856 000011E6 E85A00                  	call	SETUP_SEG
  4857 000011E9 A3[C914]                	mov	[TRIAGEADD+2],ax
  4858 000011EC 58                      	pop	ax
  4859 000011ED FF1E[C714]              	call	far [TRIAGEADD]		; get extended error
  4860 000011F1 83F841                  	cmp	ax,65			; network access denied?
  4861 000011F4 7506                    	jne	short OPENERR		; no - go deallocate batch
  4862                                  
  4863                                  _ACCDENERROR:					; yes - put out message
  4864                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  4865 000011F6 BA[3314]                	mov	dx,ACCDENERR
  4866 000011F9 E86300                  	call	RPRINT
  4867                                  OPENERR:
  4868 000011FC 8E06[930A]              	mov	es,[BATCH]		; not found--turn off batch job
  4869 00001200 B449                    	mov	ah,DEALLOC ; 49h
  4870 00001202 CD21                    	int	21h
  4871 00001204 C706[930A]0000          	mov	word [BATCH],0		; after dealloc in case of ^c
  4872 0000120A C606[E90A]01            	mov	byte [ECHOFLAG],1
  4873 0000120F C706[F80A]0000          	mov	word [NEST],0		; indicate no batch in progress
  4874                                  
  4875                                  DODTTM:
  4876                                  	;mov	ax,offset TranGroup:Datinit
  4877                                  
  4878 00001215 B80020                  	mov	ax,DATINIT
  4879 00001218 A3[BF14]                	mov	[INITADD],ax
  4880                                  
  4881                                  	; MSDOS 6.0
  4882                                  ;;;M004	mov	ax,TrnSeg	
  4883                                  ;
  4884                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  4885                                  ; M004; the transient starts on a para boundary at the label TranStart.
  4886                                  ; M004; We use TranStart to get the start of the transient segment.
  4887                                  ;
  4888                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  4889                                  	;mov	cl,4				; M004
  4890                                  	;shr	ax,cl				; get relative seg ; M004
  4891                                  	;mov	cx,cs
  4892                                  	;add	ax,cx				; ax = transient seg ; M004
  4893                                  
  4894                                  	; MSDOS 3.3
  4895                                  	; 25/09/2018
  4896 0000121B A1[DB0A]                	mov     ax,[TRNSEG]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  4897                                  
  4898                                  	; MSDOS 3.3 & MSDOS 6.0
  4899 0000121E A3[C114]                	mov	[INITADD+2],ax
  4900                                  	;call	dword ptr InitAdd
  4901 00001221 FF1E[BF14]              	call	far [INITADD]
  4902                                  NODTTM:
  4903                                  	; MSDOS 6.0
  4904                                  Copyright:
  4905                                  	;public	Copyright
  4906                                  ;	Bugbug:	remove Copyright label.
  4907                                  
  4908                                  ;if IBMVER
  4909                                  	;cmp	SingleCom,0
  4910                                  	;jnz	Drv0				; don't print header if singlecom
  4911                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4912                                  	;call	RPrint
  4913                                  ;endif
  4914                                  
  4915                                  	; MSDOS 3.3
  4916 00001225 833E[EF0A]00            	cmp	word [SINGLECOM],0	; don't print header if singlecom
  4917 0000122A 7506                    	jnz     short DRV0
  4918 0000122C BA[8F14]                	mov     dx,HEADERPTR	; dx = ptr to msg
  4919 0000122F E82D00                  	call    RPRINT
  4920                                  DRV0:
  4921                                  	; MSDOS 3.3
  4922 00001232 C606[550B]00                    mov     byte [INITFLAG],0
  4923 00001237 E9C1F1                  	jmp	ENDINIT
  4924                                  
  4925                                  	; MSDOS 6.0
  4926                                  ;Drv0:						; Reset APPEND state
  4927                                  ;	push	ds				; save data segment
  4928                                  ;	push	cs				; Get local segment into DS
  4929                                  ;	pop	ds				;
  4930                                  ;	mov	ax,APPENDSETSTATE		; Set the state of Append
  4931                                  ;	mov	bx,Append_State 		;  back to the original state
  4932                                  ;	int	2fh				;
  4933                                  ;	pop	ds				; get data segment back
  4934                                  ;;
  4935                                  ;;Check FirstCom set previously to see if this is the first instance of
  4936                                  ;;command.com. If not, we do not move command.com. Instead, we copy over the
  4937                                  ;;jump table from the previous stub to the current stub.
  4938                                  ;;
  4939                                  ;	cmp	FirstCom,1			;first command.com?
  4940                                  ;	jz	move_code			;yes, move it
  4941                                  ;
  4942                                  ;	push	es
  4943                                  ;	push	ds
  4944                                  ;
  4945                                  ;	push	ds
  4946                                  ;	pop	es
  4947                                  ;	mov	di,offset DATARES:Int2f_Entry
  4948                                  ;
  4949                                  ;	mov	ds,word ptr es:ResJmpTable+2	;get segment address
  4950                                  ;	mov	si,word ptr es:ResJmpTable	;get offset address
  4951                                  ;
  4952                                  ;	mov 	cx,NUM_RELOC_ENTRIES 		;number of dword ptrs
  4953                                  ;	shl	cx,1
  4954                                  ;	shl	cx,1				;size of table in bytes
  4955                                  ;
  4956                                  ;	cld
  4957                                  ;	rep	movsb				;copy the jump table
  4958                                  ;;
  4959                                  ;;Check if the resident code is in HMA. We assume that it is in HMA if its 
  4960                                  ;;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  4961                                  ;;
  4962                                  ;	cmp	es:[di-2],0f000h		;is resident code in HMA?
  4963                                  ;	jb	res_low				;no, dont set flag
  4964                                  ;
  4965                                  ;	mov	es:ComInHMA,1			;indicate code in HMA
  4966                                  ;
  4967                                  ;res_low:
  4968                                  ;	pop	ds
  4969                                  ;	pop	es
  4970                                  ;	jmp	short finish_init
  4971                                  ;;
  4972                                  ;;Now, we can move the resident code to its final location, either to HIMEM
  4973                                  ;;or to overlay the messages in the data segment if the user has not used the
  4974                                  ;;/msg switch.
  4975                                  ;;
  4976                                  ;move_code:
  4977                                  ;	call	Move_res_code			;move the code
  4978                                  ;
  4979                                  ;finish_init:
  4980                                  ;	jmp	RESGROUP:EndInit 		;g finish initializing
  4981                                  
  4982                                  
  4983                                  GETSTRLEN:
  4984                                  ;
  4985                                  ;	Get length of string pointed to by DS:SI.  Length includes NULL.
  4986                                  ;	Length is returned in CX
  4987                                  ;
  4988                                  	; MSDOS 3.3 & MSDOS 6.0
  4989 0000123A 31C9                    	xor	cx,cx
  4990                                  NXTCHAR:
  4991 0000123C AC                      	lodsb
  4992 0000123D 41                      	inc	cx
  4993 0000123E 08C0                    	or	al,al
  4994 00001240 75FA                    	jnz	short NXTCHAR
  4995 00001242 C3                      	retn
  4996                                  
  4997                                  SETUP_SEG:
  4998                                  ;
  4999                                  ; If the transient has been loaded in TranSeg, then we need to use that
  5000                                  ; segment for calls to routines in the transient area. Otherwise, the current
  5001                                  ; code segment is used
  5002                                  ; Segment returned in AX.
  5003                                  ;
  5004                                  	; MSDOS 3.3 & MSDOS 6.0
  5005 00001243 A1[DB0A]                	mov	ax,[TRNSEG]
  5006 00001246 803E[DD0A]01            	cmp	byte [TRNMVFLG],1	; Has transient portion been moved
  5007 0000124B 7411                    	je	short SETUP_END
  5008 0000124D 53                      	push	bx
  5009 0000124E 8CCB                    	mov	bx,cs
  5010                                  	;mov	ax,offset ResGroup:TranStart
  5011 00001250 B8[2015]                	mov	ax,TRANSTART
  5012 00001253 D1E8                    	shr	ax,1
  5013 00001255 D1E8                    	shr	ax,1
  5014 00001257 D1E8                    	shr	ax,1
  5015 00001259 D1E8                    	shr	ax,1
  5016 0000125B 01D8                    	add	ax,bx
  5017 0000125D 5B                      	pop	bx
  5018                                  SETUP_END:
  5019 0000125E C3                      	retn
  5020                                  
  5021                                  RPRINT:
  5022                                  	; MSDOS 3.3
  5023 0000125F 50                      	push    ax
  5024 00001260 E8E0FF                  	call    SETUP_SEG
  5025 00001263 A3[C514]                	mov     [PRINTADD+2], ax
  5026                                  	;call	dword ptr PRINTADD
  5027 00001266 FF1E[C314]              	call	far [PRINTADD]
  5028 0000126A 58                      	pop     ax
  5029 0000126B C3                      	retn
  5030                                  
  5031                                  	; MSDOS 6.0
  5032                                  ;***	RPrintParse - display parse error message
  5033                                  ;
  5034                                  ;	ENTRY	DX = parse error #
  5035                                  ;
  5036                                  ;	EXIT	nothing
  5037                                  ;
  5038                                  ;	USED	flags
  5039                                  ;
  5040                                  ;	EFFECTS
  5041                                  ;	  Message is displayed on stdout.
  5042                                  ;
  5043                                  ;RPrintParse	proc
  5044                                  ;
  5045                                  ;	assume	ds:ResGroup,ss:ResGroup
  5046                                  ;
  5047                                  ;	push	dx				; preserve DX
  5048                                  ;	xchg	bx,dx				; bx = parse error #
  5049                                  ;						; dx = saved BX
  5050                                  ;	dec	bx				; bx = parse error index, from 0
  5051                                  ;	shl	bx,1				; bx = offset in word table
  5052                                  ;	mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  5053                                  ;	xchg	bx,dx				; dx = ptr to error msg
  5054                                  ;						; bx = restored
  5055                                  ;	call	RPrint				; print the message
  5056                                  ;	pop	dx				; restore DX
  5057                                  ;	ret
  5058                                  ;
  5059                                  ;RPrintParse	endp
  5060                                  
  5061                                  PATHCHRCMPR:
  5062                                  	; MSDOS 3.3
  5063                                  	; 02/03/2023
  5064                                  	;push	dx
  5065                                  	;mov	dl,[slash_chr] ; '/'
  5066 0000126C 803E[130C]2F            	cmp	byte [RSWITCHAR],'/'
  5067                                  	;cmp	[RSWITCHAR],dl
  5068 00001271 7404                    	je	short RNOSLASHT
  5069 00001273 3C2F                    	cmp	al,'/'
  5070                                  	;cmp	al,dl
  5071 00001275 7402                    	je	short RET41 ; zf = 1 
  5072                                  RNOSLASHT:
  5073 00001277 3C5C                            cmp	al,'\'
  5074                                  	;cmp	al,[bslash_chr]
  5075                                  RET41:
  5076                                  	;pop	dx
  5077 00001279 C3                      	retn
  5078                                  
  5079                                  IFINDE:
  5080                                  	; MSDOS 3.3 & MSDOS 6.0
  5081 0000127A E80400                  	call	IFIND				; find the name
  5082 0000127D 722D                    	jc	short IFIND2			; carry means not found
  5083 0000127F EB3A                    	jmp	short ISCASB1 			; scan for = sign
  5084                                  ;
  5085                                  ; on return of find1, es:di points to beginning of name
  5086                                  ;
  5087                                  IFIND:
  5088 00001281 FC                      	cld
  5089 00001282 E82800                  	call	ICOUNT0 			; cx = length of name
  5090 00001285 8E06[FF0B]              	mov	es,[ENVIRSEG]
  5091 00001289 31FF                    	xor	di,di
  5092                                  IFIND1:
  5093 0000128B 51                      	push	cx
  5094 0000128C 56                      	push	si
  5095 0000128D 57                      	push	di
  5096                                  IFIND11:
  5097 0000128E AC                      	lodsb
  5098 0000128F E83500                  	call	IUPCONV
  5099 00001292 47                      	inc	di
  5100 00001293 263A45FF                	cmp	al,[es:di-1]
  5101 00001297 7502                    	jnz	short IFIND12
  5102 00001299 E2F3                    	loop	IFIND11
  5103                                  IFIND12:
  5104 0000129B 5F                      	pop	di
  5105 0000129C 5E                      	pop	si
  5106 0000129D 59                      	pop	cx
  5107 0000129E 740C                    	jz	short IFIND2
  5108 000012A0 51                      	push	cx
  5109 000012A1 E81B00                  	call	ISCASB2 			; scan for a nul
  5110 000012A4 59                      	pop	cx
  5111 000012A5 26803D00                	cmp	byte [es:di],0
  5112 000012A9 75E0                    	jnz	short IFIND1
  5113 000012AB F9                      	stc					; indicate not found
  5114                                  IFIND2:
  5115 000012AC C3                      	retn
  5116                                  
  5117                                  ICOUNT0:
  5118 000012AD 1E                      	push	ds
  5119 000012AE 07                      	pop	es
  5120 000012AF 89F7                    	mov	di,si
  5121                                  
  5122 000012B1 57                      	push	di				; count number of chars until "="
  5123 000012B2 E80600                  	call	ISCASB1
  5124                                  	; 25/09/2018
  5125                                  	;jmp	short ICOUNTX
  5126                                  	;push	di				; count number of chars until nul
  5127                                  	;call	ISCASB2
  5128                                  ;ICOUNTX:
  5129 000012B5 59                      	pop	cx
  5130 000012B6 29CF                    	sub	di,cx
  5131 000012B8 87F9                    	xchg	di,cx
  5132 000012BA C3                      	retn
  5133                                  
  5134                                  ISCASB1:
  5135                                  	; 02/03/2023
  5136 000012BB B03D                    	mov	al,"="
  5137                                  	;mov	al,[equal_sign]			; scan for an =
  5138 000012BD EB02                    	jmp	short ISCASBX
  5139                                  ISCASB2:
  5140 000012BF 30C0                    	xor	al,al				; scan for a nul
  5141                                  ISCASBX:
  5142 000012C1 B90001                  	mov	cx,256 ; 100h
  5143 000012C4 F2AE                    	repnz	scasb
  5144 000012C6 C3                      	retn
  5145                                  
  5146                                  IUPCONV:
  5147                                  	; MSDOS 3.3
  5148 000012C7 3C61                    	cmp	al,"a"
  5149                                  	; 02/03/2023
  5150                                  	;cmp	al,[letter_a]
  5151 000012C9 7206                    	jb	short IRET22
  5152 000012CB 3C7A                    	cmp	al,"z"
  5153                                  	;cmp	al,[letter_z]
  5154 000012CD 7702                    	ja	short IRET22
  5155 000012CF 2C20                    	sub	al,20h			; Lower-case changed to upper-case
  5156                                  IRET22:
  5157 000012D1 C3                              retn
  5158                                  
  5159                                  	; MSDOS 6.0
  5160                                  ; ****************************************************************
  5161                                  ; *
  5162                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  5163                                  ; *
  5164                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  5165                                  ; *		 the character in AL from the file upper case table
  5166                                  ; *		 in DOS if character if above  ascii 128, else
  5167                                  ; *		 subtracts 20H if between "a" and "z".
  5168                                  ; *
  5169                                  ; * INPUT:	 DS	      set to resident
  5170                                  ; *		 AL	      char to be upper cased
  5171                                  ; *		 FUCASE_ADDR  set to the file upper case table
  5172                                  ; *
  5173                                  ; * OUTPUT:	 AL	      upper cased character
  5174                                  ; *
  5175                                  ; ****************************************************************
  5176                                  ;
  5177                                  ;IupConv proc	near				
  5178                                  ;	assume	ds:ResGroup			;
  5179                                  ;
  5180                                  ;	cmp	al,80h				; see if char is > ascii 128
  5181                                  ;	jb	other_fucase			; no - upper case math
  5182                                  ;	sub	al,80h				; only upper 128 chars in table
  5183                                  ;	push	ds				;
  5184                                  ;	push	bx				;
  5185                                  ;	lds	bx,dword ptr fucase_addr+1		; get table address
  5186                                  ;	add	bx,2				; skip over first word
  5187                                  ;	xlat	ds:byte ptr [bx]			; convert to upper case
  5188                                  ;	pop	bx				;
  5189                                  ;	pop	ds				;
  5190                                  ;	jmp	short iupconv_end			; we finished - exit
  5191                                  ;
  5192                                  ;other_fucase:					;
  5193                                  ;	cmp	al,Lcasea			; if between "a" and "z",
  5194                                  ;	jb	iupconv_end			;     subtract 20h to get
  5195                                  ;	cmp	al,Lcasez			; upper case equivalent.
  5196                                  ;	ja	iupconv_end			;
  5197                                  ;	sub	al,20h				; Change lower-case to upper
  5198                                  ;
  5199                                  ;iupconv_end:					;
  5200                                  ;	ret
  5201                                  ;
  5202                                  ;IupConv endp					;
  5203                                  
  5204                                  
  5205                                  INIT_CONTC_SPECIALCASE:
  5206                                  	; MSDOS 3.3 & MSDOS 6.0
  5207                                  						; This routine is called if control-C
  5208 000012D2 83C406                  	add	sp,6				;  is type during the date/time prompt
  5209 000012D5 56                      	push	si				;  at initialization time.  The desired
  5210 000012D6 89D6                    	mov	si,dx				;  response is to make it look like the
  5211 000012D8 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  5212 000012DD 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  5213 000012DE CF                      	iret					;  a <CR> in the user's buffer, and
  5214                                  						;  returning directly to the user.
  5215                                  						; In this case the user is TCODE.
  5216                                  
  5217                                  ;=============================================================================
  5218                                  ; UNINIT.ASM, MSDOS 6.0 ,1991
  5219                                  ;=============================================================================
  5220                                  ; 24/09/2018 - Retro DOS v3.0
  5221                                  
  5222                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  5223                                  
  5224                                  ; TITLE	COMMAND Initialization messages
  5225                                  
  5226                                  ;INIT	SEGMENT PUBLIC PARA
  5227                                  
  5228                                  	; 25/09/2018
  5229                                  	; (15 bytes filler)
  5230 000012DF 00                      	db 0
  5231                                  	;db "25/9/2018 ETAN"
  5232 000012E0 30322F30332F323032-     	db "02/03/2023 ETAN" ; 02/03/2023	
  5232 000012E9 33204554414E       
  5233 000012EF 00                      	db 0
  5234                                  
  5235                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  5236                                  	;dw 0
  5237                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  5238 000012F0 0D0A                    	db 0Dh,0Ah
  5239 000012F2 0D0A                    	db 0Dh,0Ah
  5240 000012F4 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  5240 000012FD 285229204D532D444F-
  5240 00001306 532852292020566572-
  5240 0000130F 73696F6E20332E3330 
  5241 00001318 0D0A                    	db 0Dh,0Ah
  5242 0000131A 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1987               '
  5242 00001323 20202020284329436F-
  5242 0000132C 70797269676874204D-
  5242 00001335 6963726F736F667420-
  5242 0000133E 436F72702031393831-
  5242 00001347 2D3139383720202020-
  5242 00001350 202020202020202020-
  5242 00001359 2020               
  5243 0000135B 200D0A                  	db ' ',0Dh,0Ah
  5244 0000135E 202020202020202020-     	db '                                                   ',
  5244 00001367 202020202020202020-
  5244 00001370 202020202020202020-
  5244 00001379 202020202020202020-
  5244 00001382 202020202020202020-
  5244 0000138B 202020202020       
  5245 00001391 0D0A00                  	db 0Dh,0Ah,0
  5246                                  
  5247 00001394 20<rep 2Bh>             	times	43 db 20h
  5248                                  
  5249 000013BF 537065636966696564-     _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  5249 000013C8 20434F4D4D414E4420-
  5249 000013D1 736561726368206469-
  5249 000013DA 726563746F72792062-
  5249 000013E3 61640D0A00         
  5250                                  BADCOMLKMES:
  5251 000013E8 [BF13]                  	dw _152Fh
  5252                                  
  5253 000013EA 537065636966696564-     _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  5253 000013F3 20434F4D4D414E4420-
  5253 000013FC 736561726368206469-
  5253 00001405 726563746F72792062-
  5253 0000140E 616420616363657373-
  5253 00001417 2064656E6965640D0A-
  5253 00001420 00                 
  5254                                  BADCOMACCMSG:
  5255 00001421 [EA13]                  	dw _155Ah
  5256                                  
  5257 00001423 416363657373206465-     _1593h:	db 'Access denied',0Dh,0Ah,0
  5257 0000142C 6E6965640D0A00     
  5258                                  ACCDENERR:
  5259 00001433 [2314]                  	dw _1593h
  5260                                  
  5261 00001435 4F7574206F6620656E-     _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  5261 0000143E 7669726F6E6D656E74-
  5261 00001447 2073706163650D0A00 
  5262                                  OUTENVMSG:
  5263 00001450 [3514]                  	dw _15A5h
  5264                                  
  5265                                  BADVERMSG:
  5266 00001452 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah,'$'
  5266 0000145B 20444F532076657273-
  5266 00001464 696F6E0D0A24       
  5267                                  
  5268                                  BADENVSIZMSG:
  5269 0000146A 496E76616C69642065-     	db 'Invalid environment size specified',0Dh,0Ah,'$'
  5269 00001473 6E7669726F6E6D656E-
  5269 0000147C 742073697A65207370-
  5269 00001485 656369666965640D0A-
  5269 0000148E 24                 
  5270                                  
  5271                                  HEADERPTR:
  5272 0000148F [F012]                  	dw COPYRIGHTMSG
  5273                                  
  5274                                  ICONDEV:
  5275 00001491 2F4445562F                      db '/DEV/'
  5276 00001496 434F4E                  	db 'CON'
  5277 00001499 000000000000            	db 0,0,0,0,0,0		; Room for 8 char device	
  5278                                  BADCSPFL:
  5279 0000149F 00                      	db 0
  5280                                  COMSPECT:
  5281 000014A0 2F434F4D4D414E442E-     	db '/COMMAND.COM',0
  5281 000014A9 434F4D00           
  5282 000014AD 00                      	db 0
  5283                                  AUTOBAT:
  5284 000014AE 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0 
  5284 000014B7 45432E42415400     
  5285                                  PRDATTM:
  5286 000014BE FF                      	db -1 ; 0FFh		 ; Init not to prompt for date time
  5287                                  INITADD:
  5288 000014BF 00000000                	dd 0
  5289                                  	;dw 0
  5290                                  	;dw 0
  5291                                  PRINTADD:
  5292 000014C3 1534                    	dw PRINTF_INIT
  5293 000014C5 0000                    	dw 0
  5294                                  TRIAGEADD:
  5295 000014C7 A01E                    	dw TRIAGE_INIT
  5296 000014C9 0000                    	dw 0
  5297                                  CHUCKENV:
  5298 000014CB 00                      	db 0
  5299                                  COMSPOFFSET:
  5300                                  ECOMLOC:
  5301                                  	;dw 0Eh
  5302                                  	;dw offset ENVIRONMENT:ECOMSPEC-10h
  5303 000014CC 0E00                    	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  5304                                  COMSPSTRING:
  5305 000014CE 434F4D535045433D        	db 'COMSPEC='
  5306                                  
  5307                                  ; 02/03/2023
  5308                                  ;equal_sign:
  5309                                  ;	db '='
  5310                                  ;letter_a:
  5311                                  ;	db 'a'
  5312                                  ;letter_z:
  5313                                  ;	db 'z'
  5314                                  ;slash_chr:
  5315                                  ;	db '/'
  5316                                  ;bslash_chr:
  5317                                  ;	db '\'
  5318                                  ;space_chr:
  5319                                  ;	db 20h
  5320                                  ;letter_p:
  5321                                  ;	db 'p'
  5322                                  ;letter_d:
  5323                                  ;	db 'd'
  5324                                  ;letter_c:
  5325                                  ;	db 'c'
  5326                                  ;letter_A:
  5327                                  ;	db 'A'
  5328                                  ENVSIZ:
  5329 000014D6 0000                    	dw 0
  5330                                  ENVMAX:
  5331 000014D8 0000                    	dw 0
  5332                                  OLDENV:
  5333 000014DA 0000                    	dw 0
  5334                                  USEDENV:
  5335 000014DC 0000                    	dw 0
  5336                                  INITEND:
  5337 000014DE 0000                    	dw 0
  5338                                  TRNSIZE:
  5339 000014E0 0000                    	dw 0
  5340                                  RESETENV:
  5341 000014E2 0000                    	dw 0
  5342                                  
  5343                                  ;INIT	ENDS
  5344                                  
  5345                                  ;	END
  5346                                  
  5347                                  ;-----------------------------------------------------------------------------
  5348                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  5349                                  ;-----------------------------------------------------------------------------
  5350                                  
  5351                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  5352                                  ; 12/01/2023
  5353 000014E4 526574726F20444F53-     db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018-2023]"
  5353 000014ED 2076332E3020434F4D-
  5353 000014F6 4D414E442E434F4D20-
  5353 000014FF 6279204572646F6761-
  5353 00001508 6E2054616E205B3230-
  5353 00001511 31382D323032335D   
  5354 00001519 00                      db	0
  5355                                  
  5356                                  ;-----------------------------------------------------------------------------
  5357                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  5358                                  ;-----------------------------------------------------------------------------
  5359                                  
  5360                                  ;TAIL    SEGMENT PUBLIC PARA
  5361                                  ;        ORG     0
  5362                                  ;TRANSTART       LABEL   WORD
  5363                                  ;TAIL    ENDS
  5364                                  
  5365 0000151A 90<rep 6h>              ALIGN 16  ; 25/09/2018
  5366                                  
  5367                                  ;TRANSTART:
  5368                                  
  5369                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  5370                                  ;	times	128 db 0	
  5371                                  
  5372                                  ;-----------------------------------------------------------------------------
  5373                                  ; SEGMENT - TRANSCODE
  5374                                  ;-----------------------------------------------------------------------------
  5375                                  
  5376                                  TRANGROUP: ; 21/04/2018
  5377                                  
  5378                                  ;=============================================================================
  5379                                  ; TRANCODE.ASM
  5380                                  ;=============================================================================
  5381                                  ; 24/09/2018 - Retro DOS v3.0
  5382                                  
  5383                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  5384                                  
  5385                                  ; 21/04/2018 - Retro DOS v2.0
  5386                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  5387                                  ; (these values must be changed when transcom.s source code is changed
  5388                                  ; and data offsets are changed)
  5389                                  ;
  5390                                  ; 30/04/2018
  5391                                  ; 29/04/2018
  5392                                  
  5393                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5394                                  ;COMMAND      EQU  012CH
  5395                                  ;DATINIT      EQU  2091H
  5396                                  ;HEADCALL     EQU  428FH
  5397                                  ;TRANSPACEEND EQU  4D5CH
  5398                                  ;TRANDATAEND  EQU  3F44H
  5399                                  
  5400                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5401                                  ;TRIAGE_INIT  EQU  1F15H
  5402                                  ;PRINTF_INIT  EQU  34E0H 
  5403                                  
  5404                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  5405                                  
  5406                                  ;TPA	EQU  4293H
  5407                                  ;TRNLEN	EQU  04D6H
  5408                                  
  5409                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  5410                                  COMMAND      EQU  012CH
  5411                                  ;GETEXTERRNUM EQU 1ECCH ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  5412                                  ;TRIAGE_INIT EQU  1EF3H
  5413                                  ;DATINIT     EQU  206FH
  5414                                  ; 02/03/2023
  5415                                  GETEXTERRNUM EQU  1E79H
  5416                                  TRIAGE_INIT  EQU  1EA0H
  5417                                  DATINIT	     EQU  2000H		
  5418                                  PRINTF_INIT  EQU  3415H
  5419                                  TRANDATAEND  EQU  3E35H
  5420                                  HEADCALL     EQU  417FH
  5421                                  TRANSPACEEND EQU  4C4CH
  5422                                  
  5423                                  ;-----------------------------------------------------------------------------
  5424                                  ;START OF TRANSIENT PORTION
  5425                                  ;This code is loaded at the end of memory and may be overwritten by
  5426                                  ;memory-intensive user programs.
  5427                                  ;-----------------------------------------------------------------------------
  5428                                  
  5429                                  ;TRANSTART EQU $
  5430                                  ; 29/09/2018 
  5431                                  TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  5432                                  
  5433                                  ; 25/09/2018
  5434                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  5435                                  ;
  5436                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  5437                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  5438                                  ;
  5439                                  TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  5440                                  ;
  5441                                  
  5442                                  ;COMTRANS:
  5443                                  
  5444                                  ; 20/10/2018 - Retro DOS v3.0	
  5445 00001520 <bin 4C4Ch>             INCBIN	"TRANCOM3.BIN"
  5446                                  
  5447                                  ;COMLEN	EQU $-COMTRANS	; End of COMMAND load.
  5448                                  
  5449                                  ; 29/04/2018
  5450                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  5451                                  ;
  5452                                  ;TIMES BSS_SIZE db 0
  5453                                  ;
  5454                                  ;COMLEN	EQU $-COMTRANS	; 30/04/2018
  5455                                  
  5456                                  ;COMMANDCOMSIZE equ $ - 100h
