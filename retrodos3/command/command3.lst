     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 01/03/2023 ((Previous: 20/10/2018))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11 
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  
    43                                  ;============================================================================
    44                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    45                                  ;============================================================================
    46                                  ; 21/09/2018 - Retro DOS v3.0
    47                                  
    48                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    49                                  ;BREAK <system call definitions>
    50                                  
    51                                  ;
    52                                  ;	Microsoft Confidential
    53                                  ;	Copyright (C) Microsoft Corporation 1991
    54                                  ;	All Rights Reserved.
    55                                  ;
    56                                  
    57                                  ;SUBTTL	system call definitions
    58                                  ;PAGE
    59                                  
    60                                  Abort				EQU 0	;  0	  0
    61                                  STD_CON_INPUT			EQU 1	;  1	  1
    62                                  Std_Con_Output			EQU 2	;  2	  2
    63                                  Std_Aux_Input			EQU 3	;  3	  3
    64                                  Std_Aux_Output			EQU 4	;  4	  4
    65                                  Std_Printer_Output		EQU 5	;  5	  5
    66                                  Raw_Con_IO			EQU 6	;  6	  6
    67                                  RAW_CON_INPUT			EQU 7	;  7	  7
    68                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    69                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    70                                  Std_Con_String_Input		EQU 10	; 10	  A
    71                                  Std_Con_Input_Status		EQU 11	; 11	  B
    72                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    73                                  DISK_RESET			EQU 13	; 13	  D
    74                                  Set_Default_Drive		EQU 14	; 14	  E
    75                                  FCB_Open			EQU 15	; 15	  F
    76                                  FCB_Close			EQU 16	; 16	 10
    77                                  Dir_Search_First		EQU 17	; 17	 11
    78                                  Dir_Search_Next 		EQU 18	; 18	 12
    79                                  FCB_Delete			EQU 19	; 19	 13
    80                                  FCB_Seq_Read			EQU 20	; 20	 14
    81                                  FCB_Seq_Write			EQU 21	; 21	 15
    82                                  FCB_Create			EQU 22	; 22	 16
    83                                  FCB_Rename			EQU 23	; 23	 17
    84                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    85                                  Set_DMA 			EQU 26	; 26	 1A
    86                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    87                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    88                                  ;									   ;
    89                                  Get_Default_DPB 		EQU 31	; 31	 1F
    90                                  ;									   ;
    91                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    92                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    93                                  FCB_Random_Read 		EQU 33	; 33	 21
    94                                  FCB_Random_Write		EQU 34	; 34	 22
    95                                  Get_FCB_File_Length		EQU 35	; 35	 23
    96                                  Get_FCB_Position		EQU 36	; 36	 24
    97                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
    98                                  Create_Process_Data_Block	EQU 38	; 38	 26
    99                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   100                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   101                                  Parse_File_Descriptor		EQU 41	; 41	 29
   102                                  Get_Date			EQU 42	; 42	 2A
   103                                  Set_Date			EQU 43	; 43	 2B
   104                                  Get_Time			EQU 44	; 44	 2C
   105                                  Set_Time			EQU 45	; 45	 2D
   106                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   107                                  ; Extended functionality group
   108                                  Get_DMA 			EQU 47	; 47	 2F
   109                                  GET_VERSION			EQU 48	; 48	 30
   110                                  Keep_Process			EQU 49	; 49	 31
   111                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;									   ;
   114                                  Get_DPB 			EQU 50	; 50	 32
   115                                  ;									   ;
   116                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   117                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   118                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   119                                  Get_InDOS_Flag			EQU 52	; 52	 34
   120                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   121                                  Get_Drive_Freespace		EQU 54	; 54	 36
   122                                  CHAR_OPER			EQU 55	; 55	 37
   123                                  International			EQU 56	; 56	 38
   124                                  ;   Directory Group
   125                                  MKDir				EQU 57	; 57	 39
   126                                  RMDir				EQU 58	; 58	 3A
   127                                  CHDir				EQU 59	; 59	 3B
   128                                  ;   File Group
   129                                  Creat				EQU 60	; 60	 3C
   130                                  OPEN				EQU 61	; 61	 3D
   131                                  CLOSE				EQU 62	; 62	 3E
   132                                  READ				EQU 63	; 63	 3F
   133                                  Write				EQU 64	; 64	 40
   134                                  Unlink				EQU 65	; 65	 41
   135                                  LSEEK				EQU 66	; 66	 42
   136                                  CHMod				EQU 67	; 67	 43
   137                                  IOCTL				EQU 68	; 68	 44
   138                                  XDUP				EQU 69	; 69	 45
   139                                  XDup2				EQU 70	; 70	 46
   140                                  Current_Dir			EQU 71	; 71	 47
   141                                  ;    Memory Group
   142                                  ALLOC				EQU 72	; 72	 48
   143                                  DEALLOC				EQU 73	; 73	 49
   144                                  SETBLOCK			EQU 74	; 74	 4A
   145                                  ;    Process Group
   146                                  Exec				EQU 75	; 75	 4B
   147                                  EXIT				EQU 76	; 76	 4C
   148                                  WAITPROCESS			EQU 77	; 77	 4D
   149                                  Find_First			EQU 78	; 78	 4E
   150                                  ;   Special Group
   151                                  Find_Next			EQU 79	; 79	 4F
   152                                  ; SPECIAL SYSTEM GROUP
   153                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   154                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   155                                  ;									   ;
   156                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   157                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   158                                  Get_In_Vars			EQU 82	; 82	 52
   159                                  SetDPB				EQU 83	; 83	 53
   160                                  ;									   ;
   161                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   162                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   163                                  Get_Verify_On_Write		EQU 84	; 84	 54
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   166                                  ;									   ;
   167                                  Dup_PDB 			EQU 85	; 85	 55
   168                                  ;									   ;
   169                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   170                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   171                                  Rename				EQU 86	; 86	 56
   172                                  File_Times			EQU 87	; 87	 57
   173                                  AllocOper			EQU 88	; 88	 58
   174                                  ; Network extention system calls
   175                                  GetExtendedError		EQU 89	; 89	 59
   176                                  CreateTempFile			EQU 90	; 90	 5A
   177                                  CreateNewFile			EQU 91	; 91	 5B
   178                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   179                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   180                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   181                                  ;									   ;
   182                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   183                                  					;	    CloseByName, CloseUser,
   184                                  					;	    CloseUserProcess,
   185                                  					;	    GetOpenFileList
   186                                  ;									   ;
   187                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   188                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   189                                  UserOper			EQU 94	; 94	 5E Get and Set
   190                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   191                                  xNameTrans			EQU 96	; 96	 60
   192                                  PathParse			EQU 97	; 97	 61
   193                                  GetCurrentPSP			EQU 98	; 98	 62
   194                                  Hongeul 			EQU 99	; 99	 63
   195                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   196                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   197                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   198                                  ;									   ;
   199                                  Set_Printer_Flag		EQU 100 ; 100	 64
   200                                  ;									   ;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   203                                  GetExtCntry			EQU 101 ; 101	 65
   204                                  GetSetCdPg			EQU 102 ; 102	 66
   205                                  ExtHandle			EQU 103 ; 103	 67
   206                                  Commit				EQU 104 ; 104	 68
   207                                  GetSetMediaID			EQU 105 ; 105	 69
   208                                  IFS_IOCTL			EQU 107 ; 107	 6B
   209                                  ExtOpen 			EQU 108 ; 108	 6C
   210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   211                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   212                                  ;                                                                          ;
   213                                  ;ifdef ROMEXEC
   214                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   215                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   216                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   217                                  ;endif
   218                                  ;                                                                          ;
   219                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   220                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   221                                  ;
   222                                  ;
   223                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   224                                  OEM_C1				EQU 249 ; 249	 F9
   225                                  OEM_C2				EQU 250 ; 250	 FA
   226                                  OEM_C3				EQU 251 ; 251	 FB
   227                                  OEM_C4				EQU 252 ; 252	 FC
   228                                  OEM_C5				EQU 253 ; 253	 FD
   229                                  OEM_C6				EQU 254 ; 254	 FE
   230                                  OEM_C7				EQU 255 ; 255	 FF
   231                                  
   232                                  ;============================================================================
   233                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   234                                  ;============================================================================
   235                                  ; 21/09/2018 - Retro DOS v3.0
   236                                  
   237                                  ;BREAK <Control character definitions>
   238                                  
   239                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   240                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   241                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   242                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   243                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   244                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   245                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   246                                  c_HT	    EQU     09h 		; ^I ASCII tab
   247                                  
   248                                  ;============================================================================
   249                                  ; DIRENT.INC, MSDOS 6.0, 1991
   250                                  ;============================================================================
   251                                  ; 21/09/2018 - Retro DOS v3.0
   252                                  
   253                                  ;Break <Directory entry>
   254                                  
   255                                  ;	NOTE:  These offsets are also used in the DTA for
   256                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   257                                  ;	with the FCB filename field, and the rest of the
   258                                  ;	DIR_ENTRY fields follow. -DavidOls
   259                                  
   260                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   261                                  ;
   262                                  ;	+---------------------------+
   263                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   264                                  ;	+---------------------------+
   265                                  ;	|     (BYTE) attributes     |	    11	    B
   266                                  ;	+---------------------------+
   267                                  ;	|    (10 BYTE) reserved     |	    12	    C
   268                                  ;	+---------------------------+
   269                                  ;	| (WORD) time of last write |	    22	    16
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) date of last write |	    24	    18
   272                                  ;	+---------------------------+
   273                                  ;	|   (WORD) First cluster    |	    26	    1A
   274                                  ;	+---------------------------+
   275                                  ;	|     (DWORD) file size     |	    28	    1C
   276                                  ;	+---------------------------+
   277                                  ;
   278                                  ;   First byte of filename  = E5 -> free directory entry
   279                                  ;			    = 00 -> end of allocated directory
   280                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   281                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   282                                  ;
   283                                  
   284                                  STRUC DIR_ENTRY
   285 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   286 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   287 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   288 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   289 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   290 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   291 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   292 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   293 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   294 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   295 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   296                                  .size:
   297                                  
   298                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   299                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   300                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   301                                  ;	    this field is zero for subdirectory files.
   302                                  
   303                                  ENDSTRUC
   304                                  
   305                                  ATTR_READ_ONLY	equ	 1h
   306                                  ATTR_HIDDEN	equ	 2h
   307                                  ATTR_SYSTEM	equ	 4h
   308                                  ATTR_VOLUME_ID	equ	 8h
   309                                  ATTR_DIRECTORY	equ	10h
   310                                  ATTR_ARCHIVE	equ	20h
   311                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   312                                  				;   NO directory entry on a disk EVER
   313                                  				;   has this bit set. It is set non-zero
   314                                  				;   when a device is found by GETPATH
   315                                  
   316                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   317                                  				; OR of hard attributes for FINDENTRY
   318                                  
   319                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   320                                  				; ignore this(ese) attribute(s) during
   321                                  				; search first/next
   322                                  
   323                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   324                                  				; changeable via CHMOD
   325                                  
   326                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   327                                  
   328                                  ;============================================================================
   329                                  ; ERROR.INC, MSDOS 6.0, 1991
   330                                  ;============================================================================
   331                                  ; 21/09/2018 - Retro DOS v3.0
   332                                  
   333                                  ;**	ERROR.INC - DOS Error Codes
   334                                  ;
   335                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   336                                  ;    return error codes through AX.	If an error occurred then
   337                                  ;    the carry bit will be set and the error code is in AX.	If no error
   338                                  ;    occurred then the carry bit is reset and AX contains returned info.
   339                                  ;
   340                                  ;    Since the set of error codes is being extended as we extend the operating
   341                                  ;    system, we have provided a means for applications to ask the system for a
   342                                  ;    recommended course of action when they receive an error.
   343                                  ;
   344                                  ;    The GetExtendedError system call returns a universal error, an error
   345                                  ;    location and a recommended course of action.	The universal error code is
   346                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   347                                  ;    is issued.
   348                                  
   349                                  
   350                                  ;	2.0 error codes
   351                                  
   352                                  error_invalid_function		EQU	1
   353                                  ERROR_FILE_NOT_FOUND		EQU	2
   354                                  error_path_not_found		EQU	3
   355                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   356                                  ERROR_ACCESS_DENIED		EQU	5
   357                                  error_invalid_handle		EQU	6
   358                                  error_arena_trashed		EQU	7
   359                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   360                                  error_invalid_block		EQU	9
   361                                  error_bad_environment		EQU	10
   362                                  ERROR_BAD_FORMAT		EQU	11
   363                                  error_invalid_access		EQU	12
   364                                  error_invalid_data		EQU	13
   365                                  ;**** reserved			EQU	14	; *****
   366                                  error_invalid_drive		EQU	15
   367                                  error_current_directory 	EQU	16
   368                                  error_not_same_device		EQU	17
   369                                  error_no_more_files		EQU	18
   370                                  
   371                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   372                                  
   373                                  ERROR_WRITE_PROTECT		EQU	19
   374                                  error_bad_unit			EQU	20
   375                                  error_not_ready 		EQU	21
   376                                  error_bad_command		EQU	22
   377                                  error_CRC			EQU	23
   378                                  error_bad_length		EQU	24
   379                                  error_Seek			EQU	25
   380                                  error_not_DOS_disk		EQU	26
   381                                  error_sector_not_found		EQU	27
   382                                  error_out_of_paper		EQU	28
   383                                  error_write_fault		EQU	29
   384                                  error_read_fault		EQU	30
   385                                  ERROR_GEN_FAILURE		EQU	31
   386                                  
   387                                  ;	the new 3.0 error codes reported through INT 24
   388                                  
   389                                  error_sharing_violation 	EQU	32
   390                                  error_lock_violation		EQU	33
   391                                  error_wrong_disk		EQU	34
   392                                  ERROR_FCB_UNAVAILABLE		EQU	35
   393                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   394                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   395                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   396                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   397                                  
   398                                  ;	New OEM network-related errors are 50-79
   399                                  
   400                                  error_not_supported		EQU	50
   401                                  
   402                                  error_net_access_denied		EQU	65	;M028
   403                                  
   404                                  ;	End of INT 24 reportable errors
   405                                  
   406                                  error_file_exists		EQU	80
   407                                  error_DUP_FCB			EQU	81	; *****
   408                                  error_cannot_make		EQU	82
   409                                  error_FAIL_I24			EQU	83
   410                                  
   411                                  ;	New 3.0 network related error codes
   412                                  
   413                                  error_out_of_structures 	EQU	84
   414                                  error_Already_assigned		EQU	85
   415                                  error_invalid_password		EQU	86
   416                                  error_invalid_parameter 	EQU	87
   417                                  error_NET_write_fault		EQU	88
   418                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   419                                  
   420                                  ;============================================================================
   421                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   422                                  ;============================================================================
   423                                  ; 22/09/2018 - Retro DOS v3.0
   424                                  
   425                                  ;**	DevSym.inc - Device Symbols
   426                                  
   427                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   428                                  
   429                                  STRUC SYSDEV
   430 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   431 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   432 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   433 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   434 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   435                                  .size:
   436                                  ENDSTRUC
   437                                  
   438                                  ; 24/09/2018
   439                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   440                                  
   441                                  ;============================================================================
   442                                  ; CURDIR.INC, MSDOS 6.0, 1991
   443                                  ;============================================================================
   444                                  ; 21/09/2018 - Retro DOS v3.0
   445                                  
   446                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   447                                  
   448                                  ;============================================================================
   449                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   450                                  ;============================================================================
   451                                  ; 21/09/2018 - Retro DOS v3.0
   452                                  
   453                                  ;/*
   454                                  ; *                      Microsoft Confidential
   455                                  ; *                      Copyright (C) Microsoft Corporation 1991
   456                                  ; *                      All Rights Reserved.
   457                                  ; */
   458                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   459                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   460                                  ;*************************************
   461                                  ; COMMAND EQUs which are not switch dependant
   462                                  
   463                                  ;		include	curdir.inc	; to get DIRSTRLEN
   464                                  ;		Note dossym.inc must already have been included!
   465                                  
   466                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   467                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   468                                  
   469                                  SYM		EQU	">"
   470                                  
   471                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   472                                  
   473                                  NORMPERLIN	EQU	1
   474                                  WIDEPERLIN	EQU	5
   475                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   476                                  BatLen		EQU	32		; buffer for batch files
   477                                  YES_ECHO	EQU	1		; echo line
   478                                  NO_ECHO 	EQU	0		; don't echo line
   479                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   480                                  call_in_progress EQU	1		; indicate we're in the CALL command
   481                                  length_call	EQU	4		; length of CALL
   482                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   483                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   484                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   485                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   486                                  nullcommand	EQU    1		; no command on command line
   487                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   488                                  end_of_line_out EQU	0		;AN000; end of line for output
   489                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   490                                  result_number	EQU	1		;AN000; number returned from parser
   491                                  result_string	EQU	3		;AN000; string returned from parser
   492                                  result_filespec EQU	5		;AN000; filespec returned from parser
   493                                  result_drive	EQU	6		;AN000; drive returned from parser
   494                                  result_date	EQU	7		;AN000; date returned from parser
   495                                  result_time	EQU	8		;AN000; time returned from parser
   496                                  result_no_error EQU	0		;AN000; no error returned from parser
   497                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   498                                  util_msg_class	EQU	-1		;AN000; message class for utility
   499                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   500                                  parse_msg_class EQU	2		;AN000; message class for parse error
   501                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   502                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   503                                  colon_char	EQU	":"             ;AN000; colon character
   504                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   505                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   506                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   507                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   508                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   509                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   510                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   511                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   512                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   513                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   514                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   515                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   516                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   517                                  parm_block_size equ	11		;AN000; size of message subst block
   518                                  blank		equ	" "             ;AN000; blank character
   519                                  no_subst	equ	0		;AN000; no substitutions for messages
   520                                  one_subst	equ	1		;AN000; one substitution for messages
   521                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   522                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   523                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   524                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   525                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   526                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   527                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   528                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   529                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   530                                  capital_A	equ	'A'             ;AC000;
   531                                  vbar		equ	'|'             ;AC000;
   532                                  labracket	equ	'<'             ;AC000;
   533                                  rabracket	equ	'>'             ;AC000;
   534                                  dollar		equ	'$'             ;AC000;
   535                                  lparen		equ	'('             ;AC000;
   536                                  rparen		equ	')'             ;AC000;
   537                                  nullrparen	equ	29h		;AC000;
   538                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   539                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   540                                  star		equ	'*'             ;AC000;
   541                                  plus_chr	equ	'+'             ;AC000;
   542                                  small_a 	equ	'a'             ;AC000;
   543                                  small_z 	equ	'z'             ;AC000;
   544                                  dot_chr 	equ	'.'             ;AC000;
   545                                  tab_chr 	equ	9		;AN032;
   546                                  equal_chr	equ	'='             ;AN032;
   547                                  semicolon	equ	';'             ;AN049;
   548                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   549                                  dot_colon	equ	2e3ah		;AC000; '.:'
   550                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   551                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   552                                  AppendInstall	equ	0B700H		;AN020; append install check
   553                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   554                                  AppendGetState	equ	0B706H		;AN020; append get current state
   555                                  AppendSetState	equ	0B707H		;AN020; append set current state
   556                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   557                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   558                                  
   559                                  ;*************************************
   560                                  ;* PARSE ERROR MESSAGES
   561                                  ;*************************************
   562                                  
   563                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   564                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   565                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   566                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   567                                  
   568                                  ;*************************************
   569                                  ;* EQUATES FOR MESSAGE RETRIEVER
   570                                  ;*************************************
   571                                  
   572                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   573                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   574                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   575                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   576                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   577                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   578                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   579                                  
   580                                  ;*********************************
   581                                  ;* EQUATES FOR INT 10H
   582                                  ;*********************************
   583                                  
   584                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   585                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   586                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   587                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   588                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   589                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   590                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   591                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   592                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   593                                  
   594                                  AltPipeChr	equ	"|"             ; alternate pipe character
   595                                  
   596                                  FCB		EQU	5CH
   597                                  
   598                                  STRUC VARSTRUC
   599 00000000 ??                      .ISDIR:		RESB	1
   600 00000001 ??                      .SIZ:		RESB	1
   601 00000002 ????                    .TTAIL:		RESW	1
   602 00000004 ??                      .INFO:		RESB	1
   603 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   604                                  .size:
   605                                  ENDSTRUC
   606                                  ;
   607                                  ; Flags for internal command parsing
   608                                  ;
   609                                  fCheckDrive	equ	00000001b	; validate drive letter
   610                                  fSwitchAllowed	equ	00000010b	; switches allowed
   611                                  fLimitHelp	equ	00000100b	; /? must appear alone
   612                                  
   613                                  ;
   614                                  ; Test switches
   615                                  ;
   616                                  fParse		EQU	0001h		; display results of parseline
   617                                  
   618                                  ;
   619                                  ; Batch segment structure
   620                                  ;
   621                                  ;   BYTE    type of segment
   622                                  ;   BYTE    echo state of parent on entry to batch file
   623                                  ;   WORD    segment of last batch file
   624                                  ;   WORD    segment for FOR command
   625                                  ;   BYTE    FOR flag state on entry to batch file
   626                                  ;   DWORD   offset for next line
   627                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   628                                  ;   ASCIZ   file name (with . and ..)
   629                                  ;   BYTES   CR-terminated parameters
   630                                  ;   BYTE    0 flag to indicate end of parameters
   631                                  ;
   632                                  
   633                                  BATCHTYPE   equ 0
   634                                  
   635                                  STRUC BATCHSEGMENT
   636 00000000 ??                      .BatType:	RESB	1		; signature
   637 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   638                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   639 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   640 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   641 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   642 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   643 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   644 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   645                                  .SIZE:
   646                                  ENDSTRUC
   647                                  
   648                                  ANULL		equ	0		; terminates an argv string
   649                                  ARGMAX		equ	64		; max args on a command line
   650                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   651                                  tplen		equ	64		; max size of one argument
   652                                  arg_cnt_error	equ	1		; number of args > MAXARG
   653                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   654                                  
   655                                  STRUC ARGV_ELE				; elements in the argv array
   656 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   657 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   658 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   659 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   660 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   661 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   662                                  .SIZE:
   663                                  ENDSTRUC
   664                                  
   665                                  STRUC ARG_UNIT
   666 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   667 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   668 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   669 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   670 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   671                                  .SIZE:
   672                                  ENDSTRUC
   673                                  
   674                                  ; Equates for initialization
   675                                  ;
   676                                  INITINIT	equ	01h		; initialization in progress
   677                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   678                                  INITCTRLC	equ	04h		; already in ^C handler
   679                                  
   680                                  ;=============================================================================
   681                                  ; PDB.INC, MSDOS 6.0, 1991
   682                                  ;=============================================================================
   683                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   684                                  
   685                                  ;**	Process data block (otherwise known as program header)
   686                                  
   687                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   688                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   689                                  ;	for use.
   690                                  
   691                                  FILPERPROC	EQU     20
   692                                  
   693                                  struc PDB	; Process_data_block
   694 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   695 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   696 00000004 ??                                      resb 1
   697 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   698 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   699 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   700 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   701 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   702 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   703 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   704 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   705 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   706 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   707 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   708 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   709 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   710 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   711 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   712 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   713 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   714 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   715                                  				;  an extended FCB
   716                                  ;endstruc 	; MSDOS 3.3
   717                                  	  	; MSDOS 6.0
   718 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   719 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   720 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   721 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   722                                  endstruc
   723                                  
   724                                  ;=============================================================================
   725                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   726                                  ;=============================================================================
   727                                  ; 24/09/2018 - Retro DOS v3.0
   728                                  
   729                                  ;major_version       equ     6       ;Major DOS version
   730                                  ;minor_version       equ     00      ;Minor DOS Version
   731                                  
   732                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   733                                  
   734                                  ; MSDOS 3.3 COMMAND.COM
   735                                  MAJOR_VERSION	EQU 3
   736                                  MINOR_VERSION	EQU 30
   737                                  
   738                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   739                                  
   740                                  ;-----------------------------------------------------------------------------
   741                                  ; 21/09/2018
   742                                  ;-----------------------------------------------------------------------------
   743                                  ; Retro DOS v3.0 NOTE:  
   744                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   745                                  ;	with minor modifications which are done by me (Erdogan Tan).
   746                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   747                                  ;	source code files (written by using MASM syntax).
   748                                  ;-----------------------------------------------------------------------------
   749                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   750                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   751                                  ;----------------------------------------------------------------------------- 	
   752                                  
   753                                  ;=============================================================================
   754                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   755                                  ;=============================================================================
   756                                  ; 21/09/2018 - Retro DOS v3.0
   757                                  
   758                                  ;	page ,132
   759                                  ;	title	COMMAND - resident code for COMMAND.COM
   760                                  ;	name	COMMAND
   761                                  
   762                                  ;/*
   763                                  ; *                      Microsoft Confidential
   764                                  ; *                      Copyright (C) Microsoft Corporation 1991
   765                                  ; *                      All Rights Reserved.
   766                                  ; */
   767                                  
   768                                  ;*****************************************************************************
   769                                  ;
   770                                  ; MODULE:	       COMMAND.COM
   771                                  ;
   772                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   773                                  ;
   774                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   775                                  ;		       parts.  First is the resident portion, which includes
   776                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   777                                  ;		       error), and 2EH (command line execute); it also has
   778                                  ;		       code to test and, if necessary, reload the transient
   779                                  ;		       portion. Following the resident is the init code, which
   780                                  ;		       is overwritten after use.  Then comes the transient
   781                                  ;		       portion, which includes all command processing (whether
   782                                  ;		       internal or external).  The transient portion loads at
   783                                  ;		       the end of physical memory, and it may be overlayed by
   784                                  ;		       programs that need as much memory as possible. When the
   785                                  ;		       resident portion of command regains control from a user
   786                                  ;		       program, a check sum is performed on the transient
   787                                  ;		       portion to see if it must be reloaded.  Thus programs
   788                                  ;		       which do not need maximum memory will save the time
   789                                  ;		       required to reload COMMAND when they terminate.
   790                                  ;
   791                                  ; ENTRY POINT:	       PROGSTART
   792                                  ;
   793                                  ; INPUT:	       command line at offset 81H
   794                                  ;
   795                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   796                                  ;		       from a secondary command processor via the EXIT
   797                                  ;		       internal command.
   798                                  ;
   799                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   800                                  ;		       hang the system.
   801                                  ;
   802                                  ; INTERNAL REFERENCES:
   803                                  ;
   804                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   805                                  ;		       (COMMAND.DOC)
   806                                  ;
   807                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   808                                  ;		       (COMMAND.DOC)
   809                                  ;
   810                                  ; EXTERNAL REFERENCES:
   811                                  ;
   812                                  ;      ROUTINES:       none
   813                                  ;
   814                                  ;      DATA AREAS:     none
   815                                  ;
   816                                  ;*****************************************************************************
   817                                  ;
   818                                  ;			      REVISION HISTORY
   819                                  ;			      ----------------
   820                                  ;
   821                                  ; DOS 1.00 to DOS 3.30
   822                                  ; --------------------------
   823                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   824                                  ;
   825                                  ; REV 1.17
   826                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   827                                  ;	       resident since the EXELOAD may have overwritten the transient.
   828                                  ;
   829                                  ; REV 1.18
   830                                  ;    05/21/82  IBM version always looks on drive A
   831                                  ;	       MSVER always looks on default drive
   832                                  ;
   833                                  ; REV 1.19
   834                                  ;    06/03/82  Drive spec now entered in command line
   835                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   836                                  ;	       (print volume label)
   837                                  ;
   838                                  ; REV 1.20
   839                                  ;    06/09/82  Prints "directory" after directories
   840                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   841                                  ;
   842                                  ; REV 1.50
   843                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   844                                  ;	       do it right.
   845                                  ;
   846                                  ; REV 1.70
   847                                  ;	       EXEC used to fork off new processes
   848                                  ;
   849                                  ; REV 1.80
   850                                  ;	       C switch for single command execution
   851                                  ;
   852                                  ; REV 1.90
   853                                  ;	       Batch uses XENIX
   854                                  ;
   855                                  ; Rev 2.00
   856                                  ;	       Lots of neato stuff
   857                                  ;	       IBM 2.00 level
   858                                  ;
   859                                  ; Rev 2.01
   860                                  ;	       'D' switch for date time suppression
   861                                  ;
   862                                  ; Rev 2.02
   863                                  ;	       Default userpath is NUL rather than BIN
   864                                  ;		       same as IBM
   865                                  ;	       COMMAND split into pieces
   866                                  ;
   867                                  ; Rev 2.10
   868                                  ;	       INTERNATIONAL SUPPORT
   869                                  ;
   870                                  ; Rev 2.50
   871                                  ;	       all the 2.x new stuff -MU
   872                                  ;
   873                                  ; Rev 3.30     (Ellen G)
   874                                  ;	       CALL internal command (TBATCH2.ASM)
   875                                  ;	       CHCP internal command (TCMD2B.ASM)
   876                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   877                                  ;	       @ sign suppression of batch file line
   878                                  ;	       Replaceable environment value support in batch files
   879                                  ;	       INT 2FH calls for APPEND
   880                                  ;	       Lots of PTR fixes!
   881                                  ;
   882                                  ; Beyond 3.30 to forever  (Ellen G)
   883                                  ; ----------------------
   884                                  ;
   885                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   886                                  ;			Use Message Retriever services
   887                                  ;			/MSG switch for resident extended error msg
   888                                  ;			Convert to new capitalization support
   889                                  ;			Better error recovery on CHCP command
   890                                  ;			Code page file tag support
   891                                  ;			TRUENAME internal command
   892                                  ;			Extended screen line support
   893                                  ;			/P switch on DEL/ERASE command
   894                                  ;			Improved file redirection error recovery
   895                                  ;	(removed)	Improved batch file performance
   896                                  ;			Unconditional DBCS support
   897                                  ;			Volume serial number support
   898                                  ;	(removed)	COMMENT=?? support
   899                                  ;
   900                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   901                                  ;
   902                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   903                                  ;			require delimiters.
   904                                  ;
   905                                  ; A003	PTM P5,P9,P111	Included in A000 development
   906                                  ;
   907                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   908                                  ;			executing
   909                                  ;
   910                                  ; A005	DCR D17 	If user specifies an extension on the command
   911                                  ;			line search for that extension only.
   912                                  ;
   913                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   914                                  ;			exists"
   915                                  ;
   916                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   917                                  ;
   918                                  ; A008	PTM P182	Change COPY to set default if invalid function
   919                                  ;			returned from code page call.
   920                                  ;
   921                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   922                                  ;
   923                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   924                                  ;			transient COMMAND.
   925                                  ;
   926                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   927                                  ;			before appending to a file.
   928                                  ;
   929                                  ; A012	PTM P189	Fix redirection error recovery.
   930                                  ;
   931                                  ; A013	PTM P330	Change date format
   932                                  ;
   933                                  ; A014	PTM P455	Fix echo parsing
   934                                  ;
   935                                  ; A015	PTM P517	Fix DIR problem with * vs *.
   936                                  ;
   937                                  ; A016	PTM P354	Fix extended error message addressing
   938                                  ;
   939                                  ; A017	PTM P448	Fix appending to 0 length files
   940                                  ;
   941                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
   942                                  ;			the parser fails on. Fail on duplicate switches.
   943                                  ;
   944                                  ; A019	PTM P542	Fix device name to be printed correctly during
   945                                  ;			critical error
   946                                  ;
   947                                  ; A020	DCR D43 	Set append state off while in DIR
   948                                  ;
   949                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
   950                                  ;
   951                                  ; A022	DCR D209	Enhanced error recovery
   952                                  ;
   953                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
   954                                  ;
   955                                  ; A024	PTM P899	Fix EXTOPEN open modes.
   956                                  ;
   957                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
   958                                  ;
   959                                  ; A026	DCR D191	Change redirection error recovery support.
   960                                  ;
   961                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
   962                                  ;			with a carriage return.
   963                                  ;
   964                                  ; A028	PTM P1076	Print a blank line before printing invalid
   965                                  ;			date and invalid time messages.
   966                                  ;
   967                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
   968                                  ;			and TIME.
   969                                  ;
   970                                  ; A030	DCR D201	New extended attribute format.
   971                                  ;
   972                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
   973                                  ;
   974                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
   975                                  ;
   976                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
   977                                  ;
   978                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
   979                                  ;
   980                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
   981                                  ;			do a read to determine eof.
   982                                  ;
   983                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
   984                                  ;			so that ASSIGN works correctly.
   985                                  ;
   986                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
   987                                  ;
   988                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
   989                                  ;
   990                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
   991                                  ;
   992                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
   993                                  ;			specified.
   994                                  ;
   995                                  ; A041	PTM P1705	Close redirected files after internal APPEND
   996                                  ;			executes.
   997                                  ;
   998                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
   999                                  ;			files causing loss of batch file.
  1000                                  ;
  1001                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1002                                  ;			CALL'ed batch files.
  1003                                  ;
  1004                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1005                                  ;			as an end of line character
  1006                                  ;
  1007                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1008                                  ;			and extended message pointers when we EXIT if
  1009                                  ;			COMMAND /P is the top level process.
  1010                                  ;
  1011                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1012                                  ;			"File not found - fn"
  1013                                  ;
  1014                                  ; A047	PTM P2819	Fix transient reload prompt message
  1015                                  ;
  1016                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1017                                  ;			when DBCS code was added.
  1018                                  ;
  1019                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1020                                  ;			on line.
  1021                                  ;
  1022                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1023                                  ;
  1024                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1025                                  ;
  1026                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1027                                  ;
  1028                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1029                                  ;
  1030                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1031                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1032                                  ;
  1033                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1034                                  ;			problems with breaking out of INT 24h
  1035                                  ;
  1036                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1037                                  ;
  1038                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1039                                  ;			before the "string".  EX: COMMAND /CDIR
  1040                                  ;
  1041                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1042                                  ;			DBCS switch.
  1043                                  ;
  1044                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1045                                  ;			the time.
  1046                                  ;
  1047                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1048                                  ;			messages to be disk based.  Only keep them if /MSG
  1049                                  ;			is used.
  1050                                  ;
  1051                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1052                                  ;			out of internal commands, due to substitution blocks
  1053                                  ;			not being reset.
  1054                                  ;
  1055                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1056                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1057                                  ;			secondary copy of environment.	Change default slash in
  1058                                  ;			default comspec string to backslash.
  1059                                  ;
  1060                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1061                                  ;			text for critical error messages.
  1062                                  ;
  1063                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1064                                  ;	5/20/88 	with Microsoft product already shipped.
  1065                                  ;
  1066                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1067                                  ;	 5/20/88	with Microsoft product already shipped.
  1068                                  ;
  1069                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1070                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1071                                  ;			header and space remaining.
  1072                                  ;
  1073                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1074                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1075                                  ;			environment was putting a "Z block" marker in the old
  1076                                  ;			environment.  The fix is to move to the old environment
  1077                                  ;			to the new environment before doing the SETBLOCK.
  1078                                  ;
  1079                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1080                                  ;        09/19/88       because the check for APPEND needed to be performed
  1081                                  ;                       before the DIR's findfirst.
  1082                                  ;
  1083                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1084                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1085                                  ;                       loading trans w/new comspec with no user change comspec.
  1086                                  ;
  1087                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1088                                  ;        11/05/88       Expansion of environment variables into batch line of
  1089                                  ;                       128 chars was not being counted and "%" which should be
  1090                                  ;                       ignored were being counted.
  1091                                  ;
  1092                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1093                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1094                                  ;                       ing included in checksum and was being overwritten by
  1095                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1096                                  ;                       Also removed fix A069 (because flag now protected).
  1097                                  ;
  1098                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1099                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1100                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1101                                  ;
  1102                                  ;***********************************************************************************
  1103                                  
  1104                                  ;
  1105                                  ;	Revision History
  1106                                  ;	================
  1107                                  ;
  1108                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1109                                  ;					at init time (date/time prompt)
  1110                                  ;
  1111                                  
  1112                                  ;
  1113                                  ;.xcref
  1114                                  ;.xlist
  1115                                  ;	include dossym.inc		; basic DOS symbol set
  1116                                  ;	include syscall.inc		; DOS function names
  1117                                  ;	include comsw.asm		; build version info
  1118                                  ;	include comequ.asm		; common command.com symbols
  1119                                  ;	include resmsg.equ		; resident message names
  1120                                  ;
  1121                                  ;	include comseg.asm		;segment ordering
  1122                                  ;.list
  1123                                  ;.cref
  1124                                  
  1125                                  ;CODERES segment public byte
  1126                                  ;CODERES ends
  1127                                  ;
  1128                                  ;DATARES 	segment public byte
  1129                                  ;		extrn	AccDen:byte
  1130                                  ;		extrn	Batch:word
  1131                                  ;		extrn	EchoFlag:byte
  1132                                  ;		extrn	ExeBad:byte
  1133                                  ;		extrn	ExecEMes:byte
  1134                                  ;		extrn	ExecErrSubst:byte
  1135                                  ;		extrn	ExtCom:byte
  1136                                  ;		extrn	ForFlag:byte
  1137                                  ;		extrn	IfFlag:byte
  1138                                  ;		extrn	InitFlag:BYTE
  1139                                  ;		extrn	Nest:word
  1140                                  ;		extrn	PipeFlag:byte
  1141                                  ;		extrn	RBadNam:byte
  1142                                  ;		extrn	RetCode:word
  1143                                  ;		extrn	SingleCom:word
  1144                                  ;		extrn	TooBig:byte
  1145                                  ;
  1146                                  ;		extrn	OldDS:word
  1147                                  ;
  1148                                  ;DATARES 	ends
  1149                                  ;
  1150                                  ;
  1151                                  ;INIT		segment public para
  1152                                  ;		extrn	ConProc:near
  1153                                  ;		extrn	Init_Contc_SpecialCase:near
  1154                                  ;INIT		ends
  1155                                  
  1156                                  ; ----------------------------------------------------------------------------
  1157                                  ; START OF RESIDENT PORTION
  1158                                  ; ----------------------------------------------------------------------------
  1159                                  ; SEGMENT - CODERES
  1160                                  ; ----------------------------------------------------------------------------
  1161                                  
  1162                                  	;[ORG	0]
  1163                                  
  1164                                  ;ZERO	EQU	$
  1165                                  
  1166                                  	[ORG 100H]
  1167                                  
  1168                                  	; 21/09/2018 - Retro DOS v3.0
  1169                                  StartCode:
  1170 00000000 E9DD0C                  	jmp	CONPROC
  1171                                  
  1172                                  ;***	EXEC error handling
  1173                                  ;
  1174                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  1175                                  ;	We examine the error code and select an appropriate message.
  1176                                  
  1177                                  ;	Bugbug:	optimize reg usage in following code?  Careful of DX!
  1178                                  ;	Condense the error scan?
  1179                                  ;	RBADNAM is checked by transient, no need here?
  1180                                  ;	Move below Ext_Exec.
  1181                                  
  1182                                  EXEC_ERR:
  1183 00000003 BA[DC09]                	mov     dx,ACCDEN
  1184 00000006 83F805                  	cmp     ax,ERROR_ACCESS_DENIED	; 5
  1185 00000009 741B                    	jz      short GOTEXECEMES	; access denied
  1186 0000000B BA[C109]                	mov     dx,RBADNAM
  1187 0000000E 83F802                  	cmp     ax,ERROR_FILE_NOT_FOUND ; 2
  1188 00000011 7413                    	jz      short GOTEXECEMES	; file not found
  1189 00000013 BA[8709]                	mov     dx,TOOBIG
  1190 00000016 83F808                  	cmp     ax,ERROR_NOT_ENOUGH_MEMORY ; 8
  1191 00000019 740B                    	jz      short GOTEXECEMES
  1192 0000001B BA[7309]                	mov     dx,EXEBAD
  1193 0000001E 83F80B                  	cmp     ax,ERROR_BAD_FORMAT	; 0Bh
  1194 00000021 7403                    	jz      short GOTEXECEMES	; bad exe file
  1195                                  DEFAULT_MESSAGE:
  1196 00000023 BA[6409]                	mov     dx,EXECEMES
  1197                                  GOTEXECEMES:
  1198 00000026 0E                      	push    cs
  1199 00000027 1F                      	pop     ds
  1200 00000028 E86B06                  	call    RDISPMSG
  1201 0000002B EB0C                    	jmp     short NOEXEC
  1202                                  
  1203                                  ;***	EXEC call
  1204                                  ;
  1205                                  ;	The transient has set up everything for an EXEC system call.
  1206                                  ;	For cleanliness, we issue the EXEC here in the resident 
  1207                                  ;	so that we may be able to recover cleanly upon success.
  1208                                  ;
  1209                                  ;	CS,DS,ES,SS = DATARES seg addr
  1210                                  
  1211                                  EXT_EXEC:
  1212                                  ;SR;
  1213                                  ; The words put on the stack by the stub will be popped off when we finally
  1214                                  ;jump to LodCom (by LodCom).
  1215                                  ;
  1216 0000002D CD21                    	int	21h			; do the exec
  1217                                  EXEC_RET:
  1218 0000002F 72D2                    	jc	short EXEC_ERR		; exec failed
  1219                                  
  1220                                  ;	The exec has completed. Retrieve the exit code.
  1221                                  
  1222                                  EXEC_WAIT:
  1223 00000031 B44D                    	mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  1224 00000033 CD21                    	int	21h			; get the return code
  1225 00000035 2EA3[EC0A]              	mov     [cs:RETCODE],ax
  1226                                  
  1227                                  ;	See if we can reload the transient. The external command
  1228                                  ;	may have overwritten part of the transient.
  1229                                  
  1230                                  NOEXEC:
  1231                                  ;SR;
  1232                                  ; ds = es = ss = DATARES when we jump to LodCom
  1233                                  ;
  1234 00000039 E97101                  	jmp	LODCOM
  1235                                  
  1236                                  ;***	Int 23 (ctrl-c) handler
  1237                                  ;
  1238                                  ;	This is the default system INT 23 handler.  All processes
  1239                                  ;	(including COMMAND) get it by default.  There are some
  1240                                  ;	games that are played:  We ignore ^C during most of the
  1241                                  ;	INIT code.  This is because we may perform an ALLOC and
  1242                                  ;	diddle the header!  Also, if we are prompting for date/time
  1243                                  ;	in the init code, we are to treat ^C as empty responses.
  1244                                  
  1245                                  ;	Bugbug:	put init ctrl-c handling in init module.
  1246                                  
  1247                                  ;SR;
  1248                                  ; The stub has pushed the previous ds and DATARES onto the stack. We get
  1249                                  ;both these values off the stack now
  1250                                  ;
  1251                                  ;ContC	proc	far
  1252                                  
  1253                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  1254                                  
  1255                                  CONTC:
  1256                                  
  1257                                  ;	pop	ds			;ds = DATARES
  1258                                  ;	assume	ds:DATARES
  1259                                  ;;	pop	word [OldDS]		;OldDS = old ds
  1260                                  
  1261 0000003C 2EF606[5B0B]01          	test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  1262 00000042 740C                    	jz	short NOTATINIT			; no
  1263 00000044 2EF606[5B0B]02          	test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  1264 0000004A 7403                    	jz	short CMDIRET			; no, ignore ^C
  1265                                  	;pop	ds			; restore before jumping; M021
  1266 0000004C E9A412                  	jmp	INIT_CONTC_SPECIALCASE	; Yes, go handle it
  1267                                  CMDIRET:
  1268                                  ;SR;
  1269                                  ; Restore ds to its previous value
  1270                                  ;
  1271                                  
  1272                                  ;;	mov	ds,[OLdDS]		;
  1273                                  ;	pop	ds
  1274 0000004F CF                      	iret				; yes, ignore the ^C
  1275                                  
  1276                                  NOTATINIT:
  1277 00000050 2EF606[5B0B]04          	test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  1278 00000056 7411                    	jz	short NOTINIT		; nope too.
  1279                                  
  1280                                  ;*	We are interrupting ourselves in this ^C handler. We need
  1281                                  ;	to set carry and return to the user sans flags only if the
  1282                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  1283                                  
  1284 00000058 80FC01                  	cmp	ah,1
  1285 0000005B 72F2                    	jb	short CMDIRET
  1286 0000005D 80FC0C                  	cmp	ah,12
  1287 00000060 77ED                    	ja	short CMDIRET
  1288                                  
  1289                                  ;	pop	ds			;restore ds to old value
  1290 00000062 83C406                  	add	sp,6			; remove int frame
  1291 00000065 F9                      	stc
  1292                                  
  1293                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  1294 00000066 CA0200                  	retf	2			; remove those flags...
  1295                                  
  1296                                  NOTINIT:
  1297                                  
  1298                                  ;*	We have now received a ^C for some process (maybe ourselves
  1299                                  ;	but not at INIT).
  1300                                  ;	
  1301                                  ;	Note that we are running on the user's stack!!! Bad news if
  1302                                  ;	any of the system calls below go and issue another INT
  1303                                  ;	24... Massive stack overflow! Another bad point is that
  1304                                  ;	SavHand will save an already saved handle, thus losing a
  1305                                  ;	possible redirection...
  1306                                  ;	
  1307                                  ;	All we need to do is set the flag to indicate nested ^C. 
  1308                                  ;	The above code will correctly flag the ^C diring the
  1309                                  ;	message output and prompting while ignoring the ^C the rest
  1310                                  ;	of the time.
  1311                                  ;	
  1312                                  ;	Clean up: flush disk. If we are in the middle of a batch
  1313                                  ;	file, we ask if he wants to terminate it. If he does, then
  1314                                  ;	we turn off all internal flags and let the DOS abort.
  1315                                  
  1316 00000069 2E800E[5B0B]04          	or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  1317 0000006F FB                      	sti
  1318                                  
  1319 00000070 0E                      	push	cs			; el yucko!  change the user's ds!!
  1320 00000071 1F                      	pop	ds
  1321                                  ;	assume	ds:RESGROUP
  1322                                  
  1323                                  	;pop	ax			;discard the old ds value
  1324                                  
  1325 00000072 A1[F50A]                	mov	ax,[SINGLECOM]
  1326 00000075 09C0                    	or	ax,ax
  1327 00000077 7506                    	jnz	short NORESET
  1328 00000079 50                      	push	ax
  1329 0000007A B40D                    	mov	ah,DISK_RESET ; 0Dh
  1330 0000007C CD21                    	int	21h			; reset disks in case files were open
  1331 0000007E 58                      	pop	ax
  1332                                  
  1333                                  NORESET:
  1334                                  
  1335                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  1336                                  ;	walk the entire active list and free each segment. Here,
  1337                                  ;	we just free the single batch segment.
  1338                                  
  1339 0000007F F706[990A]FFFF          	test	word [BATCH],-1
  1340 00000085 744B                    	jz	short CONTCTERM
  1341 00000087 09C0                    	or	ax,ax
  1342 00000089 7547                    	jnz	short CONTCTERM
  1343 0000008B E85902                  	call	SAVHAND
  1344 0000008E E8A203                  	call	ASKEND			; ask if user wants to end batch
  1345                                  
  1346                                  ;	If the carry flag is clear, we do NOT free up the batch file
  1347                                  
  1348 00000091 7339                    	jnc	short CONTBATCH
  1349                                  	;mov	cl,[EchoFlag]		; get current echo flag
  1350 00000093 53                      	push	bx
  1351                                  
  1352                                  CLEARBATCH:
  1353 00000094 8E06[990A]              	mov	es,[BATCH]		; get batch segment
  1354                                  	;mov	di,[BatFile]		; get offset of batch file name
  1355                                  	; MSDOS 3.3 ([ES:4])
  1356 00000098 268B1E0400              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  1357                                  	;
  1358 0000009D 83FB00                  	cmp	bx,0			; is a FOR in progress
  1359 000000A0 7408                    	je	short NOT_BAT_FOR	; no - don't deallocate
  1360 000000A2 06                      	push	es			;
  1361 000000A3 8EC3                    	mov	es,bx			; yes - free it up...
  1362 000000A5 B449                    	mov	ah,DEALLOC ; 49h	;
  1363 000000A7 CD21                    	int	21h			;
  1364 000000A9 07                      	pop	es			; restore to batch segment
  1365                                  
  1366                                  NOT_BAT_FOR:
  1367 000000AA 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  1368 000000AF 268B1E0200              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  1369 000000B4 B449                    	mov	ah,DEALLOC ; 49h	; free it up...
  1370 000000B6 CD21                    	int	21h
  1371 000000B8 891E[990A]              	mov	[BATCH],bx		; get ready to deallocate next batch
  1372 000000BC FF0E[FE0A]              	dec	WORD [NEST]		; is there another batch file?
  1373 000000C0 75D2                    	jnz	short CLEARBATCH	; keep going until no batch file
  1374                                  
  1375                                  ;	We are terminating a batch file; restore the echo status
  1376                                  
  1377                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  1378 000000C2 5B                      	pop	bx
  1379 000000C3 880E[EF0A]              	mov	[ECHOFLAG],cl		; reset echo status
  1380                                  	; 29/05/2018
  1381 000000C7 C606[5C0B]00            	mov	byte [PIPEFLAG],0	; turn off pipeflag
  1382                                  
  1383                                  CONTBATCH:
  1384 000000CC E8C405                  	call	CRLF			; print out crlf before returning
  1385 000000CF E83A02                  	call	RESTHAND
  1386                                  
  1387                                  ;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.
  1388                                  
  1389                                  CONTCTERM:
  1390 000000D2 31C0                    	xor	ax,ax			; indicate no read
  1391 000000D4 89C5                    	mov	bp,ax
  1392                                  
  1393                                  ;	The following resetting of the state flags is good for the
  1394                                  ;	generalized batch processing.
  1395                                  
  1396 000000D6 A2[FA0A]                	mov	[IFFLAG],al		; turn off iffing
  1397 000000D9 A2[FB0A]                	mov	[FORFLAG],al		; turn off for processing
  1398 000000DC E81C00                  	call	RESPIPEOFF
  1399 000000DF 3906[F50A]              	cmp	[SINGLECOM],ax		; see if we need to set singlecom
  1400 000000E3 7406                    	jz	short NOSETSING
  1401 000000E5 C706[F50A]FFFF          	mov	word [SINGLECOM],-1	; cause termination on 
  1402                                  					;  pipe, batch, for
  1403                                  NOSETSING:
  1404                                  
  1405                                  ;	If we are doing an internal command, go through the reload process.
  1406                                  ;	If we are doing an external, let DOS abort the process.
  1407                                  ;	In both cases, we are now done with the ^C processing.
  1408                                  
  1409 000000EB 8026[5B0B]FB            	and	byte [INITFLAG],~INITCTRLC ; 0FBh
  1410 000000F0 3806[EB0A]              	cmp	[EXTCOM],al
  1411 000000F4 7503                    	jnz	short DODAB		; internal ^c
  1412 000000F6 E92001                  	jmp	LODCOM1
  1413                                  DODAB:
  1414 000000F9 F9                      	stc				; tell dos to abort
  1415                                  
  1416                                  ;SR;
  1417                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  1418                                  ;by setting carry and leaving flags on the stack
  1419                                  ;
  1420 000000FA CB                      	retf				; Leave flags on stack
  1421                                  
  1422                                  ;ContC	endp
  1423                                  
  1424                                  ;SR;
  1425                                  ; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  1426                                  ;both have ds = DATARES
  1427                                  ;
  1428                                  
  1429                                  RESPIPEOFF:
  1430 000000FB 50                      	push	ax
  1431 000000FC 31C0                    	xor	ax,ax
  1432 000000FE 2E8606[5C0B]            	xchg	al,[cs:PIPEFLAG]
  1433 00000103 08C0                    	or	al,al
  1434 00000105 7405                    	jz	short NOPIPEPOP
  1435 00000107 2ED02E[EF0A]            	shr	byte [cs:ECHOFLAG],1
  1436                                  NOPIPEPOP:
  1437 0000010C 58                      	pop	ax
  1438 0000010D C3                      	retn
  1439                                  
  1440                                  ;CODERES ends
  1441                                  
  1442                                  ;=============================================================================
  1443                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  1444                                  ;=============================================================================
  1445                                  ; 21/09/2018 - Retro DOS v3.0
  1446                                  
  1447                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  1448                                  ;	name	COMMAND2
  1449                                  
  1450                                  ;/*
  1451                                  ; *                      Microsoft Confidential
  1452                                  ; *                      Copyright (C) Microsoft Corporation 1991
  1453                                  ; *                      All Rights Reserved.
  1454                                  ; */
  1455                                  
  1456                                  ;
  1457                                  ;	Revision History
  1458                                  ;	================
  1459                                  ;
  1460                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  1461                                  ;			reserve memory by changing int 12h and then give it
  1462                                  ;			back to DOS by changing arenas in autoexec.bat.
  1463                                  ;			This makes command.com reload transient and this
  1464                                  ;			cannot be done at this stage.
  1465                                  ;
  1466                                  
  1467                                  ;CODERES segment public byte
  1468                                  
  1469                                  ;*	If we cannot allocate enough memory for the transient or there
  1470                                  ;	was some other allocation error, we display a message and
  1471                                  ;	then die.
  1472                                  
  1473                                  ;SR;
  1474                                  ; We will have to make sure that at this entry point and at FatalC, 
  1475                                  ;ds = DATARES. All jumps to these points are made from only within this file
  1476                                  ;and so we should be able to do this
  1477                                  
  1478                                  	;assume	ds:DATARES
  1479                                  BADMEMERR:
  1480 0000010E BA[EC09]                	mov	dx,BMEMMES			; DX = ptr to msg
  1481                                  FATALC:
  1482 00000111 0E                      	push	cs
  1483 00000112 1F                      	pop	ds
  1484                                  ;;	assume	ds:ResGroup
  1485                                  ;	invoke	RPrint
  1486                                  
  1487                                  	; MSDOS 3.3
  1488 00000113 E88005                  	call	RDISPMSG
  1489                                  
  1490                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  1491                                  ;	we can't do anything else!
  1492                                  
  1493 00000116 803E[F40A]00            	cmp	byte [PERMCOM],0
  1494 0000011B 7410                    	je	short FATALRET
  1495                                  
  1496                                  ;	We are a permanent command. If we are in the process of the
  1497                                  ;	magic interrupt (Singlecom) then exit too.
  1498                                  
  1499 0000011D 833E[F50A]00            	cmp	word [SINGLECOM],0		; if permcom and singlecom
  1500 00000122 7509                    	jne	short FATALRET			; must take int_2e exit
  1501                                  
  1502                                  ;	Permanent command. We can't do ANYthing except halt.
  1503                                  
  1504 00000124 BA[070A]                	mov	dx,HALTMES			; DX = ptr to msg
  1505                                  	;invoke	RPrint
  1506                                  	; MSDOS 3.3
  1507 00000127 E86C05                  	call	RDISPMSG
  1508 0000012A FB                      	sti
  1509                                  STALL:
  1510 0000012B EBFE                    	jmp	short STALL			; crash the system nicely
  1511                                  
  1512                                  FATALRET:
  1513 0000012D BA[2C0A]                	mov	dx,FRETMES			; DX = ptr to msg
  1514 00000130 E86305                  	call	RDISPMSG
  1515                                  FATALRET2:
  1516 00000133 803E[F40A]00            	cmp	byte [PERMCOM],0		; if we get here and permcom,
  1517 00000138 7517                    	jne	SHORT RET_2E			; must be int_2e
  1518                                  
  1519                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  1520                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  1521                                  ;	case we decide to do that.)
  1522 0000013A A1[8E0A]                	mov	ax,[PARENT]
  1523 0000013D A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  1524 00000140 A1[900A]                	mov	ax,[OLDTERM]
  1525 00000143 A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  1526 00000146 A1[920A]                	mov	ax,[OLDTERM+2]
  1527 00000149 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  1528 0000014C B8004C                  	mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  1529 0000014F CD21                    	int	21h
  1530                                  RET_2E:
  1531                                  ;SR;
  1532                                  ; We will ensure that ds = DATARES for all entries to this place
  1533                                  ;
  1534                                  
  1535                                  ;;	push	cs
  1536                                  ;;	pop	ds
  1537                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  1538                                    	
  1539                                  ;	assume	ds:DATARES
  1540                                  
  1541                                  	;PUSH	CS
  1542                                  	;POP	DS
  1543                                  
  1544 00000151 C706[F50A]0000          	mov	word [SINGLECOM],0	; turn off singlecom
  1545 00000157 8E06[250C]              	mov	es,[RES_TPA]
  1546 0000015B B449                    	mov	ah,DEALLOC
  1547 0000015D CD21                    	int	21h			; free up space used by transient
  1548 0000015F 8B1E[8C0A]              	mov	bx,[SAVE_PDB]
  1549 00000163 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  1550 00000165 CD21                    	int	21h			; current process is user
  1551 00000167 A1[EC0A]                	mov	ax,[RETCODE]
  1552 0000016A 803E[EB0A]00            	cmp	byte [EXTCOM],0
  1553 0000016F 7502                    	jne	short GOTECODE
  1554 00000171 31C0                    	xor	ax,ax			; internals always return 0
  1555                                  GOTECODE:
  1556 00000173 C606[EB0A]01            	mov	byte [EXTCOM],1		; force external
  1557                                  
  1558                                  ;SR; This is actually returning to the caller. However, the old code had
  1559                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  1560                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  1561                                  ;
  1562                                  	;jmp	INT_2E_RET		;"iret"
  1563                                  	; 12/01/2023 (BugFix)
  1564 00000178 FF2E[880A]              	jmp	far [INT_2E_RET]
  1565                                  
  1566                                  ;***	Int_2e, magic command executer
  1567                                  
  1568                                  INT_2E:
  1569                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  1570                                  ;SR;
  1571                                  ; We are going to come here from the stub with the old ds and DATARES value
  1572                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  1573                                  ;
  1574                                  	;pop	ds			;ds = DATARES
  1575                                  	;assume	ds:DATARES
  1576                                  	;pop	ax
  1577                                  ;	;pop	ds:OldDS 		;Save old value of ds
  1578                                  
  1579 0000017C 2E8F06[880A]            	pop	word [cs:INT_2E_RET]
  1580 00000181 2E8F06[8A0A]            	pop	word [cs:INT_2E_RET+2]	; store return address
  1581 00000186 58                      	pop	ax			; chuck flags
  1582                                  	;add	sp,2
  1583                                  
  1584 00000187 0E                      	push	cs
  1585 00000188 07                      	pop	es
  1586                                  
  1587                                  	;push	ds
  1588                                  	;pop	es			;es = DATARES
  1589                                  ;	;mov	ds,OldDS
  1590                                  	;mov	ds,ax
  1591                                  	;assume	ds:nothing		;ds = old value
  1592                                  
  1593 00000189 BF8000                  	mov	di,80h
  1594 0000018C B94000                  	mov	cx,64
  1595                                  ;	Bugbug:	cld
  1596 0000018F F3A5                    	rep	movsw
  1597 00000191 B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1598 00000193 CD21                    	int	21h			; get user's header
  1599                                  	;mov	[es:SAVE_PDB],bx
  1600 00000195 2E891E[8C0A]            	MOV	[cs:SAVE_PDB],bx
  1601 0000019A B450                    	mov	ah,SET_CURRENT_PDB ; 50H
  1602                                  
  1603                                  ;;	mov	bx,cs
  1604                                  ;SR;
  1605                                  ; Set ds = DATARES because BadMemErr expects this
  1606                                  ;
  1607                                  	;push	es
  1608                                  	;pop	ds
  1609                                  	;assume	ds:DATARES
  1610                                  
  1611                                  	;mov	bx,ds			;es = our PSP now
  1612 0000019C 8CCB                    	mov	bx,cs
  1613                                  
  1614 0000019E CD21                    	int	21h			; current process is me
  1615 000001A0 2EC706[F50A]8100        	mov	word [cs:SINGLECOM],81h
  1616 000001A7 2EC606[EB0A]01          	mov	byte [cs:EXTCOM],1	; make sure this case forced
  1617                                  
  1618                                  ;SR;
  1619                                  ; We can enter LodCom directly after a command shell is terminated or we
  1620                                  ;can fall thru from above. When we enter directly from the stub, the stack
  1621                                  ;has the old ds value and the data seg value on the stack, so that ds can
  1622                                  ;be properly set. To fake this, we push dummy values here.
  1623                                  ;
  1624                                  	;push	ds			;old value of ds
  1625                                  	;push	ds			;data seg value, ds = DATARES
  1626                                  
  1627                                  LODCOM: 				; termination handler
  1628                                  	;pop	ds			;ds = DATARES 
  1629                                  	;assume	ds:DATARES
  1630                                  	;add	sp,2
  1631                                  ;	;pop	OldDS			;store old ds
  1632                                  
  1633                                  	;cmp	EXTCOM,0
  1634 000001AD 2E803E[EB0A]00          	cmp	byte [cs:EXTCOM],0
  1635                                  	;jne	@f	 		; internal cmd - memory allocated
  1636                                  	;jne	short LODCOM0 ; 24/09/2018
  1637                                  	;jmp	LODCOM1 		; jz LODCOM1
  1638 000001B3 7464                    	je	short LODCOM1 ; 25/09/2018	
  1639                                  
  1640                                  ;@@:
  1641                                  LODCOM0: ; 24/09/2018
  1642 000001B5 BBFFFF                  	mov	bx,0FFFFh
  1643 000001B8 B448                    	mov	ah,ALLOC ; 48h	
  1644 000001BA CD21                    	int	21h			; DOS - 2+ - ALLOCATE MEMORY
  1645                                  					; BX = number of 16-byte paragraphs desired
  1646 000001BC E80A00                  	call	SETSIZE
  1647 000001BF 83C020                  	add	ax,20h
  1648 000001C2 39C3                    	cmp	bx,ax
  1649 000001C4 730B                    	jnb	short MEMOK		; > 512 byte buffer - good enough
  1650                                  BADMEMERRJ:
  1651 000001C6 E945FF                  	jmp	BADMEMERR		; not enough memory
  1652                                  
  1653                                  ;***	SetSize - get transient size in paragraphs
  1654                                  
  1655                                  SETSIZE:
  1656 000001C9 B88B4C                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh
  1657 000001CC B104                    	mov	cl,4
  1658 000001CE D3E8                    	shr	ax,cl
  1659 000001D0 C3                      	retn
  1660                                  
  1661                                  MEMOK:
  1662                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  1663                                  
  1664 000001D1 B448                    	mov	ah,ALLOC  ; 48h
  1665 000001D3 CD21                    	int	21h
  1666 000001D5 72EF                    	jc	short BADMEMERRJ	; memory arenas probably trashed
  1667 000001D7 2EC606[EB0A]00          	mov	byte [cs:EXTCOM],0	; flag not to alloc again
  1668 000001DD 2EA3[250C]              	mov	[cs:RES_TPA],ax		; save current tpa segment
  1669 000001E1 2500F0                  	and	ax,0F000h
  1670 000001E4 050010                  	add	ax,01000h		; round up to next 64k boundary
  1671 000001E7 7213                    	jc	short BAD_TPA		; memory wrap if carry set
  1672                                  
  1673                                  ;	Make sure that new boundary is within allocated range
  1674                                  
  1675 000001E9 2E8B16[250C]            	mov	dx,[cs:RES_TPA]
  1676 000001EE 01DA                    	add	dx,bx			; compute maximum address
  1677 000001F0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  1678 000001F2 7608                    	jbe	short BAD_TPA
  1679                                  
  1680                                  ;	Must have 64K of usable space.
  1681                                  
  1682 000001F4 29C2                    	sub	dx,ax			; compute the usable space
  1683 000001F6 81FA0010                	cmp	dx,01000h		; is space >= 64k ?
  1684 000001FA 7304                    	jae	short LTPASET
  1685                                  BAD_TPA:
  1686 000001FC 2EA1[250C]              	mov	ax,[cs:RES_TPA]
  1687                                  LTPASET:
  1688 00000200 2EA3[170C]              	mov	[cs:LTPA],ax		; usable tpa is 64k buffer aligned
  1689 00000204 2EA1[250C]              	mov	ax,[cs:RES_TPA]		; actual tpa is buffer allocated
  1690 00000208 01C3                    	add	bx,ax
  1691 0000020A 2E891E[E70A]            	mov	[cs:MEMSIZ],bx
  1692 0000020F E8B7FF                  	call	SETSIZE
  1693 00000212 29C3                    	sub	bx,ax
  1694                                  
  1695                                  	; MSDOS 6.0
  1696                                  ;;
  1697                                  ;;M038; Start of changes
  1698                                  ;; Changes for Novell RPL. These guys reserve memory for themselves by
  1699                                  ;;reducing int 12h size and add this memory to the system at autoexec time by
  1700                                  ;;running a program that changes arenas. This changes the largest block that
  1701                                  ;;command.com gets and so changes the transient segment. So, command.com does
  1702                                  ;;a checksum at the wrong address and thinks that the transient is destroyed
  1703                                  ;;and tries to reload it. At this point, no Comspec is defined and so the
  1704                                  ;;reload fails, hanging the system. To get around this we just copy the
  1705                                  ;;transient from the previous address to the new address(if changed) and
  1706                                  ;;then let command.com do the checksum. So, if the transient area is not
  1707                                  ;;corrupted, there will not be any reload. In Novell's case, the transient
  1708                                  ;;is not really corrupted and so this should work.
  1709                                  ;;
  1710                                  ;	cmp	bx,[cs:TRNSEG]		;Segment still the same?
  1711                                  ;	je	short LODCOM1		;yes, dont copy
  1712                                  ;;
  1713                                  ;;Check if the new segment is above or below the current move. If the new
  1714                                  ;;segment is above (i.e new block is larger than previous block), then we
  1715                                  ;;have to move in the reverse direction
  1716                                  ;;
  1717                                  ;	mov	cx,TRANSPACEEND		;cx = length to move
  1718                                  ;	ja	short _MOV_DOWN		;new seg > old seg, reverse move
  1719                                  ;	xor	si,si			;normal move
  1720                                  ;	mov	di,si
  1721                                  ;	cld
  1722                                  ;	jmp	short COPY_TRANS
  1723                                  ;_MOV_DOWN:
  1724                                  ;	mov	si,cx			;reverse move, start from end
  1725                                  ;	dec	si
  1726                                  ;	mov	di,si
  1727                                  ;	std
  1728                                  ;COPY_TRANS:
  1729                                  ;	push	ds
  1730                                  ;	push	es
  1731                                  ;	mov	es,bx			;dest segment
  1732                                  ;	mov	ds,[cs:TRNSEG]		;source segment
  1733                                  ;	;assume	ds:nothing
  1734                                  ;
  1735                                  ;	rep	movsb			;copy transient
  1736                                  ;	cld
  1737                                  ;	pop	es
  1738                                  ;	pop	ds
  1739                                  ;	;assume	ds:DATARES
  1740                                  ;;
  1741                                  ;;M038; End of changes
  1742                                  ;;
  1743 00000214 2E891E[E10A]            	mov	[cs:TRNSEG],bx		;new location of transient
  1744                                  
  1745                                  LODCOM1:
  1746                                  ;;	mov	ax,cs
  1747                                  ;;	mov	ss,ax
  1748                                  ;SR; At this point ds = DATARES which is where the stack is located
  1749                                  ;
  1750                                  	;mov	ax,ds
  1751                                  	;mov	ss,ax
  1752                                  	;assume	ss:DATARES
  1753                                  	;mov	sp,offset DATARES:RStack
  1754                                  
  1755                                  ;;	mov	ds,ax
  1756                                  
  1757                                  	;assume	ds:DATARES
  1758                                  	
  1759                                  	; MSDOS 3.3
  1760 00000219 8CC8                    	mov	ax,cs
  1761 0000021B 8ED0                    	mov	ss,ax
  1762 0000021D BC[3E07]                	mov	sp,RSTACK
  1763 00000220 8ED8                    	mov	ds,ax
  1764                                  
  1765 00000222 E88E00                  	call	HEADFIX			; close files, restore stdin, stdout
  1766 00000225 31ED                    	xor	bp,bp			; flag command ok
  1767 00000227 B8FFFF                  	mov	ax,-1
  1768 0000022A 8706[F70A]              	xchg	ax,[VERVAL]
  1769 0000022E 83F8FF                  	cmp	ax,-1
  1770 00000231 7404                    	je	short NOSETVER
  1771 00000233 B42E                    	mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  1772 00000235 CD21                    	int	21h 			; DOS - SET VERIFY FLAG
  1773                                  					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  1774                                  NOSETVER:
  1775 00000237 833E[F50A]FF            	cmp	word [SINGLECOM],-1
  1776 0000023C 7503                    	jne	short NOSNG
  1777 0000023E E9F2FE                  	jmp	FATALRET2		; we have finished the single command
  1778                                  NOSNG:
  1779 00000241 E88201                  	call	CHKSUM			; check the transient
  1780 00000244 3B16[E90A]              	cmp	dx,[SUM]
  1781 00000248 7416                    	je	short HAVCOM		; transient ok
  1782                                  BOGUS_COM:
  1783 0000024A C606[980A]01            	mov	byte [LOADING],1	; flag DskErr routine
  1784 0000024F E82501                  	call	LOADCOM
  1785                                  CHKSAME:
  1786 00000252 E87101                  	call	CHKSUM
  1787 00000255 3B16[E90A]              	cmp	dx,[SUM]
  1788 00000259 7405                    	jz	short HAVCOM		; same command
  1789                                  ALSO_BOGUS:
  1790 0000025B E86001                  	call	WRONGCOM
  1791 0000025E EBF2                    	jmp	short CHKSAME
  1792                                  
  1793                                  HAVCOM:
  1794                                  	; 25/09/2018
  1795 00000260 B80037                  	mov     ax,(CHAR_OPER*256) ; 3700h
  1796 00000263 CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  1797                                  			; Return: AL = FFh unsupported subfunction
  1798                                  			; DL = current switch character
  1799 00000265 8816[190C]              	mov     [RSWITCHAR],dl
  1800 00000269 80FA2F                  	cmp     dl,'/'
  1801 0000026C 7505                    	jnz     short USESLASH
  1802                                  	;mov	cl,'\'
  1803                                  	;mov	[RDIRCHAR],cl
  1804 0000026E C606[1A0C]5C            	mov	byte [RDIRCHAR],'\'
  1805                                  USESLASH:
  1806 00000273 C606[980A]00            	mov	byte [LOADING],0		; flag to DskErr
  1807 00000278 BE[130C]                	mov	si,TRANVARS
  1808 0000027B BFAF41                  	mov	di,HEADCALL
  1809 0000027E 8E06[E10A]              	mov	es,[TRNSEG]
  1810 00000282 FC                      	cld
  1811 00000283 B9[270C]                	mov	cx,TRANVAREND
  1812 00000286 29F1                    	sub	cx,si
  1813 00000288 F3A4                    	rep	movsb			; transfer info to transient
  1814 0000028A A1[E70A]                	mov	ax,[MEMSIZ]
  1815 0000028D A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  1816                                  
  1817                                  ;***	TJmp - jump-off to transient
  1818                                  ;
  1819                                  ;	Public label so debugger can find this spot.
  1820                                  
  1821                                  TJMP:
  1822 00000290 FF2E[DF0A]              	jmp	far [TRANS]
  1823                                  
  1824                                  ;***	TRemCheck - far version of RemCheck for transient
  1825                                  
  1826                                  TREMCHECK:
  1827                                  	;pop	ds			;ds = DATARES
  1828                                  	;add	sp,2			;discard old value of ds
  1829                                  
  1830 00000294 E80100                  	call	REMCHECK
  1831 00000297 CB                      	retf
  1832                                  
  1833                                  ;***	RemCheck
  1834                                  ;
  1835                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  1836                                  ;
  1837                                  ;	EXIT	ZR set if removeable media
  1838                                  ;		ZR clear if fixed media
  1839                                  ;
  1840                                  ;	USED	none
  1841                                  
  1842                                  REMCHECK:
  1843 00000298 50                      	push	ax
  1844 00000299 53                      	push	bx
  1845 0000029A 89C3                    	mov	bx,ax
  1846 0000029C B80844                  	mov	ax,(IOCTL<<8)+8 ; 4408h
  1847 0000029F CD21                    	int	21h			; DOS - 2+ - IOCTL -
  1848 000002A1 7304                    	jnc	short RCCONT			
  1849                                  
  1850                                  ;	If an error occurred, assume the media is non-removable.
  1851                                  ;	AX contains the non-zero error code from the int 21, so
  1852                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  1853                                  ;	appear to be non-removable.				
  1854                                  					
  1855 000002A3 09C0                    	or	ax,ax			
  1856 000002A5 EB05                    	jmp	short RESREGS
  1857                                  RCCONT:
  1858 000002A7 83E001                  	and	ax,1
  1859 000002AA F7D0                    	not	ax
  1860                                  RESREGS:
  1861 000002AC 5B                      	pop	bx
  1862 000002AD 58                      	pop	ax
  1863 000002AE C3                      	retn
  1864                                  
  1865                                  ;***	THeadFix
  1866                                  ;
  1867                                  ;	Far version of HeadFix, called from transient.
  1868                                  
  1869                                  THEADFIX:
  1870                                  	;pop	ds			;ds = DATARES
  1871                                  	;add	sp,2			;discard old ds value on stack
  1872                                  
  1873 000002AF E80100                  	call	HEADFIX
  1874 000002B2 CB                      	retf
  1875                                  
  1876                                  ;***	HeadFix
  1877                                  
  1878                                  HEADFIX:
  1879 000002B3 E82A01                  	call	SETVECT			; set vectors to our values
  1880                                  
  1881                                  ;	Clean up header
  1882                                  
  1883                                  ;	Bugbug:	optimize:
  1884                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  1885                                  
  1886 000002B6 31DB                    	xor	bx,bx				; BX = handle = 0
  1887 000002B8 8B0E[F10A]              	mov	cx,[IO_SAVE]			; CX = original stdin, stdout
  1888 000002BC 8B161800                	mov	dx,[PDB.JFN_TABLE] ; mov dx,[ds:18h] ; DX = current stdin, stdout
  1889 000002C0 38D1                    	cmp	cl,dl
  1890 000002C2 7408                    	je	short CHK1		; stdin matches
  1891 000002C4 B43E                    	mov	ah,CLOSE  ; 3Eh
  1892 000002C6 CD21                    	int	21h			; close stdin
  1893 000002C8 880E1800                	mov	[PDB.JFN_TABLE],cl ; mov [ds:18h],cl ; restore stdin
  1894                                  CHK1:
  1895 000002CC 43                      	inc	bx			; BX = handle = 1
  1896 000002CD 38F5                    	cmp	ch,dh			
  1897 000002CF 7408                    	je	short CHKOTHERHAND	; stdout matches
  1898 000002D1 B43E                    	mov	ah,CLOSE
  1899 000002D3 CD21                    	int	21h			; close stdout
  1900 000002D5 882E1900                	mov	[PDB.JFN_TABLE+1],ch ; mov [ds:19h],ch	; restore stdout
  1901                                  
  1902                                  CHKOTHERHAND:
  1903 000002D9 83C304                  	add	bx,4			; skip handles 2,3,4
  1904 000002DC B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  1905                                  					;   (handles 0-4 already done)
  1906                                  CLOSELOOP:
  1907 000002DF B43E                    	mov	ah,CLOSE ; 3Eh
  1908 000002E1 CD21                    	int	21h			; close each handle
  1909 000002E3 43                      	inc	bx			; BX = next handle
  1910 000002E4 E2F9                    	loop	CLOSELOOP
  1911                                  
  1912                                  	; MSDOS 6.0
  1913                                  ;;	Bugbug:	since this is for transient code, move it there
  1914                                  ;
  1915                                  ;;	M012: remove this CS -> DS.  Must've been missed during
  1916                                  ;;	purification.
  1917                                  ;;;	push	ds			; save data segment
  1918                                  ;;;	push	cs			; get local segment into DS
  1919                                  ;;;	pop	ds			;
  1920                                  ;	cmp	Append_Flag,-1		; do we need to reset APPEND?
  1921                                  ;	jne	Append_Fix_End		; no - just exit
  1922                                  ;	mov	ax,AppendSetState	; set the state of Append
  1923                                  ;	mov	bx,Append_State 	;     back to the original state
  1924                                  ;	int	2Fh			;
  1925                                  ;	mov	Append_Flag,0		; set append flag to invalid
  1926                                  ;Append_Fix_End: 			;
  1927                                  ;;;	pop	ds			; get data segment back
  1928                                  ;	retn
  1929                                  
  1930                                  	; MSDOS 3.3
  1931 000002E6 C3                      	retn
  1932                                  
  1933                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  1934                                  ;
  1935                                  ;	ENTRY	nothing
  1936                                  ;
  1937                                  ;	EXIT	nothing
  1938                                  ;
  1939                                  ;	USED	flags
  1940                                  ;
  1941                                  ;	EFFECTS
  1942                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  1943                                  ;	  current program's stdin,stdout set to our stderr
  1944                                  ;
  1945                                  
  1946                                  ;SR;
  1947                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  1948                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  1949                                  ;
  1950                                  SAVHAND:
  1951                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  1952                                  
  1953 000002E7 1E                      	push	ds ; MSDOS 3.3
  1954 000002E8 53                      	push	bx			;preserve registers
  1955 000002E9 50                      	push	ax
  1956                                  	;push	es
  1957                                  	;push	ds			; save DATARES value
  1958                                  
  1959 000002EA B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1960 000002EC CD21                    	int	21h			; BX = user's header seg addr
  1961 000002EE 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  1962 000002F0 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h]	; DS:BX = ptr to JFN table
  1963 000002F4 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  1964                                  
  1965                                  	;pop	es			;es = DATARES
  1966                                  	;push	es			;save it back on stack
  1967                                  	;mov	es:Handle01,ax		; save user's stdin, stdout
  1968 000002F6 2EA3[960A]              	mov	[cs:HANDLE01],ax
  1969                                  
  1970                                  ;SR;
  1971                                  ; Use es to address Handle01 & our JFN_Table
  1972                                  ;
  1973                                  
  1974                                  	;mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
  1975 000002FA 2EA01A00                	mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  1976 000002FE 88C4                    	mov	ah,al			; AH = COMMAND stderr
  1977 00000300 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  1978                                  
  1979                                  	;pop	ds			; restore registers
  1980                                  	;pop	es
  1981 00000302 58                      	pop	ax
  1982 00000303 5B                      	pop	bx
  1983 00000304 1F                      	pop	ds ; MSDOS 3.3
  1984 00000305 C3                      	retn
  1985                                  
  1986                                  	;assume	ds:DATARES
  1987                                  GETCOMDSK2:
  1988 00000306 E81F00                  	call	GETCOMDSK
  1989 00000309 E90DFF                  	jmp	LODCOM1			; memory already allocated
  1990                                  
  1991                                  RESTHAND:
  1992 0000030C 1E                      	push	ds
  1993 0000030D 53                      	push	bx			; restore stdin, stdout to user
  1994 0000030E 50                      	push	ax
  1995 0000030F B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1996 00000311 CD21                    	int	21h			; point to user's header
  1997 00000313 A1[960A]                	mov	ax,[HANDLE01]
  1998 00000316 8EDB                    	mov	ds,bx
  1999                                  	;assume ds:NOTHING
  2000 00000318 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h] ; DS:BX = ptr to jfn table
  2001 0000031C 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  2002 0000031E 58                      	pop	ax
  2003 0000031F 5B                      	pop	bx
  2004 00000320 1F                      	pop	ds
  2005 00000321 C3                      	retn
  2006                                  
  2007                                  	;assume ds:DATARES,ss:DATARES
  2008                                  HOPELESS:
  2009 00000322 BA[EF08]                	mov	dx,COMBAD
  2010 00000325 E9E9FD                  	jmp	FATALC
  2011                                  
  2012                                  GETCOMDSK:
  2013 00000328 A0[E60A]                	mov	al,[COMDRV]
  2014 0000032B E86AFF                  	call	REMCHECK
  2015 0000032E 75F2                    	jnz	short HOPELESS		; non-removable media
  2016                                  GETCOMDSK3:
  2017 00000330 81FA[EF08]              	cmp	dx,COMBAD
  2018 00000334 7503                    	jne	short GETCOMDSK4
  2019                                  	;;mov	dx,offset DATARES:ComBad	; DX = ptr to msg
  2020                                  	;invoke	RPrint				; say COMMAND is invalid
  2021 00000336 E85D03                  	call	RDISPMSG
  2022                                  GETCOMDSK4:
  2023                                  ;	Bugbug:	there's always a drive here?  No need to check?
  2024 00000339 803E[2309]00            	cmp	byte [PUTBACKDRV],0	; is there a drive in the comspec?
  2025 0000033E 7509                    	jne	short USERS_DRIVE	; yes - use it
  2026 00000340 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  2027 00000342 CD21                    	int	21h
  2028 00000344 0441                    	add	al,"A"                  ; convert to ascii
  2029 00000346 A2[2309]                	mov	[PUTBACKDRV],al		; put in message to print out
  2030                                  
  2031                                  USERS_DRIVE:
  2032                                  	; MSDOS 6.0
  2033                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  2034                                  	;mov	si,offset DATARES:PutBackSubst	;  containing COMMAND
  2035                                  	;invoke	RPrint
  2036                                  	;mov	dx,offset DATARES:Prompt	; "Press any key"
  2037                                  	;invoke	RPrint
  2038                                  
  2039                                  	; MSDOS 3.3
  2040 00000349 BA[0709]                	mov	dx,PUTBACKMSG		; prompt for diskette
  2041 0000034C E84703                  	call	RDISPMSG
  2042 0000034F 8B16[DB0A]              	mov	dx,[PUTBACKSUBSTPTR]
  2043 00000353 8B36[DD0A]              	mov	si,[COMSPEC_END]
  2044 00000357 C6440124                	mov	byte [si+1],'$'
  2045 0000035B E83803                  	call	RDISPMSG
  2046 0000035E C6440100                	mov	byte [si+1],0
  2047 00000362 BA[1909]                	mov	dx,PROMPT
  2048 00000365 E82E03                  	call    RDISPMSG
  2049                                  
  2050 00000368 E80100                  	call	GETRAWFLUSHEDBYTE
  2051 0000036B C3                      	retn
  2052                                  
  2053                                  ;***	GetRawFlushedByte - flush world and get raw input
  2054                                  
  2055                                  GETRAWFLUSHEDBYTE:
  2056 0000036C B8070C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  2057 0000036F CD21                    	int	21h			; get char without testing or echo
  2058 00000371 B8000C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  2059 00000374 CD21                    	int	21h
  2060                                  ;	Bugbug:	get rid of this return and the following retz.
  2061                                  LOADCOM_RETN:
  2062 00000376 C3                      	retn
  2063                                  
  2064                                  ;***	LoadCom - load in transient
  2065                                  
  2066                                  LOADCOM:
  2067                                  	;assume	ds:DATARES
  2068                                  	
  2069 00000377 45                      	inc	bp				; flag command read
  2070                                  
  2071 00000378 BA[9B0A]                	mov	dx,COMSPEC
  2072 0000037B B8003D                  	mov	ax,OPEN<<8	; 3D00h
  2073 0000037E CD21                    	int	21h				; open command.com
  2074 00000380 7310                    	jnc	short READCOM
  2075 00000382 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  2076 00000385 7506                    	jnz	short TRYDOOPEN
  2077 00000387 BA[AA09]                	mov	dx,NOHANDMES
  2078 0000038A E984FD                  	jmp	FATALC				; will never find a handle
  2079                                  
  2080                                  TRYDOOPEN:
  2081 0000038D E898FF                  	call	GETCOMDSK
  2082 00000390 EBE5                    	jmp	short LOADCOM
  2083                                  
  2084                                  READCOM:
  2085 00000392 89C3                    	mov	bx,ax				; BX = handle
  2086 00000394 BA[5015]                	mov	dx,TRANSTART
  2087 00000397 31C9                    	xor	cx,cx				; CX:DX = seek loc
  2088 00000399 B80042                  	mov	ax,LSEEK<<8	; 4200h
  2089 0000039C CD21                    	int	21h
  2090 0000039E 7210                    	jc	short WRONGCOM1
  2091 000003A0 B97C4B                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  2092 000003A3 1E                      	push	ds
  2093 000003A4 8E1E[E10A]              	mov	ds,[TRNSEG]
  2094                                  	;assume	ds:NOTHING
  2095 000003A8 BA0001                  	mov	dx,100h
  2096 000003AB B43F                    	mov	ah,READ	; 3Fh	
  2097 000003AD CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  2098                                  			; BX = file handle, CX = number of bytes to read
  2099                                  			; DS:DX -> buffer
  2100 000003AF 1F                      	pop	ds
  2101                                  	;assume	ds:DATARES
  2102                                  WRONGCOM1:
  2103 000003B0 9C                      	pushf
  2104 000003B1 50                      	push	ax
  2105 000003B2 B43E                    	mov	ah,CLOSE ; 3Eh
  2106 000003B4 CD21                    	int	21h			; close command.com
  2107 000003B6 58                      	pop	ax
  2108 000003B7 9D                      	popf
  2109 000003B8 7204                    	jc	short WRONGCOM		; error on read
  2110 000003BA 39C8                    	cmp	ax,cx
  2111                                  	;retz				; size matched
  2112 000003BC 74B8                    	jz	short LOADCOM_RETN
  2113                                  WRONGCOM:
  2114 000003BE BA[EF08]                	mov	dx,COMBAD
  2115 000003C1 E864FF                  	call	GETCOMDSK
  2116 000003C4 EBB1                    	jmp	short LOADCOM		; try again
  2117                                  
  2118                                  
  2119                                  ;***	ChkSum - compute transient checksum
  2120                                  
  2121                                  CHKSUM:
  2122 000003C6 1E                      	push	ds
  2123 000003C7 8E1E[E10A]              	mov	ds,[TRNSEG]
  2124 000003CB BE0001                  	mov	si,100h
  2125 000003CE B9653D                  	mov	cx,TRANDATAEND-100H	; 3E44h (for original MSDOS 3.3!)
  2126                                  
  2127                                  CHECK_SUM:
  2128 000003D1 FC                      	cld
  2129 000003D2 D1E9                    	shr	cx,1
  2130 000003D4 31D2                    	xor	dx,dx
  2131                                  CHK:
  2132 000003D6 AD                      	lodsw
  2133 000003D7 01C2                    	add	dx,ax
  2134 000003D9 83D200                  	adc	dx,0
  2135 000003DC E2F8                    	loop	CHK
  2136 000003DE 1F                      	pop	ds
  2137 000003DF C3                      	retn
  2138                                  
  2139                                  ;***	SetVect - set interrupt vectors
  2140                                  
  2141                                  SETVECT:
  2142                                  	;mov	dx,offset DATARES:LodCom_Trap 
  2143 000003E0 BA[AD01]                	mov	dx,LODCOM ; MSDOS 3.3
  2144 000003E3 B82225                  	mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  2145 000003E6 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  2146 000003EA 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  2147 000003EE CD21                    	int	21h
  2148                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  2149 000003F0 BA[3C00]                	mov	dx,CONTC ; MSDOS 3.3
  2150 000003F3 FEC0                    	inc	al	; 23h
  2151 000003F5 CD21                    	int	21h
  2152                                  	;mov	dx,offset DATARES:CritErr_Trap
  2153 000003F7 BA[4F04]                	mov	dx,CRITERR ; MSDOS 3.3
  2154 000003FA FEC0                    	inc	al	; 24h
  2155 000003FC CD21                    	int	21h
  2156 000003FE C3                      	retn
  2157                                  
  2158                                  	; MSDOS 6.0
  2159                                  ;;SR;
  2160                                  ;; We have this to take care of the extra values pushed on the stack by 
  2161                                  ;;the stub before jumping to LodCom1. We set up ds here and then jump to
  2162                                  ;;Lodcom1
  2163                                  ;;
  2164                                  ;public	TrnLodCom1
  2165                                  ;TrnLodCom1:
  2166                                  ;	pop	ds			;ds = DATARES
  2167                                  ;	add	sp,2
  2168                                  ;;	pop	ds:OldDS
  2169                                  ;	jmp	LodCom1
  2170                                  
  2171                                  ;***	EndInit - end up initialization sequence
  2172                                  ;
  2173                                  ;	Move the environment to a newly allocated segment.
  2174                                  
  2175                                  	; MSDOS 3.3
  2176                                  ENDINIT:
  2177 000003FF 1E                      	push	ds			; save segments
  2178 00000400 06                      	push	es			;
  2179 00000401 0E                      	push	cs			; get resident segment to DS
  2180 00000402 1F                      	pop	ds			;
  2181                                  	;assume	ds:RESGROUP
  2182 00000403 8B0E[0715]              	mov	cx,[USEDENV]		; get number of bytes to move
  2183 00000407 8E06[050C]              	mov	es,[ENVIRSEG]		; get target environment segment
  2184                                  	;assume	es:NOTHING
  2185                                  
  2186 0000040B 803E[0D15]01            	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  2187 00000410 750A                    	jne	short NO_RESET 		; no - we already did it
  2188 00000412 8B1E[0115]              	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  2189 00000416 06                      	push	es			; save environment - just to be sure
  2190 00000417 B44A                    	mov	ah,SETBLOCK  ; 4Ah	;
  2191 00000419 CD21                    	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2192                                  				; ES = segment address of block to change
  2193                                  				; BX = new size in paragraphs
  2194 0000041B 07                      	pop	es
  2195                                  
  2196                                  NO_RESET:
  2197 0000041C 8C062C00                	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  2198 00000420 8E1E[0515]              	mov	ds,[OLDENV]		; source environment segment
  2199                                  	;assume	ds:NOTHING
  2200 00000424 31F6                    	xor	si,si			; set up offsets to start of segments
  2201 00000426 31FF                    	xor	di,di
  2202 00000428 FC                      	cld
  2203 00000429 F3A4                    	rep	movsb			; move it
  2204 0000042B 31C0                    	xor	ax,ax
  2205 0000042D AA                      	stosb				; make sure it ends with double-null
  2206                                  
  2207                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  2208 0000042E 07                      	pop	es
  2209 0000042F 1F                      	pop	ds
  2210 00000430 E97AFD                  	jmp	LODCOM			; allocate transient
  2211                                  
  2212                                  
  2213                                  	; MSDOS 6.0
  2214                                  ;
  2215                                  ;The init code has been changed to take care of the new way in which the
  2216                                  ;environment segment is allocated.
  2217                                  ;NB: We can use all the init variables at this point because they are all in
  2218                                  ;RESGROUP
  2219                                  ;Bugbug: The above approach will not work for ROMDOS
  2220                                  ;
  2221                                  
  2222                                  ;IF 0
  2223                                  ;
  2224                                  ;EndInit:
  2225                                  ;	push	ds
  2226                                  ;	push	es			;save segments
  2227                                  ;	push	cs
  2228                                  ;	pop	ds		
  2229                                  ;	assume	ds:RESGROUP
  2230                                  ;;
  2231                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  2232                                  ;;
  2233                                  ;	mov	bx,ds
  2234                                  ;	mov	es,bx			;es = RESGROUP
  2235                                  ;;
  2236                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2237                                  ;; code + data for low COMMAND
  2238                                  ;;
  2239                                  ;	mov	bx,ResSize		;Total size of resident
  2240                                  ;	mov	ah,SETBLOCK
  2241                                  ;	int	21h			;Set block to resident size
  2242                                  ;;
  2243                                  ;;Allocate the correct size for the environment
  2244                                  ;;
  2245                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  2246                                  ;	mov	ah,ALLOC
  2247                                  ;	int	21h			;get memory
  2248                                  ;	jc	nomem_err		;out of memory,signal error
  2249                                  ;
  2250                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  2251                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  2252                                  ;	mov	es,ax			;es = address of allocated memory
  2253                                  ;	assume	es:nothing
  2254                                  ;
  2255                                  ;;
  2256                                  ;;Copy the environment to the newly allocated segment
  2257                                  ;;
  2258                                  ;	mov	cx,UsedEnv		;number of bytes to move
  2259                                  ;
  2260                                  ;	push	ds
  2261                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  2262                                  ;	assume	ds:nothing
  2263                                  ;
  2264                                  ;	xor	si,si
  2265                                  ;	mov	di,si			;Start transfer from 0
  2266                                  ;
  2267                                  ;	cld
  2268                                  ;	rep	movsb			;Do the copy
  2269                                  ;
  2270                                  ;	xor	ax,ax			
  2271                                  ;	stosb				;Make it end with double-null
  2272                                  ;
  2273                                  ;	pop	ds			;ds = RESGROUP
  2274                                  ;	assume	ds:RESGROUP
  2275                                  ;;
  2276                                  ;;We have to free the old environment block if it was allocated by INIT
  2277                                  ;;
  2278                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  2279                                  ;	je      no_free                 ;no, do not free it
  2280                                  ;
  2281                                  ;	mov	ax,OldEnv		;Get old environment
  2282                                  ;	mov	es,ax
  2283                                  ;	mov	ah,DEALLOC	
  2284                                  ;	int	21h			;Free it
  2285                                  ;no_free:
  2286                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  2287                                  ;	
  2288                                  ;	pop	es
  2289                                  ;	pop	ds
  2290                                  ;	assume	ds:nothing
  2291                                  ;	
  2292                                  ;	jmp	LodCom			;allocate transient
  2293                                  ;
  2294                                  ;nomem_err:
  2295                                  ;;
  2296                                  ;;We call the error routine which will never return. It will either exit
  2297                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  2298                                  ;;message ( if first COMMAND )
  2299                                  ;;
  2300                                  ;
  2301                                  ;	call	Alloc_error
  2302                                  ;ENDIF
  2303                                  ;
  2304                                  ;CODERES ends
  2305                                  
  2306                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2307                                  ;	the resident group which is the location where the transient
  2308                                  ;	segments will be loaded initial.
  2309                                  
  2310                                  ;TAIL		segment public para
  2311                                  ;
  2312                                  ;		org	0
  2313                                  ;TranStart	label	word
  2314                                  ;		public	TranStart
  2315                                  ;
  2316                                  ;TAIL		ends
  2317                                  ;
  2318                                  
  2319                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2320                                  ;	the transient group which is the location where the exec
  2321                                  ;	segments will be loaded initial.
  2322                                  ;
  2323                                  ;	Bugbug:	Is TRANTAIL used anymore?
  2324                                  
  2325                                  ;TRANTAIL	segment public para
  2326                                  ;
  2327                                  ;		org	0
  2328                                  ;ExecStart   	label   word
  2329                                  ;
  2330                                  ;TRANTAIL    	ends
  2331                                  
  2332                                  ;=============================================================================
  2333                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  2334                                  ;=============================================================================
  2335                                  ; 22/09/2018 - Retro DOS v3.0
  2336                                  
  2337                                  ;	title	Localizable code for resident COMMAND
  2338                                  
  2339                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2340                                  
  2341                                  ;***	AskEnd - ask user to confirm batch file termination
  2342                                  ;
  2343                                  ;	Confirm with user before freeing batch ...
  2344                                  ;
  2345                                  ;	ENTRY	nothing
  2346                                  ;
  2347                                  ;	EXIT	CY = set if batch termination is confirmed
  2348                                  ;
  2349                                  ;		CY = clear if batch should continue
  2350                                  ;
  2351                                  ;	USED	AX,DX,...
  2352                                  
  2353                                  ;	Bugbug:	move this to transient, copy to batch segment.
  2354                                  ;	Bugbug:	or move it to command1 1st.
  2355                                  
  2356                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  2357                                  
  2358                                  ASKEND:
  2359                                  	;assume	ds:DATARES
  2360                                  
  2361 00000433 BA[4609]                	mov	dx,ENDBATMES			; DX = message #
  2362                                  	;call	RPrint
  2363 00000436 E85D02                  	call	RDISPMSG  ; MSDOS 3.3
  2364 00000439 B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  2365 0000043C CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  2366                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  2367 0000043E E85D02                  	call	CHARTOUPPER			; change to upper case
  2368 00000441 3A06[7E0A]              	cmp	al,[NO_CHAR]
  2369 00000445 7407                    	je	short AERET			; answer is no (CY is clear)
  2370 00000447 3A06[7D0A]              	cmp	al,[YES_CHAR]
  2371 0000044B 75E6                    	jne	short ASKEND			; invalid response, try again
  2372 0000044D F9                      	stc					; answer is yes
  2373                                  AERET:	
  2374 0000044E C3                      	retn
  2375                                  
  2376                                  
  2377                                  ;***	DskErr - critical error handler
  2378                                  ;
  2379                                  ;	Default critical error handler unless user intercepts int 24h.
  2380                                  ;
  2381                                  ;	ENTRY	int 24h
  2382                                  ;
  2383                                  ;	EXIT
  2384                                  ;
  2385                                  ;	USED
  2386                                  ;
  2387                                  ;	EFFECTS
  2388                                  
  2389                                  ;
  2390                                  ;SR; 
  2391                                  ; The stub is going to push the old ds value and the resident data segment
  2392                                  ;onto the stack in that order. Get it off the stack
  2393                                  ;
  2394                                  
  2395                                  ;DskErr	proc	far
  2396                                  DSKERRR:
  2397                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2398                                  	;
  2399                                  	;pop	ds			;ds = DATARES
  2400                                  	;assume ds:DATARES
  2401                                  	;pop	OldDS			;save old ds value
  2402                                  
  2403                                  CRITERR: ; MSDOS 3.3
  2404 0000044F FB                      	sti
  2405 00000450 1E                      	push	ds ; 25/09/2018
  2406 00000451 06                      	push	es
  2407 00000452 56                      	push	si
  2408 00000453 51                      	push	cx
  2409 00000454 57                      	push	di
  2410 00000455 51                      	push	cx
  2411 00000456 50                      	push	ax
  2412                                  
  2413                                  	;push	ds			;save our data segment
  2414 00000457 0E                      	push	cs ; 25/09/2018
  2415 00000458 07                      	pop	es			;es = DATARES
  2416                                  
  2417 00000459 8EDD                    	mov	ds,bp
  2418                                  	;assume	ds:nothing
  2419                                  
  2420                                  	;mov	ax,[si].SDEVATT
  2421 0000045B 8B4404                  	MOV	ax,[SI+SYSDEV.ATT] ; mov ax,[si+4]	
  2422 0000045E 268826[D108]            	mov	[es:CDEVAT],ah
  2423                                  
  2424                                  	;push	cs
  2425                                  	;pop	es
  2426                                  
  2427 00000463 BF[A508]                	mov	di,DEVNAME
  2428 00000466 B90800                  	mov	cx,8
  2429                                  	;add	si,SDEVNAME  ; add si,10
  2430 00000469 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  2431                                  				
  2432 0000046C FC                      	cld
  2433 0000046D F3A4                    	rep	movsb
  2434 0000046F 58                      	pop	ax
  2435 00000470 59                      	pop	cx
  2436 00000471 5F                      	pop	di
  2437                                  
  2438                                  ;	Stack still contains DS and ES.
  2439                                  
  2440                                  ;SR;
  2441                                  ; We need ds = DATARES for SavHand
  2442                                  ;
  2443                                  	;push	es
  2444                                  	;pop	ds
  2445                                  	;assume	ds:DATARES
  2446                                  
  2447                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  2448 00000472 E872FE                  	call	SAVHAND
  2449                                  
  2450                                  	; 25/09/2018
  2451                                  	;push	cs
  2452 00000475 06                      	push	es
  2453 00000476 1F                      	pop	ds		; set up local data segment
  2454                                  	;assume	ds:resgroup
  2455                                  
  2456 00000477 52                      	push	dx
  2457 00000478 E81802                  	call	CRLF
  2458 0000047B 5A                      	pop	dx
  2459                                  
  2460                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  2461                                  
  2462 0000047C 8826[EE0A]              	mov	[CRIT_ERR_INFO],ah	; save critical error flags
  2463                                  
  2464                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  2465                                  
  2466 00000480 0441                    	add	al,'A'
  2467 00000482 A2[9908]                	mov	[DRVLET],al
  2468                                  
  2469                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  2470                                  
  2471 00000485 F6C480                  	test	ah,80h
  2472 00000488 740A                    	jz	short NOHARDE		; it's a disk-device error
  2473 0000048A F606[D108]80            	test	byte [CDEVAT],DEVTYP>>8 ; 80h
  2474 0000048F 7503                    	jnz	short NOHARDE		; it's a character device
  2475 00000491 E9EF01                  	jmp	FATERR			; it's a FAT error
  2476                                  
  2477                                  NOHARDE:
  2478 00000494 BE[7A08]                	mov	si,MREAD		; SI = "read" msg #
  2479 00000497 F6C401                  	test	ah,1
  2480 0000049A 7403                    	jz	short SAVMES		; it's a read error
  2481 0000049C BE[8208]                	mov	si,MWRITE		; SI = "write" msg #
  2482                                  
  2483                                  SAVMES:
  2484 0000049F 893E[270C]              	mov	[OLDERRNO],di		; save critical error code
  2485                                  
  2486                                  ;	Bugbug:	don't need to save/restore all here?
  2487 000004A3 06                      	push	es
  2488 000004A4 1E                      	push	ds			; GetExtendedError likes to STOMP
  2489 000004A5 55                      	push	bp
  2490 000004A6 56                      	push	si
  2491 000004A7 52                      	push	dx
  2492 000004A8 51                      	push	cx
  2493 000004A9 53                      	push	bx
  2494 000004AA B459                    	mov	ah,GetExtendedError ; 59h ; get extended error info
  2495 000004AC CD21                    	int	21h
  2496 000004AE 5B                      	pop	bx
  2497 000004AF 59                      	pop	cx
  2498 000004B0 5A                      	pop	dx
  2499 000004B1 5E                      	pop	si
  2500 000004B2 5D                      	pop	bp
  2501 000004B3 1F                      	pop	ds
  2502 000004B4 893E[830A]              	mov	[NEEDVOL],di 	; save possible ptr to volume label
  2503 000004B8 8C06[850A]              	mov	[NEEDVOL+2],es
  2504 000004BC 07                      	pop	es
  2505                                  
  2506                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  2507                                  
  2508 000004BD 30E4                    	xor	ah,ah
  2509 000004BF 89C7                    	mov	di,ax			; DI = error code
  2510                                  
  2511                                  ; Bugbug:  somewhat obsolete documentation?
  2512                                  ;
  2513                                  ; DI is now the correct error code. Classify things to see what we are
  2514                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  2515                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  2516                                  ; the like) are contiguous.
  2517                                  ;
  2518                                  
  2519                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  2520                                  ;	Check use of ErrCd_24, though.
  2521                                  
  2522 000004C1 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  2523 000004C4 7303                    	jae	short HAVCOD
  2524                                  
  2525                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  2526                                  ;	even though it's not a critical error?
  2527                                  
  2528 000004C6 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  2529                                  ;
  2530                                  ; DI now has the mapped error code. Old style errors are:
  2531                                  ;   FOOBAR <read|writ>ing drive ZZ.
  2532                                  ; New style errors are:
  2533                                  ;   FOOBAR
  2534                                  ; We need to figure out which the particular error belongs to.
  2535                                  ;
  2536                                  
  2537                                  HAVCOD:
  2538 000004C9 C606[870A]00            	mov	byte [ERRTYPE],0	; assume old style
  2539 000004CE 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  2540 000004D1 7405                    	je	short SETSTYLE
  2541 000004D3 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2542 000004D6 7504                    	jne	short GOTSTYLE
  2543                                  
  2544                                  SETSTYLE:
  2545                                  ;	Bugbug:	use INC
  2546                                  	;mov	byte [ERRTYPE],1		; must be new type
  2547 000004D8 FE06[870A]              	inc	byte [ERRTYPE] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  2548                                  
  2549                                  GOTSTYLE:
  2550 000004DC 893E[940A]              	mov	[ERRCD_24],di
  2551                                  	; 25/09/2018
  2552                                  	; MSDOS 6.0
  2553                                  	;cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  2554                                  	; MSDOS 3.3
  2555 000004E0 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2556                                  
  2557                                  						; If the error message is unknown
  2558 000004E3 7641                    	jbe	short NORMALERROR		;  redirector, continue. Otherwise,
  2559                                  ;
  2560                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  2561                                  ; how to handle things
  2562                                  ;
  2563                                  
  2564                                  ;input to IFSFUNC:    AL=1
  2565                                  ;		      BX=extended error number
  2566                                  ;
  2567                                  ;output from IFSFUNC: AL=error type (0 or 1)
  2568                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  2569                                  ;			   Abort, Retry, Ignore
  2570                                  ;			 1=<message>
  2571                                  ;			   Abort, Retry, Ignore
  2572                                  ;		      ES:DI=pointer to message text
  2573                                  ;		      carry set=>no message
  2574                                  
  2575 000004E5 89C7                    	mov	di,ax			; retrieve correct extended error...
  2576 000004E7 B80005                  	mov	ax,0500h		; is the redir there?
  2577 000004EA CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  2578                                  			; Return: AL = 00h not installed, OK to install
  2579                                  			; 01h not installed, can't install
  2580                                  			; FFh installed
  2581 000004EC 3CFF                    	cmp	al,0FFh
  2582 000004EE 7529                    	jne	short NOHANDLER		; no, go to NoHandler
  2583                                  
  2584                                  	; MSDOS 6.0
  2585                                  	;push	bx
  2586                                  	;mov	bx,di			; get ErrType and ptr to error msg
  2587                                  	;mov	ax,0501h
  2588 000004F0 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2589                                  	;pop	bx 
  2590                                  	;jc	short NOHANDLER
  2591                                  	; MSDOS 3.3
  2592 000004F2 89F8                    	mov     ax,di
  2593 000004F4 B405                    	mov     ah,5
  2594 000004F6 CD2F                    	int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2595 000004F8 721F                    	jc      short NOHANDLER
  2596                                  
  2597                                  ;	Bugbug:	need to record error type?
  2598 000004FA A2[870A]                	mov	[ERRTYPE],al
  2599 000004FD 1E                      	push	ds
  2600 000004FE 06                      	push	es
  2601 000004FF 1F                      	pop	ds
  2602 00000500 89FA                    	mov	dx,di
  2603 00000502 B9FFFF                  	mov	cx,-1			; find end of msg
  2604 00000505 30C0                    	xor	al,al
  2605                                  
  2606 00000507 FC                      	cld
  2607 00000508 F2AE                    	repnz	scasb
  2608                                  
  2609                                  ;	Bugbug:	we can do better than this.
  2610                                  
  2611 0000050A C645FF24                	mov	byte [di-1],'$'
  2612                                  	
  2613                                  	;CALL	RDISPMSG ; MSDOS 3.3
  2614                                  	
  2615 0000050E B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  2616 00000510 CD21                    	int	21h
  2617                                  
  2618 00000512 C645FF00                	mov	byte [di-1],0			; restore terminal byte
  2619                                  
  2620 00000516 1F                      	pop	ds				; clean up and continue
  2621 00000517 EB18                    	jmp	short CHECKERRTYPE
  2622                                  
  2623                                  ;*	Redir isn't available or doesn't recognize the error.
  2624                                  ;	Restore regs to unextended error.
  2625                                  
  2626                                  NOHANDLER:
  2627 00000519 C606[870A]00            	mov	byte [ERRTYPE],0
  2628                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  2629 0000051E 8B3E[270C]              	mov	di,[OLDERRNO]
  2630 00000522 893E[940A]              	mov	[ERRCD_24],di
  2631                                  
  2632                                  NORMALERROR:
  2633                                  	; MSDOS 6.0
  2634                                  	;add	di,ERROR_WRITE_PROTECT
  2635                                  	;xchg	di,dx			; may need dx later
  2636                                  	;call	RPrintCrit		; print error type
  2637                                  
  2638                                  	; MSDOS 3.3
  2639 00000526 D1E7                    	shl     di,1
  2640 00000528 8BBD[4207]              	mov     di,[CRMSGTBL+di]
  2641 0000052C 87FA                    	xchg    di,dx
  2642 0000052E E86501                  	call    RDISPMSG
  2643                                  
  2644                                  CHECKERRTYPE:
  2645 00000531 803E[870A]00            	cmp	byte [ERRTYPE],0	; Check error style...
  2646 00000536 7405                    	je	short CONTOLD
  2647 00000538 E85801                  	call	CRLF			; if new style then done printing
  2648 0000053B EB2E                    	jmp	short ASK
  2649                                  
  2650                                  CONTOLD:
  2651                                  	; MSDOS 6.0
  2652                                  ;	inc	si			; DS:SI = ptr to asciiz string
  2653                                  ;
  2654                                  ;;	Bugbug:	combine some of the following two sections?
  2655                                  ;
  2656                                  ;	test	[CDevAt],DEVTYP shr 8
  2657                                  ;	jz	BlkErr
  2658                                  ;	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
  2659                                  ;	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
  2660                                  ;	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  2661                                  ;
  2662                                  ;	call	RPrint				; print the message
  2663                                  ;	jmp	short Ask			; don't ralph on command
  2664                                  
  2665                                  	; MSDOS 3.3
  2666 0000053D BA[8A08]                	mov	dx,ERRMES
  2667 00000540 E85301                  	call	RDISPMSG
  2668 00000543 89F2                    	mov	dx,si
  2669 00000545 E84E01                  	call	RDISPMSG
  2670                                  	
  2671 00000548 F606[D108]80            	test	byte [CDEVAT], 80h
  2672 0000054D 7409                    	jz	short BLKERR
  2673 0000054F BA[9D08]                	mov	dx,CHARDEVERR	; " device "
  2674 00000552 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  2675 00000554 CD21                    	int	21h		; DOS - PRINT STRING
  2676                                  				; DS:DX -> string terminated by "$"
  2677 00000556 EB13                    	jmp	short ASK
  2678                                  
  2679                                  BLKERR:
  2680                                  	; MSDOS 6.0
  2681                                  	;mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
  2682                                  	;mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
  2683                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  2684                                  	;call	RPrint
  2685                                  
  2686                                  	; MSDOS 3.3
  2687 00000558 BA[9208]                	mov     dx,BLKDEVERR
  2688 0000055B E83801                  	call    RDISPMSG
  2689                                  
  2690 0000055E 803E[980A]00            	cmp	byte [LOADING],0
  2691 00000563 7406                    	jz	short ASK
  2692 00000565 E8A4FD                  	call	RESTHAND
  2693 00000568 E99BFD                  	jmp	GETCOMDSK2		; if error loading COMMAND, re-prompt
  2694                                  
  2695                                  ASK:
  2696 0000056B 833E[940A]0F            	cmp	word [ERRCD_24],15	; error 15 has an extra message
  2697 00000570 751C                    	jne	short NOT15		; not error 15
  2698                                  
  2699                                  ;*	For error 15, tell the user which volume/serial # are needed.
  2700                                  
  2701 00000572 51                      	push	cx
  2702                                  
  2703                                  ;	Bugbug:	does this push/pop need to be done?
  2704 00000573 1E                      	push	ds
  2705 00000574 07                      	pop	es
  2706 00000575 C536[830A]              	lds	si,[NEEDVOL]
  2707                                  	;assume	ds:NOTHING
  2708 00000579 57                      	push	di
  2709 0000057A BF[6C08]                	mov	di,VOLNAME
  2710                                  	; MSDOS 6.0
  2711                                  	;mov	cx,16			; copy volume name & serial #
  2712                                  	; MSDOS 3.3
  2713 0000057D B90B00                  	MOV	CX,11			; copy volume name
  2714 00000580 FC                      	cld
  2715 00000581 F3A4                    	rep	movsb
  2716 00000583 5F                      	pop	di
  2717 00000584 06                      	push	es
  2718 00000585 1F                      	pop	ds
  2719 00000586 59                      	pop	cx
  2720                                  	;assume	ds:DATARES
  2721                                  	; MSDOS 6.0
  2722                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  2723                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  2724                                  	;call	RPrint
  2725                                  
  2726                                  	; MSDOS 3.3
  2727 00000587 BA[5908]                	mov	dx,NEEDVOLMSG
  2728 0000058A B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2729 0000058C CD21                    	int     21h             ; DOS - PRINT STRING
  2730                                  				; DS:DX -> string terminated by "$"
  2731                                  NOT15:
  2732                                  ;*	Print abort, retry, ignore, fail message.
  2733                                  ;	Print only options that are valid.
  2734                                  
  2735                                  ;	Bugbug:	sizzle this.
  2736                                  
  2737 0000058E BA[B008]                	mov	dx,REQ_ABORT
  2738                                  	;call	RPrint
  2739 00000591 E80201                  	call	RDISPMSG
  2740 00000594 F606[EE0A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED  ; 10h
  2741 00000599 7406                    	jz	short TRY_IGNORE
  2742 0000059B BA[B608]                	mov	dx,REQ_RETRY
  2743                                  	;call	RPrint
  2744 0000059E E8F500                  	call	RDISPMSG
  2745                                  TRY_IGNORE:
  2746 000005A1 F606[EE0A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h
  2747 000005A6 7406                    	jz	short TRY_FAIL
  2748 000005A8 BA[BE08]                	mov	dx,REQ_IGNORE
  2749                                  	;call	RPrint
  2750 000005AB E8E800                  	call	RDISPMSG
  2751                                  TRY_FAIL:
  2752 000005AE F606[EE0A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED   ; 08h
  2753 000005B3 7406                    	jz	short TERM_QUESTION
  2754 000005B5 BA[C708]                	mov	dx,REQ_FAIL
  2755                                  	;call	RPrint
  2756 000005B8 E8DB00                  	call	RDISPMSG
  2757                                  TERM_QUESTION:
  2758 000005BB BA[CE08]                	mov	dx,REQ_END
  2759                                  	;call	RPrint
  2760 000005BE E8D500                  	call	RDISPMSG
  2761                                  
  2762                                  ;	If the /f switch was given, we fail all requests.
  2763                                  
  2764 000005C1 F606[F90A]FF            	test	byte [FFAIL],-1
  2765 000005C6 7405                    	jz	short DOPROMPT
  2766 000005C8 B403                    	mov	ah,3				; signal fail
  2767 000005CA E9AA00                  	jmp	EEXIT
  2768                                  
  2769                                  DOPROMPT:
  2770 000005CD B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  2771 000005D0 CD21                    	int	21h				; get response
  2772                                  
  2773 000005D2 E8BE00                  	call	CRLF
  2774 000005D5 E8C600                  	call	CHARTOUPPER			; convert to upper case
  2775 000005D8 B400                    	mov	ah,0				; return code for ignore
  2776 000005DA F606[EE0A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  2777 000005DF 7406                    	jz	short USER_RETRY
  2778 000005E1 3A06[810A]              	cmp	al,[IGNORE_CHAR]		; ignore?
  2779 000005E5 7429                    	jz	short EEXITJ
  2780                                  
  2781                                  ;	Bugbug:	optimize following code.
  2782                                  
  2783                                  USER_RETRY:
  2784 000005E7 FEC4                    	inc	ah				; return code for retry
  2785 000005E9 F606[EE0A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED ; 10h ; is retry allowed?
  2786 000005EE 7406                    	jz	short USER_ABORT
  2787 000005F0 3A06[7F0A]              	cmp	al,[RETRY_CHAR]			; retry?
  2788 000005F4 741A                    	jz	short EEXITJ
  2789                                  
  2790                                  USER_ABORT:
  2791 000005F6 FEC4                    	inc	ah				; return code for abort
  2792                                  						;  (abort always allowed)
  2793 000005F8 3A06[800A]              	cmp	al,[ABORT_CHAR]			; abort?
  2794 000005FC 7414                    	jz	short ABORT_PROCESS			; exit user program
  2795 000005FE FEC4                    	inc	ah				; return code for fail
  2796 00000600 F606[EE0A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED ; 08h ; is fail allowed?
  2797 00000605 7406                    	jz	short ASKJ
  2798 00000607 3A06[820A]              	cmp	al,[FAIL_CHAR]			; fail?
  2799 0000060B 7403                    	jz	short EEXITJ
  2800                                  ASKJ:
  2801 0000060D E95BFF                  	jmp	ASK
  2802                                  
  2803                                  EEXITJ:
  2804 00000610 EB65                    	jmp	short EEXIT
  2805                                  
  2806                                  ABORT_PROCESS:
  2807 00000612 F606[5B0B]01            	test	byte [INITFLAG],INITINIT ; 1	; COMMAND init interrupted?
  2808 00000617 741A                    	jz	short ABORTCONT			; no, handle it normally
  2809 00000619 803E[F40A]00            	cmp	byte [PERMCOM],0		; are we top level process?
  2810 0000061E 7408                    	jz	short JUSTEXIT			; yes, just exit
  2811                                  
  2812 00000620 BA[4E0A]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  2813                                  	;call	RPrint				; print it
  2814 00000623 E87000                  	call	RDISPMSG
  2815                                  
  2816                                  DEADINTHEWATER:
  2817 00000626 EBFE                    	jmp	short DEADINTHEWATER		; loop until the user reboots
  2818                                  
  2819                                  JUSTEXIT:
  2820                                  	;assume	ds:DATARES
  2821 00000628 A1[8E0A]                	mov	ax,[PARENT]			; load real parent pid
  2822 0000062B A31600                  	mov	[PDB.PARENT_PID],ax ; mov ds:16h,ax ; put it back where it belongs
  2823 0000062E B8FF4C                  	mov	ax,(EXIT<<8) | 255 ; 4CFFh
  2824 00000631 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  2825                                  				; AL = exit code
  2826                                  ABORTCONT:
  2827 00000633 F606[E40A]FF            	test	byte [IN_BATCH],-1		; Are we accessing a batch file?
  2828 00000638 7405                    	jz	short NOT_BATCH_ABORT
  2829 0000063A C606[E50A]01            	mov	byte [BATCH_ABORT],1		; set flag for abort
  2830                                  
  2831                                  NOT_BATCH_ABORT:
  2832 0000063F 8A16[5C0B]              	mov	dl,[PIPEFLAG]
  2833 00000643 E8B5FA                  	call	RESPIPEOFF
  2834 00000646 08D2                    	or	dl,dl
  2835 00000648 740D                    	je	short CHECKFORA
  2836 0000064A 833E[F50A]00            	cmp	word [SINGLECOM],0
  2837 0000064F 7406                    	je	short CHECKFORA
  2838 00000651 C706[F50A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2839                                  
  2840                                  CHECKFORA:
  2841 00000657 833E[940A]00            	cmp	word [ERRCD_24],0		; write protect?
  2842 0000065C 7407                    	je	short ABORTFOR
  2843 0000065E 833E[940A]02            	cmp	word [ERRCD_24],2		; drive not ready?
  2844 00000663 7512                    	jne	short EEXIT			; don't abort the FOR
  2845                                  
  2846                                  ABORTFOR:
  2847 00000665 C606[FB0A]00            	mov	byte [FORFLAG],0		; abort a FOR in progress
  2848 0000066A 833E[F50A]00            	cmp	word [SINGLECOM],0
  2849 0000066F 7406                    	je	short EEXIT
  2850 00000671 C706[F50A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2851                                  
  2852                                  EEXIT:
  2853 00000677 88E0                    	mov	al,ah
  2854 00000679 89FA                    	mov	dx,di
  2855                                  
  2856                                  RESTHD:
  2857 0000067B E88EFC                  	call    RESTHAND
  2858 0000067E 59                      	pop	cx
  2859 0000067F 5E                      	pop	si				; restore registers
  2860 00000680 07                      	pop	es
  2861                                  	
  2862                                  ;	; MSDOS 6.0
  2863                                  ;;;	pop	ds
  2864                                  ;;SR;
  2865                                  ;; ds has to be got from the variable we saved it in
  2866                                  ;;
  2867                                  ;
  2868                                  ; 	mov	ds,OldDS			;restore old value of ds
  2869                                  ;;	pop	ds
  2870                                  ;	assume	ds:nothing
  2871                                  
  2872                                  	; MSDOS 3.3
  2873 00000681 1F                      	pop	ds
  2874                                  
  2875 00000682 CF                      	iret
  2876                                  
  2877                                  FATERR:
  2878                                  	; MSDOS 6.0
  2879                                  	;mov	dx,offset DATARES:BadFatMsg
  2880                                  	;mov	si,offset DATARES:BadFatSubst
  2881                                  	;call	RPrint
  2882                                  
  2883                                  	; MSDOS 3.3
  2884 00000683 BA[D208]                	mov     dx,BADFATMSG
  2885 00000686 E80D00                  	call    RDISPMSG
  2886 00000689 BA[9208]                	mov     dx,BLKDEVERR
  2887 0000068C E80700                  	call    RDISPMSG
  2888                                  
  2889 0000068F B002                    	mov	al,2				; abort
  2890 00000691 EBE8                    	jmp	short RESTHD
  2891                                  
  2892                                  ;DskErr	endp
  2893                                  
  2894                                  	; MSDOS 6.0
  2895                                  ;***	RPrint - print message
  2896                                  ;***	Crlf - display cr/lf
  2897                                  ;
  2898                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  2899                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  2900                                  ;		variable fields related to substitution blocks are set
  2901                                  ;
  2902                                  ;	EXIT	nothing
  2903                                  ;
  2904                                  ;	USED	flags
  2905                                  ;
  2906                                  ;	EFFECTS
  2907                                  ;	  Message is displayed on stdout.
  2908                                  ;
  2909                                  ;	NOTE
  2910                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  2911                                  ;	    be greater than number of substition blocks present.
  2912                                  
  2913                                  ;
  2914                                  ;Crlf: 
  2915                                  ;	mov	dx,offset DATARES:Newlin	; cheap newline
  2916                                  ;
  2917                                  ;RPrint	proc
  2918                                  ;
  2919                                  ;	assume	ds:DATARES,ss:DATARES
  2920                                  ;
  2921                                  ;;	Bugbug:	do we need to save all reg's?
  2922                                  ;
  2923                                  ;	push	si			; preserve registers
  2924                                  ;	push	ax
  2925                                  ;	push	bx
  2926                                  ;	push	cx
  2927                                  ;	push	dx
  2928                                  ;
  2929                                  ;	mov	bx,si			; DS:BX = ptr to subst block
  2930                                  ;	mov	si,dx			; DS:SI = ptr to count byte
  2931                                  ;	lodsb				; AL = message length
  2932                                  ;					; DS:SI = ptr to message text
  2933                                  ;	xor	cx,cx
  2934                                  ;	mov	cl,al			; CX = message length
  2935                                  ;	jcxz	rpRet
  2936                                  ;
  2937                                  ;	call	RDispMsg
  2938                                  ;
  2939                                  ;rpRet:	pop	dx
  2940                                  ;	pop	cx
  2941                                  ;	pop	bx
  2942                                  ;	pop	ax
  2943                                  ;	pop	si
  2944                                  ;	ret
  2945                                  ;
  2946                                  ;RPrint	endp
  2947                                  
  2948                                  	; MSDOS 3.3
  2949                                  CRLF:
  2950 00000693 BA[9A08]                	mov     dx,NEWLIN
  2951                                  
  2952                                  RDISPMSG: ; Display message/text
  2953                                  	; DS:DX = ($ terminated) Message/Text address 
  2954 00000696 50                      	push    ax
  2955 00000697 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2956 00000699 F8                      	clc
  2957 0000069A CD21                    	int     21h             ; DOS - PRINT STRING
  2958                                  				; DS:DX -> string terminated by "$"
  2959 0000069C 58                      	pop     ax
  2960 0000069D C3                      	retn
  2961                                  
  2962                                  
  2963                                  	; MSDOS 6.0
  2964                                  
  2965                                  ;***	RPrintCrit - print critical error message
  2966                                  ;
  2967                                  ;	ENTRY	DX = extended error # (19-39)
  2968                                  ;
  2969                                  ;	EXIT	nothing
  2970                                  ;
  2971                                  ;	USED	flags
  2972                                  ;
  2973                                  ;	EFFECTS
  2974                                  ;	  Message is displayed on stdout
  2975                                  
  2976                                  ;RPrintCrit	proc
  2977                                  ;
  2978                                  ;	assume	ds:DATARES,ss:DATARES
  2979                                  ;
  2980                                  ;	push	dx			; preserve DX
  2981                                  ;	xchg	bx,dx			; BX = extended error #
  2982                                  ;					; DX = saved BX
  2983                                  ;	sub	bx,19			; BX = critical error index, from 0
  2984                                  ;	shl	bx,1			; BX = offset in word table
  2985                                  ;	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
  2986                                  ;	xchg	bx,dx			; DX = ptr to error msg
  2987                                  ;					; BX = restored
  2988                                  ;	call	RPrint			; print the message
  2989                                  ;	pop	dx			; restore DX
  2990                                  ;	ret
  2991                                  ;
  2992                                  ;RPrintCrit	endp
  2993                                  
  2994                                  
  2995                                  ;***	RDispMsg - display message
  2996                                  ;
  2997                                  ;	Display message, with substitutions, for RPrint.
  2998                                  ;
  2999                                  ;	ENTRY	DS:SI = ptr to message text
  3000                                  ;		CX = message length
  3001                                  ;		DS:BX = ptr to substitution block, if any
  3002                                  ;
  3003                                  ;	EXIT	nothing
  3004                                  ;
  3005                                  ;	USED	AX,CX,DX,SI
  3006                                  
  3007                                  ;RDispMsg	proc
  3008                                  ;
  3009                                  ;	assume	ds:DATARES,ss:DATARES
  3010                                  ;
  3011                                  ;rdNextChar:
  3012                                  ;	lodsb				; AL = next char
  3013                                  ;	cmp	al,'%'
  3014                                  ;	jne	rdOutChar		; not a substitution
  3015                                  ;	mov	dl,ds:[si]		; DL = possible '1' - '9'
  3016                                  ;	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  3017                                  ;	cmp	dl,9
  3018                                  ;	jae	rdOutChar		; not a substitution
  3019                                  ;
  3020                                  ;;*	A substitution code %1 - %9 has been encountered.
  3021                                  ;;	DL = 0-8, indicating %1-%9
  3022                                  ;;	DS:BX = ptr to substitution block
  3023                                  ;
  3024                                  ;	call	SubstMsg		; display the substitution
  3025                                  ;	inc	si			; SI = ptr past %n
  3026                                  ;	dec	cx			; count extra character in %n
  3027                                  ;	jmp	short rdCharDone
  3028                                  ;
  3029                                  ;;*	Normal character output.
  3030                                  ;
  3031                                  ;rdOutChar:
  3032                                  ;	mov	dl,al			; DL = char
  3033                                  ;	mov	ah,2			; AH = DOS Character Output code
  3034                                  ;	int	21h			; call DOS
  3035                                  ;rdCharDone:
  3036                                  ;	loop	rdNextChar
  3037                                  ;	ret
  3038                                  ;
  3039                                  ;RDispMsg	endp
  3040                                  
  3041                                  ;***	SubstMsg - display message substitution
  3042                                  ;
  3043                                  ;	Display a substitution string within a message.
  3044                                  ;	Substitution can be a char, an ASCIIZ string, or
  3045                                  ;	a word to be displayed as hex digits.
  3046                                  ;
  3047                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  3048                                  ;		DS:BX = ptr to substitution block
  3049                                  ;
  3050                                  ;	EXIT	nothing
  3051                                  ;
  3052                                  ;	USED	AX,DX
  3053                                  
  3054                                  ;SubstMsg	proc
  3055                                  ;
  3056                                  ;	assume	ds:DATARES,ss:DATARES
  3057                                  ;
  3058                                  ;	push	bx			; preserve BX
  3059                                  ;	push	cx			; preserve CX
  3060                                  ;
  3061                                  ;	mov	al,size SUBST		; AL = size of substitution block
  3062                                  ;	mul	dl			; AX = offset of desired subst block
  3063                                  ;	add	bx,ax			; DS:BX = ptr to desired subst block
  3064                                  ;
  3065                                  ;	mov	al,[bx].SubstType	; AX = substitution type flag
  3066                                  ;	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  3067                                  ;
  3068                                  ;;	AL = 1, 2, or 3 for char, string, or hex type
  3069                                  ;
  3070                                  ;	dec	al
  3071                                  ;	jz	smChar
  3072                                  ;	dec	al
  3073                                  ;	jz	smStr
  3074                                  ;
  3075                                  ;;*	Hex number substitution.
  3076                                  ;
  3077                                  ;	mov	ax,ds:[bx]		; AX = word value
  3078                                  ;	mov	cx,4			; CX = # digits to display
  3079                                  ;smDigit:
  3080                                  ;	rol	ax,1
  3081                                  ;	rol	ax,1
  3082                                  ;	rol	ax,1
  3083                                  ;	rol	ax,1			; AL<3:0> = next digit
  3084                                  ;
  3085                                  ;	push	ax			; save other digits
  3086                                  ;	and	al,0Fh			; AL = binary digit
  3087                                  ;	add	al,'0'			; AL = ascii digit if 0-9
  3088                                  ;	cmp	al,'9'
  3089                                  ;	jbe	@F			; it's 0-9
  3090                                  ;	add	al,'A' - '0' - 10	; AL = ascii digit A-F
  3091                                  ;@@:
  3092                                  ;	mov	dl,al			; DL = ascii digit
  3093                                  ;	mov	ah,2
  3094                                  ;	int	21h			; output the ascii digit
  3095                                  ;	pop	ax			; restore all digits
  3096                                  ;
  3097                                  ;	loop	smDigit
  3098                                  ;	jmp	short smRet
  3099                                  ;
  3100                                  ;;*	Char substitution.
  3101                                  ;
  3102                                  ;smChar:
  3103                                  ;	mov	dl,ds:[bx]		; DL = char to output
  3104                                  ;	mov	ah,2
  3105                                  ;	int	21h
  3106                                  ;	jmp	short smRet
  3107                                  ;
  3108                                  ;;*	String substitution.
  3109                                  ;
  3110                                  ;smStr:
  3111                                  ;	mov	dl,ds:[bx]		; DL = next char
  3112                                  ;	or	dl,dl
  3113                                  ;	jz	smRet			; null char - we're done
  3114                                  ;	mov	ah,2
  3115                                  ;	int	21h			; display char
  3116                                  ;	inc	bx			; DS:BX = ptr to next char
  3117                                  ;	jmp	smStr
  3118                                  ;
  3119                                  ;smRet:	pop	cx
  3120                                  ;	pop	bx
  3121                                  ;	ret
  3122                                  ;
  3123                                  ;SubstMsg	endp
  3124                                  
  3125                                  
  3126                                  	; MSDOS 6.0
  3127                                  
  3128                                  ;***	CharToUpper - convert character to uppercase
  3129                                  ;
  3130                                  ;	ENTRY	AL = char
  3131                                  ;
  3132                                  ;	EXIT	AL = uppercase char
  3133                                  ;
  3134                                  ;	USED	AX
  3135                                  
  3136                                  ;CharToUpper	proc
  3137                                  ;
  3138                                  ;	assume	ds:DATARES
  3139                                  ;
  3140                                  ;	push	ax		; put char on stack as arg to int 2F
  3141                                  ;	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  3142                                  ;	int	2Fh
  3143                                  ;	inc	sp		; throw away old char on stack
  3144                                  ;	inc	sp
  3145                                  ;	ret
  3146                                  ;
  3147                                  ;CharToUpper	endp
  3148                                  
  3149                                  	; MSDOS 3.3
  3150                                  CHARTOUPPER:
  3151 0000069E 3C80                    	cmp	al,80h
  3152 000006A0 7210                    	jb	short CHARTOUPPER1
  3153 000006A2 2C80                    	sub	al,80h
  3154 000006A4 1E                      	push	ds
  3155 000006A5 53                      	push	bx
  3156 000006A6 C51E[060B]              	lds	bx,[UPPERCASETBL]
  3157 000006AA 83C302                  	add	bx,2
  3158 000006AD D7                      	xlat
  3159 000006AE 5B                      	pop	bx
  3160 000006AF 1F                      	pop	ds
  3161 000006B0 EB0A                    	jmp	short CHARTOUPPER_RETN
  3162                                  CHARTOUPPER1:
  3163 000006B2 3C61                    	cmp	al,'a'
  3164 000006B4 7206                    	jb	short CHARTOUPPER_RETN
  3165 000006B6 3C7A                    	cmp	al,'z'
  3166 000006B8 7702                    	ja	short CHARTOUPPER_RETN
  3167 000006BA 2C20                    	sub	al,20h
  3168                                  CHARTOUPPER_RETN:
  3169 000006BC C3                      	retn
  3170                                  
  3171                                  ;public	EndCode
  3172                                  ;EndCode label	byte
  3173                                  
  3174                                  ;=============================================================================
  3175                                  ; RDATA.ASM, MSDOS 6.0, 1991
  3176                                  ;=============================================================================
  3177                                  ; 22/09/2018 - Retro DOS v3.0
  3178                                  
  3179                                  ;NOTE: This initialized rezident data is just as rezident data section/portion
  3180                                  ;      of the disassembled MSDOS 3.3 COMMAND.COM code.
  3181                                  ;   (MSDOS 6.0 RDATA.ASM is used for comments & descriptions about the RDATA.) 
  3182                                  
  3183                                  ; RDATA section of Retro DOS v2.0 'command2.s' (05/05/2018) has been modified 
  3184                                  ; for 'command3.s' (22/09/2018), here:
  3185                                  
  3186 000006BD 90                      ALIGN 2
  3187                                  	; 22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3188                                  RSTACK_SPACE:
  3189 000006BE 00<rep 80h>             	times 128 db 0
  3190                                  RSTACK:
  3191 0000073E 0000                    	dw 	0
  3192                                  
  3193                                  	; 25/09/2018	
  3194                                  	; (filler)
  3195 00000740 0000                    	dW	0
  3196                                  
  3197                                  RDATA	EQU	$
  3198                                  
  3199                                  ;TITLE   COMMAND Resident DATA
  3200                                  
  3201                                  ; Data for resident portion
  3202                                  
  3203                                  ;DATARES SEGMENT PUBLIC BYTE
  3204                                  
  3205                                  	;ORG     0
  3206                                  ;ZERO    =       $
  3207                                  
  3208                                  CRMSGTBL:
  3209 00000742 [6607]                  	dw	CRMSG0		; "Write protect$"
  3210 00000744 [7407]                  	dw	CRMSG1		; "Bad unit$"
  3211 00000746 [7D07]                  	dw	CRMSG2		; "Not ready$"
  3212 00000748 [8707]                  	dw	CRMSG3		; "Bad command $"
  3213 0000074A [9407]                  	dw	CRMSG4		; "Data$"
  3214 0000074C [9907]                  	dw	CRMSG5		; "Bad call format$"
  3215 0000074E [A907]                  	dw	CRMSG6		; "Seek$"
  3216 00000750 [AE07]                  	dw	CRMSG7		; "Non-DOS disk$"
  3217 00000752 [BB07]                  	dw	CRMSG8		; "Sector not found$"
  3218 00000754 [CC07]                  	dw	CRMSG9		; "No paper$"
  3219 00000756 [D507]                  	dw	CRMSG10		; "Write fault$"
  3220 00000758 [E107]                  	dw	CRMSG11		; "Read fault$"
  3221 0000075A [EC07]                  	dw	CRMSG12		; "General Failure$"
  3222 0000075C [FC07]                  	dw	CRMSG13		; "Sharing Violation$"
  3223 0000075E [0E08]                  	dw	CRMSG14		; "Lock Violation$"
  3224 00000760 [1D08]                  	dw	CRMSG15		; "Invalid Disk Change$"
  3225 00000762 [3108]                  	dw	CRMSG16		; "FCB unavailable$"
  3226 00000764 [4108]                  	dw	CRMSG17		; "Sharing buffer exceeded$"
  3227                                  
  3228 00000766 57726974652070726F-     CRMSG0:	 db 'Write protect$'
  3228 0000076F 7465637424         
  3229 00000774 42616420756E697424      CRMSG1:	 db 'Bad unit$'
  3230 0000077D 4E6F74207265616479-     CRMSG2:	 db 'Not ready$'
  3230 00000786 24                 
  3231 00000787 42616420636F6D6D61-     CRMSG3:	 db 'Bad command $'
  3231 00000790 6E642024           
  3232 00000794 4461746124              CRMSG4:	 db 'Data$'
  3233 00000799 4261642063616C6C20-     CRMSG5:	 db 'Bad call format$'
  3233 000007A2 666F726D617424     
  3234 000007A9 5365656B24              CRMSG6:	 db 'Seek$'
  3235 000007AE 4E6F6E2D444F532064-     CRMSG7:	 db 'Non-DOS disk$'
  3235 000007B7 69736B24           
  3236 000007BB 536563746F72206E6F-     CRMSG8:	 db 'Sector not found$'
  3236 000007C4 7420666F756E6424   
  3237 000007CC 4E6F20706170657224      CRMSG9:	 db 'No paper$'
  3238 000007D5 577269746520666175-     CRMSG10: db 'Write fault$'
  3238 000007DE 6C7424             
  3239 000007E1 52656164206661756C-     CRMSG11: db 'Read fault$'
  3239 000007EA 7424               
  3240 000007EC 47656E6572616C2046-     CRMSG12: db 'General Failure$'
  3240 000007F5 61696C75726524     
  3241 000007FC 53686172696E672056-     CRMSG13: db 'Sharing Violation$'
  3241 00000805 696F6C6174696F6E24 
  3242 0000080E 4C6F636B2056696F6C-     CRMSG14: db 'Lock Violation$'
  3242 00000817 6174696F6E24       
  3243 0000081D 496E76616C69642044-     CRMSG15: db 'Invalid Disk Change$'
  3243 00000826 69736B204368616E67-
  3243 0000082F 6524               
  3244 00000831 46434220756E617661-     CRMSG16: db 'FCB unavailable$'
  3244 0000083A 696C61626C6524     
  3245 00000841 53686172696E672062-     CRMSG17: db 'Sharing buffer exceeded$'
  3245 0000084A 756666657220657863-
  3245 00000853 656564656424       
  3246                                  
  3247 00000859 506C6561736520496E-     NEEDVOLMSG:	db 'Please Insert disk '
  3247 00000862 73657274206469736B-
  3247 0000086B 20                 
  3248 0000086C 00<rep Bh>              VOLNAME: times 11 db 0	; db 0Bh dup(0)
  3249 00000877 0D0A24                  		db 0Dh,0Ah,'$'
  3250 0000087A 72656164696E6724        MREAD:		db 'reading$'
  3251 00000882 77726974696E6724        MWRITE:		db 'writing$'
  3252 0000088A 206572726F722024        ERRMES:		db ' error $'
  3253 00000892 20647269766520          BLKDEVERR:	db ' drive '
  3254 00000899 41                      DRVLET:		db 'A'
  3255 0000089A 0D0A24                  NEWLIN:		db 0Dh,0Ah,'$'
  3256 0000089D 2064657669636520        CHARDEVERR:	db ' device '
  3257 000008A5 00<rep 8h>              DEVNAME: times 8 db 0 ; db 8 dup(0)
  3258 000008AD 0D0A24                  		db 0Dh,0Ah,'$'
  3259 000008B0 41626F727424            REQ_ABORT:	db 'Abort$'
  3260 000008B6 2C20526574727924        REQ_RETRY:	db ', Retry$'
  3261 000008BE 2C2049676E6F726524      REQ_IGNORE:	db ', Ignore$'
  3262 000008C7 2C204661696C24          REQ_FAIL:	db ', Fail$'
  3263 000008CE 3F2024                  REQ_END:	db '? $'
  3264 000008D1 00                      CDEVAT:		db 0
  3265 000008D2 0D0A46696C6520616C-     BADFATMSG:	db 0Dh,0Ah,'File allocation table bad,$'
  3265 000008DB 6C6F636174696F6E20-
  3265 000008E4 7461626C6520626164-
  3265 000008ED 2C24               
  3266 000008EF 0D0A496E76616C6964-     COMBAD:		db 0Dh,0Ah,'Invalid COMMAND.COM',0Dh,0Ah,'$'
  3266 000008F8 20434F4D4D414E442E-
  3266 00000901 434F4D0D0A24       
  3267 00000907 496E73657274206469-     PUTBACKMSG:	db 'Insert disk with $'
  3267 00000910 736B20776974682024 
  3268 00000919 20696E206472697665-     PROMPT:		db ' in drive '
  3268 00000922 20                 
  3269 00000923 200D0A616E64207374-     PUTBACKDRV:	db ' ',0Dh,0Ah, 'and strike any key when ready',0Dh,0Ah,'$'
  3269 0000092C 72696B6520616E7920-
  3269 00000935 6B6579207768656E20-
  3269 0000093E 72656164790D0A24   
  3270 00000946 0D0A5465726D696E61-     ENDBATMES:	db 0Dh,0Ah,'Terminate batch job (Y/N)? $'
  3270 0000094F 746520626174636820-
  3270 00000958 6A6F622028592F4E29-
  3270 00000961 3F2024             
  3271 00000964 45584543206661696C-     EXECEMES:	db 'EXEC failure',0Dh,0Ah,'$'
  3271 0000096D 7572650D0A24       
  3272 00000973 4572726F7220696E20-     EXEBAD:		db 'Error in EXE file',0Dh,0Ah,'$'
  3272 0000097C 4558452066696C650D-
  3272 00000985 0A24               
  3273 00000987 50726F6772616D2074-     TOOBIG:		db 'Program too big to fit in memory',0Dh,0Ah,'$'
  3273 00000990 6F6F2062696720746F-
  3273 00000999 2066697420696E206D-
  3273 000009A2 656D6F72790D0A24   
  3274 000009AA 0D0A4E6F2066726565-     NOHANDMES:	db 0Dh,0Ah,'No free file handles$'
  3274 000009B3 2066696C652068616E-
  3274 000009BC 646C657324         
  3275 000009C1 42616420436F6D6D61-     RBADNAM:	db 'Bad Command or file name',0Dh,0Ah,'$'
  3275 000009CA 6E64206F722066696C-
  3275 000009D3 65206E616D650D0A24 
  3276 000009DC 416363657373206465-     ACCDEN:		db 'Access denied',0Dh,0Ah,'$'
  3276 000009E5 6E6965640D0A24     
  3277 000009EC 0D0A4D656D6F727920-     BMEMMES:	db 0Dh,0Ah,'Memory allocation error $'
  3277 000009F5 616C6C6F636174696F-
  3277 000009FE 6E206572726F722024 
  3278 00000A07 0D0A43616E6E6F7420-     HALTMES:	db 0Dh,0Ah,'Cannot load COMMAND, system halted$'
  3278 00000A10 6C6F616420434F4D4D-
  3278 00000A19 414E442C2073797374-
  3278 00000A22 656D2068616C746564-
  3278 00000A2B 24                 
  3279 00000A2C 0D0A43616E6E6F7420-     FRETMES:	db 0Dh,0Ah,'Cannot start COMMAND, exiting',0Dh,0Ah,'$'
  3279 00000A35 737461727420434F4D-
  3279 00000A3E 4D414E442C20657869-
  3279 00000A47 74696E670D0A24     
  3280 00000A4E 0D0A546F70206C6576-     PATRICIDE:	db 0Dh,0Ah,'Top level process aborted, cannot continue. $'
  3280 00000A57 656C2070726F636573-
  3280 00000A60 732061626F72746564-
  3280 00000A69 2C2063616E6E6F7420-
  3280 00000A72 636F6E74696E75652E-
  3280 00000A7B 2024               
  3281 00000A7D 59                      YES_CHAR:	db 'Y'
  3282 00000A7E 4E                      NO_CHAR:	db 'N'
  3283 00000A7F 52                      RETRY_CHAR:	db 'R'
  3284 00000A80 41                      ABORT_CHAR:	db 'A'
  3285 00000A81 49                      IGNORE_CHAR:	db 'I'
  3286 00000A82 46                      FAIL_CHAR:	db 'F'
  3287 00000A83 00000000                NEEDVOL:	dd 0
  3288 00000A87 00                      ERRTYPE:	db 0
  3289                                  
  3290                                  ; 22/09/2018 -  22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3291                                  
  3292                                  RETRABASE: ; 30/04/2018 (Base addr for common params, for transient portion)
  3293                                  	   ; Note: Order of following parameters must not be changed
  3294                                  	   ; without changing address references of them in 'transcom.s').	
  3295                                  
  3296 00000A88 00000000                INT_2E_RET:	DD 0		; Magic command executer return address
  3297 00000A8C 0000                    SAVE_PDB:	DW 0
  3298 00000A8E 0000                    PARENT:		DW 0
  3299 00000A90 00000000                OLDTERM:	dd 0
  3300 00000A94 0000                    ERRCD_24:	DW 0
  3301 00000A96 0000                    HANDLE01:	DW 0
  3302 00000A98 00                      LOADING:	DB 0
  3303 00000A99 0000                    BATCH:		DW 0		; Assume no batch mode initially
  3304                                  
  3305                                  ;		Bugbug:	ComSpec should be 64+3+12+1?
  3306                                  ;		What's this comspec_end about?
  3307 00000A9B 00<rep 40h>             COMSPEC: times 64 DB 0
  3308 00000ADB 0000                    PUTBACKSUBSTPTR: dw 0
  3309 00000ADD 0000                    COMSPEC_END:	dw 0
  3310 00000ADF 2C01                    TRANS:		DW COMMAND
  3311 00000AE1 0000                    TRNSEG:		DW 0
  3312 00000AE3 00                      TRNMVFLG:	db 0		; set if transient portion has been moved
  3313 00000AE4 00                      IN_BATCH:	db 0		; set if we are in batch processing mode
  3314 00000AE5 00                      BATCH_ABORT:	db 0		; set if user wants to abort from batch mode
  3315                                  
  3316 00000AE6 00                      COMDRV:		DB 0		; DRIVE SPEC TO LOAD AUTOEXEC AND COMMAND
  3317 00000AE7 0000                    MEMSIZ:		DW 0
  3318 00000AE9 0000                    SUM:		DW 0
  3319 00000AEB 01                      EXTCOM:		DB 1		; For init, pretend just did an external
  3320 00000AEC 0000                    RETCODE:	DW 0
  3321 00000AEE 00                      CRIT_ERR_INFO:	db 0		; hold critical error flags for r,i,f
  3322                                  
  3323                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  3324                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  3325                                  
  3326 00000AEF 01                      ECHOFLAG:	DB 1		; low bit true => echo commands
  3327 00000AF0 01                      SUPPRESS:	db 1		; used for echo, 1=echo line
  3328 00000AF1 0000                    IO_SAVE:	DW 0
  3329 00000AF3 00                      RESTDIR:	DB 0
  3330 00000AF4 00                      PERMCOM:	DB 0		; true => permanent command
  3331 00000AF5 0000                    SINGLECOM:	DW 0		; true => single command version
  3332 00000AF7 FFFF                    VERVAL:	        DW -1
  3333 00000AF9 00                      FFAIL:		db 0		; true => fail all int 24s
  3334 00000AFA 00                      IFFLAG:		db 0            ; true => IF statement in progress
  3335 00000AFB 00                      FORFLAG:	DB 0		; true => FOR statement in progress
  3336 00000AFC 0000                    FORPTR:		dw 0		
  3337 00000AFE 0000                    NEST:		dw 0		; nested batch file counter
  3338 00000B00 00                      CALL_FLAG:	db 0		; no CALL (batch command) in progress
  3339 00000B01 00                      CALL_BATCH_FLAG: db 0
  3340 00000B02 0000                    NEXT_BATCH:	dw 0		; address of next batch segment
  3341 00000B04 00                      NULLFLAG:	db 0		; flag if no command on command line
  3342                                  
  3343 00000B05 00                      UCASE_ADDR:	db 0
  3344 00000B06 00000000                UPPERCASETBL:	dd 0
  3345                                  
  3346 00000B0A 00                      RE_OUT_APP:	db 0
  3347 00000B0B 00<rep 50h>             RE_OUTSTR: times (64+3+13) db 0
  3348                                  
  3349 00000B5B 01                      INITFLAG:	DB INITINIT ; 1 ; 24/09/2018
  3350                                  
  3351                                  ; Note:  these two bytes are referenced as a word
  3352 00000B5C 00                      PIPEFLAG:	DB 0
  3353 00000B5D 00                      PIPEFILES:	DB 0
  3354                                  
  3355                                  ;--- 2.x data for piping
  3356                                  ;
  3357                                  ; All the "_" are substituted later, the one before the : is substituted
  3358                                  ; by the current drive, and the others by the CreateTemp call with the
  3359                                  ; unique file name. Note that the first 0 is the first char of the pipe
  3360                                  ; name. -MU
  3361                                  ;
  3362                                  ;--- Order-dependent, do not change
  3363                                  
  3364                                  ; MSDOS 3.3
  3365                                  
  3366 00000B5E 5F3A2F                  PIPE1:		db "_:/"
  3367 00000B61 00                      PIPE1T:		db 0
  3368 00000B62 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3368 00000B6B 5F5F00             
  3369 00000B6E 5F3A2F                  PIPE2:		db "_:/"
  3370 00000B71 00                      PIPE2T		db 0
  3371 00000B72 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3371 00000B7B 5F5F00             
  3372                                  
  3373                                  ; MSDOS 3.3 & MSDOS 6.0
  3374 00000B7E 0000                    PIPEPTR:	dw 0
  3375 00000B80 00<rep 81h>             PIPESTR: times 129 db 0
  3376                                  
  3377                                  ; MSDOS 6.0
  3378                                  
  3379                                  ;SR
  3380                                  ; Pipe1 & Pipe2 now need to store full-fledged pathnames
  3381                                  ;
  3382                                  
  3383                                  ; Bugbug:  can we find any way around maintaining these
  3384                                  ; large buffers?
  3385                                  
  3386                                  ;Pipe1		db	67+12 dup (?)
  3387                                  ;Pipe2		db	67+12 dup (?)
  3388                                  ;PipePtr 	dw	?
  3389                                  ;PipeStr 	db	129 dup (?)
  3390                                  
  3391                                  ;EndPipe	label	byte	; marks end of buffers; M004
  3392                                  
  3393 00000C01 [5E0B]                  INPIPEPTR:	dw PIPE1
  3394 00000C03 [6E0B]                  OUTPIPEPTR:	dw PIPE2
  3395                                  
  3396                                  ;EXEC_BLOCK LABEL BYTE		; The data block for EXEC calls
  3397                                  EXEC_BLOCK:
  3398 00000C05 0000                    ENVIRSEG:	DW 0
  3399                                  ;COM_PTR LABEL	DWORD
  3400 00000C07 8000                    COM_PTR:	DW 80H		; Point at unformatted parameters
  3401 00000C09 0000                    		DW 0
  3402                                  ;COM_FCB1 LABEL	DWORD
  3403 00000C0B 5C00                    COM_FCB1:      	DW 5CH
  3404 00000C0D 0000                            	DW 0
  3405                                  ;COM_FCB2 LABEL	DWORD
  3406 00000C0F 6C00                    COM_FCB2:	DW 6CH
  3407 00000C11 0000                            	DW 0
  3408                                  
  3409                                  ;TRANVARS LABEL  BYTE		; Variables passed to transient
  3410                                  TRANVARS:
  3411                                  		;DW OFFSET RESGROUP:THEADFIX
  3412 00000C13 [AF02]                  		DW THEADFIX
  3413 00000C15 0000                    MYSEG:		DW 0		; Put our own segment here
  3414 00000C17 0000                    LTPA:		DW 0		; WILL STORE TPA SEGMENT HERE
  3415 00000C19 2D                      RSWITCHAR:	DB "-"
  3416 00000C1A 2F                      RDIRCHAR:	DB "/"
  3417                                          	;DW OFFSET RESGROUP:EXT_EXEC
  3418 00000C1B [2D00]                  		DW EXT_EXEC
  3419 00000C1D 0000                    MYSEG1:		DW 0
  3420                                  		;DW OFFSET RESGROUP:TREMCHECK
  3421 00000C1F [9402]                  		DW TREMCHECK
  3422 00000C21 0000                    MYSEG2:		DW 0
  3423                                  
  3424 00000C23 0000                    RESTEST:	dw 0
  3425 00000C25 0000                    RES_TPA:	DW 0		; original tpa (not rounded to 64k)
  3426                                  ;TRANVAREND	label	byte
  3427                                  TRANVAREND:
  3428 00000C27 0000                    OLDERRNO:	dw 0
  3429                                  
  3430                                  		; Here is Offset 0D27h in original MSDOS 3.3 COMMAND.COM
  3431                                  
  3432                                  ;DATARESEND	LABEL   BYTE
  3433                                  DATARESEND:
  3434                                  		; 22/09/2018
  3435                                  
  3436                                  ;DATARES ENDS
  3437                                  ;        END
  3438                                  
  3439                                  ;=============================================================================
  3440                                  ; COMMAND.ASM (MSDOS 2.11), ENVDATA.ASM (MSDOS 6.0)
  3441                                  ;=============================================================================
  3442                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3443                                  
  3444 00000C29 90<rep 7h>              align 16
  3445                                  
  3446                                  	; Here is Offset 0D80h in original MSDOS 3.3 COMMAND.COM
  3447                                  
  3448                                  ;ENVIRONMENT SEGMENT PUBLIC PARA        ; Default COMMAND environment
  3449                                  
  3450                                  ;	PUBLIC  ECOMSPEC,ENVIREND,PATHSTRING
  3451                                  
  3452                                          ;ORG	0
  3453                                  ;ENVARENA	DB 10H DUP (?)	; Pad for mem arena
  3454 00000C30 00<rep 10h>             ENVARENA:	TIMES 16 DB 0		
  3455                                  ENVIRONMENT:			; 30/04/2018 ('command2.s')
  3456                                  	; Here is Offset 0D90h in original MSDOS 3.3 COMMAND.COM
  3457 00000C40 504154483D              PATHSTRING:	DB "PATH="
  3458                                  ;USERPATH LABEL  BYTE
  3459 00000C45 00                      USERPATH:      	DB 0		; Null path
  3460 00000C46 434F4D535045433D                	DB "COMSPEC="
  3461 00000C4E 2F434F4D4D414E442E-     ECOMSPEC:	DB "/COMMAND.COM"
  3461 00000C57 434F4D             
  3462                                          	;DB 134 DUP (0)
  3463 00000C5A 00<rep 86h>             		TIMES	134 DB 0
  3464                                  
  3465                                  ;ENVIREND	LABEL   BYTE
  3466                                  ENVIREND:
  3467                                  	; Here is Offset 0E30h in original MSDOS 3.3 COMMAND.COM
  3468                                  	
  3469                                  ENVIRONSIZ EQU  $-PATHSTRING	; 160 = 0A0h
  3470                                  ENVIRONSIZ2 EQU $-ECOMSPEC	; 146 = 092h
  3471                                  
  3472                                  ;ENVIRONMENT ENDS
  3473                                  
  3474                                  ; ENVDATA.ASM
  3475                                  ;
  3476                                  ;/*
  3477                                  ; *                      Microsoft Confidential
  3478                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3479                                  ; *                      All Rights Reserved.
  3480                                  ; */
  3481                                  ;	SCCSID = @(#)envdata.asm	1.1 85/05/14
  3482                                  ;
  3483                                  ; This file is included by init.asm and is used as the default environment.
  3484                                  ;
  3485                                  ;
  3486                                  ;Environment Struc                       ; Default COMMAND environment
  3487                                  ;
  3488                                  ;Env_PathString  db	"path="
  3489                                  ;Env_PathSpec    db     "c:\msdos"
  3490                                  ;                db     0
  3491                                  ;Env_PrmptString db     "prompt="
  3492                                  ;Env_PrmptSpec   db     "$p$g"
  3493                                  ;                db     0
  3494                                  ;Env_ComString   db     "comspec="
  3495                                  ;Env_ComSpec     db     "\command.com"
  3496                                  ;		 db	134 dup (0)
  3497                                  ;
  3498                                  ;Environment ends
  3499                                  
  3500                                  ;MAX_COMSPEC	equ     SIZE Environment - Env_ComSpec
  3501                                  
  3502                                  MAX_COMSPEC	EQU	ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3503                                  
  3504                                  ;-----------------------------------------------------------------------------
  3505                                  ; 24/09/2018 - RetRo DOS v3.0
  3506                                  ;ENDCODE:
  3507                                  INITSTART:	; End of rezident code and data
  3508                                  		; (Offset 0E30h in original MSDOS 3.3 COMMAND.COM)
  3509                                  ;-----------------------------------------------------------------------------
  3510                                  
  3511                                  ;=============================================================================
  3512                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  3513                                  ;=============================================================================
  3514                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3515                                  
  3516                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  3517                                  
  3518                                  ;TITLE   COMMAND Initialization
  3519                                  
  3520                                  ;ENVIRONSIZ EQU  0A0H		;Must agree with values in ENVIRONMENT segment
  3521                                  ;ENVIRONSIZ2 EQU 092H
  3522                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3523                                  
  3524                                  ; UINIT.ASM, MSDOS 6.0, 1991
  3525                                  ; 23/09/2018
  3526                                  ENVBIG	EQU	32768			;AN000; maximum environment size
  3527                                  ENVSML	EQU	160			;AN000; minimum environment size
  3528                                  
  3529                                  ;-----------------------------------------------------------------------------
  3530                                  ; START OF INIT PORTION
  3531                                  ; This code is deallocated after initialization.
  3532                                  ;-----------------------------------------------------------------------------
  3533                                  
  3534                                  ;INIT    SEGMENT PUBLIC PARA
  3535                                  
  3536                                  ; 	EXTRN   HEADER:BYTE
  3537                                  ;	EXTRN   BADCOMLKMES:BYTE
  3538                                  
  3539                                  ;	PUBLIC  CONPROC
  3540                                  
  3541                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  3542                                  
  3543                                          ;ORG 0
  3544                                  ;ZERO = $
  3545                                  	; 23/09/2018
  3546                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  3547                                  
  3548                                  CONPROC:
  3549                                  	;MOV	SP,OFFSET RESGROUP:RSTACK	; must be first instruction
  3550 00000CE0 BC[3E07]                	MOV	SP,RSTACK
  3551                                  ;
  3552                                  ; We need to set the PSP to us right at start because Carousel needs
  3553                                  ; to be lied to and it does not set PSP when it transfers control to
  3554                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  3555                                  ; command.com is also not lied to.
  3556                                  ;
  3557                                  	; MSDOS 6.0
  3558                                          ;mov     ah,SET_CURRENT_PDB
  3559                                          ;mov     bx,es
  3560                                          ;int     21h
  3561                                  
  3562 00000CE3 B80030                          mov     ax,GET_VERSION<<8 ; 30h
  3563 00000CE6 CD21                    	int	21h
  3564 00000CE8 3D031E                  	cmp	ax,EXPECTED_VERSION ; 1E03h
  3565 00000CEB 7412                    	je	short OKDOS			; DOS version is ok
  3566                                  
  3567 00000CED BA[7314]                	mov	dx,BADVERMSG			; DX = ptr to msg
  3568                                  	;call	RPrint
  3569                                  
  3570                                  	; MSDOS 3.3
  3571 00000CF0 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  3572 00000CF2 CD21                    	int	21h             ; DOS - PRINT STRING
  3573                                  				; DS:DX -> string terminated by "$"
  3574 00000CF4 8CC0                    	mov	ax,es
  3575 00000CF6 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  3576                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  3577 00000CFB 74FE                    HERE:	jz	short HERE			;  loop forever
  3578                                  	
  3579 00000CFD CD20                    	int	20h				; otherwise, exit
  3580                                  OKDOS:
  3581                                  	; 23/09/2018
  3582                                  ;
  3583                                  ;  Calculate and save the end of the INIT segment (which is also
  3584                                  ;  the beginning of TRANGROUP).
  3585                                  ;
  3586                                  	; MSDOS 3.3
  3587 00000CFF B465                    	mov	ah,65h
  3588 00000D01 B002                    	mov	al,2
  3589 00000D03 BAFFFF                  	mov	dx,-1
  3590 00000D06 BBFFFF                  	mov	bx,-1
  3591 00000D09 B90500                  	mov	cx,5
  3592 00000D0C BF[050B]                	mov	di,UCASE_ADDR
  3593 00000D0F CD21                    	int     21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  3594                                  			; AL = 02h : Get pointer to character translation table
  3595                                  			; BX = code page (-1 = current global code page)
  3596                                  			; DX = country ID (-1 = current country)
  3597                                  			; CX = amount of data to return
  3598                                  	; ES:DI = pointer to output buffer
  3599                                  	; Buffer offset :
  3600                                  	;	00h -  byte,  country Id
  3601                                  	;  	01h -  dword, pointer to uppercase table	
  3602                                  
  3603                                  	; MSDOS 6.0 (& MSDOS 3.3)
  3604 00000D11 BA[5F15]                  	mov	dx,TRANSTART+15			; get end of init code
  3605                                  	; 27/09/2018
  3606                                          ;mov	dx,TRANSTART ; (paragraph aligned address)
  3607 00000D14 B104                    	mov	cl,4				; change to paragraphs
  3608 00000D16 D3EA                            shr	dx,cl				;
  3609 00000D18 8CC8                            mov     ax,cs                           ; get current segment
  3610 00000D1A 01D0                            add     ax,dx                           ; calculate segment of end of init
  3611 00000D1C A3[0915]                        mov     [INITEND],ax			; save this
  3612                                  
  3613 00000D1F A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h ; Init PARENT so we can exit
  3614 00000D22 A3[8E0A]                	mov	[PARENT],ax			    ;  correctly.
  3615 00000D25 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  3616 00000D28 A3[900A]                	mov	[OLDTERM],ax
  3617 00000D2B A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  3618 00000D2E A3[920A]                	mov	[OLDTERM+2],ax
  3619                                  
  3620                                  	;mov	ax,ENDCODE+15
  3621 00000D31 B8[EF0C]                	mov	ax,INITSTART+15 ; 24/09/2018
  3622 00000D34 B104                    	mov	cl,4				; ax = size of resident part of
  3623 00000D36 D3E8                    	shr	ax,cl				;  command in paragraphs. Add
  3624 00000D38 8CC9                    	mov	cx,cs				;  this to CS and you get the
  3625 00000D3A 01C8                    	add	ax,cx				;  segment of the TPA.
  3626                                  	
  3627 00000D3C A3[250C]                	mov     [RES_TPA],ax			; Temporarily save the TPA segment
  3628 00000D3F 2500F0                  	and     ax,0F000h
  3629 00000D42 050010                  	add     ax,1000h			; Round up to next 64K boundary
  3630 00000D45 7303                    	jnc     short TPA_SET			; Memory wrap if carry set
  3631 00000D47 A1[250C]                	mov     ax,[RES_TPA]
  3632                                  TPA_SET:
  3633 00000D4A A3[170C]                	mov	[LTPA],ax			; Good enough for the moment
  3634 00000D4D A10200                  	mov	ax,[PDB.BLOCK_LEN] ; mov ax,ds:2 ; ax = # of paras given to command
  3635                                  
  3636 00000D50 8C1E[1D0C]              	mov	[MYSEG1],ds			; These 3 variables are used as part of
  3637 00000D54 8C1E[210C]              	mov	[MYSEG2],ds			;  3 long ptrs that the transient will
  3638 00000D58 8C1E[150C]              	mov	[MYSEG],ds			;  use to call resident routines.
  3639                                  
  3640 00000D5C A3[E70A]                        mov     [MEMSIZ],ax			; Needed for execing other programs
  3641                                  ;
  3642                                  ; Compute maximum size of environment
  3643                                  ;
  3644                                  	;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  3645 00000D5F C706[0315]4500                  mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  3646                                  ;
  3647                                  ; Compute minimum size of environment
  3648                                  ;
  3649                                  	;mov	word [ENVSIZ],10 ; = 160/16
  3650 00000D65 C706[0115]0A00          	mov	word [ENVSIZ],ENVSML/16; 
  3651                                  
  3652                                  	;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  3653 00000D6B BA8B4C                  	mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  3654 00000D6E B104                    	mov	cl,4				;  in paragraphs.
  3655 00000D70 D3EA                    	shr	dx,cl
  3656 00000D72 8916[0B15]                      mov     [TRNSIZE],dx			; save size of transient in paragraphs
  3657                                  
  3658 00000D76 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  3659 00000D78 A3[E10A]                	mov	[TRNSEG],ax			;  = seg addr to load the transient at.
  3660 00000D7B A12C00                  	mov	ax,[PDB.ENVIRON] ; mov ax,ds:2Ch ; ax = environment segment
  3661                                  
  3662                                          ; MSDOS 6.0
  3663                                  	;mov	EnvirSeg,ax			;
  3664                                          ;or	ax,ax				; if there is no environment segment,
  3665                                          ;jz	buildenv			; make one
  3666                                  	;
  3667                                          ;cmp	FirstCom,0			; if this is the first command.com,
  3668                                  	;je	environpassed			; do a merge job (make sure COMSPEC exists)
  3669                                  
  3670                                  	; MSDOS 3.3
  3671 00000D7E 09C0                    	or	ax,ax
  3672 00000D80 7406                    	jz	short BUILDENV
  3673 00000D82 FE06[EC14]                      inc	byte [CHUCKENV]			; Flag no ENVIRONSEG
  3674 00000D86 EB0B                            jmp	short ENVIRONPASSED
  3675                                  
  3676                                  	; MSDOS 6.0
  3677                                  ;
  3678                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  3679                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  3680                                  ; size and free this buffer. We need this buffer because we no longer have an
  3681                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  3682                                  ; given on the command line before we know the environment size. This routine
  3683                                  ; will not return in case of an allocation error. It will either exit or hang
  3684                                  ; depending on whether or not this is the first COMMAND.COM or not.
  3685                                  ;
  3686                                  ;buildenv:
  3687                                  ;	call	alloc_env                       ; try to allocate buffer
  3688                                  ;environpassed:
  3689                                  ;	mov	es,ax                           ; and it load into es.
  3690                                  ;	assume	es:nothing
  3691                                  ;
  3692                                  ;gottheenvir:
  3693                                  ;;
  3694                                  ;; Initialize the command drive
  3695                                  ;;
  3696                                  	; MSDOS 3.3
  3697                                  BUILDENV:
  3698                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  3699 00000D88 B8[400C]                	mov	ax,PATHSTRING ; "PATH="
  3700 00000D8B B104                    	mov	cl,4
  3701 00000D8D D3E8                    	shr	ax,cl
  3702 00000D8F 8CDA                    	mov	dx,ds
  3703 00000D91 01D0                    	add	ax,dx
  3704                                  
  3705                                  ENVIRONPASSED:
  3706 00000D93 A3[050C]                	mov	[ENVIRSEG],ax
  3707                                  
  3708 00000D96 8EC0                    	mov	es,ax
  3709                                  
  3710                                  	;mov	ax,CHAR_OPER<<8
  3711 00000D98 B80037                  	mov	ax,CHAR_OPER*256 ; 3700h
  3712 00000D9B CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3713                                  			; Return: AL = FFh unsupported subfunction
  3714                                  			; DL = current switch character
  3715 00000D9D 8816[190C]              	mov	[RSWITCHAR],dl
  3716                                  
  3717                                  	;CMP	dl,'/'
  3718 00000DA1 3A16[FA14]              	cmp	dl,[slash_chr]
  3719 00000DA5 7511                    	jnz	short IUSESLASH
  3720                                  
  3721                                  	;mov	al,'\'
  3722 00000DA7 A0[FB14]                	mov	al,[bslash_chr]
  3723 00000DAA A2[C114]                	mov	[COMSPECT],al
  3724                                  
  3725 00000DAD 803E[EC14]00            	cmp	byte [CHUCKENV],0
  3726 00000DB2 7504                    	jnz	short IUSESLASH
  3727                                  
  3728                                  	;mov	ES:[ECOMSPEC-10h],'\'
  3729                                  	; 30/04/2018
  3730                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  3731                                  	; 23/09/2018
  3732 00000DB4 26A20E00                	mov	[ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  3733                                  
  3734                                  ;gottheenvir:
  3735                                  IUSESLASH:
  3736                                  ;
  3737                                  ; Initialize the command drive
  3738                                  ;
  3739                                  	; MSDOS 3.3 & MSDOS 6.0
  3740 00000DB8 B419                    	mov	ah,GET_DEFAULT_DRIVE	; 19h
  3741 00000DBA CD21                    	int	21h
  3742 00000DBC FEC0                    	inc	al
  3743 00000DBE A2[E60A]                	mov	[COMDRV],al
  3744                                  
  3745                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  3746 00000DC1 A05C00                          mov	al,[FCB]
  3747 00000DC4 08C0                    	or	al,al
  3748 00000DC6 7426                    	jz	short NOCOMDRV		; no drive specified
  3749                                  
  3750 00000DC8 B43A                    	mov	ah,':'
  3751 00000DCA A2[E60A]                	mov	[COMDRV],al
  3752 00000DCD 0440                    	add	al,40h			; convert number to uppercase character
  3753                                  
  3754 00000DCF FD                      	std
  3755                                  
  3756                                  	; MSDOS 6.0
  3757                                          ;cmp	AllocedEnv,0		; if a new environment is being built,
  3758                                  	;je	notwidenv		;  move the default comspec string in it
  3759                                  	;mov	di,ComspOffset
  3760                                          ;cmp	byte ptr es:[di+1],':'	; drive specifier already exist?
  3761                                          ;je	notwidenv               ; yes, must have been inherited that way
  3762                                  
  3763                                  	; MSDOS 3.3
  3764 00000DD0 803E[EC14]00                    cmp	byte [CHUCKENV],0
  3765 00000DD5 7513                    	jne	short NOTWIDENV
  3766                                  
  3767 00000DD7 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  3768 00000DD8 06                      	push	es			;  the drivespec is in ax and is copied
  3769 00000DD9 1F                      	pop	ds			;  on to the front of the string.
  3770                                  
  3771                                  	; MSDOS 6.0
  3772                                          ;lea	si,[di+MAX_COMSPEC-3]	
  3773                                          ;lea	di,[di+MAX_COMSPEC-1]
  3774                                  
  3775                                  	; MSDOS 3.3
  3776                                  	; 23/09/2018
  3777                                  	; 30/04/2018
  3778                                  	;mov	di,159
  3779                                  	;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  3780 00000DDA BF9F00                          mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  3781                                  	;mov	si,157
  3782                                  	;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  3783 00000DDD BE9D00                          mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  3784                                  	;mov	cx,144
  3785                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  3786 00000DE0 B99000                          mov     cx,MAX_COMSPEC-2
  3787                                  
  3788 00000DE3 F3A4                    	rep	movsb
  3789 00000DE5 1F                      	pop	ds
  3790                                  
  3791                                  	; MSDOS 6.0
  3792                                  	;mov     word ptr es:[di-1],ax
  3793                                  
  3794                                  	; MSDOS 3.3
  3795                                  	;mov	es:0Eh,ax
  3796                                  	;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  3797 00000DE6 26A30E00                	mov	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  3798                                  
  3799                                  	; MSDOS 3.3 & MSDOS 6.0
  3800                                  NOTWIDENV:
  3801 00000DEA FC                      	cld
  3802                                  
  3803 00000DEB A3[CF14]                	mov    [AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  3804                                  
  3805                                  NOCOMDRV:
  3806 00000DEE E8EFF5                          CALL    SETVECT         ; Set the vectors
  3807                                  
  3808                                  	; MSDOS 3.3
  3809 00000DF1 BE8000                  	mov	si,80h		; get command line
  3810 00000DF4 AC                      	lodsb			; get length of line
  3811 00000DF5 88C1                    	mov	cl,al
  3812 00000DF7 30ED                    	xor	ch,ch		; cx = length of command line
  3813                                  ;
  3814                                  ; insure that the command line correctly ends with a cr
  3815                                  ;
  3816 00000DF9 01CE                    	add	si,cx		; go to end of command line	
  3817 00000DFB C6040D                  	mov	byte [si], 0Dh	; insert a carriage return
  3818                                  
  3819 00000DFE BE8100                  	mov	si,81h		; Start of parms
  3820                                  CHKARG:
  3821 00000E01 E369                            jcxz	COMRETURNSJ     ; No parameters
  3822 00000E03 49                              dec	cx
  3823 00000E04 AC                      	lodsb
  3824                                  CHECKSWITCHCHR:
  3825                                  	;cmp	al,' '
  3826 00000E05 3A06[FC14]              	cmp	al,[space_chr]	 ;Skip blank spaces
  3827 00000E09 74F6                    	jz	short CHKARG
  3828 00000E0B 3C09                    	cmp	al,9		; Skip TAB characters
  3829 00000E0D 74F2                    	jz	short CHKARG
  3830 00000E0F 3A06[190C]              	cmp	al,[RSWITCHAR]	; Switch?
  3831 00000E13 7403                    	jz	short PARSE_CONT ; Yes, get the char after the switch
  3832 00000E15 E9D800                  	jmp	CHKOTHERARGS	; No
  3833                                  
  3834                                  PARSE_CONT:
  3835                                  ;
  3836                                  ; See if a switch was entered
  3837                                  ;
  3838 00000E18 E352                    	jcxz	COMRETURNSJ
  3839 00000E1A 49                      	dec	cx
  3840 00000E1B AC                      	lodsb
  3841 00000E1C 0C20                    	or	al,20h		; Lower case
  3842 00000E1E 3C66                    	cmp	al,'f'		; FAIL switch
  3843 00000E20 7507                    	jnz     short CHECKPSWITCH
  3844                                  	
  3845                                  	; MSDOS 6.0
  3846                                  ;SetFSwitch:
  3847                                  	;cmp	fFail,-1		; has fail switch been set?
  3848                                  	;jnz	failok			; no - set it
  3849                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3850                                          ;jmp	parse_line_error        ; go issue error 
  3851                                  
  3852                                  	; MSDOS 3.3 & MSDOS 6.0
  3853                                  FAIL_OK:
  3854 00000E22 C606[F90A]FF            	mov	byte [FFAIL],-1	; fail all INT 24s.
  3855                                  	; MSDOS 3.3
  3856 00000E27 EBD8                    	jmp	short CHKARG
  3857                                  
  3858                                  CHECKPSWITCH:
  3859                                          ;CMP	AL,'p'		; Permanent COMMAND switch
  3860 00000E29 3A06[FD14]              	cmp	al,[letter_p]
  3861 00000E2D 751C                            JNZ     short CHECKDSWITCH
  3862                                  
  3863                                  SETPSWITCH:
  3864                                  ;
  3865                                  ; We have a permanent COMMAND switch /P.  Flag this and stash the
  3866                                  ; termination address.
  3867                                  ;
  3868                                  	; MSDOS 6.0
  3869                                  	;cmp	PermCom,0		; has /p switch been set?
  3870                                  	;jz	permcomok		; no - set it
  3871                                          ;mov	ax,moreargs_ptr		; set up too many arguments
  3872                                          ;jmp	parse_line_error 		; go issue error 
  3873                                  ;permcomok:
  3874                                  	; MSDOS 3.3 & MSDOS 6.0
  3875 00000E2F FE06[F40A]              	inc	byte [PERMCOM]
  3876 00000E33 C706[900A][AD01]        	mov     word [OLDTERM],LODCOM
  3877 00000E39 8C1E[920A]              	mov     [OLDTERM+2],ds
  3878                                  ;
  3879                                  ; make sure that we display the date and time. if the flag was not
  3880                                  ; initialized, set it to indicate yes, do prompt.
  3881                                  ;
  3882                                  	; MSDOS 3.3
  3883 00000E3D 803E[DF14]FF            	cmp     byte [PRDATTM],-1
  3884 00000E42 75BD                    	jnz     short CHKARG
  3885 00000E44 C606[DF14]00            	mov     byte [PRDATTM],0
  3886 00000E49 EBB6                    	jmp     short CHKARG
  3887                                  
  3888                                  ;COMRETURNSJ:
  3889                                  ;	; MSDOS 3.3
  3890                                  ;	JMP	ARGSDONE
  3891                                  
  3892                                  CHECKDSWITCH:
  3893                                  	;cmp	al,'d'
  3894 00000E4B 3A06[FE14]                      cmp	al,[letter_d]
  3895 00000E4F 7507                    	jnz     short CHECKCSWITCH
  3896                                  SETDSWITCH:
  3897                                  ;
  3898                                  ; Flag no date/time prompting.
  3899                                  ;
  3900                                  	; MSDOS 6.0
  3901                                  	;cmp	Dswitch,0		; has /D switch been set?
  3902                                  	;jz	setdateok		; no - set it
  3903                                          ;mov	ax,Moreargs_ptr	; set up too many arguments
  3904                                          ;jmp	parse_line_error	; go issue error message
  3905                                  ;setdateok:
  3906                                  	;inc	Dswitch 		; indicate /D entered
  3907                                  
  3908                                  	; MSDOS 3.3 & MSDOS 6.0
  3909 00000E51 C606[DF14]01                    mov	byte [PRDATTM],1  ; User explicitly says no date time
  3910                                  	; MSDOS 3.3
  3911 00000E56 EBA9                    	jmp	short CHKARG
  3912                                  
  3913                                  CHECKCSWITCH:
  3914                                          ;cmp	al,'c'
  3915 00000E58 3A06[FF14]              	cmp     al,[letter_c]
  3916 00000E5C 7511                            jnz	short CHECKESWITCH
  3917                                  
  3918                                  ;SetSSwitch:
  3919                                  SETCSWITCH:
  3920                                  ;
  3921                                  ; Set up pointer to command line, flag no date/time and turn off singlecom.
  3922                                  ;
  3923 00000E5E C606[F40A]00            	mov	byte [PERMCOM],0	; A SINGLECOM must not be a PERMCOM
  3924 00000E63 8936[F50A]              	mov	[SINGLECOM],si		; Point to the rest of the command line
  3925                                  	;mov	byte [PERMCOM],0
  3926 00000E67 C606[DF14]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  3927                                  COMRETURNSJ: ; 24/09/2018
  3928 00000E6C E96C01                  	jmp	ARGSDONE
  3929                                  
  3930                                  CHECKESWITCH:
  3931 00000E6F 3C65                    	cmp     al,'e'
  3932 00000E71 758E                    	jnz     short CHKARG
  3933                                  ;
  3934                                  ; Look for environment-size setting switch
  3935                                  ;
  3936                                  ; The environment size is represented in decimal bytes and is
  3937                                  ; converted into paragraphs (rounded up to the next paragraph).
  3938                                  ;
  3939                                  SETESWITCH:
  3940                                  	; MSDOS 6.0
  3941                                  	;cmp	Eswitch,0		; has environment size switch been set?
  3942                                  	;jz	eswitchok		; no - set it
  3943                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3944                                          ;jmp	Parse_line_error	; go issue error message
  3945                                  ;eswitchok:
  3946                                  	;inc	Eswitch			; indicate /E entered 	
  3947                                  
  3948                                  	; 23/09/2018 - Retro DOS v3.0
  3949                                  
  3950                                  	; MSDOS 3.3
  3951                                  	; (COMMAND.COM offset 0FC5h)
  3952                                  ESWITCHOK:
  3953 00000E73 E38C                    	jcxz    CHKARG
  3954 00000E75 49                      	dec     cx
  3955 00000E76 AC                      	lodsb
  3956 00000E77 3C3A                    	cmp     al,':'
  3957 00000E79 758A                    	jnz     short CHECKSWITCHCHR
  3958 00000E7B 31DB                    	xor     bx,bx
  3959 00000E7D 89D8                    	mov     ax,bx
  3960                                  GETENVSIZE:
  3961 00000E7F E33C                    	jcxz    SETENVSIZE
  3962 00000E81 49                      	dec     cx
  3963 00000E82 AC                      	lodsb
  3964 00000E83 3C30                    	cmp     al,'0'
  3965 00000E85 7214                    	jb      short NOTDECIMALCHR
  3966 00000E87 3C39                    	cmp     al,'9'
  3967 00000E89 7710                    	ja      short NOTDECIMALCHR
  3968 00000E8B 2C30                    	sub     al,'0'
  3969 00000E8D 89DA                    	mov     dx,bx
  3970 00000E8F D1E2                    	shl     dx,1
  3971 00000E91 D1E2                    	shl     dx,1   ; dx = 4*bx	
  3972 00000E93 01D3                    	add     bx,dx  ; bx = 5*bx
  3973 00000E95 D1E3                    	shl     bx,1   ; bx = 10*bx	
  3974 00000E97 01C3                    	add     bx,ax
  3975 00000E99 EBE4                    	jmp     short GETENVSIZE
  3976                                  
  3977                                  NOTDECIMALCHR:
  3978                                  	;cmp	al,' '
  3979 00000E9B 3A06[FC14]              	cmp     al,[space_chr]
  3980 00000E9F 741A                    	jz      short CHECKENVSIZE
  3981                                  	;cmp	al,'/'
  3982 00000EA1 3A06[190C]              	cmp     al,[RSWITCHAR]
  3983 00000EA5 7414                    	jz      short CHECKENVSIZE
  3984                                  
  3985                                  CHECKNEXTECHR:
  3986 00000EA7 E33D                    	jcxz    INVENVSIZE
  3987 00000EA9 49                      	dec     cx
  3988 00000EAA AC                      	lodsb
  3989                                  	;cmp	al,' '
  3990 00000EAB 3A06[FC14]              	cmp     al,[space_chr]
  3991 00000EAF 7406                    	jz      short ENVSIZESPC
  3992                                  	;cmp	al,'/'
  3993 00000EB1 3A06[190C]              	cmp     al,[RSWITCHAR]
  3994 00000EB5 75F0                    	jnz     short CHECKNEXTECHR
  3995                                  
  3996                                  ENVSIZESPC:
  3997 00000EB7 4E                      	dec     si
  3998 00000EB8 41                      	inc     cx
  3999 00000EB9 EB2B                    	jmp     short INVENVSIZE
  4000                                  	
  4001                                  	;nop
  4002                                  
  4003                                  CHECKENVSIZE: 
  4004 00000EBB 4E                      	dec     si
  4005 00000EBC 41                      	inc     cx
  4006                                  
  4007                                  SETENVSIZE:
  4008                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  4009 00000EBD C706[0115]0008          	mov	word [ENVSIZ],ENVBIG/16
  4010 00000EC3 81FB0080                	cmp     bx,32768
  4011 00000EC7 771D                    	ja      short INVENVSIZE
  4012                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  4013 00000EC9 C706[0115]0A00          	mov	word [ENVSIZ],ENVSML/16
  4014 00000ECF 81FBA000                	cmp     bx,160
  4015 00000ED3 7211                    	jb      short INVENVSIZE
  4016 00000ED5 83C30F                  	add     bx,15
  4017 00000ED8 D1EB                    	shr     bx,1
  4018 00000EDA D1EB                    	shr     bx,1
  4019 00000EDC D1EB                    	shr     bx,1
  4020 00000EDE D1EB                    	shr     bx,1
  4021 00000EE0 891E[0115]              	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  4022 00000EE4 EB07                    	jmp     short NEXTCH2
  4023                                  
  4024                                  	;nop
  4025                                  
  4026                                  INVENVSIZE:
  4027 00000EE6 BA[8B14]                	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  4028 00000EE9 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4029 00000EEB CD21                    	int     21h             ; DOS - PRINT STRING
  4030                                  				; DS:DX -> string terminated by "$"
  4031                                  NEXTCH2:
  4032                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  4033 00000EED E911FF                  	jmp     CHKARG
  4034                                  
  4035                                  	;jmp	ARGSDONE
  4036                                  
  4037                                  CHKOTHERARGS:
  4038                                  ;
  4039                                  ; We have a non-switch character here.
  4040                                  ;
  4041                                  	; MSDOS 6.0
  4042                                  ;	push	ds ; ***			;
  4043                                  ;	push	si ; **** 			; save place in command line
  4044                                  ;	lds	si,Comnd1_Addr			; get address of filespec
  4045                                  ;	assume	ds:nothing			;
  4046                                  ;
  4047                                  ;	mov	dx,si				; put in dx also
  4048                                  ;       mov     ax,(OPEN shl 8) or 2            ; Read and write
  4049                                  ;	int	21h
  4050                                  ;	jc	ChkSrchSpec			; Wasn't a file
  4051                                  ;	mov	bx,ax
  4052                                  ;	mov	ax,IOCTL shl 8
  4053                                  ;	int	21h
  4054                                  ;	test	dl,80h
  4055                                  ;	jnz	IsaDevice
  4056                                  ;
  4057                                  ;BadSetCon:					;
  4058                                  ;	mov	ah,CLOSE			; Close initial handle, wasn't a device
  4059                                  ;	int	21h
  4060                                  ;	jmp	short ChkSrchSpec
  4061                                  
  4062                                  	; MSDOS 3.3
  4063                                  	; (COMMAND.COM offset 1047h)
  4064 00000EF0 4E                              dec	si
  4065 00000EF1 41                      	inc	cx
  4066 00000EF2 89F2                    	mov	dx,si
  4067 00000EF4 51                      	push	cx ; *
  4068 00000EF5 56                      	push	si ; **
  4069                                  CONTRLOOP:
  4070 00000EF6 AC                      	lodsb
  4071 00000EF7 49                      	dec	cx
  4072                                  	;cmp	al,' '
  4073 00000EF8 3A06[FC14]              	cmp	al,[space_chr]
  4074 00000EFC 7409                    	jz	short SETCDEV
  4075 00000EFE 3C09                    	cmp	al,9
  4076 00000F00 7405                    	jz	short SETCDEV
  4077 00000F02 E302                    	jcxz	SETCDEVA
  4078 00000F04 EBF0                    	jmp	short CONTRLOOP
  4079                                  
  4080                                  SETCDEVA:
  4081 00000F06 46                              inc	si
  4082                                  SETCDEV:
  4083 00000F07 C644FF00                	mov	byte [SI-1],0
  4084                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  4085 00000F0B B8023D                          mov	ax,(OPEN*256) | 2 ; 3D02h
  4086 00000F0E CD21                            int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  4087                                  			; DS:DX -> ASCIZ filename
  4088                                  			; AL = access mode
  4089                                  			; 2 - read & write
  4090 00000F10 7247                            jc	short CHKSRCHSPEC	; Wasn't a file
  4091 00000F12 89C3                            mov	bx,ax
  4092                                          ;mov	ax,IOCTL shl 8
  4093 00000F14 B80044                          mov     ax,IOCTL*256 ; 4400h
  4094 00000F17 CD21                    	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  4095                                  			; BX = file or device handle
  4096 00000F19 F6C280                          test	dl,80H
  4097 00000F1C 7506                    	jnz	short ISADEVICE
  4098                                  BADSETCON: ; MSDOS 6.0
  4099 00000F1E B43E                    	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  4100 00000F20 CD21                            int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  4101                                  			; BX = file handle
  4102 00000F22 EB35                            JMP     short CHKSRCHSPEC
  4103                                  
  4104                                  	;nop
  4105                                  
  4106                                  ISADEVICE:
  4107                                  	; MSDOS 3.3 & MSDOS 6.0
  4108 00000F24 30F6                    	xor	dh,dh
  4109 00000F26 80CA03                  	or	dl,3				; Make sure has CON attributes
  4110                                  	;mov	ax,(IOCTL shl 8) or 1
  4111 00000F29 B80144                  	mov	ax,(IOCTL*256) | 1 ; 4401h
  4112 00000F2C CD21                    	int	21h
  4113                                  	;
  4114                                  	; 25/09/2018
  4115 00000F2E 5A                      	pop	dx ; **
  4116 00000F2F 5A                      	pop	dx ; *
  4117                                  	;
  4118 00000F30 72EC                    	jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  4119 00000F32 89DA                    	mov	dx,bx				; Save new handle
  4120                                  
  4121                                  	; MSDOS 6.0
  4122                                  	;cmp	es:DevFlag,1
  4123                                  	;jz	DevErr
  4124                                  
  4125                                  	; MSDOS 3.3
  4126                                          ;pop	bx ; **				; Throw away saved SI
  4127                                          ;pop	bx ; *				; Throw away saved CX
  4128                                  
  4129                                  	; MSDOS 3.3 & MSDOS 6.0
  4130 00000F34 51                      	push	cx
  4131 00000F35 B90300                  	mov	cx,3
  4132 00000F38 31DB                    	xor	bx,bx
  4133                                  
  4134                                  RCCLLOOP:
  4135 00000F3A B43E                    	mov	ah,CLOSE ; 3Eh
  4136 00000F3C CD21                    	int	21h
  4137 00000F3E 43                      	inc	bx
  4138 00000F3F E2F9                    	loop	RCCLLOOP
  4139                                  
  4140 00000F41 89D3                    	mov	bx,dx				; New device handle
  4141 00000F43 B445                    	mov	ah,XDUP ; 45h
  4142 00000F45 CD21                    	int	21h				; Dup to 0
  4143 00000F47 B445                    	mov	ah,XDUP
  4144 00000F49 CD21                    	int	21h				; Dup to 1
  4145 00000F4B B445                    	mov	ah,XDUP
  4146 00000F4D CD21                    	int	21h				; Dup to 2
  4147 00000F4F B43E                    	mov	ah,CLOSE
  4148 00000F51 CD21                    	int	21h				; Close initial handle
  4149                                  	
  4150 00000F53 59                      	pop	cx
  4151                                  	
  4152                                  	; MSDOS 6.0
  4153                                  	;pop	si ; ****			; restore position of command line
  4154                                  	;pop	ds ; ***			;
  4155                                  ;
  4156                                  ; Register the fact that we already have redirected the output and cannot do
  4157                                  ; it again
  4158                                  ;
  4159                                  	;inc	es:DevFlag			;
  4160                                          ;jmp	Parse_command_line		; continue parsing
  4161                                  
  4162                                  	; MSDOS 3.3
  4163 00000F54 E361                    	jcxz	ARGSDONEJ2
  4164 00000F56 E9A8FE                  	jmp	CHKARG
  4165                                  
  4166                                  	; MSDOS 6.0
  4167                                  ;DevErr:
  4168                                  	;pop	si ; ****
  4169                                  	;pop	ds ; ***
  4170                                  	;mov	dx,1
  4171                                          ;call	RPrintParse                     ; "Too many parameters"
  4172                                          ;call	CrLf
  4173                                  	;jmp	Parse_command_line
  4174                                  
  4175                                  
  4176                                  CHKSRCHSPEC:                    ; Not a device, so must be directory spec
  4177                                  
  4178                                  	; MSDOS 6.0
  4179                                          ;cmp	es:PathFlag,1			; already set COMSPEC?
  4180                                          ;jz	DevErr				; yes, error
  4181                                  	;
  4182                                          ;inc	es:PathFlag			; mark that we have a path
  4183                                  ;
  4184                                  ; We have to override the passed environment. Allocate a buffer for use now.
  4185                                  ; This buffer will later be replaced by a proper environment
  4186                                  ;
  4187                                  	;call	alloc_env                       ; environment buffer
  4188                                  	;mov	es,ax
  4189                                  	;assume	es:nothing
  4190                                  	;push	si				; remember location of file
  4191                                  	;xor	cx,cx				; clear cx for counting
  4192                                  
  4193                                  ;countloop:
  4194                                  	;lodsb					; get a character
  4195                                  	;inc	cx				; increment counter
  4196                                          ;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  4197                                  	;jnz	countloop			; no - keep counting
  4198                                  	;
  4199                                  	;mov	al,Space
  4200                                  	;dec	si				; move back one
  4201                                          ;mov	byte ptr [si],al                ; put a space at end of line
  4202                                  ;
  4203                                  ; We now know how long the new pathspec for command.com is.  Time to
  4204                                  ; figure out how long the current COMSPEC setting is, and then to move
  4205                                  ; all the environment data up, throwing that COMSPEC setting away, and
  4206                                  ; preparing to append the new COMSPEC.  ComspOffset (the offset of
  4207                                  ; where the filespec exists in the environment) is updated as well.
  4208                                  ;
  4209                                  	;push	cx                              ;
  4210                                          ;mov	cx,ENVBIG                       ;
  4211                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  4212                                          ;mov	al,0                            ;
  4213                                          ;repne	scasb                           ; find the end of COMSPEC
  4214                                          ;mov	si,di                           ;
  4215                                  ;comp_endenv:                                   ;
  4216                                          ;scasb                                  ; end of env?
  4217                                          ;je	got_endenv                      ; yes
  4218                                          ;repne	scasb                           ;
  4219                                          ;jmp	comp_endenv                     ;
  4220                                  ;got_endenv:                                    ;
  4221                                          ;mov    cx,di                           ;
  4222                                          ;sub    cx,si                           ;
  4223                                          ;mov    di,ComspOffset                  ;
  4224                                          ;sub    di,ComspStrLen                  ;
  4225                                          ;push   ds                              ;
  4226                                          ;push   es                              ;
  4227                                          ;pop    ds                              ;
  4228                                          ;rep    movsb                           ;
  4229                                          ;dec    di                              ; copy in new COMSPEC=
  4230                                          ;push   cs                              ;
  4231                                          ;pop    ds                              ;
  4232                                          ;assume ds:ResGroup                     ;
  4233                                          ;mov    si,offset RESGROUP:ComspString  ;
  4234                                          ;mov    cx,ComspStrLen                  ;
  4235                                          ;rep    movsb                           ;
  4236                                          ;mov    ComspOffset,di                  ;
  4237                                          ;pop    ds                              ;
  4238                                          ;assume ds:nothing                      ;
  4239                                          ;pop    cx                              ;
  4240                                  	;
  4241                                          ;pop    si                              ; get new comspec location back
  4242                                  
  4243                                  	; MSDOS 3.3
  4244 00000F59 C606[EC14]00            	mov     byte [CHUCKENV],0	; If search specified -- no inheritance
  4245 00000F5E B8[400C]                	mov     ax,PATHSTRING ; "PATH="	; Figure environment pointer
  4246 00000F61 B104                    	mov     cl,4
  4247 00000F63 D3E8                    	shr     ax,cl
  4248 00000F65 8CDA                    	mov     dx,ds
  4249 00000F67 01D0                    	add     ax,dx
  4250 00000F69 A3[050C]                	mov     [ENVIRSEG],ax
  4251 00000F6C 8EC0                    	mov     es,ax
  4252                                  	;mov	al,' '
  4253 00000F6E A0[FC14]                	mov     al,[space_chr]
  4254 00000F71 8844FF                  	mov     [si-1],al
  4255 00000F74 5E                      	pop     si ; **			; Remember location
  4256 00000F75 59                      	pop     cx ; *			; and count
  4257                                  	;mov	di,[ECOMLOC]
  4258 00000F76 8B3E[ED14]              	mov     di,[COMSPOFFSET]
  4259                                  
  4260                                  COMTRLOOP:
  4261                                  	; MSDOS 3.3 & MSDOS 6.0
  4262 00000F7A AC                      	lodsb
  4263 00000F7B 49                      	dec	cx
  4264                                  	;cmp	al,' '
  4265 00000F7C 3A06[FC14]              	cmp	al,[space_chr]
  4266 00000F80 7409                    	je	short SETCOMSR
  4267                                  	; MSDOS 3.3
  4268 00000F82 3C09                    	cmp	al,9
  4269 00000F84 7405                    	je	short SETCOMSR
  4270                                  	; MSDOS 3.3 & MSDOS 6.0
  4271 00000F86 AA                      	stosb
  4272 00000F87 E302                    	jcxz	SETCOMSR
  4273 00000F89 EBEF                    	jmp	short COMTRLOOP
  4274                                  
  4275                                  SETCOMSR:
  4276                                  	; MSDOS 6.0
  4277                                  	;push	cx
  4278                                  	;
  4279                                  	;push	cs				; Get local segment
  4280                                  	;pop	ds				;
  4281                                  	;assume	ds:ResGroup			;
  4282                                  	;
  4283                                  	;push	ds
  4284                                  	;mov	si,offset ResGroup:ComSpect
  4285                                  	;mov	cx,14
  4286                                  	;
  4287                                  	;mov	al,es:[di-1]
  4288                                  	;
  4289                                  	;cmp	al,RDirChar
  4290                                  	;jnz	iNotRoot
  4291                                  	;inc	si				; Don't make a double /
  4292                                  	;dec	cx
  4293                                  	
  4294                                  	; MSDOS 3.3
  4295 00000F8B 56                      	push    si
  4296 00000F8C 51                      	push    cx
  4297 00000F8D 1E                      	push    ds
  4298 00000F8E BE[C114]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4299 00000F91 B90E00                  	mov     cx,14
  4300 00000F94 268A45FF                	mov     al,[es:di-1]
  4301 00000F98 E8E602                  	call    PATHCHRCMPR
  4302 00000F9B 7502                    	jnz     short INOTROOT			
  4303 00000F9D 46                      	inc     si				; Don't make a double /
  4304 00000F9E 49                      	dec     cx
  4305                                  
  4306                                  INOTROOT:
  4307                                  	; MSDOS 3.3 & MSDOS 6.0
  4308 00000F9F F3A4                    	rep	movsb
  4309                                  
  4310                                  	;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  4311 00000FA1 8B16[ED14]                      mov     dx,[COMSPOFFSET]
  4312 00000FA5 06                      	push	es
  4313 00000FA6 1F                      	pop	ds
  4314                                  	;mov	ax,OPEN shl 8
  4315 00000FA7 B8003D                  	mov	ax,OPEN*256 ; 3D00h
  4316 00000FAA CD21                    	int	21h				; Open COMMAND.COM
  4317 00000FAC 1F                      	pop	ds
  4318 00000FAD 720D                    	jc	short SETCOMSRBAD		; No COMMAND.COM here
  4319 00000FAF 89C3                    	mov	bx,ax				; Handle
  4320 00000FB1 B43E                    	mov	ah,CLOSE ; 3Eh
  4321 00000FB3 CD21                    	int	21h				; Close COMMAND.COM
  4322                                  SETCOMSRRET:
  4323 00000FB5 59                      	pop	cx
  4324 00000FB6 5E                      	pop	si
  4325                                  
  4326                                  	; MSDOS 6.0
  4327                                  	;pop	ds				;
  4328                                  	;assume	ds:ResGroup			;
  4329                                  	;
  4330                                  	;push	cs				; Make sure local ES is
  4331                                  	;pop	es				;  restored
  4332                                  	;jmp	Parse_command_line		; continue parsing command line
  4333                                  
  4334                                  	; MSDOS 3.3
  4335                                  ARGSDONEJ2:
  4336 00000FB7 E322                    	jcxz	ARGSDONE
  4337 00000FB9 E945FE                  	jmp	CHKARG
  4338                                  
  4339                                  SETCOMSRBAD:
  4340                                  	; MSDOS 3.3 & MSDOS 6.0
  4341                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  4342 00000FBC BA[0914]                	mov	dx,BADCOMLKMES
  4343                                  
  4344                                  ;	Note:  we're about to make a near call to TriageError, which
  4345                                  ;	lives in a different segment and group.  Some linkers will
  4346                                  ;	generate a warning like "Possible fix-up overflow".  We're
  4347                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  4348                                  ;	we're still all together.
  4349                                  
  4350 00000FBF E81D23                  	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  4351                                  				; in original MSDOS 3.3 COMMAND.COM	
  4352 00000FC2 83F841                  	cmp	ax,65
  4353 00000FC5 7503                    	jne	short DOPRT
  4354                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  4355 00000FC7 BA[4214]                	mov	dx,BADCOMACCMSG
  4356                                  DOPRT:
  4357 00000FCA E8A702                  	call	RPRINT
  4358                                  	;mov	si,offset ResGroup:ComSpect
  4359 00000FCD BE[C114]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4360                                  	;mov	di,[ECOMLOC]
  4361 00000FD0 8B3E[ED14]                      mov     di,[COMSPOFFSET]
  4362 00000FD4 B90E00                  	mov	cx,14
  4363 00000FD7 F3A4                    	rep	movsb				; get my default back
  4364                                  
  4365 00000FD9 EBDA                    	jmp	short SETCOMSRRET
  4366                                  
  4367                                  ARGSDONE:
  4368                                  	; MSDOS 6.0
  4369                                  	;mov	es,EnvirSeg			; get environment back
  4370                                  	;assume	es:nothing			;
  4371                                  
  4372                                  	; MSDOS 3.3 & MSDOS 6.0
  4373 00000FDB 803E[F40A]00                    cmp	byte [PERMCOM],0
  4374 00000FE0 742E                            jz	short COMRETURNS
  4375                                  
  4376 00000FE2 06                      	push	es				; Save environment pointer
  4377 00000FE3 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  4378 00000FE5 8CDB                    	mov	bx,ds
  4379 00000FE7 8EC3                    	mov	es,bx
  4380 00000FE9 CD21                    	int	21h				; current process is me
  4381 00000FEB BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  4382                                  	;mov	ax,offset RESGROUP:LODCOM
  4383 00000FEE B8[AD01]                        mov	ax,LODCOM
  4384 00000FF1 AB                              stosw
  4385 00000FF2 8CD8                            mov	ax,ds
  4386 00000FF4 AB                              stosw
  4387                                          ;mov	ax,offset RESGROUP:CONTC
  4388 00000FF5 B8[3C00]                        mov	ax,CONTC
  4389 00000FF8 AB                              stosw
  4390 00000FF9 8CD8                            mov	ax,ds
  4391 00000FFB AB                              stosw
  4392                                  	;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  4393 00000FFC B8[4F04]                	mov     ax,CRITERR
  4394 00000FFF AB                      	stosw
  4395 00001000 8CD8                    	mov     ax,ds
  4396 00001002 AB                      	stosw
  4397                                  	;mov	word ptr ds:16h,ds
  4398                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  4399 00001003 8C1E1600                	mov	[PDB.PARENT_PID],ds
  4400                                          ;mov	dx,offset RESGROUP:INT_2E
  4401 00001007 BA[7C01]                        mov	dx,INT_2E
  4402                                          ;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  4403 0000100A B82E25                  	mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  4404 0000100D CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  4405                                  			; AL = interrupt number
  4406                                  			; DS:DX = new vector to be used for specified interrupt
  4407 0000100F 07                              pop	es				; Remember environment
  4408                                  	
  4409                                  COMRETURNS:
  4410                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  4411 00001010 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  4412 00001013 A3[8E0A]                        mov	[PARENT],ax			; Save parent
  4413                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  4414 00001016 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  4415                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  4416 0000101A A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax, ds:18h
  4417 0000101D A3[F10A]                        mov	[IO_SAVE],ax		; Get the default stdin and out
  4418 00001020 8C1E[090C]                      mov	[COM_PTR+2],ds		; Set all these to resident
  4419 00001024 8C1E[0D0C]                      mov	[COM_FCB1+2],ds
  4420 00001028 8C1E[110C]              	mov	[COM_FCB2+2],ds
  4421                                          ;mov	di,offset ResGroup:ComSpec
  4422 0000102C BF[9B0A]                        mov	di,COMSPEC
  4423                                  
  4424                                  	;mov	si,[ECOMLOC]
  4425 0000102F 8B36[ED14]              	mov	si,[COMSPOFFSET]
  4426                                  	;cmp	AllocedEnv,0  ; MSDOS 6.0
  4427 00001033 803E[EC14]00                    cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  4428                                  	
  4429 00001038 8CD8                    	mov	ax,ds				; Xchg es,ds
  4430 0000103A 06                      	push	es
  4431 0000103B 1F                      	pop	ds
  4432 0000103C 8EC0                    	mov	es,ax
  4433                                  
  4434                                  	;jne	CopyComsp  ; MSDOS 6.0
  4435 0000103E 741D                            je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  4436                                  
  4437 00001040 0E                              push	cs
  4438 00001041 1F                              pop	ds
  4439                                  
  4440                                          ;mov	si,offset ResGroup:ComspString
  4441 00001042 BE[EF14]                	mov	si,COMSPSTRING ; "COMSPEC="
  4442 00001045 06                      	push	es
  4443 00001046 57                      	push	di
  4444 00001047 E84C02                  	call	IFINDE
  4445 0000104A 89FE                    	mov	si,di
  4446 0000104C 06                      	push	es
  4447 0000104D 1F                      	pop	ds
  4448 0000104E 5F                      	pop	di
  4449 0000104F 07                      	pop	es
  4450 00001050 730B                            jnc	short COPYCOMSP
  4451                                  
  4452                                  	; MSDOS 6.0
  4453                                  ;ComSpecNofnd:
  4454                                          ;mov	si,offset ResGroup:ComspString
  4455                                          ;add	si,ComspStrLen
  4456                                  	;push	cs
  4457                                  	;pop	ds
  4458                                  
  4459                                  COMSPECNOFND:
  4460                                  	; MSDOS 3.3
  4461                                          ;mov	si,[es:ECOMLOC]
  4462 00001052 268B36[ED14]                    mov	si,[es:COMSPOFFSET]
  4463                                  	;add	si,offset RESGROUP:PATHSTRING
  4464 00001057 81C6[400C]                      add	si,PATHSTRING ; "PATH="
  4465 0000105B 0E                      	push	cs
  4466 0000105C 1F                              pop	ds
  4467                                  
  4468                                  COPYCOMSP:
  4469                                  	; MSDOS 3.3 & MSDOS 6.0
  4470                                  	;mov	es:PutBackComSpec.SubstPtr,di
  4471 0000105D 26893E[DB0A]            	mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  4472 00001062 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  4473 00001066 7506                    	jne	short COPYCOMSPLOOP		; If not, do not skip over first 2 bytes
  4474                                  	;add	es:PutBackComSpec.SubstPtr,2
  4475 00001068 268306[DB0A]02          	add	word [es:PUTBACKSUBSTPTR],2
  4476                                  
  4477                                  COPYCOMSPLOOP:
  4478 0000106E AC                      	lodsb
  4479 0000106F AA                      	stosb
  4480 00001070 08C0                    	or	al,al
  4481 00001072 75FA                    	jnz	short COPYCOMSPLOOP
  4482                                  
  4483 00001074 26893E[DD0A]            	mov	[es:COMSPEC_END],di		; Save ptr to end of comspec path
  4484 00001079 26FF0E[DD0A]            	dec	word [es:COMSPEC_END]
  4485 0000107E 268A26[E60A]            	mov	ah,[es:COMDRV]
  4486 00001083 80C440                  	add	ah,'A'-1 ; 40h
  4487 00001086 268826[2309]            	mov	[es:PUTBACKDRV],ah		; save drive letter
  4488                                  
  4489                                  	; MSDOS 6.0
  4490                                  	;call	setup_for_messages		; set up parse and extended error messages
  4491                                  ;
  4492                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  4493                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  4494                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  4495                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  4496                                  ; the data otherwise it is just the data.
  4497                                  ; 
  4498                                  	;call	Setup_res_end			;put resident size in ResSize
  4499                                  
  4500                                  	;push	cs
  4501                                  	;pop	ds
  4502                                  	;assume	ds:RESGROUP
  4503                                  
  4504                                  ;Public EnvMaximum
  4505                                  ;EnvMaximum:
  4506                                  
  4507                                  	; MSDOS 3.3
  4508 0000108B 0E                      	push	cs
  4509 0000108C 1F                              pop	ds
  4510                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  4511 0000108D BB[380C]                	mov	bx,DATARESEND+15
  4512 00001090 B104                            mov	cl,4
  4513 00001092 D3EB                            shr	bx,cl
  4514 00001094 B44A                            MOV     AH,SETBLOCK ; 4Ah
  4515 00001096 CD21                            int	21h			; Shrink me to the resident only
  4516                                  
  4517                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  4518                                  
  4519 00001098 C606[E30A]01            	mov	byte [TRNMVFLG], 1
  4520 0000109D 06                      	push	es ; *
  4521 0000109E BE[5015]                	mov	si,TRANSTART
  4522 000010A1 BF0000                  	mov	di,0
  4523 000010A4 8E06[E10A]              	mov	es,[TRNSEG]
  4524                                  	;mov	cx,4D5Ch
  4525 000010A8 B97C4C                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  4526 000010AB 51                      	push	cx
  4527 000010AC 89C8                    	mov	ax,cx
  4528 000010AE 01F0                    	add	ax,si
  4529 000010B0 B104                    	mov	cl,4
  4530 000010B2 D3E8                    	shr	ax,cl
  4531 000010B4 40                      	inc	ax
  4532 000010B5 8CD9                    	mov	cx,ds
  4533 000010B7 01C8                    	add	ax,cx
  4534 000010B9 3B06[E10A]              	cmp	ax,[TRNSEG]
  4535 000010BD 59                      	pop	cx
  4536 000010BE 7205                    	jb	short MOV_DOWN
  4537                                  
  4538 000010C0 E8B4F2                  	call	LOADCOM
  4539 000010C3 EB0A                    	jmp	short ICHKSUM
  4540                                  
  4541                                  MOV_DOWN:
  4542 000010C5 01CE                    	add     si,cx
  4543 000010C7 4E                      	dec     si
  4544 000010C8 01CF                    	add     di,cx
  4545 000010CA 4F                      	dec     di
  4546 000010CB FD                      	std
  4547 000010CC F3A4                    	rep movsb
  4548 000010CE FC                      	cld
  4549                                  
  4550                                  ICHKSUM:
  4551                                  	; 24/09/2018
  4552                                  ;
  4553                                  ; Compute checksum right now before we can get corrupted and save it
  4554                                  ;
  4555                                  	; MSDOS 6.0
  4556                                  	;mov	si,offset RESGROUP:TranStart
  4557                                  	;add	si,100h
  4558                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  4559                                  	;
  4560                                  	;cld
  4561                                  	;shr	cx,1
  4562                                  	;xor	dx,dx
  4563                                  ;Ichksum:
  4564                                  	;lodsw
  4565                                  	;add	dx,ax
  4566                                  	;adc	dx,0
  4567                                  	;loop	Ichksum
  4568                                  	;
  4569                                          ;mov	Sum,dx			; store checksum
  4570                                  
  4571                                  	; MSDOS 3.3
  4572 000010CF 07                      	pop     es ; *
  4573 000010D0 E8F3F2                  	call    CHKSUM
  4574 000010D3 8916[E90A]              	mov     [SUM],dx
  4575                                  
  4576                                  	; MSDOS 3.3 & MSDOS 6.0
  4577 000010D7 803E[DF14]00                    cmp     byte [PRDATTM],0	;
  4578 000010DC 750C                            jnz     short NOBATCHSEG	; don't do autoexec or date time
  4579                                  ;
  4580                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  4581                                  ;
  4582                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  4583                                  	;mov	bx,3
  4584 000010DE BB0300                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  4585 000010E1 B448                            mov     ah,ALLOC ; 48h		;
  4586 000010E3 CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4587                                  			; BX = number of 16-byte paragraphs desired
  4588 000010E5 7203                    	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  4589 000010E7 A3[990A]                        mov     [BATCH],ax		; save batch segment
  4590                                  
  4591                                  NOBATCHSEG:
  4592                                  	; MSDOS 6.0
  4593                                  	;mov	bx,EnvirSeg                     ; get old environment segment
  4594                                  	;mov	OldEnv,bx                       ; save it
  4595                                  	;
  4596                                          ;mov	UsedEnv,0                       ; initialize env size counter
  4597                                  	;mov	ds,bx
  4598                                  	;assume	ds:nothing
  4599                                  	;
  4600                                  	;xor	si,si
  4601                                  	;mov	di,si
  4602                                  ;
  4603                                  ; This is the maximum allowed size for the environment
  4604                                  ;
  4605                                  	;mov	bx,4096 - 1 			; max. allowed env. size
  4606                                  	;mov	EnvMax,bx
  4607                                  				 
  4608                                  	;shl	bx,1
  4609                                  	;shl	bx,1
  4610                                  	;shl	bx,1
  4611                                  	;shl	bx,1
  4612                                  	;mov	EnvMax, bx			; convert envmax to bytes
  4613                                  	;dec	bx				; dec by one to leave room for double 0
  4614                                  	;xor	dx,dx				; use dx to indicate that there was
  4615                                  						; no environment size error.
  4616                                  ;public NxtStr
  4617                                  ;NxtStr:
  4618                                  	;call	GetStrLen			; get the size of the current env string
  4619                                  
  4620                                  ;Bugbug: Can use ss here to address UsedEnv
  4621                                  
  4622                                  	;push	ds                              ; get addressability to environment
  4623                                          ;push	cs                              ;                       counter
  4624                                          ;pop	ds                              ;
  4625                                          ;assume	ds:ResGroup
  4626                                          ;add	UsedEnv,cx                      ; add the string length to env size
  4627                                          ;pop	ds                              ;
  4628                                  	;assume	ds:nothing
  4629                                  	;cmp	cx,1				; end of environment was encountered.
  4630                                  	;jz	EnvExit
  4631                                  	;sub	bx,cx
  4632                                  	;jae	OkCpyStr			; can't fit in all of enviroment.
  4633                                  	;inc	dx				; out of env space msg must be displayed
  4634                                  	;jmp	short EnvExit
  4635                                  ;OkCpyStr:
  4636                                  	;jmp	NxtStr
  4637                                  ;EnvExit:
  4638                                  	;push	cs
  4639                                  	;pop	ds
  4640                                  	;assume	ds:ResGroup
  4641                                  	;or	dx,dx				; dx will be non-zero if error
  4642                                  	;jz	EnvNoErr
  4643                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  4644                                  	;call 	RPrint
  4645                                  	;
  4646                                  ;EnvNoErr:
  4647                                  	;mov	ax,EnvSiz			;env size previously set
  4648                                  	;mov	cl,4
  4649                                  	;shl	ax,cl				;get size in bytes
  4650                                  	;cmp	ax,UsedEnv			;is it a new env?
  4651                                  	;ja	st_envsize			;yes, store the size
  4652                                  	;
  4653                                  	;mov	ax,UsedEnv
  4654                                  	;add	ax,15				;round up
  4655                                  ;st_envsize:	
  4656                                  	;shr	ax,cl
  4657                                  	;mov	EnvSiz,ax			;store env size needed(paras)
  4658                                  ;if MSVER
  4659                                  	;cmp	SingleCom,0
  4660                                  	;jnz	nophead 			; don't print header if singlecom
  4661                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4662                                  	;call	RPrint
  4663                                  ;nophead:
  4664                                  ;endif
  4665                                  
  4666                                  	; MSDOS 3.3
  4667 000010EA BBFFFF                  	mov     bx,0FFFFh ; 65535
  4668 000010ED B448                    	mov     ah,ALLOC ; 48h
  4669 000010EF CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4670                                  			; BX = number of 16-byte paragraphs desired
  4671 000010F1 2B1E[0B15]              	sub     bx,[TRNSIZE]
  4672 000010F5 81EB8000                	sub     bx,128
  4673 000010F9 891E[0315]              	mov     [ENVMAX],bx
  4674                                  
  4675 000010FD 81FB0010                	cmp     bx,4096
  4676 00001101 7207                    	jb      short ALLOCENVIRSEG
  4677 00001103 BBFF0F                  	mov     bx,4096-1		; max. allowed environment size
  4678 00001106 891E[0315]              	mov     [ENVMAX],bx
  4679                                  
  4680                                  ALLOCENVIRSEG:
  4681 0000110A B448                    	mov     ah,ALLOC ; 48h
  4682 0000110C CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4683                                  			; BX = number of 16-byte paragraphs desired
  4684 0000110E 8B1E[050C]              	mov     bx,[ENVIRSEG]		; get old environment segment
  4685 00001112 891E[0515]              	mov     [OLDENV],bx		; save it	
  4686 00001116 C706[0715]0000          	mov     word [USEDENV],0	; initialize environment size counter
  4687 0000111C 8EDB                    	mov     ds,bx
  4688 0000111E 36A3[050C]              	mov     [ss:ENVIRSEG], ax	; save new environment segment
  4689 00001122 8EC0                    	mov     es,ax
  4690 00001124 31F6                    	xor     si,si
  4691 00001126 89F7                    	mov     di,si
  4692 00001128 368B1E[0315]            	mov     bx,[ss:ENVMAX]
  4693 0000112D D1E3                    	shl     bx,1
  4694 0000112F D1E3                    	shl     bx,1
  4695 00001131 D1E3                    	shl     bx,1
  4696 00001133 D1E3                    	shl     bx,1
  4697 00001135 36891E[0315]            	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  4698 0000113A 4B                      	dec     bx			; dec by one to leave room for double 0
  4699 0000113B 31D2                    	xor     dx,dx			; use dx to indicate that there was
  4700                                  					; no environment size error.
  4701                                  
  4702                                  NXSTR:
  4703 0000113D E80F01                  	call    GETSTRLEN		; get the size of the current env string
  4704                                  
  4705 00001140 1E                      	push    ds
  4706 00001141 0E                      	push    cs
  4707 00001142 1F                      	pop     ds
  4708 00001143 010E[0715]              	add     [USEDENV],cx		; add the string length to env size
  4709 00001147 1F                      	pop     ds
  4710 00001148 83F901                  	cmp     cx,1			; end of environment was encountered.
  4711 0000114B 7409                    	je      short ENVEXIT
  4712 0000114D 29CB                    	sub     bx,cx
  4713 0000114F 7303                    	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  4714 00001151 42                      	inc     dx			; out of env space msg must be displayed
  4715 00001152 EB02                    	jmp     short ENVEXIT
  4716                                  
  4717                                  	;nop
  4718                                  
  4719                                  OKCPYSTR:
  4720 00001154 EBE7                    	jmp     short NXSTR
  4721                                  
  4722                                  ENVEXIT: 
  4723 00001156 0E                      	push    cs
  4724 00001157 1F                      	pop     ds
  4725 00001158 09D2                    	or      dx, dx			; dx will be non-zero if error
  4726 0000115A 7406                    	jz      short ENVNOERR
  4727 0000115C BA[7114]                	mov     dx,OUTENVMSG		; dx = ptr to msg
  4728 0000115F E81201                  	call    RPRINT
  4729                                  
  4730                                  ENVNOERR:
  4731 00001162 8B0E[0315]              	mov     cx,[ENVMAX]
  4732 00001166 29D9                    	sub     cx,bx			; current environment size in bytes
  4733 00001168 83C110                  	add     cx,16			; add memory arena to the size
  4734 0000116B D1E9                    	shr     cx,1
  4735 0000116D D1E9                    	shr     cx,1
  4736 0000116F D1E9                    	shr     cx,1
  4737 00001171 D1E9                    	shr     cx,1			; convert current env size to paragraphs
  4738 00001173 3B0E[0115]              	cmp     cx,[ENVSIZ]		; compare with env size previously set
  4739                                  	;jb	short SET_ENVSIZE
  4740 00001177 7604                    	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  4741 00001179 890E[0115]              	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  4742                                  
  4743                                  SET_ENVSIZE:
  4744 0000117D 8B1E[0115]              	mov     bx,[ENVSIZ]
  4745 00001181 8CC0                    	mov     ax,es
  4746 00001183 01D8                    	add     ax,bx			; get end segment of environemnt
  4747 00001185 3B06[0915]              	cmp     ax,[INITEND]		; compare with init code end segment
  4748 00001189 770E                    	ja      short NOPHEAD
  4749                                  					; free unused paragraghs		
  4750 0000118B 8CC0                    	mov     ax,es
  4751 0000118D 8B1E[0915]              	mov     bx,[INITEND]
  4752 00001191 29C3                    	sub     bx,ax
  4753                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  4754 00001193 C706[0D15]0100          	mov	word [RESETENV],1	; environment segment reset sign
  4755                                  
  4756                                  NOPHEAD:
  4757                                  	; MSDOS 3.3
  4758 00001199 B44A                    	mov     ah,SETBLOCK ; 4Ah
  4759 0000119B CD21                    	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  4760                                  			; ES = segment address of block to change
  4761                                  			; BX = new size in paragraphs
  4762                                  
  4763                                  	; MSDOS 3.3 & 6.0
  4764 0000119D 833E[990A]00            	cmp     word [BATCH],0		; did we set up a batch segment?
  4765 000011A2 7503                    	jnz     short DODATE		; yes - go initialize it
  4766 000011A4 E99300                  	jmp     NODTTM			; don't do autoexec or date time
  4767                                  
  4768                                  DODATE:
  4769                                  ;
  4770                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  4771                                  ;
  4772                                  
  4773 000011A7 A1[990A]                	mov	ax,[BATCH]		; get batch segment
  4774 000011AA C606[EF0A]03            	mov	byte [ECHOFLAG],3	; set batch echo
  4775 000011AF C706[FE0A]0100          	mov	word [NEST],1		; set nest flag to 1 batch
  4776 000011B5 8EC0                    	mov	es,ax
  4777                                  ;
  4778                                  ; initialize the segment
  4779                                  ;
  4780 000011B7 31FF                    	xor	di,di
  4781 000011B9 B000                    	mov	al,BATCHTYPE ; 0
  4782 000011BB AA                      	stosb
  4783 000011BC B001                    	mov	al,1			; initialize echo for batch exit
  4784 000011BE AA                      	stosb
  4785                                  ;
  4786                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  4787                                  ;
  4788 000011BF 31C0                    	xor	ax,ax			; initialize to zero
  4789                                  	;stosb	; MSDOS 6.0 		; clear out BatchEOF
  4790                                  
  4791 000011C1 AB                      	stosw				; batch segment of last job - batlast
  4792 000011C2 AB                      	stosw				; segment for FOR
  4793 000011C3 AA                      	stosb				; FOR flag
  4794 000011C4 AB                      	stosw				; position in file - batseek
  4795 000011C5 AB                      	stosw
  4796                                  ;
  4797                                  ; clean out the parameters
  4798                                  ;
  4799 000011C6 B8FFFF                  	mov	ax,-1			; initialize to no parameters
  4800 000011C9 B90A00                  	mov	cx,10
  4801 000011CC F3AB                    	rep	stosw
  4802                                  ;
  4803                                  ; decide whether we should grab the default drive
  4804                                  ;
  4805 000011CE 803E[CF14]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  4806 000011D3 750B                    	jnz	short NOAUTSET
  4807 000011D5 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h
  4808 000011D7 CD21                    	int	21h
  4809                                  	;add	al,'A'
  4810 000011D9 0206[0015]              	add	al,[letter_A] ; Ucasea
  4811 000011DD A2[CF14]                	mov	[AUTOBAT],al
  4812                                  
  4813                                  NOAUTSET:
  4814                                  ;
  4815                                  ; copy in the batch file name (including nul)
  4816                                  ;
  4817                                  	;mov	si,offset ResGroup:AutoBat
  4818 000011E0 BE[CF14]                	mov	si,AUTOBAT
  4819 000011E3 B90800                  	mov	cx,8
  4820 000011E6 F3A5                    	rep	movsw
  4821                                  	;movsb	; MSDOS 6.0		; move in carriage return to terminate string
  4822                                  
  4823                                  	;mov	dx,offset ResGroup:AutoBat
  4824 000011E8 BA[CF14]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  4825                                  
  4826                                  	;mov	ax,OPEN shl 8
  4827 000011EB B8003D                  	mov	ax,OPEN*256 ; 3D00h  ; open for read
  4828 000011EE CD21                    	int	21h			; see if autoexec.bat exists
  4829 000011F0 7208                    	jc	short NOABAT
  4830 000011F2 89C3                    	mov	bx,ax
  4831 000011F4 B43E                    	mov	ah,CLOSE  ; 3Eh
  4832 000011F6 CD21                    	int	21h
  4833 000011F8 EB4D                    	jmp	short DRV0		; go process autoexec
  4834                                  
  4835                                  NOABAT:
  4836 000011FA 50                      	push	ax
  4837 000011FB E85A00                  	call	SETUP_SEG
  4838 000011FE A3[EA14]                	mov	[TRIAGEADD+2],ax
  4839 00001201 58                      	pop	ax
  4840 00001202 FF1E[E814]              	call	far [TRIAGEADD]		; get extended error
  4841 00001206 83F841                  	cmp	ax,65			; network access denied?
  4842 00001209 7506                    	jne	short OPENERR		; no - go deallocate batch
  4843                                  
  4844                                  _ACCDENERROR:					; yes - put out message
  4845                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  4846 0000120B BA[5414]                	mov	dx,ACCDENERR
  4847 0000120E E86300                  	call	RPRINT
  4848                                  
  4849                                  OPENERR:
  4850 00001211 8E06[990A]              	mov	es,[BATCH]		; not found--turn off batch job
  4851 00001215 B449                    	mov	ah,DEALLOC ; 49h
  4852 00001217 CD21                    	int	21h
  4853 00001219 C706[990A]0000          	mov	word [BATCH],0		; after dealloc in case of ^c
  4854 0000121F C606[EF0A]01            	mov	byte [ECHOFLAG],1
  4855 00001224 C706[FE0A]0000          	mov	word [NEST],0		; indicate no batch in progress
  4856                                  
  4857                                  DODTTM:
  4858                                  	;mov	ax,offset TranGroup:Datinit
  4859                                  
  4860 0000122A B81620                  	mov	ax,DATINIT
  4861 0000122D A3[E014]                	mov	[INITADD],ax
  4862                                  
  4863                                  	; MSDOS 6.0
  4864                                  ;;;M004	mov	ax,TrnSeg	
  4865                                  ;
  4866                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  4867                                  ; M004; the transient starts on a para boundary at the label TranStart.
  4868                                  ; M004; We use TranStart to get the start of the transient segment.
  4869                                  ;
  4870                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  4871                                  	;mov	cl,4				; M004
  4872                                  	;shr	ax,cl				; get relative seg ; M004
  4873                                  	;mov	cx,cs
  4874                                  	;add	ax,cx				; ax = transient seg ; M004
  4875                                  
  4876                                  	; MSDOS 3.3
  4877                                  	; 25/09/2018
  4878 00001230 A1[E10A]                	mov     ax,[TRNSEG]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  4879                                  
  4880                                  	; MSDOS 3.3 & MSDOS 6.0
  4881 00001233 A3[E214]                	mov	[INITADD+2],ax
  4882                                  	;call	dword ptr InitAdd
  4883 00001236 FF1E[E014]              	call	far [INITADD]
  4884                                  
  4885                                  NODTTM:
  4886                                  	; MSDOS 6.0
  4887                                  Copyright:
  4888                                  	;public	Copyright
  4889                                  ;	Bugbug:	remove Copyright label.
  4890                                  
  4891                                  ;if IBMVER
  4892                                  	;cmp	SingleCom,0
  4893                                  	;jnz	Drv0				; don't print header if singlecom
  4894                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4895                                  	;call	RPrint
  4896                                  ;endif
  4897                                  
  4898                                  	; MSDOS 3.3
  4899 0000123A 833E[F50A]00            	cmp	word [SINGLECOM],0	; don't print header if singlecom
  4900 0000123F 7506                    	jnz     short DRV0
  4901 00001241 BA[B014]                	mov     dx,HEADERPTR	; dx = ptr to msg
  4902 00001244 E82D00                  	call    RPRINT
  4903                                  
  4904                                  DRV0:
  4905                                  	; MSDOS 3.3
  4906 00001247 C606[5B0B]00                    mov     byte [INITFLAG],0
  4907 0000124C E9B0F1                  	jmp	ENDINIT
  4908                                  
  4909                                  	; MSDOS 6.0
  4910                                  ;Drv0:						; Reset APPEND state
  4911                                  ;	push	ds				; save data segment
  4912                                  ;	push	cs				; Get local segment into DS
  4913                                  ;	pop	ds				;
  4914                                  ;	mov	ax,APPENDSETSTATE		; Set the state of Append
  4915                                  ;	mov	bx,Append_State 		;  back to the original state
  4916                                  ;	int	2fh				;
  4917                                  ;	pop	ds				; get data segment back
  4918                                  ;;
  4919                                  ;;Check FirstCom set previously to see if this is the first instance of
  4920                                  ;;command.com. If not, we do not move command.com. Instead, we copy over the
  4921                                  ;;jump table from the previous stub to the current stub.
  4922                                  ;;
  4923                                  ;	cmp	FirstCom,1			;first command.com?
  4924                                  ;	jz	move_code			;yes, move it
  4925                                  ;
  4926                                  ;	push	es
  4927                                  ;	push	ds
  4928                                  ;
  4929                                  ;	push	ds
  4930                                  ;	pop	es
  4931                                  ;	mov	di,offset DATARES:Int2f_Entry
  4932                                  ;
  4933                                  ;	mov	ds,word ptr es:ResJmpTable+2	;get segment address
  4934                                  ;	mov	si,word ptr es:ResJmpTable	;get offset address
  4935                                  ;
  4936                                  ;	mov 	cx,NUM_RELOC_ENTRIES 		;number of dword ptrs
  4937                                  ;	shl	cx,1
  4938                                  ;	shl	cx,1				;size of table in bytes
  4939                                  ;
  4940                                  ;	cld
  4941                                  ;	rep	movsb				;copy the jump table
  4942                                  ;;
  4943                                  ;;Check if the resident code is in HMA. We assume that it is in HMA if its 
  4944                                  ;;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  4945                                  ;;
  4946                                  ;	cmp	es:[di-2],0f000h		;is resident code in HMA?
  4947                                  ;	jb	res_low				;no, dont set flag
  4948                                  ;
  4949                                  ;	mov	es:ComInHMA,1			;indicate code in HMA
  4950                                  ;
  4951                                  ;res_low:
  4952                                  ;	pop	ds
  4953                                  ;	pop	es
  4954                                  ;	jmp	short finish_init
  4955                                  ;;
  4956                                  ;;Now, we can move the resident code to its final location, either to HIMEM
  4957                                  ;;or to overlay the messages in the data segment if the user has not used the
  4958                                  ;;/msg switch.
  4959                                  ;;
  4960                                  ;move_code:
  4961                                  ;	call	Move_res_code			;move the code
  4962                                  ;
  4963                                  ;finish_init:
  4964                                  ;	jmp	RESGROUP:EndInit 		;g finish initializing
  4965                                  
  4966                                  
  4967                                  GETSTRLEN:
  4968                                  ;
  4969                                  ;	Get length of string pointed to by DS:SI.  Length includes NULL.
  4970                                  ;	Length is returned in CX
  4971                                  ;
  4972                                  	; MSDOS 3.3 & MSDOS 6.0
  4973 0000124F 31C9                    	xor	cx,cx
  4974                                  NXTCHAR:
  4975 00001251 AC                      	lodsb
  4976 00001252 41                      	inc	cx
  4977 00001253 08C0                    	or	al,al
  4978 00001255 75FA                    	jnz	short NXTCHAR
  4979 00001257 C3                      	retn
  4980                                  
  4981                                  SETUP_SEG:
  4982                                  ;
  4983                                  ; If the transient has been loaded in TranSeg, then we need to use that
  4984                                  ; segment for calls to routines in the transient area. Otherwise, the current
  4985                                  ; code segment is used
  4986                                  ; Segment returned in AX.
  4987                                  ;
  4988                                  	; MSDOS 3.3 & MSDOS 6.0
  4989 00001258 A1[E10A]                	mov	ax,[TRNSEG]
  4990 0000125B 803E[E30A]01            	cmp	byte [TRNMVFLG],1	; Has transient portion been moved
  4991 00001260 7411                    	je	short SETUP_END
  4992 00001262 53                      	push	bx
  4993 00001263 8CCB                    	mov	bx,cs
  4994                                  	;mov	ax,offset ResGroup:TranStart
  4995 00001265 B8[5015]                	mov	ax,TRANSTART
  4996 00001268 D1E8                    	shr	ax,1
  4997 0000126A D1E8                    	shr	ax,1
  4998 0000126C D1E8                    	shr	ax,1
  4999 0000126E D1E8                    	shr	ax,1
  5000 00001270 01D8                    	add	ax,bx
  5001 00001272 5B                      	pop	bx
  5002                                  SETUP_END:
  5003 00001273 C3                      	retn
  5004                                  
  5005                                  RPRINT:
  5006                                  	; MSDOS 3.3
  5007 00001274 50                      	push    ax
  5008 00001275 E8E0FF                  	call    SETUP_SEG
  5009 00001278 A3[E614]                	mov     [PRINTADD+2], ax
  5010                                  	;call	dword ptr PRINTADD
  5011 0000127B FF1E[E414]              	call	far [PRINTADD]
  5012 0000127F 58                      	pop     ax
  5013 00001280 C3                      	retn
  5014                                  
  5015                                  	; MSDOS 6.0
  5016                                  ;***	RPrintParse - display parse error message
  5017                                  ;
  5018                                  ;	ENTRY	DX = parse error #
  5019                                  ;
  5020                                  ;	EXIT	nothing
  5021                                  ;
  5022                                  ;	USED	flags
  5023                                  ;
  5024                                  ;	EFFECTS
  5025                                  ;	  Message is displayed on stdout.
  5026                                  ;
  5027                                  ;RPrintParse	proc
  5028                                  ;
  5029                                  ;	assume	ds:ResGroup,ss:ResGroup
  5030                                  ;
  5031                                  ;	push	dx				; preserve DX
  5032                                  ;	xchg	bx,dx				; bx = parse error #
  5033                                  ;						; dx = saved BX
  5034                                  ;	dec	bx				; bx = parse error index, from 0
  5035                                  ;	shl	bx,1				; bx = offset in word table
  5036                                  ;	mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  5037                                  ;	xchg	bx,dx				; dx = ptr to error msg
  5038                                  ;						; bx = restored
  5039                                  ;	call	RPrint				; print the message
  5040                                  ;	pop	dx				; restore DX
  5041                                  ;	ret
  5042                                  ;
  5043                                  ;RPrintParse	endp
  5044                                  
  5045                                  PATHCHRCMPR:
  5046                                  	; MSDOS 3.3
  5047 00001281 52                      	push	dx
  5048 00001282 8A16[FA14]              	mov	dl,[slash_chr]
  5049                                  	;cmp	byte [RSWITCHAR],'/'
  5050 00001286 3816[190C]                      cmp	[RSWITCHAR],dl
  5051 0000128A 7404                    	je	short RNOSLASHT
  5052                                  	;cmp	al,'/'
  5053 0000128C 38D0                    	cmp	al,dl
  5054 0000128E 7404                    	je	short RET41 ; zf = 1 
  5055                                  RNOSLASHT:
  5056                                          ;cmp	al,'\'
  5057 00001290 3A06[FB14]              	cmp	al,[bslash_chr]
  5058                                  RET41:
  5059 00001294 5A                      	pop	dx
  5060 00001295 C3                      	retn
  5061                                  
  5062                                  IFINDE:
  5063                                  	; MSDOS 3.3 & MSDOS 6.0
  5064 00001296 E80400                  	call	IFIND				; find the name
  5065 00001299 722D                    	jc	short IFIND2			; carry means not found
  5066 0000129B EB3A                    	jmp	short ISCASB1 			; scan for = sign
  5067                                  ;
  5068                                  ; on return of find1, es:di points to beginning of name
  5069                                  ;
  5070                                  IFIND:
  5071 0000129D FC                      	cld
  5072 0000129E E82800                  	call	ICOUNT0 			; cx = length of name
  5073 000012A1 8E06[050C]              	mov	es,[ENVIRSEG]
  5074 000012A5 31FF                    	xor	di,di
  5075                                  IFIND1:
  5076 000012A7 51                      	push	cx
  5077 000012A8 56                      	push	si
  5078 000012A9 57                      	push	di
  5079                                  IFIND11:
  5080 000012AA AC                      	lodsb
  5081 000012AB E83600                  	call	IUPCONV
  5082 000012AE 47                      	inc	di
  5083 000012AF 263A45FF                	cmp	al,[es:di-1]
  5084 000012B3 7502                    	jnz	short IFIND12
  5085 000012B5 E2F3                    	loop	IFIND11
  5086                                  IFIND12:
  5087 000012B7 5F                      	pop	di
  5088 000012B8 5E                      	pop	si
  5089 000012B9 59                      	pop	cx
  5090 000012BA 740C                    	jz	short IFIND2
  5091 000012BC 51                      	push	cx
  5092 000012BD E81C00                  	call	ISCASB2 			; scan for a nul
  5093 000012C0 59                      	pop	cx
  5094 000012C1 26803D00                	cmp	byte [es:di],0
  5095 000012C5 75E0                    	jnz	short IFIND1
  5096 000012C7 F9                      	stc					; indicate not found
  5097                                  IFIND2:
  5098 000012C8 C3                      	retn
  5099                                  
  5100                                  ICOUNT0:
  5101 000012C9 1E                      	push	ds
  5102 000012CA 07                      	pop	es
  5103 000012CB 89F7                    	mov	di,si
  5104                                  
  5105 000012CD 57                      	push	di				; count number of chars until "="
  5106 000012CE E80600                  	call	ISCASB1
  5107                                  	; 25/09/2018
  5108                                  	;jmp	short ICOUNTX
  5109                                  	;push	di				; count number of chars until nul
  5110                                  	;call	ISCASB2
  5111                                  
  5112                                  ;ICOUNTX:
  5113 000012D1 59                      	pop	cx
  5114 000012D2 29CF                    	sub	di,cx
  5115 000012D4 87F9                    	xchg	di,cx
  5116 000012D6 C3                      	retn
  5117                                  
  5118                                  ISCASB1:
  5119                                  	;mov	al,"="
  5120 000012D7 A0[F714]                	mov	al,[equal_sign]			; scan for an =
  5121 000012DA EB02                    	jmp	short ISCASBX
  5122                                  
  5123                                  ISCASB2:
  5124 000012DC 30C0                    	xor	al,al				; scan for a nul
  5125                                  
  5126                                  ISCASBX:
  5127 000012DE B90001                  	mov	cx,256 ; 100h
  5128 000012E1 F2AE                    	repnz	scasb
  5129 000012E3 C3                      	retn
  5130                                  
  5131                                  IUPCONV:
  5132                                  	; MSDOS 3.3
  5133                                          ;cmp	al,"a"
  5134 000012E4 3A06[F814]              	cmp	al,[letter_a]
  5135 000012E8 7208                            jb	short IRET22
  5136                                          ;cmp	al,"z"
  5137 000012EA 3A06[F914]                      cmp	al,[letter_z]
  5138 000012EE 7702                    	ja	short IRET22
  5139 000012F0 2C20                            sub	al,20h			; Lower-case changed to upper-case
  5140                                  IRET22:
  5141 000012F2 C3                              retn
  5142                                  
  5143                                  	; MSDOS 6.0
  5144                                  ; ****************************************************************
  5145                                  ; *
  5146                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  5147                                  ; *
  5148                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  5149                                  ; *		 the character in AL from the file upper case table
  5150                                  ; *		 in DOS if character if above  ascii 128, else
  5151                                  ; *		 subtracts 20H if between "a" and "z".
  5152                                  ; *
  5153                                  ; * INPUT:	 DS	      set to resident
  5154                                  ; *		 AL	      char to be upper cased
  5155                                  ; *		 FUCASE_ADDR  set to the file upper case table
  5156                                  ; *
  5157                                  ; * OUTPUT:	 AL	      upper cased character
  5158                                  ; *
  5159                                  ; ****************************************************************
  5160                                  ;
  5161                                  ;IupConv proc	near				
  5162                                  ;	assume	ds:ResGroup			;
  5163                                  ;
  5164                                  ;	cmp	al,80h				; see if char is > ascii 128
  5165                                  ;	jb	other_fucase			; no - upper case math
  5166                                  ;	sub	al,80h				; only upper 128 chars in table
  5167                                  ;	push	ds				;
  5168                                  ;	push	bx				;
  5169                                  ;	lds	bx,dword ptr fucase_addr+1		; get table address
  5170                                  ;	add	bx,2				; skip over first word
  5171                                  ;	xlat	ds:byte ptr [bx]			; convert to upper case
  5172                                  ;	pop	bx				;
  5173                                  ;	pop	ds				;
  5174                                  ;	jmp	short iupconv_end			; we finished - exit
  5175                                  ;
  5176                                  ;other_fucase:					;
  5177                                  ;	cmp	al,Lcasea			; if between "a" and "z",
  5178                                  ;	jb	iupconv_end			;     subtract 20h to get
  5179                                  ;	cmp	al,Lcasez			; upper case equivalent.
  5180                                  ;	ja	iupconv_end			;
  5181                                  ;	sub	al,20h				; Change lower-case to upper
  5182                                  ;
  5183                                  ;iupconv_end:					;
  5184                                  ;	ret
  5185                                  ;
  5186                                  ;IupConv endp					;
  5187                                  
  5188                                  
  5189                                  INIT_CONTC_SPECIALCASE:
  5190                                  	; MSDOS 3.3 & MSDOS 6.0
  5191                                  						; This routine is called if control-C
  5192 000012F3 83C406                  	add	sp,6				;  is type during the date/time prompt
  5193 000012F6 56                      	push	si				;  at initialization time.  The desired
  5194 000012F7 89D6                    	mov	si,dx				;  response is to make it look like the
  5195 000012F9 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  5196 000012FE 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  5197 000012FF CF                      	iret					;  a <CR> in the user's buffer, and
  5198                                  						;  returning directly to the user.
  5199                                  						; In this case the user is TCODE.
  5200                                  
  5201                                  ;=============================================================================
  5202                                  ; UNINIT.ASM, MSDOS 6.0 ,1991
  5203                                  ;=============================================================================
  5204                                  ; 24/09/2018 - Retro DOS v3.0
  5205                                  
  5206                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  5207                                  
  5208                                  ; TITLE	COMMAND Initialization messages
  5209                                  
  5210                                  ;INIT	SEGMENT PUBLIC PARA
  5211                                  
  5212                                  	; 25/09/2018
  5213                                  	; (15 bytes filler)
  5214 00001300 00                      	db 0
  5215                                  	;db "25/9/2018 ETAN"
  5216 00001301 30312F30332F323032-     	db "01/03/2023 ETAN" ; 01/03/2023	
  5216 0000130A 33204554414E       
  5217 00001310 00                      	db 0
  5218                                  
  5219                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  5220                                  	;dw 0
  5221                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  5222 00001311 0D0A                    	db 0Dh,0Ah
  5223 00001313 0D0A                    	db 0Dh,0Ah
  5224 00001315 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  5224 0000131E 285229204D532D444F-
  5224 00001327 532852292020566572-
  5224 00001330 73696F6E20332E3330 
  5225 00001339 0D0A                    	db 0Dh,0Ah
  5226 0000133B 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1987               '
  5226 00001344 20202020284329436F-
  5226 0000134D 70797269676874204D-
  5226 00001356 6963726F736F667420-
  5226 0000135F 436F72702031393831-
  5226 00001368 2D3139383720202020-
  5226 00001371 202020202020202020-
  5226 0000137A 2020               
  5227 0000137C 200D0A                  	db ' ',0Dh,0Ah
  5228 0000137F 202020202020202020-     	db '                                                   ',
  5228 00001388 202020202020202020-
  5228 00001391 202020202020202020-
  5228 0000139A 202020202020202020-
  5228 000013A3 202020202020202020-
  5228 000013AC 202020202020       
  5229 000013B2 0D0A00                  	db 0Dh,0Ah,0
  5230                                  
  5231 000013B5 20<rep 2Bh>             	times	43 db 20h
  5232                                  
  5233 000013E0 537065636966696564-     _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  5233 000013E9 20434F4D4D414E4420-
  5233 000013F2 736561726368206469-
  5233 000013FB 726563746F72792062-
  5233 00001404 61640D0A00         
  5234                                  BADCOMLKMES:
  5235 00001409 [E013]                  	dw _152Fh
  5236                                  
  5237 0000140B 537065636966696564-     _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  5237 00001414 20434F4D4D414E4420-
  5237 0000141D 736561726368206469-
  5237 00001426 726563746F72792062-
  5237 0000142F 616420616363657373-
  5237 00001438 2064656E6965640D0A-
  5237 00001441 00                 
  5238                                  BADCOMACCMSG:
  5239 00001442 [0B14]                  	dw _155Ah
  5240                                  
  5241 00001444 416363657373206465-     _1593h:	db 'Access denied',0Dh,0Ah,0
  5241 0000144D 6E6965640D0A00     
  5242                                  ACCDENERR:
  5243 00001454 [4414]                  	dw _1593h
  5244                                  
  5245 00001456 4F7574206F6620656E-     _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  5245 0000145F 7669726F6E6D656E74-
  5245 00001468 2073706163650D0A00 
  5246                                  OUTENVMSG:
  5247 00001471 [5614]                  	dw _15A5h
  5248                                  
  5249                                  BADVERMSG:
  5250 00001473 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah,'$'
  5250 0000147C 20444F532076657273-
  5250 00001485 696F6E0D0A24       
  5251                                  
  5252                                  BADENVSIZMSG:
  5253 0000148B 496E76616C69642065-     	db 'Invalid environment size specified',0Dh,0Ah,'$'
  5253 00001494 6E7669726F6E6D656E-
  5253 0000149D 742073697A65207370-
  5253 000014A6 656369666965640D0A-
  5253 000014AF 24                 
  5254                                  
  5255                                  HEADERPTR:
  5256 000014B0 [1113]                  	dw COPYRIGHTMSG
  5257                                  
  5258                                  ICONDEV:
  5259 000014B2 2F4445562F                      db '/DEV/'
  5260 000014B7 434F4E                  	db 'CON'
  5261 000014BA 000000000000            	db 0,0,0,0,0,0		; Room for 8 char device	
  5262                                  BADCSPFL:
  5263 000014C0 00                      	db 0
  5264                                  COMSPECT:
  5265 000014C1 2F434F4D4D414E442E-     	db '/COMMAND.COM',0
  5265 000014CA 434F4D00           
  5266 000014CE 00                      	db 0
  5267                                  AUTOBAT:
  5268 000014CF 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0 
  5268 000014D8 45432E42415400     
  5269                                  PRDATTM:
  5270 000014DF FF                      	db -1 ; 0FFh		 ; Init not to prompt for date time
  5271                                  INITADD:
  5272 000014E0 00000000                	dd 0
  5273                                  	;dw 0
  5274                                  	;dw 0
  5275                                  PRINTADD:
  5276 000014E4 4034                    	dw PRINTF_INIT
  5277 000014E6 0000                    	dw 0
  5278                                  TRIAGEADD:
  5279 000014E8 B61E                    	dw TRIAGE_INIT
  5280 000014EA 0000                    	dw 0
  5281                                  CHUCKENV:
  5282 000014EC 00                      	db 0
  5283                                  COMSPOFFSET:
  5284                                  ECOMLOC:
  5285                                  	;dw 0Eh
  5286                                  	;dw offset ENVIRONMENT:ECOMSPEC-10h
  5287 000014ED 0E00                    	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  5288                                  COMSPSTRING:
  5289 000014EF 434F4D535045433D        	db 'COMSPEC='
  5290                                  equal_sign:
  5291 000014F7 3D                      	db '='
  5292                                  letter_a:
  5293 000014F8 61                      	db 'a'
  5294                                  letter_z:
  5295 000014F9 7A                      	db 'z'
  5296                                  slash_chr:
  5297 000014FA 2F                      	db '/'
  5298                                  bslash_chr:
  5299 000014FB 5C                      	db '\'
  5300                                  space_chr:
  5301 000014FC 20                      	db 20h
  5302                                  letter_p:
  5303 000014FD 70                      	db 'p'
  5304                                  letter_d:
  5305 000014FE 64                      	db 'd'
  5306                                  letter_c:
  5307 000014FF 63                      	db 'c'
  5308                                  letter_A:
  5309 00001500 41                      	db 'A'
  5310                                  ENVSIZ:
  5311 00001501 0000                    	dw 0
  5312                                  ENVMAX:
  5313 00001503 0000                    	dw 0
  5314                                  OLDENV:
  5315 00001505 0000                    	dw 0
  5316                                  USEDENV:
  5317 00001507 0000                    	dw 0
  5318                                  INITEND:
  5319 00001509 0000                    	dw 0
  5320                                  TRNSIZE:
  5321 0000150B 0000                    	dw 0
  5322                                  RESETENV:
  5323 0000150D 0000                    	dw 0
  5324                                  
  5325                                  ;INIT	ENDS
  5326                                  
  5327                                  ;	END
  5328                                  
  5329                                  ;-----------------------------------------------------------------------------
  5330                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  5331                                  ;-----------------------------------------------------------------------------
  5332                                  
  5333                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  5334                                  ; 12/01/2023
  5335 0000150F 526574726F20444F53-     db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018-2023]"
  5335 00001518 2076332E3020434F4D-
  5335 00001521 4D414E442E434F4D20-
  5335 0000152A 6279204572646F6761-
  5335 00001533 6E2054616E205B3230-
  5335 0000153C 31382D323032335D   
  5336 00001544 00                      db	0
  5337                                  
  5338                                  ;-----------------------------------------------------------------------------
  5339                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  5340                                  ;-----------------------------------------------------------------------------
  5341                                  
  5342                                  ;TAIL    SEGMENT PUBLIC PARA
  5343                                  ;        ORG     0
  5344                                  ;TRANSTART       LABEL   WORD
  5345                                  ;TAIL    ENDS
  5346                                  
  5347 00001545 90<rep Bh>              ALIGN 16  ; 25/09/2018
  5348                                  
  5349                                  ;TRANSTART:
  5350                                  
  5351                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  5352                                  ;	times	128 db 0	
  5353                                  
  5354                                  ;-----------------------------------------------------------------------------
  5355                                  ; SEGMENT - TRANSCODE
  5356                                  ;-----------------------------------------------------------------------------
  5357                                  
  5358                                  TRANGROUP: ; 21/04/2018
  5359                                  
  5360                                  ;=============================================================================
  5361                                  ; TRANCODE.ASM
  5362                                  ;=============================================================================
  5363                                  ; 24/09/2018 - Retro DOS v3.0
  5364                                  
  5365                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  5366                                  
  5367                                  ; 21/04/2018 - Retro DOS v2.0
  5368                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  5369                                  ; (these values must be changed when transcom.s source code is changed
  5370                                  ; and data offsets are changed)
  5371                                  ;
  5372                                  ; 30/04/2018
  5373                                  ; 29/04/2018
  5374                                  
  5375                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5376                                  ;COMMAND      EQU  012CH
  5377                                  ;DATINIT      EQU  2091H
  5378                                  ;HEADCALL     EQU  428FH
  5379                                  ;TRANSPACEEND EQU  4D5CH
  5380                                  ;TRANDATAEND  EQU  3F44H
  5381                                  
  5382                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5383                                  ;TRIAGE_INIT  EQU  1F15H
  5384                                  ;PRINTF_INIT  EQU  34E0H 
  5385                                  
  5386                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  5387                                  
  5388                                  ;TPA	EQU  4293H
  5389                                  ;TRNLEN	EQU  04D6H
  5390                                  
  5391                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  5392                                  COMMAND      EQU  012CH
  5393                                  ;GETEXTERRNUM EQU 1ECCH ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  5394                                  ;TRIAGE_INIT EQU  1EF3H
  5395                                  ;DATINIT     EQU  206FH
  5396                                  ; 01/03/2023
  5397                                  GETEXTERRNUM EQU  1E8FH
  5398                                  TRIAGE_INIT  EQU  1EB6H
  5399                                  DATINIT	     EQU  2016H		
  5400                                  PRINTF_INIT  EQU  3440H
  5401                                  TRANDATAEND  EQU  3E65H
  5402                                  HEADCALL     EQU  41AFH
  5403                                  TRANSPACEEND EQU  4C7CH
  5404                                  
  5405                                  ;-----------------------------------------------------------------------------
  5406                                  ;START OF TRANSIENT PORTION
  5407                                  ;This code is loaded at the end of memory and may be overwritten by
  5408                                  ;memory-intensive user programs.
  5409                                  ;-----------------------------------------------------------------------------
  5410                                  
  5411                                  ;TRANSTART EQU $
  5412                                  ; 29/09/2018 
  5413                                  TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  5414                                  
  5415                                  ; 25/09/2018
  5416                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  5417                                  ;
  5418                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  5419                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  5420                                  ;
  5421                                  TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  5422                                  ;
  5423                                  
  5424                                  ;COMTRANS:
  5425                                  
  5426                                  ; 20/10/2018 - Retro DOS v3.0	
  5427 00001550 <bin 4C7Ch>             INCBIN	"TRANCOM3.BIN"
  5428                                  
  5429                                  ;COMLEN	EQU $-COMTRANS	; End of COMMAND load.
  5430                                  
  5431                                  ; 29/04/2018
  5432                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  5433                                  ;
  5434                                  ;TIMES BSS_SIZE db 0
  5435                                  ;
  5436                                  ;COMLEN	EQU $-COMTRANS	; 30/04/2018
  5437                                  
  5438                                  ;COMMANDCOMSIZE equ $ - 100h
