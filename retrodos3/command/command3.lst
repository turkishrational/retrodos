     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 24/02/2023 (BugFix: 12/01/2023) ((Previous: 20/10/2018))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11 
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  
    43                                  ;============================================================================
    44                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    45                                  ;============================================================================
    46                                  ; 21/09/2018 - Retro DOS v3.0
    47                                  
    48                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    49                                  ;BREAK <system call definitions>
    50                                  
    51                                  ;
    52                                  ;	Microsoft Confidential
    53                                  ;	Copyright (C) Microsoft Corporation 1991
    54                                  ;	All Rights Reserved.
    55                                  ;
    56                                  
    57                                  ;SUBTTL	system call definitions
    58                                  ;PAGE
    59                                  
    60                                  Abort				EQU 0	;  0	  0
    61                                  STD_CON_INPUT			EQU 1	;  1	  1
    62                                  Std_Con_Output			EQU 2	;  2	  2
    63                                  Std_Aux_Input			EQU 3	;  3	  3
    64                                  Std_Aux_Output			EQU 4	;  4	  4
    65                                  Std_Printer_Output		EQU 5	;  5	  5
    66                                  Raw_Con_IO			EQU 6	;  6	  6
    67                                  RAW_CON_INPUT			EQU 7	;  7	  7
    68                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    69                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    70                                  Std_Con_String_Input		EQU 10	; 10	  A
    71                                  Std_Con_Input_Status		EQU 11	; 11	  B
    72                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    73                                  DISK_RESET			EQU 13	; 13	  D
    74                                  Set_Default_Drive		EQU 14	; 14	  E
    75                                  FCB_Open			EQU 15	; 15	  F
    76                                  FCB_Close			EQU 16	; 16	 10
    77                                  Dir_Search_First		EQU 17	; 17	 11
    78                                  Dir_Search_Next 		EQU 18	; 18	 12
    79                                  FCB_Delete			EQU 19	; 19	 13
    80                                  FCB_Seq_Read			EQU 20	; 20	 14
    81                                  FCB_Seq_Write			EQU 21	; 21	 15
    82                                  FCB_Create			EQU 22	; 22	 16
    83                                  FCB_Rename			EQU 23	; 23	 17
    84                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    85                                  Set_DMA 			EQU 26	; 26	 1A
    86                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    87                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    88                                  ;									   ;
    89                                  Get_Default_DPB 		EQU 31	; 31	 1F
    90                                  ;									   ;
    91                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    92                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    93                                  FCB_Random_Read 		EQU 33	; 33	 21
    94                                  FCB_Random_Write		EQU 34	; 34	 22
    95                                  Get_FCB_File_Length		EQU 35	; 35	 23
    96                                  Get_FCB_Position		EQU 36	; 36	 24
    97                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
    98                                  Create_Process_Data_Block	EQU 38	; 38	 26
    99                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   100                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   101                                  Parse_File_Descriptor		EQU 41	; 41	 29
   102                                  Get_Date			EQU 42	; 42	 2A
   103                                  Set_Date			EQU 43	; 43	 2B
   104                                  Get_Time			EQU 44	; 44	 2C
   105                                  Set_Time			EQU 45	; 45	 2D
   106                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   107                                  ; Extended functionality group
   108                                  Get_DMA 			EQU 47	; 47	 2F
   109                                  GET_VERSION			EQU 48	; 48	 30
   110                                  Keep_Process			EQU 49	; 49	 31
   111                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;									   ;
   114                                  Get_DPB 			EQU 50	; 50	 32
   115                                  ;									   ;
   116                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   117                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   118                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   119                                  Get_InDOS_Flag			EQU 52	; 52	 34
   120                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   121                                  Get_Drive_Freespace		EQU 54	; 54	 36
   122                                  CHAR_OPER			EQU 55	; 55	 37
   123                                  International			EQU 56	; 56	 38
   124                                  ;   Directory Group
   125                                  MKDir				EQU 57	; 57	 39
   126                                  RMDir				EQU 58	; 58	 3A
   127                                  CHDir				EQU 59	; 59	 3B
   128                                  ;   File Group
   129                                  Creat				EQU 60	; 60	 3C
   130                                  OPEN				EQU 61	; 61	 3D
   131                                  CLOSE				EQU 62	; 62	 3E
   132                                  READ				EQU 63	; 63	 3F
   133                                  Write				EQU 64	; 64	 40
   134                                  Unlink				EQU 65	; 65	 41
   135                                  LSEEK				EQU 66	; 66	 42
   136                                  CHMod				EQU 67	; 67	 43
   137                                  IOCTL				EQU 68	; 68	 44
   138                                  XDUP				EQU 69	; 69	 45
   139                                  XDup2				EQU 70	; 70	 46
   140                                  Current_Dir			EQU 71	; 71	 47
   141                                  ;    Memory Group
   142                                  ALLOC				EQU 72	; 72	 48
   143                                  DEALLOC				EQU 73	; 73	 49
   144                                  SETBLOCK			EQU 74	; 74	 4A
   145                                  ;    Process Group
   146                                  Exec				EQU 75	; 75	 4B
   147                                  EXIT				EQU 76	; 76	 4C
   148                                  WAITPROCESS			EQU 77	; 77	 4D
   149                                  Find_First			EQU 78	; 78	 4E
   150                                  ;   Special Group
   151                                  Find_Next			EQU 79	; 79	 4F
   152                                  ; SPECIAL SYSTEM GROUP
   153                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   154                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   155                                  ;									   ;
   156                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   157                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   158                                  Get_In_Vars			EQU 82	; 82	 52
   159                                  SetDPB				EQU 83	; 83	 53
   160                                  ;									   ;
   161                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   162                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   163                                  Get_Verify_On_Write		EQU 84	; 84	 54
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   166                                  ;									   ;
   167                                  Dup_PDB 			EQU 85	; 85	 55
   168                                  ;									   ;
   169                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   170                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   171                                  Rename				EQU 86	; 86	 56
   172                                  File_Times			EQU 87	; 87	 57
   173                                  AllocOper			EQU 88	; 88	 58
   174                                  ; Network extention system calls
   175                                  GetExtendedError		EQU 89	; 89	 59
   176                                  CreateTempFile			EQU 90	; 90	 5A
   177                                  CreateNewFile			EQU 91	; 91	 5B
   178                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   179                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   180                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   181                                  ;									   ;
   182                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   183                                  					;	    CloseByName, CloseUser,
   184                                  					;	    CloseUserProcess,
   185                                  					;	    GetOpenFileList
   186                                  ;									   ;
   187                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   188                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   189                                  UserOper			EQU 94	; 94	 5E Get and Set
   190                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   191                                  xNameTrans			EQU 96	; 96	 60
   192                                  PathParse			EQU 97	; 97	 61
   193                                  GetCurrentPSP			EQU 98	; 98	 62
   194                                  Hongeul 			EQU 99	; 99	 63
   195                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   196                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   197                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   198                                  ;									   ;
   199                                  Set_Printer_Flag		EQU 100 ; 100	 64
   200                                  ;									   ;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   203                                  GetExtCntry			EQU 101 ; 101	 65
   204                                  GetSetCdPg			EQU 102 ; 102	 66
   205                                  ExtHandle			EQU 103 ; 103	 67
   206                                  Commit				EQU 104 ; 104	 68
   207                                  GetSetMediaID			EQU 105 ; 105	 69
   208                                  IFS_IOCTL			EQU 107 ; 107	 6B
   209                                  ExtOpen 			EQU 108 ; 108	 6C
   210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   211                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   212                                  ;                                                                          ;
   213                                  ;ifdef ROMEXEC
   214                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   215                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   216                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   217                                  ;endif
   218                                  ;                                                                          ;
   219                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   220                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   221                                  ;
   222                                  ;
   223                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   224                                  OEM_C1				EQU 249 ; 249	 F9
   225                                  OEM_C2				EQU 250 ; 250	 FA
   226                                  OEM_C3				EQU 251 ; 251	 FB
   227                                  OEM_C4				EQU 252 ; 252	 FC
   228                                  OEM_C5				EQU 253 ; 253	 FD
   229                                  OEM_C6				EQU 254 ; 254	 FE
   230                                  OEM_C7				EQU 255 ; 255	 FF
   231                                  
   232                                  ;============================================================================
   233                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   234                                  ;============================================================================
   235                                  ; 21/09/2018 - Retro DOS v3.0
   236                                  
   237                                  ;BREAK <Control character definitions>
   238                                  
   239                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   240                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   241                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   242                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   243                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   244                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   245                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   246                                  c_HT	    EQU     09h 		; ^I ASCII tab
   247                                  
   248                                  ;============================================================================
   249                                  ; DIRENT.INC, MSDOS 6.0, 1991
   250                                  ;============================================================================
   251                                  ; 21/09/2018 - Retro DOS v3.0
   252                                  
   253                                  ;Break <Directory entry>
   254                                  
   255                                  ;	NOTE:  These offsets are also used in the DTA for
   256                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   257                                  ;	with the FCB filename field, and the rest of the
   258                                  ;	DIR_ENTRY fields follow. -DavidOls
   259                                  
   260                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   261                                  ;
   262                                  ;	+---------------------------+
   263                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   264                                  ;	+---------------------------+
   265                                  ;	|     (BYTE) attributes     |	    11	    B
   266                                  ;	+---------------------------+
   267                                  ;	|    (10 BYTE) reserved     |	    12	    C
   268                                  ;	+---------------------------+
   269                                  ;	| (WORD) time of last write |	    22	    16
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) date of last write |	    24	    18
   272                                  ;	+---------------------------+
   273                                  ;	|   (WORD) First cluster    |	    26	    1A
   274                                  ;	+---------------------------+
   275                                  ;	|     (DWORD) file size     |	    28	    1C
   276                                  ;	+---------------------------+
   277                                  ;
   278                                  ;   First byte of filename  = E5 -> free directory entry
   279                                  ;			    = 00 -> end of allocated directory
   280                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   281                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   282                                  ;
   283                                  
   284                                  STRUC DIR_ENTRY
   285 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   286 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   287 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   288 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   289 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   290 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   291 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   292 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   293 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   294 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   295 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   296                                  .size:
   297                                  
   298                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   299                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   300                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   301                                  ;	    this field is zero for subdirectory files.
   302                                  
   303                                  ENDSTRUC
   304                                  
   305                                  ATTR_READ_ONLY	equ	 1h
   306                                  ATTR_HIDDEN	equ	 2h
   307                                  ATTR_SYSTEM	equ	 4h
   308                                  ATTR_VOLUME_ID	equ	 8h
   309                                  ATTR_DIRECTORY	equ	10h
   310                                  ATTR_ARCHIVE	equ	20h
   311                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   312                                  				;   NO directory entry on a disk EVER
   313                                  				;   has this bit set. It is set non-zero
   314                                  				;   when a device is found by GETPATH
   315                                  
   316                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   317                                  				; OR of hard attributes for FINDENTRY
   318                                  
   319                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   320                                  				; ignore this(ese) attribute(s) during
   321                                  				; search first/next
   322                                  
   323                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   324                                  				; changeable via CHMOD
   325                                  
   326                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   327                                  
   328                                  ;============================================================================
   329                                  ; ERROR.INC, MSDOS 6.0, 1991
   330                                  ;============================================================================
   331                                  ; 21/09/2018 - Retro DOS v3.0
   332                                  
   333                                  ;**	ERROR.INC - DOS Error Codes
   334                                  ;
   335                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   336                                  ;    return error codes through AX.	If an error occurred then
   337                                  ;    the carry bit will be set and the error code is in AX.	If no error
   338                                  ;    occurred then the carry bit is reset and AX contains returned info.
   339                                  ;
   340                                  ;    Since the set of error codes is being extended as we extend the operating
   341                                  ;    system, we have provided a means for applications to ask the system for a
   342                                  ;    recommended course of action when they receive an error.
   343                                  ;
   344                                  ;    The GetExtendedError system call returns a universal error, an error
   345                                  ;    location and a recommended course of action.	The universal error code is
   346                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   347                                  ;    is issued.
   348                                  
   349                                  
   350                                  ;	2.0 error codes
   351                                  
   352                                  error_invalid_function		EQU	1
   353                                  ERROR_FILE_NOT_FOUND		EQU	2
   354                                  error_path_not_found		EQU	3
   355                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   356                                  ERROR_ACCESS_DENIED		EQU	5
   357                                  error_invalid_handle		EQU	6
   358                                  error_arena_trashed		EQU	7
   359                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   360                                  error_invalid_block		EQU	9
   361                                  error_bad_environment		EQU	10
   362                                  ERROR_BAD_FORMAT		EQU	11
   363                                  error_invalid_access		EQU	12
   364                                  error_invalid_data		EQU	13
   365                                  ;**** reserved			EQU	14	; *****
   366                                  error_invalid_drive		EQU	15
   367                                  error_current_directory 	EQU	16
   368                                  error_not_same_device		EQU	17
   369                                  error_no_more_files		EQU	18
   370                                  
   371                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   372                                  
   373                                  ERROR_WRITE_PROTECT		EQU	19
   374                                  error_bad_unit			EQU	20
   375                                  error_not_ready 		EQU	21
   376                                  error_bad_command		EQU	22
   377                                  error_CRC			EQU	23
   378                                  error_bad_length		EQU	24
   379                                  error_Seek			EQU	25
   380                                  error_not_DOS_disk		EQU	26
   381                                  error_sector_not_found		EQU	27
   382                                  error_out_of_paper		EQU	28
   383                                  error_write_fault		EQU	29
   384                                  error_read_fault		EQU	30
   385                                  ERROR_GEN_FAILURE		EQU	31
   386                                  
   387                                  ;	the new 3.0 error codes reported through INT 24
   388                                  
   389                                  error_sharing_violation 	EQU	32
   390                                  error_lock_violation		EQU	33
   391                                  error_wrong_disk		EQU	34
   392                                  ERROR_FCB_UNAVAILABLE		EQU	35
   393                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   394                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   395                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   396                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   397                                  
   398                                  ;	New OEM network-related errors are 50-79
   399                                  
   400                                  error_not_supported		EQU	50
   401                                  
   402                                  error_net_access_denied		EQU	65	;M028
   403                                  
   404                                  ;	End of INT 24 reportable errors
   405                                  
   406                                  error_file_exists		EQU	80
   407                                  error_DUP_FCB			EQU	81	; *****
   408                                  error_cannot_make		EQU	82
   409                                  error_FAIL_I24			EQU	83
   410                                  
   411                                  ;	New 3.0 network related error codes
   412                                  
   413                                  error_out_of_structures 	EQU	84
   414                                  error_Already_assigned		EQU	85
   415                                  error_invalid_password		EQU	86
   416                                  error_invalid_parameter 	EQU	87
   417                                  error_NET_write_fault		EQU	88
   418                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   419                                  
   420                                  ;============================================================================
   421                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   422                                  ;============================================================================
   423                                  ; 22/09/2018 - Retro DOS v3.0
   424                                  
   425                                  ;**	DevSym.inc - Device Symbols
   426                                  
   427                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   428                                  
   429                                  STRUC SYSDEV
   430 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   431 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   432 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   433 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   434 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   435                                  .size:
   436                                  ENDSTRUC
   437                                  
   438                                  ; 24/09/2018
   439                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   440                                  
   441                                  ;============================================================================
   442                                  ; CURDIR.INC, MSDOS 6.0, 1991
   443                                  ;============================================================================
   444                                  ; 21/09/2018 - Retro DOS v3.0
   445                                  
   446                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   447                                  
   448                                  ;============================================================================
   449                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   450                                  ;============================================================================
   451                                  ; 21/09/2018 - Retro DOS v3.0
   452                                  
   453                                  ;/*
   454                                  ; *                      Microsoft Confidential
   455                                  ; *                      Copyright (C) Microsoft Corporation 1991
   456                                  ; *                      All Rights Reserved.
   457                                  ; */
   458                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   459                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   460                                  ;*************************************
   461                                  ; COMMAND EQUs which are not switch dependant
   462                                  
   463                                  ;		include	curdir.inc	; to get DIRSTRLEN
   464                                  ;		Note dossym.inc must already have been included!
   465                                  
   466                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   467                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   468                                  
   469                                  SYM		EQU	">"
   470                                  
   471                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   472                                  
   473                                  NORMPERLIN	EQU	1
   474                                  WIDEPERLIN	EQU	5
   475                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   476                                  BatLen		EQU	32		; buffer for batch files
   477                                  YES_ECHO	EQU	1		; echo line
   478                                  NO_ECHO 	EQU	0		; don't echo line
   479                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   480                                  call_in_progress EQU	1		; indicate we're in the CALL command
   481                                  length_call	EQU	4		; length of CALL
   482                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   483                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   484                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   485                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   486                                  nullcommand	EQU    1		; no command on command line
   487                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   488                                  end_of_line_out EQU	0		;AN000; end of line for output
   489                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   490                                  result_number	EQU	1		;AN000; number returned from parser
   491                                  result_string	EQU	3		;AN000; string returned from parser
   492                                  result_filespec EQU	5		;AN000; filespec returned from parser
   493                                  result_drive	EQU	6		;AN000; drive returned from parser
   494                                  result_date	EQU	7		;AN000; date returned from parser
   495                                  result_time	EQU	8		;AN000; time returned from parser
   496                                  result_no_error EQU	0		;AN000; no error returned from parser
   497                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   498                                  util_msg_class	EQU	-1		;AN000; message class for utility
   499                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   500                                  parse_msg_class EQU	2		;AN000; message class for parse error
   501                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   502                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   503                                  colon_char	EQU	":"             ;AN000; colon character
   504                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   505                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   506                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   507                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   508                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   509                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   510                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   511                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   512                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   513                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   514                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   515                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   516                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   517                                  parm_block_size equ	11		;AN000; size of message subst block
   518                                  blank		equ	" "             ;AN000; blank character
   519                                  no_subst	equ	0		;AN000; no substitutions for messages
   520                                  one_subst	equ	1		;AN000; one substitution for messages
   521                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   522                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   523                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   524                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   525                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   526                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   527                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   528                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   529                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   530                                  capital_A	equ	'A'             ;AC000;
   531                                  vbar		equ	'|'             ;AC000;
   532                                  labracket	equ	'<'             ;AC000;
   533                                  rabracket	equ	'>'             ;AC000;
   534                                  dollar		equ	'$'             ;AC000;
   535                                  lparen		equ	'('             ;AC000;
   536                                  rparen		equ	')'             ;AC000;
   537                                  nullrparen	equ	29h		;AC000;
   538                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   539                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   540                                  star		equ	'*'             ;AC000;
   541                                  plus_chr	equ	'+'             ;AC000;
   542                                  small_a 	equ	'a'             ;AC000;
   543                                  small_z 	equ	'z'             ;AC000;
   544                                  dot_chr 	equ	'.'             ;AC000;
   545                                  tab_chr 	equ	9		;AN032;
   546                                  equal_chr	equ	'='             ;AN032;
   547                                  semicolon	equ	';'             ;AN049;
   548                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   549                                  dot_colon	equ	2e3ah		;AC000; '.:'
   550                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   551                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   552                                  AppendInstall	equ	0B700H		;AN020; append install check
   553                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   554                                  AppendGetState	equ	0B706H		;AN020; append get current state
   555                                  AppendSetState	equ	0B707H		;AN020; append set current state
   556                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   557                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   558                                  
   559                                  ;*************************************
   560                                  ;* PARSE ERROR MESSAGES
   561                                  ;*************************************
   562                                  
   563                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   564                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   565                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   566                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   567                                  
   568                                  ;*************************************
   569                                  ;* EQUATES FOR MESSAGE RETRIEVER
   570                                  ;*************************************
   571                                  
   572                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   573                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   574                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   575                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   576                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   577                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   578                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   579                                  
   580                                  ;*********************************
   581                                  ;* EQUATES FOR INT 10H
   582                                  ;*********************************
   583                                  
   584                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   585                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   586                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   587                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   588                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   589                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   590                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   591                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   592                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   593                                  
   594                                  AltPipeChr	equ	"|"             ; alternate pipe character
   595                                  
   596                                  FCB		EQU	5CH
   597                                  
   598                                  STRUC VARSTRUC
   599 00000000 ??                      .ISDIR:		RESB	1
   600 00000001 ??                      .SIZ:		RESB	1
   601 00000002 ????                    .TTAIL:		RESW	1
   602 00000004 ??                      .INFO:		RESB	1
   603 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   604                                  .size:
   605                                  ENDSTRUC
   606                                  ;
   607                                  ; Flags for internal command parsing
   608                                  ;
   609                                  fCheckDrive	equ	00000001b	; validate drive letter
   610                                  fSwitchAllowed	equ	00000010b	; switches allowed
   611                                  fLimitHelp	equ	00000100b	; /? must appear alone
   612                                  
   613                                  ;
   614                                  ; Test switches
   615                                  ;
   616                                  fParse		EQU	0001h		; display results of parseline
   617                                  
   618                                  ;
   619                                  ; Batch segment structure
   620                                  ;
   621                                  ;   BYTE    type of segment
   622                                  ;   BYTE    echo state of parent on entry to batch file
   623                                  ;   WORD    segment of last batch file
   624                                  ;   WORD    segment for FOR command
   625                                  ;   BYTE    FOR flag state on entry to batch file
   626                                  ;   DWORD   offset for next line
   627                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   628                                  ;   ASCIZ   file name (with . and ..)
   629                                  ;   BYTES   CR-terminated parameters
   630                                  ;   BYTE    0 flag to indicate end of parameters
   631                                  ;
   632                                  
   633                                  BATCHTYPE   equ 0
   634                                  
   635                                  STRUC BATCHSEGMENT
   636 00000000 ??                      .BatType:	RESB	1		; signature
   637 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   638                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   639 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   640 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   641 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   642 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   643 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   644 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   645                                  .SIZE:
   646                                  ENDSTRUC
   647                                  
   648                                  ANULL		equ	0		; terminates an argv string
   649                                  ARGMAX		equ	64		; max args on a command line
   650                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   651                                  tplen		equ	64		; max size of one argument
   652                                  arg_cnt_error	equ	1		; number of args > MAXARG
   653                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   654                                  
   655                                  STRUC ARGV_ELE				; elements in the argv array
   656 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   657 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   658 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   659 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   660 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   661 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   662                                  .SIZE:
   663                                  ENDSTRUC
   664                                  
   665                                  STRUC ARG_UNIT
   666 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   667 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   668 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   669 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   670 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   671                                  .SIZE:
   672                                  ENDSTRUC
   673                                  
   674                                  ; Equates for initialization
   675                                  ;
   676                                  INITINIT	equ	01h		; initialization in progress
   677                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   678                                  INITCTRLC	equ	04h		; already in ^C handler
   679                                  
   680                                  ;=============================================================================
   681                                  ; PDB.INC, MSDOS 6.0, 1991
   682                                  ;=============================================================================
   683                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   684                                  
   685                                  ;**	Process data block (otherwise known as program header)
   686                                  
   687                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   688                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   689                                  ;	for use.
   690                                  
   691                                  FILPERPROC	EQU     20
   692                                  
   693                                  struc PDB	; Process_data_block
   694 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   695 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   696 00000004 ??                                      resb 1
   697 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   698 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   699 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   700 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   701 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   702 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   703 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   704 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   705 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   706 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   707 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   708 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   709 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   710 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   711 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   712 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   713 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   714 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   715                                  				;  an extended FCB
   716                                  ;endstruc 	; MSDOS 3.3
   717                                  	  	; MSDOS 6.0
   718 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   719 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   720 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   721 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   722                                  endstruc
   723                                  
   724                                  ;=============================================================================
   725                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   726                                  ;=============================================================================
   727                                  ; 24/09/2018 - Retro DOS v3.0
   728                                  
   729                                  ;major_version       equ     6       ;Major DOS version
   730                                  ;minor_version       equ     00      ;Minor DOS Version
   731                                  
   732                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   733                                  
   734                                  ; MSDOS 3.3 COMMAND.COM
   735                                  MAJOR_VERSION	EQU 3
   736                                  MINOR_VERSION	EQU 30
   737                                  
   738                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   739                                  
   740                                  ;-----------------------------------------------------------------------------
   741                                  ; 21/09/2018
   742                                  ;-----------------------------------------------------------------------------
   743                                  ; Retro DOS v3.0 NOTE:  
   744                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   745                                  ;	with minor modifications which are done by me (Erdogan Tan).
   746                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   747                                  ;	source code files (written by using MASM syntax).
   748                                  ;-----------------------------------------------------------------------------
   749                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   750                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   751                                  ;----------------------------------------------------------------------------- 	
   752                                  
   753                                  ;=============================================================================
   754                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   755                                  ;=============================================================================
   756                                  ; 21/09/2018 - Retro DOS v3.0
   757                                  
   758                                  ;	page ,132
   759                                  ;	title	COMMAND - resident code for COMMAND.COM
   760                                  ;	name	COMMAND
   761                                  
   762                                  ;/*
   763                                  ; *                      Microsoft Confidential
   764                                  ; *                      Copyright (C) Microsoft Corporation 1991
   765                                  ; *                      All Rights Reserved.
   766                                  ; */
   767                                  
   768                                  ;*****************************************************************************
   769                                  ;
   770                                  ; MODULE:	       COMMAND.COM
   771                                  ;
   772                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   773                                  ;
   774                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   775                                  ;		       parts.  First is the resident portion, which includes
   776                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   777                                  ;		       error), and 2EH (command line execute); it also has
   778                                  ;		       code to test and, if necessary, reload the transient
   779                                  ;		       portion. Following the resident is the init code, which
   780                                  ;		       is overwritten after use.  Then comes the transient
   781                                  ;		       portion, which includes all command processing (whether
   782                                  ;		       internal or external).  The transient portion loads at
   783                                  ;		       the end of physical memory, and it may be overlayed by
   784                                  ;		       programs that need as much memory as possible. When the
   785                                  ;		       resident portion of command regains control from a user
   786                                  ;		       program, a check sum is performed on the transient
   787                                  ;		       portion to see if it must be reloaded.  Thus programs
   788                                  ;		       which do not need maximum memory will save the time
   789                                  ;		       required to reload COMMAND when they terminate.
   790                                  ;
   791                                  ; ENTRY POINT:	       PROGSTART
   792                                  ;
   793                                  ; INPUT:	       command line at offset 81H
   794                                  ;
   795                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   796                                  ;		       from a secondary command processor via the EXIT
   797                                  ;		       internal command.
   798                                  ;
   799                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   800                                  ;		       hang the system.
   801                                  ;
   802                                  ; INTERNAL REFERENCES:
   803                                  ;
   804                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   805                                  ;		       (COMMAND.DOC)
   806                                  ;
   807                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   808                                  ;		       (COMMAND.DOC)
   809                                  ;
   810                                  ; EXTERNAL REFERENCES:
   811                                  ;
   812                                  ;      ROUTINES:       none
   813                                  ;
   814                                  ;      DATA AREAS:     none
   815                                  ;
   816                                  ;*****************************************************************************
   817                                  ;
   818                                  ;			      REVISION HISTORY
   819                                  ;			      ----------------
   820                                  ;
   821                                  ; DOS 1.00 to DOS 3.30
   822                                  ; --------------------------
   823                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   824                                  ;
   825                                  ; REV 1.17
   826                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   827                                  ;	       resident since the EXELOAD may have overwritten the transient.
   828                                  ;
   829                                  ; REV 1.18
   830                                  ;    05/21/82  IBM version always looks on drive A
   831                                  ;	       MSVER always looks on default drive
   832                                  ;
   833                                  ; REV 1.19
   834                                  ;    06/03/82  Drive spec now entered in command line
   835                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   836                                  ;	       (print volume label)
   837                                  ;
   838                                  ; REV 1.20
   839                                  ;    06/09/82  Prints "directory" after directories
   840                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   841                                  ;
   842                                  ; REV 1.50
   843                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   844                                  ;	       do it right.
   845                                  ;
   846                                  ; REV 1.70
   847                                  ;	       EXEC used to fork off new processes
   848                                  ;
   849                                  ; REV 1.80
   850                                  ;	       C switch for single command execution
   851                                  ;
   852                                  ; REV 1.90
   853                                  ;	       Batch uses XENIX
   854                                  ;
   855                                  ; Rev 2.00
   856                                  ;	       Lots of neato stuff
   857                                  ;	       IBM 2.00 level
   858                                  ;
   859                                  ; Rev 2.01
   860                                  ;	       'D' switch for date time suppression
   861                                  ;
   862                                  ; Rev 2.02
   863                                  ;	       Default userpath is NUL rather than BIN
   864                                  ;		       same as IBM
   865                                  ;	       COMMAND split into pieces
   866                                  ;
   867                                  ; Rev 2.10
   868                                  ;	       INTERNATIONAL SUPPORT
   869                                  ;
   870                                  ; Rev 2.50
   871                                  ;	       all the 2.x new stuff -MU
   872                                  ;
   873                                  ; Rev 3.30     (Ellen G)
   874                                  ;	       CALL internal command (TBATCH2.ASM)
   875                                  ;	       CHCP internal command (TCMD2B.ASM)
   876                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   877                                  ;	       @ sign suppression of batch file line
   878                                  ;	       Replaceable environment value support in batch files
   879                                  ;	       INT 2FH calls for APPEND
   880                                  ;	       Lots of PTR fixes!
   881                                  ;
   882                                  ; Beyond 3.30 to forever  (Ellen G)
   883                                  ; ----------------------
   884                                  ;
   885                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   886                                  ;			Use Message Retriever services
   887                                  ;			/MSG switch for resident extended error msg
   888                                  ;			Convert to new capitalization support
   889                                  ;			Better error recovery on CHCP command
   890                                  ;			Code page file tag support
   891                                  ;			TRUENAME internal command
   892                                  ;			Extended screen line support
   893                                  ;			/P switch on DEL/ERASE command
   894                                  ;			Improved file redirection error recovery
   895                                  ;	(removed)	Improved batch file performance
   896                                  ;			Unconditional DBCS support
   897                                  ;			Volume serial number support
   898                                  ;	(removed)	COMMENT=?? support
   899                                  ;
   900                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   901                                  ;
   902                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   903                                  ;			require delimiters.
   904                                  ;
   905                                  ; A003	PTM P5,P9,P111	Included in A000 development
   906                                  ;
   907                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   908                                  ;			executing
   909                                  ;
   910                                  ; A005	DCR D17 	If user specifies an extension on the command
   911                                  ;			line search for that extension only.
   912                                  ;
   913                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   914                                  ;			exists"
   915                                  ;
   916                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   917                                  ;
   918                                  ; A008	PTM P182	Change COPY to set default if invalid function
   919                                  ;			returned from code page call.
   920                                  ;
   921                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   922                                  ;
   923                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   924                                  ;			transient COMMAND.
   925                                  ;
   926                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   927                                  ;			before appending to a file.
   928                                  ;
   929                                  ; A012	PTM P189	Fix redirection error recovery.
   930                                  ;
   931                                  ; A013	PTM P330	Change date format
   932                                  ;
   933                                  ; A014	PTM P455	Fix echo parsing
   934                                  ;
   935                                  ; A015	PTM P517	Fix DIR problem with * vs *.
   936                                  ;
   937                                  ; A016	PTM P354	Fix extended error message addressing
   938                                  ;
   939                                  ; A017	PTM P448	Fix appending to 0 length files
   940                                  ;
   941                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
   942                                  ;			the parser fails on. Fail on duplicate switches.
   943                                  ;
   944                                  ; A019	PTM P542	Fix device name to be printed correctly during
   945                                  ;			critical error
   946                                  ;
   947                                  ; A020	DCR D43 	Set append state off while in DIR
   948                                  ;
   949                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
   950                                  ;
   951                                  ; A022	DCR D209	Enhanced error recovery
   952                                  ;
   953                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
   954                                  ;
   955                                  ; A024	PTM P899	Fix EXTOPEN open modes.
   956                                  ;
   957                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
   958                                  ;
   959                                  ; A026	DCR D191	Change redirection error recovery support.
   960                                  ;
   961                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
   962                                  ;			with a carriage return.
   963                                  ;
   964                                  ; A028	PTM P1076	Print a blank line before printing invalid
   965                                  ;			date and invalid time messages.
   966                                  ;
   967                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
   968                                  ;			and TIME.
   969                                  ;
   970                                  ; A030	DCR D201	New extended attribute format.
   971                                  ;
   972                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
   973                                  ;
   974                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
   975                                  ;
   976                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
   977                                  ;
   978                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
   979                                  ;
   980                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
   981                                  ;			do a read to determine eof.
   982                                  ;
   983                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
   984                                  ;			so that ASSIGN works correctly.
   985                                  ;
   986                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
   987                                  ;
   988                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
   989                                  ;
   990                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
   991                                  ;
   992                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
   993                                  ;			specified.
   994                                  ;
   995                                  ; A041	PTM P1705	Close redirected files after internal APPEND
   996                                  ;			executes.
   997                                  ;
   998                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
   999                                  ;			files causing loss of batch file.
  1000                                  ;
  1001                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1002                                  ;			CALL'ed batch files.
  1003                                  ;
  1004                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1005                                  ;			as an end of line character
  1006                                  ;
  1007                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1008                                  ;			and extended message pointers when we EXIT if
  1009                                  ;			COMMAND /P is the top level process.
  1010                                  ;
  1011                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1012                                  ;			"File not found - fn"
  1013                                  ;
  1014                                  ; A047	PTM P2819	Fix transient reload prompt message
  1015                                  ;
  1016                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1017                                  ;			when DBCS code was added.
  1018                                  ;
  1019                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1020                                  ;			on line.
  1021                                  ;
  1022                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1023                                  ;
  1024                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1025                                  ;
  1026                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1027                                  ;
  1028                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1029                                  ;
  1030                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1031                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1032                                  ;
  1033                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1034                                  ;			problems with breaking out of INT 24h
  1035                                  ;
  1036                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1037                                  ;
  1038                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1039                                  ;			before the "string".  EX: COMMAND /CDIR
  1040                                  ;
  1041                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1042                                  ;			DBCS switch.
  1043                                  ;
  1044                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1045                                  ;			the time.
  1046                                  ;
  1047                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1048                                  ;			messages to be disk based.  Only keep them if /MSG
  1049                                  ;			is used.
  1050                                  ;
  1051                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1052                                  ;			out of internal commands, due to substitution blocks
  1053                                  ;			not being reset.
  1054                                  ;
  1055                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1056                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1057                                  ;			secondary copy of environment.	Change default slash in
  1058                                  ;			default comspec string to backslash.
  1059                                  ;
  1060                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1061                                  ;			text for critical error messages.
  1062                                  ;
  1063                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1064                                  ;	5/20/88 	with Microsoft product already shipped.
  1065                                  ;
  1066                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1067                                  ;	 5/20/88	with Microsoft product already shipped.
  1068                                  ;
  1069                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1070                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1071                                  ;			header and space remaining.
  1072                                  ;
  1073                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1074                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1075                                  ;			environment was putting a "Z block" marker in the old
  1076                                  ;			environment.  The fix is to move to the old environment
  1077                                  ;			to the new environment before doing the SETBLOCK.
  1078                                  ;
  1079                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1080                                  ;        09/19/88       because the check for APPEND needed to be performed
  1081                                  ;                       before the DIR's findfirst.
  1082                                  ;
  1083                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1084                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1085                                  ;                       loading trans w/new comspec with no user change comspec.
  1086                                  ;
  1087                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1088                                  ;        11/05/88       Expansion of environment variables into batch line of
  1089                                  ;                       128 chars was not being counted and "%" which should be
  1090                                  ;                       ignored were being counted.
  1091                                  ;
  1092                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1093                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1094                                  ;                       ing included in checksum and was being overwritten by
  1095                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1096                                  ;                       Also removed fix A069 (because flag now protected).
  1097                                  ;
  1098                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1099                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1100                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1101                                  ;
  1102                                  ;***********************************************************************************
  1103                                  
  1104                                  ;
  1105                                  ;	Revision History
  1106                                  ;	================
  1107                                  ;
  1108                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1109                                  ;					at init time (date/time prompt)
  1110                                  ;
  1111                                  
  1112                                  ;
  1113                                  ;.xcref
  1114                                  ;.xlist
  1115                                  ;	include dossym.inc		; basic DOS symbol set
  1116                                  ;	include syscall.inc		; DOS function names
  1117                                  ;	include comsw.asm		; build version info
  1118                                  ;	include comequ.asm		; common command.com symbols
  1119                                  ;	include resmsg.equ		; resident message names
  1120                                  ;
  1121                                  ;	include comseg.asm		;segment ordering
  1122                                  ;.list
  1123                                  ;.cref
  1124                                  
  1125                                  ;CODERES segment public byte
  1126                                  ;CODERES ends
  1127                                  ;
  1128                                  ;DATARES 	segment public byte
  1129                                  ;		extrn	AccDen:byte
  1130                                  ;		extrn	Batch:word
  1131                                  ;		extrn	EchoFlag:byte
  1132                                  ;		extrn	ExeBad:byte
  1133                                  ;		extrn	ExecEMes:byte
  1134                                  ;		extrn	ExecErrSubst:byte
  1135                                  ;		extrn	ExtCom:byte
  1136                                  ;		extrn	ForFlag:byte
  1137                                  ;		extrn	IfFlag:byte
  1138                                  ;		extrn	InitFlag:BYTE
  1139                                  ;		extrn	Nest:word
  1140                                  ;		extrn	PipeFlag:byte
  1141                                  ;		extrn	RBadNam:byte
  1142                                  ;		extrn	RetCode:word
  1143                                  ;		extrn	SingleCom:word
  1144                                  ;		extrn	TooBig:byte
  1145                                  ;
  1146                                  ;		extrn	OldDS:word
  1147                                  ;
  1148                                  ;DATARES 	ends
  1149                                  ;
  1150                                  ;
  1151                                  ;INIT		segment public para
  1152                                  ;		extrn	ConProc:near
  1153                                  ;		extrn	Init_Contc_SpecialCase:near
  1154                                  ;INIT		ends
  1155                                  
  1156                                  ; ----------------------------------------------------------------------------
  1157                                  ; START OF RESIDENT PORTION
  1158                                  ; ----------------------------------------------------------------------------
  1159                                  ; SEGMENT - CODERES
  1160                                  ; ----------------------------------------------------------------------------
  1161                                  
  1162                                  	;[ORG	0]
  1163                                  
  1164                                  ;ZERO	EQU	$
  1165                                  
  1166                                  	[ORG 100H]
  1167                                  
  1168                                  	; 21/09/2018 - Retro DOS v3.0
  1169                                  StartCode:
  1170 00000000 E9DD0C                  	jmp	CONPROC
  1171                                  
  1172                                  ;***	EXEC error handling
  1173                                  ;
  1174                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  1175                                  ;	We examine the error code and select an appropriate message.
  1176                                  
  1177                                  ;	Bugbug:	optimize reg usage in following code?  Careful of DX!
  1178                                  ;	Condense the error scan?
  1179                                  ;	RBADNAM is checked by transient, no need here?
  1180                                  ;	Move below Ext_Exec.
  1181                                  
  1182                                  EXEC_ERR:
  1183 00000003 BA[DC09]                	mov     dx,ACCDEN
  1184 00000006 83F805                  	cmp     ax,ERROR_ACCESS_DENIED	; 5
  1185 00000009 741B                    	jz      short GOTEXECEMES	; access denied
  1186 0000000B BA[C109]                	mov     dx,RBADNAM
  1187 0000000E 83F802                  	cmp     ax,ERROR_FILE_NOT_FOUND ; 2
  1188 00000011 7413                    	jz      short GOTEXECEMES	; file not found
  1189 00000013 BA[8709]                	mov     dx,TOOBIG
  1190 00000016 83F808                  	cmp     ax,ERROR_NOT_ENOUGH_MEMORY ; 8
  1191 00000019 740B                    	jz      short GOTEXECEMES
  1192 0000001B BA[7309]                	mov     dx,EXEBAD
  1193 0000001E 83F80B                  	cmp     ax,ERROR_BAD_FORMAT	; 0Bh
  1194 00000021 7403                    	jz      short GOTEXECEMES	; bad exe file
  1195                                  DEFAULT_MESSAGE:
  1196 00000023 BA[6409]                	mov     dx,EXECEMES
  1197                                  GOTEXECEMES:
  1198 00000026 0E                      	push    cs
  1199 00000027 1F                      	pop     ds
  1200 00000028 E86B06                  	call    RDISPMSG
  1201 0000002B EB0C                    	jmp     short NOEXEC
  1202                                  
  1203                                  ;***	EXEC call
  1204                                  ;
  1205                                  ;	The transient has set up everything for an EXEC system call.
  1206                                  ;	For cleanliness, we issue the EXEC here in the resident 
  1207                                  ;	so that we may be able to recover cleanly upon success.
  1208                                  ;
  1209                                  ;	CS,DS,ES,SS = DATARES seg addr
  1210                                  
  1211                                  EXT_EXEC:
  1212                                  ;SR;
  1213                                  ; The words put on the stack by the stub will be popped off when we finally
  1214                                  ;jump to LodCom (by LodCom).
  1215                                  ;
  1216 0000002D CD21                    	int	21h			; do the exec
  1217                                  EXEC_RET:
  1218 0000002F 72D2                    	jc	short EXEC_ERR		; exec failed
  1219                                  
  1220                                  ;	The exec has completed. Retrieve the exit code.
  1221                                  
  1222                                  EXEC_WAIT:
  1223 00000031 B44D                    	mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  1224 00000033 CD21                    	int	21h			; get the return code
  1225 00000035 2EA3[EC0A]              	mov     [cs:RETCODE],ax
  1226                                  
  1227                                  ;	See if we can reload the transient. The external command
  1228                                  ;	may have overwritten part of the transient.
  1229                                  
  1230                                  NOEXEC:
  1231                                  ;SR;
  1232                                  ; ds = es = ss = DATARES when we jump to LodCom
  1233                                  ;
  1234 00000039 E97101                  	jmp	LODCOM
  1235                                  
  1236                                  ;***	Int 23 (ctrl-c) handler
  1237                                  ;
  1238                                  ;	This is the default system INT 23 handler.  All processes
  1239                                  ;	(including COMMAND) get it by default.  There are some
  1240                                  ;	games that are played:  We ignore ^C during most of the
  1241                                  ;	INIT code.  This is because we may perform an ALLOC and
  1242                                  ;	diddle the header!  Also, if we are prompting for date/time
  1243                                  ;	in the init code, we are to treat ^C as empty responses.
  1244                                  
  1245                                  ;	Bugbug:	put init ctrl-c handling in init module.
  1246                                  
  1247                                  ;SR;
  1248                                  ; The stub has pushed the previous ds and DATARES onto the stack. We get
  1249                                  ;both these values off the stack now
  1250                                  ;
  1251                                  ;ContC	proc	far
  1252                                  
  1253                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  1254                                  
  1255                                  CONTC:
  1256                                  
  1257                                  ;	pop	ds			;ds = DATARES
  1258                                  ;	assume	ds:DATARES
  1259                                  ;;	pop	word [OldDS]		;OldDS = old ds
  1260                                  
  1261 0000003C 2EF606[5B0B]01          	test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  1262 00000042 740C                    	jz	short NOTATINIT			; no
  1263 00000044 2EF606[5B0B]02          	test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  1264 0000004A 7403                    	jz	short CMDIRET			; no, ignore ^C
  1265                                  	;pop	ds			; restore before jumping; M021
  1266 0000004C E9A412                  	jmp	INIT_CONTC_SPECIALCASE	; Yes, go handle it
  1267                                  CMDIRET:
  1268                                  ;SR;
  1269                                  ; Restore ds to its previous value
  1270                                  ;
  1271                                  
  1272                                  ;;	mov	ds,[OLdDS]		;
  1273                                  ;	pop	ds
  1274 0000004F CF                      	iret				; yes, ignore the ^C
  1275                                  
  1276                                  NOTATINIT:
  1277 00000050 2EF606[5B0B]04          	test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  1278 00000056 7411                    	jz	short NOTINIT		; nope too.
  1279                                  
  1280                                  ;*	We are interrupting ourselves in this ^C handler. We need
  1281                                  ;	to set carry and return to the user sans flags only if the
  1282                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  1283                                  
  1284 00000058 80FC01                  	cmp	ah,1
  1285 0000005B 72F2                    	jb	short CMDIRET
  1286 0000005D 80FC0C                  	cmp	ah,12
  1287 00000060 77ED                    	ja	short CMDIRET
  1288                                  
  1289                                  ;	pop	ds			;restore ds to old value
  1290 00000062 83C406                  	add	sp,6			; remove int frame
  1291 00000065 F9                      	stc
  1292                                  
  1293                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  1294 00000066 CA0200                  	retf	2			; remove those flags...
  1295                                  
  1296                                  NOTINIT:
  1297                                  
  1298                                  ;*	We have now received a ^C for some process (maybe ourselves
  1299                                  ;	but not at INIT).
  1300                                  ;	
  1301                                  ;	Note that we are running on the user's stack!!! Bad news if
  1302                                  ;	any of the system calls below go and issue another INT
  1303                                  ;	24... Massive stack overflow! Another bad point is that
  1304                                  ;	SavHand will save an already saved handle, thus losing a
  1305                                  ;	possible redirection...
  1306                                  ;	
  1307                                  ;	All we need to do is set the flag to indicate nested ^C. 
  1308                                  ;	The above code will correctly flag the ^C diring the
  1309                                  ;	message output and prompting while ignoring the ^C the rest
  1310                                  ;	of the time.
  1311                                  ;	
  1312                                  ;	Clean up: flush disk. If we are in the middle of a batch
  1313                                  ;	file, we ask if he wants to terminate it. If he does, then
  1314                                  ;	we turn off all internal flags and let the DOS abort.
  1315                                  
  1316 00000069 2E800E[5B0B]04          	or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  1317 0000006F FB                      	sti
  1318                                  
  1319 00000070 0E                      	push	cs			; el yucko!  change the user's ds!!
  1320 00000071 1F                      	pop	ds
  1321                                  ;	assume	ds:RESGROUP
  1322                                  
  1323                                  	;pop	ax			;discard the old ds value
  1324                                  
  1325 00000072 A1[F50A]                	mov	ax,[SINGLECOM]
  1326 00000075 09C0                    	or	ax,ax
  1327 00000077 7506                    	jnz	short NORESET
  1328 00000079 50                      	push	ax
  1329 0000007A B40D                    	mov	ah,DISK_RESET ; 0Dh
  1330 0000007C CD21                    	int	21h			; reset disks in case files were open
  1331 0000007E 58                      	pop	ax
  1332                                  
  1333                                  NORESET:
  1334                                  
  1335                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  1336                                  ;	walk the entire active list and free each segment. Here,
  1337                                  ;	we just free the single batch segment.
  1338                                  
  1339 0000007F F706[990A]FFFF          	test	word [BATCH],-1
  1340 00000085 744B                    	jz	short CONTCTERM
  1341 00000087 09C0                    	or	ax,ax
  1342 00000089 7547                    	jnz	short CONTCTERM
  1343 0000008B E85902                  	call	SAVHAND
  1344 0000008E E8A203                  	call	ASKEND			; ask if user wants to end batch
  1345                                  
  1346                                  ;	If the carry flag is clear, we do NOT free up the batch file
  1347                                  
  1348 00000091 7339                    	jnc	short CONTBATCH
  1349                                  	;mov	cl,[EchoFlag]		; get current echo flag
  1350 00000093 53                      	push	bx
  1351                                  
  1352                                  CLEARBATCH:
  1353 00000094 8E06[990A]              	mov	es,[BATCH]		; get batch segment
  1354                                  	;mov	di,[BatFile]		; get offset of batch file name
  1355                                  	; MSDOS 3.3 ([ES:4])
  1356 00000098 268B1E0400              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  1357                                  	;
  1358 0000009D 83FB00                  	cmp	bx,0			; is a FOR in progress
  1359 000000A0 7408                    	je	short NOT_BAT_FOR	; no - don't deallocate
  1360 000000A2 06                      	push	es			;
  1361 000000A3 8EC3                    	mov	es,bx			; yes - free it up...
  1362 000000A5 B449                    	mov	ah,DEALLOC ; 49h	;
  1363 000000A7 CD21                    	int	21h			;
  1364 000000A9 07                      	pop	es			; restore to batch segment
  1365                                  
  1366                                  NOT_BAT_FOR:
  1367 000000AA 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  1368 000000AF 268B1E0200              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  1369 000000B4 B449                    	mov	ah,DEALLOC ; 49h	; free it up...
  1370 000000B6 CD21                    	int	21h
  1371 000000B8 891E[990A]              	mov	[BATCH],bx		; get ready to deallocate next batch
  1372 000000BC FF0E[FE0A]              	dec	WORD [NEST]		; is there another batch file?
  1373 000000C0 75D2                    	jnz	short CLEARBATCH	; keep going until no batch file
  1374                                  
  1375                                  ;	We are terminating a batch file; restore the echo status
  1376                                  
  1377                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  1378 000000C2 5B                      	pop	bx
  1379 000000C3 880E[EF0A]              	mov	[ECHOFLAG],cl		; reset echo status
  1380                                  	; 29/05/2018
  1381 000000C7 C606[5C0B]00            	mov	byte [PIPEFLAG],0	; turn off pipeflag
  1382                                  
  1383                                  CONTBATCH:
  1384 000000CC E8C405                  	call	CRLF			; print out crlf before returning
  1385 000000CF E83A02                  	call	RESTHAND
  1386                                  
  1387                                  ;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.
  1388                                  
  1389                                  CONTCTERM:
  1390 000000D2 31C0                    	xor	ax,ax			; indicate no read
  1391 000000D4 89C5                    	mov	bp,ax
  1392                                  
  1393                                  ;	The following resetting of the state flags is good for the
  1394                                  ;	generalized batch processing.
  1395                                  
  1396 000000D6 A2[FA0A]                	mov	[IFFLAG],al		; turn off iffing
  1397 000000D9 A2[FB0A]                	mov	[FORFLAG],al		; turn off for processing
  1398 000000DC E81C00                  	call	RESPIPEOFF
  1399 000000DF 3906[F50A]              	cmp	[SINGLECOM],ax		; see if we need to set singlecom
  1400 000000E3 7406                    	jz	short NOSETSING
  1401 000000E5 C706[F50A]FFFF          	mov	word [SINGLECOM],-1	; cause termination on 
  1402                                  					;  pipe, batch, for
  1403                                  NOSETSING:
  1404                                  
  1405                                  ;	If we are doing an internal command, go through the reload process.
  1406                                  ;	If we are doing an external, let DOS abort the process.
  1407                                  ;	In both cases, we are now done with the ^C processing.
  1408                                  
  1409 000000EB 8026[5B0B]FB            	and	byte [INITFLAG],~INITCTRLC ; 0FBh
  1410 000000F0 3806[EB0A]              	cmp	[EXTCOM],al
  1411 000000F4 7503                    	jnz	short DODAB		; internal ^c
  1412 000000F6 E92001                  	jmp	LODCOM1
  1413                                  DODAB:
  1414 000000F9 F9                      	stc				; tell dos to abort
  1415                                  
  1416                                  ;SR;
  1417                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  1418                                  ;by setting carry and leaving flags on the stack
  1419                                  ;
  1420 000000FA CB                      	retf				; Leave flags on stack
  1421                                  
  1422                                  ;ContC	endp
  1423                                  
  1424                                  ;SR;
  1425                                  ; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  1426                                  ;both have ds = DATARES
  1427                                  ;
  1428                                  
  1429                                  RESPIPEOFF:
  1430 000000FB 50                      	push	ax
  1431 000000FC 31C0                    	xor	ax,ax
  1432 000000FE 2E8606[5C0B]            	xchg	al,[cs:PIPEFLAG]
  1433 00000103 08C0                    	or	al,al
  1434 00000105 7405                    	jz	short NOPIPEPOP
  1435 00000107 2ED02E[EF0A]            	shr	byte [cs:ECHOFLAG],1
  1436                                  NOPIPEPOP:
  1437 0000010C 58                      	pop	ax
  1438 0000010D C3                      	retn
  1439                                  
  1440                                  ;CODERES ends
  1441                                  
  1442                                  ;=============================================================================
  1443                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  1444                                  ;=============================================================================
  1445                                  ; 21/09/2018 - Retro DOS v3.0
  1446                                  
  1447                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  1448                                  ;	name	COMMAND2
  1449                                  
  1450                                  ;/*
  1451                                  ; *                      Microsoft Confidential
  1452                                  ; *                      Copyright (C) Microsoft Corporation 1991
  1453                                  ; *                      All Rights Reserved.
  1454                                  ; */
  1455                                  
  1456                                  ;
  1457                                  ;	Revision History
  1458                                  ;	================
  1459                                  ;
  1460                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  1461                                  ;			reserve memory by changing int 12h and then give it
  1462                                  ;			back to DOS by changing arenas in autoexec.bat.
  1463                                  ;			This makes command.com reload transient and this
  1464                                  ;			cannot be done at this stage.
  1465                                  ;
  1466                                  
  1467                                  ;CODERES segment public byte
  1468                                  
  1469                                  ;*	If we cannot allocate enough memory for the transient or there
  1470                                  ;	was some other allocation error, we display a message and
  1471                                  ;	then die.
  1472                                  
  1473                                  ;SR;
  1474                                  ; We will have to make sure that at this entry point and at FatalC, 
  1475                                  ;ds = DATARES. All jumps to these points are made from only within this file
  1476                                  ;and so we should be able to do this
  1477                                  
  1478                                  	;assume	ds:DATARES
  1479                                  BADMEMERR:
  1480 0000010E BA[EC09]                	mov	dx,BMEMMES			; DX = ptr to msg
  1481                                  FATALC:
  1482 00000111 0E                      	push	cs
  1483 00000112 1F                      	pop	ds
  1484                                  ;;	assume	ds:ResGroup
  1485                                  ;	invoke	RPrint
  1486                                  
  1487                                  	; MSDOS 3.3
  1488 00000113 E88005                  	call	RDISPMSG
  1489                                  
  1490                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  1491                                  ;	we can't do anything else!
  1492                                  
  1493 00000116 803E[F40A]00            	cmp	byte [PERMCOM],0
  1494 0000011B 7410                    	je	short FATALRET
  1495                                  
  1496                                  ;	We are a permanent command. If we are in the process of the
  1497                                  ;	magic interrupt (Singlecom) then exit too.
  1498                                  
  1499 0000011D 833E[F50A]00            	cmp	word [SINGLECOM],0		; if permcom and singlecom
  1500 00000122 7509                    	jne	short FATALRET			; must take int_2e exit
  1501                                  
  1502                                  ;	Permanent command. We can't do ANYthing except halt.
  1503                                  
  1504 00000124 BA[070A]                	mov	dx,HALTMES			; DX = ptr to msg
  1505                                  	;invoke	RPrint
  1506                                  	; MSDOS 3.3
  1507 00000127 E86C05                  	call	RDISPMSG
  1508 0000012A FB                      	sti
  1509                                  STALL:
  1510 0000012B EBFE                    	jmp	short STALL			; crash the system nicely
  1511                                  
  1512                                  FATALRET:
  1513 0000012D BA[2C0A]                	mov	dx,FRETMES			; DX = ptr to msg
  1514 00000130 E86305                  	call	RDISPMSG
  1515                                  FATALRET2:
  1516 00000133 803E[F40A]00            	cmp	byte [PERMCOM],0		; if we get here and permcom,
  1517 00000138 7517                    	jne	SHORT RET_2E			; must be int_2e
  1518                                  
  1519                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  1520                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  1521                                  ;	case we decide to do that.)
  1522 0000013A A1[8E0A]                	mov	ax,[PARENT]
  1523 0000013D A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  1524 00000140 A1[900A]                	mov	ax,[OLDTERM]
  1525 00000143 A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  1526 00000146 A1[920A]                	mov	ax,[OLDTERM+2]
  1527 00000149 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  1528 0000014C B8004C                  	mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  1529 0000014F CD21                    	int	21h
  1530                                  RET_2E:
  1531                                  ;SR;
  1532                                  ; We will ensure that ds = DATARES for all entries to this place
  1533                                  ;
  1534                                  
  1535                                  ;;	push	cs
  1536                                  ;;	pop	ds
  1537                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  1538                                    	
  1539                                  ;	assume	ds:DATARES
  1540                                  
  1541                                  	;PUSH	CS
  1542                                  	;POP	DS
  1543                                  
  1544 00000151 C706[F50A]0000          	mov	word [SINGLECOM],0	; turn off singlecom
  1545 00000157 8E06[250C]              	mov	es,[RES_TPA]
  1546 0000015B B449                    	mov	ah,DEALLOC
  1547 0000015D CD21                    	int	21h			; free up space used by transient
  1548 0000015F 8B1E[8C0A]              	mov	bx,[SAVE_PDB]
  1549 00000163 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  1550 00000165 CD21                    	int	21h			; current process is user
  1551 00000167 A1[EC0A]                	mov	ax,[RETCODE]
  1552 0000016A 803E[EB0A]00            	cmp	byte [EXTCOM],0
  1553 0000016F 7502                    	jne	short GOTECODE
  1554 00000171 31C0                    	xor	ax,ax			; internals always return 0
  1555                                  GOTECODE:
  1556 00000173 C606[EB0A]01            	mov	byte [EXTCOM],1		; force external
  1557                                  
  1558                                  ;SR; This is actually returning to the caller. However, the old code had
  1559                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  1560                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  1561                                  ;
  1562                                  	;jmp	INT_2E_RET		;"iret"
  1563                                  	; 12/01/2023 (BugFix)
  1564 00000178 FF2E[880A]              	jmp	far [INT_2E_RET]
  1565                                  
  1566                                  
  1567                                  ;***	Int_2e, magic command executer
  1568                                  
  1569                                  INT_2E:
  1570                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  1571                                  ;SR;
  1572                                  ; We are going to come here from the stub with the old ds and DATARES value
  1573                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  1574                                  ;
  1575                                  	;pop	ds			;ds = DATARES
  1576                                  	;assume	ds:DATARES
  1577                                  	;pop	ax
  1578                                  ;	;pop	ds:OldDS 		;Save old value of ds
  1579                                  
  1580 0000017C 2E8F06[880A]            	pop	word [cs:INT_2E_RET]
  1581 00000181 2E8F06[8A0A]            	pop	word [cs:INT_2E_RET+2]	; store return address
  1582 00000186 58                      	pop	ax			; chuck flags
  1583                                  	;add	sp,2
  1584                                  
  1585 00000187 0E                      	push	cs
  1586 00000188 07                      	pop	es
  1587                                  
  1588                                  	;push	ds
  1589                                  	;pop	es			;es = DATARES
  1590                                  ;	;mov	ds,OldDS
  1591                                  	;mov	ds,ax
  1592                                  	;assume	ds:nothing		;ds = old value
  1593                                  
  1594 00000189 BF8000                  	mov	di,80h
  1595 0000018C B94000                  	mov	cx,64
  1596                                  ;	Bugbug:	cld
  1597 0000018F F3A5                    	rep	movsw
  1598 00000191 B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1599 00000193 CD21                    	int	21h			; get user's header
  1600                                  	;mov	[es:SAVE_PDB],bx
  1601 00000195 2E891E[8C0A]            	MOV	[cs:SAVE_PDB],bx
  1602 0000019A B450                    	mov	ah,SET_CURRENT_PDB ; 50H
  1603                                  
  1604                                  ;;	mov	bx,cs
  1605                                  ;SR;
  1606                                  ; Set ds = DATARES because BadMemErr expects this
  1607                                  ;
  1608                                  	;push	es
  1609                                  	;pop	ds
  1610                                  	;assume	ds:DATARES
  1611                                  
  1612                                  	;mov	bx,ds			;es = our PSP now
  1613 0000019C 8CCB                    	mov	bx,cs
  1614                                  
  1615 0000019E CD21                    	int	21h			; current process is me
  1616 000001A0 2EC706[F50A]8100        	mov	word [cs:SINGLECOM],81h
  1617 000001A7 2EC606[EB0A]01          	mov	byte [cs:EXTCOM],1	; make sure this case forced
  1618                                  
  1619                                  ;SR;
  1620                                  ; We can enter LodCom directly after a command shell is terminated or we
  1621                                  ;can fall thru from above. When we enter directly from the stub, the stack
  1622                                  ;has the old ds value and the data seg value on the stack, so that ds can
  1623                                  ;be properly set. To fake this, we push dummy values here.
  1624                                  ;
  1625                                  	;push	ds			;old value of ds
  1626                                  	;push	ds			;data seg value, ds = DATARES
  1627                                  
  1628                                  LODCOM: 				; termination handler
  1629                                  	;pop	ds			;ds = DATARES 
  1630                                  	;assume	ds:DATARES
  1631                                  	;add	sp,2
  1632                                  ;	;pop	OldDS			;store old ds
  1633                                  
  1634                                  	;cmp	EXTCOM,0
  1635 000001AD 2E803E[EB0A]00          	cmp	byte [cs:EXTCOM],0
  1636                                  	;jne	@f	 		; internal cmd - memory allocated
  1637                                  	;jne	short LODCOM0 ; 24/09/2018
  1638                                  	;jmp	LODCOM1 		; jz LODCOM1
  1639 000001B3 7464                    	je	short LODCOM1 ; 25/09/2018	
  1640                                  
  1641                                  ;@@:
  1642                                  LODCOM0: ; 24/09/2018
  1643 000001B5 BBFFFF                  	mov	bx,0FFFFh
  1644 000001B8 B448                    	mov	ah,ALLOC ; 48h	
  1645 000001BA CD21                    	int	21h			; DOS - 2+ - ALLOCATE MEMORY
  1646                                  					; BX = number of 16-byte paragraphs desired
  1647 000001BC E80A00                  	call	SETSIZE
  1648 000001BF 83C020                  	add	ax,20h
  1649 000001C2 39C3                    	cmp	bx,ax
  1650 000001C4 730B                    	jnb	short MEMOK		; > 512 byte buffer - good enough
  1651                                  BADMEMERRJ:
  1652 000001C6 E945FF                  	jmp	BADMEMERR		; not enough memory
  1653                                  
  1654                                  ;***	SetSize - get transient size in paragraphs
  1655                                  
  1656                                  SETSIZE:
  1657 000001C9 B84B4D                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh
  1658 000001CC B104                    	mov	cl,4
  1659 000001CE D3E8                    	shr	ax,cl
  1660 000001D0 C3                      	retn
  1661                                  
  1662                                  MEMOK:
  1663                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  1664                                  
  1665 000001D1 B448                    	mov	ah,ALLOC  ; 48h
  1666 000001D3 CD21                    	int	21h
  1667 000001D5 72EF                    	jc	short BADMEMERRJ	; memory arenas probably trashed
  1668 000001D7 2EC606[EB0A]00          	mov	byte [cs:EXTCOM],0	; flag not to alloc again
  1669 000001DD 2EA3[250C]              	mov	[cs:RES_TPA],ax		; save current tpa segment
  1670 000001E1 2500F0                  	and	ax,0F000h
  1671 000001E4 050010                  	add	ax,01000h		; round up to next 64k boundary
  1672 000001E7 7213                    	jc	short BAD_TPA		; memory wrap if carry set
  1673                                  
  1674                                  ;	Make sure that new boundary is within allocated range
  1675                                  
  1676 000001E9 2E8B16[250C]            	mov	dx,[cs:RES_TPA]
  1677 000001EE 01DA                    	add	dx,bx			; compute maximum address
  1678 000001F0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  1679 000001F2 7608                    	jbe	short BAD_TPA
  1680                                  
  1681                                  ;	Must have 64K of usable space.
  1682                                  
  1683 000001F4 29C2                    	sub	dx,ax			; compute the usable space
  1684 000001F6 81FA0010                	cmp	dx,01000h		; is space >= 64k ?
  1685 000001FA 7304                    	jae	short LTPASET
  1686                                  BAD_TPA:
  1687 000001FC 2EA1[250C]              	mov	ax,[cs:RES_TPA]
  1688                                  LTPASET:
  1689 00000200 2EA3[170C]              	mov	[cs:LTPA],ax		; usable tpa is 64k buffer aligned
  1690 00000204 2EA1[250C]              	mov	ax,[cs:RES_TPA]		; actual tpa is buffer allocated
  1691 00000208 01C3                    	add	bx,ax
  1692 0000020A 2E891E[E70A]            	mov	[cs:MEMSIZ],bx
  1693 0000020F E8B7FF                  	call	SETSIZE
  1694 00000212 29C3                    	sub	bx,ax
  1695                                  
  1696                                  	; MSDOS 6.0
  1697                                  ;;
  1698                                  ;;M038; Start of changes
  1699                                  ;; Changes for Novell RPL. These guys reserve memory for themselves by
  1700                                  ;;reducing int 12h size and add this memory to the system at autoexec time by
  1701                                  ;;running a program that changes arenas. This changes the largest block that
  1702                                  ;;command.com gets and so changes the transient segment. So, command.com does
  1703                                  ;;a checksum at the wrong address and thinks that the transient is destroyed
  1704                                  ;;and tries to reload it. At this point, no Comspec is defined and so the
  1705                                  ;;reload fails, hanging the system. To get around this we just copy the
  1706                                  ;;transient from the previous address to the new address(if changed) and
  1707                                  ;;then let command.com do the checksum. So, if the transient area is not
  1708                                  ;;corrupted, there will not be any reload. In Novell's case, the transient
  1709                                  ;;is not really corrupted and so this should work.
  1710                                  ;;
  1711                                  ;	cmp	bx,[cs:TRNSEG]		;Segment still the same?
  1712                                  ;	je	short LODCOM1		;yes, dont copy
  1713                                  ;;
  1714                                  ;;Check if the new segment is above or below the current move. If the new
  1715                                  ;;segment is above (i.e new block is larger than previous block), then we
  1716                                  ;;have to move in the reverse direction
  1717                                  ;;
  1718                                  ;	mov	cx,TRANSPACEEND		;cx = length to move
  1719                                  ;	ja	short _MOV_DOWN		;new seg > old seg, reverse move
  1720                                  ;	xor	si,si			;normal move
  1721                                  ;	mov	di,si
  1722                                  ;	cld
  1723                                  ;	jmp	short COPY_TRANS
  1724                                  ;_MOV_DOWN:
  1725                                  ;	mov	si,cx			;reverse move, start from end
  1726                                  ;	dec	si
  1727                                  ;	mov	di,si
  1728                                  ;	std
  1729                                  ;COPY_TRANS:
  1730                                  ;	push	ds
  1731                                  ;	push	es
  1732                                  ;	mov	es,bx			;dest segment
  1733                                  ;	mov	ds,[cs:TRNSEG]		;source segment
  1734                                  ;	;assume	ds:nothing
  1735                                  ;
  1736                                  ;	rep	movsb			;copy transient
  1737                                  ;	cld
  1738                                  ;	pop	es
  1739                                  ;	pop	ds
  1740                                  ;	;assume	ds:DATARES
  1741                                  ;;
  1742                                  ;;M038; End of changes
  1743                                  ;;
  1744 00000214 2E891E[E10A]            	mov	[cs:TRNSEG],bx		;new location of transient
  1745                                  
  1746                                  LODCOM1:
  1747                                  ;;	mov	ax,cs
  1748                                  ;;	mov	ss,ax
  1749                                  ;SR; At this point ds = DATARES which is where the stack is located
  1750                                  ;
  1751                                  	;mov	ax,ds
  1752                                  	;mov	ss,ax
  1753                                  	;assume	ss:DATARES
  1754                                  	;mov	sp,offset DATARES:RStack
  1755                                  
  1756                                  ;;	mov	ds,ax
  1757                                  
  1758                                  	;assume	ds:DATARES
  1759                                  	
  1760                                  	; MSDOS 3.3
  1761 00000219 8CC8                    	mov	ax,cs
  1762 0000021B 8ED0                    	mov	ss,ax
  1763 0000021D BC[3E07]                	mov	sp,RSTACK
  1764 00000220 8ED8                    	mov	ds,ax
  1765                                  
  1766 00000222 E88E00                  	call	HEADFIX			; close files, restore stdin, stdout
  1767 00000225 31ED                    	xor	bp,bp			; flag command ok
  1768 00000227 B8FFFF                  	mov	ax,-1
  1769 0000022A 8706[F70A]              	xchg	ax,[VERVAL]
  1770 0000022E 83F8FF                  	cmp	ax,-1
  1771 00000231 7404                    	je	short NOSETVER
  1772 00000233 B42E                    	mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  1773 00000235 CD21                    	int	21h 			; DOS - SET VERIFY FLAG
  1774                                  					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  1775                                  NOSETVER:
  1776 00000237 833E[F50A]FF            	cmp	word [SINGLECOM],-1
  1777 0000023C 7503                    	jne	short NOSNG
  1778 0000023E E9F2FE                  	jmp	FATALRET2		; we have finished the single command
  1779                                  NOSNG:
  1780 00000241 E88201                  	call	CHKSUM			; check the transient
  1781 00000244 3B16[E90A]              	cmp	dx,[SUM]
  1782 00000248 7416                    	je	short HAVCOM		; transient ok
  1783                                  BOGUS_COM:
  1784 0000024A C606[980A]01            	mov	byte [LOADING],1	; flag DskErr routine
  1785 0000024F E82501                  	call	LOADCOM
  1786                                  CHKSAME:
  1787 00000252 E87101                  	call	CHKSUM
  1788 00000255 3B16[E90A]              	cmp	dx,[SUM]
  1789 00000259 7405                    	jz	short HAVCOM		; same command
  1790                                  ALSO_BOGUS:
  1791 0000025B E86001                  	call	WRONGCOM
  1792 0000025E EBF2                    	jmp	short CHKSAME
  1793                                  
  1794                                  HAVCOM:
  1795                                  	; 25/09/2018
  1796 00000260 B80037                  	mov     ax,(CHAR_OPER*256) ; 3700h
  1797 00000263 CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  1798                                  			; Return: AL = FFh unsupported subfunction
  1799                                  			; DL = current switch character
  1800 00000265 8816[190C]              	mov     [RSWITCHAR],dl
  1801 00000269 80FA2F                  	cmp     dl,'/'
  1802 0000026C 7505                    	jnz     short USESLASH
  1803                                  	;mov	cl,'\'
  1804                                  	;mov	[RDIRCHAR],cl
  1805 0000026E C606[1A0C]5C            	mov	byte [RDIRCHAR],'\'
  1806                                  USESLASH:
  1807 00000273 C606[980A]00            	mov	byte [LOADING],0		; flag to DskErr
  1808 00000278 BE[130C]                	mov	si,TRANVARS
  1809 0000027B BF6F42                  	mov	di,HEADCALL
  1810 0000027E 8E06[E10A]              	mov	es,[TRNSEG]
  1811 00000282 FC                      	cld
  1812 00000283 B9[270C]                	mov	cx,TRANVAREND
  1813 00000286 29F1                    	sub	cx,si
  1814 00000288 F3A4                    	rep	movsb			; transfer info to transient
  1815 0000028A A1[E70A]                	mov	ax,[MEMSIZ]
  1816 0000028D A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  1817                                  
  1818                                  ;***	TJmp - jump-off to transient
  1819                                  ;
  1820                                  ;	Public label so debugger can find this spot.
  1821                                  
  1822                                  TJMP:
  1823 00000290 FF2E[DF0A]              	jmp	far [TRANS]
  1824                                  
  1825                                  ;***	TRemCheck - far version of RemCheck for transient
  1826                                  
  1827                                  TREMCHECK:
  1828                                  	;pop	ds			;ds = DATARES
  1829                                  	;add	sp,2			;discard old value of ds
  1830                                  
  1831 00000294 E80100                  	call	REMCHECK
  1832 00000297 CB                      	retf
  1833                                  
  1834                                  ;***	RemCheck
  1835                                  ;
  1836                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  1837                                  ;
  1838                                  ;	EXIT	ZR set if removeable media
  1839                                  ;		ZR clear if fixed media
  1840                                  ;
  1841                                  ;	USED	none
  1842                                  
  1843                                  REMCHECK:
  1844 00000298 50                      	push	ax
  1845 00000299 53                      	push	bx
  1846 0000029A 89C3                    	mov	bx,ax
  1847 0000029C B80844                  	mov	ax,(IOCTL<<8)+8 ; 4408h
  1848 0000029F CD21                    	int	21h			; DOS - 2+ - IOCTL -
  1849 000002A1 7304                    	jnc	short RCCONT			
  1850                                  
  1851                                  ;	If an error occurred, assume the media is non-removable.
  1852                                  ;	AX contains the non-zero error code from the int 21, so
  1853                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  1854                                  ;	appear to be non-removable.				
  1855                                  					
  1856 000002A3 09C0                    	or	ax,ax			
  1857 000002A5 EB05                    	jmp	short RESREGS
  1858                                  RCCONT:
  1859 000002A7 83E001                  	and	ax,1
  1860 000002AA F7D0                    	not	ax
  1861                                  RESREGS:
  1862 000002AC 5B                      	pop	bx
  1863 000002AD 58                      	pop	ax
  1864 000002AE C3                      	retn
  1865                                  
  1866                                  ;***	THeadFix
  1867                                  ;
  1868                                  ;	Far version of HeadFix, called from transient.
  1869                                  
  1870                                  THEADFIX:
  1871                                  	;pop	ds			;ds = DATARES
  1872                                  	;add	sp,2			;discard old ds value on stack
  1873                                  
  1874 000002AF E80100                  	call	HEADFIX
  1875 000002B2 CB                      	retf
  1876                                  
  1877                                  ;***	HeadFix
  1878                                  
  1879                                  HEADFIX:
  1880 000002B3 E82A01                  	call	SETVECT			; set vectors to our values
  1881                                  
  1882                                  ;	Clean up header
  1883                                  
  1884                                  ;	Bugbug:	optimize:
  1885                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  1886                                  
  1887 000002B6 31DB                    	xor	bx,bx				; BX = handle = 0
  1888 000002B8 8B0E[F10A]              	mov	cx,[IO_SAVE]			; CX = original stdin, stdout
  1889 000002BC 8B161800                	mov	dx,[PDB.JFN_TABLE] ; mov dx,[ds:18h] ; DX = current stdin, stdout
  1890 000002C0 38D1                    	cmp	cl,dl
  1891 000002C2 7408                    	je	short CHK1		; stdin matches
  1892 000002C4 B43E                    	mov	ah,CLOSE  ; 3Eh
  1893 000002C6 CD21                    	int	21h			; close stdin
  1894 000002C8 880E1800                	mov	[PDB.JFN_TABLE],cl ; mov [ds:18h],cl ; restore stdin
  1895                                  CHK1:
  1896 000002CC 43                      	inc	bx			; BX = handle = 1
  1897 000002CD 38F5                    	cmp	ch,dh			
  1898 000002CF 7408                    	je	short CHKOTHERHAND	; stdout matches
  1899 000002D1 B43E                    	mov	ah,CLOSE
  1900 000002D3 CD21                    	int	21h			; close stdout
  1901 000002D5 882E1900                	mov	[PDB.JFN_TABLE+1],ch ; mov [ds:19h],ch	; restore stdout
  1902                                  
  1903                                  CHKOTHERHAND:
  1904 000002D9 83C304                  	add	bx,4			; skip handles 2,3,4
  1905 000002DC B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  1906                                  					;   (handles 0-4 already done)
  1907                                  CLOSELOOP:
  1908 000002DF B43E                    	mov	ah,CLOSE ; 3Eh
  1909 000002E1 CD21                    	int	21h			; close each handle
  1910 000002E3 43                      	inc	bx			; BX = next handle
  1911 000002E4 E2F9                    	loop	CLOSELOOP
  1912                                  
  1913                                  	; MSDOS 6.0
  1914                                  ;;	Bugbug:	since this is for transient code, move it there
  1915                                  ;
  1916                                  ;;	M012: remove this CS -> DS.  Must've been missed during
  1917                                  ;;	purification.
  1918                                  ;;;	push	ds			; save data segment
  1919                                  ;;;	push	cs			; get local segment into DS
  1920                                  ;;;	pop	ds			;
  1921                                  ;	cmp	Append_Flag,-1		; do we need to reset APPEND?
  1922                                  ;	jne	Append_Fix_End		; no - just exit
  1923                                  ;	mov	ax,AppendSetState	; set the state of Append
  1924                                  ;	mov	bx,Append_State 	;     back to the original state
  1925                                  ;	int	2Fh			;
  1926                                  ;	mov	Append_Flag,0		; set append flag to invalid
  1927                                  ;Append_Fix_End: 			;
  1928                                  ;;;	pop	ds			; get data segment back
  1929                                  ;	retn
  1930                                  
  1931                                  	; MSDOS 3.3
  1932 000002E6 C3                      	retn
  1933                                  
  1934                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  1935                                  ;
  1936                                  ;	ENTRY	nothing
  1937                                  ;
  1938                                  ;	EXIT	nothing
  1939                                  ;
  1940                                  ;	USED	flags
  1941                                  ;
  1942                                  ;	EFFECTS
  1943                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  1944                                  ;	  current program's stdin,stdout set to our stderr
  1945                                  ;
  1946                                  
  1947                                  ;SR;
  1948                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  1949                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  1950                                  ;
  1951                                  SAVHAND:
  1952                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  1953                                  
  1954 000002E7 1E                      	push	ds ; MSDOS 3.3
  1955 000002E8 53                      	push	bx			;preserve registers
  1956 000002E9 50                      	push	ax
  1957                                  	;push	es
  1958                                  	;push	ds			; save DATARES value
  1959                                  
  1960 000002EA B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1961 000002EC CD21                    	int	21h			; BX = user's header seg addr
  1962 000002EE 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  1963 000002F0 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h]	; DS:BX = ptr to JFN table
  1964 000002F4 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  1965                                  
  1966                                  	;pop	es			;es = DATARES
  1967                                  	;push	es			;save it back on stack
  1968                                  	;mov	es:Handle01,ax		; save user's stdin, stdout
  1969 000002F6 2EA3[960A]              	mov	[cs:HANDLE01],ax
  1970                                  
  1971                                  ;SR;
  1972                                  ; Use es to address Handle01 & our JFN_Table
  1973                                  ;
  1974                                  
  1975                                  	;mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
  1976 000002FA 2EA01A00                	mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  1977 000002FE 88C4                    	mov	ah,al			; AH = COMMAND stderr
  1978 00000300 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  1979                                  
  1980                                  	;pop	ds			; restore registers
  1981                                  	;pop	es
  1982 00000302 58                      	pop	ax
  1983 00000303 5B                      	pop	bx
  1984 00000304 1F                      	pop	ds ; MSDOS 3.3
  1985 00000305 C3                      	retn
  1986                                  
  1987                                  	;assume	ds:DATARES
  1988                                  GETCOMDSK2:
  1989 00000306 E81F00                  	call	GETCOMDSK
  1990 00000309 E90DFF                  	jmp	LODCOM1			; memory already allocated
  1991                                  
  1992                                  RESTHAND:
  1993 0000030C 1E                      	push	ds
  1994 0000030D 53                      	push	bx			; restore stdin, stdout to user
  1995 0000030E 50                      	push	ax
  1996 0000030F B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1997 00000311 CD21                    	int	21h			; point to user's header
  1998 00000313 A1[960A]                	mov	ax,[HANDLE01]
  1999 00000316 8EDB                    	mov	ds,bx
  2000                                  	;assume ds:NOTHING
  2001 00000318 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h] ; DS:BX = ptr to jfn table
  2002 0000031C 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  2003 0000031E 58                      	pop	ax
  2004 0000031F 5B                      	pop	bx
  2005 00000320 1F                      	pop	ds
  2006 00000321 C3                      	retn
  2007                                  
  2008                                  	;assume ds:DATARES,ss:DATARES
  2009                                  HOPELESS:
  2010 00000322 BA[EF08]                	mov	dx,COMBAD
  2011 00000325 E9E9FD                  	jmp	FATALC
  2012                                  
  2013                                  GETCOMDSK:
  2014 00000328 A0[E60A]                	mov	al,[COMDRV]
  2015 0000032B E86AFF                  	call	REMCHECK
  2016 0000032E 75F2                    	jnz	short HOPELESS		; non-removable media
  2017                                  GETCOMDSK3:
  2018 00000330 81FA[EF08]              	cmp	dx,COMBAD
  2019 00000334 7503                    	jne	short GETCOMDSK4
  2020                                  	;;mov	dx,offset DATARES:ComBad	; DX = ptr to msg
  2021                                  	;invoke	RPrint				; say COMMAND is invalid
  2022 00000336 E85D03                  	call	RDISPMSG
  2023                                  GETCOMDSK4:
  2024                                  ;	Bugbug:	there's always a drive here?  No need to check?
  2025 00000339 803E[2309]00            	cmp	byte [PUTBACKDRV],0	; is there a drive in the comspec?
  2026 0000033E 7509                    	jne	short USERS_DRIVE	; yes - use it
  2027 00000340 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  2028 00000342 CD21                    	int	21h
  2029 00000344 0441                    	add	al,"A"                  ; convert to ascii
  2030 00000346 A2[2309]                	mov	[PUTBACKDRV],al		; put in message to print out
  2031                                  
  2032                                  USERS_DRIVE:
  2033                                  	; MSDOS 6.0
  2034                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  2035                                  	;mov	si,offset DATARES:PutBackSubst	;  containing COMMAND
  2036                                  	;invoke	RPrint
  2037                                  	;mov	dx,offset DATARES:Prompt	; "Press any key"
  2038                                  	;invoke	RPrint
  2039                                  
  2040                                  	; MSDOS 3.3
  2041 00000349 BA[0709]                	mov	dx,PUTBACKMSG		; prompt for diskette
  2042 0000034C E84703                  	call	RDISPMSG
  2043 0000034F 8B16[DB0A]              	mov	dx,[PUTBACKSUBSTPTR]
  2044 00000353 8B36[DD0A]              	mov	si,[COMSPEC_END]
  2045 00000357 C6440124                	mov	byte [si+1],'$'
  2046 0000035B E83803                  	call	RDISPMSG
  2047 0000035E C6440100                	mov	byte [si+1],0
  2048 00000362 BA[1909]                	mov	dx,PROMPT
  2049 00000365 E82E03                  	call    RDISPMSG
  2050                                  
  2051 00000368 E80100                  	call	GETRAWFLUSHEDBYTE
  2052 0000036B C3                      	retn
  2053                                  
  2054                                  ;***	GetRawFlushedByte - flush world and get raw input
  2055                                  
  2056                                  GETRAWFLUSHEDBYTE:
  2057 0000036C B8070C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  2058 0000036F CD21                    	int	21h			; get char without testing or echo
  2059 00000371 B8000C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  2060 00000374 CD21                    	int	21h
  2061                                  ;	Bugbug:	get rid of this return and the following retz.
  2062                                  LOADCOM_RETN:
  2063 00000376 C3                      	retn
  2064                                  
  2065                                  ;***	LoadCom - load in transient
  2066                                  
  2067                                  LOADCOM:
  2068                                  	;assume	ds:DATARES
  2069                                  	
  2070 00000377 45                      	inc	bp				; flag command read
  2071                                  
  2072 00000378 BA[9B0A]                	mov	dx,COMSPEC
  2073 0000037B B8003D                  	mov	ax,OPEN<<8	; 3D00h
  2074 0000037E CD21                    	int	21h				; open command.com
  2075 00000380 7310                    	jnc	short READCOM
  2076 00000382 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  2077 00000385 7506                    	jnz	short TRYDOOPEN
  2078 00000387 BA[AA09]                	mov	dx,NOHANDMES
  2079 0000038A E984FD                  	jmp	FATALC				; will never find a handle
  2080                                  
  2081                                  TRYDOOPEN:
  2082 0000038D E898FF                  	call	GETCOMDSK
  2083 00000390 EBE5                    	jmp	short LOADCOM
  2084                                  
  2085                                  READCOM:
  2086 00000392 89C3                    	mov	bx,ax				; BX = handle
  2087 00000394 BA[5015]                	mov	dx,TRANSTART
  2088 00000397 31C9                    	xor	cx,cx				; CX:DX = seek loc
  2089 00000399 B80042                  	mov	ax,LSEEK<<8	; 4200h
  2090 0000039C CD21                    	int	21h
  2091 0000039E 7210                    	jc	short WRONGCOM1
  2092 000003A0 B93C4C                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  2093 000003A3 1E                      	push	ds
  2094 000003A4 8E1E[E10A]              	mov	ds,[TRNSEG]
  2095                                  	;assume	ds:NOTHING
  2096 000003A8 BA0001                  	mov	dx,100h
  2097 000003AB B43F                    	mov	ah,READ	; 3Fh	
  2098 000003AD CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  2099                                  			; BX = file handle, CX = number of bytes to read
  2100                                  			; DS:DX -> buffer
  2101 000003AF 1F                      	pop	ds
  2102                                  	;assume	ds:DATARES
  2103                                  WRONGCOM1:
  2104 000003B0 9C                      	pushf
  2105 000003B1 50                      	push	ax
  2106 000003B2 B43E                    	mov	ah,CLOSE ; 3Eh
  2107 000003B4 CD21                    	int	21h			; close command.com
  2108 000003B6 58                      	pop	ax
  2109 000003B7 9D                      	popf
  2110 000003B8 7204                    	jc	short WRONGCOM		; error on read
  2111 000003BA 39C8                    	cmp	ax,cx
  2112                                  	;retz				; size matched
  2113 000003BC 74B8                    	jz	short LOADCOM_RETN
  2114                                  WRONGCOM:
  2115 000003BE BA[EF08]                	mov	dx,COMBAD
  2116 000003C1 E864FF                  	call	GETCOMDSK
  2117 000003C4 EBB1                    	jmp	short LOADCOM		; try again
  2118                                  
  2119                                  
  2120                                  ;***	ChkSum - compute transient checksum
  2121                                  
  2122                                  CHKSUM:
  2123 000003C6 1E                      	push	ds
  2124 000003C7 8E1E[E10A]              	mov	ds,[TRNSEG]
  2125 000003CB BE0001                  	mov	si,100h
  2126 000003CE B9243E                  	mov	cx,TRANDATAEND-100H	; 3E44h (for original MSDOS 3.3!)
  2127                                  
  2128                                  CHECK_SUM:
  2129 000003D1 FC                      	cld
  2130 000003D2 D1E9                    	shr	cx,1
  2131 000003D4 31D2                    	xor	dx,dx
  2132                                  CHK:
  2133 000003D6 AD                      	lodsw
  2134 000003D7 01C2                    	add	dx,ax
  2135 000003D9 83D200                  	adc	dx,0
  2136 000003DC E2F8                    	loop	CHK
  2137 000003DE 1F                      	pop	ds
  2138 000003DF C3                      	retn
  2139                                  
  2140                                  ;***	SetVect - set interrupt vectors
  2141                                  
  2142                                  SETVECT:
  2143                                  	;mov	dx,offset DATARES:LodCom_Trap 
  2144 000003E0 BA[AD01]                	mov	dx,LODCOM ; MSDOS 3.3
  2145 000003E3 B82225                  	mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  2146 000003E6 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  2147 000003EA 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  2148 000003EE CD21                    	int	21h
  2149                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  2150 000003F0 BA[3C00]                	mov	dx,CONTC ; MSDOS 3.3
  2151 000003F3 FEC0                    	inc	al	; 23h
  2152 000003F5 CD21                    	int	21h
  2153                                  	;mov	dx,offset DATARES:CritErr_Trap
  2154 000003F7 BA[4F04]                	mov	dx,CRITERR ; MSDOS 3.3
  2155 000003FA FEC0                    	inc	al	; 24h
  2156 000003FC CD21                    	int	21h
  2157 000003FE C3                      	retn
  2158                                  
  2159                                  	; MSDOS 6.0
  2160                                  ;;SR;
  2161                                  ;; We have this to take care of the extra values pushed on the stack by 
  2162                                  ;;the stub before jumping to LodCom1. We set up ds here and then jump to
  2163                                  ;;Lodcom1
  2164                                  ;;
  2165                                  ;public	TrnLodCom1
  2166                                  ;TrnLodCom1:
  2167                                  ;	pop	ds			;ds = DATARES
  2168                                  ;	add	sp,2
  2169                                  ;;	pop	ds:OldDS
  2170                                  ;	jmp	LodCom1
  2171                                  
  2172                                  ;***	EndInit - end up initialization sequence
  2173                                  ;
  2174                                  ;	Move the environment to a newly allocated segment.
  2175                                  
  2176                                  	; MSDOS 3.3
  2177                                  ENDINIT:
  2178 000003FF 1E                      	push	ds			; save segments
  2179 00000400 06                      	push	es			;
  2180 00000401 0E                      	push	cs			; get resident segment to DS
  2181 00000402 1F                      	pop	ds			;
  2182                                  	;assume	ds:RESGROUP
  2183 00000403 8B0E[0615]              	mov	cx,[USEDENV]		; get number of bytes to move
  2184 00000407 8E06[050C]              	mov	es,[ENVIRSEG]		; get target environment segment
  2185                                  	;assume	es:NOTHING
  2186                                  
  2187 0000040B 803E[0C15]01            	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  2188 00000410 750A                    	jne	short NO_RESET 		; no - we already did it
  2189 00000412 8B1E[0015]              	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  2190 00000416 06                      	push	es			; save environment - just to be sure
  2191 00000417 B44A                    	mov	ah,SETBLOCK  ; 4Ah	;
  2192 00000419 CD21                    	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2193                                  				; ES = segment address of block to change
  2194                                  				; BX = new size in paragraphs
  2195 0000041B 07                      	pop	es
  2196                                  
  2197                                  NO_RESET:
  2198 0000041C 8C062C00                	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  2199 00000420 8E1E[0415]              	mov	ds,[OLDENV]		; source environment segment
  2200                                  	;assume	ds:NOTHING
  2201 00000424 31F6                    	xor	si,si			; set up offsets to start of segments
  2202 00000426 31FF                    	xor	di,di
  2203 00000428 FC                      	cld
  2204 00000429 F3A4                    	rep	movsb			; move it
  2205 0000042B 31C0                    	xor	ax,ax
  2206 0000042D AA                      	stosb				; make sure it ends with double-null
  2207                                  
  2208                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  2209 0000042E 07                      	pop	es
  2210 0000042F 1F                      	pop	ds
  2211 00000430 E97AFD                  	jmp	LODCOM			; allocate transient
  2212                                  
  2213                                  
  2214                                  	; MSDOS 6.0
  2215                                  ;
  2216                                  ;The init code has been changed to take care of the new way in which the
  2217                                  ;environment segment is allocated.
  2218                                  ;NB: We can use all the init variables at this point because they are all in
  2219                                  ;RESGROUP
  2220                                  ;Bugbug: The above approach will not work for ROMDOS
  2221                                  ;
  2222                                  
  2223                                  ;IF 0
  2224                                  ;
  2225                                  ;EndInit:
  2226                                  ;	push	ds
  2227                                  ;	push	es			;save segments
  2228                                  ;	push	cs
  2229                                  ;	pop	ds		
  2230                                  ;	assume	ds:RESGROUP
  2231                                  ;;
  2232                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  2233                                  ;;
  2234                                  ;	mov	bx,ds
  2235                                  ;	mov	es,bx			;es = RESGROUP
  2236                                  ;;
  2237                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2238                                  ;; code + data for low COMMAND
  2239                                  ;;
  2240                                  ;	mov	bx,ResSize		;Total size of resident
  2241                                  ;	mov	ah,SETBLOCK
  2242                                  ;	int	21h			;Set block to resident size
  2243                                  ;;
  2244                                  ;;Allocate the correct size for the environment
  2245                                  ;;
  2246                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  2247                                  ;	mov	ah,ALLOC
  2248                                  ;	int	21h			;get memory
  2249                                  ;	jc	nomem_err		;out of memory,signal error
  2250                                  ;
  2251                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  2252                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  2253                                  ;	mov	es,ax			;es = address of allocated memory
  2254                                  ;	assume	es:nothing
  2255                                  ;
  2256                                  ;;
  2257                                  ;;Copy the environment to the newly allocated segment
  2258                                  ;;
  2259                                  ;	mov	cx,UsedEnv		;number of bytes to move
  2260                                  ;
  2261                                  ;	push	ds
  2262                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  2263                                  ;	assume	ds:nothing
  2264                                  ;
  2265                                  ;	xor	si,si
  2266                                  ;	mov	di,si			;Start transfer from 0
  2267                                  ;
  2268                                  ;	cld
  2269                                  ;	rep	movsb			;Do the copy
  2270                                  ;
  2271                                  ;	xor	ax,ax			
  2272                                  ;	stosb				;Make it end with double-null
  2273                                  ;
  2274                                  ;	pop	ds			;ds = RESGROUP
  2275                                  ;	assume	ds:RESGROUP
  2276                                  ;;
  2277                                  ;;We have to free the old environment block if it was allocated by INIT
  2278                                  ;;
  2279                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  2280                                  ;	je      no_free                 ;no, do not free it
  2281                                  ;
  2282                                  ;	mov	ax,OldEnv		;Get old environment
  2283                                  ;	mov	es,ax
  2284                                  ;	mov	ah,DEALLOC	
  2285                                  ;	int	21h			;Free it
  2286                                  ;no_free:
  2287                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  2288                                  ;	
  2289                                  ;	pop	es
  2290                                  ;	pop	ds
  2291                                  ;	assume	ds:nothing
  2292                                  ;	
  2293                                  ;	jmp	LodCom			;allocate transient
  2294                                  ;
  2295                                  ;nomem_err:
  2296                                  ;;
  2297                                  ;;We call the error routine which will never return. It will either exit
  2298                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  2299                                  ;;message ( if first COMMAND )
  2300                                  ;;
  2301                                  ;
  2302                                  ;	call	Alloc_error
  2303                                  ;ENDIF
  2304                                  ;
  2305                                  ;CODERES ends
  2306                                  
  2307                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2308                                  ;	the resident group which is the location where the transient
  2309                                  ;	segments will be loaded initial.
  2310                                  
  2311                                  ;TAIL		segment public para
  2312                                  ;
  2313                                  ;		org	0
  2314                                  ;TranStart	label	word
  2315                                  ;		public	TranStart
  2316                                  ;
  2317                                  ;TAIL		ends
  2318                                  ;
  2319                                  
  2320                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2321                                  ;	the transient group which is the location where the exec
  2322                                  ;	segments will be loaded initial.
  2323                                  ;
  2324                                  ;	Bugbug:	Is TRANTAIL used anymore?
  2325                                  
  2326                                  ;TRANTAIL	segment public para
  2327                                  ;
  2328                                  ;		org	0
  2329                                  ;ExecStart   	label   word
  2330                                  ;
  2331                                  ;TRANTAIL    	ends
  2332                                  
  2333                                  ;=============================================================================
  2334                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  2335                                  ;=============================================================================
  2336                                  ; 22/09/2018 - Retro DOS v3.0
  2337                                  
  2338                                  ;	title	Localizable code for resident COMMAND
  2339                                  
  2340                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2341                                  
  2342                                  ;***	AskEnd - ask user to confirm batch file termination
  2343                                  ;
  2344                                  ;	Confirm with user before freeing batch ...
  2345                                  ;
  2346                                  ;	ENTRY	nothing
  2347                                  ;
  2348                                  ;	EXIT	CY = set if batch termination is confirmed
  2349                                  ;
  2350                                  ;		CY = clear if batch should continue
  2351                                  ;
  2352                                  ;	USED	AX,DX,...
  2353                                  
  2354                                  ;	Bugbug:	move this to transient, copy to batch segment.
  2355                                  ;	Bugbug:	or move it to command1 1st.
  2356                                  
  2357                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  2358                                  
  2359                                  ASKEND:
  2360                                  	;assume	ds:DATARES
  2361                                  
  2362 00000433 BA[4609]                	mov	dx,ENDBATMES			; DX = message #
  2363                                  	;call	RPrint
  2364 00000436 E85D02                  	call	RDISPMSG  ; MSDOS 3.3
  2365 00000439 B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  2366 0000043C CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  2367                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  2368 0000043E E85D02                  	call	CHARTOUPPER			; change to upper case
  2369 00000441 3A06[7E0A]              	cmp	al,[NO_CHAR]
  2370 00000445 7407                    	je	short AERET			; answer is no (CY is clear)
  2371 00000447 3A06[7D0A]              	cmp	al,[YES_CHAR]
  2372 0000044B 75E6                    	jne	short ASKEND			; invalid response, try again
  2373 0000044D F9                      	stc					; answer is yes
  2374                                  AERET:	
  2375 0000044E C3                      	retn
  2376                                  
  2377                                  
  2378                                  ;***	DskErr - critical error handler
  2379                                  ;
  2380                                  ;	Default critical error handler unless user intercepts int 24h.
  2381                                  ;
  2382                                  ;	ENTRY	int 24h
  2383                                  ;
  2384                                  ;	EXIT
  2385                                  ;
  2386                                  ;	USED
  2387                                  ;
  2388                                  ;	EFFECTS
  2389                                  
  2390                                  ;
  2391                                  ;SR; 
  2392                                  ; The stub is going to push the old ds value and the resident data segment
  2393                                  ;onto the stack in that order. Get it off the stack
  2394                                  ;
  2395                                  
  2396                                  ;DskErr	proc	far
  2397                                  DSKERRR:
  2398                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2399                                  	;
  2400                                  	;pop	ds			;ds = DATARES
  2401                                  	;assume ds:DATARES
  2402                                  	;pop	OldDS			;save old ds value
  2403                                  
  2404                                  CRITERR: ; MSDOS 3.3
  2405 0000044F FB                      	sti
  2406 00000450 1E                      	push	ds ; 25/09/2018
  2407 00000451 06                      	push	es
  2408 00000452 56                      	push	si
  2409 00000453 51                      	push	cx
  2410 00000454 57                      	push	di
  2411 00000455 51                      	push	cx
  2412 00000456 50                      	push	ax
  2413                                  
  2414                                  	;push	ds			;save our data segment
  2415 00000457 0E                      	push	cs ; 25/09/2018
  2416 00000458 07                      	pop	es			;es = DATARES
  2417                                  
  2418 00000459 8EDD                    	mov	ds,bp
  2419                                  	;assume	ds:nothing
  2420                                  
  2421                                  	;mov	ax,[si].SDEVATT
  2422 0000045B 8B4404                  	MOV	ax,[SI+SYSDEV.ATT] ; mov ax,[si+4]	
  2423 0000045E 268826[D108]            	mov	[es:CDEVAT],ah
  2424                                  
  2425                                  	;push	cs
  2426                                  	;pop	es
  2427                                  
  2428 00000463 BF[A508]                	mov	di,DEVNAME
  2429 00000466 B90800                  	mov	cx,8
  2430                                  	;add	si,SDEVNAME  ; add si,10
  2431 00000469 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  2432                                  				
  2433 0000046C FC                      	cld
  2434 0000046D F3A4                    	rep	movsb
  2435 0000046F 58                      	pop	ax
  2436 00000470 59                      	pop	cx
  2437 00000471 5F                      	pop	di
  2438                                  
  2439                                  ;	Stack still contains DS and ES.
  2440                                  
  2441                                  ;SR;
  2442                                  ; We need ds = DATARES for SavHand
  2443                                  ;
  2444                                  	;push	es
  2445                                  	;pop	ds
  2446                                  	;assume	ds:DATARES
  2447                                  
  2448                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  2449 00000472 E872FE                  	call	SAVHAND
  2450                                  
  2451                                  	; 25/09/2018
  2452                                  	;push	cs
  2453 00000475 06                      	push	es
  2454 00000476 1F                      	pop	ds		; set up local data segment
  2455                                  	;assume	ds:resgroup
  2456                                  
  2457 00000477 52                      	push	dx
  2458 00000478 E81802                  	call	CRLF
  2459 0000047B 5A                      	pop	dx
  2460                                  
  2461                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  2462                                  
  2463 0000047C 8826[EE0A]              	mov	[CRIT_ERR_INFO],ah	; save critical error flags
  2464                                  
  2465                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  2466                                  
  2467 00000480 0441                    	add	al,'A'
  2468 00000482 A2[9908]                	mov	[DRVLET],al
  2469                                  
  2470                                  ;	Bugbug:	These labels are awful.  Change, especially 'NoHardE'.
  2471                                  
  2472 00000485 F6C480                  	test	ah,80h
  2473 00000488 740A                    	jz	short NOHARDE		; it's a disk-device error
  2474 0000048A F606[D108]80            	test	byte [CDEVAT],DEVTYP>>8 ; 80h
  2475 0000048F 7503                    	jnz	short NOHARDE		; it's a character device
  2476 00000491 E9EF01                  	jmp	FATERR			; it's a FAT error
  2477                                  
  2478                                  NOHARDE:
  2479 00000494 BE[7A08]                	mov	si,MREAD		; SI = "read" msg #
  2480 00000497 F6C401                  	test	ah,1
  2481 0000049A 7403                    	jz	short SAVMES		  ; it's a read error
  2482 0000049C BE[8208]                	mov	si,MWRITE		; SI = "write" msg #
  2483                                  
  2484                                  SAVMES:
  2485 0000049F 893E[270C]              	mov	[OLDERRNO],di		; save critical error code
  2486                                  
  2487                                  ;	Bugbug:	don't need to save/restore all here?
  2488 000004A3 06                      	push	es
  2489 000004A4 1E                      	push	ds			; GetExtendedError likes to STOMP
  2490 000004A5 55                      	push	bp
  2491 000004A6 56                      	push	si
  2492 000004A7 52                      	push	dx
  2493 000004A8 51                      	push	cx
  2494 000004A9 53                      	push	bx
  2495 000004AA B459                    	mov	ah,GetExtendedError ; 59h ; get extended error info
  2496 000004AC CD21                    	int	21h
  2497 000004AE 5B                      	pop	bx
  2498 000004AF 59                      	pop	cx
  2499 000004B0 5A                      	pop	dx
  2500 000004B1 5E                      	pop	si
  2501 000004B2 5D                      	pop	bp
  2502 000004B3 1F                      	pop	ds
  2503 000004B4 893E[830A]              	mov	[NEEDVOL],di 	; save possible ptr to volume label
  2504 000004B8 8C06[850A]              	mov	[NEEDVOL+2],es
  2505 000004BC 07                      	pop	es
  2506                                  
  2507                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  2508                                  
  2509 000004BD 30E4                    	xor	ah,ah
  2510 000004BF 89C7                    	mov	di,ax			; DI = error code
  2511                                  
  2512                                  ; Bugbug:  somewhat obsolete documentation?
  2513                                  ;
  2514                                  ; DI is now the correct error code. Classify things to see what we are
  2515                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  2516                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  2517                                  ; the like) are contiguous.
  2518                                  ;
  2519                                  
  2520                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  2521                                  ;	Check use of ErrCd_24, though.
  2522                                  
  2523 000004C1 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  2524 000004C4 7303                    	jae	short HAVCOD
  2525                                  
  2526                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  2527                                  ;	even though it's not a critical error?
  2528                                  
  2529 000004C6 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  2530                                  ;
  2531                                  ; DI now has the mapped error code. Old style errors are:
  2532                                  ;   FOOBAR <read|writ>ing drive ZZ.
  2533                                  ; New style errors are:
  2534                                  ;   FOOBAR
  2535                                  ; We need to figure out which the particular error belongs to.
  2536                                  ;
  2537                                  
  2538                                  HAVCOD:
  2539 000004C9 C606[870A]00            	mov	byte [ERRTYPE],0	; assume old style
  2540 000004CE 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  2541 000004D1 7405                    	je	short SETSTYLE
  2542 000004D3 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2543 000004D6 7504                    	jne	short GOTSTYLE
  2544                                  
  2545                                  SETSTYLE:
  2546                                  ;	Bugbug:	use INC
  2547                                  	;mov	byte [ERRTYPE],1		; must be new type
  2548 000004D8 FE06[870A]              	inc	byte [ERRTYPE] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  2549                                  
  2550                                  GOTSTYLE:
  2551 000004DC 893E[940A]              	mov	[ERRCD_24],di
  2552                                  	; 25/09/2018
  2553                                  	; MSDOS 6.0
  2554                                  	;cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  2555                                  	; MSDOS 3.3
  2556 000004E0 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2557                                  
  2558                                  						; If the error message is unknown
  2559 000004E3 7641                    	jbe	short NORMALERROR		;  redirector, continue. Otherwise,
  2560                                  ;
  2561                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  2562                                  ; how to handle things
  2563                                  ;
  2564                                  
  2565                                  ;input to IFSFUNC:    AL=1
  2566                                  ;		      BX=extended error number
  2567                                  ;
  2568                                  ;output from IFSFUNC: AL=error type (0 or 1)
  2569                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  2570                                  ;			   Abort, Retry, Ignore
  2571                                  ;			 1=<message>
  2572                                  ;			   Abort, Retry, Ignore
  2573                                  ;		      ES:DI=pointer to message text
  2574                                  ;		      carry set=>no message
  2575                                  
  2576 000004E5 89C7                    	mov	di,ax			; retrieve correct extended error...
  2577 000004E7 B80005                  	mov	ax,0500h		; is the redir there?
  2578 000004EA CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  2579                                  			; Return: AL = 00h not installed, OK to install
  2580                                  			; 01h not installed, can't install
  2581                                  			; FFh installed
  2582 000004EC 3CFF                    	cmp	al,0FFh
  2583 000004EE 7529                    	jne	short NOHANDLER		; no, go to NoHandler
  2584                                  
  2585                                  	; MSDOS 6.0
  2586                                  	;push	bx
  2587                                  	;mov	bx,di			; get ErrType and ptr to error msg
  2588                                  	;mov	ax,0501h
  2589 000004F0 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2590                                  	;pop	bx 
  2591                                  	;jc	short NOHANDLER
  2592                                  	; MSDOS 3.3
  2593 000004F2 89F8                    	mov     ax,di
  2594 000004F4 B405                    	mov     ah,5
  2595 000004F6 CD2F                    	int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2596 000004F8 721F                    	jc      short NOHANDLER
  2597                                  
  2598                                  ;	Bugbug:	need to record error type?
  2599 000004FA A2[870A]                	mov	[ERRTYPE],al
  2600 000004FD 1E                      	push	ds
  2601 000004FE 06                      	push	es
  2602 000004FF 1F                      	pop	ds
  2603 00000500 89FA                    	mov	dx,di
  2604 00000502 B9FFFF                  	mov	cx,-1			; find end of msg
  2605 00000505 30C0                    	xor	al,al
  2606                                  
  2607 00000507 FC                      	cld
  2608 00000508 F2AE                    	repnz	scasb
  2609                                  
  2610                                  ;	Bugbug:	we can do better than this.
  2611                                  
  2612 0000050A C645FF24                	mov	byte [di-1],'$'
  2613                                  	
  2614                                  	;CALL	RDISPMSG ; MSDOS 3.3
  2615                                  	
  2616 0000050E B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  2617 00000510 CD21                    	int	21h
  2618                                  
  2619 00000512 C645FF00                	mov	byte [di-1],0			; restore terminal byte
  2620                                  
  2621 00000516 1F                      	pop	ds				; clean up and continue
  2622 00000517 EB18                    	jmp	short CHECKERRTYPE
  2623                                  
  2624                                  ;*	Redir isn't available or doesn't recognize the error.
  2625                                  ;	Restore regs to unextended error.
  2626                                  
  2627                                  NOHANDLER:
  2628 00000519 C606[870A]00            	mov	byte [ERRTYPE],0
  2629                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  2630 0000051E 8B3E[270C]              	mov	di,[OLDERRNO]
  2631 00000522 893E[940A]              	mov	[ERRCD_24],di
  2632                                  
  2633                                  NORMALERROR:
  2634                                  	; MSDOS 6.0
  2635                                  	;add	di,ERROR_WRITE_PROTECT
  2636                                  	;xchg	di,dx			; may need dx later
  2637                                  	;call	RPrintCrit		; print error type
  2638                                  
  2639                                  	; MSDOS 3.3
  2640 00000526 D1E7                    	shl     di,1
  2641 00000528 8BBD[4207]              	mov     di,[CRMSGTBL+di]
  2642 0000052C 87FA                    	xchg    di,dx
  2643 0000052E E86501                  	call    RDISPMSG
  2644                                  
  2645                                  CHECKERRTYPE:
  2646 00000531 803E[870A]00            	cmp	byte [ERRTYPE],0	; Check error style...
  2647 00000536 7405                    	je	short CONTOLD
  2648 00000538 E85801                  	call	CRLF			; if new style then done printing
  2649 0000053B EB2E                    	jmp	short ASK
  2650                                  
  2651                                  CONTOLD:
  2652                                  	; MSDOS 6.0
  2653                                  ;	inc	si			; DS:SI = ptr to asciiz string
  2654                                  ;
  2655                                  ;;	Bugbug:	combine some of the following two sections?
  2656                                  ;
  2657                                  ;	test	[CDevAt],DEVTYP shr 8
  2658                                  ;	jz	BlkErr
  2659                                  ;	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
  2660                                  ;	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
  2661                                  ;	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  2662                                  ;
  2663                                  ;	call	RPrint				; print the message
  2664                                  ;	jmp	short Ask			; don't ralph on command
  2665                                  
  2666                                  	; MSDOS 3.3
  2667 0000053D BA[8A08]                	mov	dx,ERRMES
  2668 00000540 E85301                  	call	RDISPMSG
  2669 00000543 89F2                    	mov	dx,si
  2670 00000545 E84E01                  	call	RDISPMSG
  2671                                  	
  2672 00000548 F606[D108]80            	test	byte [CDEVAT], 80h
  2673 0000054D 7409                    	jz	short BLKERR
  2674 0000054F BA[9D08]                	mov	dx,CHARDEVERR	; " device "
  2675 00000552 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  2676 00000554 CD21                    	int	21h		; DOS - PRINT STRING
  2677                                  				; DS:DX -> string terminated by "$"
  2678 00000556 EB13                    	jmp	short ASK
  2679                                  
  2680                                  BLKERR:
  2681                                  	; MSDOS 6.0
  2682                                  	;mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
  2683                                  	;mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
  2684                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  2685                                  	;call	RPrint
  2686                                  
  2687                                  	; MSDOS 3.3
  2688 00000558 BA[9208]                	mov     dx,BLKDEVERR
  2689 0000055B E83801                  	call    RDISPMSG
  2690                                  
  2691 0000055E 803E[980A]00            	cmp	byte [LOADING],0
  2692 00000563 7406                    	jz	short ASK
  2693 00000565 E8A4FD                  	call	RESTHAND
  2694 00000568 E99BFD                  	jmp	GETCOMDSK2		; if error loading COMMAND, re-prompt
  2695                                  
  2696                                  ASK:
  2697 0000056B 833E[940A]0F            	cmp	word [ERRCD_24],15	; error 15 has an extra message
  2698 00000570 751C                    	jne	short NOT15		; not error 15
  2699                                  
  2700                                  ;*	For error 15, tell the user which volume/serial # are needed.
  2701                                  
  2702 00000572 51                      	push	cx
  2703                                  
  2704                                  ;	Bugbug:	does this push/pop need to be done?
  2705 00000573 1E                      	push	ds
  2706 00000574 07                      	pop	es
  2707 00000575 C536[830A]              	lds	si,[NEEDVOL]
  2708                                  	;assume	ds:NOTHING
  2709 00000579 57                      	push	di
  2710 0000057A BF[6C08]                	mov	di,VOLNAME
  2711                                  	; MSDOS 6.0
  2712                                  	;mov	cx,16			; copy volume name & serial #
  2713                                  	; MSDOS 3.3
  2714 0000057D B90B00                  	MOV	CX,11			; copy volume name
  2715 00000580 FC                      	cld
  2716 00000581 F3A4                    	rep	movsb
  2717 00000583 5F                      	pop	di
  2718 00000584 06                      	push	es
  2719 00000585 1F                      	pop	ds
  2720 00000586 59                      	pop	cx
  2721                                  	;assume	ds:DATARES
  2722                                  	; MSDOS 6.0
  2723                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  2724                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  2725                                  	;call	RPrint
  2726                                  
  2727                                  	; MSDOS 3.3
  2728 00000587 BA[5908]                	mov	dx,NEEDVOLMSG
  2729 0000058A B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2730 0000058C CD21                    	int     21h             ; DOS - PRINT STRING
  2731                                  				; DS:DX -> string terminated by "$"
  2732                                  NOT15:
  2733                                  ;*	Print abort, retry, ignore, fail message.
  2734                                  ;	Print only options that are valid.
  2735                                  
  2736                                  ;	Bugbug:	sizzle this.
  2737                                  
  2738 0000058E BA[B008]                	mov	dx,REQ_ABORT
  2739                                  	;call	RPrint
  2740 00000591 E80201                  	call	RDISPMSG
  2741 00000594 F606[EE0A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED  ; 10h
  2742 00000599 7406                    	jz	short TRY_IGNORE
  2743 0000059B BA[B608]                	mov	dx,REQ_RETRY
  2744                                  	;call	RPrint
  2745 0000059E E8F500                  	call	RDISPMSG
  2746                                  TRY_IGNORE:
  2747 000005A1 F606[EE0A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h
  2748 000005A6 7406                    	jz	short TRY_FAIL
  2749 000005A8 BA[BE08]                	mov	dx,REQ_IGNORE
  2750                                  	;call	RPrint
  2751 000005AB E8E800                  	call	RDISPMSG
  2752                                  TRY_FAIL:
  2753 000005AE F606[EE0A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED   ; 08h
  2754 000005B3 7406                    	jz	short TERM_QUESTION
  2755 000005B5 BA[C708]                	mov	dx,REQ_FAIL
  2756                                  	;call	RPrint
  2757 000005B8 E8DB00                  	call	RDISPMSG
  2758                                  TERM_QUESTION:
  2759 000005BB BA[CE08]                	mov	dx,REQ_END
  2760                                  	;call	RPrint
  2761 000005BE E8D500                  	call	RDISPMSG
  2762                                  
  2763                                  ;	If the /f switch was given, we fail all requests.
  2764                                  
  2765 000005C1 F606[F90A]FF            	test	byte [FFAIL],-1
  2766 000005C6 7405                    	jz	short DOPROMPT
  2767 000005C8 B403                    	mov	ah,3				; signal fail
  2768 000005CA E9AA00                  	jmp	EEXIT
  2769                                  
  2770                                  DOPROMPT:
  2771 000005CD B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  2772 000005D0 CD21                    	int	21h				; get response
  2773                                  
  2774 000005D2 E8BE00                  	call	CRLF
  2775 000005D5 E8C600                  	call	CHARTOUPPER			; convert to upper case
  2776 000005D8 B400                    	mov	ah,0				; return code for ignore
  2777 000005DA F606[EE0A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  2778 000005DF 7406                    	jz	short USER_RETRY
  2779 000005E1 3A06[810A]              	cmp	al,[IGNORE_CHAR]		; ignore?
  2780 000005E5 7429                    	jz	short EEXITJ
  2781                                  
  2782                                  ;	Bugbug:	optimize following code.
  2783                                  
  2784                                  USER_RETRY:
  2785 000005E7 FEC4                    	inc	ah				; return code for retry
  2786 000005E9 F606[EE0A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED ; 10h ; is retry allowed?
  2787 000005EE 7406                    	jz	short USER_ABORT
  2788 000005F0 3A06[7F0A]              	cmp	al,[RETRY_CHAR]			; retry?
  2789 000005F4 741A                    	jz	short EEXITJ
  2790                                  
  2791                                  USER_ABORT:
  2792 000005F6 FEC4                    	inc	ah				; return code for abort
  2793                                  						;  (abort always allowed)
  2794 000005F8 3A06[800A]              	cmp	al,[ABORT_CHAR]			; abort?
  2795 000005FC 7414                    	jz	short ABORT_PROCESS			; exit user program
  2796 000005FE FEC4                    	inc	ah				; return code for fail
  2797 00000600 F606[EE0A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED ; 08h ; is fail allowed?
  2798 00000605 7406                    	jz	short ASKJ
  2799 00000607 3A06[820A]              	cmp	al,[FAIL_CHAR]			; fail?
  2800 0000060B 7403                    	jz	short EEXITJ
  2801                                  ASKJ:
  2802 0000060D E95BFF                  	jmp	ASK
  2803                                  
  2804                                  EEXITJ:
  2805 00000610 EB65                    	jmp	short EEXIT
  2806                                  
  2807                                  ABORT_PROCESS:
  2808 00000612 F606[5B0B]01            	test	byte [INITFLAG],INITINIT ; 1	; COMMAND init interrupted?
  2809 00000617 741A                    	jz	short ABORTCONT			; no, handle it normally
  2810 00000619 803E[F40A]00            	cmp	byte [PERMCOM],0		; are we top level process?
  2811 0000061E 7408                    	jz	short JUSTEXIT			; yes, just exit
  2812                                  
  2813 00000620 BA[4E0A]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  2814                                  	;call	RPrint				; print it
  2815 00000623 E87000                  	call	RDISPMSG
  2816                                  
  2817                                  DEADINTHEWATER:
  2818 00000626 EBFE                    	jmp	short DEADINTHEWATER		; loop until the user reboots
  2819                                  
  2820                                  JUSTEXIT:
  2821                                  	;assume	ds:DATARES
  2822 00000628 A1[8E0A]                	mov	ax,[PARENT]			; load real parent pid
  2823 0000062B A31600                  	mov	[PDB.PARENT_PID],ax ; mov ds:16h,ax ; put it back where it belongs
  2824 0000062E B8FF4C                  	mov	ax,(EXIT<<8) | 255 ; 4CFFh
  2825 00000631 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  2826                                  				; AL = exit code
  2827                                  ABORTCONT:
  2828 00000633 F606[E40A]FF            	test	byte [IN_BATCH],-1		; Are we accessing a batch file?
  2829 00000638 7405                    	jz	short NOT_BATCH_ABORT
  2830 0000063A C606[E50A]01            	mov	byte [BATCH_ABORT],1		; set flag for abort
  2831                                  
  2832                                  NOT_BATCH_ABORT:
  2833 0000063F 8A16[5C0B]              	mov	dl,[PIPEFLAG]
  2834 00000643 E8B5FA                  	call	RESPIPEOFF
  2835 00000646 08D2                    	or	dl,dl
  2836 00000648 740D                    	je	short CHECKFORA
  2837 0000064A 833E[F50A]00            	cmp	word [SINGLECOM],0
  2838 0000064F 7406                    	je	short CHECKFORA
  2839 00000651 C706[F50A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2840                                  
  2841                                  CHECKFORA:
  2842 00000657 833E[940A]00            	cmp	word [ERRCD_24],0		; write protect?
  2843 0000065C 7407                    	je	short ABORTFOR
  2844 0000065E 833E[940A]02            	cmp	word [ERRCD_24],2		; drive not ready?
  2845 00000663 7512                    	jne	short EEXIT			; don't abort the FOR
  2846                                  
  2847                                  ABORTFOR:
  2848 00000665 C606[FB0A]00            	mov	byte [FORFLAG],0		; abort a FOR in progress
  2849 0000066A 833E[F50A]00            	cmp	word [SINGLECOM],0
  2850 0000066F 7406                    	je	short EEXIT
  2851 00000671 C706[F50A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2852                                  
  2853                                  EEXIT:
  2854 00000677 88E0                    	mov	al,ah
  2855 00000679 89FA                    	mov	dx,di
  2856                                  
  2857                                  RESTHD:
  2858 0000067B E88EFC                  	call    RESTHAND
  2859 0000067E 59                      	pop	cx
  2860 0000067F 5E                      	pop	si				; restore registers
  2861 00000680 07                      	pop	es
  2862                                  	
  2863                                  ;	; MSDOS 6.0
  2864                                  ;;;	pop	ds
  2865                                  ;;SR;
  2866                                  ;; ds has to be got from the variable we saved it in
  2867                                  ;;
  2868                                  ;
  2869                                  ; 	mov	ds,OldDS			;restore old value of ds
  2870                                  ;;	pop	ds
  2871                                  ;	assume	ds:nothing
  2872                                  
  2873                                  	; MSDOS 3.3
  2874 00000681 1F                      	pop	ds
  2875                                  
  2876 00000682 CF                      	iret
  2877                                  
  2878                                  FATERR:
  2879                                  	; MSDOS 6.0
  2880                                  	;mov	dx,offset DATARES:BadFatMsg
  2881                                  	;mov	si,offset DATARES:BadFatSubst
  2882                                  	;call	RPrint
  2883                                  
  2884                                  	; MSDOS 3.3
  2885 00000683 BA[D208]                	mov     dx,BADFATMSG
  2886 00000686 E80D00                  	call    RDISPMSG
  2887 00000689 BA[9208]                	mov     dx,BLKDEVERR
  2888 0000068C E80700                  	call    RDISPMSG
  2889                                  
  2890 0000068F B002                    	mov	al,2				; abort
  2891 00000691 EBE8                    	jmp	short RESTHD
  2892                                  
  2893                                  ;DskErr	endp
  2894                                  
  2895                                  	; MSDOS 6.0
  2896                                  ;***	RPrint - print message
  2897                                  ;***	Crlf - display cr/lf
  2898                                  ;
  2899                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  2900                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  2901                                  ;		variable fields related to substitution blocks are set
  2902                                  ;
  2903                                  ;	EXIT	nothing
  2904                                  ;
  2905                                  ;	USED	flags
  2906                                  ;
  2907                                  ;	EFFECTS
  2908                                  ;	  Message is displayed on stdout.
  2909                                  ;
  2910                                  ;	NOTE
  2911                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  2912                                  ;	    be greater than number of substition blocks present.
  2913                                  
  2914                                  ;
  2915                                  ;Crlf: 
  2916                                  ;	mov	dx,offset DATARES:Newlin	; cheap newline
  2917                                  ;
  2918                                  ;RPrint	proc
  2919                                  ;
  2920                                  ;	assume	ds:DATARES,ss:DATARES
  2921                                  ;
  2922                                  ;;	Bugbug:	do we need to save all reg's?
  2923                                  ;
  2924                                  ;	push	si			; preserve registers
  2925                                  ;	push	ax
  2926                                  ;	push	bx
  2927                                  ;	push	cx
  2928                                  ;	push	dx
  2929                                  ;
  2930                                  ;	mov	bx,si			; DS:BX = ptr to subst block
  2931                                  ;	mov	si,dx			; DS:SI = ptr to count byte
  2932                                  ;	lodsb				; AL = message length
  2933                                  ;					; DS:SI = ptr to message text
  2934                                  ;	xor	cx,cx
  2935                                  ;	mov	cl,al			; CX = message length
  2936                                  ;	jcxz	rpRet
  2937                                  ;
  2938                                  ;	call	RDispMsg
  2939                                  ;
  2940                                  ;rpRet:	pop	dx
  2941                                  ;	pop	cx
  2942                                  ;	pop	bx
  2943                                  ;	pop	ax
  2944                                  ;	pop	si
  2945                                  ;	ret
  2946                                  ;
  2947                                  ;RPrint	endp
  2948                                  
  2949                                  	; MSDOS 3.3
  2950                                  CRLF:
  2951 00000693 BA[9A08]                	mov     dx,NEWLIN
  2952                                  
  2953                                  RDISPMSG: ; Display message/text
  2954                                  	; DS:DX = ($ terminated) Message/Text address 
  2955 00000696 50                      	push    ax
  2956 00000697 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2957 00000699 F8                      	clc
  2958 0000069A CD21                    	int     21h             ; DOS - PRINT STRING
  2959                                  				; DS:DX -> string terminated by "$"
  2960 0000069C 58                      	pop     ax
  2961 0000069D C3                      	retn
  2962                                  
  2963                                  
  2964                                  	; MSDOS 6.0
  2965                                  
  2966                                  ;***	RPrintCrit - print critical error message
  2967                                  ;
  2968                                  ;	ENTRY	DX = extended error # (19-39)
  2969                                  ;
  2970                                  ;	EXIT	nothing
  2971                                  ;
  2972                                  ;	USED	flags
  2973                                  ;
  2974                                  ;	EFFECTS
  2975                                  ;	  Message is displayed on stdout
  2976                                  
  2977                                  ;RPrintCrit	proc
  2978                                  ;
  2979                                  ;	assume	ds:DATARES,ss:DATARES
  2980                                  ;
  2981                                  ;	push	dx			; preserve DX
  2982                                  ;	xchg	bx,dx			; BX = extended error #
  2983                                  ;					; DX = saved BX
  2984                                  ;	sub	bx,19			; BX = critical error index, from 0
  2985                                  ;	shl	bx,1			; BX = offset in word table
  2986                                  ;	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
  2987                                  ;	xchg	bx,dx			; DX = ptr to error msg
  2988                                  ;					; BX = restored
  2989                                  ;	call	RPrint			; print the message
  2990                                  ;	pop	dx			; restore DX
  2991                                  ;	ret
  2992                                  ;
  2993                                  ;RPrintCrit	endp
  2994                                  
  2995                                  
  2996                                  ;***	RDispMsg - display message
  2997                                  ;
  2998                                  ;	Display message, with substitutions, for RPrint.
  2999                                  ;
  3000                                  ;	ENTRY	DS:SI = ptr to message text
  3001                                  ;		CX = message length
  3002                                  ;		DS:BX = ptr to substitution block, if any
  3003                                  ;
  3004                                  ;	EXIT	nothing
  3005                                  ;
  3006                                  ;	USED	AX,CX,DX,SI
  3007                                  
  3008                                  ;RDispMsg	proc
  3009                                  ;
  3010                                  ;	assume	ds:DATARES,ss:DATARES
  3011                                  ;
  3012                                  ;rdNextChar:
  3013                                  ;	lodsb				; AL = next char
  3014                                  ;	cmp	al,'%'
  3015                                  ;	jne	rdOutChar		; not a substitution
  3016                                  ;	mov	dl,ds:[si]		; DL = possible '1' - '9'
  3017                                  ;	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  3018                                  ;	cmp	dl,9
  3019                                  ;	jae	rdOutChar		; not a substitution
  3020                                  ;
  3021                                  ;;*	A substitution code %1 - %9 has been encountered.
  3022                                  ;;	DL = 0-8, indicating %1-%9
  3023                                  ;;	DS:BX = ptr to substitution block
  3024                                  ;
  3025                                  ;	call	SubstMsg		; display the substitution
  3026                                  ;	inc	si			; SI = ptr past %n
  3027                                  ;	dec	cx			; count extra character in %n
  3028                                  ;	jmp	short rdCharDone
  3029                                  ;
  3030                                  ;;*	Normal character output.
  3031                                  ;
  3032                                  ;rdOutChar:
  3033                                  ;	mov	dl,al			; DL = char
  3034                                  ;	mov	ah,2			; AH = DOS Character Output code
  3035                                  ;	int	21h			; call DOS
  3036                                  ;rdCharDone:
  3037                                  ;	loop	rdNextChar
  3038                                  ;	ret
  3039                                  ;
  3040                                  ;RDispMsg	endp
  3041                                  
  3042                                  ;***	SubstMsg - display message substitution
  3043                                  ;
  3044                                  ;	Display a substitution string within a message.
  3045                                  ;	Substitution can be a char, an ASCIIZ string, or
  3046                                  ;	a word to be displayed as hex digits.
  3047                                  ;
  3048                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  3049                                  ;		DS:BX = ptr to substitution block
  3050                                  ;
  3051                                  ;	EXIT	nothing
  3052                                  ;
  3053                                  ;	USED	AX,DX
  3054                                  
  3055                                  ;SubstMsg	proc
  3056                                  ;
  3057                                  ;	assume	ds:DATARES,ss:DATARES
  3058                                  ;
  3059                                  ;	push	bx			; preserve BX
  3060                                  ;	push	cx			; preserve CX
  3061                                  ;
  3062                                  ;	mov	al,size SUBST		; AL = size of substitution block
  3063                                  ;	mul	dl			; AX = offset of desired subst block
  3064                                  ;	add	bx,ax			; DS:BX = ptr to desired subst block
  3065                                  ;
  3066                                  ;	mov	al,[bx].SubstType	; AX = substitution type flag
  3067                                  ;	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  3068                                  ;
  3069                                  ;;	AL = 1, 2, or 3 for char, string, or hex type
  3070                                  ;
  3071                                  ;	dec	al
  3072                                  ;	jz	smChar
  3073                                  ;	dec	al
  3074                                  ;	jz	smStr
  3075                                  ;
  3076                                  ;;*	Hex number substitution.
  3077                                  ;
  3078                                  ;	mov	ax,ds:[bx]		; AX = word value
  3079                                  ;	mov	cx,4			; CX = # digits to display
  3080                                  ;smDigit:
  3081                                  ;	rol	ax,1
  3082                                  ;	rol	ax,1
  3083                                  ;	rol	ax,1
  3084                                  ;	rol	ax,1			; AL<3:0> = next digit
  3085                                  ;
  3086                                  ;	push	ax			; save other digits
  3087                                  ;	and	al,0Fh			; AL = binary digit
  3088                                  ;	add	al,'0'			; AL = ascii digit if 0-9
  3089                                  ;	cmp	al,'9'
  3090                                  ;	jbe	@F			; it's 0-9
  3091                                  ;	add	al,'A' - '0' - 10	; AL = ascii digit A-F
  3092                                  ;@@:
  3093                                  ;	mov	dl,al			; DL = ascii digit
  3094                                  ;	mov	ah,2
  3095                                  ;	int	21h			; output the ascii digit
  3096                                  ;	pop	ax			; restore all digits
  3097                                  ;
  3098                                  ;	loop	smDigit
  3099                                  ;	jmp	short smRet
  3100                                  ;
  3101                                  ;;*	Char substitution.
  3102                                  ;
  3103                                  ;smChar:
  3104                                  ;	mov	dl,ds:[bx]		; DL = char to output
  3105                                  ;	mov	ah,2
  3106                                  ;	int	21h
  3107                                  ;	jmp	short smRet
  3108                                  ;
  3109                                  ;;*	String substitution.
  3110                                  ;
  3111                                  ;smStr:
  3112                                  ;	mov	dl,ds:[bx]		; DL = next char
  3113                                  ;	or	dl,dl
  3114                                  ;	jz	smRet			; null char - we're done
  3115                                  ;	mov	ah,2
  3116                                  ;	int	21h			; display char
  3117                                  ;	inc	bx			; DS:BX = ptr to next char
  3118                                  ;	jmp	smStr
  3119                                  ;
  3120                                  ;smRet:	pop	cx
  3121                                  ;	pop	bx
  3122                                  ;	ret
  3123                                  ;
  3124                                  ;SubstMsg	endp
  3125                                  
  3126                                  
  3127                                  	; MSDOS 6.0
  3128                                  
  3129                                  ;***	CharToUpper - convert character to uppercase
  3130                                  ;
  3131                                  ;	ENTRY	AL = char
  3132                                  ;
  3133                                  ;	EXIT	AL = uppercase char
  3134                                  ;
  3135                                  ;	USED	AX
  3136                                  
  3137                                  ;CharToUpper	proc
  3138                                  ;
  3139                                  ;	assume	ds:DATARES
  3140                                  ;
  3141                                  ;	push	ax		; put char on stack as arg to int 2F
  3142                                  ;	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  3143                                  ;	int	2Fh
  3144                                  ;	inc	sp		; throw away old char on stack
  3145                                  ;	inc	sp
  3146                                  ;	ret
  3147                                  ;
  3148                                  ;CharToUpper	endp
  3149                                  
  3150                                  	; MSDOS 3.3
  3151                                  CHARTOUPPER:
  3152 0000069E 3C80                    	cmp	al,80h
  3153 000006A0 7210                    	jb	short CHARTOUPPER1
  3154 000006A2 2C80                    	sub	al,80h
  3155 000006A4 1E                      	push	ds
  3156 000006A5 53                      	push	bx
  3157 000006A6 C51E[060B]              	lds	bx,[UPPERCASETBL]
  3158 000006AA 83C302                  	add	bx,2
  3159 000006AD D7                      	xlat
  3160 000006AE 5B                      	pop	bx
  3161 000006AF 1F                      	pop	ds
  3162 000006B0 EB0A                    	jmp	short CHARTOUPPER_RETN
  3163                                  CHARTOUPPER1:
  3164 000006B2 3C61                    	cmp	al,'a'
  3165 000006B4 7206                    	jb	short CHARTOUPPER_RETN
  3166 000006B6 3C7A                    	cmp	al,'z'
  3167 000006B8 7702                    	ja	short CHARTOUPPER_RETN
  3168 000006BA 2C20                    	sub	al,20h
  3169                                  CHARTOUPPER_RETN:
  3170 000006BC C3                      	retn
  3171                                  
  3172                                  ;public	EndCode
  3173                                  ;EndCode label	byte
  3174                                  
  3175                                  ;=============================================================================
  3176                                  ; RDATA.ASM, MSDOS 6.0, 1991
  3177                                  ;=============================================================================
  3178                                  ; 22/09/2018 - Retro DOS v3.0
  3179                                  
  3180                                  ;NOTE: This initialized rezident data is just as rezident data section/portion
  3181                                  ;      of the disassembled MSDOS 3.3 COMMAND.COM code.
  3182                                  ;   (MSDOS 6.0 RDATA.ASM is used for comments & descriptions about the RDATA.) 
  3183                                  
  3184                                  ; RDATA section of Retro DOS v2.0 'command2.s' (05/05/2018) has been modified 
  3185                                  ; for 'command3.s' (22/09/2018), here:
  3186                                  
  3187 000006BD 90                      ALIGN 2
  3188                                  	; 22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3189                                  RSTACK_SPACE:
  3190 000006BE 00<rep 80h>             	times 128 db 0
  3191                                  RSTACK:
  3192 0000073E 0000                    	dw 	0
  3193                                  
  3194                                  	; 25/09/2018	
  3195                                  	; (filler)
  3196 00000740 0000                    	dW	0
  3197                                  
  3198                                  RDATA	EQU	$
  3199                                  
  3200                                  ;TITLE   COMMAND Resident DATA
  3201                                  
  3202                                  ; Data for resident portion
  3203                                  
  3204                                  ;DATARES SEGMENT PUBLIC BYTE
  3205                                  
  3206                                  	;ORG     0
  3207                                  ;ZERO    =       $
  3208                                  
  3209                                  CRMSGTBL:
  3210 00000742 [6607]                  	dw	CRMSG0		; "Write protect$"
  3211 00000744 [7407]                  	dw	CRMSG1		; "Bad unit$"
  3212 00000746 [7D07]                  	dw	CRMSG2		; "Not ready$"
  3213 00000748 [8707]                  	dw	CRMSG3		; "Bad command $"
  3214 0000074A [9407]                  	dw	CRMSG4		; "Data$"
  3215 0000074C [9907]                  	dw	CRMSG5		; "Bad call format$"
  3216 0000074E [A907]                  	dw	CRMSG6		; "Seek$"
  3217 00000750 [AE07]                  	dw	CRMSG7		; "Non-DOS disk$"
  3218 00000752 [BB07]                  	dw	CRMSG8		; "Sector not found$"
  3219 00000754 [CC07]                  	dw	CRMSG9		; "No paper$"
  3220 00000756 [D507]                  	dw	CRMSG10		; "Write fault$"
  3221 00000758 [E107]                  	dw	CRMSG11		; "Read fault$"
  3222 0000075A [EC07]                  	dw	CRMSG12		; "General Failure$"
  3223 0000075C [FC07]                  	dw	CRMSG13		; "Sharing Violation$"
  3224 0000075E [0E08]                  	dw	CRMSG14		; "Lock Violation$"
  3225 00000760 [1D08]                  	dw	CRMSG15		; "Invalid Disk Change$"
  3226 00000762 [3108]                  	dw	CRMSG16		; "FCB unavailable$"
  3227 00000764 [4108]                  	dw	CRMSG17		; "Sharing buffer exceeded$"
  3228                                  
  3229 00000766 57726974652070726F-     CRMSG0:	 db 'Write protect$'
  3229 0000076F 7465637424         
  3230 00000774 42616420756E697424      CRMSG1:	 db 'Bad unit$'
  3231 0000077D 4E6F74207265616479-     CRMSG2:	 db 'Not ready$'
  3231 00000786 24                 
  3232 00000787 42616420636F6D6D61-     CRMSG3:	 db 'Bad command $'
  3232 00000790 6E642024           
  3233 00000794 4461746124              CRMSG4:	 db 'Data$'
  3234 00000799 4261642063616C6C20-     CRMSG5:	 db 'Bad call format$'
  3234 000007A2 666F726D617424     
  3235 000007A9 5365656B24              CRMSG6:	 db 'Seek$'
  3236 000007AE 4E6F6E2D444F532064-     CRMSG7:	 db 'Non-DOS disk$'
  3236 000007B7 69736B24           
  3237 000007BB 536563746F72206E6F-     CRMSG8:	 db 'Sector not found$'
  3237 000007C4 7420666F756E6424   
  3238 000007CC 4E6F20706170657224      CRMSG9:	 db 'No paper$'
  3239 000007D5 577269746520666175-     CRMSG10: db 'Write fault$'
  3239 000007DE 6C7424             
  3240 000007E1 52656164206661756C-     CRMSG11: db 'Read fault$'
  3240 000007EA 7424               
  3241 000007EC 47656E6572616C2046-     CRMSG12: db 'General Failure$'
  3241 000007F5 61696C75726524     
  3242 000007FC 53686172696E672056-     CRMSG13: db 'Sharing Violation$'
  3242 00000805 696F6C6174696F6E24 
  3243 0000080E 4C6F636B2056696F6C-     CRMSG14: db 'Lock Violation$'
  3243 00000817 6174696F6E24       
  3244 0000081D 496E76616C69642044-     CRMSG15: db 'Invalid Disk Change$'
  3244 00000826 69736B204368616E67-
  3244 0000082F 6524               
  3245 00000831 46434220756E617661-     CRMSG16: db 'FCB unavailable$'
  3245 0000083A 696C61626C6524     
  3246 00000841 53686172696E672062-     CRMSG17: db 'Sharing buffer exceeded$'
  3246 0000084A 756666657220657863-
  3246 00000853 656564656424       
  3247                                  
  3248 00000859 506C6561736520496E-     NEEDVOLMSG:	db 'Please Insert disk '
  3248 00000862 73657274206469736B-
  3248 0000086B 20                 
  3249 0000086C 00<rep Bh>              VOLNAME: times 11 db 0	; db 0Bh dup(0)
  3250 00000877 0D0A24                  		db 0Dh,0Ah,'$'
  3251 0000087A 72656164696E6724        MREAD:		db 'reading$'
  3252 00000882 77726974696E6724        MWRITE:		db 'writing$'
  3253 0000088A 206572726F722024        ERRMES:		db ' error $'
  3254 00000892 20647269766520          BLKDEVERR:	db ' drive '
  3255 00000899 41                      DRVLET:		db 'A'
  3256 0000089A 0D0A24                  NEWLIN:		db 0Dh,0Ah,'$'
  3257 0000089D 2064657669636520        CHARDEVERR:	db ' device '
  3258 000008A5 00<rep 8h>              DEVNAME: times 8 db 0 ; db 8 dup(0)
  3259 000008AD 0D0A24                  		db 0Dh,0Ah,'$'
  3260 000008B0 41626F727424            REQ_ABORT:	db 'Abort$'
  3261 000008B6 2C20526574727924        REQ_RETRY:	db ', Retry$'
  3262 000008BE 2C2049676E6F726524      REQ_IGNORE:	db ', Ignore$'
  3263 000008C7 2C204661696C24          REQ_FAIL:	db ', Fail$'
  3264 000008CE 3F2024                  REQ_END:	db '? $'
  3265 000008D1 00                      CDEVAT:		db 0
  3266 000008D2 0D0A46696C6520616C-     BADFATMSG:	db 0Dh,0Ah,'File allocation table bad,$'
  3266 000008DB 6C6F636174696F6E20-
  3266 000008E4 7461626C6520626164-
  3266 000008ED 2C24               
  3267 000008EF 0D0A496E76616C6964-     COMBAD:		db 0Dh,0Ah,'Invalid COMMAND.COM',0Dh,0Ah,'$'
  3267 000008F8 20434F4D4D414E442E-
  3267 00000901 434F4D0D0A24       
  3268 00000907 496E73657274206469-     PUTBACKMSG:	db 'Insert disk with $'
  3268 00000910 736B20776974682024 
  3269 00000919 20696E206472697665-     PROMPT:		db ' in drive '
  3269 00000922 20                 
  3270 00000923 200D0A616E64207374-     PUTBACKDRV:	db ' ',0Dh,0Ah, 'and strike any key when ready',0Dh,0Ah,'$'
  3270 0000092C 72696B6520616E7920-
  3270 00000935 6B6579207768656E20-
  3270 0000093E 72656164790D0A24   
  3271 00000946 0D0A5465726D696E61-     ENDBATMES:	db 0Dh,0Ah,'Terminate batch job (Y/N)? $'
  3271 0000094F 746520626174636820-
  3271 00000958 6A6F622028592F4E29-
  3271 00000961 3F2024             
  3272 00000964 45584543206661696C-     EXECEMES:	db 'EXEC failure',0Dh,0Ah,'$'
  3272 0000096D 7572650D0A24       
  3273 00000973 4572726F7220696E20-     EXEBAD:		db 'Error in EXE file',0Dh,0Ah,'$'
  3273 0000097C 4558452066696C650D-
  3273 00000985 0A24               
  3274 00000987 50726F6772616D2074-     TOOBIG:		db 'Program too big to fit in memory',0Dh,0Ah,'$'
  3274 00000990 6F6F2062696720746F-
  3274 00000999 2066697420696E206D-
  3274 000009A2 656D6F72790D0A24   
  3275 000009AA 0D0A4E6F2066726565-     NOHANDMES:	db 0Dh,0Ah,'No free file handles$'
  3275 000009B3 2066696C652068616E-
  3275 000009BC 646C657324         
  3276 000009C1 42616420436F6D6D61-     RBADNAM:	db 'Bad Command or file name',0Dh,0Ah,'$'
  3276 000009CA 6E64206F722066696C-
  3276 000009D3 65206E616D650D0A24 
  3277 000009DC 416363657373206465-     ACCDEN:		db 'Access denied',0Dh,0Ah,'$'
  3277 000009E5 6E6965640D0A24     
  3278 000009EC 0D0A4D656D6F727920-     BMEMMES:	db 0Dh,0Ah,'Memory allocation error $'
  3278 000009F5 616C6C6F636174696F-
  3278 000009FE 6E206572726F722024 
  3279 00000A07 0D0A43616E6E6F7420-     HALTMES:	db 0Dh,0Ah,'Cannot load COMMAND, system halted$'
  3279 00000A10 6C6F616420434F4D4D-
  3279 00000A19 414E442C2073797374-
  3279 00000A22 656D2068616C746564-
  3279 00000A2B 24                 
  3280 00000A2C 0D0A43616E6E6F7420-     FRETMES:	db 0Dh,0Ah,'Cannot start COMMAND, exiting',0Dh,0Ah,'$'
  3280 00000A35 737461727420434F4D-
  3280 00000A3E 4D414E442C20657869-
  3280 00000A47 74696E670D0A24     
  3281 00000A4E 0D0A546F70206C6576-     PATRICIDE:	db 0Dh,0Ah,'Top level process aborted, cannot continue. $'
  3281 00000A57 656C2070726F636573-
  3281 00000A60 732061626F72746564-
  3281 00000A69 2C2063616E6E6F7420-
  3281 00000A72 636F6E74696E75652E-
  3281 00000A7B 2024               
  3282 00000A7D 59                      YES_CHAR:	db 'Y'
  3283 00000A7E 4E                      NO_CHAR:	db 'N'
  3284 00000A7F 52                      RETRY_CHAR:	db 'R'
  3285 00000A80 41                      ABORT_CHAR:	db 'A'
  3286 00000A81 49                      IGNORE_CHAR:	db 'I'
  3287 00000A82 46                      FAIL_CHAR:	db 'F'
  3288 00000A83 00000000                NEEDVOL:	dd 0
  3289 00000A87 00                      ERRTYPE:	db 0
  3290                                  
  3291                                  ; 22/09/2018 -  22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3292                                  
  3293                                  RETRABASE: ; 30/04/2018 (Base addr for common params, for transient portion)
  3294                                  	   ; Note: Order of following parameters must not be changed
  3295                                  	   ; without changing address references of them in 'transcom.s').	
  3296                                  
  3297 00000A88 00000000                INT_2E_RET:	DD 0		; Magic command executer return address
  3298 00000A8C 0000                    SAVE_PDB:	DW 0
  3299 00000A8E 0000                    PARENT:		DW 0
  3300 00000A90 00000000                OLDTERM:	dd 0
  3301 00000A94 0000                    ERRCD_24:	DW 0
  3302 00000A96 0000                    HANDLE01:	DW 0
  3303 00000A98 00                      LOADING:	DB 0
  3304 00000A99 0000                    BATCH:		DW 0		; Assume no batch mode initially
  3305                                  
  3306                                  ;		Bugbug:	ComSpec should be 64+3+12+1?
  3307                                  ;		What's this comspec_end about?
  3308 00000A9B 00<rep 40h>             COMSPEC: times 64 DB 0
  3309 00000ADB 0000                    PUTBACKSUBSTPTR: dw 0
  3310 00000ADD 0000                    COMSPEC_END:	dw 0
  3311 00000ADF 2C01                    TRANS:		DW COMMAND
  3312 00000AE1 0000                    TRNSEG:		DW 0
  3313 00000AE3 00                      TRNMVFLG:	db 0		; set if transient portion has been moved
  3314 00000AE4 00                      IN_BATCH:	db 0		; set if we are in batch processing mode
  3315 00000AE5 00                      BATCH_ABORT:	db 0		; set if user wants to abort from batch mode
  3316                                  
  3317 00000AE6 00                      COMDRV:		DB 0		; DRIVE SPEC TO LOAD AUTOEXEC AND COMMAND
  3318 00000AE7 0000                    MEMSIZ:		DW 0
  3319 00000AE9 0000                    SUM:		DW 0
  3320 00000AEB 01                      EXTCOM:		DB 1		; For init, pretend just did an external
  3321 00000AEC 0000                    RETCODE:	DW 0
  3322 00000AEE 00                      CRIT_ERR_INFO:	db 0		; hold critical error flags for r,i,f
  3323                                  
  3324                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  3325                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  3326                                  
  3327 00000AEF 01                      ECHOFLAG:	DB 1		; low bit true => echo commands
  3328 00000AF0 01                      SUPPRESS:	db 1		; used for echo, 1=echo line
  3329 00000AF1 0000                    IO_SAVE:	DW 0
  3330 00000AF3 00                      RESTDIR:	DB 0
  3331 00000AF4 00                      PERMCOM:	DB 0		; true => permanent command
  3332 00000AF5 0000                    SINGLECOM:	DW 0		; true => single command version
  3333 00000AF7 FFFF                    VERVAL:	        DW -1
  3334 00000AF9 00                      FFAIL:		db 0		; true => fail all int 24s
  3335 00000AFA 00                      IFFLAG:		db 0            ; true => IF statement in progress
  3336 00000AFB 00                      FORFLAG:	DB 0		; true => FOR statement in progress
  3337 00000AFC 0000                    FORPTR:		dw 0		
  3338 00000AFE 0000                    NEST:		dw 0		; nested batch file counter
  3339 00000B00 00                      CALL_FLAG:	db 0		; no CALL (batch command) in progress
  3340 00000B01 00                      CALL_BATCH_FLAG: db 0
  3341 00000B02 0000                    NEXT_BATCH:	dw 0		; address of next batch segment
  3342 00000B04 00                      NULLFLAG:	db 0		; flag if no command on command line
  3343                                  
  3344 00000B05 00                      UCASE_ADDR:	db 0
  3345 00000B06 00000000                UPPERCASETBL:	dd 0
  3346                                  
  3347 00000B0A 00                      RE_OUT_APP:	db 0
  3348 00000B0B 00<rep 50h>             RE_OUTSTR: times (64+3+13) db 0
  3349                                  
  3350 00000B5B 01                      INITFLAG:	DB INITINIT ; 1 ; 24/09/2018
  3351                                  
  3352                                  ; Note:  these two bytes are referenced as a word
  3353 00000B5C 00                      PIPEFLAG:	DB 0
  3354 00000B5D 00                      PIPEFILES:	DB 0
  3355                                  
  3356                                  ;--- 2.x data for piping
  3357                                  ;
  3358                                  ; All the "_" are substituted later, the one before the : is substituted
  3359                                  ; by the current drive, and the others by the CreateTemp call with the
  3360                                  ; unique file name. Note that the first 0 is the first char of the pipe
  3361                                  ; name. -MU
  3362                                  ;
  3363                                  ;--- Order-dependent, do not change
  3364                                  
  3365                                  ; MSDOS 3.3
  3366                                  
  3367 00000B5E 5F3A2F                  PIPE1:		db "_:/"
  3368 00000B61 00                      PIPE1T:		db 0
  3369 00000B62 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3369 00000B6B 5F5F00             
  3370 00000B6E 5F3A2F                  PIPE2:		db "_:/"
  3371 00000B71 00                      PIPE2T		db 0
  3372 00000B72 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3372 00000B7B 5F5F00             
  3373                                  
  3374                                  ; MSDOS 3.3 & MSDOS 6.0
  3375 00000B7E 0000                    PIPEPTR:	dw 0
  3376 00000B80 00<rep 81h>             PIPESTR: times 129 db 0
  3377                                  
  3378                                  ; MSDOS 6.0
  3379                                  
  3380                                  ;SR
  3381                                  ; Pipe1 & Pipe2 now need to store full-fledged pathnames
  3382                                  ;
  3383                                  
  3384                                  ; Bugbug:  can we find any way around maintaining these
  3385                                  ; large buffers?
  3386                                  
  3387                                  ;Pipe1		db	67+12 dup (?)
  3388                                  ;Pipe2		db	67+12 dup (?)
  3389                                  ;PipePtr 	dw	?
  3390                                  ;PipeStr 	db	129 dup (?)
  3391                                  
  3392                                  ;EndPipe	label	byte	; marks end of buffers; M004
  3393                                  
  3394 00000C01 [5E0B]                  INPIPEPTR:	dw PIPE1
  3395 00000C03 [6E0B]                  OUTPIPEPTR:	dw PIPE2
  3396                                  
  3397                                  ;EXEC_BLOCK LABEL BYTE		; The data block for EXEC calls
  3398                                  EXEC_BLOCK:
  3399 00000C05 0000                    ENVIRSEG:	DW 0
  3400                                  ;COM_PTR LABEL	DWORD
  3401 00000C07 8000                    COM_PTR:	DW 80H		; Point at unformatted parameters
  3402 00000C09 0000                    		DW 0
  3403                                  ;COM_FCB1 LABEL	DWORD
  3404 00000C0B 5C00                    COM_FCB1:      	DW 5CH
  3405 00000C0D 0000                            	DW 0
  3406                                  ;COM_FCB2 LABEL	DWORD
  3407 00000C0F 6C00                    COM_FCB2:	DW 6CH
  3408 00000C11 0000                            	DW 0
  3409                                  
  3410                                  ;TRANVARS LABEL  BYTE		; Variables passed to transient
  3411                                  TRANVARS:
  3412                                  		;DW OFFSET RESGROUP:THEADFIX
  3413 00000C13 [AF02]                  		DW THEADFIX
  3414 00000C15 0000                    MYSEG:		DW 0		; Put our own segment here
  3415 00000C17 0000                    LTPA:		DW 0		; WILL STORE TPA SEGMENT HERE
  3416 00000C19 2D                      RSWITCHAR:	DB "-"
  3417 00000C1A 2F                      RDIRCHAR:	DB "/"
  3418                                          	;DW OFFSET RESGROUP:EXT_EXEC
  3419 00000C1B [2D00]                  		DW EXT_EXEC
  3420 00000C1D 0000                    MYSEG1:		DW 0
  3421                                  		;DW OFFSET RESGROUP:TREMCHECK
  3422 00000C1F [9402]                  		DW TREMCHECK
  3423 00000C21 0000                    MYSEG2:		DW 0
  3424                                  
  3425 00000C23 0000                    RESTEST:	dw 0
  3426 00000C25 0000                    RES_TPA:	DW 0		; original tpa (not rounded to 64k)
  3427                                  ;TRANVAREND	label	byte
  3428                                  TRANVAREND:
  3429 00000C27 0000                    OLDERRNO:	dw 0
  3430                                  
  3431                                  		; Here is Offset 0D27h in original MSDOS 3.3 COMMAND.COM
  3432                                  
  3433                                  ;DATARESEND	LABEL   BYTE
  3434                                  DATARESEND:
  3435                                  		; 22/09/2018
  3436                                  
  3437                                  ;DATARES ENDS
  3438                                  ;        END
  3439                                  
  3440                                  ;=============================================================================
  3441                                  ; COMMAND.ASM (MSDOS 2.11), ENVDATA.ASM (MSDOS 6.0)
  3442                                  ;=============================================================================
  3443                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3444                                  
  3445 00000C29 90<rep 7h>              align 16
  3446                                  
  3447                                  	; Here is Offset 0D80h in original MSDOS 3.3 COMMAND.COM
  3448                                  
  3449                                  ;ENVIRONMENT SEGMENT PUBLIC PARA        ; Default COMMAND environment
  3450                                  
  3451                                  ;	PUBLIC  ECOMSPEC,ENVIREND,PATHSTRING
  3452                                  
  3453                                          ;ORG	0
  3454                                  ;ENVARENA	DB 10H DUP (?)	; Pad for mem arena
  3455 00000C30 00<rep 10h>             ENVARENA:	TIMES 16 DB 0		
  3456                                  ENVIRONMENT:			; 30/04/2018 ('command2.s')
  3457                                  	; Here is Offset 0D90h in original MSDOS 3.3 COMMAND.COM
  3458 00000C40 504154483D              PATHSTRING:	DB "PATH="
  3459                                  ;USERPATH LABEL  BYTE
  3460 00000C45 00                      USERPATH:      	DB 0		; Null path
  3461 00000C46 434F4D535045433D                	DB "COMSPEC="
  3462 00000C4E 2F434F4D4D414E442E-     ECOMSPEC:	DB "/COMMAND.COM"
  3462 00000C57 434F4D             
  3463                                          	;DB 134 DUP (0)
  3464 00000C5A 00<rep 86h>             		TIMES	134 DB 0
  3465                                  
  3466                                  ;ENVIREND	LABEL   BYTE
  3467                                  ENVIREND:
  3468                                  	; Here is Offset 0E30h in original MSDOS 3.3 COMMAND.COM
  3469                                  	
  3470                                  ENVIRONSIZ EQU  $-PATHSTRING	; 160 = 0A0h
  3471                                  ENVIRONSIZ2 EQU $-ECOMSPEC	; 146 = 092h
  3472                                  
  3473                                  ;ENVIRONMENT ENDS
  3474                                  
  3475                                  ; ENVDATA.ASM
  3476                                  ;
  3477                                  ;/*
  3478                                  ; *                      Microsoft Confidential
  3479                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3480                                  ; *                      All Rights Reserved.
  3481                                  ; */
  3482                                  ;	SCCSID = @(#)envdata.asm	1.1 85/05/14
  3483                                  ;
  3484                                  ; This file is included by init.asm and is used as the default environment.
  3485                                  ;
  3486                                  ;
  3487                                  ;Environment Struc                       ; Default COMMAND environment
  3488                                  ;
  3489                                  ;Env_PathString  db	"path="
  3490                                  ;Env_PathSpec    db     "c:\msdos"
  3491                                  ;                db     0
  3492                                  ;Env_PrmptString db     "prompt="
  3493                                  ;Env_PrmptSpec   db     "$p$g"
  3494                                  ;                db     0
  3495                                  ;Env_ComString   db     "comspec="
  3496                                  ;Env_ComSpec     db     "\command.com"
  3497                                  ;		 db	134 dup (0)
  3498                                  ;
  3499                                  ;Environment ends
  3500                                  
  3501                                  ;MAX_COMSPEC	equ     SIZE Environment - Env_ComSpec
  3502                                  
  3503                                  MAX_COMSPEC	EQU	ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3504                                  
  3505                                  ;-----------------------------------------------------------------------------
  3506                                  ; 24/09/2018 - RetRo DOS v3.0
  3507                                  ;ENDCODE:
  3508                                  INITSTART:	; End of rezident code and data
  3509                                  		; (Offset 0E30h in original MSDOS 3.3 COMMAND.COM)
  3510                                  ;-----------------------------------------------------------------------------
  3511                                  
  3512                                  ;=============================================================================
  3513                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  3514                                  ;=============================================================================
  3515                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3516                                  
  3517                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  3518                                  
  3519                                  ;TITLE   COMMAND Initialization
  3520                                  
  3521                                  ;ENVIRONSIZ EQU  0A0H		;Must agree with values in ENVIRONMENT segment
  3522                                  ;ENVIRONSIZ2 EQU 092H
  3523                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3524                                  
  3525                                  ; UINIT.ASM, MSDOS 6.0, 1991
  3526                                  ; 23/09/2018
  3527                                  ENVBIG	EQU	32768			;AN000; maximum environment size
  3528                                  ENVSML	EQU	160			;AN000; minimum environment size
  3529                                  
  3530                                  ;-----------------------------------------------------------------------------
  3531                                  ; START OF INIT PORTION
  3532                                  ; This code is deallocated after initialization.
  3533                                  ;-----------------------------------------------------------------------------
  3534                                  
  3535                                  ;INIT    SEGMENT PUBLIC PARA
  3536                                  
  3537                                  ; 	EXTRN   HEADER:BYTE
  3538                                  ;	EXTRN   BADCOMLKMES:BYTE
  3539                                  
  3540                                  ;	PUBLIC  CONPROC
  3541                                  
  3542                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  3543                                  
  3544                                          ;ORG 0
  3545                                  ;ZERO = $
  3546                                  	; 23/09/2018
  3547                                  ZERO equ $	 ; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  3548                                  
  3549                                  CONPROC:
  3550                                  	;MOV	SP,OFFSET RESGROUP:RSTACK	; must be first instruction
  3551 00000CE0 BC[3E07]                	MOV	SP,RSTACK
  3552                                  ;
  3553                                  ; We need to set the PSP to us right at start because Carousel needs
  3554                                  ; to be lied to and it does not set PSP when it transfers control to
  3555                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  3556                                  ; command.com is also not lied to.
  3557                                  ;
  3558                                  	; MSDOS 6.0
  3559                                          ;mov     ah,SET_CURRENT_PDB
  3560                                          ;mov     bx,es
  3561                                          ;int     21h
  3562                                  
  3563 00000CE3 B80030                          mov     ax,GET_VERSION<<8 ; 30h
  3564 00000CE6 CD21                    	int	21h
  3565 00000CE8 3D031E                  	cmp	ax,EXPECTED_VERSION ; 1E03h
  3566 00000CEB 7412                    	je	short OKDOS			; DOS version is ok
  3567                                  
  3568 00000CED BA[7214]                	mov	dx,BADVERMSG			; DX = ptr to msg
  3569                                  	;call	RPrint
  3570                                  
  3571                                  	; MSDOS 3.3
  3572 00000CF0 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  3573 00000CF2 CD21                    	int	21h             ; DOS - PRINT STRING
  3574                                  				; DS:DX -> string terminated by "$"
  3575 00000CF4 8CC0                    	mov	ax,es
  3576 00000CF6 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  3577                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  3578 00000CFB 74FE                    HERE:	jz	short HERE			;  loop forever
  3579                                  	
  3580 00000CFD CD20                    	int	20h				; otherwise, exit
  3581                                  OKDOS:
  3582                                  	; 23/09/2018
  3583                                  ;
  3584                                  ;  Calculate and save the end of the INIT segment (which is also
  3585                                  ;  the beginning of TRANGROUP).
  3586                                  ;
  3587                                  	; MSDOS 3.3
  3588 00000CFF B465                    	mov	ah,65h
  3589 00000D01 B002                    	mov	al,2
  3590 00000D03 BAFFFF                  	mov	dx,-1
  3591 00000D06 BBFFFF                  	mov	bx,-1
  3592 00000D09 B90500                  	mov	cx,5
  3593 00000D0C BF[050B]                	mov	di,UCASE_ADDR
  3594 00000D0F CD21                    	int     21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  3595                                  			; AL = 02h : Get pointer to character translation table
  3596                                  			; BX = code page (-1 = current global code page)
  3597                                  			; DX = country ID (-1 = current country)
  3598                                  			; CX = amount of data to return
  3599                                  	; ES:DI = pointer to output buffer
  3600                                  	; Buffer offset :
  3601                                  	;	00h -  byte,  country Id
  3602                                  	;  	01h -  dword, pointer to uppercase table	
  3603                                  
  3604                                  	; MSDOS 6.0 (& MSDOS 3.3)
  3605 00000D11 BA[5F15]                  	mov	dx,TRANSTART+15			; get end of init code
  3606                                  	; 27/09/2018
  3607                                          ;mov	dx,TRANSTART ; (paragraph aligned address)
  3608 00000D14 B104                    	mov	cl,4				; change to paragraphs
  3609 00000D16 D3EA                            shr	dx,cl				;
  3610 00000D18 8CC8                            mov     ax,cs                           ; get current segment
  3611 00000D1A 01D0                            add     ax,dx                           ; calculate segment of end of init
  3612 00000D1C A3[0815]                        mov     [INITEND],ax			; save this
  3613                                  
  3614 00000D1F A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h ; Init PARENT so we can exit
  3615 00000D22 A3[8E0A]                	mov	[PARENT],ax			    ;  correctly.
  3616 00000D25 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  3617 00000D28 A3[900A]                	mov	[OLDTERM],ax
  3618 00000D2B A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  3619 00000D2E A3[920A]                	mov	[OLDTERM+2],ax
  3620                                  
  3621                                  	;mov	ax,ENDCODE+15
  3622 00000D31 B8[EF0C]                	mov	ax,INITSTART+15 ; 24/09/2018
  3623 00000D34 B104                    	mov	cl,4				; ax = size of resident part of
  3624 00000D36 D3E8                    	shr	ax,cl				;  command in paragraphs. Add
  3625 00000D38 8CC9                    	mov	cx,cs				;  this to CS and you get the
  3626 00000D3A 01C8                    	add	ax,cx				;  segment of the TPA.
  3627                                  	
  3628 00000D3C A3[250C]                	mov     [RES_TPA],ax			; Temporarily save the TPA segment
  3629 00000D3F 2500F0                  	and     ax,0F000h
  3630 00000D42 050010                  	add     ax,1000h			; Round up to next 64K boundary
  3631 00000D45 7303                    	jnc     short TPA_SET			; Memory wrap if carry set
  3632 00000D47 A1[250C]                	mov     ax,[RES_TPA]
  3633                                  TPA_SET:
  3634 00000D4A A3[170C]                	mov	[LTPA],ax			; Good enough for the moment
  3635 00000D4D A10200                  	mov	ax,[PDB.BLOCK_LEN] ; mov ax,ds:2 ; ax = # of paras given to command
  3636                                  
  3637 00000D50 8C1E[1D0C]              	mov	[MYSEG1],ds			; These 3 variables are used as part of
  3638 00000D54 8C1E[210C]              	mov	[MYSEG2],ds			;  3 long ptrs that the transient will
  3639 00000D58 8C1E[150C]              	mov	[MYSEG],ds			;  use to call resident routines.
  3640                                  
  3641 00000D5C A3[E70A]                        MOV     [MEMSIZ],ax			; Needed for execing other programs
  3642                                  ;
  3643                                  ; Compute maximum size of environment
  3644                                  ;
  3645                                  	;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  3646 00000D5F C706[0215]4500                  mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  3647                                  ;
  3648                                  ; Compute minimum size of environment
  3649                                  ;
  3650                                  	;mov	word [ENVSIZ],10 ; = 160/16
  3651 00000D65 C706[0015]0A00          	mov	word [ENVSIZ],ENVSML/16; 
  3652                                  
  3653                                  	;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  3654 00000D6B BA4B4D                  	mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  3655 00000D6E B104                    	mov	cl,4				;  in paragraphs.
  3656 00000D70 D3EA                    	shr	dx,cl
  3657 00000D72 8916[0A15]                      mov     [TRNSIZE],dx			; save size of transient in paragraphs
  3658                                  
  3659 00000D76 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  3660 00000D78 A3[E10A]                	mov	[TRNSEG],ax			;  = seg addr to load the transient at.
  3661 00000D7B A12C00                  	mov	ax,[PDB.ENVIRON] ; mov ax,ds:2Ch ; ax = environment segment
  3662                                  
  3663                                          ; MSDOS 6.0
  3664                                  	;mov	EnvirSeg,ax			;
  3665                                          ;or	ax,ax				; if there is no environment segment,
  3666                                          ;jz	buildenv			; make one
  3667                                  	;
  3668                                          ;cmp	FirstCom,0			; if this is the first command.com,
  3669                                  	;je	environpassed			; do a merge job (make sure COMSPEC exists)
  3670                                  
  3671                                  	; MSDOS 3.3
  3672 00000D7E 09C0                    	or	ax,ax
  3673 00000D80 7406                    	jz	short BUILDENV
  3674 00000D82 FE06[EB14]                      inc	byte [CHUCKENV]			; Flag no ENVIRONSEG
  3675 00000D86 EB0B                            jmp	short ENVIRONPASSED
  3676                                  
  3677                                  	; MSDOS 6.0
  3678                                  ;
  3679                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  3680                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  3681                                  ; size and free this buffer. We need this buffer because we no longer have an
  3682                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  3683                                  ; given on the command line before we know the environment size. This routine
  3684                                  ; will not return in case of an allocation error. It will either exit or hang
  3685                                  ; depending on whether or not this is the first COMMAND.COM or not.
  3686                                  ;
  3687                                  ;buildenv:
  3688                                  ;	call	alloc_env                       ; try to allocate buffer
  3689                                  ;environpassed:
  3690                                  ;	mov	es,ax                           ; and it load into es.
  3691                                  ;	assume	es:nothing
  3692                                  ;
  3693                                  ;gottheenvir:
  3694                                  ;;
  3695                                  ;; Initialize the command drive
  3696                                  ;;
  3697                                  	; MSDOS 3.3
  3698                                  BUILDENV:
  3699                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  3700 00000D88 B8[400C]                	mov	ax,PATHSTRING ; "PATH="
  3701 00000D8B B104                    	mov	cl,4
  3702 00000D8D D3E8                    	shr	ax,cl
  3703 00000D8F 8CDA                    	mov	dx,ds
  3704 00000D91 01D0                    	add	ax,dx
  3705                                  
  3706                                  ENVIRONPASSED:
  3707 00000D93 A3[050C]                        mov	[ENVIRSEG],ax
  3708                                  
  3709 00000D96 8EC0                            MOV     es,ax
  3710                                  
  3711                                          ;mov	ax,CHAR_OPER<<8
  3712 00000D98 B80037                          mov	ax,CHAR_OPER*256 ; 3700h
  3713 00000D9B CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3714                                  			; Return: AL = FFh unsupported subfunction
  3715                                  			; DL = current switch character
  3716 00000D9D 8816[190C]                      mov	[RSWITCHAR],dl
  3717                                  
  3718                                          ;CMP	dl,'/'
  3719 00000DA1 3A16[F914]              	cmp	dl,[slash_chr]
  3720 00000DA5 7511                            jnz	short IUSESLASH
  3721                                  
  3722                                  	;mov	al,'\'
  3723 00000DA7 A0[FA14]                 	mov	al,[bslash_chr]
  3724 00000DAA A2[C014]                	mov	[COMSPECT],al
  3725                                  
  3726 00000DAD 803E[EB14]00            	cmp	byte [CHUCKENV],0
  3727 00000DB2 7504                    	jnz	short IUSESLASH
  3728                                  
  3729                                          ;mov	ES:[ECOMSPEC-10h],'\'
  3730                                  	; 30/04/2018
  3731                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  3732                                  	; 23/09/2018
  3733 00000DB4 26A20E00                	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  3734                                  
  3735                                  ;gottheenvir:
  3736                                  IUSESLASH:
  3737                                  ;
  3738                                  ; Initialize the command drive
  3739                                  ;
  3740                                  	; MSDOS 3.3 & MSDOS 6.0
  3741 00000DB8 B419                    	mov	ah,GET_DEFAULT_DRIVE	; 19h
  3742 00000DBA CD21                    	int	21h
  3743 00000DBC FEC0                    	inc	al
  3744 00000DBE A2[E60A]                	mov	[COMDRV],al
  3745                                  
  3746                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  3747 00000DC1 A05C00                          mov	al,[FCB]
  3748 00000DC4 08C0                    	or	al,al
  3749 00000DC6 7426                    	jz	short NOCOMDRV		; no drive specified
  3750                                  
  3751 00000DC8 B43A                    	mov	ah,':'
  3752 00000DCA A2[E60A]                	mov	[COMDRV],al
  3753 00000DCD 0440                    	add	al,40h			; convert number to uppercase character
  3754                                  
  3755 00000DCF FD                      	std
  3756                                  
  3757                                  	; MSDOS 6.0
  3758                                          ;cmp	AllocedEnv,0		; if a new environment is being built,
  3759                                  	;je	notwidenv		;  move the default comspec string in it
  3760                                  	;mov	di,ComspOffset
  3761                                          ;cmp	byte ptr es:[di+1],':'	; drive specifier already exist?
  3762                                          ;je	notwidenv               ; yes, must have been inherited that way
  3763                                  
  3764                                  	; MSDOS 3.3
  3765 00000DD0 803E[EB14]00                    cmp	byte [CHUCKENV],0
  3766 00000DD5 7513                    	jne	short NOTWIDENV
  3767                                  
  3768 00000DD7 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  3769 00000DD8 06                      	push	es			;  the drivespec is in ax and is copied
  3770 00000DD9 1F                      	pop	ds			;  on to the front of the string.
  3771                                  
  3772                                  	; MSDOS 6.0
  3773                                          ;lea	si,[di+MAX_COMSPEC-3]	
  3774                                          ;lea	di,[di+MAX_COMSPEC-1]
  3775                                  
  3776                                  	; MSDOS 3.3
  3777                                  	; 23/09/2018
  3778                                  	; 30/04/2018
  3779                                  	;mov	di,159
  3780                                  	;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  3781 00000DDA BF9F00                          mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  3782                                  	;mov	si,157
  3783                                  	;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  3784 00000DDD BE9D00                          mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  3785                                  	;mov	cx,144
  3786                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  3787 00000DE0 B99000                          mov     cx,MAX_COMSPEC-2
  3788                                  
  3789 00000DE3 F3A4                    	rep	movsb
  3790 00000DE5 1F                      	pop	ds
  3791                                  
  3792                                  	; MSDOS 6.0
  3793                                  	;mov     word ptr es:[di-1],ax
  3794                                  
  3795                                  	; MSDOS 3.3
  3796                                  	;mov	es:0Eh,ax
  3797                                  	;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  3798 00000DE6 26A30E00                	MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  3799                                  
  3800                                  	; MSDOS 3.3 & MSDOS 6.0
  3801                                  NOTWIDENV:
  3802 00000DEA FC                      	cld
  3803                                  
  3804 00000DEB A3[CE14]                	mov    [AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  3805                                  
  3806                                  NOCOMDRV:
  3807 00000DEE E8EFF5                          CALL    SETVECT         ; Set the vectors
  3808                                  
  3809                                  	; MSDOS 3.3
  3810 00000DF1 BE8000                  	mov	si,80h		; get command line
  3811 00000DF4 AC                      	lodsb			; get length of line
  3812 00000DF5 88C1                    	mov	cl,al
  3813 00000DF7 30ED                    	xor	ch,ch		; cx = length of command line
  3814                                  ;
  3815                                  ; insure that the command line correctly ends with a cr
  3816                                  ;
  3817 00000DF9 01CE                    	add	si,cx		; go to end of command line	
  3818 00000DFB C6040D                  	mov	byte [si], 0Dh	; insert a carriage return
  3819                                  
  3820 00000DFE BE8100                  	mov	si,81h		; Start of parms
  3821                                  CHKARG:
  3822 00000E01 E369                            jcxz	COMRETURNSJ     ; No parameters
  3823 00000E03 49                              dec	cx
  3824 00000E04 AC                      	lodsb
  3825                                  CHECKSWITCHCHR:
  3826                                  	;cmp	al,' '
  3827 00000E05 3A06[FB14]              	cmp	al,[space_chr]	 ;Skip blank spaces
  3828 00000E09 74F6                    	jz	short CHKARG
  3829 00000E0B 3C09                    	cmp	al,9		; Skip TAB characters
  3830 00000E0D 74F2                    	jz	short CHKARG
  3831 00000E0F 3A06[190C]              	cmp	al,[RSWITCHAR]	; Switch?
  3832 00000E13 7403                    	jz	short PARSE_CONT ; Yes, get the char after the switch
  3833 00000E15 E9D800                  	jmp	CHKOTHERARGS	; No
  3834                                  
  3835                                  PARSE_CONT:
  3836                                  ;
  3837                                  ; See if a switch was entered
  3838                                  ;
  3839 00000E18 E352                    	jcxz	COMRETURNSJ
  3840 00000E1A 49                      	dec	cx
  3841 00000E1B AC                      	lodsb
  3842 00000E1C 0C20                    	or	al,20h		; Lower case
  3843 00000E1E 3C66                    	cmp	al,'f'		; FAIL switch
  3844 00000E20 7507                    	jnz     short CHECKPSWITCH
  3845                                  	
  3846                                  	; MSDOS 6.0
  3847                                  ;SetFSwitch:
  3848                                  	;cmp	fFail,-1		; has fail switch been set?
  3849                                  	;jnz	failok			; no - set it
  3850                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3851                                          ;jmp	parse_line_error        ; go issue error 
  3852                                  
  3853                                  	; MSDOS 3.3 & MSDOS 6.0
  3854                                  FAIL_OK:
  3855 00000E22 C606[F90A]FF            	mov	byte [FFAIL],-1	; fail all INT 24s.
  3856                                  	; MSDOS 3.3
  3857 00000E27 EBD8                    	jmp	short CHKARG
  3858                                  
  3859                                  CHECKPSWITCH:
  3860                                          ;CMP	AL,'p'		; Permanent COMMAND switch
  3861 00000E29 3A06[FC14]              	cmp	al,[letter_p]
  3862 00000E2D 751C                            JNZ     short CHECKDSWITCH
  3863                                  
  3864                                  SETPSWITCH:
  3865                                  ;
  3866                                  ; We have a permanent COMMAND switch /P.  Flag this and stash the
  3867                                  ; termination address.
  3868                                  ;
  3869                                  	; MSDOS 6.0
  3870                                  	;cmp	PermCom,0		; has /p switch been set?
  3871                                  	;jz	permcomok		; no - set it
  3872                                          ;mov	ax,moreargs_ptr		; set up too many arguments
  3873                                          ;jmp	parse_line_error 		; go issue error 
  3874                                  ;permcomok:
  3875                                  	; MSDOS 3.3 & MSDOS 6.0
  3876 00000E2F FE06[F40A]              	inc	byte [PERMCOM]
  3877 00000E33 C706[900A][AD01]        	mov     word [OLDTERM],LODCOM
  3878 00000E39 8C1E[920A]              	mov     [OLDTERM+2],ds
  3879                                  ;
  3880                                  ; make sure that we display the date and time. if the flag was not
  3881                                  ; initialized, set it to indicate yes, do prompt.
  3882                                  ;
  3883                                  	; MSDOS 3.3
  3884 00000E3D 803E[DE14]FF            	cmp     byte [PRDATTM],-1
  3885 00000E42 75BD                    	jnz     short CHKARG
  3886 00000E44 C606[DE14]00            	mov     byte [PRDATTM],0
  3887 00000E49 EBB6                    	jmp     short CHKARG
  3888                                  
  3889                                  ;COMRETURNSJ:
  3890                                  ;	; MSDOS 3.3
  3891                                  ;	JMP	ARGSDONE
  3892                                  
  3893                                  CHECKDSWITCH:
  3894                                  	;cmp	al,'d'
  3895 00000E4B 3A06[FD14]                      cmp	al,[letter_d]
  3896 00000E4F 7507                    	jnz     short CHECKCSWITCH
  3897                                  SETDSWITCH:
  3898                                  ;
  3899                                  ; Flag no date/time prompting.
  3900                                  ;
  3901                                  	; MSDOS 6.0
  3902                                  	;cmp	Dswitch,0		; has /D switch been set?
  3903                                  	;jz	setdateok		; no - set it
  3904                                          ;mov	ax,Moreargs_ptr	; set up too many arguments
  3905                                          ;jmp	parse_line_error	; go issue error message
  3906                                  ;setdateok:
  3907                                  	;inc	Dswitch 		; indicate /D entered
  3908                                  
  3909                                  	; MSDOS 3.3 & MSDOS 6.0
  3910 00000E51 C606[DE14]01                    mov	byte [PRDATTM],1  ; User explicitly says no date time
  3911                                  	; MSDOS 3.3
  3912 00000E56 EBA9                    	jmp	short CHKARG
  3913                                  
  3914                                  CHECKCSWITCH:
  3915                                          ;cmp	al,'c'
  3916 00000E58 3A06[FE14]              	cmp     al,[letter_c]
  3917 00000E5C 7511                            jnz	short CHECKESWITCH
  3918                                  
  3919                                  ;SetSSwitch:
  3920                                  SETCSWITCH:
  3921                                  ;
  3922                                  ; Set up pointer to command line, flag no date/time and turn off singlecom.
  3923                                  ;
  3924 00000E5E C606[F40A]00            	mov	byte [PERMCOM],0	; A SINGLECOM must not be a PERMCOM
  3925 00000E63 8936[F50A]              	mov	[SINGLECOM],si		; Point to the rest of the command line
  3926                                  	;mov	byte [PERMCOM],0
  3927 00000E67 C606[DE14]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  3928                                  COMRETURNSJ: ; 24/09/2018
  3929 00000E6C E96C01                  	jmp	ARGSDONE
  3930                                  
  3931                                  CHECKESWITCH:
  3932 00000E6F 3C65                    	cmp     al,'e'
  3933 00000E71 758E                    	jnz     short CHKARG
  3934                                  ;
  3935                                  ; Look for environment-size setting switch
  3936                                  ;
  3937                                  ; The environment size is represented in decimal bytes and is
  3938                                  ; converted into paragraphs (rounded up to the next paragraph).
  3939                                  ;
  3940                                  SETESWITCH:
  3941                                  	; MSDOS 6.0
  3942                                  	;cmp	Eswitch,0		; has environment size switch been set?
  3943                                  	;jz	eswitchok		; no - set it
  3944                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3945                                          ;jmp	Parse_line_error	; go issue error message
  3946                                  ;eswitchok:
  3947                                  	;inc	Eswitch			; indicate /E entered 	
  3948                                  
  3949                                  	; 23/09/2018 - Retro DOS v3.0
  3950                                  
  3951                                  	; MSDOS 3.3
  3952                                  	; (COMMAND.COM offset 0FC5h)
  3953                                  ESWITCHOK:
  3954 00000E73 E38C                    	jcxz    CHKARG
  3955 00000E75 49                      	dec     cx
  3956 00000E76 AC                      	lodsb
  3957 00000E77 3C3A                    	cmp     al,':'
  3958 00000E79 758A                    	jnz     short CHECKSWITCHCHR
  3959 00000E7B 31DB                    	xor     bx,bx
  3960 00000E7D 89D8                    	mov     ax,bx
  3961                                  GETENVSIZE:
  3962 00000E7F E33C                    	jcxz    SETENVSIZE
  3963 00000E81 49                      	dec     cx
  3964 00000E82 AC                      	lodsb
  3965 00000E83 3C30                    	cmp     al,'0'
  3966 00000E85 7214                    	jb      short NOTDECIMALCHR
  3967 00000E87 3C39                    	cmp     al,'9'
  3968 00000E89 7710                    	ja      short NOTDECIMALCHR
  3969 00000E8B 2C30                    	sub     al,'0'
  3970 00000E8D 89DA                    	mov     dx,bx
  3971 00000E8F D1E2                    	shl     dx,1
  3972 00000E91 D1E2                    	shl     dx,1   ; dx = 4*bx	
  3973 00000E93 01D3                    	add     bx,dx  ; bx = 5*bx
  3974 00000E95 D1E3                    	shl     bx,1   ; bx = 10*bx	
  3975 00000E97 01C3                    	add     bx,ax
  3976 00000E99 EBE4                    	jmp     short GETENVSIZE
  3977                                  
  3978                                  NOTDECIMALCHR:
  3979                                  	;cmp	al,' '
  3980 00000E9B 3A06[FB14]              	cmp     al,[space_chr]
  3981 00000E9F 741A                    	jz      short CHECKENVSIZE
  3982                                  	;cmp	al,'/'
  3983 00000EA1 3A06[190C]              	cmp     al,[RSWITCHAR]
  3984 00000EA5 7414                    	jz      short CHECKENVSIZE
  3985                                  
  3986                                  CHECKNEXTECHR:
  3987 00000EA7 E33D                    	jcxz    INVENVSIZE
  3988 00000EA9 49                      	dec     cx
  3989 00000EAA AC                      	lodsb
  3990                                  	;cmp	al,' '
  3991 00000EAB 3A06[FB14]              	cmp     al,[space_chr]
  3992 00000EAF 7406                    	jz      short ENVSIZESPC
  3993                                  	;cmp	al,'/'
  3994 00000EB1 3A06[190C]              	cmp     al,[RSWITCHAR]
  3995 00000EB5 75F0                    	jnz     short CHECKNEXTECHR
  3996                                  
  3997                                  ENVSIZESPC:
  3998 00000EB7 4E                      	dec     si
  3999 00000EB8 41                      	inc     cx
  4000 00000EB9 EB2B                    	jmp     short INVENVSIZE
  4001                                  	
  4002                                  	;nop
  4003                                  
  4004                                  CHECKENVSIZE: 
  4005 00000EBB 4E                      	dec     si
  4006 00000EBC 41                      	inc     cx
  4007                                  
  4008                                  SETENVSIZE:
  4009                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  4010 00000EBD C706[0015]0008          	mov	word [ENVSIZ],ENVBIG/16
  4011 00000EC3 81FB0080                	cmp     bx,32768
  4012 00000EC7 771D                    	ja      short INVENVSIZE
  4013                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  4014 00000EC9 C706[0015]0A00          	mov	word [ENVSIZ],ENVSML/16
  4015 00000ECF 81FBA000                	cmp     bx,160
  4016 00000ED3 7211                    	jb      short INVENVSIZE
  4017 00000ED5 83C30F                  	add     bx,15
  4018 00000ED8 D1EB                    	shr     bx,1
  4019 00000EDA D1EB                    	shr     bx,1
  4020 00000EDC D1EB                    	shr     bx,1
  4021 00000EDE D1EB                    	shr     bx,1
  4022 00000EE0 891E[0015]              	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  4023 00000EE4 EB07                    	jmp     short NEXTCH2
  4024                                  
  4025                                  	;nop
  4026                                  
  4027                                  INVENVSIZE:
  4028 00000EE6 BA[8A14]                	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  4029 00000EE9 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4030 00000EEB CD21                    	int     21h             ; DOS - PRINT STRING
  4031                                  				; DS:DX -> string terminated by "$"
  4032                                  NEXTCH2:
  4033                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  4034 00000EED E911FF                  	jmp     CHKARG
  4035                                  
  4036                                  	;jmp	ARGSDONE
  4037                                  
  4038                                  CHKOTHERARGS:
  4039                                  ;
  4040                                  ; We have a non-switch character here.
  4041                                  ;
  4042                                  	; MSDOS 6.0
  4043                                  ;	push	ds ; ***			;
  4044                                  ;	push	si ; **** 			; save place in command line
  4045                                  ;	lds	si,Comnd1_Addr			; get address of filespec
  4046                                  ;	assume	ds:nothing			;
  4047                                  ;
  4048                                  ;	mov	dx,si				; put in dx also
  4049                                  ;       mov     ax,(OPEN shl 8) or 2            ; Read and write
  4050                                  ;	int	21h
  4051                                  ;	jc	ChkSrchSpec			; Wasn't a file
  4052                                  ;	mov	bx,ax
  4053                                  ;	mov	ax,IOCTL shl 8
  4054                                  ;	int	21h
  4055                                  ;	test	dl,80h
  4056                                  ;	jnz	IsaDevice
  4057                                  ;
  4058                                  ;BadSetCon:					;
  4059                                  ;	mov	ah,CLOSE			; Close initial handle, wasn't a device
  4060                                  ;	int	21h
  4061                                  ;	jmp	short ChkSrchSpec
  4062                                  
  4063                                  	; MSDOS 3.3
  4064                                  	; (COMMAND.COM offset 1047h)
  4065 00000EF0 4E                              dec	si
  4066 00000EF1 41                      	inc	cx
  4067 00000EF2 89F2                    	mov	dx,si
  4068 00000EF4 51                      	push	cx ; *
  4069 00000EF5 56                      	push	si ; **
  4070                                  CONTRLOOP:
  4071 00000EF6 AC                      	lodsb
  4072 00000EF7 49                      	dec	cx
  4073                                  	;cmp	al,' '
  4074 00000EF8 3A06[FB14]              	cmp	al,[space_chr]
  4075 00000EFC 7409                    	jz	short SETCDEV
  4076 00000EFE 3C09                    	cmp	al,9
  4077 00000F00 7405                    	jz	short SETCDEV
  4078 00000F02 E302                    	jcxz	SETCDEVA
  4079 00000F04 EBF0                    	jmp	short CONTRLOOP
  4080                                  
  4081                                  SETCDEVA:
  4082 00000F06 46                              inc	si
  4083                                  SETCDEV:
  4084 00000F07 C644FF00                	mov	byte [SI-1],0
  4085                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  4086 00000F0B B8023D                          mov	ax,(OPEN*256) | 2 ; 3D02h
  4087 00000F0E CD21                            int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  4088                                  			; DS:DX -> ASCIZ filename
  4089                                  			; AL = access mode
  4090                                  			; 2 - read & write
  4091 00000F10 7247                            jc	short CHKSRCHSPEC	; Wasn't a file
  4092 00000F12 89C3                            mov	bx,ax
  4093                                          ;mov	ax,IOCTL shl 8
  4094 00000F14 B80044                          mov     ax,IOCTL*256 ; 4400h
  4095 00000F17 CD21                    	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  4096                                  			; BX = file or device handle
  4097 00000F19 F6C280                          test	dl,80H
  4098 00000F1C 7506                    	jnz	short ISADEVICE
  4099                                  BADSETCON: ; MSDOS 6.0
  4100 00000F1E B43E                    	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  4101 00000F20 CD21                            int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  4102                                  			; BX = file handle
  4103 00000F22 EB35                            JMP     short CHKSRCHSPEC
  4104                                  
  4105                                  	;nop
  4106                                  
  4107                                  ISADEVICE:
  4108                                  	; MSDOS 3.3 & MSDOS 6.0
  4109 00000F24 30F6                    	xor	dh,dh
  4110 00000F26 80CA03                  	or	dl,3				; Make sure has CON attributes
  4111                                  	;mov	ax,(IOCTL shl 8) or 1
  4112 00000F29 B80144                  	mov	ax,(IOCTL*256) | 1 ; 4401h
  4113 00000F2C CD21                    	int	21h
  4114                                  	;
  4115                                  	; 25/09/2018
  4116 00000F2E 5A                      	pop	dx ; **
  4117 00000F2F 5A                      	pop	dx ; *
  4118                                  	;
  4119 00000F30 72EC                    	jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  4120 00000F32 89DA                    	mov	dx,bx				; Save new handle
  4121                                  
  4122                                  	; MSDOS 6.0
  4123                                  	;cmp	es:DevFlag,1
  4124                                  	;jz	DevErr
  4125                                  
  4126                                  	; MSDOS 3.3
  4127                                          ;pop	bx ; **				; Throw away saved SI
  4128                                          ;pop	bx ; *				; Throw away saved CX
  4129                                  
  4130                                  	; MSDOS 3.3 & MSDOS 6.0
  4131 00000F34 51                      	push	cx
  4132 00000F35 B90300                  	mov	cx,3
  4133 00000F38 31DB                    	xor	bx,bx
  4134                                  
  4135                                  RCCLLOOP:
  4136 00000F3A B43E                    	mov	ah,CLOSE ; 3Eh
  4137 00000F3C CD21                    	int	21h
  4138 00000F3E 43                      	inc	bx
  4139 00000F3F E2F9                    	loop	RCCLLOOP
  4140                                  
  4141 00000F41 89D3                    	mov	bx,dx				; New device handle
  4142 00000F43 B445                    	mov	ah,XDUP ; 45h
  4143 00000F45 CD21                    	int	21h				; Dup to 0
  4144 00000F47 B445                    	mov	ah,XDUP
  4145 00000F49 CD21                    	int	21h				; Dup to 1
  4146 00000F4B B445                    	mov	ah,XDUP
  4147 00000F4D CD21                    	int	21h				; Dup to 2
  4148 00000F4F B43E                    	mov	ah,CLOSE
  4149 00000F51 CD21                    	int	21h				; Close initial handle
  4150                                  	
  4151 00000F53 59                      	pop	cx
  4152                                  	
  4153                                  	; MSDOS 6.0
  4154                                  	;pop	si ; ****			; restore position of command line
  4155                                  	;pop	ds ; ***			;
  4156                                  ;
  4157                                  ; Register the fact that we already have redirected the output and cannot do
  4158                                  ; it again
  4159                                  ;
  4160                                  	;inc	es:DevFlag			;
  4161                                          ;jmp	Parse_command_line		; continue parsing
  4162                                  
  4163                                  	; MSDOS 3.3
  4164 00000F54 E361                    	jcxz	ARGSDONEJ2
  4165 00000F56 E9A8FE                  	jmp	CHKARG
  4166                                  
  4167                                  	; MSDOS 6.0
  4168                                  ;DevErr:
  4169                                  	;pop	si ; ****
  4170                                  	;pop	ds ; ***
  4171                                  	;mov	dx,1
  4172                                          ;call	RPrintParse                     ; "Too many parameters"
  4173                                          ;call	CrLf
  4174                                  	;jmp	Parse_command_line
  4175                                  
  4176                                  
  4177                                  CHKSRCHSPEC:                    ; Not a device, so must be directory spec
  4178                                  
  4179                                  	; MSDOS 6.0
  4180                                          ;cmp	es:PathFlag,1			; already set COMSPEC?
  4181                                          ;jz	DevErr				; yes, error
  4182                                  	;
  4183                                          ;inc	es:PathFlag			; mark that we have a path
  4184                                  ;
  4185                                  ; We have to override the passed environment. Allocate a buffer for use now.
  4186                                  ; This buffer will later be replaced by a proper environment
  4187                                  ;
  4188                                  	;call	alloc_env                       ; environment buffer
  4189                                  	;mov	es,ax
  4190                                  	;assume	es:nothing
  4191                                  	;push	si				; remember location of file
  4192                                  	;xor	cx,cx				; clear cx for counting
  4193                                  
  4194                                  ;countloop:
  4195                                  	;lodsb					; get a character
  4196                                  	;inc	cx				; increment counter
  4197                                          ;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  4198                                  	;jnz	countloop			; no - keep counting
  4199                                  	;
  4200                                  	;mov	al,Space
  4201                                  	;dec	si				; move back one
  4202                                          ;mov	byte ptr [si],al                ; put a space at end of line
  4203                                  ;
  4204                                  ; We now know how long the new pathspec for command.com is.  Time to
  4205                                  ; figure out how long the current COMSPEC setting is, and then to move
  4206                                  ; all the environment data up, throwing that COMSPEC setting away, and
  4207                                  ; preparing to append the new COMSPEC.  ComspOffset (the offset of
  4208                                  ; where the filespec exists in the environment) is updated as well.
  4209                                  ;
  4210                                  	;push	cx                              ;
  4211                                          ;mov	cx,ENVBIG                       ;
  4212                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  4213                                          ;mov	al,0                            ;
  4214                                          ;repne	scasb                           ; find the end of COMSPEC
  4215                                          ;mov	si,di                           ;
  4216                                  ;comp_endenv:                                   ;
  4217                                          ;scasb                                  ; end of env?
  4218                                          ;je	got_endenv                      ; yes
  4219                                          ;repne	scasb                           ;
  4220                                          ;jmp	comp_endenv                     ;
  4221                                  ;got_endenv:                                    ;
  4222                                          ;mov    cx,di                           ;
  4223                                          ;sub    cx,si                           ;
  4224                                          ;mov    di,ComspOffset                  ;
  4225                                          ;sub    di,ComspStrLen                  ;
  4226                                          ;push   ds                              ;
  4227                                          ;push   es                              ;
  4228                                          ;pop    ds                              ;
  4229                                          ;rep    movsb                           ;
  4230                                          ;dec    di                              ; copy in new COMSPEC=
  4231                                          ;push   cs                              ;
  4232                                          ;pop    ds                              ;
  4233                                          ;assume ds:ResGroup                     ;
  4234                                          ;mov    si,offset RESGROUP:ComspString  ;
  4235                                          ;mov    cx,ComspStrLen                  ;
  4236                                          ;rep    movsb                           ;
  4237                                          ;mov    ComspOffset,di                  ;
  4238                                          ;pop    ds                              ;
  4239                                          ;assume ds:nothing                      ;
  4240                                          ;pop    cx                              ;
  4241                                  	;
  4242                                          ;pop    si                              ; get new comspec location back
  4243                                  
  4244                                  	; MSDOS 3.3
  4245 00000F59 C606[EB14]00            	mov     byte [CHUCKENV],0	; If search specified -- no inheritance
  4246 00000F5E B8[400C]                	mov     ax,PATHSTRING ; "PATH="	; Figure environment pointer
  4247 00000F61 B104                    	mov     cl,4
  4248 00000F63 D3E8                    	shr     ax,cl
  4249 00000F65 8CDA                    	mov     dx,ds
  4250 00000F67 01D0                    	add     ax,dx
  4251 00000F69 A3[050C]                	mov     [ENVIRSEG],ax
  4252 00000F6C 8EC0                    	mov     es,ax
  4253                                  	;mov	al,' '
  4254 00000F6E A0[FB14]                	mov     al,[space_chr]
  4255 00000F71 8844FF                  	mov     [si-1],al
  4256 00000F74 5E                      	pop     si ; **			; Remember location
  4257 00000F75 59                      	pop     cx ; *			; and count
  4258                                  	;mov	di,[ECOMLOC]
  4259 00000F76 8B3E[EC14]              	mov     di,[COMSPOFFSET]
  4260                                  
  4261                                  COMTRLOOP:
  4262                                  	; MSDOS 3.3 & MSDOS 6.0
  4263 00000F7A AC                      	lodsb
  4264 00000F7B 49                      	dec	cx
  4265                                  	;cmp	al,' '
  4266 00000F7C 3A06[FB14]              	cmp	al,[space_chr]
  4267 00000F80 7409                    	je	short SETCOMSR
  4268                                  	; MSDOS 3.3
  4269 00000F82 3C09                    	cmp	al,9
  4270 00000F84 7405                    	je	short SETCOMSR
  4271                                  	; MSDOS 3.3 & MSDOS 6.0
  4272 00000F86 AA                      	stosb
  4273 00000F87 E302                    	jcxz	SETCOMSR
  4274 00000F89 EBEF                    	jmp	short COMTRLOOP
  4275                                  
  4276                                  SETCOMSR:
  4277                                  	; MSDOS 6.0
  4278                                  	;push	cx
  4279                                  	;
  4280                                  	;push	cs				; Get local segment
  4281                                  	;pop	ds				;
  4282                                  	;assume	ds:ResGroup			;
  4283                                  	;
  4284                                  	;push	ds
  4285                                  	;mov	si,offset ResGroup:ComSpect
  4286                                  	;mov	cx,14
  4287                                  	;
  4288                                  	;mov	al,es:[di-1]
  4289                                  	;
  4290                                  	;cmp	al,RDirChar
  4291                                  	;jnz	iNotRoot
  4292                                  	;inc	si				; Don't make a double /
  4293                                  	;dec	cx
  4294                                  	
  4295                                  	; MSDOS 3.3
  4296 00000F8B 56                      	push    si
  4297 00000F8C 51                      	push    cx
  4298 00000F8D 1E                      	push    ds
  4299 00000F8E BE[C014]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4300 00000F91 B90E00                  	mov     cx,14
  4301 00000F94 268A45FF                	mov     al,[es:di-1]
  4302 00000F98 E8E602                  	call    PATHCHRCMPR
  4303 00000F9B 7502                    	jnz     short INOTROOT			
  4304 00000F9D 46                      	inc     si				; Don't make a double /
  4305 00000F9E 49                      	dec     cx
  4306                                  
  4307                                  INOTROOT:
  4308                                  	; MSDOS 3.3 & MSDOS 6.0
  4309 00000F9F F3A4                    	rep	movsb
  4310                                  
  4311                                  	;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  4312 00000FA1 8B16[EC14]                      mov     dx,[COMSPOFFSET]
  4313 00000FA5 06                      	push	es
  4314 00000FA6 1F                      	pop	ds
  4315                                  	;mov	ax,OPEN shl 8
  4316 00000FA7 B8003D                  	mov	ax,OPEN*256 ; 3D00h
  4317 00000FAA CD21                    	int	21h				; Open COMMAND.COM
  4318 00000FAC 1F                      	pop	ds
  4319 00000FAD 720D                    	jc	short SETCOMSRBAD		; No COMMAND.COM here
  4320 00000FAF 89C3                    	mov	bx,ax				; Handle
  4321 00000FB1 B43E                    	mov	ah,CLOSE ; 3Eh
  4322 00000FB3 CD21                    	int	21h				; Close COMMAND.COM
  4323                                  SETCOMSRRET:
  4324 00000FB5 59                      	pop	cx
  4325 00000FB6 5E                      	pop	si
  4326                                  
  4327                                  	; MSDOS 6.0
  4328                                  	;pop	ds				;
  4329                                  	;assume	ds:ResGroup			;
  4330                                  	;
  4331                                  	;push	cs				; Make sure local ES is
  4332                                  	;pop	es				;  restored
  4333                                  	;jmp	Parse_command_line		; continue parsing command line
  4334                                  
  4335                                  	; MSDOS 3.3
  4336                                  ARGSDONEJ2:
  4337 00000FB7 E322                    	jcxz	ARGSDONE
  4338 00000FB9 E945FE                  	jmp	CHKARG
  4339                                  
  4340                                  SETCOMSRBAD:
  4341                                  	; MSDOS 3.3 & MSDOS 6.0
  4342                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  4343 00000FBC BA[0814]                	mov	dx,BADCOMLKMES
  4344                                  
  4345                                  ;	Note:  we're about to make a near call to TriageError, which
  4346                                  ;	lives in a different segment and group.  Some linkers will
  4347                                  ;	generate a warning like "Possible fix-up overflow".  We're
  4348                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  4349                                  ;	we're still all together.
  4350                                  
  4351 00000FBF E85A23                  	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  4352                                  				; in original MSDOS 3.3 COMMAND.COM	
  4353 00000FC2 83F841                  	cmp	ax,65
  4354 00000FC5 7503                    	jne	short DOPRT
  4355                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  4356 00000FC7 BA[4114]                	mov	dx,BADCOMACCMSG
  4357                                  DOPRT:
  4358 00000FCA E8A702                  	call	RPRINT
  4359                                  	;mov	si,offset ResGroup:ComSpect
  4360 00000FCD BE[C014]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4361                                  	;mov	di,[ECOMLOC]
  4362 00000FD0 8B3E[EC14]                      mov     di,[COMSPOFFSET]
  4363 00000FD4 B90E00                  	mov	cx,14
  4364 00000FD7 F3A4                    	rep	movsb				; get my default back
  4365                                  
  4366 00000FD9 EBDA                    	jmp	short SETCOMSRRET
  4367                                  
  4368                                  ARGSDONE:
  4369                                  	; MSDOS 6.0
  4370                                  	;mov	es,EnvirSeg			; get environment back
  4371                                  	;assume	es:nothing			;
  4372                                  
  4373                                  	; MSDOS 3.3 & MSDOS 6.0
  4374 00000FDB 803E[F40A]00                    cmp	byte [PERMCOM],0
  4375 00000FE0 742E                            jz	short COMRETURNS
  4376                                  
  4377 00000FE2 06                      	push	es				; Save environment pointer
  4378 00000FE3 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  4379 00000FE5 8CDB                    	mov	bx,ds
  4380 00000FE7 8EC3                    	mov	es,bx
  4381 00000FE9 CD21                    	int	21h				; current process is me
  4382 00000FEB BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  4383                                  	;mov	ax,offset RESGROUP:LODCOM
  4384 00000FEE B8[AD01]                        mov	ax,LODCOM
  4385 00000FF1 AB                              stosw
  4386 00000FF2 8CD8                            mov	ax,ds
  4387 00000FF4 AB                              stosw
  4388                                          ;mov	ax,offset RESGROUP:CONTC
  4389 00000FF5 B8[3C00]                        mov	ax,CONTC
  4390 00000FF8 AB                              stosw
  4391 00000FF9 8CD8                            mov	ax,ds
  4392 00000FFB AB                              stosw
  4393                                  	;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  4394 00000FFC B8[4F04]                	mov     ax,CRITERR
  4395 00000FFF AB                      	stosw
  4396 00001000 8CD8                    	mov     ax,ds
  4397 00001002 AB                      	stosw
  4398                                  	;mov	word ptr ds:16h,ds
  4399                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  4400 00001003 8C1E1600                	mov	[PDB.PARENT_PID],ds
  4401                                          ;mov	dx,offset RESGROUP:INT_2E
  4402 00001007 BA[7C01]                        mov	dx,INT_2E
  4403                                          ;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  4404 0000100A B82E25                  	mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  4405 0000100D CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  4406                                  			; AL = interrupt number
  4407                                  			; DS:DX = new vector to be used for specified interrupt
  4408 0000100F 07                              pop	es				; Remember environment
  4409                                  	
  4410                                  COMRETURNS:
  4411                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  4412 00001010 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  4413 00001013 A3[8E0A]                        mov	[PARENT],ax			; Save parent
  4414                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  4415 00001016 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  4416                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  4417 0000101A A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax, ds:18h
  4418 0000101D A3[F10A]                        mov	[IO_SAVE],ax		; Get the default stdin and out
  4419 00001020 8C1E[090C]                      mov	[COM_PTR+2],ds		; Set all these to resident
  4420 00001024 8C1E[0D0C]                      mov	[COM_FCB1+2],ds
  4421 00001028 8C1E[110C]              	mov	[COM_FCB2+2],ds
  4422                                          ;mov	di,offset ResGroup:ComSpec
  4423 0000102C BF[9B0A]                        mov	di,COMSPEC
  4424                                  
  4425                                  	;mov	si,[ECOMLOC]
  4426 0000102F 8B36[EC14]              	mov	si,[COMSPOFFSET]
  4427                                  	;cmp	AllocedEnv,0  ; MSDOS 6.0
  4428 00001033 803E[EB14]00                    cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  4429                                  	
  4430 00001038 8CD8                    	mov	ax,ds				; Xchg es,ds
  4431 0000103A 06                      	push	es
  4432 0000103B 1F                      	pop	ds
  4433 0000103C 8EC0                    	mov	es,ax
  4434                                  
  4435                                  	;jne	CopyComsp  ; MSDOS 6.0
  4436 0000103E 741D                            je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  4437                                  
  4438 00001040 0E                              push	cs
  4439 00001041 1F                              pop	ds
  4440                                  
  4441                                          ;mov	si,offset ResGroup:ComspString
  4442 00001042 BE[EE14]                	mov	si,COMSPSTRING ; "COMSPEC="
  4443 00001045 06                      	push	es
  4444 00001046 57                      	push	di
  4445 00001047 E84C02                  	call	IFINDE
  4446 0000104A 89FE                    	mov	si,di
  4447 0000104C 06                      	push	es
  4448 0000104D 1F                      	pop	ds
  4449 0000104E 5F                      	pop	di
  4450 0000104F 07                      	pop	es
  4451 00001050 730B                            jnc	short COPYCOMSP
  4452                                  
  4453                                  	; MSDOS 6.0
  4454                                  ;ComSpecNofnd:
  4455                                          ;mov	si,offset ResGroup:ComspString
  4456                                          ;add	si,ComspStrLen
  4457                                  	;push	cs
  4458                                  	;pop	ds
  4459                                  
  4460                                  COMSPECNOFND:
  4461                                  	; MSDOS 3.3
  4462                                          ;mov	si,[es:ECOMLOC]
  4463 00001052 268B36[EC14]                    mov	si,[es:COMSPOFFSET]
  4464                                  	;add	si,offset RESGROUP:PATHSTRING
  4465 00001057 81C6[400C]                      add	si,PATHSTRING ; "PATH="
  4466 0000105B 0E                      	push	cs
  4467 0000105C 1F                              pop	ds
  4468                                  
  4469                                  COPYCOMSP:
  4470                                  	; MSDOS 3.3 & MSDOS 6.0
  4471                                  	;mov	es:PutBackComSpec.SubstPtr,di
  4472 0000105D 26893E[DB0A]            	mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  4473 00001062 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  4474 00001066 7506                    	jne	short COPYCOMSPLOOP		; If not, do not skip over first 2 bytes
  4475                                  	;add	es:PutBackComSpec.SubstPtr,2
  4476 00001068 268306[DB0A]02          	add	word [es:PUTBACKSUBSTPTR],2
  4477                                  
  4478                                  COPYCOMSPLOOP:
  4479 0000106E AC                      	lodsb
  4480 0000106F AA                      	stosb
  4481 00001070 08C0                    	or	al,al
  4482 00001072 75FA                    	jnz	short COPYCOMSPLOOP
  4483                                  
  4484 00001074 26893E[DD0A]            	mov	[es:COMSPEC_END],di		; Save ptr to end of comspec path
  4485 00001079 26FF0E[DD0A]            	dec	word [es:COMSPEC_END]
  4486 0000107E 268A26[E60A]            	mov	ah,[es:COMDRV]
  4487 00001083 80C440                  	add	ah,'A'-1 ; 40h
  4488 00001086 268826[2309]            	mov	[es:PUTBACKDRV],ah		; save drive letter
  4489                                  
  4490                                  	; MSDOS 6.0
  4491                                  	;call	setup_for_messages		; set up parse and extended error messages
  4492                                  ;
  4493                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  4494                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  4495                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  4496                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  4497                                  ; the data otherwise it is just the data.
  4498                                  ; 
  4499                                  	;call	Setup_res_end			;put resident size in ResSize
  4500                                  
  4501                                  	;push	cs
  4502                                  	;pop	ds
  4503                                  	;assume	ds:RESGROUP
  4504                                  
  4505                                  ;Public EnvMaximum
  4506                                  ;EnvMaximum:
  4507                                  
  4508                                  	; MSDOS 3.3
  4509 0000108B 0E                      	push	cs
  4510 0000108C 1F                              pop	ds
  4511                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  4512 0000108D BB[380C]                	mov	bx,DATARESEND+15
  4513 00001090 B104                            mov	cl,4
  4514 00001092 D3EB                            shr	bx,cl
  4515 00001094 B44A                            MOV     AH,SETBLOCK ; 4Ah
  4516 00001096 CD21                            int	21h			; Shrink me to the resident only
  4517                                  
  4518                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  4519                                  
  4520 00001098 C606[E30A]01            	mov	byte [TRNMVFLG], 1
  4521 0000109D 06                      	push	es ; *
  4522 0000109E BE[5015]                	mov	si,TRANSTART
  4523 000010A1 BF0000                  	mov	di,0
  4524 000010A4 8E06[E10A]              	mov	es,[TRNSEG]
  4525                                  	;mov	cx,4D5Ch
  4526 000010A8 B93C4D                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  4527 000010AB 51                      	push	cx
  4528 000010AC 89C8                    	mov	ax,cx
  4529 000010AE 01F0                    	add	ax,si
  4530 000010B0 B104                    	mov	cl,4
  4531 000010B2 D3E8                    	shr	ax,cl
  4532 000010B4 40                      	inc	ax
  4533 000010B5 8CD9                    	mov	cx,ds
  4534 000010B7 01C8                    	add	ax,cx
  4535 000010B9 3B06[E10A]              	cmp	ax,[TRNSEG]
  4536 000010BD 59                      	pop	cx
  4537 000010BE 7205                    	jb	short MOV_DOWN
  4538                                  
  4539 000010C0 E8B4F2                  	call	LOADCOM
  4540 000010C3 EB0A                    	jmp	short ICHKSUM
  4541                                  
  4542                                  MOV_DOWN:
  4543 000010C5 01CE                    	add     si,cx
  4544 000010C7 4E                      	dec     si
  4545 000010C8 01CF                    	add     di,cx
  4546 000010CA 4F                      	dec     di
  4547 000010CB FD                      	std
  4548 000010CC F3A4                    	rep movsb
  4549 000010CE FC                      	cld
  4550                                  
  4551                                  ICHKSUM:
  4552                                  	; 24/09/2018
  4553                                  ;
  4554                                  ; Compute checksum right now before we can get corrupted and save it
  4555                                  ;
  4556                                  	; MSDOS 6.0
  4557                                  	;mov	si,offset RESGROUP:TranStart
  4558                                  	;add	si,100h
  4559                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  4560                                  	;
  4561                                  	;cld
  4562                                  	;shr	cx,1
  4563                                  	;xor	dx,dx
  4564                                  ;Ichksum:
  4565                                  	;lodsw
  4566                                  	;add	dx,ax
  4567                                  	;adc	dx,0
  4568                                  	;loop	Ichksum
  4569                                  	;
  4570                                          ;mov	Sum,dx			; store checksum
  4571                                  
  4572                                  	; MSDOS 3.3
  4573 000010CF 07                      	pop     es ; *
  4574 000010D0 E8F3F2                  	call    CHKSUM
  4575 000010D3 8916[E90A]              	mov     [SUM],dx
  4576                                  
  4577                                  	; MSDOS 3.3 & MSDOS 6.0
  4578 000010D7 803E[DE14]00                    cmp     byte [PRDATTM],0	;
  4579 000010DC 750C                            jnz     short NOBATCHSEG	; don't do autoexec or date time
  4580                                  ;
  4581                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  4582                                  ;
  4583                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  4584                                  	;mov	bx,3
  4585 000010DE BB0300                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  4586 000010E1 B448                            mov     ah,ALLOC ; 48h		;
  4587 000010E3 CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4588                                  			; BX = number of 16-byte paragraphs desired
  4589 000010E5 7203                    	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  4590 000010E7 A3[990A]                        mov     [BATCH],ax		; save batch segment
  4591                                  
  4592                                  NOBATCHSEG:
  4593                                  	; MSDOS 6.0
  4594                                  	;mov	bx,EnvirSeg                     ; get old environment segment
  4595                                  	;mov	OldEnv,bx                       ; save it
  4596                                  	;
  4597                                          ;mov	UsedEnv,0                       ; initialize env size counter
  4598                                  	;mov	ds,bx
  4599                                  	;assume	ds:nothing
  4600                                  	;
  4601                                  	;xor	si,si
  4602                                  	;mov	di,si
  4603                                  ;
  4604                                  ; This is the maximum allowed size for the environment
  4605                                  ;
  4606                                  	;mov	bx,4096 - 1 			; max. allowed env. size
  4607                                  	;mov	EnvMax,bx
  4608                                  				 
  4609                                  	;shl	bx,1
  4610                                  	;shl	bx,1
  4611                                  	;shl	bx,1
  4612                                  	;shl	bx,1
  4613                                  	;mov	EnvMax, bx			; convert envmax to bytes
  4614                                  	;dec	bx				; dec by one to leave room for double 0
  4615                                  	;xor	dx,dx				; use dx to indicate that there was
  4616                                  						; no environment size error.
  4617                                  ;public NxtStr
  4618                                  ;NxtStr:
  4619                                  	;call	GetStrLen			; get the size of the current env string
  4620                                  
  4621                                  ;Bugbug: Can use ss here to address UsedEnv
  4622                                  
  4623                                  	;push	ds                              ; get addressability to environment
  4624                                          ;push	cs                              ;                       counter
  4625                                          ;pop	ds                              ;
  4626                                          ;assume	ds:ResGroup
  4627                                          ;add	UsedEnv,cx                      ; add the string length to env size
  4628                                          ;pop	ds                              ;
  4629                                  	;assume	ds:nothing
  4630                                  	;cmp	cx,1				; end of environment was encountered.
  4631                                  	;jz	EnvExit
  4632                                  	;sub	bx,cx
  4633                                  	;jae	OkCpyStr			; can't fit in all of enviroment.
  4634                                  	;inc	dx				; out of env space msg must be displayed
  4635                                  	;jmp	short EnvExit
  4636                                  ;OkCpyStr:
  4637                                  	;jmp	NxtStr
  4638                                  ;EnvExit:
  4639                                  	;push	cs
  4640                                  	;pop	ds
  4641                                  	;assume	ds:ResGroup
  4642                                  	;or	dx,dx				; dx will be non-zero if error
  4643                                  	;jz	EnvNoErr
  4644                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  4645                                  	;call 	RPrint
  4646                                  	;
  4647                                  ;EnvNoErr:
  4648                                  	;mov	ax,EnvSiz			;env size previously set
  4649                                  	;mov	cl,4
  4650                                  	;shl	ax,cl				;get size in bytes
  4651                                  	;cmp	ax,UsedEnv			;is it a new env?
  4652                                  	;ja	st_envsize			;yes, store the size
  4653                                  	;
  4654                                  	;mov	ax,UsedEnv
  4655                                  	;add	ax,15				;round up
  4656                                  ;st_envsize:	
  4657                                  	;shr	ax,cl
  4658                                  	;mov	EnvSiz,ax			;store env size needed(paras)
  4659                                  ;if MSVER
  4660                                  	;cmp	SingleCom,0
  4661                                  	;jnz	nophead 			; don't print header if singlecom
  4662                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4663                                  	;call	RPrint
  4664                                  ;nophead:
  4665                                  ;endif
  4666                                  
  4667                                  	; MSDOS 3.3
  4668 000010EA BBFFFF                  	mov     bx,0FFFFh ; 65535
  4669 000010ED B448                    	mov     ah,ALLOC ; 48h
  4670 000010EF CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4671                                  			; BX = number of 16-byte paragraphs desired
  4672 000010F1 2B1E[0A15]              	sub     bx,[TRNSIZE]
  4673 000010F5 81EB8000                	sub     bx,128
  4674 000010F9 891E[0215]              	mov     [ENVMAX],bx
  4675                                  
  4676 000010FD 81FB0010                	cmp     bx,4096
  4677 00001101 7207                    	jb      short ALLOCENVIRSEG
  4678 00001103 BBFF0F                  	mov     bx,4096-1		; max. allowed environment size
  4679 00001106 891E[0215]              	mov     [ENVMAX],bx
  4680                                  
  4681                                  ALLOCENVIRSEG:
  4682 0000110A B448                    	mov     ah,ALLOC ; 48h
  4683 0000110C CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4684                                  			; BX = number of 16-byte paragraphs desired
  4685 0000110E 8B1E[050C]              	mov     bx,[ENVIRSEG]		; get old environment segment
  4686 00001112 891E[0415]              	mov     [OLDENV],bx		; save it	
  4687 00001116 C706[0615]0000          	mov     word [USEDENV],0	; initialize environment size counter
  4688 0000111C 8EDB                    	mov     ds,bx
  4689 0000111E 36A3[050C]              	mov     [ss:ENVIRSEG], ax	; save new environment segment
  4690 00001122 8EC0                    	mov     es,ax
  4691 00001124 31F6                    	xor     si,si
  4692 00001126 89F7                    	mov     di,si
  4693 00001128 368B1E[0215]            	mov     bx,[ss:ENVMAX]
  4694 0000112D D1E3                    	shl     bx,1
  4695 0000112F D1E3                    	shl     bx,1
  4696 00001131 D1E3                    	shl     bx,1
  4697 00001133 D1E3                    	shl     bx,1
  4698 00001135 36891E[0215]            	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  4699 0000113A 4B                      	dec     bx			; dec by one to leave room for double 0
  4700 0000113B 31D2                    	xor     dx,dx			; use dx to indicate that there was
  4701                                  					; no environment size error.
  4702                                  
  4703                                  NXSTR:
  4704 0000113D E80F01                  	call    GETSTRLEN		; get the size of the current env string
  4705                                  
  4706 00001140 1E                      	push    ds
  4707 00001141 0E                      	push    cs
  4708 00001142 1F                      	pop     ds
  4709 00001143 010E[0615]              	add     [USEDENV],cx		; add the string length to env size
  4710 00001147 1F                      	pop     ds
  4711 00001148 83F901                  	cmp     cx,1			; end of environment was encountered.
  4712 0000114B 7409                    	je      short ENVEXIT
  4713 0000114D 29CB                    	sub     bx,cx
  4714 0000114F 7303                    	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  4715 00001151 42                      	inc     dx			; out of env space msg must be displayed
  4716 00001152 EB02                    	jmp     short ENVEXIT
  4717                                  
  4718                                  	;nop
  4719                                  
  4720                                  OKCPYSTR:
  4721 00001154 EBE7                    	jmp     short NXSTR
  4722                                  
  4723                                  ENVEXIT: 
  4724 00001156 0E                      	push    cs
  4725 00001157 1F                      	pop     ds
  4726 00001158 09D2                    	or      dx, dx			; dx will be non-zero if error
  4727 0000115A 7406                    	jz      short ENVNOERR
  4728 0000115C BA[7014]                	mov     dx,OUTENVMSG		; dx = ptr to msg
  4729 0000115F E81201                  	call    RPRINT
  4730                                  
  4731                                  ENVNOERR:
  4732 00001162 8B0E[0215]              	mov     cx,[ENVMAX]
  4733 00001166 29D9                    	sub     cx,bx			; current environment size in bytes
  4734 00001168 83C110                  	add     cx,16			; add memory arena to the size
  4735 0000116B D1E9                    	shr     cx,1
  4736 0000116D D1E9                    	shr     cx,1
  4737 0000116F D1E9                    	shr     cx,1
  4738 00001171 D1E9                    	shr     cx,1			; convert current env size to paragraphs
  4739 00001173 3B0E[0015]              	cmp     cx,[ENVSIZ]		; compare with env size previously set
  4740                                  	;jb	short SET_ENVSIZE
  4741 00001177 7604                    	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  4742 00001179 890E[0015]              	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  4743                                  
  4744                                  SET_ENVSIZE:
  4745 0000117D 8B1E[0015]              	mov     bx,[ENVSIZ]
  4746 00001181 8CC0                    	mov     ax,es
  4747 00001183 01D8                    	add     ax,bx			; get end segment of environemnt
  4748 00001185 3B06[0815]              	cmp     ax,[INITEND]		; compare with init code end segment
  4749 00001189 770E                    	ja      short NOPHEAD
  4750                                  					; free unused paragraghs		
  4751 0000118B 8CC0                    	mov     ax,es
  4752 0000118D 8B1E[0815]              	mov     bx,[INITEND]
  4753 00001191 29C3                    	sub     bx,ax
  4754                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  4755 00001193 C706[0C15]0100          	mov	word [RESETENV],1	; environment segment reset sign
  4756                                  
  4757                                  NOPHEAD:
  4758                                  	; MSDOS 3.3
  4759 00001199 B44A                    	mov     ah,SETBLOCK ; 4Ah
  4760 0000119B CD21                    	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  4761                                  			; ES = segment address of block to change
  4762                                  			; BX = new size in paragraphs
  4763                                  
  4764                                  	; MSDOS 3.3 & 6.0
  4765 0000119D 833E[990A]00            	cmp     word [BATCH],0		; did we set up a batch segment?
  4766 000011A2 7503                    	jnz     short DODATE		; yes - go initialize it
  4767 000011A4 E99300                  	jmp     NODTTM			; don't do autoexec or date time
  4768                                  
  4769                                  DODATE:
  4770                                  ;
  4771                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  4772                                  ;
  4773                                  
  4774 000011A7 A1[990A]                	mov	ax,[BATCH]		; get batch segment
  4775 000011AA C606[EF0A]03            	mov	byte [ECHOFLAG],3	; set batch echo
  4776 000011AF C706[FE0A]0100          	mov	word [NEST],1		; set nest flag to 1 batch
  4777 000011B5 8EC0                    	mov	es,ax
  4778                                  ;
  4779                                  ; initialize the segment
  4780                                  ;
  4781 000011B7 31FF                    	xor	di,di
  4782 000011B9 B000                    	mov	al,BATCHTYPE ; 0
  4783 000011BB AA                      	stosb
  4784 000011BC B001                    	mov	al,1			; initialize echo for batch exit
  4785 000011BE AA                      	stosb
  4786                                  ;
  4787                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  4788                                  ;
  4789 000011BF 31C0                    	xor	ax,ax			; initialize to zero
  4790                                  	;stosb	; MSDOS 6.0 		; clear out BatchEOF
  4791                                  
  4792 000011C1 AB                      	stosw				; batch segment of last job - batlast
  4793 000011C2 AB                      	stosw				; segment for FOR
  4794 000011C3 AA                      	stosb				; FOR flag
  4795 000011C4 AB                      	stosw				; position in file - batseek
  4796 000011C5 AB                      	stosw
  4797                                  ;
  4798                                  ; clean out the parameters
  4799                                  ;
  4800 000011C6 B8FFFF                  	mov	ax,-1			; initialize to no parameters
  4801 000011C9 B90A00                  	mov	cx,10
  4802 000011CC F3AB                    	rep	stosw
  4803                                  ;
  4804                                  ; decide whether we should grab the default drive
  4805                                  ;
  4806 000011CE 803E[CE14]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  4807 000011D3 750B                    	jnz	short NOAUTSET
  4808 000011D5 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h
  4809 000011D7 CD21                    	int	21h
  4810                                  	;add	al,'A'
  4811 000011D9 0206[FF14]              	add	al,[letter_A] ; Ucasea
  4812 000011DD A2[CE14]                	mov	[AUTOBAT],al
  4813                                  
  4814                                  NOAUTSET:
  4815                                  ;
  4816                                  ; copy in the batch file name (including nul)
  4817                                  ;
  4818                                  	;mov	si,offset ResGroup:AutoBat
  4819 000011E0 BE[CE14]                	mov	si,AUTOBAT
  4820 000011E3 B90800                  	mov	cx,8
  4821 000011E6 F3A5                    	rep	movsw
  4822                                  	;movsb	; MSDOS 6.0		; move in carriage return to terminate string
  4823                                  
  4824                                  	;mov	dx,offset ResGroup:AutoBat
  4825 000011E8 BA[CE14]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  4826                                  
  4827                                  	;mov	ax,OPEN shl 8
  4828 000011EB B8003D                  	mov	ax,OPEN*256 ; 3D00h  ; open for read
  4829 000011EE CD21                    	int	21h			; see if autoexec.bat exists
  4830 000011F0 7208                    	jc	short NOABAT
  4831 000011F2 89C3                    	mov	bx,ax
  4832 000011F4 B43E                    	mov	ah,CLOSE  ; 3Eh
  4833 000011F6 CD21                    	int	21h
  4834 000011F8 EB4D                    	jmp	short DRV0		; go process autoexec
  4835                                  
  4836                                  NOABAT:
  4837 000011FA 50                      	push	ax
  4838 000011FB E85A00                  	call	SETUP_SEG
  4839 000011FE A3[E914]                	mov	[TRIAGEADD+2],ax
  4840 00001201 58                      	pop	ax
  4841 00001202 FF1E[E714]              	call	far [TRIAGEADD]		; get extended error
  4842 00001206 83F841                  	cmp	ax,65			; network access denied?
  4843 00001209 7506                    	jne	short OPENERR		; no - go deallocate batch
  4844                                  
  4845                                  _ACCDENERROR:					; yes - put out message
  4846                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  4847 0000120B BA[5314]                	mov	dx,ACCDENERR
  4848 0000120E E86300                  	call	RPRINT
  4849                                  
  4850                                  OPENERR:
  4851 00001211 8E06[990A]              	mov	es,[BATCH]		; not found--turn off batch job
  4852 00001215 B449                    	mov	ah,DEALLOC ; 49h
  4853 00001217 CD21                    	int	21h
  4854 00001219 C706[990A]0000          	mov	word [BATCH],0		; after dealloc in case of ^c
  4855 0000121F C606[EF0A]01            	mov	byte [ECHOFLAG],1
  4856 00001224 C706[FE0A]0000          	mov	word [NEST],0		; indicate no batch in progress
  4857                                  
  4858                                  DODTTM:
  4859                                  	;mov	ax,offset TranGroup:Datinit
  4860                                  
  4861 0000122A B86F20                  	mov	ax,DATINIT
  4862 0000122D A3[DF14]                	mov	[INITADD],ax
  4863                                  
  4864                                  	; MSDOS 6.0
  4865                                  ;;;M004	mov	ax,TrnSeg	
  4866                                  ;
  4867                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  4868                                  ; M004; the transient starts on a para boundary at the label TranStart.
  4869                                  ; M004; We use TranStart to get the start of the transient segment.
  4870                                  ;
  4871                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  4872                                  	;mov	cl,4				; M004
  4873                                  	;shr	ax,cl				; get relative seg ; M004
  4874                                  	;mov	cx,cs
  4875                                  	;add	ax,cx				; ax = transient seg ; M004
  4876                                  
  4877                                  	; MSDOS 3.3
  4878                                  	; 25/09/2018
  4879 00001230 A1[E10A]                	mov     ax,[TRNSEG]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  4880                                  
  4881                                  	; MSDOS 3.3 & MSDOS 6.0
  4882 00001233 A3[E114]                	mov	[INITADD+2],ax
  4883                                  	;call	dword ptr InitAdd
  4884 00001236 FF1E[DF14]              	call	far [INITADD]
  4885                                  
  4886                                  NODTTM:
  4887                                  	; MSDOS 6.0
  4888                                  Copyright:
  4889                                  	;public	Copyright
  4890                                  ;	Bugbug:	remove Copyright label.
  4891                                  
  4892                                  ;if IBMVER
  4893                                  	;cmp	SingleCom,0
  4894                                  	;jnz	Drv0				; don't print header if singlecom
  4895                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4896                                  	;call	RPrint
  4897                                  ;endif
  4898                                  
  4899                                  	; MSDOS 3.3
  4900 0000123A 833E[F50A]00            	cmp	word [SINGLECOM],0	; don't print header if singlecom
  4901 0000123F 7506                    	jnz     short DRV0
  4902 00001241 BA[AF14]                	mov     dx,HEADERPTR	; dx = ptr to msg
  4903 00001244 E82D00                  	call    RPRINT
  4904                                  
  4905                                  DRV0:
  4906                                  	; MSDOS 3.3
  4907 00001247 C606[5B0B]00                    mov     byte [INITFLAG],0
  4908 0000124C E9B0F1                  	jmp	ENDINIT
  4909                                  
  4910                                  	; MSDOS 6.0
  4911                                  ;Drv0:						; Reset APPEND state
  4912                                  ;	push	ds				; save data segment
  4913                                  ;	push	cs				; Get local segment into DS
  4914                                  ;	pop	ds				;
  4915                                  ;	mov	ax,APPENDSETSTATE		; Set the state of Append
  4916                                  ;	mov	bx,Append_State 		;  back to the original state
  4917                                  ;	int	2fh				;
  4918                                  ;	pop	ds				; get data segment back
  4919                                  ;;
  4920                                  ;;Check FirstCom set previously to see if this is the first instance of
  4921                                  ;;command.com. If not, we do not move command.com. Instead, we copy over the
  4922                                  ;;jump table from the previous stub to the current stub.
  4923                                  ;;
  4924                                  ;	cmp	FirstCom,1			;first command.com?
  4925                                  ;	jz	move_code			;yes, move it
  4926                                  ;
  4927                                  ;	push	es
  4928                                  ;	push	ds
  4929                                  ;
  4930                                  ;	push	ds
  4931                                  ;	pop	es
  4932                                  ;	mov	di,offset DATARES:Int2f_Entry
  4933                                  ;
  4934                                  ;	mov	ds,word ptr es:ResJmpTable+2	;get segment address
  4935                                  ;	mov	si,word ptr es:ResJmpTable	;get offset address
  4936                                  ;
  4937                                  ;	mov 	cx,NUM_RELOC_ENTRIES 		;number of dword ptrs
  4938                                  ;	shl	cx,1
  4939                                  ;	shl	cx,1				;size of table in bytes
  4940                                  ;
  4941                                  ;	cld
  4942                                  ;	rep	movsb				;copy the jump table
  4943                                  ;;
  4944                                  ;;Check if the resident code is in HMA. We assume that it is in HMA if its 
  4945                                  ;;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  4946                                  ;;
  4947                                  ;	cmp	es:[di-2],0f000h		;is resident code in HMA?
  4948                                  ;	jb	res_low				;no, dont set flag
  4949                                  ;
  4950                                  ;	mov	es:ComInHMA,1			;indicate code in HMA
  4951                                  ;
  4952                                  ;res_low:
  4953                                  ;	pop	ds
  4954                                  ;	pop	es
  4955                                  ;	jmp	short finish_init
  4956                                  ;;
  4957                                  ;;Now, we can move the resident code to its final location, either to HIMEM
  4958                                  ;;or to overlay the messages in the data segment if the user has not used the
  4959                                  ;;/msg switch.
  4960                                  ;;
  4961                                  ;move_code:
  4962                                  ;	call	Move_res_code			;move the code
  4963                                  ;
  4964                                  ;finish_init:
  4965                                  ;	jmp	RESGROUP:EndInit 		;g finish initializing
  4966                                  
  4967                                  
  4968                                  GETSTRLEN:
  4969                                  ;
  4970                                  ;	Get length of string pointed to by DS:SI.  Length includes NULL.
  4971                                  ;	Length is returned in CX
  4972                                  ;
  4973                                  	; MSDOS 3.3 & MSDOS 6.0
  4974 0000124F 31C9                    	xor	cx,cx
  4975                                  NXTCHAR:
  4976 00001251 AC                      	lodsb
  4977 00001252 41                      	inc	cx
  4978 00001253 08C0                    	or	al,al
  4979 00001255 75FA                    	jnz	short NXTCHAR
  4980 00001257 C3                      	retn
  4981                                  
  4982                                  SETUP_SEG:
  4983                                  ;
  4984                                  ; If the transient has been loaded in TranSeg, then we need to use that
  4985                                  ; segment for calls to routines in the transient area. Otherwise, the current
  4986                                  ; code segment is used
  4987                                  ; Segment returned in AX.
  4988                                  ;
  4989                                  	; MSDOS 3.3 & MSDOS 6.0
  4990 00001258 A1[E10A]                	mov	ax,[TRNSEG]
  4991 0000125B 803E[E30A]01            	cmp	byte [TRNMVFLG],1	; Has transient portion been moved
  4992 00001260 7411                    	je	short SETUP_END
  4993 00001262 53                      	push	bx
  4994 00001263 8CCB                    	mov	bx,cs
  4995                                  	;mov	ax,offset ResGroup:TranStart
  4996 00001265 B8[5015]                	mov	ax,TRANSTART
  4997 00001268 D1E8                    	shr	ax,1
  4998 0000126A D1E8                    	shr	ax,1
  4999 0000126C D1E8                    	shr	ax,1
  5000 0000126E D1E8                    	shr	ax,1
  5001 00001270 01D8                    	add	ax,bx
  5002 00001272 5B                      	pop	bx
  5003                                  SETUP_END:
  5004 00001273 C3                      	retn
  5005                                  
  5006                                  RPRINT:
  5007                                  	; MSDOS 3.3
  5008 00001274 50                      	push    ax
  5009 00001275 E8E0FF                  	call    SETUP_SEG
  5010 00001278 A3[E514]                	mov     [PRINTADD+2], ax
  5011                                  	;call	dword ptr PRINTADD
  5012 0000127B FF1E[E314]              	call	far [PRINTADD]
  5013 0000127F 58                      	pop     ax
  5014 00001280 C3                      	retn
  5015                                  
  5016                                  	; MSDOS 6.0
  5017                                  ;***	RPrintParse - display parse error message
  5018                                  ;
  5019                                  ;	ENTRY	DX = parse error #
  5020                                  ;
  5021                                  ;	EXIT	nothing
  5022                                  ;
  5023                                  ;	USED	flags
  5024                                  ;
  5025                                  ;	EFFECTS
  5026                                  ;	  Message is displayed on stdout.
  5027                                  ;
  5028                                  ;RPrintParse	proc
  5029                                  ;
  5030                                  ;	assume	ds:ResGroup,ss:ResGroup
  5031                                  ;
  5032                                  ;	push	dx				; preserve DX
  5033                                  ;	xchg	bx,dx				; bx = parse error #
  5034                                  ;						; dx = saved BX
  5035                                  ;	dec	bx				; bx = parse error index, from 0
  5036                                  ;	shl	bx,1				; bx = offset in word table
  5037                                  ;	mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  5038                                  ;	xchg	bx,dx				; dx = ptr to error msg
  5039                                  ;						; bx = restored
  5040                                  ;	call	RPrint				; print the message
  5041                                  ;	pop	dx				; restore DX
  5042                                  ;	ret
  5043                                  ;
  5044                                  ;RPrintParse	endp
  5045                                  
  5046                                  PATHCHRCMPR:
  5047                                  	; MSDOS 3.3
  5048 00001281 52                      	push	dx
  5049 00001282 8A16[F914]              	mov	dl,[slash_chr]
  5050                                  	;cmp	byte [RSWITCHAR],'/'
  5051 00001286 3816[190C]                      cmp	[RSWITCHAR],dl
  5052 0000128A 7404                    	je	short RNOSLASHT
  5053                                  	;cmp	al,'/'
  5054 0000128C 38D0                    	cmp	al,dl
  5055 0000128E 7404                    	je	short RET41 ; zf = 1 
  5056                                  RNOSLASHT:
  5057                                          ;cmp	al,'\'
  5058 00001290 3A06[FA14]              	cmp	al,[bslash_chr]
  5059                                  RET41:
  5060 00001294 5A                      	pop	dx
  5061 00001295 C3                      	retn
  5062                                  
  5063                                  IFINDE:
  5064                                  	; MSDOS 3.3 & MSDOS 6.0
  5065 00001296 E80400                  	call	IFIND				; find the name
  5066 00001299 722D                    	jc	short IFIND2			; carry means not found
  5067 0000129B EB3A                    	jmp	short ISCASB1 			; scan for = sign
  5068                                  ;
  5069                                  ; on return of find1, es:di points to beginning of name
  5070                                  ;
  5071                                  IFIND:
  5072 0000129D FC                      	cld
  5073 0000129E E82800                  	call	ICOUNT0 			; cx = length of name
  5074 000012A1 8E06[050C]              	mov	es,[ENVIRSEG]
  5075 000012A5 31FF                    	xor	di,di
  5076                                  IFIND1:
  5077 000012A7 51                      	push	cx
  5078 000012A8 56                      	push	si
  5079 000012A9 57                      	push	di
  5080                                  IFIND11:
  5081 000012AA AC                      	lodsb
  5082 000012AB E83600                  	call	IUPCONV
  5083 000012AE 47                      	inc	di
  5084 000012AF 263A45FF                	cmp	al,[es:di-1]
  5085 000012B3 7502                    	jnz	short IFIND12
  5086 000012B5 E2F3                    	loop	IFIND11
  5087                                  IFIND12:
  5088 000012B7 5F                      	pop	di
  5089 000012B8 5E                      	pop	si
  5090 000012B9 59                      	pop	cx
  5091 000012BA 740C                    	jz	short IFIND2
  5092 000012BC 51                      	push	cx
  5093 000012BD E81C00                  	call	ISCASB2 			; scan for a nul
  5094 000012C0 59                      	pop	cx
  5095 000012C1 26803D00                	cmp	byte [es:di],0
  5096 000012C5 75E0                    	jnz	short IFIND1
  5097 000012C7 F9                      	stc					; indicate not found
  5098                                  IFIND2:
  5099 000012C8 C3                      	retn
  5100                                  
  5101                                  ICOUNT0:
  5102 000012C9 1E                      	push	ds
  5103 000012CA 07                      	pop	es
  5104 000012CB 89F7                    	mov	di,si
  5105                                  
  5106 000012CD 57                      	push	di				; count number of chars until "="
  5107 000012CE E80600                  	call	ISCASB1
  5108                                  	; 25/09/2018
  5109                                  	;jmp	short ICOUNTX
  5110                                  	;push	di				; count number of chars until nul
  5111                                  	;call	ISCASB2
  5112                                  
  5113                                  ;ICOUNTX:
  5114 000012D1 59                      	pop	cx
  5115 000012D2 29CF                    	sub	di,cx
  5116 000012D4 87F9                    	xchg	di,cx
  5117 000012D6 C3                      	retn
  5118                                  
  5119                                  ISCASB1:
  5120                                  	;mov	al,"="
  5121 000012D7 A0[F614]                	mov	al,[equal_sign]			; scan for an =
  5122 000012DA EB02                    	jmp	short ISCASBX
  5123                                  
  5124                                  ISCASB2:
  5125 000012DC 30C0                    	xor	al,al				; scan for a nul
  5126                                  
  5127                                  ISCASBX:
  5128 000012DE B90001                  	mov	cx,256 ; 100h
  5129 000012E1 F2AE                    	repnz	scasb
  5130 000012E3 C3                      	retn
  5131                                  
  5132                                  IUPCONV:
  5133                                  	; MSDOS 3.3
  5134                                          ;cmp	al,"a"
  5135 000012E4 3A06[F714]              	cmp	al,[letter_a]
  5136 000012E8 7208                            jb	short IRET22
  5137                                          ;cmp	al,"z"
  5138 000012EA 3A06[F814]                      cmp	al,[letter_z]
  5139 000012EE 7702                    	ja	short IRET22
  5140 000012F0 2C20                            sub	al,20h			; Lower-case changed to upper-case
  5141                                  IRET22:
  5142 000012F2 C3                              retn
  5143                                  
  5144                                  	; MSDOS 6.0
  5145                                  ; ****************************************************************
  5146                                  ; *
  5147                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  5148                                  ; *
  5149                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  5150                                  ; *		 the character in AL from the file upper case table
  5151                                  ; *		 in DOS if character if above  ascii 128, else
  5152                                  ; *		 subtracts 20H if between "a" and "z".
  5153                                  ; *
  5154                                  ; * INPUT:	 DS	      set to resident
  5155                                  ; *		 AL	      char to be upper cased
  5156                                  ; *		 FUCASE_ADDR  set to the file upper case table
  5157                                  ; *
  5158                                  ; * OUTPUT:	 AL	      upper cased character
  5159                                  ; *
  5160                                  ; ****************************************************************
  5161                                  ;
  5162                                  ;IupConv proc	near				
  5163                                  ;	assume	ds:ResGroup			;
  5164                                  ;
  5165                                  ;	cmp	al,80h				; see if char is > ascii 128
  5166                                  ;	jb	other_fucase			; no - upper case math
  5167                                  ;	sub	al,80h				; only upper 128 chars in table
  5168                                  ;	push	ds				;
  5169                                  ;	push	bx				;
  5170                                  ;	lds	bx,dword ptr fucase_addr+1		; get table address
  5171                                  ;	add	bx,2				; skip over first word
  5172                                  ;	xlat	ds:byte ptr [bx]			; convert to upper case
  5173                                  ;	pop	bx				;
  5174                                  ;	pop	ds				;
  5175                                  ;	jmp	short iupconv_end			; we finished - exit
  5176                                  ;
  5177                                  ;other_fucase:					;
  5178                                  ;	cmp	al,Lcasea			; if between "a" and "z",
  5179                                  ;	jb	iupconv_end			;     subtract 20h to get
  5180                                  ;	cmp	al,Lcasez			; upper case equivalent.
  5181                                  ;	ja	iupconv_end			;
  5182                                  ;	sub	al,20h				; Change lower-case to upper
  5183                                  ;
  5184                                  ;iupconv_end:					;
  5185                                  ;	ret
  5186                                  ;
  5187                                  ;IupConv endp					;
  5188                                  
  5189                                  
  5190                                  INIT_CONTC_SPECIALCASE:
  5191                                  	; MSDOS 3.3 & MSDOS 6.0
  5192                                  						; This routine is called if control-C
  5193 000012F3 83C406                  	add	sp,6				;  is type during the date/time prompt
  5194 000012F6 56                      	push	si				;  at initialization time.  The desired
  5195 000012F7 89D6                    	mov	si,dx				;  response is to make it look like the
  5196 000012F9 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  5197 000012FE 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  5198 000012FF CF                      	iret					;  a <CR> in the user's buffer, and
  5199                                  						;  returning directly to the user.
  5200                                  						; In this case the user is TCODE.
  5201                                  
  5202                                  ;=============================================================================
  5203                                  ; UNINIT.ASM, MSDOS 6.0 ,1991
  5204                                  ;=============================================================================
  5205                                  ; 24/09/2018 - Retro DOS v3.0
  5206                                  
  5207                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  5208                                  
  5209                                  ; TITLE	COMMAND Initialization messages
  5210                                  
  5211                                  ;INIT	SEGMENT PUBLIC PARA
  5212                                  
  5213                                  	; 25/09/2018
  5214                                  	; (15 bytes filler)
  5215 00001300 00                      	db 0
  5216 00001301 32352F392F32303138-     	db "25/9/2018 ETAN"
  5216 0000130A 204554414E         
  5217 0000130F 00                      	db 0
  5218                                  
  5219                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  5220                                  	;dw 0
  5221                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  5222 00001310 0D0A                    	db 0Dh,0Ah
  5223 00001312 0D0A                    	db 0Dh,0Ah
  5224 00001314 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  5224 0000131D 285229204D532D444F-
  5224 00001326 532852292020566572-
  5224 0000132F 73696F6E20332E3330 
  5225 00001338 0D0A                    	db 0Dh,0Ah
  5226 0000133A 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1987               '
  5226 00001343 20202020284329436F-
  5226 0000134C 70797269676874204D-
  5226 00001355 6963726F736F667420-
  5226 0000135E 436F72702031393831-
  5226 00001367 2D3139383720202020-
  5226 00001370 202020202020202020-
  5226 00001379 2020               
  5227 0000137B 200D0A                  	db ' ',0Dh,0Ah
  5228 0000137E 202020202020202020-     	db '                                                   ',
  5228 00001387 202020202020202020-
  5228 00001390 202020202020202020-
  5228 00001399 202020202020202020-
  5228 000013A2 202020202020202020-
  5228 000013AB 202020202020       
  5229 000013B1 0D0A00                  	db 0Dh,0Ah,0
  5230                                  
  5231 000013B4 20<rep 2Bh>             	times	43 db 20h
  5232                                  
  5233 000013DF 537065636966696564-     _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  5233 000013E8 20434F4D4D414E4420-
  5233 000013F1 736561726368206469-
  5233 000013FA 726563746F72792062-
  5233 00001403 61640D0A00         
  5234                                  BADCOMLKMES:
  5235 00001408 [DF13]                  	dw _152Fh
  5236                                  
  5237 0000140A 537065636966696564-     _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  5237 00001413 20434F4D4D414E4420-
  5237 0000141C 736561726368206469-
  5237 00001425 726563746F72792062-
  5237 0000142E 616420616363657373-
  5237 00001437 2064656E6965640D0A-
  5237 00001440 00                 
  5238                                  BADCOMACCMSG:
  5239 00001441 [0A14]                  	dw _155Ah
  5240                                  
  5241 00001443 416363657373206465-     _1593h:	db 'Access denied',0Dh,0Ah,0
  5241 0000144C 6E6965640D0A00     
  5242                                  ACCDENERR:
  5243 00001453 [4314]                  	dw _1593h
  5244                                  
  5245 00001455 4F7574206F6620656E-     _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  5245 0000145E 7669726F6E6D656E74-
  5245 00001467 2073706163650D0A00 
  5246                                  OUTENVMSG:
  5247 00001470 [5514]                  	dw _15A5h
  5248                                  
  5249                                  BADVERMSG:
  5250 00001472 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah,'$'
  5250 0000147B 20444F532076657273-
  5250 00001484 696F6E0D0A24       
  5251                                  
  5252                                  BADENVSIZMSG:
  5253 0000148A 496E76616C69642065-     	db 'Invalid environment size specified',0Dh,0Ah,'$'
  5253 00001493 6E7669726F6E6D656E-
  5253 0000149C 742073697A65207370-
  5253 000014A5 656369666965640D0A-
  5253 000014AE 24                 
  5254                                  
  5255                                  HEADERPTR:
  5256 000014AF [1013]                  	dw COPYRIGHTMSG
  5257                                  
  5258                                  ICONDEV:
  5259 000014B1 2F4445562F                      db '/DEV/'
  5260 000014B6 434F4E                  	db 'CON'
  5261 000014B9 000000000000            	db 0,0,0,0,0,0		; Room for 8 char device	
  5262                                  BADCSPFL:
  5263 000014BF 00                      	db 0
  5264                                  COMSPECT:
  5265 000014C0 2F434F4D4D414E442E-     	db '/COMMAND.COM',0
  5265 000014C9 434F4D00           
  5266 000014CD 00                      	db 0
  5267                                  AUTOBAT:
  5268 000014CE 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0 
  5268 000014D7 45432E42415400     
  5269                                  PRDATTM:
  5270 000014DE FF                      	db -1 ; 0FFh		 ; Init not to prompt for date time
  5271                                  INITADD:
  5272 000014DF 00000000                	dd 0
  5273                                  	;dw 0
  5274                                  	;dw 0
  5275                                  PRINTADD:
  5276 000014E3 BF34                    	dw PRINTF_INIT
  5277 000014E5 0000                    	dw 0
  5278                                  TRIAGEADD:
  5279 000014E7 F31E                    	dw TRIAGE_INIT
  5280 000014E9 0000                    	dw 0
  5281                                  CHUCKENV:
  5282 000014EB 00                      	db 0
  5283                                  COMSPOFFSET:
  5284                                  ECOMLOC:
  5285                                  	;dw 0Eh
  5286                                  	;dw offset ENVIRONMENT:ECOMSPEC-10h
  5287 000014EC 0E00                    	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  5288                                  COMSPSTRING:
  5289 000014EE 434F4D535045433D        	db 'COMSPEC='
  5290                                  equal_sign:
  5291 000014F6 3D                      	db '='
  5292                                  letter_a:
  5293 000014F7 61                      	db 'a'
  5294                                  letter_z:
  5295 000014F8 7A                      	db 'z'
  5296                                  slash_chr:
  5297 000014F9 2F                      	db '/'
  5298                                  bslash_chr:
  5299 000014FA 5C                      	db '\'
  5300                                  space_chr:
  5301 000014FB 20                      	db 20h
  5302                                  letter_p:
  5303 000014FC 70                      	db 'p'
  5304                                  letter_d:
  5305 000014FD 64                      	db 'd'
  5306                                  letter_c:
  5307 000014FE 63                      	db 'c'
  5308                                  letter_A:
  5309 000014FF 41                      	db 'A'
  5310                                  ENVSIZ:
  5311 00001500 0000                    	dw 0
  5312                                  ENVMAX:
  5313 00001502 0000                    	dw 0
  5314                                  OLDENV:
  5315 00001504 0000                    	dw 0
  5316                                  USEDENV:
  5317 00001506 0000                    	dw 0
  5318                                  INITEND:
  5319 00001508 0000                    	dw 0
  5320                                  TRNSIZE:
  5321 0000150A 0000                    	dw 0
  5322                                  RESETENV:
  5323 0000150C 0000                    	dw 0
  5324                                  
  5325                                  ;INIT	ENDS
  5326                                  
  5327                                  ;	END
  5328                                  
  5329                                  ;-----------------------------------------------------------------------------
  5330                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  5331                                  ;-----------------------------------------------------------------------------
  5332                                  
  5333                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  5334                                  ; 12/01/2023
  5335 0000150E 526574726F20444F53-     db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018-2023]"
  5335 00001517 2076332E3020434F4D-
  5335 00001520 4D414E442E434F4D20-
  5335 00001529 6279204572646F6761-
  5335 00001532 6E2054616E205B3230-
  5335 0000153B 31382D323032335D   
  5336 00001543 00                      db	0
  5337                                  
  5338                                  ;-----------------------------------------------------------------------------
  5339                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  5340                                  ;-----------------------------------------------------------------------------
  5341                                  
  5342                                  ;TAIL    SEGMENT PUBLIC PARA
  5343                                  ;        ORG     0
  5344                                  ;TRANSTART       LABEL   WORD
  5345                                  ;TAIL    ENDS
  5346                                  
  5347 00001544 90<rep Ch>              ALIGN 16  ; 25/09/2018
  5348                                  
  5349                                  ;TRANSTART:
  5350                                  
  5351                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  5352                                  ;	times	128 db 0	
  5353                                  
  5354                                  ;-----------------------------------------------------------------------------
  5355                                  ; SEGMENT - TRANSCODE
  5356                                  ;-----------------------------------------------------------------------------
  5357                                  
  5358                                  TRANGROUP: ; 21/04/2018
  5359                                  
  5360                                  ;=============================================================================
  5361                                  ; TRANCODE.ASM
  5362                                  ;=============================================================================
  5363                                  ; 24/09/2018 - Retro DOS v3.0
  5364                                  
  5365                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  5366                                  
  5367                                  ; 21/04/2018 - Retro DOS v2.0
  5368                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  5369                                  ; (these values must be changed when transcom.s source code is changed
  5370                                  ; and data offsets are changed)
  5371                                  ;
  5372                                  ; 30/04/2018
  5373                                  ; 29/04/2018
  5374                                  
  5375                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5376                                  ;COMMAND      EQU  012CH
  5377                                  ;DATINIT      EQU  2091H
  5378                                  ;HEADCALL     EQU  428FH
  5379                                  ;TRANSPACEEND EQU  4D5CH
  5380                                  ;TRANDATAEND  EQU  3F44H
  5381                                  
  5382                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5383                                  ;TRIAGE_INIT  EQU  1F15H
  5384                                  ;PRINTF_INIT  EQU  34E0H 
  5385                                  
  5386                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  5387                                  
  5388                                  ;TPA	EQU  4293H
  5389                                  ;TRNLEN	EQU  04D6H
  5390                                  
  5391                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  5392                                  COMMAND      EQU  012CH
  5393                                  DATINIT      EQU  206FH
  5394                                  HEADCALL     EQU  426FH
  5395                                  TRANSPACEEND EQU  4D3CH
  5396                                  TRANDATAEND  EQU  3F24H
  5397                                  TRIAGE_INIT  EQU  1EF3H
  5398                                  PRINTF_INIT  EQU  34BFH 
  5399                                  
  5400                                  GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  5401                                  
  5402                                  ;-----------------------------------------------------------------------------
  5403                                  ;START OF TRANSIENT PORTION
  5404                                  ;This code is loaded at the end of memory and may be overwritten by
  5405                                  ;memory-intensive user programs.
  5406                                  ;-----------------------------------------------------------------------------
  5407                                  
  5408                                  ;TRANSTART EQU $
  5409                                  ; 29/09/2018 
  5410                                  TRANSTART:		  ; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  5411                                  
  5412                                  ; 25/09/2018
  5413                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  5414                                  ;
  5415                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  5416                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  5417                                  ;
  5418                                  TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  5419                                  ;
  5420                                  
  5421                                  ;COMTRANS:
  5422                                  
  5423                                  ; 20/10/2018 - Retro DOS v3.0	
  5424 00001550 <bin 4D3Ch>             INCBIN	"TRANCOM3.BIN"
  5425                                  
  5426                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  5427                                  
  5428                                  ; 29/04/2018
  5429                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  5430                                  ;
  5431                                  ;TIMES BSS_SIZE db 0
  5432                                  ;
  5433                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  5434                                  
  5435                                  ;COMMANDCOMSIZE equ $ - 100h
