     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 3.3 Command Interpreter) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 03/03/2023 ((Previous: 20/10/2018))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11 
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command3.s -l command3.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND2.S' (MSDOS 2.11 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 05/05/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  
    43                                  ;============================================================================
    44                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    45                                  ;============================================================================
    46                                  ; 21/09/2018 - Retro DOS v3.0
    47                                  
    48                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    49                                  ;BREAK <system call definitions>
    50                                  
    51                                  ;
    52                                  ;	Microsoft Confidential
    53                                  ;	Copyright (C) Microsoft Corporation 1991
    54                                  ;	All Rights Reserved.
    55                                  ;
    56                                  
    57                                  ;SUBTTL	system call definitions
    58                                  ;PAGE
    59                                  
    60                                  Abort				EQU 0	;  0	  0
    61                                  STD_CON_INPUT			EQU 1	;  1	  1
    62                                  Std_Con_Output			EQU 2	;  2	  2
    63                                  Std_Aux_Input			EQU 3	;  3	  3
    64                                  Std_Aux_Output			EQU 4	;  4	  4
    65                                  Std_Printer_Output		EQU 5	;  5	  5
    66                                  Raw_Con_IO			EQU 6	;  6	  6
    67                                  RAW_CON_INPUT			EQU 7	;  7	  7
    68                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    69                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    70                                  Std_Con_String_Input		EQU 10	; 10	  A
    71                                  Std_Con_Input_Status		EQU 11	; 11	  B
    72                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    73                                  DISK_RESET			EQU 13	; 13	  D
    74                                  Set_Default_Drive		EQU 14	; 14	  E
    75                                  FCB_Open			EQU 15	; 15	  F
    76                                  FCB_Close			EQU 16	; 16	 10
    77                                  Dir_Search_First		EQU 17	; 17	 11
    78                                  Dir_Search_Next 		EQU 18	; 18	 12
    79                                  FCB_Delete			EQU 19	; 19	 13
    80                                  FCB_Seq_Read			EQU 20	; 20	 14
    81                                  FCB_Seq_Write			EQU 21	; 21	 15
    82                                  FCB_Create			EQU 22	; 22	 16
    83                                  FCB_Rename			EQU 23	; 23	 17
    84                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    85                                  Set_DMA 			EQU 26	; 26	 1A
    86                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    87                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    88                                  ;									   ;
    89                                  Get_Default_DPB 		EQU 31	; 31	 1F
    90                                  ;									   ;
    91                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    92                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    93                                  FCB_Random_Read 		EQU 33	; 33	 21
    94                                  FCB_Random_Write		EQU 34	; 34	 22
    95                                  Get_FCB_File_Length		EQU 35	; 35	 23
    96                                  Get_FCB_Position		EQU 36	; 36	 24
    97                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
    98                                  Create_Process_Data_Block	EQU 38	; 38	 26
    99                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   100                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   101                                  Parse_File_Descriptor		EQU 41	; 41	 29
   102                                  Get_Date			EQU 42	; 42	 2A
   103                                  Set_Date			EQU 43	; 43	 2B
   104                                  Get_Time			EQU 44	; 44	 2C
   105                                  Set_Time			EQU 45	; 45	 2D
   106                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   107                                  ; Extended functionality group
   108                                  Get_DMA 			EQU 47	; 47	 2F
   109                                  GET_VERSION			EQU 48	; 48	 30
   110                                  Keep_Process			EQU 49	; 49	 31
   111                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;									   ;
   114                                  Get_DPB 			EQU 50	; 50	 32
   115                                  ;									   ;
   116                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   117                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   118                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   119                                  Get_InDOS_Flag			EQU 52	; 52	 34
   120                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   121                                  Get_Drive_Freespace		EQU 54	; 54	 36
   122                                  CHAR_OPER			EQU 55	; 55	 37
   123                                  International			EQU 56	; 56	 38
   124                                  ;   Directory Group
   125                                  MKDir				EQU 57	; 57	 39
   126                                  RMDir				EQU 58	; 58	 3A
   127                                  CHDir				EQU 59	; 59	 3B
   128                                  ;   File Group
   129                                  Creat				EQU 60	; 60	 3C
   130                                  OPEN				EQU 61	; 61	 3D
   131                                  CLOSE				EQU 62	; 62	 3E
   132                                  READ				EQU 63	; 63	 3F
   133                                  Write				EQU 64	; 64	 40
   134                                  Unlink				EQU 65	; 65	 41
   135                                  LSEEK				EQU 66	; 66	 42
   136                                  CHMod				EQU 67	; 67	 43
   137                                  IOCTL				EQU 68	; 68	 44
   138                                  XDUP				EQU 69	; 69	 45
   139                                  XDup2				EQU 70	; 70	 46
   140                                  Current_Dir			EQU 71	; 71	 47
   141                                  ;    Memory Group
   142                                  ALLOC				EQU 72	; 72	 48
   143                                  DEALLOC				EQU 73	; 73	 49
   144                                  SETBLOCK			EQU 74	; 74	 4A
   145                                  ;    Process Group
   146                                  Exec				EQU 75	; 75	 4B
   147                                  EXIT				EQU 76	; 76	 4C
   148                                  WAITPROCESS			EQU 77	; 77	 4D
   149                                  Find_First			EQU 78	; 78	 4E
   150                                  ;   Special Group
   151                                  Find_Next			EQU 79	; 79	 4F
   152                                  ; SPECIAL SYSTEM GROUP
   153                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   154                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   155                                  ;									   ;
   156                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   157                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   158                                  Get_In_Vars			EQU 82	; 82	 52
   159                                  SetDPB				EQU 83	; 83	 53
   160                                  ;									   ;
   161                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   162                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   163                                  Get_Verify_On_Write		EQU 84	; 84	 54
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   166                                  ;									   ;
   167                                  Dup_PDB 			EQU 85	; 85	 55
   168                                  ;									   ;
   169                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   170                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   171                                  Rename				EQU 86	; 86	 56
   172                                  File_Times			EQU 87	; 87	 57
   173                                  AllocOper			EQU 88	; 88	 58
   174                                  ; Network extention system calls
   175                                  GetExtendedError		EQU 89	; 89	 59
   176                                  CreateTempFile			EQU 90	; 90	 5A
   177                                  CreateNewFile			EQU 91	; 91	 5B
   178                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   179                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   180                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   181                                  ;									   ;
   182                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   183                                  					;	    CloseByName, CloseUser,
   184                                  					;	    CloseUserProcess,
   185                                  					;	    GetOpenFileList
   186                                  ;									   ;
   187                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   188                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   189                                  UserOper			EQU 94	; 94	 5E Get and Set
   190                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   191                                  xNameTrans			EQU 96	; 96	 60
   192                                  PathParse			EQU 97	; 97	 61
   193                                  GetCurrentPSP			EQU 98	; 98	 62
   194                                  Hongeul 			EQU 99	; 99	 63
   195                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   196                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   197                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   198                                  ;									   ;
   199                                  Set_Printer_Flag		EQU 100 ; 100	 64
   200                                  ;									   ;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   203                                  GetExtCntry			EQU 101 ; 101	 65
   204                                  GetSetCdPg			EQU 102 ; 102	 66
   205                                  ExtHandle			EQU 103 ; 103	 67
   206                                  Commit				EQU 104 ; 104	 68
   207                                  GetSetMediaID			EQU 105 ; 105	 69
   208                                  IFS_IOCTL			EQU 107 ; 107	 6B
   209                                  ExtOpen 			EQU 108 ; 108	 6C
   210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   211                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   212                                  ;                                                                          ;
   213                                  ;ifdef ROMEXEC
   214                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   215                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   216                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F			; M035
   217                                  ;endif
   218                                  ;                                                                          ;
   219                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   220                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   221                                  ;
   222                                  ;
   223                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   224                                  OEM_C1				EQU 249 ; 249	 F9
   225                                  OEM_C2				EQU 250 ; 250	 FA
   226                                  OEM_C3				EQU 251 ; 251	 FB
   227                                  OEM_C4				EQU 252 ; 252	 FC
   228                                  OEM_C5				EQU 253 ; 253	 FD
   229                                  OEM_C6				EQU 254 ; 254	 FE
   230                                  OEM_C7				EQU 255 ; 255	 FF
   231                                  
   232                                  ;============================================================================
   233                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   234                                  ;============================================================================
   235                                  ; 21/09/2018 - Retro DOS v3.0
   236                                  
   237                                  ;BREAK <Control character definitions>
   238                                  
   239                                  c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
   240                                  c_BS	    EQU     08h 		; ^H ASCII backspace
   241                                  c_CR	    EQU     0Dh 		; ^M ASCII carriage return
   242                                  c_LF	    EQU     0Ah 		; ^J ASCII linefeed
   243                                  c_ETB	    EQU     17h 		; ^W ASCII end of transmission
   244                                  c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
   245                                  c_ETX	    EQU     03h 		; ^C ASCII end of text
   246                                  c_HT	    EQU     09h 		; ^I ASCII tab
   247                                  
   248                                  ;============================================================================
   249                                  ; DIRENT.INC, MSDOS 6.0, 1991
   250                                  ;============================================================================
   251                                  ; 21/09/2018 - Retro DOS v3.0
   252                                  
   253                                  ;Break <Directory entry>
   254                                  
   255                                  ;	NOTE:  These offsets are also used in the DTA for
   256                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   257                                  ;	with the FCB filename field, and the rest of the
   258                                  ;	DIR_ENTRY fields follow. -DavidOls
   259                                  
   260                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   261                                  ;
   262                                  ;	+---------------------------+
   263                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   264                                  ;	+---------------------------+
   265                                  ;	|     (BYTE) attributes     |	    11	    B
   266                                  ;	+---------------------------+
   267                                  ;	|    (10 BYTE) reserved     |	    12	    C
   268                                  ;	+---------------------------+
   269                                  ;	| (WORD) time of last write |	    22	    16
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) date of last write |	    24	    18
   272                                  ;	+---------------------------+
   273                                  ;	|   (WORD) First cluster    |	    26	    1A
   274                                  ;	+---------------------------+
   275                                  ;	|     (DWORD) file size     |	    28	    1C
   276                                  ;	+---------------------------+
   277                                  ;
   278                                  ;   First byte of filename  = E5 -> free directory entry
   279                                  ;			    = 00 -> end of allocated directory
   280                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   281                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   282                                  ;
   283                                  
   284                                  STRUC DIR_ENTRY
   285 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   286 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   287 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   288 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   289 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   290 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   291 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   292 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   293 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   294 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   295 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   296                                  .size:
   297                                  
   298                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   299                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   300                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   301                                  ;	    this field is zero for subdirectory files.
   302                                  
   303                                  ENDSTRUC
   304                                  
   305                                  ATTR_READ_ONLY	equ	 1h
   306                                  ATTR_HIDDEN	equ	 2h
   307                                  ATTR_SYSTEM	equ	 4h
   308                                  ATTR_VOLUME_ID	equ	 8h
   309                                  ATTR_DIRECTORY	equ	10h
   310                                  ATTR_ARCHIVE	equ	20h
   311                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   312                                  				;   NO directory entry on a disk EVER
   313                                  				;   has this bit set. It is set non-zero
   314                                  				;   when a device is found by GETPATH
   315                                  
   316                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   317                                  				; OR of hard attributes for FINDENTRY
   318                                  
   319                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   320                                  				; ignore this(ese) attribute(s) during
   321                                  				; search first/next
   322                                  
   323                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   324                                  				; changeable via CHMOD
   325                                  
   326                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   327                                  
   328                                  ;============================================================================
   329                                  ; ERROR.INC, MSDOS 6.0, 1991
   330                                  ;============================================================================
   331                                  ; 21/09/2018 - Retro DOS v3.0
   332                                  
   333                                  ;**	ERROR.INC - DOS Error Codes
   334                                  ;
   335                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   336                                  ;    return error codes through AX.	If an error occurred then
   337                                  ;    the carry bit will be set and the error code is in AX.	If no error
   338                                  ;    occurred then the carry bit is reset and AX contains returned info.
   339                                  ;
   340                                  ;    Since the set of error codes is being extended as we extend the operating
   341                                  ;    system, we have provided a means for applications to ask the system for a
   342                                  ;    recommended course of action when they receive an error.
   343                                  ;
   344                                  ;    The GetExtendedError system call returns a universal error, an error
   345                                  ;    location and a recommended course of action.	The universal error code is
   346                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   347                                  ;    is issued.
   348                                  
   349                                  
   350                                  ;	2.0 error codes
   351                                  
   352                                  error_invalid_function		EQU	1
   353                                  ERROR_FILE_NOT_FOUND		EQU	2
   354                                  error_path_not_found		EQU	3
   355                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   356                                  ERROR_ACCESS_DENIED		EQU	5
   357                                  error_invalid_handle		EQU	6
   358                                  error_arena_trashed		EQU	7
   359                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   360                                  error_invalid_block		EQU	9
   361                                  error_bad_environment		EQU	10
   362                                  ERROR_BAD_FORMAT		EQU	11
   363                                  error_invalid_access		EQU	12
   364                                  error_invalid_data		EQU	13
   365                                  ;**** reserved			EQU	14	; *****
   366                                  error_invalid_drive		EQU	15
   367                                  error_current_directory 	EQU	16
   368                                  error_not_same_device		EQU	17
   369                                  error_no_more_files		EQU	18
   370                                  
   371                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   372                                  
   373                                  ERROR_WRITE_PROTECT		EQU	19
   374                                  error_bad_unit			EQU	20
   375                                  error_not_ready 		EQU	21
   376                                  error_bad_command		EQU	22
   377                                  error_CRC			EQU	23
   378                                  error_bad_length		EQU	24
   379                                  error_Seek			EQU	25
   380                                  error_not_DOS_disk		EQU	26
   381                                  error_sector_not_found		EQU	27
   382                                  error_out_of_paper		EQU	28
   383                                  error_write_fault		EQU	29
   384                                  error_read_fault		EQU	30
   385                                  ERROR_GEN_FAILURE		EQU	31
   386                                  
   387                                  ;	the new 3.0 error codes reported through INT 24
   388                                  
   389                                  error_sharing_violation 	EQU	32
   390                                  error_lock_violation		EQU	33
   391                                  error_wrong_disk		EQU	34
   392                                  ERROR_FCB_UNAVAILABLE		EQU	35
   393                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   394                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   395                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   396                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   397                                  
   398                                  ;	New OEM network-related errors are 50-79
   399                                  
   400                                  error_not_supported		EQU	50
   401                                  
   402                                  error_net_access_denied		EQU	65	;M028
   403                                  
   404                                  ;	End of INT 24 reportable errors
   405                                  
   406                                  error_file_exists		EQU	80
   407                                  error_DUP_FCB			EQU	81	; *****
   408                                  error_cannot_make		EQU	82
   409                                  error_FAIL_I24			EQU	83
   410                                  
   411                                  ;	New 3.0 network related error codes
   412                                  
   413                                  error_out_of_structures 	EQU	84
   414                                  error_Already_assigned		EQU	85
   415                                  error_invalid_password		EQU	86
   416                                  error_invalid_parameter 	EQU	87
   417                                  error_NET_write_fault		EQU	88
   418                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   419                                  
   420                                  ;============================================================================
   421                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   422                                  ;============================================================================
   423                                  ; 22/09/2018 - Retro DOS v3.0
   424                                  
   425                                  ;**	DevSym.inc - Device Symbols
   426                                  
   427                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   428                                  
   429                                  STRUC SYSDEV
   430 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   431 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   432 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   433 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   434 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   435                                  .size:
   436                                  ENDSTRUC
   437                                  
   438                                  ; 24/09/2018
   439                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   440                                  
   441                                  ;============================================================================
   442                                  ; CURDIR.INC, MSDOS 6.0, 1991
   443                                  ;============================================================================
   444                                  ; 21/09/2018 - Retro DOS v3.0
   445                                  
   446                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   447                                  
   448                                  ;============================================================================
   449                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   450                                  ;============================================================================
   451                                  ; 21/09/2018 - Retro DOS v3.0
   452                                  
   453                                  ;/*
   454                                  ; *                      Microsoft Confidential
   455                                  ; *                      Copyright (C) Microsoft Corporation 1991
   456                                  ; *                      All Rights Reserved.
   457                                  ; */
   458                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   459                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   460                                  ;*************************************
   461                                  ; COMMAND EQUs which are not switch dependant
   462                                  
   463                                  ;		include	curdir.inc	; to get DIRSTRLEN
   464                                  ;		Note dossym.inc must already have been included!
   465                                  
   466                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   467                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   468                                  
   469                                  SYM		EQU	">"
   470                                  
   471                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   472                                  
   473                                  NORMPERLIN	EQU	1
   474                                  WIDEPERLIN	EQU	5
   475                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   476                                  BatLen		EQU	32		; buffer for batch files
   477                                  YES_ECHO	EQU	1		; echo line
   478                                  NO_ECHO 	EQU	0		; don't echo line
   479                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   480                                  call_in_progress EQU	1		; indicate we're in the CALL command
   481                                  length_call	EQU	4		; length of CALL
   482                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   483                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   484                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   485                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   486                                  nullcommand	EQU    1		; no command on command line
   487                                  end_of_line	EQU    -1		;AN000; end of line return from parser
   488                                  end_of_line_out EQU	0		;AN000; end of line for output
   489                                  end_of_line_in	EQU	0dh		;AN000; end of line for input
   490                                  result_number	EQU	1		;AN000; number returned from parser
   491                                  result_string	EQU	3		;AN000; string returned from parser
   492                                  result_filespec EQU	5		;AN000; filespec returned from parser
   493                                  result_drive	EQU	6		;AN000; drive returned from parser
   494                                  result_date	EQU	7		;AN000; date returned from parser
   495                                  result_time	EQU	8		;AN000; time returned from parser
   496                                  result_no_error EQU	0		;AN000; no error returned from parser
   497                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   498                                  util_msg_class	EQU	-1		;AN000; message class for utility
   499                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   500                                  parse_msg_class EQU	2		;AN000; message class for parse error
   501                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   502                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   503                                  colon_char	EQU	":"             ;AN000; colon character
   504                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   505                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   506                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   507                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   508                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   509                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   510                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   511                                  shell_action	equ	0ffh		;AN000; SHELL - return for taking SHELL specific action
   512                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   513                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   514                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   515                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   516                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   517                                  parm_block_size equ	11		;AN000; size of message subst block
   518                                  blank		equ	" "             ;AN000; blank character
   519                                  no_subst	equ	0		;AN000; no substitutions for messages
   520                                  one_subst	equ	1		;AN000; one substitution for messages
   521                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   522                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   523                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   524                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   525                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   526                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   527                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   528                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   529                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   530                                  capital_A	equ	'A'             ;AC000;
   531                                  vbar		equ	'|'             ;AC000;
   532                                  labracket	equ	'<'             ;AC000;
   533                                  rabracket	equ	'>'             ;AC000;
   534                                  dollar		equ	'$'             ;AC000;
   535                                  lparen		equ	'('             ;AC000;
   536                                  rparen		equ	')'             ;AC000;
   537                                  nullrparen	equ	29h		;AC000;
   538                                  in_word 	equ	4e49h		;AC000; 'NI'  ('IN' backwards)
   539                                  do_word 	equ	4f44h		;AC000; 'OD'  ('DO' backwards)
   540                                  star		equ	'*'             ;AC000;
   541                                  plus_chr	equ	'+'             ;AC000;
   542                                  small_a 	equ	'a'             ;AC000;
   543                                  small_z 	equ	'z'             ;AC000;
   544                                  dot_chr 	equ	'.'             ;AC000;
   545                                  tab_chr 	equ	9		;AN032;
   546                                  equal_chr	equ	'='             ;AN032;
   547                                  semicolon	equ	';'             ;AN049;
   548                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   549                                  dot_colon	equ	2e3ah		;AC000; '.:'
   550                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   551                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   552                                  AppendInstall	equ	0B700H		;AN020; append install check
   553                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   554                                  AppendGetState	equ	0B706H		;AN020; append get current state
   555                                  AppendSetState	equ	0B707H		;AN020; append set current state
   556                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   557                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   558                                  
   559                                  ;*************************************
   560                                  ;* PARSE ERROR MESSAGES
   561                                  ;*************************************
   562                                  
   563                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   564                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   565                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   566                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   567                                  
   568                                  ;*************************************
   569                                  ;* EQUATES FOR MESSAGE RETRIEVER
   570                                  ;*************************************
   571                                  
   572                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   573                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   574                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   575                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   576                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   577                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   578                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   579                                  
   580                                  ;*********************************
   581                                  ;* EQUATES FOR INT 10H
   582                                  ;*********************************
   583                                  
   584                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   585                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   586                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   587                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   588                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   589                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   590                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   591                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   592                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   593                                  
   594                                  AltPipeChr	equ	"|"             ; alternate pipe character
   595                                  
   596                                  FCB		EQU	5CH
   597                                  
   598                                  STRUC VARSTRUC
   599 00000000 ??                      .ISDIR:		RESB	1
   600 00000001 ??                      .SIZ:		RESB	1
   601 00000002 ????                    .TTAIL:		RESW	1
   602 00000004 ??                      .INFO:		RESB	1
   603 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   604                                  .size:
   605                                  ENDSTRUC
   606                                  ;
   607                                  ; Flags for internal command parsing
   608                                  ;
   609                                  fCheckDrive	equ	00000001b	; validate drive letter
   610                                  fSwitchAllowed	equ	00000010b	; switches allowed
   611                                  fLimitHelp	equ	00000100b	; /? must appear alone
   612                                  
   613                                  ;
   614                                  ; Test switches
   615                                  ;
   616                                  fParse		EQU	0001h		; display results of parseline
   617                                  
   618                                  ;
   619                                  ; Batch segment structure
   620                                  ;
   621                                  ;   BYTE    type of segment
   622                                  ;   BYTE    echo state of parent on entry to batch file
   623                                  ;   WORD    segment of last batch file
   624                                  ;   WORD    segment for FOR command
   625                                  ;   BYTE    FOR flag state on entry to batch file
   626                                  ;   DWORD   offset for next line
   627                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
   628                                  ;   ASCIZ   file name (with . and ..)
   629                                  ;   BYTES   CR-terminated parameters
   630                                  ;   BYTE    0 flag to indicate end of parameters
   631                                  ;
   632                                  
   633                                  BATCHTYPE   equ 0
   634                                  
   635                                  STRUC BATCHSEGMENT
   636 00000000 ??                      .BatType:	RESB	1		; signature
   637 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   638                                  ;.BatchEOF:	RESB	1		; records if EOF reached on file
   639 00000002 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   640 00000004 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   641 00000006 ??                      .BatForFlag:	RESB	1		; G state of FOR
   642 00000007 ????????                .BatSeek:	RESD	1		; lseek position of next char
   643 0000000B <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   644 0000001F ??                      .BatFile:	RESB	1		; beginning of batch file name
   645                                  .SIZE:
   646                                  ENDSTRUC
   647                                  
   648                                  ANULL		equ	0		; terminates an argv string
   649                                  ARGMAX		equ	64		; max args on a command line
   650                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   651                                  tplen		equ	64		; max size of one argument
   652                                  arg_cnt_error	equ	1		; number of args > MAXARG
   653                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   654                                  
   655                                  STRUC ARGV_ELE				; elements in the argv array
   656 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   657 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   658 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   659 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   660 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   661 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   662                                  .SIZE:
   663                                  ENDSTRUC
   664                                  
   665                                  STRUC ARG_UNIT
   666 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   667 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   668 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   669 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   670 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   671                                  .SIZE:
   672                                  ENDSTRUC
   673                                  
   674                                  ; Equates for initialization
   675                                  ;
   676                                  INITINIT	equ	01h		; initialization in progress
   677                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   678                                  INITCTRLC	equ	04h		; already in ^C handler
   679                                  
   680                                  ;=============================================================================
   681                                  ; PDB.INC, MSDOS 6.0, 1991
   682                                  ;=============================================================================
   683                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   684                                  
   685                                  ;**	Process data block (otherwise known as program header)
   686                                  
   687                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   688                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   689                                  ;	for use.
   690                                  
   691                                  FILPERPROC	EQU     20
   692                                  
   693                                  struc PDB	; Process_data_block
   694 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   695 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   696 00000004 ??                                      resb 1
   697 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   698 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   699 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   700 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   701 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   702 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   703 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   704 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   705 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   706 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   707 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   708 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   709 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   710 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   711 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   712 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   713 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   714 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   715                                  				;  an extended FCB
   716                                  ;endstruc 	; MSDOS 3.3
   717                                  	  	; MSDOS 6.0
   718 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   719 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   720 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   721 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   722                                  endstruc
   723                                  
   724                                  ;=============================================================================
   725                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   726                                  ;=============================================================================
   727                                  ; 24/09/2018 - Retro DOS v3.0
   728                                  
   729                                  ;major_version       equ     6       ;Major DOS version
   730                                  ;minor_version       equ     00      ;Minor DOS Version
   731                                  
   732                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   733                                  
   734                                  ; MSDOS 3.3 COMMAND.COM
   735                                  MAJOR_VERSION	EQU 3
   736                                  MINOR_VERSION	EQU 30
   737                                  
   738                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   739                                  
   740                                  ;-----------------------------------------------------------------------------
   741                                  ; 21/09/2018
   742                                  ;-----------------------------------------------------------------------------
   743                                  ; Retro DOS v3.0 NOTE:  
   744                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   745                                  ;	with minor modifications which are done by me (Erdogan Tan).
   746                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   747                                  ;	source code files (written by using MASM syntax).
   748                                  ;-----------------------------------------------------------------------------
   749                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   750                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   751                                  ;----------------------------------------------------------------------------- 	
   752                                  
   753                                  ;=============================================================================
   754                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   755                                  ;=============================================================================
   756                                  ; 21/09/2018 - Retro DOS v3.0
   757                                  
   758                                  ;	page ,132
   759                                  ;	title	COMMAND - resident code for COMMAND.COM
   760                                  ;	name	COMMAND
   761                                  
   762                                  ;/*
   763                                  ; *                      Microsoft Confidential
   764                                  ; *                      Copyright (C) Microsoft Corporation 1991
   765                                  ; *                      All Rights Reserved.
   766                                  ; */
   767                                  
   768                                  ;*****************************************************************************
   769                                  ;
   770                                  ; MODULE:	       COMMAND.COM
   771                                  ;
   772                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   773                                  ;
   774                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   775                                  ;		       parts.  First is the resident portion, which includes
   776                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   777                                  ;		       error), and 2EH (command line execute); it also has
   778                                  ;		       code to test and, if necessary, reload the transient
   779                                  ;		       portion. Following the resident is the init code, which
   780                                  ;		       is overwritten after use.  Then comes the transient
   781                                  ;		       portion, which includes all command processing (whether
   782                                  ;		       internal or external).  The transient portion loads at
   783                                  ;		       the end of physical memory, and it may be overlayed by
   784                                  ;		       programs that need as much memory as possible. When the
   785                                  ;		       resident portion of command regains control from a user
   786                                  ;		       program, a check sum is performed on the transient
   787                                  ;		       portion to see if it must be reloaded.  Thus programs
   788                                  ;		       which do not need maximum memory will save the time
   789                                  ;		       required to reload COMMAND when they terminate.
   790                                  ;
   791                                  ; ENTRY POINT:	       PROGSTART
   792                                  ;
   793                                  ; INPUT:	       command line at offset 81H
   794                                  ;
   795                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   796                                  ;		       from a secondary command processor via the EXIT
   797                                  ;		       internal command.
   798                                  ;
   799                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   800                                  ;		       hang the system.
   801                                  ;
   802                                  ; INTERNAL REFERENCES:
   803                                  ;
   804                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   805                                  ;		       (COMMAND.DOC)
   806                                  ;
   807                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   808                                  ;		       (COMMAND.DOC)
   809                                  ;
   810                                  ; EXTERNAL REFERENCES:
   811                                  ;
   812                                  ;      ROUTINES:       none
   813                                  ;
   814                                  ;      DATA AREAS:     none
   815                                  ;
   816                                  ;*****************************************************************************
   817                                  ;
   818                                  ;			      REVISION HISTORY
   819                                  ;			      ----------------
   820                                  ;
   821                                  ; DOS 1.00 to DOS 3.30
   822                                  ; --------------------------
   823                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   824                                  ;
   825                                  ; REV 1.17
   826                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   827                                  ;	       resident since the EXELOAD may have overwritten the transient.
   828                                  ;
   829                                  ; REV 1.18
   830                                  ;    05/21/82  IBM version always looks on drive A
   831                                  ;	       MSVER always looks on default drive
   832                                  ;
   833                                  ; REV 1.19
   834                                  ;    06/03/82  Drive spec now entered in command line
   835                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   836                                  ;	       (print volume label)
   837                                  ;
   838                                  ; REV 1.20
   839                                  ;    06/09/82  Prints "directory" after directories
   840                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   841                                  ;
   842                                  ; REV 1.50
   843                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   844                                  ;	       do it right.
   845                                  ;
   846                                  ; REV 1.70
   847                                  ;	       EXEC used to fork off new processes
   848                                  ;
   849                                  ; REV 1.80
   850                                  ;	       C switch for single command execution
   851                                  ;
   852                                  ; REV 1.90
   853                                  ;	       Batch uses XENIX
   854                                  ;
   855                                  ; Rev 2.00
   856                                  ;	       Lots of neato stuff
   857                                  ;	       IBM 2.00 level
   858                                  ;
   859                                  ; Rev 2.01
   860                                  ;	       'D' switch for date time suppression
   861                                  ;
   862                                  ; Rev 2.02
   863                                  ;	       Default userpath is NUL rather than BIN
   864                                  ;		       same as IBM
   865                                  ;	       COMMAND split into pieces
   866                                  ;
   867                                  ; Rev 2.10
   868                                  ;	       INTERNATIONAL SUPPORT
   869                                  ;
   870                                  ; Rev 2.50
   871                                  ;	       all the 2.x new stuff -MU
   872                                  ;
   873                                  ; Rev 3.30     (Ellen G)
   874                                  ;	       CALL internal command (TBATCH2.ASM)
   875                                  ;	       CHCP internal command (TCMD2B.ASM)
   876                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   877                                  ;	       @ sign suppression of batch file line
   878                                  ;	       Replaceable environment value support in batch files
   879                                  ;	       INT 2FH calls for APPEND
   880                                  ;	       Lots of PTR fixes!
   881                                  ;
   882                                  ; Beyond 3.30 to forever  (Ellen G)
   883                                  ; ----------------------
   884                                  ;
   885                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   886                                  ;			Use Message Retriever services
   887                                  ;			/MSG switch for resident extended error msg
   888                                  ;			Convert to new capitalization support
   889                                  ;			Better error recovery on CHCP command
   890                                  ;			Code page file tag support
   891                                  ;			TRUENAME internal command
   892                                  ;			Extended screen line support
   893                                  ;			/P switch on DEL/ERASE command
   894                                  ;			Improved file redirection error recovery
   895                                  ;	(removed)	Improved batch file performance
   896                                  ;			Unconditional DBCS support
   897                                  ;			Volume serial number support
   898                                  ;	(removed)	COMMENT=?? support
   899                                  ;
   900                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   901                                  ;
   902                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   903                                  ;			require delimiters.
   904                                  ;
   905                                  ; A003	PTM P5,P9,P111	Included in A000 development
   906                                  ;
   907                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   908                                  ;			executing
   909                                  ;
   910                                  ; A005	DCR D17 	If user specifies an extension on the command
   911                                  ;			line search for that extension only.
   912                                  ;
   913                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   914                                  ;			exists"
   915                                  ;
   916                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   917                                  ;
   918                                  ; A008	PTM P182	Change COPY to set default if invalid function
   919                                  ;			returned from code page call.
   920                                  ;
   921                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   922                                  ;
   923                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   924                                  ;			transient COMMAND.
   925                                  ;
   926                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   927                                  ;			before appending to a file.
   928                                  ;
   929                                  ; A012	PTM P189	Fix redirection error recovery.
   930                                  ;
   931                                  ; A013	PTM P330	Change date format
   932                                  ;
   933                                  ; A014	PTM P455	Fix echo parsing
   934                                  ;
   935                                  ; A015	PTM P517	Fix DIR problem with * vs *.
   936                                  ;
   937                                  ; A016	PTM P354	Fix extended error message addressing
   938                                  ;
   939                                  ; A017	PTM P448	Fix appending to 0 length files
   940                                  ;
   941                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
   942                                  ;			the parser fails on. Fail on duplicate switches.
   943                                  ;
   944                                  ; A019	PTM P542	Fix device name to be printed correctly during
   945                                  ;			critical error
   946                                  ;
   947                                  ; A020	DCR D43 	Set append state off while in DIR
   948                                  ;
   949                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
   950                                  ;
   951                                  ; A022	DCR D209	Enhanced error recovery
   952                                  ;
   953                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
   954                                  ;
   955                                  ; A024	PTM P899	Fix EXTOPEN open modes.
   956                                  ;
   957                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
   958                                  ;
   959                                  ; A026	DCR D191	Change redirection error recovery support.
   960                                  ;
   961                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
   962                                  ;			with a carriage return.
   963                                  ;
   964                                  ; A028	PTM P1076	Print a blank line before printing invalid
   965                                  ;			date and invalid time messages.
   966                                  ;
   967                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
   968                                  ;			and TIME.
   969                                  ;
   970                                  ; A030	DCR D201	New extended attribute format.
   971                                  ;
   972                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
   973                                  ;
   974                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
   975                                  ;
   976                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
   977                                  ;
   978                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
   979                                  ;
   980                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
   981                                  ;			do a read to determine eof.
   982                                  ;
   983                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
   984                                  ;			so that ASSIGN works correctly.
   985                                  ;
   986                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
   987                                  ;
   988                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
   989                                  ;
   990                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
   991                                  ;
   992                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
   993                                  ;			specified.
   994                                  ;
   995                                  ; A041	PTM P1705	Close redirected files after internal APPEND
   996                                  ;			executes.
   997                                  ;
   998                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
   999                                  ;			files causing loss of batch file.
  1000                                  ;
  1001                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1002                                  ;			CALL'ed batch files.
  1003                                  ;
  1004                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1005                                  ;			as an end of line character
  1006                                  ;
  1007                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1008                                  ;			and extended message pointers when we EXIT if
  1009                                  ;			COMMAND /P is the top level process.
  1010                                  ;
  1011                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1012                                  ;			"File not found - fn"
  1013                                  ;
  1014                                  ; A047	PTM P2819	Fix transient reload prompt message
  1015                                  ;
  1016                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1017                                  ;			when DBCS code was added.
  1018                                  ;
  1019                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1020                                  ;			on line.
  1021                                  ;
  1022                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1023                                  ;
  1024                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1025                                  ;
  1026                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1027                                  ;
  1028                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1029                                  ;
  1030                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1031                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1032                                  ;
  1033                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1034                                  ;			problems with breaking out of INT 24h
  1035                                  ;
  1036                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1037                                  ;
  1038                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1039                                  ;			before the "string".  EX: COMMAND /CDIR
  1040                                  ;
  1041                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1042                                  ;			DBCS switch.
  1043                                  ;
  1044                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1045                                  ;			the time.
  1046                                  ;
  1047                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1048                                  ;			messages to be disk based.  Only keep them if /MSG
  1049                                  ;			is used.
  1050                                  ;
  1051                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1052                                  ;			out of internal commands, due to substitution blocks
  1053                                  ;			not being reset.
  1054                                  ;
  1055                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1056                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1057                                  ;			secondary copy of environment.	Change default slash in
  1058                                  ;			default comspec string to backslash.
  1059                                  ;
  1060                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1061                                  ;			text for critical error messages.
  1062                                  ;
  1063                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1064                                  ;	5/20/88 	with Microsoft product already shipped.
  1065                                  ;
  1066                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1067                                  ;	 5/20/88	with Microsoft product already shipped.
  1068                                  ;
  1069                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1070                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1071                                  ;			header and space remaining.
  1072                                  ;
  1073                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1074                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1075                                  ;			environment was putting a "Z block" marker in the old
  1076                                  ;			environment.  The fix is to move to the old environment
  1077                                  ;			to the new environment before doing the SETBLOCK.
  1078                                  ;
  1079                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1080                                  ;        09/19/88       because the check for APPEND needed to be performed
  1081                                  ;                       before the DIR's findfirst.
  1082                                  ;
  1083                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1084                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1085                                  ;                       loading trans w/new comspec with no user change comspec.
  1086                                  ;
  1087                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1088                                  ;        11/05/88       Expansion of environment variables into batch line of
  1089                                  ;                       128 chars was not being counted and "%" which should be
  1090                                  ;                       ignored were being counted.
  1091                                  ;
  1092                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1093                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1094                                  ;                       ing included in checksum and was being overwritten by
  1095                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1096                                  ;                       Also removed fix A069 (because flag now protected).
  1097                                  ;
  1098                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1099                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1100                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1101                                  ;
  1102                                  ;***********************************************************************************
  1103                                  
  1104                                  ;
  1105                                  ;	Revision History
  1106                                  ;	================
  1107                                  ;
  1108                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1109                                  ;					at init time (date/time prompt)
  1110                                  ;
  1111                                  
  1112                                  ;
  1113                                  ;.xcref
  1114                                  ;.xlist
  1115                                  ;	include dossym.inc		; basic DOS symbol set
  1116                                  ;	include syscall.inc		; DOS function names
  1117                                  ;	include comsw.asm		; build version info
  1118                                  ;	include comequ.asm		; common command.com symbols
  1119                                  ;	include resmsg.equ		; resident message names
  1120                                  ;
  1121                                  ;	include comseg.asm		;segment ordering
  1122                                  ;.list
  1123                                  ;.cref
  1124                                  
  1125                                  ;CODERES segment public byte
  1126                                  ;CODERES ends
  1127                                  ;
  1128                                  ;DATARES 	segment public byte
  1129                                  ;		extrn	AccDen:byte
  1130                                  ;		extrn	Batch:word
  1131                                  ;		extrn	EchoFlag:byte
  1132                                  ;		extrn	ExeBad:byte
  1133                                  ;		extrn	ExecEMes:byte
  1134                                  ;		extrn	ExecErrSubst:byte
  1135                                  ;		extrn	ExtCom:byte
  1136                                  ;		extrn	ForFlag:byte
  1137                                  ;		extrn	IfFlag:byte
  1138                                  ;		extrn	InitFlag:BYTE
  1139                                  ;		extrn	Nest:word
  1140                                  ;		extrn	PipeFlag:byte
  1141                                  ;		extrn	RBadNam:byte
  1142                                  ;		extrn	RetCode:word
  1143                                  ;		extrn	SingleCom:word
  1144                                  ;		extrn	TooBig:byte
  1145                                  ;
  1146                                  ;		extrn	OldDS:word
  1147                                  ;
  1148                                  ;DATARES 	ends
  1149                                  ;
  1150                                  ;
  1151                                  ;INIT		segment public para
  1152                                  ;		extrn	ConProc:near
  1153                                  ;		extrn	Init_Contc_SpecialCase:near
  1154                                  ;INIT		ends
  1155                                  
  1156                                  ; ----------------------------------------------------------------------------
  1157                                  ; START OF RESIDENT PORTION
  1158                                  ; ----------------------------------------------------------------------------
  1159                                  ; SEGMENT - CODERES
  1160                                  ; ----------------------------------------------------------------------------
  1161                                  
  1162                                  	;[ORG	0]
  1163                                  
  1164                                  ;ZERO	EQU	$
  1165                                  
  1166                                  	[ORG 100H]
  1167                                  
  1168                                  	; 21/09/2018 - Retro DOS v3.0
  1169                                  StartCode:
  1170 00000000 E9CD0C                  	jmp	CONPROC
  1171                                  
  1172                                  ;***	EXEC error handling
  1173                                  ;
  1174                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  1175                                  ;	We examine the error code and select an appropriate message.
  1176                                  
  1177                                  ;	Bugbug:	optimize reg usage in following code?  Careful of DX!
  1178                                  ;	Condense the error scan?
  1179                                  ;	RBADNAM is checked by transient, no need here?
  1180                                  ;	Move below Ext_Exec.
  1181                                  
  1182                                  EXEC_ERR:
  1183 00000003 BA[CA09]                	mov     dx,ACCDEN
  1184 00000006 83F805                  	cmp     ax,ERROR_ACCESS_DENIED	; 5
  1185 00000009 741B                    	jz      short GOTEXECEMES	; access denied
  1186 0000000B BA[AF09]                	mov     dx,RBADNAM
  1187 0000000E 83F802                  	cmp     ax,ERROR_FILE_NOT_FOUND ; 2
  1188 00000011 7413                    	jz      short GOTEXECEMES	; file not found
  1189 00000013 BA[7509]                	mov     dx,TOOBIG
  1190 00000016 83F808                  	cmp     ax,ERROR_NOT_ENOUGH_MEMORY ; 8
  1191 00000019 740B                    	jz      short GOTEXECEMES
  1192 0000001B BA[6109]                	mov     dx,EXEBAD
  1193 0000001E 83F80B                  	cmp     ax,ERROR_BAD_FORMAT	; 0Bh
  1194 00000021 7403                    	jz      short GOTEXECEMES	; bad exe file
  1195                                  DEFAULT_MESSAGE:
  1196 00000023 BA[5209]                	mov     dx,EXECEMES
  1197                                  GOTEXECEMES:
  1198 00000026 0E                      	push    cs
  1199 00000027 1F                      	pop     ds
  1200 00000028 E85906                  	call    RDISPMSG
  1201 0000002B EB0C                    	jmp     short NOEXEC
  1202                                  
  1203                                  ;***	EXEC call
  1204                                  ;
  1205                                  ;	The transient has set up everything for an EXEC system call.
  1206                                  ;	For cleanliness, we issue the EXEC here in the resident 
  1207                                  ;	so that we may be able to recover cleanly upon success.
  1208                                  ;
  1209                                  ;	CS,DS,ES,SS = DATARES seg addr
  1210                                  
  1211                                  EXT_EXEC:
  1212                                  ;SR;
  1213                                  ; The words put on the stack by the stub will be popped off when we finally
  1214                                  ;jump to LodCom (by LodCom).
  1215                                  ;
  1216 0000002D CD21                    	int	21h			; do the exec
  1217                                  EXEC_RET:
  1218 0000002F 72D2                    	jc	short EXEC_ERR		; exec failed
  1219                                  
  1220                                  ;	The exec has completed. Retrieve the exit code.
  1221                                  
  1222                                  EXEC_WAIT:
  1223 00000031 B44D                    	mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  1224 00000033 CD21                    	int	21h			; get the return code
  1225 00000035 2EA3[D40A]              	mov     [cs:RETCODE],ax
  1226                                  
  1227                                  ;	See if we can reload the transient. The external command
  1228                                  ;	may have overwritten part of the transient.
  1229                                  
  1230                                  NOEXEC:
  1231                                  ;SR;
  1232                                  ; ds = es = ss = DATARES when we jump to LodCom
  1233                                  ;
  1234 00000039 E97101                  	jmp	LODCOM
  1235                                  
  1236                                  ;***	Int 23 (ctrl-c) handler
  1237                                  ;
  1238                                  ;	This is the default system INT 23 handler.  All processes
  1239                                  ;	(including COMMAND) get it by default.  There are some
  1240                                  ;	games that are played:  We ignore ^C during most of the
  1241                                  ;	INIT code.  This is because we may perform an ALLOC and
  1242                                  ;	diddle the header!  Also, if we are prompting for date/time
  1243                                  ;	in the init code, we are to treat ^C as empty responses.
  1244                                  
  1245                                  ;	Bugbug:	put init ctrl-c handling in init module.
  1246                                  
  1247                                  ;SR;
  1248                                  ; The stub has pushed the previous ds and DATARES onto the stack. We get
  1249                                  ;both these values off the stack now
  1250                                  ;
  1251                                  ;ContC	proc	far
  1252                                  
  1253                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  1254                                  
  1255                                  CONTC:
  1256                                  
  1257                                  ;	pop	ds			;ds = DATARES
  1258                                  ;	assume	ds:DATARES
  1259                                  ;;	pop	word [OldDS]		;OldDS = old ds
  1260                                  
  1261 0000003C 2EF606[430B]01          	test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  1262 00000042 740C                    	jz	short NOTATINIT			; no
  1263 00000044 2EF606[430B]02          	test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  1264 0000004A 7403                    	jz	short CMDIRET			; no, ignore ^C
  1265                                  	;pop	ds			; restore before jumping; M021
  1266 0000004C E97312                  	jmp	INIT_CONTC_SPECIALCASE	; Yes, go handle it
  1267                                  CMDIRET:
  1268                                  ;SR;
  1269                                  ; Restore ds to its previous value
  1270                                  ;
  1271                                  
  1272                                  ;;	mov	ds,[OLdDS]		;
  1273                                  ;	pop	ds
  1274 0000004F CF                      	iret				; yes, ignore the ^C
  1275                                  
  1276                                  NOTATINIT:
  1277 00000050 2EF606[430B]04          	test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  1278 00000056 7411                    	jz	short NOTINIT		; nope too.
  1279                                  
  1280                                  ;*	We are interrupting ourselves in this ^C handler. We need
  1281                                  ;	to set carry and return to the user sans flags only if the
  1282                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  1283                                  
  1284 00000058 80FC01                  	cmp	ah,1
  1285 0000005B 72F2                    	jb	short CMDIRET
  1286 0000005D 80FC0C                  	cmp	ah,12
  1287 00000060 77ED                    	ja	short CMDIRET
  1288                                  
  1289                                  ;	pop	ds			;restore ds to old value
  1290 00000062 83C406                  	add	sp,6			; remove int frame
  1291 00000065 F9                      	stc
  1292                                  
  1293                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  1294 00000066 CA0200                  	retf	2			; remove those flags...
  1295                                  
  1296                                  NOTINIT:
  1297                                  
  1298                                  ;*	We have now received a ^C for some process (maybe ourselves
  1299                                  ;	but not at INIT).
  1300                                  ;	
  1301                                  ;	Note that we are running on the user's stack!!! Bad news if
  1302                                  ;	any of the system calls below go and issue another INT
  1303                                  ;	24... Massive stack overflow! Another bad point is that
  1304                                  ;	SavHand will save an already saved handle, thus losing a
  1305                                  ;	possible redirection...
  1306                                  ;	
  1307                                  ;	All we need to do is set the flag to indicate nested ^C. 
  1308                                  ;	The above code will correctly flag the ^C diring the
  1309                                  ;	message output and prompting while ignoring the ^C the rest
  1310                                  ;	of the time.
  1311                                  ;	
  1312                                  ;	Clean up: flush disk. If we are in the middle of a batch
  1313                                  ;	file, we ask if he wants to terminate it. If he does, then
  1314                                  ;	we turn off all internal flags and let the DOS abort.
  1315                                  
  1316 00000069 2E800E[430B]04          	or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  1317 0000006F FB                      	sti
  1318                                  
  1319 00000070 0E                      	push	cs			; el yucko!  change the user's ds!!
  1320 00000071 1F                      	pop	ds
  1321                                  ;	assume	ds:RESGROUP
  1322                                  
  1323                                  	;pop	ax			;discard the old ds value
  1324                                  
  1325 00000072 A1[DD0A]                	mov	ax,[SINGLECOM]
  1326 00000075 09C0                    	or	ax,ax
  1327 00000077 7506                    	jnz	short NORESET
  1328 00000079 50                      	push	ax
  1329 0000007A B40D                    	mov	ah,DISK_RESET ; 0Dh
  1330 0000007C CD21                    	int	21h			; reset disks in case files were open
  1331 0000007E 58                      	pop	ax
  1332                                  
  1333                                  NORESET:
  1334                                  
  1335                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  1336                                  ;	walk the entire active list and free each segment. Here,
  1337                                  ;	we just free the single batch segment.
  1338                                  
  1339 0000007F F706[810A]FFFF          	test	word [BATCH],-1
  1340 00000085 744B                    	jz	short CONTCTERM
  1341 00000087 09C0                    	or	ax,ax
  1342 00000089 7547                    	jnz	short CONTCTERM
  1343 0000008B E85902                  	call	SAVHAND
  1344 0000008E E89E03                  	call	ASKEND			; ask if user wants to end batch
  1345                                  
  1346                                  ;	If the carry flag is clear, we do NOT free up the batch file
  1347                                  
  1348 00000091 7339                    	jnc	short CONTBATCH
  1349                                  	;mov	cl,[EchoFlag]		; get current echo flag
  1350 00000093 53                      	push	bx
  1351                                  
  1352                                  CLEARBATCH:
  1353 00000094 8E06[810A]              	mov	es,[BATCH]		; get batch segment
  1354                                  	;mov	di,[BatFile]		; get offset of batch file name
  1355                                  	; MSDOS 3.3 ([ES:4])
  1356 00000098 268B1E0400              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  1357                                  	;
  1358 0000009D 83FB00                  	cmp	bx,0			; is a FOR in progress
  1359 000000A0 7408                    	je	short NOT_BAT_FOR	; no - don't deallocate
  1360 000000A2 06                      	push	es			;
  1361 000000A3 8EC3                    	mov	es,bx			; yes - free it up...
  1362 000000A5 B449                    	mov	ah,DEALLOC ; 49h	;
  1363 000000A7 CD21                    	int	21h			;
  1364 000000A9 07                      	pop	es			; restore to batch segment
  1365                                  
  1366                                  NOT_BAT_FOR:
  1367 000000AA 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  1368 000000AF 268B1E0200              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  1369 000000B4 B449                    	mov	ah,DEALLOC ; 49h	; free it up...
  1370 000000B6 CD21                    	int	21h
  1371 000000B8 891E[810A]              	mov	[BATCH],bx		; get ready to deallocate next batch
  1372 000000BC FF0E[E60A]              	dec	WORD [NEST]		; is there another batch file?
  1373 000000C0 75D2                    	jnz	short CLEARBATCH	; keep going until no batch file
  1374                                  
  1375                                  ;	We are terminating a batch file; restore the echo status
  1376                                  
  1377                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  1378 000000C2 5B                      	pop	bx
  1379 000000C3 880E[D70A]              	mov	[ECHOFLAG],cl		; reset echo status
  1380                                  	; 29/05/2018
  1381 000000C7 C606[440B]00            	mov	byte [PIPEFLAG],0	; turn off pipeflag
  1382                                  
  1383                                  CONTBATCH:
  1384 000000CC E8B205                  	call	CRLF			; print out crlf before returning
  1385 000000CF E83A02                  	call	RESTHAND
  1386                                  
  1387                                  ;	Yes, we are terminating.  Turn off flags and allow the DOS to abort.
  1388                                  
  1389                                  CONTCTERM:
  1390 000000D2 31C0                    	xor	ax,ax			; indicate no read
  1391 000000D4 89C5                    	mov	bp,ax
  1392                                  
  1393                                  ;	The following resetting of the state flags is good for the
  1394                                  ;	generalized batch processing.
  1395                                  
  1396 000000D6 A2[E20A]                	mov	[IFFLAG],al		; turn off iffing
  1397 000000D9 A2[E30A]                	mov	[FORFLAG],al		; turn off for processing
  1398 000000DC E81C00                  	call	RESPIPEOFF
  1399 000000DF 3906[DD0A]              	cmp	[SINGLECOM],ax		; see if we need to set singlecom
  1400 000000E3 7406                    	jz	short NOSETSING
  1401 000000E5 C706[DD0A]FFFF          	mov	word [SINGLECOM],-1	; cause termination on 
  1402                                  					;  pipe, batch, for
  1403                                  NOSETSING:
  1404                                  
  1405                                  ;	If we are doing an internal command, go through the reload process.
  1406                                  ;	If we are doing an external, let DOS abort the process.
  1407                                  ;	In both cases, we are now done with the ^C processing.
  1408                                  
  1409 000000EB 8026[430B]FB            	and	byte [INITFLAG],~INITCTRLC ; 0FBh
  1410 000000F0 3806[D30A]              	cmp	[EXTCOM],al
  1411 000000F4 7503                    	jnz	short DODAB		; internal ^c
  1412 000000F6 E92001                  	jmp	LODCOM1
  1413                                  DODAB:
  1414 000000F9 F9                      	stc				; tell dos to abort
  1415                                  
  1416                                  ;SR;
  1417                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  1418                                  ;by setting carry and leaving flags on the stack
  1419                                  ;
  1420 000000FA CB                      	retf				; Leave flags on stack
  1421                                  
  1422                                  ;ContC	endp
  1423                                  
  1424                                  ;SR;
  1425                                  ; ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  1426                                  ;both have ds = DATARES
  1427                                  ;
  1428                                  
  1429                                  RESPIPEOFF:
  1430 000000FB 50                      	push	ax
  1431 000000FC 31C0                    	xor	ax,ax
  1432 000000FE 2E8606[440B]            	xchg	al,[cs:PIPEFLAG]
  1433 00000103 08C0                    	or	al,al
  1434 00000105 7405                    	jz	short NOPIPEPOP
  1435 00000107 2ED02E[D70A]            	shr	byte [cs:ECHOFLAG],1
  1436                                  NOPIPEPOP:
  1437 0000010C 58                      	pop	ax
  1438 0000010D C3                      	retn
  1439                                  
  1440                                  ;CODERES ends
  1441                                  
  1442                                  ;=============================================================================
  1443                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  1444                                  ;=============================================================================
  1445                                  ; 21/09/2018 - Retro DOS v3.0
  1446                                  
  1447                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  1448                                  ;	name	COMMAND2
  1449                                  
  1450                                  ;/*
  1451                                  ; *                      Microsoft Confidential
  1452                                  ; *                      Copyright (C) Microsoft Corporation 1991
  1453                                  ; *                      All Rights Reserved.
  1454                                  ; */
  1455                                  
  1456                                  ;
  1457                                  ;	Revision History
  1458                                  ;	================
  1459                                  ;
  1460                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  1461                                  ;			reserve memory by changing int 12h and then give it
  1462                                  ;			back to DOS by changing arenas in autoexec.bat.
  1463                                  ;			This makes command.com reload transient and this
  1464                                  ;			cannot be done at this stage.
  1465                                  ;
  1466                                  
  1467                                  ;CODERES segment public byte
  1468                                  
  1469                                  ;*	If we cannot allocate enough memory for the transient or there
  1470                                  ;	was some other allocation error, we display a message and
  1471                                  ;	then die.
  1472                                  
  1473                                  ;SR;
  1474                                  ; We will have to make sure that at this entry point and at FatalC, 
  1475                                  ;ds = DATARES. All jumps to these points are made from only within this file
  1476                                  ;and so we should be able to do this
  1477                                  
  1478                                  	;assume	ds:DATARES
  1479                                  BADMEMERR:
  1480 0000010E BA[DA09]                	mov	dx,BMEMMES			; DX = ptr to msg
  1481                                  FATALC:
  1482 00000111 0E                      	push	cs
  1483 00000112 1F                      	pop	ds
  1484                                  ;;	assume	ds:ResGroup
  1485                                  ;	invoke	RPrint
  1486                                  
  1487                                  	; MSDOS 3.3
  1488 00000113 E86E05                  	call	RDISPMSG
  1489                                  
  1490                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  1491                                  ;	we can't do anything else!
  1492                                  
  1493 00000116 803E[DC0A]00            	cmp	byte [PERMCOM],0
  1494 0000011B 7410                    	je	short FATALRET
  1495                                  
  1496                                  ;	We are a permanent command. If we are in the process of the
  1497                                  ;	magic interrupt (Singlecom) then exit too.
  1498                                  
  1499 0000011D 833E[DD0A]00            	cmp	word [SINGLECOM],0		; if permcom and singlecom
  1500 00000122 7509                    	jne	short FATALRET			; must take int_2e exit
  1501                                  
  1502                                  ;	Permanent command. We can't do ANYthing except halt.
  1503                                  
  1504 00000124 BA[F509]                	mov	dx,HALTMES			; DX = ptr to msg
  1505                                  	;invoke	RPrint
  1506                                  	; MSDOS 3.3
  1507 00000127 E85A05                  	call	RDISPMSG
  1508 0000012A FB                      	sti
  1509                                  STALL:
  1510 0000012B EBFE                    	jmp	short STALL			; crash the system nicely
  1511                                  
  1512                                  FATALRET:
  1513 0000012D BA[1A0A]                	mov	dx,FRETMES			; DX = ptr to msg
  1514 00000130 E85105                  	call	RDISPMSG
  1515                                  FATALRET2:
  1516 00000133 803E[DC0A]00            	cmp	byte [PERMCOM],0		; if we get here and permcom,
  1517 00000138 7517                    	jne	SHORT RET_2E			; must be int_2e
  1518                                  
  1519                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  1520                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  1521                                  ;	case we decide to do that.)
  1522 0000013A A1[760A]                	mov	ax,[PARENT]
  1523 0000013D A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  1524 00000140 A1[780A]                	mov	ax,[OLDTERM]
  1525 00000143 A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  1526 00000146 A1[7A0A]                	mov	ax,[OLDTERM+2]
  1527 00000149 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  1528 0000014C B8004C                  	mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  1529 0000014F CD21                    	int	21h
  1530                                  RET_2E:
  1531                                  ;SR;
  1532                                  ; We will ensure that ds = DATARES for all entries to this place
  1533                                  ;
  1534                                  
  1535                                  ;;	push	cs
  1536                                  ;;	pop	ds
  1537                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  1538                                    	
  1539                                  ;	assume	ds:DATARES
  1540                                  
  1541                                  	;PUSH	CS
  1542                                  	;POP	DS
  1543                                  
  1544 00000151 C706[DD0A]0000          	mov	word [SINGLECOM],0	; turn off singlecom
  1545 00000157 8E06[0D0C]              	mov	es,[RES_TPA]
  1546 0000015B B449                    	mov	ah,DEALLOC
  1547 0000015D CD21                    	int	21h			; free up space used by transient
  1548 0000015F 8B1E[740A]              	mov	bx,[SAVE_PDB]
  1549 00000163 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  1550 00000165 CD21                    	int	21h			; current process is user
  1551 00000167 A1[D40A]                	mov	ax,[RETCODE]
  1552 0000016A 803E[D30A]00            	cmp	byte [EXTCOM],0
  1553 0000016F 7502                    	jne	short GOTECODE
  1554 00000171 31C0                    	xor	ax,ax			; internals always return 0
  1555                                  GOTECODE:
  1556 00000173 C606[D30A]01            	mov	byte [EXTCOM],1		; force external
  1557                                  
  1558                                  ;SR; This is actually returning to the caller. However, the old code had
  1559                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  1560                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  1561                                  ;
  1562                                  	;jmp	INT_2E_RET		;"iret"
  1563                                  	; 12/01/2023 (BugFix)
  1564 00000178 FF2E[700A]              	jmp	far [INT_2E_RET]
  1565                                  
  1566                                  ;***	Int_2e, magic command executer
  1567                                  
  1568                                  INT_2E:
  1569                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  1570                                  ;SR;
  1571                                  ; We are going to come here from the stub with the old ds and DATARES value
  1572                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  1573                                  ;
  1574                                  	;pop	ds			;ds = DATARES
  1575                                  	;assume	ds:DATARES
  1576                                  	;pop	ax
  1577                                  ;	;pop	ds:OldDS 		;Save old value of ds
  1578                                  
  1579 0000017C 2E8F06[700A]            	pop	word [cs:INT_2E_RET]
  1580 00000181 2E8F06[720A]            	pop	word [cs:INT_2E_RET+2]	; store return address
  1581 00000186 58                      	pop	ax			; chuck flags
  1582                                  	;add	sp,2
  1583                                  
  1584 00000187 0E                      	push	cs
  1585 00000188 07                      	pop	es
  1586                                  
  1587                                  	;push	ds
  1588                                  	;pop	es			;es = DATARES
  1589                                  ;	;mov	ds,OldDS
  1590                                  	;mov	ds,ax
  1591                                  	;assume	ds:nothing		;ds = old value
  1592                                  
  1593 00000189 BF8000                  	mov	di,80h
  1594 0000018C B94000                  	mov	cx,64
  1595                                  ;	Bugbug:	cld
  1596 0000018F F3A5                    	rep	movsw
  1597 00000191 B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1598 00000193 CD21                    	int	21h			; get user's header
  1599                                  	;mov	[es:SAVE_PDB],bx
  1600 00000195 2E891E[740A]            	MOV	[cs:SAVE_PDB],bx
  1601 0000019A B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  1602                                  
  1603                                  ;;	mov	bx,cs
  1604                                  ;SR;
  1605                                  ; Set ds = DATARES because BadMemErr expects this
  1606                                  ;
  1607                                  	;push	es
  1608                                  	;pop	ds
  1609                                  	;assume	ds:DATARES
  1610                                  
  1611                                  	;mov	bx,ds			;es = our PSP now
  1612 0000019C 8CCB                    	mov	bx,cs
  1613                                  
  1614 0000019E CD21                    	int	21h			; current process is me
  1615 000001A0 2EC706[DD0A]8100        	mov	word [cs:SINGLECOM],81h
  1616 000001A7 2EC606[D30A]01          	mov	byte [cs:EXTCOM],1	; make sure this case forced
  1617                                  
  1618                                  ;SR;
  1619                                  ; We can enter LodCom directly after a command shell is terminated or we
  1620                                  ;can fall thru from above. When we enter directly from the stub, the stack
  1621                                  ;has the old ds value and the data seg value on the stack, so that ds can
  1622                                  ;be properly set. To fake this, we push dummy values here.
  1623                                  ;
  1624                                  	;push	ds			;old value of ds
  1625                                  	;push	ds			;data seg value, ds = DATARES
  1626                                  
  1627                                  LODCOM: 				; termination handler
  1628                                  	;pop	ds			;ds = DATARES 
  1629                                  	;assume	ds:DATARES
  1630                                  	;add	sp,2
  1631                                  ;	;pop	OldDS			;store old ds
  1632                                  
  1633                                  	;cmp	EXTCOM,0
  1634 000001AD 2E803E[D30A]00          	cmp	byte [cs:EXTCOM],0
  1635                                  	;jne	@f	 		; internal cmd - memory allocated
  1636                                  	;jne	short LODCOM0 ; 24/09/2018
  1637                                  	;jmp	LODCOM1 		; jz LODCOM1
  1638 000001B3 7464                    	je	short LODCOM1 ; 25/09/2018	
  1639                                  
  1640                                  ;@@:
  1641                                  LODCOM0: ; 24/09/2018
  1642 000001B5 BBFFFF                  	mov	bx,0FFFFh
  1643 000001B8 B448                    	mov	ah,ALLOC ; 48h	
  1644 000001BA CD21                    	int	21h			; DOS - 2+ - ALLOCATE MEMORY
  1645                                  					; BX = number of 16-byte paragraphs desired
  1646 000001BC E80A00                  	call	SETSIZE
  1647 000001BF 83C020                  	add	ax,20h
  1648 000001C2 39C3                    	cmp	bx,ax
  1649 000001C4 730B                    	jnb	short MEMOK		; > 512 byte buffer - good enough
  1650                                  BADMEMERRJ:
  1651 000001C6 E945FF                  	jmp	BADMEMERR		; not enough memory
  1652                                  
  1653                                  ;***	SetSize - get transient size in paragraphs
  1654                                  
  1655                                  SETSIZE:
  1656 000001C9 B8414C                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh
  1657 000001CC B104                    	mov	cl,4
  1658 000001CE D3E8                    	shr	ax,cl
  1659 000001D0 C3                      	retn
  1660                                  
  1661                                  MEMOK:
  1662                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  1663                                  
  1664 000001D1 B448                    	mov	ah,ALLOC  ; 48h
  1665 000001D3 CD21                    	int	21h
  1666 000001D5 72EF                    	jc	short BADMEMERRJ	; memory arenas probably trashed
  1667 000001D7 2EC606[D30A]00          	mov	byte [cs:EXTCOM],0	; flag not to alloc again
  1668 000001DD 2EA3[0D0C]              	mov	[cs:RES_TPA],ax		; save current tpa segment
  1669 000001E1 2500F0                  	and	ax,0F000h
  1670 000001E4 050010                  	add	ax,01000h		; round up to next 64k boundary
  1671 000001E7 7213                    	jc	short BAD_TPA		; memory wrap if carry set
  1672                                  
  1673                                  ;	Make sure that new boundary is within allocated range
  1674                                  
  1675 000001E9 2E8B16[0D0C]            	mov	dx,[cs:RES_TPA]
  1676 000001EE 01DA                    	add	dx,bx			; compute maximum address
  1677 000001F0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  1678 000001F2 7608                    	jbe	short BAD_TPA
  1679                                  
  1680                                  ;	Must have 64K of usable space.
  1681                                  
  1682 000001F4 29C2                    	sub	dx,ax			; compute the usable space
  1683 000001F6 81FA0010                	cmp	dx,01000h		; is space >= 64k ?
  1684 000001FA 7304                    	jae	short LTPASET
  1685                                  BAD_TPA:
  1686 000001FC 2EA1[0D0C]              	mov	ax,[cs:RES_TPA]
  1687                                  LTPASET:
  1688 00000200 2EA3[FF0B]              	mov	[cs:LTPA],ax		; usable tpa is 64k buffer aligned
  1689 00000204 2EA1[0D0C]              	mov	ax,[cs:RES_TPA]		; actual tpa is buffer allocated
  1690 00000208 01C3                    	add	bx,ax
  1691 0000020A 2E891E[CF0A]            	mov	[cs:MEMSIZ],bx
  1692 0000020F E8B7FF                  	call	SETSIZE
  1693 00000212 29C3                    	sub	bx,ax
  1694                                  
  1695                                  	; MSDOS 6.0
  1696                                  ;;
  1697                                  ;;M038; Start of changes
  1698                                  ;; Changes for Novell RPL. These guys reserve memory for themselves by
  1699                                  ;;reducing int 12h size and add this memory to the system at autoexec time by
  1700                                  ;;running a program that changes arenas. This changes the largest block that
  1701                                  ;;command.com gets and so changes the transient segment. So, command.com does
  1702                                  ;;a checksum at the wrong address and thinks that the transient is destroyed
  1703                                  ;;and tries to reload it. At this point, no Comspec is defined and so the
  1704                                  ;;reload fails, hanging the system. To get around this we just copy the
  1705                                  ;;transient from the previous address to the new address(if changed) and
  1706                                  ;;then let command.com do the checksum. So, if the transient area is not
  1707                                  ;;corrupted, there will not be any reload. In Novell's case, the transient
  1708                                  ;;is not really corrupted and so this should work.
  1709                                  ;;
  1710                                  ;	cmp	bx,[cs:TRNSEG]		;Segment still the same?
  1711                                  ;	je	short LODCOM1		;yes, dont copy
  1712                                  ;;
  1713                                  ;;Check if the new segment is above or below the current move. If the new
  1714                                  ;;segment is above (i.e new block is larger than previous block), then we
  1715                                  ;;have to move in the reverse direction
  1716                                  ;;
  1717                                  ;	mov	cx,TRANSPACEEND		;cx = length to move
  1718                                  ;	ja	short _MOV_DOWN		;new seg > old seg, reverse move
  1719                                  ;	xor	si,si			;normal move
  1720                                  ;	mov	di,si
  1721                                  ;	cld
  1722                                  ;	jmp	short COPY_TRANS
  1723                                  ;_MOV_DOWN:
  1724                                  ;	mov	si,cx			;reverse move, start from end
  1725                                  ;	dec	si
  1726                                  ;	mov	di,si
  1727                                  ;	std
  1728                                  ;COPY_TRANS:
  1729                                  ;	push	ds
  1730                                  ;	push	es
  1731                                  ;	mov	es,bx			;dest segment
  1732                                  ;	mov	ds,[cs:TRNSEG]		;source segment
  1733                                  ;	;assume	ds:nothing
  1734                                  ;
  1735                                  ;	rep	movsb			;copy transient
  1736                                  ;	cld
  1737                                  ;	pop	es
  1738                                  ;	pop	ds
  1739                                  ;	;assume	ds:DATARES
  1740                                  ;;
  1741                                  ;;M038; End of changes
  1742                                  ;;
  1743 00000214 2E891E[C90A]            	mov	[cs:TRNSEG],bx		;new location of transient
  1744                                  
  1745                                  LODCOM1:
  1746                                  ;;	mov	ax,cs
  1747                                  ;;	mov	ss,ax
  1748                                  ;SR; At this point ds = DATARES which is where the stack is located
  1749                                  ;
  1750                                  	;mov	ax,ds
  1751                                  	;mov	ss,ax
  1752                                  	;assume	ss:DATARES
  1753                                  	;mov	sp,offset DATARES:RStack
  1754                                  
  1755                                  ;;	mov	ds,ax
  1756                                  
  1757                                  	;assume	ds:DATARES
  1758                                  	
  1759                                  	; MSDOS 3.3
  1760 00000219 8CC8                    	mov	ax,cs
  1761 0000021B 8ED0                    	mov	ss,ax
  1762 0000021D BC[2C07]                	mov	sp,RSTACK
  1763 00000220 8ED8                    	mov	ds,ax
  1764                                  
  1765 00000222 E88E00                  	call	HEADFIX			; close files, restore stdin, stdout
  1766 00000225 31ED                    	xor	bp,bp			; flag command ok
  1767 00000227 B8FFFF                  	mov	ax,-1
  1768 0000022A 8706[DF0A]              	xchg	ax,[VERVAL]
  1769 0000022E 83F8FF                  	cmp	ax,-1
  1770 00000231 7404                    	je	short NOSETVER
  1771 00000233 B42E                    	mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  1772 00000235 CD21                    	int	21h 			; DOS - SET VERIFY FLAG
  1773                                  					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  1774                                  NOSETVER:
  1775 00000237 833E[DD0A]FF            	cmp	word [SINGLECOM],-1
  1776 0000023C 7503                    	jne	short NOSNG
  1777 0000023E E9F2FE                  	jmp	FATALRET2		; we have finished the single command
  1778                                  NOSNG:
  1779 00000241 E87E01                  	call	CHKSUM			; check the transient
  1780 00000244 3B16[D10A]              	cmp	dx,[SUM]
  1781 00000248 7416                    	je	short HAVCOM		; transient ok
  1782                                  BOGUS_COM:
  1783 0000024A C606[800A]01            	mov	byte [LOADING],1	; flag DskErr routine
  1784 0000024F E82101                  	call	LOADCOM
  1785                                  CHKSAME:
  1786 00000252 E86D01                  	call	CHKSUM
  1787 00000255 3B16[D10A]              	cmp	dx,[SUM]
  1788 00000259 7405                    	jz	short HAVCOM		; same command
  1789                                  ALSO_BOGUS:
  1790 0000025B E85C01                  	call	WRONGCOM
  1791 0000025E EBF2                    	jmp	short CHKSAME
  1792                                  
  1793                                  HAVCOM:
  1794                                  	; 25/09/2018
  1795 00000260 B80037                  	mov     ax,(CHAR_OPER*256) ; 3700h
  1796 00000263 CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  1797                                  			; Return: AL = FFh unsupported subfunction
  1798                                  			; DL = current switch character
  1799 00000265 8816[010C]              	mov     [RSWITCHAR],dl
  1800 00000269 80FA2F                  	cmp     dl,'/'
  1801 0000026C 7505                    	jnz     short USESLASH
  1802                                  	;mov	cl,'\'
  1803                                  	;mov	[RDIRCHAR],cl
  1804 0000026E C606[020C]5C            	mov	byte [RDIRCHAR],'\'
  1805                                  USESLASH:
  1806 00000273 C606[800A]00            	mov	byte [LOADING],0		; flag to DskErr
  1807 00000278 BE[FB0B]                	mov	si,TRANVARS
  1808 0000027B BF6441                  	mov	di,HEADCALL
  1809 0000027E 8E06[C90A]              	mov	es,[TRNSEG]
  1810 00000282 FC                      	cld
  1811 00000283 B9[0F0C]                	mov	cx,TRANVAREND
  1812 00000286 29F1                    	sub	cx,si
  1813 00000288 F3A4                    	rep	movsb			; transfer info to transient
  1814 0000028A A1[CF0A]                	mov	ax,[MEMSIZ]
  1815 0000028D A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  1816                                  
  1817                                  ;***	TJmp - jump-off to transient
  1818                                  ;
  1819                                  ;	Public label so debugger can find this spot.
  1820                                  
  1821                                  TJMP:
  1822 00000290 FF2E[C70A]              	jmp	far [TRANS]
  1823                                  
  1824                                  ;***	TRemCheck - far version of RemCheck for transient
  1825                                  
  1826                                  TREMCHECK:
  1827                                  	;pop	ds			;ds = DATARES
  1828                                  	;add	sp,2			;discard old value of ds
  1829                                  
  1830 00000294 E80100                  	call	REMCHECK
  1831 00000297 CB                      	retf
  1832                                  
  1833                                  ;***	RemCheck
  1834                                  ;
  1835                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  1836                                  ;
  1837                                  ;	EXIT	ZR set if removeable media
  1838                                  ;		ZR clear if fixed media
  1839                                  ;
  1840                                  ;	USED	none
  1841                                  
  1842                                  REMCHECK:
  1843 00000298 50                      	push	ax
  1844 00000299 53                      	push	bx
  1845 0000029A 89C3                    	mov	bx,ax
  1846 0000029C B80844                  	mov	ax,(IOCTL<<8)+8 ; 4408h
  1847 0000029F CD21                    	int	21h			; DOS - 2+ - IOCTL -
  1848 000002A1 7304                    	jnc	short RCCONT			
  1849                                  
  1850                                  ;	If an error occurred, assume the media is non-removable.
  1851                                  ;	AX contains the non-zero error code from the int 21, so
  1852                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  1853                                  ;	appear to be non-removable.				
  1854                                  					
  1855 000002A3 09C0                    	or	ax,ax			
  1856 000002A5 EB05                    	jmp	short RESREGS
  1857                                  RCCONT:
  1858 000002A7 83E001                  	and	ax,1
  1859 000002AA F7D0                    	not	ax
  1860                                  RESREGS:
  1861 000002AC 5B                      	pop	bx
  1862 000002AD 58                      	pop	ax
  1863 000002AE C3                      	retn
  1864                                  
  1865                                  ;***	THeadFix
  1866                                  ;
  1867                                  ;	Far version of HeadFix, called from transient.
  1868                                  
  1869                                  THEADFIX:
  1870                                  	;pop	ds			;ds = DATARES
  1871                                  	;add	sp,2			;discard old ds value on stack
  1872                                  
  1873 000002AF E80100                  	call	HEADFIX
  1874 000002B2 CB                      	retf
  1875                                  
  1876                                  ;***	HeadFix
  1877                                  
  1878                                  HEADFIX:
  1879 000002B3 E82601                  	call	SETVECT			; set vectors to our values
  1880                                  
  1881                                  ;	Clean up header
  1882                                  
  1883                                  ;	Bugbug:	optimize:
  1884                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  1885                                  
  1886 000002B6 31DB                    	xor	bx,bx				; BX = handle = 0
  1887 000002B8 8B0E[D90A]              	mov	cx,[IO_SAVE]			; CX = original stdin, stdout
  1888 000002BC 8B161800                	mov	dx,[PDB.JFN_TABLE] ; mov dx,[ds:18h] ; DX = current stdin, stdout
  1889 000002C0 38D1                    	cmp	cl,dl
  1890 000002C2 7408                    	je	short CHK1		; stdin matches
  1891 000002C4 B43E                    	mov	ah,CLOSE  ; 3Eh
  1892 000002C6 CD21                    	int	21h			; close stdin
  1893 000002C8 880E1800                	mov	[PDB.JFN_TABLE],cl ; mov [ds:18h],cl ; restore stdin
  1894                                  CHK1:
  1895 000002CC 43                      	inc	bx			; BX = handle = 1
  1896 000002CD 38F5                    	cmp	ch,dh			
  1897 000002CF 7408                    	je	short CHKOTHERHAND	; stdout matches
  1898 000002D1 B43E                    	mov	ah,CLOSE
  1899 000002D3 CD21                    	int	21h			; close stdout
  1900 000002D5 882E1900                	mov	[PDB.JFN_TABLE+1],ch ; mov [ds:19h],ch	; restore stdout
  1901                                  
  1902                                  CHKOTHERHAND:
  1903 000002D9 83C304                  	add	bx,4			; skip handles 2,3,4
  1904 000002DC B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  1905                                  					;   (handles 0-4 already done)
  1906                                  CLOSELOOP:
  1907 000002DF B43E                    	mov	ah,CLOSE ; 3Eh
  1908 000002E1 CD21                    	int	21h			; close each handle
  1909 000002E3 43                      	inc	bx			; BX = next handle
  1910 000002E4 E2F9                    	loop	CLOSELOOP
  1911                                  
  1912                                  	; MSDOS 6.0
  1913                                  ;;	Bugbug:	since this is for transient code, move it there
  1914                                  ;
  1915                                  ;;	M012: remove this CS -> DS.  Must've been missed during
  1916                                  ;;	purification.
  1917                                  ;;;	push	ds			; save data segment
  1918                                  ;;;	push	cs			; get local segment into DS
  1919                                  ;;;	pop	ds			;
  1920                                  ;	cmp	Append_Flag,-1		; do we need to reset APPEND?
  1921                                  ;	jne	Append_Fix_End		; no - just exit
  1922                                  ;	mov	ax,AppendSetState	; set the state of Append
  1923                                  ;	mov	bx,Append_State 	;     back to the original state
  1924                                  ;	int	2Fh			;
  1925                                  ;	mov	Append_Flag,0		; set append flag to invalid
  1926                                  ;Append_Fix_End: 			;
  1927                                  ;;;	pop	ds			; get data segment back
  1928                                  ;	retn
  1929                                  
  1930                                  	; MSDOS 3.3
  1931 000002E6 C3                      	retn
  1932                                  
  1933                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  1934                                  ;
  1935                                  ;	ENTRY	nothing
  1936                                  ;
  1937                                  ;	EXIT	nothing
  1938                                  ;
  1939                                  ;	USED	flags
  1940                                  ;
  1941                                  ;	EFFECTS
  1942                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  1943                                  ;	  current program's stdin,stdout set to our stderr
  1944                                  ;
  1945                                  
  1946                                  ;SR;
  1947                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  1948                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  1949                                  ;
  1950                                  SAVHAND:
  1951                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  1952                                  
  1953 000002E7 1E                      	push	ds ; MSDOS 3.3
  1954 000002E8 53                      	push	bx			;preserve registers
  1955 000002E9 50                      	push	ax
  1956                                  	;push	es
  1957                                  	;push	ds			; save DATARES value
  1958                                  
  1959 000002EA B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1960 000002EC CD21                    	int	21h			; BX = user's header seg addr
  1961 000002EE 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  1962 000002F0 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h]	; DS:BX = ptr to JFN table
  1963 000002F4 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  1964                                  
  1965                                  	;pop	es			;es = DATARES
  1966                                  	;push	es			;save it back on stack
  1967                                  	;mov	es:Handle01,ax		; save user's stdin, stdout
  1968 000002F6 2EA3[7E0A]              	mov	[cs:HANDLE01],ax
  1969                                  
  1970                                  ;SR;
  1971                                  ; Use es to address Handle01 & our JFN_Table
  1972                                  ;
  1973                                  
  1974                                  	;mov	al,es:[PDB_JFN_TABLE+2] ; AL = COMMAND stderr
  1975 000002FA 2EA01A00                	mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  1976 000002FE 88C4                    	mov	ah,al			; AH = COMMAND stderr
  1977 00000300 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  1978                                  
  1979                                  	;pop	ds			; restore registers
  1980                                  	;pop	es
  1981 00000302 58                      	pop	ax
  1982 00000303 5B                      	pop	bx
  1983 00000304 1F                      	pop	ds ; MSDOS 3.3
  1984 00000305 C3                      	retn
  1985                                  
  1986                                  	;assume	ds:DATARES
  1987                                  GETCOMDSK2:
  1988 00000306 E81F00                  	call	GETCOMDSK
  1989 00000309 E90DFF                  	jmp	LODCOM1			; memory already allocated
  1990                                  
  1991                                  RESTHAND:
  1992 0000030C 1E                      	push	ds
  1993 0000030D 53                      	push	bx			; restore stdin, stdout to user
  1994 0000030E 50                      	push	ax
  1995 0000030F B451                    	mov	ah,GET_CURRENT_PDB ; 51h
  1996 00000311 CD21                    	int	21h			; point to user's header
  1997 00000313 A1[7E0A]                	mov	ax,[HANDLE01]
  1998 00000316 8EDB                    	mov	ds,bx
  1999                                  	;assume ds:NOTHING
  2000 00000318 C51E3400                	lds	bx,[PDB.JFN_Pointer] ; lds bx,[ds:34h] ; DS:BX = ptr to jfn table
  2001 0000031C 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  2002 0000031E 58                      	pop	ax
  2003 0000031F 5B                      	pop	bx
  2004 00000320 1F                      	pop	ds
  2005 00000321 C3                      	retn
  2006                                  
  2007                                  	;assume ds:DATARES,ss:DATARES
  2008                                  HOPELESS:
  2009 00000322 BA[DD08]                	mov	dx,COMBAD
  2010 00000325 E9E9FD                  	jmp	FATALC
  2011                                  
  2012                                  GETCOMDSK:
  2013 00000328 A0[CE0A]                	mov	al,[COMDRV]
  2014 0000032B E86AFF                  	call	REMCHECK
  2015 0000032E 75F2                    	jnz	short HOPELESS		; non-removable media
  2016                                  GETCOMDSK3:
  2017 00000330 81FA[DD08]              	cmp	dx,COMBAD
  2018 00000334 7503                    	jne	short GETCOMDSK4
  2019                                  	;;mov	dx,offset DATARES:ComBad	; DX = ptr to msg
  2020                                  	;invoke	RPrint				; say COMMAND is invalid
  2021 00000336 E84B03                  	call	RDISPMSG
  2022                                  GETCOMDSK4:
  2023                                  ;	Bugbug:	there's always a drive here?  No need to check?
  2024 00000339 803E[1109]00            	cmp	byte [PUTBACKDRV],0	; is there a drive in the comspec?
  2025 0000033E 7509                    	jne	short USERS_DRIVE	; yes - use it
  2026 00000340 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  2027 00000342 CD21                    	int	21h
  2028 00000344 0441                    	add	al,"A"                  ; convert to ascii
  2029 00000346 A2[1109]                	mov	[PUTBACKDRV],al		; put in message to print out
  2030                                  
  2031                                  USERS_DRIVE:
  2032                                  	; MSDOS 6.0
  2033                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  2034                                  	;mov	si,offset DATARES:PutBackSubst	;  containing COMMAND
  2035                                  	;invoke	RPrint
  2036                                  	;mov	dx,offset DATARES:Prompt	; "Press any key"
  2037                                  	;invoke	RPrint
  2038                                  
  2039                                  	; MSDOS 3.3
  2040 00000349 BA[F508]                	mov	dx,PUTBACKMSG		; prompt for diskette
  2041 0000034C E83503                  	call	RDISPMSG
  2042 0000034F 8B16[C30A]              	mov	dx,[PUTBACKSUBSTPTR]
  2043 00000353 8B36[C50A]              	mov	si,[COMSPEC_END]
  2044 00000357 C6440124                	mov	byte [si+1],'$'
  2045 0000035B E82603                  	call	RDISPMSG
  2046 0000035E C6440100                	mov	byte [si+1],0
  2047 00000362 BA[0709]                	mov	dx,PROMPT
  2048 00000365 E81C03                  	call    RDISPMSG
  2049                                  
  2050                                  	;call	GETRAWFLUSHEDBYTE
  2051                                  	;retn
  2052                                  	; 02/03/2023
  2053                                  	;jmp	short GETRAWFLUSHEDBYTE
  2054                                  
  2055                                  ;***	GetRawFlushedByte - flush world and get raw input
  2056                                  
  2057                                  GETRAWFLUSHEDBYTE:
  2058 00000368 B8070C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  2059 0000036B CD21                    	int	21h			; get char without testing or echo
  2060 0000036D B8000C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  2061 00000370 CD21                    	int	21h
  2062                                  ;	Bugbug:	get rid of this return and the following retz.
  2063                                  LOADCOM_RETN:
  2064 00000372 C3                      	retn
  2065                                  
  2066                                  ;***	LoadCom - load in transient
  2067                                  
  2068                                  LOADCOM:
  2069                                  	;assume	ds:DATARES
  2070                                  	
  2071 00000373 45                      	inc	bp				; flag command read
  2072                                  
  2073 00000374 BA[830A]                	mov	dx,COMSPEC
  2074 00000377 B8003D                  	mov	ax,OPEN<<8	; 3D00h
  2075 0000037A CD21                    	int	21h				; open command.com
  2076 0000037C 7310                    	jnc	short READCOM
  2077 0000037E 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  2078 00000381 7506                    	jnz	short TRYDOOPEN
  2079 00000383 BA[9809]                	mov	dx,NOHANDMES
  2080 00000386 E988FD                  	jmp	FATALC				; will never find a handle
  2081                                  
  2082                                  TRYDOOPEN:
  2083 00000389 E89CFF                  	call	GETCOMDSK
  2084 0000038C EBE5                    	jmp	short LOADCOM
  2085                                  
  2086                                  READCOM:
  2087 0000038E 89C3                    	mov	bx,ax				; BX = handle
  2088 00000390 BA[E014]                	mov	dx,TRANSTART
  2089 00000393 31C9                    	xor	cx,cx				; CX:DX = seek loc
  2090 00000395 B80042                  	mov	ax,LSEEK<<8	; 4200h
  2091 00000398 CD21                    	int	21h
  2092 0000039A 7210                    	jc	short WRONGCOM1
  2093 0000039C B9324B                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  2094 0000039F 1E                      	push	ds
  2095 000003A0 8E1E[C90A]              	mov	ds,[TRNSEG]
  2096                                  	;assume	ds:NOTHING
  2097 000003A4 BA0001                  	mov	dx,100h
  2098 000003A7 B43F                    	mov	ah,READ	; 3Fh	
  2099 000003A9 CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  2100                                  			; BX = file handle, CX = number of bytes to read
  2101                                  			; DS:DX -> buffer
  2102 000003AB 1F                      	pop	ds
  2103                                  	;assume	ds:DATARES
  2104                                  WRONGCOM1:
  2105 000003AC 9C                      	pushf
  2106 000003AD 50                      	push	ax
  2107 000003AE B43E                    	mov	ah,CLOSE ; 3Eh
  2108 000003B0 CD21                    	int	21h			; close command.com
  2109 000003B2 58                      	pop	ax
  2110 000003B3 9D                      	popf
  2111 000003B4 7204                    	jc	short WRONGCOM		; error on read
  2112 000003B6 39C8                    	cmp	ax,cx
  2113                                  	;retz				; size matched
  2114 000003B8 74B8                    	jz	short LOADCOM_RETN
  2115                                  WRONGCOM:
  2116 000003BA BA[DD08]                	mov	dx,COMBAD
  2117 000003BD E868FF                  	call	GETCOMDSK
  2118 000003C0 EBB1                    	jmp	short LOADCOM		; try again
  2119                                  
  2120                                  ;***	ChkSum - compute transient checksum
  2121                                  
  2122                                  CHKSUM:
  2123 000003C2 1E                      	push	ds
  2124 000003C3 8E1E[C90A]              	mov	ds,[TRNSEG]
  2125 000003C7 BE0001                  	mov	si,100h
  2126 000003CA B9253D                  	mov	cx,TRANDATAEND-100H	; 3E44h (for original MSDOS 3.3!)
  2127                                  CHECK_SUM:
  2128 000003CD FC                      	cld
  2129 000003CE D1E9                    	shr	cx,1
  2130 000003D0 31D2                    	xor	dx,dx
  2131                                  CHK:
  2132 000003D2 AD                      	lodsw
  2133 000003D3 01C2                    	add	dx,ax
  2134 000003D5 83D200                  	adc	dx,0
  2135 000003D8 E2F8                    	loop	CHK
  2136 000003DA 1F                      	pop	ds
  2137 000003DB C3                      	retn
  2138                                  
  2139                                  ;***	SetVect - set interrupt vectors
  2140                                  
  2141                                  SETVECT:
  2142                                  	;mov	dx,offset DATARES:LodCom_Trap 
  2143 000003DC BA[AD01]                	mov	dx,LODCOM ; MSDOS 3.3
  2144 000003DF B82225                  	mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  2145 000003E2 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  2146 000003E6 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  2147 000003EA CD21                    	int	21h
  2148                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  2149 000003EC BA[3C00]                	mov	dx,CONTC ; MSDOS 3.3
  2150 000003EF FEC0                    	inc	al	; 23h
  2151 000003F1 CD21                    	int	21h
  2152                                  	;mov	dx,offset DATARES:CritErr_Trap
  2153 000003F3 BA[4704]                	mov	dx,CRITERR ; MSDOS 3.3
  2154 000003F6 FEC0                    	inc	al	; 24h
  2155 000003F8 CD21                    	int	21h
  2156 000003FA C3                      	retn
  2157                                  
  2158                                  	; MSDOS 6.0
  2159                                  ;;SR;
  2160                                  ;; We have this to take care of the extra values pushed on the stack by 
  2161                                  ;;the stub before jumping to LodCom1. We set up ds here and then jump to
  2162                                  ;;Lodcom1
  2163                                  ;;
  2164                                  ;public	TrnLodCom1
  2165                                  ;TrnLodCom1:
  2166                                  ;	pop	ds			;ds = DATARES
  2167                                  ;	add	sp,2
  2168                                  ;;	pop	ds:OldDS
  2169                                  ;	jmp	LodCom1
  2170                                  
  2171                                  ;***	EndInit - end up initialization sequence
  2172                                  ;
  2173                                  ;	Move the environment to a newly allocated segment.
  2174                                  
  2175                                  	; MSDOS 3.3
  2176                                  ENDINIT:
  2177 000003FB 1E                      	push	ds			; save segments
  2178 000003FC 06                      	push	es			;
  2179 000003FD 0E                      	push	cs			; get resident segment to DS
  2180 000003FE 1F                      	pop	ds			;
  2181                                  	;assume	ds:RESGROUP
  2182 000003FF 8B0E[A114]              	mov	cx,[USEDENV]		; get number of bytes to move
  2183 00000403 8E06[ED0B]              	mov	es,[ENVIRSEG]		; get target environment segment
  2184                                  	;assume	es:NOTHING
  2185                                  
  2186 00000407 803E[A714]01            	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  2187 0000040C 750A                    	jne	short NO_RESET 		; no - we already did it
  2188 0000040E 8B1E[9B14]              	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  2189 00000412 06                      	push	es			; save environment - just to be sure
  2190 00000413 B44A                    	mov	ah,SETBLOCK  ; 4Ah	;
  2191 00000415 CD21                    	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2192                                  				; ES = segment address of block to change
  2193                                  				; BX = new size in paragraphs
  2194 00000417 07                      	pop	es
  2195                                  
  2196                                  NO_RESET:
  2197 00000418 8C062C00                	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  2198 0000041C 8E1E[9F14]              	mov	ds,[OLDENV]		; source environment segment
  2199                                  	;assume	ds:NOTHING
  2200 00000420 31F6                    	xor	si,si			; set up offsets to start of segments
  2201 00000422 31FF                    	xor	di,di
  2202 00000424 FC                      	cld
  2203 00000425 F3A4                    	rep	movsb			; move it
  2204 00000427 31C0                    	xor	ax,ax
  2205 00000429 AA                      	stosb				; make sure it ends with double-null
  2206                                  
  2207                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  2208 0000042A 07                      	pop	es
  2209 0000042B 1F                      	pop	ds
  2210 0000042C E97EFD                  	jmp	LODCOM			; allocate transient
  2211                                  
  2212                                  
  2213                                  	; MSDOS 6.0
  2214                                  ;
  2215                                  ;The init code has been changed to take care of the new way in which the
  2216                                  ;environment segment is allocated.
  2217                                  ;NB: We can use all the init variables at this point because they are all in
  2218                                  ;RESGROUP
  2219                                  ;Bugbug: The above approach will not work for ROMDOS
  2220                                  ;
  2221                                  
  2222                                  ;IF 0
  2223                                  ;
  2224                                  ;EndInit:
  2225                                  ;	push	ds
  2226                                  ;	push	es			;save segments
  2227                                  ;	push	cs
  2228                                  ;	pop	ds		
  2229                                  ;	assume	ds:RESGROUP
  2230                                  ;;
  2231                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  2232                                  ;;
  2233                                  ;	mov	bx,ds
  2234                                  ;	mov	es,bx			;es = RESGROUP
  2235                                  ;;
  2236                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2237                                  ;; code + data for low COMMAND
  2238                                  ;;
  2239                                  ;	mov	bx,ResSize		;Total size of resident
  2240                                  ;	mov	ah,SETBLOCK
  2241                                  ;	int	21h			;Set block to resident size
  2242                                  ;;
  2243                                  ;;Allocate the correct size for the environment
  2244                                  ;;
  2245                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  2246                                  ;	mov	ah,ALLOC
  2247                                  ;	int	21h			;get memory
  2248                                  ;	jc	nomem_err		;out of memory,signal error
  2249                                  ;
  2250                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  2251                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  2252                                  ;	mov	es,ax			;es = address of allocated memory
  2253                                  ;	assume	es:nothing
  2254                                  ;
  2255                                  ;;
  2256                                  ;;Copy the environment to the newly allocated segment
  2257                                  ;;
  2258                                  ;	mov	cx,UsedEnv		;number of bytes to move
  2259                                  ;
  2260                                  ;	push	ds
  2261                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  2262                                  ;	assume	ds:nothing
  2263                                  ;
  2264                                  ;	xor	si,si
  2265                                  ;	mov	di,si			;Start transfer from 0
  2266                                  ;
  2267                                  ;	cld
  2268                                  ;	rep	movsb			;Do the copy
  2269                                  ;
  2270                                  ;	xor	ax,ax			
  2271                                  ;	stosb				;Make it end with double-null
  2272                                  ;
  2273                                  ;	pop	ds			;ds = RESGROUP
  2274                                  ;	assume	ds:RESGROUP
  2275                                  ;;
  2276                                  ;;We have to free the old environment block if it was allocated by INIT
  2277                                  ;;
  2278                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  2279                                  ;	je      no_free                 ;no, do not free it
  2280                                  ;
  2281                                  ;	mov	ax,OldEnv		;Get old environment
  2282                                  ;	mov	es,ax
  2283                                  ;	mov	ah,DEALLOC	
  2284                                  ;	int	21h			;Free it
  2285                                  ;no_free:
  2286                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  2287                                  ;	
  2288                                  ;	pop	es
  2289                                  ;	pop	ds
  2290                                  ;	assume	ds:nothing
  2291                                  ;	
  2292                                  ;	jmp	LodCom			;allocate transient
  2293                                  ;
  2294                                  ;nomem_err:
  2295                                  ;;
  2296                                  ;;We call the error routine which will never return. It will either exit
  2297                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  2298                                  ;;message ( if first COMMAND )
  2299                                  ;;
  2300                                  ;
  2301                                  ;	call	Alloc_error
  2302                                  ;ENDIF
  2303                                  ;
  2304                                  ;CODERES ends
  2305                                  
  2306                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2307                                  ;	the resident group which is the location where the transient
  2308                                  ;	segments will be loaded initial.
  2309                                  
  2310                                  ;TAIL		segment public para
  2311                                  ;
  2312                                  ;		org	0
  2313                                  ;TranStart	label	word
  2314                                  ;		public	TranStart
  2315                                  ;
  2316                                  ;TAIL		ends
  2317                                  ;
  2318                                  
  2319                                  ;	This TAIL segment is used to produce a PARA aligned label in
  2320                                  ;	the transient group which is the location where the exec
  2321                                  ;	segments will be loaded initial.
  2322                                  ;
  2323                                  ;	Bugbug:	Is TRANTAIL used anymore?
  2324                                  
  2325                                  ;TRANTAIL	segment public para
  2326                                  ;
  2327                                  ;		org	0
  2328                                  ;ExecStart   	label   word
  2329                                  ;
  2330                                  ;TRANTAIL    	ends
  2331                                  
  2332                                  ;=============================================================================
  2333                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  2334                                  ;=============================================================================
  2335                                  ; 22/09/2018 - Retro DOS v3.0
  2336                                  
  2337                                  ;	title	Localizable code for resident COMMAND
  2338                                  
  2339                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2340                                  
  2341                                  ;***	AskEnd - ask user to confirm batch file termination
  2342                                  ;
  2343                                  ;	Confirm with user before freeing batch ...
  2344                                  ;
  2345                                  ;	ENTRY	nothing
  2346                                  ;
  2347                                  ;	EXIT	CY = set if batch termination is confirmed
  2348                                  ;
  2349                                  ;		CY = clear if batch should continue
  2350                                  ;
  2351                                  ;	USED	AX,DX,...
  2352                                  
  2353                                  ;	Bugbug:	move this to transient, copy to batch segment.
  2354                                  ;	Bugbug:	or move it to command1 1st.
  2355                                  
  2356                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  2357                                  
  2358                                  ASKEND:
  2359                                  	;assume	ds:DATARES
  2360                                  
  2361 0000042F BA[3409]                	mov	dx,ENDBATMES			; DX = message #
  2362                                  	;call	RPrint
  2363 00000432 E84F02                  	call	RDISPMSG  ; MSDOS 3.3
  2364 00000435 B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  2365 00000438 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  2366                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  2367 0000043A E84F02                  	call	CHARTOUPPER			; change to upper case
  2368                                  	;cmp	al,[NO_CHAR]
  2369                                  	; 03/03/2023
  2370 0000043D 3C4E                    	cmp	al,'N'
  2371 0000043F 7405                    	je	short AERET			; answer is no (CY is clear)
  2372                                  	;cmp	al,[YES_CHAR]
  2373                                  	; 03/03/2023
  2374 00000441 3C59                    	cmp	al,'Y'
  2375 00000443 75EA                    	jne	short ASKEND			; invalid response, try again
  2376 00000445 F9                      	stc					; answer is yes
  2377                                  AERET:	
  2378 00000446 C3                      	retn
  2379                                  
  2380                                  
  2381                                  ;***	DskErr - critical error handler
  2382                                  ;
  2383                                  ;	Default critical error handler unless user intercepts int 24h.
  2384                                  ;
  2385                                  ;	ENTRY	int 24h
  2386                                  ;
  2387                                  ;	EXIT
  2388                                  ;
  2389                                  ;	USED
  2390                                  ;
  2391                                  ;	EFFECTS
  2392                                  
  2393                                  ;
  2394                                  ;SR; 
  2395                                  ; The stub is going to push the old ds value and the resident data segment
  2396                                  ;onto the stack in that order. Get it off the stack
  2397                                  ;
  2398                                  
  2399                                  ;DskErr	proc	far
  2400                                  DSKERRR:
  2401                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2402                                  	;
  2403                                  	;pop	ds			;ds = DATARES
  2404                                  	;assume ds:DATARES
  2405                                  	;pop	OldDS			;save old ds value
  2406                                  
  2407                                  CRITERR: ; MSDOS 3.3
  2408 00000447 FB                      	sti
  2409 00000448 1E                      	push	ds ; 25/09/2018
  2410 00000449 06                      	push	es
  2411 0000044A 56                      	push	si
  2412 0000044B 51                      	push	cx
  2413 0000044C 57                      	push	di
  2414 0000044D 51                      	push	cx
  2415 0000044E 50                      	push	ax
  2416                                  
  2417                                  	;push	ds			;save our data segment
  2418 0000044F 0E                      	push	cs ; 25/09/2018
  2419 00000450 07                      	pop	es			;es = DATARES
  2420                                  
  2421 00000451 8EDD                    	mov	ds,bp
  2422                                  	;assume	ds:nothing
  2423                                  
  2424                                  	;mov	ax,[si].SDEVATT
  2425 00000453 8B4404                  	MOV	ax,[SI+SYSDEV.ATT] ; mov ax,[si+4]	
  2426 00000456 268826[BF08]            	mov	[es:CDEVAT],ah
  2427                                  
  2428                                  	;push	cs
  2429                                  	;pop	es
  2430                                  
  2431 0000045B BF[9308]                	mov	di,DEVNAME
  2432 0000045E B90800                  	mov	cx,8
  2433                                  	;add	si,SDEVNAME  ; add si,10
  2434 00000461 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  2435                                  				
  2436 00000464 FC                      	cld
  2437 00000465 F3A4                    	rep	movsb
  2438 00000467 58                      	pop	ax
  2439 00000468 59                      	pop	cx
  2440 00000469 5F                      	pop	di
  2441                                  
  2442                                  ;	Stack still contains DS and ES.
  2443                                  
  2444                                  ;SR;
  2445                                  ; We need ds = DATARES for SavHand
  2446                                  ;
  2447                                  	;push	es
  2448                                  	;pop	ds
  2449                                  	;assume	ds:DATARES
  2450                                  
  2451                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  2452 0000046A E87AFE                  	call	SAVHAND
  2453                                  
  2454                                  	; 25/09/2018
  2455                                  	;push	cs
  2456 0000046D 06                      	push	es
  2457 0000046E 1F                      	pop	ds		; set up local data segment
  2458                                  	;assume	ds:resgroup
  2459                                  
  2460 0000046F 52                      	push	dx
  2461 00000470 E80E02                  	call	CRLF
  2462 00000473 5A                      	pop	dx
  2463                                  
  2464                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  2465                                  
  2466 00000474 8826[D60A]              	mov	[CRIT_ERR_INFO],ah	; save critical error flags
  2467                                  
  2468                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  2469                                  
  2470 00000478 0441                    	add	al,'A'
  2471 0000047A A2[8708]                	mov	[DRVLET],al
  2472                                  
  2473                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  2474                                  
  2475 0000047D F6C480                  	test	ah,80h
  2476 00000480 740A                    	jz	short NOHARDE		; it's a disk-device error
  2477 00000482 F606[BF08]80            	test	byte [CDEVAT],DEVTYP>>8 ; 80h
  2478 00000487 7503                    	jnz	short NOHARDE		; it's a character device
  2479 00000489 E9E501                  	jmp	FATERR			; it's a FAT error
  2480                                  
  2481                                  NOHARDE:
  2482 0000048C BE[6808]                	mov	si,MREAD		; SI = "read" msg #
  2483 0000048F F6C401                  	test	ah,1
  2484 00000492 7403                    	jz	short SAVMES		; it's a read error
  2485 00000494 BE[7008]                	mov	si,MWRITE		; SI = "write" msg #
  2486                                  
  2487                                  SAVMES:
  2488 00000497 893E[0F0C]              	mov	[OLDERRNO],di		; save critical error code
  2489                                  
  2490                                  ;	Bugbug:	don't need to save/restore all here?
  2491 0000049B 06                      	push	es
  2492 0000049C 1E                      	push	ds			; GetExtendedError likes to STOMP
  2493 0000049D 55                      	push	bp
  2494 0000049E 56                      	push	si
  2495 0000049F 52                      	push	dx
  2496 000004A0 51                      	push	cx
  2497 000004A1 53                      	push	bx
  2498 000004A2 B459                    	mov	ah,GetExtendedError ; 59h ; get extended error info
  2499 000004A4 CD21                    	int	21h
  2500 000004A6 5B                      	pop	bx
  2501 000004A7 59                      	pop	cx
  2502 000004A8 5A                      	pop	dx
  2503 000004A9 5E                      	pop	si
  2504 000004AA 5D                      	pop	bp
  2505 000004AB 1F                      	pop	ds
  2506 000004AC 893E[6B0A]              	mov	[NEEDVOL],di 	; save possible ptr to volume label
  2507 000004B0 8C06[6D0A]              	mov	[NEEDVOL+2],es
  2508 000004B4 07                      	pop	es
  2509                                  
  2510                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  2511                                  
  2512 000004B5 30E4                    	xor	ah,ah
  2513 000004B7 89C7                    	mov	di,ax			; DI = error code
  2514                                  
  2515                                  ; Bugbug:  somewhat obsolete documentation?
  2516                                  ;
  2517                                  ; DI is now the correct error code. Classify things to see what we are
  2518                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  2519                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  2520                                  ; the like) are contiguous.
  2521                                  ;
  2522                                  
  2523                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  2524                                  ;	Check use of ErrCd_24, though.
  2525                                  
  2526 000004B9 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  2527 000004BC 7303                    	jae	short HAVCOD
  2528                                  
  2529                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  2530                                  ;	even though it's not a critical error?
  2531                                  
  2532 000004BE BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  2533                                  ;
  2534                                  ; DI now has the mapped error code. Old style errors are:
  2535                                  ;   FOOBAR <read|writ>ing drive ZZ.
  2536                                  ; New style errors are:
  2537                                  ;   FOOBAR
  2538                                  ; We need to figure out which the particular error belongs to.
  2539                                  ;
  2540                                  
  2541                                  HAVCOD:
  2542 000004C1 C606[6F0A]00            	mov	byte [ERRTYPE],0	; assume old style
  2543 000004C6 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  2544 000004C9 7405                    	je	short SETSTYLE
  2545 000004CB 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2546 000004CE 7504                    	jne	short GOTSTYLE
  2547                                  
  2548                                  SETSTYLE:
  2549                                  ;	Bugbug:	use INC
  2550                                  	;mov	byte [ERRTYPE],1		; must be new type
  2551 000004D0 FE06[6F0A]              	inc	byte [ERRTYPE] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  2552                                  
  2553                                  GOTSTYLE:
  2554 000004D4 893E[7C0A]              	mov	[ERRCD_24],di
  2555                                  	; 25/09/2018
  2556                                  	; MSDOS 6.0
  2557                                  	;cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  2558                                  	; MSDOS 3.3
  2559 000004D8 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  2560                                  
  2561                                  						; If the error message is unknown
  2562 000004DB 7641                    	jbe	short NORMALERROR		;  redirector, continue. Otherwise,
  2563                                  ;
  2564                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  2565                                  ; how to handle things
  2566                                  ;
  2567                                  
  2568                                  ;input to IFSFUNC:    AL=1
  2569                                  ;		      BX=extended error number
  2570                                  ;
  2571                                  ;output from IFSFUNC: AL=error type (0 or 1)
  2572                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  2573                                  ;			   Abort, Retry, Ignore
  2574                                  ;			 1=<message>
  2575                                  ;			   Abort, Retry, Ignore
  2576                                  ;		      ES:DI=pointer to message text
  2577                                  ;		      carry set=>no message
  2578                                  
  2579 000004DD 89C7                    	mov	di,ax			; retrieve correct extended error...
  2580 000004DF B80005                  	mov	ax,0500h		; is the redir there?
  2581 000004E2 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  2582                                  			; Return: AL = 00h not installed, OK to install
  2583                                  			; 01h not installed, can't install
  2584                                  			; FFh installed
  2585 000004E4 3CFF                    	cmp	al,0FFh
  2586 000004E6 7529                    	jne	short NOHANDLER		; no, go to NoHandler
  2587                                  
  2588                                  	; MSDOS 6.0
  2589                                  	;push	bx
  2590                                  	;mov	bx,di			; get ErrType and ptr to error msg
  2591                                  	;mov	ax,0501h
  2592 000004E8 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2593                                  	;pop	bx 
  2594                                  	;jc	short NOHANDLER
  2595                                  	; MSDOS 3.3
  2596 000004EA 89F8                    	mov     ax,di
  2597 000004EC B405                    	mov     ah,5
  2598 000004EE CD2F                    	int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  2599 000004F0 721F                    	jc      short NOHANDLER
  2600                                  
  2601                                  ;	Bugbug:	need to record error type?
  2602 000004F2 A2[6F0A]                	mov	[ERRTYPE],al
  2603 000004F5 1E                      	push	ds
  2604 000004F6 06                      	push	es
  2605 000004F7 1F                      	pop	ds
  2606 000004F8 89FA                    	mov	dx,di
  2607 000004FA B9FFFF                  	mov	cx,-1			; find end of msg
  2608 000004FD 30C0                    	xor	al,al
  2609                                  
  2610 000004FF FC                      	cld
  2611 00000500 F2AE                    	repnz	scasb
  2612                                  
  2613                                  ;	Bugbug:	we can do better than this.
  2614                                  
  2615 00000502 C645FF24                	mov	byte [di-1],'$'
  2616                                  	
  2617                                  	;CALL	RDISPMSG ; MSDOS 3.3
  2618                                  	
  2619 00000506 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  2620 00000508 CD21                    	int	21h
  2621                                  
  2622 0000050A C645FF00                	mov	byte [di-1],0			; restore terminal byte
  2623                                  
  2624 0000050E 1F                      	pop	ds				; clean up and continue
  2625 0000050F EB18                    	jmp	short CHECKERRTYPE
  2626                                  
  2627                                  ;*	Redir isn't available or doesn't recognize the error.
  2628                                  ;	Restore regs to unextended error.
  2629                                  
  2630                                  NOHANDLER:
  2631 00000511 C606[6F0A]00            	mov	byte [ERRTYPE],0
  2632                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  2633 00000516 8B3E[0F0C]              	mov	di,[OLDERRNO]
  2634 0000051A 893E[7C0A]              	mov	[ERRCD_24],di
  2635                                  
  2636                                  NORMALERROR:
  2637                                  	; MSDOS 6.0
  2638                                  	;add	di,ERROR_WRITE_PROTECT
  2639                                  	;xchg	di,dx			; may need dx later
  2640                                  	;call	RPrintCrit		; print error type
  2641                                  
  2642                                  	; MSDOS 3.3
  2643 0000051E D1E7                    	shl     di,1
  2644 00000520 8BBD[3007]              	mov     di,[CRMSGTBL+di]
  2645 00000524 87FA                    	xchg    di,dx
  2646 00000526 E85B01                  	call    RDISPMSG
  2647                                  
  2648                                  CHECKERRTYPE:
  2649 00000529 803E[6F0A]00            	cmp	byte [ERRTYPE],0	; Check error style...
  2650 0000052E 7418                    	je	short CONTOLD
  2651 00000530 E84E01                  	call	CRLF			; if new style then done printing
  2652 00000533 EB2C                    	jmp	short ASK
  2653                                  
  2654                                  	; 02/03/2023
  2655                                  BLKERR:
  2656                                  	; MSDOS 6.0
  2657                                  	;mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
  2658                                  	;mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
  2659                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  2660                                  	;call	RPrint
  2661                                  
  2662                                  	; MSDOS 3.3
  2663 00000535 BA[8008]                	mov     dx,BLKDEVERR
  2664 00000538 E84901                  	call    RDISPMSG
  2665                                  
  2666 0000053B 803E[800A]00            	cmp	byte [LOADING],0
  2667 00000540 741F                    	jz	short ASK
  2668 00000542 E8C7FD                  	call	RESTHAND
  2669 00000545 E9BEFD                  	jmp	GETCOMDSK2		; if error loading COMMAND, re-prompt
  2670                                  
  2671                                  CONTOLD:
  2672                                  	; MSDOS 6.0
  2673                                  ;	inc	si			; DS:SI = ptr to asciiz string
  2674                                  ;
  2675                                  ;;	Bugbug:	combine some of the following two sections?
  2676                                  ;
  2677                                  ;	test	[CDevAt],DEVTYP shr 8
  2678                                  ;	jz	BlkErr
  2679                                  ;	mov	dx,offset DATARES:CharDevErr	  ; DX = ptr to device message
  2680                                  ;	mov	CharDevErrRw.SubstPtr,si	  ; point to read/write string
  2681                                  ;	mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  2682                                  ;
  2683                                  ;	call	RPrint				; print the message
  2684                                  ;	jmp	short Ask			; don't ralph on command
  2685                                  
  2686                                  	; MSDOS 3.3
  2687 00000548 BA[7808]                	mov	dx,ERRMES
  2688 0000054B E83601                  	call	RDISPMSG
  2689 0000054E 89F2                    	mov	dx,si
  2690 00000550 E83101                  	call	RDISPMSG
  2691                                  	
  2692 00000553 F606[BF08]80            	test	byte [CDEVAT], 80h
  2693 00000558 74DB                    	jz	short BLKERR
  2694 0000055A BA[8B08]                	mov	dx,CHARDEVERR	; " device "
  2695 0000055D B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  2696 0000055F CD21                    	int	21h		; DOS - PRINT STRING
  2697                                  				; DS:DX -> string terminated by "$"
  2698                                  	; 02/03/2023
  2699                                  	;jmp	short ASK
  2700                                  
  2701                                  ; 02/03/2023
  2702                                  ;BLKERR:
  2703                                  ;	; MSDOS 6.0
  2704                                  ;	;mov	dx,offset DATARES:BlkDevErr	  ; DX = error msg #
  2705                                  ;	;mov	BlkDevErrRw.SubstPtr,si		  ; "reading","writing" ptr
  2706                                  ;	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  2707                                  ;	;call	RPrint
  2708                                  ;
  2709                                  ;	; MSDOS 3.3
  2710                                  ;	mov     dx,BLKDEVERR
  2711                                  ;	call    RDISPMSG
  2712                                  ;
  2713                                  ;	cmp	byte [LOADING],0
  2714                                  ;	jz	short ASK
  2715                                  ;	call	RESTHAND
  2716                                  ;	jmp	GETCOMDSK2		; if error loading COMMAND, re-prompt
  2717                                  
  2718                                  ASK:
  2719 00000561 833E[7C0A]0F            	cmp	word [ERRCD_24],15	; error 15 has an extra message
  2720 00000566 751C                    	jne	short NOT15		; not error 15
  2721                                  
  2722                                  ;*	For error 15, tell the user which volume/serial # are needed.
  2723                                  
  2724 00000568 51                      	push	cx
  2725                                  
  2726                                  ;	Bugbug:	does this push/pop need to be done?
  2727 00000569 1E                      	push	ds
  2728 0000056A 07                      	pop	es
  2729 0000056B C536[6B0A]              	lds	si,[NEEDVOL]
  2730                                  	;assume	ds:NOTHING
  2731 0000056F 57                      	push	di
  2732 00000570 BF[5A08]                	mov	di,VOLNAME
  2733                                  	; MSDOS 6.0
  2734                                  	;mov	cx,16			; copy volume name & serial #
  2735                                  	; MSDOS 3.3
  2736 00000573 B90B00                  	mov	cx,11			; copy volume name
  2737 00000576 FC                      	cld
  2738 00000577 F3A4                    	rep	movsb
  2739 00000579 5F                      	pop	di
  2740 0000057A 06                      	push	es
  2741 0000057B 1F                      	pop	ds
  2742 0000057C 59                      	pop	cx
  2743                                  	;assume	ds:DATARES
  2744                                  	; MSDOS 6.0
  2745                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  2746                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  2747                                  	;call	RPrint
  2748                                  
  2749                                  	; MSDOS 3.3
  2750 0000057D BA[4708]                	mov	dx,NEEDVOLMSG
  2751 00000580 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2752 00000582 CD21                    	int     21h             ; DOS - PRINT STRING
  2753                                  				; DS:DX -> string terminated by "$"
  2754                                  NOT15:
  2755                                  ;*	Print abort, retry, ignore, fail message.
  2756                                  ;	Print only options that are valid.
  2757                                  
  2758                                  ;	Bugbug:	sizzle this.
  2759                                  
  2760 00000584 BA[9E08]                	mov	dx,REQ_ABORT
  2761                                  	;call	RPrint
  2762 00000587 E8FA00                  	call	RDISPMSG
  2763 0000058A F606[D60A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED  ; 10h
  2764 0000058F 7406                    	jz	short TRY_IGNORE
  2765 00000591 BA[A408]                	mov	dx,REQ_RETRY
  2766                                  	;call	RPrint
  2767 00000594 E8ED00                  	call	RDISPMSG
  2768                                  TRY_IGNORE:
  2769 00000597 F606[D60A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h
  2770 0000059C 7406                    	jz	short TRY_FAIL
  2771 0000059E BA[AC08]                	mov	dx,REQ_IGNORE
  2772                                  	;call	RPrint
  2773 000005A1 E8E000                  	call	RDISPMSG
  2774                                  TRY_FAIL:
  2775 000005A4 F606[D60A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED   ; 08h
  2776 000005A9 7406                    	jz	short TERM_QUESTION
  2777 000005AB BA[B508]                	mov	dx,REQ_FAIL
  2778                                  	;call	RPrint
  2779 000005AE E8D300                  	call	RDISPMSG
  2780                                  TERM_QUESTION:
  2781 000005B1 BA[BC08]                	mov	dx,REQ_END
  2782                                  	;call	RPrint
  2783 000005B4 E8CD00                  	call	RDISPMSG
  2784                                  
  2785                                  ;	If the /f switch was given, we fail all requests.
  2786                                  
  2787 000005B7 F606[E10A]FF            	test	byte [FFAIL],-1
  2788 000005BC 7405                    	jz	short DOPROMPT
  2789 000005BE B403                    	mov	ah,3				; signal fail
  2790 000005C0 E9A200                  	jmp	EEXIT
  2791                                  
  2792                                  DOPROMPT:
  2793 000005C3 B8010C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  2794 000005C6 CD21                    	int	21h				; get response
  2795                                  
  2796 000005C8 E8B600                  	call	CRLF
  2797 000005CB E8BE00                  	call	CHARTOUPPER			; convert to upper case
  2798 000005CE B400                    	mov	ah,0				; return code for ignore
  2799 000005D0 F606[D60A]20            	test	byte [CRIT_ERR_INFO],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  2800 000005D5 7404                    	jz	short USER_RETRY
  2801                                  	;cmp	al,[IGNORE_CHAR]		; ignore?
  2802                                  	; 03/03/2023
  2803 000005D7 3C49                    	cmp	al,'I'
  2804 000005D9 7423                    	jz	short EEXITJ
  2805                                  
  2806                                  ;	Bugbug:	optimize following code.
  2807                                  
  2808                                  USER_RETRY:
  2809 000005DB FEC4                    	inc	ah				; return code for retry
  2810 000005DD F606[D60A]10            	test	byte [CRIT_ERR_INFO],RETRY_ALLOWED ; 10h ; is retry allowed?
  2811 000005E2 7404                    	jz	short USER_ABORT
  2812                                  	;cmp	al,[RETRY_CHAR]			; retry?
  2813                                  	; 03/03/2023
  2814 000005E4 3C52                    	cmp	al,'R'
  2815 000005E6 7416                    	jz	short EEXITJ
  2816                                  
  2817                                  USER_ABORT:
  2818 000005E8 FEC4                    	inc	ah				; return code for abort
  2819                                  						;  (abort always allowed)
  2820                                  	;cmp	al,[ABORT_CHAR]			; abort?
  2821                                  	; 03/03/2023
  2822 000005EA 3C41                    	cmp	al,'A'
  2823 000005EC 7412                    	jz	short ABORT_PROCESS			; exit user program
  2824 000005EE FEC4                    	inc	ah				; return code for fail
  2825 000005F0 F606[D60A]08            	test	byte [CRIT_ERR_INFO],FAIL_ALLOWED ; 08h ; is fail allowed?
  2826 000005F5 7404                    	jz	short ASKJ
  2827                                  	;cmp	al,[FAIL_CHAR]			; fail?
  2828                                  	; 03/03/2023
  2829 000005F7 3C46                    	cmp	al,'F'
  2830 000005F9 7403                    	jz	short EEXITJ
  2831                                  ASKJ:
  2832 000005FB E963FF                  	jmp	ASK
  2833                                  
  2834                                  EEXITJ:
  2835 000005FE EB65                    	jmp	short EEXIT
  2836                                  
  2837                                  ABORT_PROCESS:
  2838 00000600 F606[430B]01            	test	byte [INITFLAG],INITINIT ; 1	; COMMAND init interrupted?
  2839 00000605 741A                    	jz	short ABORTCONT			; no, handle it normally
  2840 00000607 803E[DC0A]00            	cmp	byte [PERMCOM],0		; are we top level process?
  2841 0000060C 7408                    	jz	short JUSTEXIT			; yes, just exit
  2842                                  
  2843 0000060E BA[3C0A]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  2844                                  	;call	RPrint				; print it
  2845 00000611 E87000                  	call	RDISPMSG
  2846                                  
  2847                                  DEADINTHEWATER:
  2848 00000614 EBFE                    	jmp	short DEADINTHEWATER		; loop until the user reboots
  2849                                  
  2850                                  JUSTEXIT:
  2851                                  	;assume	ds:DATARES
  2852 00000616 A1[760A]                	mov	ax,[PARENT]			; load real parent pid
  2853 00000619 A31600                  	mov	[PDB.PARENT_PID],ax ; mov ds:16h,ax ; put it back where it belongs
  2854 0000061C B8FF4C                  	mov	ax,(EXIT<<8) | 255 ; 4CFFh
  2855 0000061F CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  2856                                  				; AL = exit code
  2857                                  ABORTCONT:
  2858 00000621 F606[CC0A]FF            	test	byte [IN_BATCH],-1		; Are we accessing a batch file?
  2859 00000626 7405                    	jz	short NOT_BATCH_ABORT
  2860 00000628 C606[CD0A]01            	mov	byte [BATCH_ABORT],1		; set flag for abort
  2861                                  NOT_BATCH_ABORT:
  2862 0000062D 8A16[440B]              	mov	dl,[PIPEFLAG]
  2863 00000631 E8C7FA                  	call	RESPIPEOFF
  2864 00000634 08D2                    	or	dl,dl
  2865 00000636 740D                    	je	short CHECKFORA
  2866 00000638 833E[DD0A]00            	cmp	word [SINGLECOM],0
  2867 0000063D 7406                    	je	short CHECKFORA
  2868 0000063F C706[DD0A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2869                                  CHECKFORA:
  2870 00000645 833E[7C0A]00            	cmp	word [ERRCD_24],0		; write protect?
  2871 0000064A 7407                    	je	short ABORTFOR
  2872 0000064C 833E[7C0A]02            	cmp	word [ERRCD_24],2		; drive not ready?
  2873 00000651 7512                    	jne	short EEXIT			; don't abort the FOR
  2874                                  ABORTFOR:
  2875 00000653 C606[E30A]00            	mov	byte [FORFLAG],0		; abort a FOR in progress
  2876 00000658 833E[DD0A]00            	cmp	word [SINGLECOM],0
  2877 0000065D 7406                    	je	short EEXIT
  2878 0000065F C706[DD0A]FFFF          	mov	word [SINGLECOM],-1		; make sure singlecom exits
  2879                                  EEXIT:
  2880 00000665 88E0                    	mov	al,ah
  2881 00000667 89FA                    	mov	dx,di
  2882                                  RESTHD:
  2883 00000669 E8A0FC                  	call    RESTHAND
  2884 0000066C 59                      	pop	cx
  2885 0000066D 5E                      	pop	si				; restore registers
  2886 0000066E 07                      	pop	es
  2887                                  	
  2888                                  ;	; MSDOS 6.0
  2889                                  ;;;	pop	ds
  2890                                  ;;SR;
  2891                                  ;; ds has to be got from the variable we saved it in
  2892                                  ;;
  2893                                  ;
  2894                                  ; 	mov	ds,OldDS			;restore old value of ds
  2895                                  ;;	pop	ds
  2896                                  ;	assume	ds:nothing
  2897                                  
  2898                                  	; MSDOS 3.3
  2899 0000066F 1F                      	pop	ds
  2900                                  
  2901 00000670 CF                      	iret
  2902                                  
  2903                                  FATERR:
  2904                                  	; MSDOS 6.0
  2905                                  	;mov	dx,offset DATARES:BadFatMsg
  2906                                  	;mov	si,offset DATARES:BadFatSubst
  2907                                  	;call	RPrint
  2908                                  
  2909                                  	; MSDOS 3.3
  2910 00000671 BA[C008]                	mov     dx,BADFATMSG
  2911 00000674 E80D00                  	call    RDISPMSG
  2912 00000677 BA[8008]                	mov     dx,BLKDEVERR
  2913 0000067A E80700                  	call    RDISPMSG
  2914                                  
  2915 0000067D B002                    	mov	al,2				; abort
  2916 0000067F EBE8                    	jmp	short RESTHD
  2917                                  
  2918                                  ;DskErr	endp
  2919                                  
  2920                                  	; MSDOS 6.0
  2921                                  ;***	RPrint - print message
  2922                                  ;***	Crlf - display cr/lf
  2923                                  ;
  2924                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  2925                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  2926                                  ;		variable fields related to substitution blocks are set
  2927                                  ;
  2928                                  ;	EXIT	nothing
  2929                                  ;
  2930                                  ;	USED	flags
  2931                                  ;
  2932                                  ;	EFFECTS
  2933                                  ;	  Message is displayed on stdout.
  2934                                  ;
  2935                                  ;	NOTE
  2936                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  2937                                  ;	    be greater than number of substition blocks present.
  2938                                  
  2939                                  ;
  2940                                  ;Crlf: 
  2941                                  ;	mov	dx,offset DATARES:Newlin	; cheap newline
  2942                                  ;
  2943                                  ;RPrint	proc
  2944                                  ;
  2945                                  ;	assume	ds:DATARES,ss:DATARES
  2946                                  ;
  2947                                  ;;	Bugbug:	do we need to save all reg's?
  2948                                  ;
  2949                                  ;	push	si			; preserve registers
  2950                                  ;	push	ax
  2951                                  ;	push	bx
  2952                                  ;	push	cx
  2953                                  ;	push	dx
  2954                                  ;
  2955                                  ;	mov	bx,si			; DS:BX = ptr to subst block
  2956                                  ;	mov	si,dx			; DS:SI = ptr to count byte
  2957                                  ;	lodsb				; AL = message length
  2958                                  ;					; DS:SI = ptr to message text
  2959                                  ;	xor	cx,cx
  2960                                  ;	mov	cl,al			; CX = message length
  2961                                  ;	jcxz	rpRet
  2962                                  ;
  2963                                  ;	call	RDispMsg
  2964                                  ;
  2965                                  ;rpRet:	pop	dx
  2966                                  ;	pop	cx
  2967                                  ;	pop	bx
  2968                                  ;	pop	ax
  2969                                  ;	pop	si
  2970                                  ;	ret
  2971                                  ;
  2972                                  ;RPrint	endp
  2973                                  
  2974                                  	; MSDOS 3.3
  2975                                  CRLF:
  2976 00000681 BA[8808]                	mov     dx,NEWLIN
  2977                                  
  2978                                  RDISPMSG: ; Display message/text
  2979                                  	; DS:DX = ($ terminated) Message/Text address 
  2980 00000684 50                      	push    ax
  2981 00000685 B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  2982 00000687 F8                      	clc
  2983 00000688 CD21                    	int     21h             ; DOS - PRINT STRING
  2984                                  				; DS:DX -> string terminated by "$"
  2985 0000068A 58                      	pop     ax
  2986 0000068B C3                      	retn
  2987                                  
  2988                                  	; MSDOS 6.0
  2989                                  
  2990                                  ;***	RPrintCrit - print critical error message
  2991                                  ;
  2992                                  ;	ENTRY	DX = extended error # (19-39)
  2993                                  ;
  2994                                  ;	EXIT	nothing
  2995                                  ;
  2996                                  ;	USED	flags
  2997                                  ;
  2998                                  ;	EFFECTS
  2999                                  ;	  Message is displayed on stdout
  3000                                  
  3001                                  ;RPrintCrit	proc
  3002                                  ;
  3003                                  ;	assume	ds:DATARES,ss:DATARES
  3004                                  ;
  3005                                  ;	push	dx			; preserve DX
  3006                                  ;	xchg	bx,dx			; BX = extended error #
  3007                                  ;					; DX = saved BX
  3008                                  ;	sub	bx,19			; BX = critical error index, from 0
  3009                                  ;	shl	bx,1			; BX = offset in word table
  3010                                  ;	mov	bx,CritMsgPtrs[bx]	; BX = ptr to error msg
  3011                                  ;	xchg	bx,dx			; DX = ptr to error msg
  3012                                  ;					; BX = restored
  3013                                  ;	call	RPrint			; print the message
  3014                                  ;	pop	dx			; restore DX
  3015                                  ;	ret
  3016                                  ;
  3017                                  ;RPrintCrit	endp
  3018                                  
  3019                                  
  3020                                  ;***	RDispMsg - display message
  3021                                  ;
  3022                                  ;	Display message, with substitutions, for RPrint.
  3023                                  ;
  3024                                  ;	ENTRY	DS:SI = ptr to message text
  3025                                  ;		CX = message length
  3026                                  ;		DS:BX = ptr to substitution block, if any
  3027                                  ;
  3028                                  ;	EXIT	nothing
  3029                                  ;
  3030                                  ;	USED	AX,CX,DX,SI
  3031                                  
  3032                                  ;RDispMsg	proc
  3033                                  ;
  3034                                  ;	assume	ds:DATARES,ss:DATARES
  3035                                  ;
  3036                                  ;rdNextChar:
  3037                                  ;	lodsb				; AL = next char
  3038                                  ;	cmp	al,'%'
  3039                                  ;	jne	rdOutChar		; not a substitution
  3040                                  ;	mov	dl,ds:[si]		; DL = possible '1' - '9'
  3041                                  ;	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  3042                                  ;	cmp	dl,9
  3043                                  ;	jae	rdOutChar		; not a substitution
  3044                                  ;
  3045                                  ;;*	A substitution code %1 - %9 has been encountered.
  3046                                  ;;	DL = 0-8, indicating %1-%9
  3047                                  ;;	DS:BX = ptr to substitution block
  3048                                  ;
  3049                                  ;	call	SubstMsg		; display the substitution
  3050                                  ;	inc	si			; SI = ptr past %n
  3051                                  ;	dec	cx			; count extra character in %n
  3052                                  ;	jmp	short rdCharDone
  3053                                  ;
  3054                                  ;;*	Normal character output.
  3055                                  ;
  3056                                  ;rdOutChar:
  3057                                  ;	mov	dl,al			; DL = char
  3058                                  ;	mov	ah,2			; AH = DOS Character Output code
  3059                                  ;	int	21h			; call DOS
  3060                                  ;rdCharDone:
  3061                                  ;	loop	rdNextChar
  3062                                  ;	ret
  3063                                  ;
  3064                                  ;RDispMsg	endp
  3065                                  
  3066                                  ;***	SubstMsg - display message substitution
  3067                                  ;
  3068                                  ;	Display a substitution string within a message.
  3069                                  ;	Substitution can be a char, an ASCIIZ string, or
  3070                                  ;	a word to be displayed as hex digits.
  3071                                  ;
  3072                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  3073                                  ;		DS:BX = ptr to substitution block
  3074                                  ;
  3075                                  ;	EXIT	nothing
  3076                                  ;
  3077                                  ;	USED	AX,DX
  3078                                  
  3079                                  ;SubstMsg	proc
  3080                                  ;
  3081                                  ;	assume	ds:DATARES,ss:DATARES
  3082                                  ;
  3083                                  ;	push	bx			; preserve BX
  3084                                  ;	push	cx			; preserve CX
  3085                                  ;
  3086                                  ;	mov	al,size SUBST		; AL = size of substitution block
  3087                                  ;	mul	dl			; AX = offset of desired subst block
  3088                                  ;	add	bx,ax			; DS:BX = ptr to desired subst block
  3089                                  ;
  3090                                  ;	mov	al,[bx].SubstType	; AX = substitution type flag
  3091                                  ;	mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  3092                                  ;
  3093                                  ;;	AL = 1, 2, or 3 for char, string, or hex type
  3094                                  ;
  3095                                  ;	dec	al
  3096                                  ;	jz	smChar
  3097                                  ;	dec	al
  3098                                  ;	jz	smStr
  3099                                  ;
  3100                                  ;;*	Hex number substitution.
  3101                                  ;
  3102                                  ;	mov	ax,ds:[bx]		; AX = word value
  3103                                  ;	mov	cx,4			; CX = # digits to display
  3104                                  ;smDigit:
  3105                                  ;	rol	ax,1
  3106                                  ;	rol	ax,1
  3107                                  ;	rol	ax,1
  3108                                  ;	rol	ax,1			; AL<3:0> = next digit
  3109                                  ;
  3110                                  ;	push	ax			; save other digits
  3111                                  ;	and	al,0Fh			; AL = binary digit
  3112                                  ;	add	al,'0'			; AL = ascii digit if 0-9
  3113                                  ;	cmp	al,'9'
  3114                                  ;	jbe	@F			; it's 0-9
  3115                                  ;	add	al,'A' - '0' - 10	; AL = ascii digit A-F
  3116                                  ;@@:
  3117                                  ;	mov	dl,al			; DL = ascii digit
  3118                                  ;	mov	ah,2
  3119                                  ;	int	21h			; output the ascii digit
  3120                                  ;	pop	ax			; restore all digits
  3121                                  ;
  3122                                  ;	loop	smDigit
  3123                                  ;	jmp	short smRet
  3124                                  ;
  3125                                  ;;*	Char substitution.
  3126                                  ;
  3127                                  ;smChar:
  3128                                  ;	mov	dl,ds:[bx]		; DL = char to output
  3129                                  ;	mov	ah,2
  3130                                  ;	int	21h
  3131                                  ;	jmp	short smRet
  3132                                  ;
  3133                                  ;;*	String substitution.
  3134                                  ;
  3135                                  ;smStr:
  3136                                  ;	mov	dl,ds:[bx]		; DL = next char
  3137                                  ;	or	dl,dl
  3138                                  ;	jz	smRet			; null char - we're done
  3139                                  ;	mov	ah,2
  3140                                  ;	int	21h			; display char
  3141                                  ;	inc	bx			; DS:BX = ptr to next char
  3142                                  ;	jmp	smStr
  3143                                  ;
  3144                                  ;smRet:	pop	cx
  3145                                  ;	pop	bx
  3146                                  ;	ret
  3147                                  ;
  3148                                  ;SubstMsg	endp
  3149                                  
  3150                                  
  3151                                  	; MSDOS 6.0
  3152                                  
  3153                                  ;***	CharToUpper - convert character to uppercase
  3154                                  ;
  3155                                  ;	ENTRY	AL = char
  3156                                  ;
  3157                                  ;	EXIT	AL = uppercase char
  3158                                  ;
  3159                                  ;	USED	AX
  3160                                  
  3161                                  ;CharToUpper	proc
  3162                                  ;
  3163                                  ;	assume	ds:DATARES
  3164                                  ;
  3165                                  ;	push	ax		; put char on stack as arg to int 2F
  3166                                  ;	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  3167                                  ;	int	2Fh
  3168                                  ;	inc	sp		; throw away old char on stack
  3169                                  ;	inc	sp
  3170                                  ;	ret
  3171                                  ;
  3172                                  ;CharToUpper	endp
  3173                                  
  3174                                  	; MSDOS 3.3
  3175                                  CHARTOUPPER:
  3176 0000068C 3C80                    	cmp	al,80h
  3177 0000068E 7210                    	jb	short CHARTOUPPER1
  3178 00000690 2C80                    	sub	al,80h
  3179 00000692 1E                      	push	ds
  3180 00000693 53                      	push	bx
  3181 00000694 C51E[EE0A]              	lds	bx,[UPPERCASETBL]
  3182 00000698 83C302                  	add	bx,2
  3183 0000069B D7                      	xlat
  3184 0000069C 5B                      	pop	bx
  3185 0000069D 1F                      	pop	ds
  3186 0000069E EB0A                    	jmp	short CHARTOUPPER_RETN
  3187                                  CHARTOUPPER1:
  3188 000006A0 3C61                    	cmp	al,'a'
  3189 000006A2 7206                    	jb	short CHARTOUPPER_RETN
  3190 000006A4 3C7A                    	cmp	al,'z'
  3191 000006A6 7702                    	ja	short CHARTOUPPER_RETN
  3192 000006A8 2C20                    	sub	al,20h
  3193                                  CHARTOUPPER_RETN:
  3194 000006AA C3                      	retn
  3195                                  
  3196                                  ;public	EndCode
  3197                                  ;EndCode label	byte
  3198                                  
  3199                                  ;=============================================================================
  3200                                  ; RDATA.ASM, MSDOS 6.0, 1991
  3201                                  ;=============================================================================
  3202                                  ; 22/09/2018 - Retro DOS v3.0
  3203                                  
  3204                                  ;NOTE: This initialized rezident data is just as rezident data section/portion
  3205                                  ;      of the disassembled MSDOS 3.3 COMMAND.COM code.
  3206                                  ;   (MSDOS 6.0 RDATA.ASM is used for comments & descriptions about the RDATA.) 
  3207                                  
  3208                                  ; RDATA section of Retro DOS v2.0 'command2.s' (05/05/2018) has been modified 
  3209                                  ; for 'command3.s' (22/09/2018), here:
  3210                                  
  3211 000006AB 90                      ALIGN 2
  3212                                  	; 22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3213                                  RSTACK_SPACE:
  3214 000006AC 00<rep 80h>             	times 128 db 0
  3215                                  RSTACK:
  3216 0000072C 0000                    	dw 	0
  3217                                  
  3218                                  	; 25/09/2018	
  3219                                  	; (filler)
  3220 0000072E 0000                    	dW	0
  3221                                  
  3222                                  RDATA	EQU	$
  3223                                  
  3224                                  ;TITLE   COMMAND Resident DATA
  3225                                  
  3226                                  ; Data for resident portion
  3227                                  
  3228                                  ;DATARES SEGMENT PUBLIC BYTE
  3229                                  
  3230                                  	;ORG     0
  3231                                  ;ZERO    =       $
  3232                                  
  3233                                  CRMSGTBL:
  3234 00000730 [5407]                  	dw	CRMSG0		; "Write protect$"
  3235 00000732 [6207]                  	dw	CRMSG1		; "Bad unit$"
  3236 00000734 [6B07]                  	dw	CRMSG2		; "Not ready$"
  3237 00000736 [7507]                  	dw	CRMSG3		; "Bad command $"
  3238 00000738 [8207]                  	dw	CRMSG4		; "Data$"
  3239 0000073A [8707]                  	dw	CRMSG5		; "Bad call format$"
  3240 0000073C [9707]                  	dw	CRMSG6		; "Seek$"
  3241 0000073E [9C07]                  	dw	CRMSG7		; "Non-DOS disk$"
  3242 00000740 [A907]                  	dw	CRMSG8		; "Sector not found$"
  3243 00000742 [BA07]                  	dw	CRMSG9		; "No paper$"
  3244 00000744 [C307]                  	dw	CRMSG10		; "Write fault$"
  3245 00000746 [CF07]                  	dw	CRMSG11		; "Read fault$"
  3246 00000748 [DA07]                  	dw	CRMSG12		; "General Failure$"
  3247 0000074A [EA07]                  	dw	CRMSG13		; "Sharing Violation$"
  3248 0000074C [FC07]                  	dw	CRMSG14		; "Lock Violation$"
  3249 0000074E [0B08]                  	dw	CRMSG15		; "Invalid Disk Change$"
  3250 00000750 [1F08]                  	dw	CRMSG16		; "FCB unavailable$"
  3251 00000752 [2F08]                  	dw	CRMSG17		; "Sharing buffer exceeded$"
  3252                                  
  3253 00000754 57726974652070726F-     CRMSG0:	 db 'Write protect$'
  3253 0000075D 7465637424         
  3254 00000762 42616420756E697424      CRMSG1:	 db 'Bad unit$'
  3255 0000076B 4E6F74207265616479-     CRMSG2:	 db 'Not ready$'
  3255 00000774 24                 
  3256 00000775 42616420636F6D6D61-     CRMSG3:	 db 'Bad command $'
  3256 0000077E 6E642024           
  3257 00000782 4461746124              CRMSG4:	 db 'Data$'
  3258 00000787 4261642063616C6C20-     CRMSG5:	 db 'Bad call format$'
  3258 00000790 666F726D617424     
  3259 00000797 5365656B24              CRMSG6:	 db 'Seek$'
  3260 0000079C 4E6F6E2D444F532064-     CRMSG7:	 db 'Non-DOS disk$'
  3260 000007A5 69736B24           
  3261 000007A9 536563746F72206E6F-     CRMSG8:	 db 'Sector not found$'
  3261 000007B2 7420666F756E6424   
  3262 000007BA 4E6F20706170657224      CRMSG9:	 db 'No paper$'
  3263 000007C3 577269746520666175-     CRMSG10: db 'Write fault$'
  3263 000007CC 6C7424             
  3264 000007CF 52656164206661756C-     CRMSG11: db 'Read fault$'
  3264 000007D8 7424               
  3265 000007DA 47656E6572616C2046-     CRMSG12: db 'General Failure$'
  3265 000007E3 61696C75726524     
  3266 000007EA 53686172696E672056-     CRMSG13: db 'Sharing Violation$'
  3266 000007F3 696F6C6174696F6E24 
  3267 000007FC 4C6F636B2056696F6C-     CRMSG14: db 'Lock Violation$'
  3267 00000805 6174696F6E24       
  3268 0000080B 496E76616C69642044-     CRMSG15: db 'Invalid Disk Change$'
  3268 00000814 69736B204368616E67-
  3268 0000081D 6524               
  3269 0000081F 46434220756E617661-     CRMSG16: db 'FCB unavailable$'
  3269 00000828 696C61626C6524     
  3270 0000082F 53686172696E672062-     CRMSG17: db 'Sharing buffer exceeded$'
  3270 00000838 756666657220657863-
  3270 00000841 656564656424       
  3271                                  
  3272 00000847 506C6561736520496E-     NEEDVOLMSG:	db 'Please Insert disk '
  3272 00000850 73657274206469736B-
  3272 00000859 20                 
  3273 0000085A 00<rep Bh>              VOLNAME: times 11 db 0	; db 0Bh dup(0)
  3274 00000865 0D0A24                  		db 0Dh,0Ah,'$'
  3275 00000868 72656164696E6724        MREAD:		db 'reading$'
  3276 00000870 77726974696E6724        MWRITE:		db 'writing$'
  3277 00000878 206572726F722024        ERRMES:		db ' error $'
  3278 00000880 20647269766520          BLKDEVERR:	db ' drive '
  3279 00000887 41                      DRVLET:		db 'A'
  3280 00000888 0D0A24                  NEWLIN:		db 0Dh,0Ah,'$'
  3281 0000088B 2064657669636520        CHARDEVERR:	db ' device '
  3282 00000893 00<rep 8h>              DEVNAME: times 8 db 0 ; db 8 dup(0)
  3283 0000089B 0D0A24                  		db 0Dh,0Ah,'$'
  3284 0000089E 41626F727424            REQ_ABORT:	db 'Abort$'
  3285 000008A4 2C20526574727924        REQ_RETRY:	db ', Retry$'
  3286 000008AC 2C2049676E6F726524      REQ_IGNORE:	db ', Ignore$'
  3287 000008B5 2C204661696C24          REQ_FAIL:	db ', Fail$'
  3288 000008BC 3F2024                  REQ_END:	db '? $'
  3289 000008BF 00                      CDEVAT:		db 0
  3290 000008C0 0D0A46696C6520616C-     BADFATMSG:	db 0Dh,0Ah,'File allocation table bad,$'
  3290 000008C9 6C6F636174696F6E20-
  3290 000008D2 7461626C6520626164-
  3290 000008DB 2C24               
  3291 000008DD 0D0A496E76616C6964-     COMBAD:		db 0Dh,0Ah,'Invalid COMMAND.COM',0Dh,0Ah,'$'
  3291 000008E6 20434F4D4D414E442E-
  3291 000008EF 434F4D0D0A24       
  3292 000008F5 496E73657274206469-     PUTBACKMSG:	db 'Insert disk with $'
  3292 000008FE 736B20776974682024 
  3293 00000907 20696E206472697665-     PROMPT:		db ' in drive '
  3293 00000910 20                 
  3294 00000911 200D0A616E64207374-     PUTBACKDRV:	db ' ',0Dh,0Ah, 'and strike any key when ready',0Dh,0Ah,'$'
  3294 0000091A 72696B6520616E7920-
  3294 00000923 6B6579207768656E20-
  3294 0000092C 72656164790D0A24   
  3295 00000934 0D0A5465726D696E61-     ENDBATMES:	db 0Dh,0Ah,'Terminate batch job (Y/N)? $'
  3295 0000093D 746520626174636820-
  3295 00000946 6A6F622028592F4E29-
  3295 0000094F 3F2024             
  3296 00000952 45584543206661696C-     EXECEMES:	db 'EXEC failure',0Dh,0Ah,'$'
  3296 0000095B 7572650D0A24       
  3297 00000961 4572726F7220696E20-     EXEBAD:		db 'Error in EXE file',0Dh,0Ah,'$'
  3297 0000096A 4558452066696C650D-
  3297 00000973 0A24               
  3298 00000975 50726F6772616D2074-     TOOBIG:		db 'Program too big to fit in memory',0Dh,0Ah,'$'
  3298 0000097E 6F6F2062696720746F-
  3298 00000987 2066697420696E206D-
  3298 00000990 656D6F72790D0A24   
  3299 00000998 0D0A4E6F2066726565-     NOHANDMES:	db 0Dh,0Ah,'No free file handles$'
  3299 000009A1 2066696C652068616E-
  3299 000009AA 646C657324         
  3300 000009AF 42616420436F6D6D61-     RBADNAM:	db 'Bad Command or file name',0Dh,0Ah,'$'
  3300 000009B8 6E64206F722066696C-
  3300 000009C1 65206E616D650D0A24 
  3301 000009CA 416363657373206465-     ACCDEN:		db 'Access denied',0Dh,0Ah,'$'
  3301 000009D3 6E6965640D0A24     
  3302 000009DA 0D0A4D656D6F727920-     BMEMMES:	db 0Dh,0Ah,'Memory allocation error $'
  3302 000009E3 616C6C6F636174696F-
  3302 000009EC 6E206572726F722024 
  3303 000009F5 0D0A43616E6E6F7420-     HALTMES:	db 0Dh,0Ah,'Cannot load COMMAND, system halted$'
  3303 000009FE 6C6F616420434F4D4D-
  3303 00000A07 414E442C2073797374-
  3303 00000A10 656D2068616C746564-
  3303 00000A19 24                 
  3304 00000A1A 0D0A43616E6E6F7420-     FRETMES:	db 0Dh,0Ah,'Cannot start COMMAND, exiting',0Dh,0Ah,'$'
  3304 00000A23 737461727420434F4D-
  3304 00000A2C 4D414E442C20657869-
  3304 00000A35 74696E670D0A24     
  3305 00000A3C 0D0A546F70206C6576-     PATRICIDE:	db 0Dh,0Ah,'Top level process aborted, cannot continue. $'
  3305 00000A45 656C2070726F636573-
  3305 00000A4E 732061626F72746564-
  3305 00000A57 2C2063616E6E6F7420-
  3305 00000A60 636F6E74696E75652E-
  3305 00000A69 2024               
  3306                                  ; 03/03/2023
  3307                                  ;YES_CHAR:	db 'Y'
  3308                                  ;NO_CHAR:	db 'N'
  3309                                  ;RETRY_CHAR:	db 'R'
  3310                                  ;ABORT_CHAR:	db 'A'
  3311                                  ;IGNORE_CHAR:	db 'I'
  3312                                  ;FAIL_CHAR:	db 'F'
  3313 00000A6B 00000000                NEEDVOL:	dd 0
  3314 00000A6F 00                      ERRTYPE:	db 0
  3315                                  
  3316                                  ; 22/09/2018 -  22/09/2018 - Retro DOS v3.0 (MSDOS 3.3) COMMAND.COM
  3317                                  
  3318                                  RETRABASE: ; 30/04/2018 (Base addr for common params, for transient portion)
  3319                                  	   ; Note: Order of following parameters must not be changed
  3320                                  	   ; without changing address references of them in 'transcom.s').	
  3321                                  
  3322 00000A70 00000000                INT_2E_RET:	DD 0		; Magic command executer return address
  3323 00000A74 0000                    SAVE_PDB:	DW 0
  3324 00000A76 0000                    PARENT:		DW 0
  3325 00000A78 00000000                OLDTERM:	dd 0
  3326 00000A7C 0000                    ERRCD_24:	DW 0
  3327 00000A7E 0000                    HANDLE01:	DW 0
  3328 00000A80 00                      LOADING:	DB 0
  3329 00000A81 0000                    BATCH:		DW 0		; Assume no batch mode initially
  3330                                  
  3331                                  ;		Bugbug:	ComSpec should be 64+3+12+1?
  3332                                  ;		What's this comspec_end about?
  3333 00000A83 00<rep 40h>             COMSPEC: times 64 DB 0
  3334 00000AC3 0000                    PUTBACKSUBSTPTR: dw 0
  3335 00000AC5 0000                    COMSPEC_END:	dw 0
  3336 00000AC7 2C01                    TRANS:		DW COMMAND
  3337 00000AC9 0000                    TRNSEG:		DW 0
  3338 00000ACB 00                      TRNMVFLG:	db 0		; set if transient portion has been moved
  3339 00000ACC 00                      IN_BATCH:	db 0		; set if we are in batch processing mode
  3340 00000ACD 00                      BATCH_ABORT:	db 0		; set if user wants to abort from batch mode
  3341                                  
  3342 00000ACE 00                      COMDRV:		DB 0		; DRIVE SPEC TO LOAD AUTOEXEC AND COMMAND
  3343 00000ACF 0000                    MEMSIZ:		DW 0
  3344 00000AD1 0000                    SUM:		DW 0
  3345 00000AD3 01                      EXTCOM:		DB 1		; For init, pretend just did an external
  3346 00000AD4 0000                    RETCODE:	DW 0
  3347 00000AD6 00                      CRIT_ERR_INFO:	db 0		; hold critical error flags for r,i,f
  3348                                  
  3349                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  3350                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  3351                                  
  3352 00000AD7 01                      ECHOFLAG:	DB 1		; low bit true => echo commands
  3353 00000AD8 01                      SUPPRESS:	db 1		; used for echo, 1=echo line
  3354 00000AD9 0000                    IO_SAVE:	DW 0
  3355 00000ADB 00                      RESTDIR:	DB 0
  3356 00000ADC 00                      PERMCOM:	DB 0		; true => permanent command
  3357 00000ADD 0000                    SINGLECOM:	DW 0		; true => single command version
  3358 00000ADF FFFF                    VERVAL:	        DW -1
  3359 00000AE1 00                      FFAIL:		db 0		; true => fail all int 24s
  3360 00000AE2 00                      IFFLAG:		db 0            ; true => IF statement in progress
  3361 00000AE3 00                      FORFLAG:	DB 0		; true => FOR statement in progress
  3362 00000AE4 0000                    FORPTR:		dw 0		
  3363 00000AE6 0000                    NEST:		dw 0		; nested batch file counter
  3364 00000AE8 00                      CALL_FLAG:	db 0		; no CALL (batch command) in progress
  3365 00000AE9 00                      CALL_BATCH_FLAG: db 0
  3366 00000AEA 0000                    NEXT_BATCH:	dw 0		; address of next batch segment
  3367 00000AEC 00                      NULLFLAG:	db 0		; flag if no command on command line
  3368                                  
  3369 00000AED 00                      UCASE_ADDR:	db 0
  3370 00000AEE 00000000                UPPERCASETBL:	dd 0
  3371                                  
  3372 00000AF2 00                      RE_OUT_APP:	db 0
  3373 00000AF3 00<rep 50h>             RE_OUTSTR: times (64+3+13) db 0
  3374                                  
  3375 00000B43 01                      INITFLAG:	DB INITINIT ; 1 ; 24/09/2018
  3376                                  
  3377                                  ; Note:  these two bytes are referenced as a word
  3378 00000B44 00                      PIPEFLAG:	DB 0
  3379 00000B45 00                      PIPEFILES:	DB 0
  3380                                  
  3381                                  ;--- 2.x data for piping
  3382                                  ;
  3383                                  ; All the "_" are substituted later, the one before the : is substituted
  3384                                  ; by the current drive, and the others by the CreateTemp call with the
  3385                                  ; unique file name. Note that the first 0 is the first char of the pipe
  3386                                  ; name. -MU
  3387                                  ;
  3388                                  ;--- Order-dependent, do not change
  3389                                  
  3390                                  ; MSDOS 3.3
  3391                                  
  3392 00000B46 5F3A2F                  PIPE1:		db "_:/"
  3393 00000B49 00                      PIPE1T:		db 0
  3394 00000B4A 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3394 00000B53 5F5F00             
  3395 00000B56 5F3A2F                  PIPE2:		db "_:/"
  3396 00000B59 00                      PIPE2T		db 0
  3397 00000B5A 5F5F5F5F5F5F5F2E5F-     		db "_______.___",0
  3397 00000B63 5F5F00             
  3398                                  
  3399                                  ; MSDOS 3.3 & MSDOS 6.0
  3400 00000B66 0000                    PIPEPTR:	dw 0
  3401 00000B68 00<rep 81h>             PIPESTR: times 129 db 0
  3402                                  
  3403                                  ; MSDOS 6.0
  3404                                  
  3405                                  ;SR
  3406                                  ; Pipe1 & Pipe2 now need to store full-fledged pathnames
  3407                                  ;
  3408                                  
  3409                                  ; Bugbug:  can we find any way around maintaining these
  3410                                  ; large buffers?
  3411                                  
  3412                                  ;Pipe1		db	67+12 dup (?)
  3413                                  ;Pipe2		db	67+12 dup (?)
  3414                                  ;PipePtr 	dw	?
  3415                                  ;PipeStr 	db	129 dup (?)
  3416                                  
  3417                                  ;EndPipe	label	byte	; marks end of buffers; M004
  3418                                  
  3419 00000BE9 [460B]                  INPIPEPTR:	dw PIPE1
  3420 00000BEB [560B]                  OUTPIPEPTR:	dw PIPE2
  3421                                  
  3422                                  ;EXEC_BLOCK LABEL BYTE		; The data block for EXEC calls
  3423                                  EXEC_BLOCK:
  3424 00000BED 0000                    ENVIRSEG:	DW 0
  3425                                  ;COM_PTR LABEL	DWORD
  3426 00000BEF 8000                    COM_PTR:	DW 80H		; Point at unformatted parameters
  3427 00000BF1 0000                    		DW 0
  3428                                  ;COM_FCB1 LABEL	DWORD
  3429 00000BF3 5C00                    COM_FCB1:      	DW 5CH
  3430 00000BF5 0000                            	DW 0
  3431                                  ;COM_FCB2 LABEL	DWORD
  3432 00000BF7 6C00                    COM_FCB2:	DW 6CH
  3433 00000BF9 0000                            	DW 0
  3434                                  
  3435                                  ;TRANVARS LABEL  BYTE		; Variables passed to transient
  3436                                  TRANVARS:
  3437                                  		;DW OFFSET RESGROUP:THEADFIX
  3438 00000BFB [AF02]                  		DW THEADFIX
  3439 00000BFD 0000                    MYSEG:		DW 0		; Put our own segment here
  3440 00000BFF 0000                    LTPA:		DW 0		; WILL STORE TPA SEGMENT HERE
  3441 00000C01 2D                      RSWITCHAR:	DB "-"
  3442 00000C02 2F                      RDIRCHAR:	DB "/"
  3443                                          	;DW OFFSET RESGROUP:EXT_EXEC
  3444 00000C03 [2D00]                  		DW EXT_EXEC
  3445 00000C05 0000                    MYSEG1:		DW 0
  3446                                  		;DW OFFSET RESGROUP:TREMCHECK
  3447 00000C07 [9402]                  		DW TREMCHECK
  3448 00000C09 0000                    MYSEG2:		DW 0
  3449                                  
  3450 00000C0B 0000                    RESTEST:	dw 0
  3451 00000C0D 0000                    RES_TPA:	DW 0		; original tpa (not rounded to 64k)
  3452                                  ;TRANVAREND	label	byte
  3453                                  TRANVAREND:
  3454 00000C0F 0000                    OLDERRNO:	dw 0
  3455                                  
  3456                                  		; Here is Offset 0D27h in original MSDOS 3.3 COMMAND.COM
  3457                                  
  3458                                  ;DATARESEND	LABEL   BYTE
  3459                                  DATARESEND:
  3460                                  		; 22/09/2018
  3461                                  
  3462                                  ;DATARES ENDS
  3463                                  ;        END
  3464                                  
  3465                                  ;=============================================================================
  3466                                  ; COMMAND.ASM (MSDOS 2.11), ENVDATA.ASM (MSDOS 6.0)
  3467                                  ;=============================================================================
  3468                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3469                                  
  3470 00000C11 90<rep Fh>              align 16
  3471                                  
  3472                                  	; Here is Offset 0D80h in original MSDOS 3.3 COMMAND.COM
  3473                                  
  3474                                  ;ENVIRONMENT SEGMENT PUBLIC PARA        ; Default COMMAND environment
  3475                                  
  3476                                  ;	PUBLIC  ECOMSPEC,ENVIREND,PATHSTRING
  3477                                  
  3478                                          ;ORG	0
  3479                                  ;ENVARENA	DB 10H DUP (?)	; Pad for mem arena
  3480 00000C20 00<rep 10h>             ENVARENA:	TIMES 16 DB 0		
  3481                                  ENVIRONMENT:			; 30/04/2018 ('command2.s')
  3482                                  	; Here is Offset 0D90h in original MSDOS 3.3 COMMAND.COM
  3483 00000C30 504154483D              PATHSTRING:	DB "PATH="
  3484                                  ;USERPATH LABEL  BYTE
  3485 00000C35 00                      USERPATH:      	DB 0		; Null path
  3486 00000C36 434F4D535045433D                	DB "COMSPEC="
  3487 00000C3E 2F434F4D4D414E442E-     ECOMSPEC:	DB "/COMMAND.COM"
  3487 00000C47 434F4D             
  3488                                          	;DB 134 DUP (0)
  3489 00000C4A 00<rep 86h>             		TIMES	134 DB 0
  3490                                  
  3491                                  ;ENVIREND	LABEL   BYTE
  3492                                  ENVIREND:
  3493                                  	; Here is Offset 0E30h in original MSDOS 3.3 COMMAND.COM
  3494                                  	
  3495                                  ENVIRONSIZ EQU  $-PATHSTRING	; 160 = 0A0h
  3496                                  ENVIRONSIZ2 EQU $-ECOMSPEC	; 146 = 092h
  3497                                  
  3498                                  ;ENVIRONMENT ENDS
  3499                                  
  3500                                  ; ENVDATA.ASM
  3501                                  ;
  3502                                  ;/*
  3503                                  ; *                      Microsoft Confidential
  3504                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3505                                  ; *                      All Rights Reserved.
  3506                                  ; */
  3507                                  ;	SCCSID = @(#)envdata.asm	1.1 85/05/14
  3508                                  ;
  3509                                  ; This file is included by init.asm and is used as the default environment.
  3510                                  ;
  3511                                  ;
  3512                                  ;Environment Struc                       ; Default COMMAND environment
  3513                                  ;
  3514                                  ;Env_PathString  db	"path="
  3515                                  ;Env_PathSpec    db     "c:\msdos"
  3516                                  ;                db     0
  3517                                  ;Env_PrmptString db     "prompt="
  3518                                  ;Env_PrmptSpec   db     "$p$g"
  3519                                  ;                db     0
  3520                                  ;Env_ComString   db     "comspec="
  3521                                  ;Env_ComSpec     db     "\command.com"
  3522                                  ;		 db	134 dup (0)
  3523                                  ;
  3524                                  ;Environment ends
  3525                                  
  3526                                  ;MAX_COMSPEC	equ     SIZE Environment - Env_ComSpec
  3527                                  
  3528                                  MAX_COMSPEC	EQU	ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3529                                  
  3530                                  ;-----------------------------------------------------------------------------
  3531                                  ; 24/09/2018 - RetRo DOS v3.0
  3532                                  ;ENDCODE:
  3533                                  INITSTART:	; End of rezident code and data
  3534                                  		; (Offset 0E30h in original MSDOS 3.3 COMMAND.COM)
  3535                                  ;-----------------------------------------------------------------------------
  3536                                  
  3537                                  ;=============================================================================
  3538                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  3539                                  ;=============================================================================
  3540                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  3541                                  
  3542                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  3543                                  
  3544                                  ;TITLE   COMMAND Initialization
  3545                                  
  3546                                  ;ENVIRONSIZ EQU  0A0H		;Must agree with values in ENVIRONMENT segment
  3547                                  ;ENVIRONSIZ2 EQU 092H
  3548                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  3549                                  
  3550                                  ; UINIT.ASM, MSDOS 6.0, 1991
  3551                                  ; 23/09/2018
  3552                                  ENVBIG	EQU	32768			;AN000; maximum environment size
  3553                                  ENVSML	EQU	160			;AN000; minimum environment size
  3554                                  
  3555                                  ;-----------------------------------------------------------------------------
  3556                                  ; START OF INIT PORTION
  3557                                  ; This code is deallocated after initialization.
  3558                                  ;-----------------------------------------------------------------------------
  3559                                  
  3560                                  ;INIT    SEGMENT PUBLIC PARA
  3561                                  
  3562                                  ; 	EXTRN   HEADER:BYTE
  3563                                  ;	EXTRN   BADCOMLKMES:BYTE
  3564                                  
  3565                                  ;	PUBLIC  CONPROC
  3566                                  
  3567                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  3568                                  
  3569                                          ;ORG 0
  3570                                  ;ZERO = $
  3571                                  	; 23/09/2018
  3572                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  3573                                  
  3574                                  CONPROC:
  3575                                  	;MOV	SP,OFFSET RESGROUP:RSTACK	; must be first instruction
  3576 00000CD0 BC[2C07]                	MOV	SP,RSTACK
  3577                                  ;
  3578                                  ; We need to set the PSP to us right at start because Carousel needs
  3579                                  ; to be lied to and it does not set PSP when it transfers control to
  3580                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  3581                                  ; command.com is also not lied to.
  3582                                  ;
  3583                                  	; MSDOS 6.0
  3584                                          ;mov     ah,SET_CURRENT_PDB
  3585                                          ;mov     bx,es
  3586                                          ;int     21h
  3587                                  
  3588 00000CD3 B80030                          mov     ax,GET_VERSION<<8 ; 30h
  3589 00000CD6 CD21                    	int	21h
  3590 00000CD8 3D031E                  	cmp	ax,EXPECTED_VERSION ; 1E03h
  3591 00000CDB 7412                    	je	short OKDOS			; DOS version is ok
  3592                                  
  3593 00000CDD BA[1714]                	mov	dx,BADVERMSG			; DX = ptr to msg
  3594                                  	;call	RPrint
  3595                                  
  3596                                  	; MSDOS 3.3
  3597 00000CE0 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
  3598 00000CE2 CD21                    	int	21h             ; DOS - PRINT STRING
  3599                                  				; DS:DX -> string terminated by "$"
  3600 00000CE4 8CC0                    	mov	ax,es
  3601 00000CE6 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  3602                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  3603 00000CEB 74FE                    HERE:	jz	short HERE			;  loop forever
  3604                                  	
  3605 00000CED CD20                    	int	20h				; otherwise, exit
  3606                                  OKDOS:
  3607                                  	; 23/09/2018
  3608                                  ;
  3609                                  ;  Calculate and save the end of the INIT segment (which is also
  3610                                  ;  the beginning of TRANGROUP).
  3611                                  ;
  3612                                  	; MSDOS 3.3
  3613 00000CEF B465                    	mov	ah,65h
  3614 00000CF1 B002                    	mov	al,2
  3615 00000CF3 BAFFFF                  	mov	dx,-1
  3616 00000CF6 BBFFFF                  	mov	bx,-1
  3617 00000CF9 B90500                  	mov	cx,5
  3618 00000CFC BF[ED0A]                	mov	di,UCASE_ADDR
  3619 00000CFF CD21                    	int     21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  3620                                  			; AL = 02h : Get pointer to character translation table
  3621                                  			; BX = code page (-1 = current global code page)
  3622                                  			; DX = country ID (-1 = current country)
  3623                                  			; CX = amount of data to return
  3624                                  	; ES:DI = pointer to output buffer
  3625                                  	; Buffer offset :
  3626                                  	;	00h -  byte,  country Id
  3627                                  	;  	01h -  dword, pointer to uppercase table	
  3628                                  
  3629                                  	; MSDOS 6.0 (& MSDOS 3.3)
  3630 00000D01 BA[EF14]                  	mov	dx,TRANSTART+15			; get end of init code
  3631                                  	; 27/09/2018
  3632                                          ;mov	dx,TRANSTART ; (paragraph aligned address)
  3633 00000D04 B104                    	mov	cl,4				; change to paragraphs
  3634 00000D06 D3EA                            shr	dx,cl				;
  3635 00000D08 8CC8                            mov     ax,cs                           ; get current segment
  3636 00000D0A 01D0                            add     ax,dx                           ; calculate segment of end of init
  3637 00000D0C A3[A314]                        mov     [INITEND],ax			; save this
  3638                                  
  3639 00000D0F A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h ; Init PARENT so we can exit
  3640 00000D12 A3[760A]                	mov	[PARENT],ax			    ;  correctly.
  3641 00000D15 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  3642 00000D18 A3[780A]                	mov	[OLDTERM],ax
  3643 00000D1B A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  3644 00000D1E A3[7A0A]                	mov	[OLDTERM+2],ax
  3645                                  
  3646                                  	;mov	ax,ENDCODE+15
  3647 00000D21 B8[DF0C]                	mov	ax,INITSTART+15 ; 24/09/2018
  3648 00000D24 B104                    	mov	cl,4				; ax = size of resident part of
  3649 00000D26 D3E8                    	shr	ax,cl				;  command in paragraphs. Add
  3650 00000D28 8CC9                    	mov	cx,cs				;  this to CS and you get the
  3651 00000D2A 01C8                    	add	ax,cx				;  segment of the TPA.
  3652                                  	
  3653 00000D2C A3[0D0C]                	mov     [RES_TPA],ax			; Temporarily save the TPA segment
  3654 00000D2F 2500F0                  	and     ax,0F000h
  3655 00000D32 050010                  	add     ax,1000h			; Round up to next 64K boundary
  3656 00000D35 7303                    	jnc     short TPA_SET			; Memory wrap if carry set
  3657 00000D37 A1[0D0C]                	mov     ax,[RES_TPA]
  3658                                  TPA_SET:
  3659 00000D3A A3[FF0B]                	mov	[LTPA],ax			; Good enough for the moment
  3660 00000D3D A10200                  	mov	ax,[PDB.BLOCK_LEN] ; mov ax,ds:2 ; ax = # of paras given to command
  3661                                  
  3662 00000D40 8C1E[050C]              	mov	[MYSEG1],ds			; These 3 variables are used as part of
  3663 00000D44 8C1E[090C]              	mov	[MYSEG2],ds			;  3 long ptrs that the transient will
  3664 00000D48 8C1E[FD0B]              	mov	[MYSEG],ds			;  use to call resident routines.
  3665                                  
  3666 00000D4C A3[CF0A]                        mov     [MEMSIZ],ax			; Needed for execing other programs
  3667                                  ;
  3668                                  ; Compute maximum size of environment
  3669                                  ;
  3670                                  	;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  3671 00000D4F C706[9D14]4400                  mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  3672                                  ;
  3673                                  ; Compute minimum size of environment
  3674                                  ;
  3675                                  	;mov	word [ENVSIZ],10 ; = 160/16
  3676 00000D55 C706[9B14]0A00          	mov	word [ENVSIZ],ENVSML/16; 
  3677                                  
  3678                                  	;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  3679 00000D5B BA414C                  	mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  3680 00000D5E B104                    	mov	cl,4				;  in paragraphs.
  3681 00000D60 D3EA                    	shr	dx,cl
  3682 00000D62 8916[A514]                      mov     [TRNSIZE],dx			; save size of transient in paragraphs
  3683                                  
  3684 00000D66 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  3685 00000D68 A3[C90A]                	mov	[TRNSEG],ax			;  = seg addr to load the transient at.
  3686 00000D6B A12C00                  	mov	ax,[PDB.ENVIRON] ; mov ax,ds:2Ch ; ax = environment segment
  3687                                  
  3688                                          ; MSDOS 6.0
  3689                                  	;mov	EnvirSeg,ax			;
  3690                                          ;or	ax,ax				; if there is no environment segment,
  3691                                          ;jz	buildenv			; make one
  3692                                  	;
  3693                                          ;cmp	FirstCom,0			; if this is the first command.com,
  3694                                  	;je	environpassed			; do a merge job (make sure COMSPEC exists)
  3695                                  
  3696                                  	; MSDOS 3.3
  3697 00000D6E 09C0                    	or	ax,ax
  3698 00000D70 7406                    	jz	short BUILDENV
  3699 00000D72 FE06[9014]                      inc	byte [CHUCKENV]			; Flag no ENVIRONSEG
  3700 00000D76 EB0B                            jmp	short ENVIRONPASSED
  3701                                  
  3702                                  	; MSDOS 6.0
  3703                                  ;
  3704                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  3705                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  3706                                  ; size and free this buffer. We need this buffer because we no longer have an
  3707                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  3708                                  ; given on the command line before we know the environment size. This routine
  3709                                  ; will not return in case of an allocation error. It will either exit or hang
  3710                                  ; depending on whether or not this is the first COMMAND.COM or not.
  3711                                  ;
  3712                                  ;buildenv:
  3713                                  ;	call	alloc_env                       ; try to allocate buffer
  3714                                  ;environpassed:
  3715                                  ;	mov	es,ax                           ; and it load into es.
  3716                                  ;	assume	es:nothing
  3717                                  ;
  3718                                  ;gottheenvir:
  3719                                  ;;
  3720                                  ;; Initialize the command drive
  3721                                  ;;
  3722                                  	; MSDOS 3.3
  3723                                  BUILDENV:
  3724                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  3725 00000D78 B8[300C]                	mov	ax,PATHSTRING ; "PATH="
  3726 00000D7B B104                    	mov	cl,4
  3727 00000D7D D3E8                    	shr	ax,cl
  3728 00000D7F 8CDA                    	mov	dx,ds
  3729 00000D81 01D0                    	add	ax,dx
  3730                                  
  3731                                  ENVIRONPASSED:
  3732 00000D83 A3[ED0B]                	mov	[ENVIRSEG],ax
  3733                                  
  3734 00000D86 8EC0                    	mov	es,ax
  3735                                  
  3736                                  	;mov	ax,CHAR_OPER<<8
  3737 00000D88 B80037                  	mov	ax,CHAR_OPER*256 ; 3700h
  3738 00000D8B CD21                    	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3739                                  			; Return: AL = FFh unsupported subfunction
  3740                                  			; DL = current switch character
  3741 00000D8D 8816[010C]              	mov	[RSWITCHAR],dl
  3742                                  
  3743                                  	; 02/03/2023
  3744 00000D91 80FA2F                  	cmp	dl,'/'
  3745                                  	;cmp	dl,[slash_chr]
  3746 00000D94 7510                    	jnz	short IUSESLASH
  3747 00000D96 B05C                    	mov	al,'\'
  3748                                  	;mov	al,[bslash_chr]
  3749 00000D98 A2[6514]                	mov	[COMSPECT],al
  3750                                  
  3751 00000D9B 803E[9014]00            	cmp	byte [CHUCKENV],0
  3752 00000DA0 7504                    	jnz	short IUSESLASH
  3753                                  
  3754                                  	;mov	ES:[ECOMSPEC-10h],'\'
  3755                                  	; 30/04/2018
  3756                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  3757                                  	; 23/09/2018
  3758 00000DA2 26A20E00                	mov	[ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  3759                                  
  3760                                  ;gottheenvir:
  3761                                  IUSESLASH:
  3762                                  ;
  3763                                  ; Initialize the command drive
  3764                                  ;
  3765                                  	; MSDOS 3.3 & MSDOS 6.0
  3766 00000DA6 B419                    	mov	ah,GET_DEFAULT_DRIVE	; 19h
  3767 00000DA8 CD21                    	int	21h
  3768 00000DAA FEC0                    	inc	al
  3769 00000DAC A2[CE0A]                	mov	[COMDRV],al
  3770                                  
  3771                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  3772 00000DAF A05C00                          mov	al,[FCB]
  3773 00000DB2 08C0                    	or	al,al
  3774 00000DB4 7426                    	jz	short NOCOMDRV		; no drive specified
  3775                                  
  3776 00000DB6 B43A                    	mov	ah,':'
  3777 00000DB8 A2[CE0A]                	mov	[COMDRV],al
  3778 00000DBB 0440                    	add	al,40h			; convert number to uppercase character
  3779                                  
  3780 00000DBD FD                      	std
  3781                                  
  3782                                  	; MSDOS 6.0
  3783                                          ;cmp	AllocedEnv,0		; if a new environment is being built,
  3784                                  	;je	notwidenv		;  move the default comspec string in it
  3785                                  	;mov	di,ComspOffset
  3786                                          ;cmp	byte ptr es:[di+1],':'	; drive specifier already exist?
  3787                                          ;je	notwidenv               ; yes, must have been inherited that way
  3788                                  
  3789                                  	; MSDOS 3.3
  3790 00000DBE 803E[9014]00                    cmp	byte [CHUCKENV],0
  3791 00000DC3 7513                    	jne	short NOTWIDENV
  3792                                  
  3793 00000DC5 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  3794 00000DC6 06                      	push	es			;  the drivespec is in ax and is copied
  3795 00000DC7 1F                      	pop	ds			;  on to the front of the string.
  3796                                  
  3797                                  	; MSDOS 6.0
  3798                                          ;lea	si,[di+MAX_COMSPEC-3]	
  3799                                          ;lea	di,[di+MAX_COMSPEC-1]
  3800                                  
  3801                                  	; MSDOS 3.3
  3802                                  	; 23/09/2018
  3803                                  	; 30/04/2018
  3804                                  	;mov	di,159
  3805                                  	;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  3806 00000DC8 BF9F00                          mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  3807                                  	;mov	si,157
  3808                                  	;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  3809 00000DCB BE9D00                          mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  3810                                  	;mov	cx,144
  3811                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  3812 00000DCE B99000                          mov     cx,MAX_COMSPEC-2
  3813                                  
  3814 00000DD1 F3A4                    	rep	movsb
  3815 00000DD3 1F                      	pop	ds
  3816                                  
  3817                                  	; MSDOS 6.0
  3818                                  	;mov	word ptr es:[di-1],ax
  3819                                  
  3820                                  	; MSDOS 3.3
  3821                                  	;mov	es:0Eh,ax
  3822                                  	;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  3823 00000DD4 26A30E00                	mov	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  3824                                  
  3825                                  	; MSDOS 3.3 & MSDOS 6.0
  3826                                  NOTWIDENV:
  3827 00000DD8 FC                      	cld
  3828                                  
  3829 00000DD9 A3[7314]                	mov    [AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  3830                                  
  3831                                  NOCOMDRV:
  3832 00000DDC E8FDF5                          CALL    SETVECT         ; Set the vectors
  3833                                  
  3834                                  	; MSDOS 3.3
  3835 00000DDF BE8000                  	mov	si,80h		; get command line
  3836 00000DE2 AC                      	lodsb			; get length of line
  3837 00000DE3 88C1                    	mov	cl,al
  3838 00000DE5 30ED                    	xor	ch,ch		; cx = length of command line
  3839                                  ;
  3840                                  ; insure that the command line correctly ends with a cr
  3841                                  ;
  3842 00000DE7 01CE                    	add	si,cx		; go to end of command line	
  3843 00000DE9 C6040D                  	mov	byte [si], 0Dh	; insert a carriage return
  3844                                  
  3845 00000DEC BE8100                  	mov	si,81h		; Start of parms
  3846                                  CHKARG:
  3847 00000DEF E361                            jcxz	COMRETURNSJ     ; No parameters
  3848 00000DF1 49                              dec	cx
  3849 00000DF2 AC                      	lodsb
  3850                                  CHECKSWITCHCHR:
  3851                                  	; 02/03/2023
  3852 00000DF3 3C20                    	cmp	al,' ' ; 20h
  3853                                  	;cmp	al,[space_chr]	 ;Skip blank spaces
  3854 00000DF5 74F8                    	jz	short CHKARG
  3855 00000DF7 3C09                    	cmp	al,9		; Skip TAB characters
  3856 00000DF9 74F4                    	jz	short CHKARG
  3857 00000DFB 3A06[010C]              	cmp	al,[RSWITCHAR]	; Switch?
  3858 00000DFF 7403                    	jz	short PARSE_CONT ; Yes, get the char after the switch
  3859 00000E01 E9CE00                  	jmp	CHKOTHERARGS	; No
  3860                                  
  3861                                  PARSE_CONT:
  3862                                  ;
  3863                                  ; See if a switch was entered
  3864                                  ;
  3865 00000E04 E34C                    	jcxz	COMRETURNSJ
  3866 00000E06 49                      	dec	cx
  3867 00000E07 AC                      	lodsb
  3868 00000E08 0C20                    	or	al,20h		; Lower case
  3869 00000E0A 3C66                    	cmp	al,'f'		; FAIL switch
  3870 00000E0C 7507                    	jnz     short CHECKPSWITCH
  3871                                  	
  3872                                  	; MSDOS 6.0
  3873                                  ;SetFSwitch:
  3874                                  	;cmp	fFail,-1		; has fail switch been set?
  3875                                  	;jnz	failok			; no - set it
  3876                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3877                                          ;jmp	parse_line_error        ; go issue error 
  3878                                  
  3879                                  	; MSDOS 3.3 & MSDOS 6.0
  3880                                  FAIL_OK:
  3881 00000E0E C606[E10A]FF            	mov	byte [FFAIL],-1	; fail all INT 24s.
  3882                                  	; MSDOS 3.3
  3883 00000E13 EBDA                    	jmp	short CHKARG
  3884                                  
  3885                                  CHECKPSWITCH:
  3886                                  	; 02/03/2023
  3887 00000E15 3C70                    	cmp	al,'p'		; Permanent COMMAND switch
  3888                                  	;cmp	al,[letter_p]
  3889 00000E17 751C                            jnz	short CHECKDSWITCH
  3890                                  
  3891                                  SETPSWITCH:
  3892                                  ;
  3893                                  ; We have a permanent COMMAND switch /P.  Flag this and stash the
  3894                                  ; termination address.
  3895                                  ;
  3896                                  	; MSDOS 6.0
  3897                                  	;cmp	PermCom,0		; has /p switch been set?
  3898                                  	;jz	permcomok		; no - set it
  3899                                          ;mov	ax,moreargs_ptr		; set up too many arguments
  3900                                          ;jmp	parse_line_error 		; go issue error 
  3901                                  ;permcomok:
  3902                                  	; MSDOS 3.3 & MSDOS 6.0
  3903 00000E19 FE06[DC0A]              	inc	byte [PERMCOM]
  3904 00000E1D C706[780A][AD01]        	mov     word [OLDTERM],LODCOM
  3905 00000E23 8C1E[7A0A]              	mov     [OLDTERM+2],ds
  3906                                  ;
  3907                                  ; make sure that we display the date and time. if the flag was not
  3908                                  ; initialized, set it to indicate yes, do prompt.
  3909                                  ;
  3910                                  	; MSDOS 3.3
  3911 00000E27 803E[8314]FF            	cmp     byte [PRDATTM],-1
  3912 00000E2C 75C1                    	jnz     short CHKARG
  3913 00000E2E C606[8314]00            	mov     byte [PRDATTM],0
  3914 00000E33 EBBA                    	jmp     short CHKARG
  3915                                  
  3916                                  ;COMRETURNSJ:
  3917                                  ;	; MSDOS 3.3
  3918                                  ;	JMP	ARGSDONE
  3919                                  
  3920                                  CHECKDSWITCH:
  3921                                  	; 02/03/2023
  3922 00000E35 3C64                    	cmp	al,'d'
  3923                                          ;cmp	al,[letter_d]
  3924 00000E37 7507                    	jnz     short CHECKCSWITCH
  3925                                  SETDSWITCH:
  3926                                  ;
  3927                                  ; Flag no date/time prompting.
  3928                                  ;
  3929                                  	; MSDOS 6.0
  3930                                  	;cmp	Dswitch,0		; has /D switch been set?
  3931                                  	;jz	setdateok		; no - set it
  3932                                          ;mov	ax,Moreargs_ptr	; set up too many arguments
  3933                                          ;jmp	parse_line_error	; go issue error message
  3934                                  ;setdateok:
  3935                                  	;inc	Dswitch 		; indicate /D entered
  3936                                  
  3937                                  	; MSDOS 3.3 & MSDOS 6.0
  3938 00000E39 C606[8314]01                    mov	byte [PRDATTM],1  ; User explicitly says no date time
  3939                                  	; MSDOS 3.3
  3940 00000E3E EBAF                    	jmp	short CHKARG
  3941                                  
  3942                                  CHECKCSWITCH:
  3943                                  	; 02/03/2023
  3944 00000E40 3C63                            cmp	al,'c'
  3945                                  	;cmp	al,[letter_c]
  3946 00000E42 7511                            jnz	short CHECKESWITCH
  3947                                  
  3948                                  ;SetSSwitch:
  3949                                  SETCSWITCH:
  3950                                  ;
  3951                                  ; Set up pointer to command line, flag no date/time and turn off singlecom.
  3952                                  ;
  3953 00000E44 C606[DC0A]00            	mov	byte [PERMCOM],0	; A SINGLECOM must not be a PERMCOM
  3954 00000E49 8936[DD0A]              	mov	[SINGLECOM],si		; Point to the rest of the command line
  3955                                  	;mov	byte [PERMCOM],0
  3956 00000E4D C606[8314]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  3957                                  COMRETURNSJ: ; 24/09/2018
  3958 00000E52 E96301                  	jmp	ARGSDONE
  3959                                  
  3960                                  CHECKESWITCH:
  3961 00000E55 3C65                    	cmp     al,'e'
  3962 00000E57 7596                    	jnz     short CHKARG
  3963                                  ;
  3964                                  ; Look for environment-size setting switch
  3965                                  ;
  3966                                  ; The environment size is represented in decimal bytes and is
  3967                                  ; converted into paragraphs (rounded up to the next paragraph).
  3968                                  ;
  3969                                  SETESWITCH:
  3970                                  	; MSDOS 6.0
  3971                                  	;cmp	Eswitch,0		; has environment size switch been set?
  3972                                  	;jz	eswitchok		; no - set it
  3973                                          ;mov	ax,Moreargs_ptr         ; set up too many arguments
  3974                                          ;jmp	Parse_line_error	; go issue error message
  3975                                  ;eswitchok:
  3976                                  	;inc	Eswitch			; indicate /E entered 	
  3977                                  
  3978                                  	; 23/09/2018 - Retro DOS v3.0
  3979                                  
  3980                                  	; MSDOS 3.3
  3981                                  	; (COMMAND.COM offset 0FC5h)
  3982                                  ESWITCHOK:
  3983 00000E59 E394                    	jcxz    CHKARG
  3984 00000E5B 49                      	dec     cx
  3985 00000E5C AC                      	lodsb
  3986 00000E5D 3C3A                    	cmp     al,':'
  3987 00000E5F 7592                    	jnz     short CHECKSWITCHCHR
  3988 00000E61 31DB                    	xor     bx,bx
  3989 00000E63 89D8                    	mov     ax,bx
  3990                                  GETENVSIZE:
  3991 00000E65 E338                    	jcxz    SETENVSIZE
  3992 00000E67 49                      	dec     cx
  3993 00000E68 AC                      	lodsb
  3994 00000E69 3C30                    	cmp     al,'0'
  3995 00000E6B 7214                    	jb      short NOTDECIMALCHR
  3996 00000E6D 3C39                    	cmp     al,'9'
  3997 00000E6F 7710                    	ja      short NOTDECIMALCHR
  3998 00000E71 2C30                    	sub     al,'0'
  3999 00000E73 89DA                    	mov     dx,bx
  4000 00000E75 D1E2                    	shl     dx,1
  4001 00000E77 D1E2                    	shl     dx,1   ; dx = 4*bx	
  4002 00000E79 01D3                    	add     bx,dx  ; bx = 5*bx
  4003 00000E7B D1E3                    	shl     bx,1   ; bx = 10*bx	
  4004 00000E7D 01C3                    	add     bx,ax
  4005 00000E7F EBE4                    	jmp     short GETENVSIZE
  4006                                  
  4007                                  NOTDECIMALCHR:
  4008                                  	; 02/03/2023
  4009 00000E81 3C20                    	cmp	al,' ' ; 20h
  4010                                  	;cmp	al,[space_chr]
  4011 00000E83 7418                    	jz      short CHECKENVSIZE
  4012                                  	;cmp	al,'/'
  4013 00000E85 3A06[010C]              	cmp     al,[RSWITCHAR]
  4014 00000E89 7412                    	jz      short CHECKENVSIZE
  4015                                  
  4016                                  CHECKNEXTECHR:
  4017 00000E8B E33B                    	jcxz    INVENVSIZE
  4018 00000E8D 49                      	dec     cx
  4019 00000E8E AC                      	lodsb
  4020                                  	; 02/03/2023
  4021 00000E8F 3C20                    	cmp	al,' ' ; 20h
  4022                                  	;cmp	al,[space_chr]
  4023 00000E91 7406                    	jz      short ENVSIZESPC
  4024                                  	;cmp	al,'/'
  4025 00000E93 3A06[010C]              	cmp     al,[RSWITCHAR]
  4026 00000E97 75F2                    	jnz     short CHECKNEXTECHR
  4027                                  
  4028                                  ENVSIZESPC:
  4029 00000E99 4E                      	dec     si
  4030 00000E9A 41                      	inc     cx
  4031 00000E9B EB2B                    	jmp     short INVENVSIZE
  4032                                  	
  4033                                  	;nop
  4034                                  
  4035                                  CHECKENVSIZE: 
  4036 00000E9D 4E                      	dec     si
  4037 00000E9E 41                      	inc     cx
  4038                                  
  4039                                  SETENVSIZE:
  4040                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  4041 00000E9F C706[9B14]0008          	mov	word [ENVSIZ],ENVBIG/16
  4042 00000EA5 81FB0080                	cmp     bx,32768
  4043 00000EA9 771D                    	ja      short INVENVSIZE
  4044                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  4045 00000EAB C706[9B14]0A00          	mov	word [ENVSIZ],ENVSML/16
  4046 00000EB1 81FBA000                	cmp     bx,160
  4047 00000EB5 7211                    	jb      short INVENVSIZE
  4048 00000EB7 83C30F                  	add     bx,15
  4049 00000EBA D1EB                    	shr     bx,1
  4050 00000EBC D1EB                    	shr     bx,1
  4051 00000EBE D1EB                    	shr     bx,1
  4052 00000EC0 D1EB                    	shr     bx,1
  4053 00000EC2 891E[9B14]              	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  4054 00000EC6 EB07                    	jmp     short NEXTCH2
  4055                                  
  4056                                  	;nop
  4057                                  
  4058                                  INVENVSIZE:
  4059 00000EC8 BA[2F14]                	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  4060 00000ECB B409                    	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4061 00000ECD CD21                    	int     21h             ; DOS - PRINT STRING
  4062                                  				; DS:DX -> string terminated by "$"
  4063                                  NEXTCH2:
  4064                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  4065 00000ECF E91DFF                  	jmp     CHKARG
  4066                                  
  4067                                  	;jmp	ARGSDONE
  4068                                  
  4069                                  CHKOTHERARGS:
  4070                                  ;
  4071                                  ; We have a non-switch character here.
  4072                                  ;
  4073                                  	; MSDOS 6.0
  4074                                  ;	push	ds ; ***			;
  4075                                  ;	push	si ; **** 			; save place in command line
  4076                                  ;	lds	si,Comnd1_Addr			; get address of filespec
  4077                                  ;	assume	ds:nothing			;
  4078                                  ;
  4079                                  ;	mov	dx,si				; put in dx also
  4080                                  ;       mov     ax,(OPEN shl 8) or 2            ; Read and write
  4081                                  ;	int	21h
  4082                                  ;	jc	ChkSrchSpec			; Wasn't a file
  4083                                  ;	mov	bx,ax
  4084                                  ;	mov	ax,IOCTL shl 8
  4085                                  ;	int	21h
  4086                                  ;	test	dl,80h
  4087                                  ;	jnz	IsaDevice
  4088                                  ;
  4089                                  ;BadSetCon:					;
  4090                                  ;	mov	ah,CLOSE			; Close initial handle, wasn't a device
  4091                                  ;	int	21h
  4092                                  ;	jmp	short ChkSrchSpec
  4093                                  
  4094                                  	; MSDOS 3.3
  4095                                  	; (COMMAND.COM offset 1047h)
  4096 00000ED2 4E                              dec	si
  4097 00000ED3 41                      	inc	cx
  4098 00000ED4 89F2                    	mov	dx,si
  4099 00000ED6 51                      	push	cx ; *
  4100 00000ED7 56                      	push	si ; **
  4101                                  CONTRLOOP:
  4102 00000ED8 AC                      	lodsb
  4103 00000ED9 49                      	dec	cx
  4104                                  	; 02/03/2023
  4105 00000EDA 3C20                    	cmp	al,' ' ; 20h
  4106                                  	;cmp	al,[space_chr]
  4107 00000EDC 7409                    	jz	short SETCDEV
  4108 00000EDE 3C09                    	cmp	al,9
  4109 00000EE0 7405                    	jz	short SETCDEV
  4110 00000EE2 E302                    	jcxz	SETCDEVA
  4111 00000EE4 EBF2                    	jmp	short CONTRLOOP
  4112                                  
  4113                                  SETCDEVA:
  4114 00000EE6 46                              inc	si
  4115                                  SETCDEV:
  4116 00000EE7 C644FF00                	mov	byte [SI-1],0
  4117                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  4118 00000EEB B8023D                          mov	ax,(OPEN*256) | 2 ; 3D02h
  4119 00000EEE CD21                            int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  4120                                  			; DS:DX -> ASCIZ filename
  4121                                  			; AL = access mode
  4122                                  			; 2 - read & write
  4123 00000EF0 7247                            jc	short CHKSRCHSPEC	; Wasn't a file
  4124 00000EF2 89C3                            mov	bx,ax
  4125                                          ;mov	ax,IOCTL shl 8
  4126 00000EF4 B80044                          mov     ax,IOCTL*256 ; 4400h
  4127 00000EF7 CD21                    	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  4128                                  			; BX = file or device handle
  4129 00000EF9 F6C280                          test	dl,80H
  4130 00000EFC 7506                    	jnz	short ISADEVICE
  4131                                  BADSETCON: ; MSDOS 6.0
  4132 00000EFE B43E                    	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  4133 00000F00 CD21                            int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  4134                                  			; BX = file handle
  4135 00000F02 EB35                            JMP     short CHKSRCHSPEC
  4136                                  
  4137                                  	;nop
  4138                                  
  4139                                  ISADEVICE:
  4140                                  	; MSDOS 3.3 & MSDOS 6.0
  4141 00000F04 30F6                    	xor	dh,dh
  4142 00000F06 80CA03                  	or	dl,3				; Make sure has CON attributes
  4143                                  	;mov	ax,(IOCTL shl 8) or 1
  4144 00000F09 B80144                  	mov	ax,(IOCTL*256) | 1 ; 4401h
  4145 00000F0C CD21                    	int	21h
  4146                                  	;
  4147                                  	; 25/09/2018
  4148 00000F0E 5A                      	pop	dx ; **
  4149 00000F0F 5A                      	pop	dx ; *
  4150                                  	;
  4151 00000F10 72EC                    	jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  4152 00000F12 89DA                    	mov	dx,bx				; Save new handle
  4153                                  
  4154                                  	; MSDOS 6.0
  4155                                  	;cmp	es:DevFlag,1
  4156                                  	;jz	DevErr
  4157                                  
  4158                                  	; MSDOS 3.3
  4159                                          ;pop	bx ; **				; Throw away saved SI
  4160                                          ;pop	bx ; *				; Throw away saved CX
  4161                                  
  4162                                  	; MSDOS 3.3 & MSDOS 6.0
  4163 00000F14 51                      	push	cx
  4164 00000F15 B90300                  	mov	cx,3
  4165 00000F18 31DB                    	xor	bx,bx
  4166                                  RCCLLOOP:
  4167 00000F1A B43E                    	mov	ah,CLOSE ; 3Eh
  4168 00000F1C CD21                    	int	21h
  4169 00000F1E 43                      	inc	bx
  4170 00000F1F E2F9                    	loop	RCCLLOOP
  4171                                  
  4172 00000F21 89D3                    	mov	bx,dx				; New device handle
  4173 00000F23 B445                    	mov	ah,XDUP ; 45h
  4174 00000F25 CD21                    	int	21h				; Dup to 0
  4175 00000F27 B445                    	mov	ah,XDUP
  4176 00000F29 CD21                    	int	21h				; Dup to 1
  4177 00000F2B B445                    	mov	ah,XDUP
  4178 00000F2D CD21                    	int	21h				; Dup to 2
  4179 00000F2F B43E                    	mov	ah,CLOSE
  4180 00000F31 CD21                    	int	21h				; Close initial handle
  4181                                  	
  4182 00000F33 59                      	pop	cx
  4183                                  	
  4184                                  	; MSDOS 6.0
  4185                                  	;pop	si ; ****			; restore position of command line
  4186                                  	;pop	ds ; ***			;
  4187                                  ;
  4188                                  ; Register the fact that we already have redirected the output and cannot do
  4189                                  ; it again
  4190                                  ;
  4191                                  	;inc	es:DevFlag			;
  4192                                          ;jmp	Parse_command_line		; continue parsing
  4193                                  
  4194                                  	; MSDOS 3.3
  4195 00000F34 E35E                    	jcxz	ARGSDONEJ2
  4196 00000F36 E9B6FE                  	jmp	CHKARG
  4197                                  
  4198                                  	; MSDOS 6.0
  4199                                  ;DevErr:
  4200                                  	;pop	si ; ****
  4201                                  	;pop	ds ; ***
  4202                                  	;mov	dx,1
  4203                                          ;call	RPrintParse                     ; "Too many parameters"
  4204                                          ;call	CrLf
  4205                                  	;jmp	Parse_command_line
  4206                                  
  4207                                  CHKSRCHSPEC:                    ; Not a device, so must be directory spec
  4208                                  
  4209                                  	; MSDOS 6.0
  4210                                          ;cmp	es:PathFlag,1			; already set COMSPEC?
  4211                                          ;jz	DevErr				; yes, error
  4212                                  	;
  4213                                          ;inc	es:PathFlag			; mark that we have a path
  4214                                  ;
  4215                                  ; We have to override the passed environment. Allocate a buffer for use now.
  4216                                  ; This buffer will later be replaced by a proper environment
  4217                                  ;
  4218                                  	;call	alloc_env                       ; environment buffer
  4219                                  	;mov	es,ax
  4220                                  	;assume	es:nothing
  4221                                  	;push	si				; remember location of file
  4222                                  	;xor	cx,cx				; clear cx for counting
  4223                                  
  4224                                  ;countloop:
  4225                                  	;lodsb					; get a character
  4226                                  	;inc	cx				; increment counter
  4227                                          ;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  4228                                  	;jnz	countloop			; no - keep counting
  4229                                  	;
  4230                                  	;mov	al,Space
  4231                                  	;dec	si				; move back one
  4232                                          ;mov	byte ptr [si],al                ; put a space at end of line
  4233                                  ;
  4234                                  ; We now know how long the new pathspec for command.com is.  Time to
  4235                                  ; figure out how long the current COMSPEC setting is, and then to move
  4236                                  ; all the environment data up, throwing that COMSPEC setting away, and
  4237                                  ; preparing to append the new COMSPEC.  ComspOffset (the offset of
  4238                                  ; where the filespec exists in the environment) is updated as well.
  4239                                  ;
  4240                                  	;push	cx                              ;
  4241                                          ;mov	cx,ENVBIG                       ;
  4242                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  4243                                          ;mov	al,0                            ;
  4244                                          ;repne	scasb                           ; find the end of COMSPEC
  4245                                          ;mov	si,di                           ;
  4246                                  ;comp_endenv:                                   ;
  4247                                          ;scasb                                  ; end of env?
  4248                                          ;je	got_endenv                      ; yes
  4249                                          ;repne	scasb                           ;
  4250                                          ;jmp	comp_endenv                     ;
  4251                                  ;got_endenv:                                    ;
  4252                                          ;mov    cx,di                           ;
  4253                                          ;sub    cx,si                           ;
  4254                                          ;mov    di,ComspOffset                  ;
  4255                                          ;sub    di,ComspStrLen                  ;
  4256                                          ;push   ds                              ;
  4257                                          ;push   es                              ;
  4258                                          ;pop    ds                              ;
  4259                                          ;rep    movsb                           ;
  4260                                          ;dec    di                              ; copy in new COMSPEC=
  4261                                          ;push   cs                              ;
  4262                                          ;pop    ds                              ;
  4263                                          ;assume ds:ResGroup                     ;
  4264                                          ;mov    si,offset RESGROUP:ComspString  ;
  4265                                          ;mov    cx,ComspStrLen                  ;
  4266                                          ;rep    movsb                           ;
  4267                                          ;mov    ComspOffset,di                  ;
  4268                                          ;pop    ds                              ;
  4269                                          ;assume ds:nothing                      ;
  4270                                          ;pop    cx                              ;
  4271                                  	;
  4272                                          ;pop    si                              ; get new comspec location back
  4273                                  
  4274                                  	; MSDOS 3.3
  4275 00000F39 C606[9014]00            	mov     byte [CHUCKENV],0	; If search specified -- no inheritance
  4276 00000F3E B8[300C]                	mov     ax,PATHSTRING ; "PATH="	; Figure environment pointer
  4277 00000F41 B104                    	mov     cl,4
  4278 00000F43 D3E8                    	shr     ax,cl
  4279 00000F45 8CDA                    	mov     dx,ds
  4280 00000F47 01D0                    	add     ax,dx
  4281 00000F49 A3[ED0B]                	mov     [ENVIRSEG],ax
  4282 00000F4C 8EC0                    	mov     es,ax
  4283                                  	; 02/03/2023
  4284 00000F4E B020                    	mov	al,' ' ; 20h
  4285                                  	;mov	al,[space_chr]
  4286 00000F50 8844FF                  	mov     [si-1],al
  4287 00000F53 5E                      	pop     si ; **			; Remember location
  4288 00000F54 59                      	pop     cx ; *			; and count
  4289                                  	;mov	di,[ECOMLOC]
  4290 00000F55 8B3E[9114]              	mov     di,[COMSPOFFSET]
  4291                                  
  4292                                  COMTRLOOP:
  4293                                  	; MSDOS 3.3 & MSDOS 6.0
  4294 00000F59 AC                      	lodsb
  4295 00000F5A 49                      	dec	cx
  4296                                  	; 02/03/2023
  4297 00000F5B 3C20                    	cmp	al,' ' ; 20h
  4298                                  	;cmp	al,[space_chr]
  4299 00000F5D 7409                    	je	short SETCOMSR
  4300                                  	; MSDOS 3.3
  4301 00000F5F 3C09                    	cmp	al,9
  4302 00000F61 7405                    	je	short SETCOMSR
  4303                                  	; MSDOS 3.3 & MSDOS 6.0
  4304 00000F63 AA                      	stosb
  4305 00000F64 E302                    	jcxz	SETCOMSR
  4306 00000F66 EBF1                    	jmp	short COMTRLOOP
  4307                                  
  4308                                  SETCOMSR:
  4309                                  	; MSDOS 6.0
  4310                                  	;push	cx
  4311                                  	;
  4312                                  	;push	cs				; Get local segment
  4313                                  	;pop	ds				;
  4314                                  	;assume	ds:ResGroup			;
  4315                                  	;
  4316                                  	;push	ds
  4317                                  	;mov	si,offset ResGroup:ComSpect
  4318                                  	;mov	cx,14
  4319                                  	;
  4320                                  	;mov	al,es:[di-1]
  4321                                  	;
  4322                                  	;cmp	al,RDirChar
  4323                                  	;jnz	iNotRoot
  4324                                  	;inc	si				; Don't make a double /
  4325                                  	;dec	cx
  4326                                  	
  4327                                  	; MSDOS 3.3
  4328 00000F68 56                      	push    si
  4329 00000F69 51                      	push    cx
  4330 00000F6A 1E                      	push    ds
  4331 00000F6B BE[6514]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4332 00000F6E B90E00                  	mov     cx,14
  4333 00000F71 268A45FF                	mov     al,[es:di-1]
  4334 00000F75 E8E402                  	call    PATHCHRCMPR
  4335 00000F78 7502                    	jnz     short INOTROOT			
  4336 00000F7A 46                      	inc     si				; Don't make a double /
  4337 00000F7B 49                      	dec     cx
  4338                                  INOTROOT:
  4339                                  	; MSDOS 3.3 & MSDOS 6.0
  4340 00000F7C F3A4                    	rep	movsb
  4341                                  
  4342                                  	;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  4343 00000F7E 8B16[9114]                      mov     dx,[COMSPOFFSET]
  4344 00000F82 06                      	push	es
  4345 00000F83 1F                      	pop	ds
  4346                                  	;mov	ax,OPEN shl 8
  4347 00000F84 B8003D                  	mov	ax,OPEN*256 ; 3D00h
  4348 00000F87 CD21                    	int	21h				; Open COMMAND.COM
  4349 00000F89 1F                      	pop	ds
  4350 00000F8A 720D                    	jc	short SETCOMSRBAD		; No COMMAND.COM here
  4351 00000F8C 89C3                    	mov	bx,ax				; Handle
  4352 00000F8E B43E                    	mov	ah,CLOSE ; 3Eh
  4353 00000F90 CD21                    	int	21h				; Close COMMAND.COM
  4354                                  SETCOMSRRET:
  4355 00000F92 59                      	pop	cx
  4356 00000F93 5E                      	pop	si
  4357                                  
  4358                                  	; MSDOS 6.0
  4359                                  	;pop	ds				;
  4360                                  	;assume	ds:ResGroup			;
  4361                                  	;
  4362                                  	;push	cs				; Make sure local ES is
  4363                                  	;pop	es				;  restored
  4364                                  	;jmp	Parse_command_line		; continue parsing command line
  4365                                  
  4366                                  	; MSDOS 3.3
  4367                                  ARGSDONEJ2:
  4368 00000F94 E322                    	jcxz	ARGSDONE
  4369 00000F96 E956FE                  	jmp	CHKARG
  4370                                  
  4371                                  SETCOMSRBAD:
  4372                                  	; MSDOS 3.3 & MSDOS 6.0
  4373                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  4374 00000F99 BA[AD13]                	mov	dx,BADCOMLKMES
  4375                                  
  4376                                  ;	Note:  we're about to make a near call to TriageError, which
  4377                                  ;	lives in a different segment and group.  Some linkers will
  4378                                  ;	generate a warning like "Possible fix-up overflow".  We're
  4379                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  4380                                  ;	we're still all together.
  4381                                  
  4382 00000F9C E8B622                  	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  4383                                  				; in original MSDOS 3.3 COMMAND.COM	
  4384 00000F9F 83F841                  	cmp	ax,65
  4385 00000FA2 7503                    	jne	short DOPRT
  4386                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  4387 00000FA4 BA[E613]                	mov	dx,BADCOMACCMSG
  4388                                  DOPRT:
  4389 00000FA7 E8A502                  	call	RPRINT
  4390                                  	;mov	si,offset ResGroup:ComSpect
  4391 00000FAA BE[6514]                	mov     si,COMSPECT ; "/COMMAND.COM"
  4392                                  	;mov	di,[ECOMLOC]
  4393 00000FAD 8B3E[9114]                      mov     di,[COMSPOFFSET]
  4394 00000FB1 B90E00                  	mov	cx,14
  4395 00000FB4 F3A4                    	rep	movsb				; get my default back
  4396                                  
  4397 00000FB6 EBDA                    	jmp	short SETCOMSRRET
  4398                                  
  4399                                  ARGSDONE:
  4400                                  	; MSDOS 6.0
  4401                                  	;mov	es,EnvirSeg			; get environment back
  4402                                  	;assume	es:nothing			;
  4403                                  
  4404                                  	; MSDOS 3.3 & MSDOS 6.0
  4405 00000FB8 803E[DC0A]00                    cmp	byte [PERMCOM],0
  4406 00000FBD 742E                            jz	short COMRETURNS
  4407                                  
  4408 00000FBF 06                      	push	es				; Save environment pointer
  4409 00000FC0 B450                    	mov	ah,SET_CURRENT_PDB ; 50h
  4410 00000FC2 8CDB                    	mov	bx,ds
  4411 00000FC4 8EC3                    	mov	es,bx
  4412 00000FC6 CD21                    	int	21h				; current process is me
  4413 00000FC8 BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  4414                                  	;mov	ax,offset RESGROUP:LODCOM
  4415 00000FCB B8[AD01]                        mov	ax,LODCOM
  4416 00000FCE AB                              stosw
  4417 00000FCF 8CD8                            mov	ax,ds
  4418 00000FD1 AB                              stosw
  4419                                          ;mov	ax,offset RESGROUP:CONTC
  4420 00000FD2 B8[3C00]                        mov	ax,CONTC
  4421 00000FD5 AB                              stosw
  4422 00000FD6 8CD8                            mov	ax,ds
  4423 00000FD8 AB                              stosw
  4424                                  	;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  4425 00000FD9 B8[4704]                	mov     ax,CRITERR
  4426 00000FDC AB                      	stosw
  4427 00000FDD 8CD8                    	mov     ax,ds
  4428 00000FDF AB                      	stosw
  4429                                  	;mov	word ptr ds:16h,ds
  4430                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  4431 00000FE0 8C1E1600                	mov	[PDB.PARENT_PID],ds
  4432                                          ;mov	dx,offset RESGROUP:INT_2E
  4433 00000FE4 BA[7C01]                        mov	dx,INT_2E
  4434                                          ;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  4435 00000FE7 B82E25                  	mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  4436 00000FEA CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  4437                                  			; AL = interrupt number
  4438                                  			; DS:DX = new vector to be used for specified interrupt
  4439 00000FEC 07                              pop	es				; Remember environment
  4440                                  	
  4441                                  COMRETURNS:
  4442                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  4443 00000FED A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  4444 00000FF0 A3[760A]                        mov	[PARENT],ax			; Save parent
  4445                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  4446 00000FF3 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  4447                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  4448 00000FF7 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax, ds:18h
  4449 00000FFA A3[D90A]                        mov	[IO_SAVE],ax		; Get the default stdin and out
  4450 00000FFD 8C1E[F10B]                      mov	[COM_PTR+2],ds		; Set all these to resident
  4451 00001001 8C1E[F50B]                      mov	[COM_FCB1+2],ds
  4452 00001005 8C1E[F90B]              	mov	[COM_FCB2+2],ds
  4453                                          ;mov	di,offset ResGroup:ComSpec
  4454 00001009 BF[830A]                        mov	di,COMSPEC
  4455                                  
  4456                                  	;mov	si,[ECOMLOC]
  4457 0000100C 8B36[9114]              	mov	si,[COMSPOFFSET]
  4458                                  	;cmp	AllocedEnv,0  ; MSDOS 6.0
  4459 00001010 803E[9014]00                    cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  4460                                  	
  4461 00001015 8CD8                    	mov	ax,ds				; Xchg es,ds
  4462 00001017 06                      	push	es
  4463 00001018 1F                      	pop	ds
  4464 00001019 8EC0                    	mov	es,ax
  4465                                  
  4466                                  	;jne	CopyComsp  ; MSDOS 6.0
  4467 0000101B 741D                            je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  4468                                  
  4469 0000101D 0E                              push	cs
  4470 0000101E 1F                              pop	ds
  4471                                  
  4472                                          ;mov	si,offset ResGroup:ComspString
  4473 0000101F BE[9314]                	mov	si,COMSPSTRING ; "COMSPEC="
  4474 00001022 06                      	push	es
  4475 00001023 57                      	push	di
  4476 00001024 E84302                  	call	IFINDE
  4477 00001027 89FE                    	mov	si,di
  4478 00001029 06                      	push	es
  4479 0000102A 1F                      	pop	ds
  4480 0000102B 5F                      	pop	di
  4481 0000102C 07                      	pop	es
  4482 0000102D 730B                            jnc	short COPYCOMSP
  4483                                  
  4484                                  	; MSDOS 6.0
  4485                                  ;ComSpecNofnd:
  4486                                          ;mov	si,offset ResGroup:ComspString
  4487                                          ;add	si,ComspStrLen
  4488                                  	;push	cs
  4489                                  	;pop	ds
  4490                                  
  4491                                  COMSPECNOFND:
  4492                                  	; MSDOS 3.3
  4493                                          ;mov	si,[es:ECOMLOC]
  4494 0000102F 268B36[9114]                    mov	si,[es:COMSPOFFSET]
  4495                                  	;add	si,offset RESGROUP:PATHSTRING
  4496 00001034 81C6[300C]                      add	si,PATHSTRING ; "PATH="
  4497 00001038 0E                      	push	cs
  4498 00001039 1F                              pop	ds
  4499                                  
  4500                                  COPYCOMSP:
  4501                                  	; MSDOS 3.3 & MSDOS 6.0
  4502                                  	;mov	es:PutBackComSpec.SubstPtr,di
  4503 0000103A 26893E[C30A]            	mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  4504 0000103F 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  4505 00001043 7506                    	jne	short COPYCOMSPLOOP		; If not, do not skip over first 2 bytes
  4506                                  	;add	es:PutBackComSpec.SubstPtr,2
  4507 00001045 268306[C30A]02          	add	word [es:PUTBACKSUBSTPTR],2
  4508                                  
  4509                                  COPYCOMSPLOOP:
  4510 0000104B AC                      	lodsb
  4511 0000104C AA                      	stosb
  4512 0000104D 08C0                    	or	al,al
  4513 0000104F 75FA                    	jnz	short COPYCOMSPLOOP
  4514                                  
  4515 00001051 26893E[C50A]            	mov	[es:COMSPEC_END],di		; Save ptr to end of comspec path
  4516 00001056 26FF0E[C50A]            	dec	word [es:COMSPEC_END]
  4517 0000105B 268A26[CE0A]            	mov	ah,[es:COMDRV]
  4518 00001060 80C440                  	add	ah,'A'-1 ; 40h
  4519 00001063 268826[1109]            	mov	[es:PUTBACKDRV],ah		; save drive letter
  4520                                  
  4521                                  	; MSDOS 6.0
  4522                                  	;call	setup_for_messages		; set up parse and extended error messages
  4523                                  ;
  4524                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  4525                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  4526                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  4527                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  4528                                  ; the data otherwise it is just the data.
  4529                                  ; 
  4530                                  	;call	Setup_res_end			;put resident size in ResSize
  4531                                  
  4532                                  	;push	cs
  4533                                  	;pop	ds
  4534                                  	;assume	ds:RESGROUP
  4535                                  
  4536                                  ;Public EnvMaximum
  4537                                  ;EnvMaximum:
  4538                                  
  4539                                  	; MSDOS 3.3
  4540 00001068 0E                      	push	cs
  4541 00001069 1F                              pop	ds
  4542                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  4543 0000106A BB[200C]                	mov	bx,DATARESEND+15
  4544 0000106D B104                            mov	cl,4
  4545 0000106F D3EB                            shr	bx,cl
  4546 00001071 B44A                            MOV     AH,SETBLOCK ; 4Ah
  4547 00001073 CD21                            int	21h			; Shrink me to the resident only
  4548                                  
  4549                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  4550                                  
  4551 00001075 C606[CB0A]01            	mov	byte [TRNMVFLG], 1
  4552 0000107A 06                      	push	es ; *
  4553 0000107B BE[E014]                	mov	si,TRANSTART
  4554 0000107E BF0000                  	mov	di,0
  4555 00001081 8E06[C90A]              	mov	es,[TRNSEG]
  4556                                  	;mov	cx,4D5Ch
  4557 00001085 B9324C                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  4558 00001088 51                      	push	cx
  4559 00001089 89C8                    	mov	ax,cx
  4560 0000108B 01F0                    	add	ax,si
  4561 0000108D B104                    	mov	cl,4
  4562 0000108F D3E8                    	shr	ax,cl
  4563 00001091 40                      	inc	ax
  4564 00001092 8CD9                    	mov	cx,ds
  4565 00001094 01C8                    	add	ax,cx
  4566 00001096 3B06[C90A]              	cmp	ax,[TRNSEG]
  4567 0000109A 59                      	pop	cx
  4568 0000109B 7205                    	jb	short MOV_DOWN
  4569                                  
  4570 0000109D E8D3F2                  	call	LOADCOM
  4571 000010A0 EB0A                    	jmp	short ICHKSUM
  4572                                  
  4573                                  MOV_DOWN:
  4574 000010A2 01CE                    	add     si,cx
  4575 000010A4 4E                      	dec     si
  4576 000010A5 01CF                    	add     di,cx
  4577 000010A7 4F                      	dec     di
  4578 000010A8 FD                      	std
  4579 000010A9 F3A4                    	rep movsb
  4580 000010AB FC                      	cld
  4581                                  
  4582                                  ICHKSUM:
  4583                                  	; 24/09/2018
  4584                                  ;
  4585                                  ; Compute checksum right now before we can get corrupted and save it
  4586                                  ;
  4587                                  	; MSDOS 6.0
  4588                                  	;mov	si,offset RESGROUP:TranStart
  4589                                  	;add	si,100h
  4590                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  4591                                  	;
  4592                                  	;cld
  4593                                  	;shr	cx,1
  4594                                  	;xor	dx,dx
  4595                                  ;Ichksum:
  4596                                  	;lodsw
  4597                                  	;add	dx,ax
  4598                                  	;adc	dx,0
  4599                                  	;loop	Ichksum
  4600                                  	;
  4601                                          ;mov	Sum,dx			; store checksum
  4602                                  
  4603                                  	; MSDOS 3.3
  4604 000010AC 07                      	pop     es ; *
  4605 000010AD E812F3                  	call    CHKSUM
  4606 000010B0 8916[D10A]              	mov     [SUM],dx
  4607                                  
  4608                                  	; MSDOS 3.3 & MSDOS 6.0
  4609 000010B4 803E[8314]00                    cmp     byte [PRDATTM],0	;
  4610 000010B9 750C                            jnz     short NOBATCHSEG	; don't do autoexec or date time
  4611                                  ;
  4612                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  4613                                  ;
  4614                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  4615                                  	;mov	bx,3
  4616 000010BB BB0300                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  4617 000010BE B448                            mov     ah,ALLOC ; 48h		;
  4618 000010C0 CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4619                                  			; BX = number of 16-byte paragraphs desired
  4620 000010C2 7203                    	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  4621 000010C4 A3[810A]                        mov     [BATCH],ax		; save batch segment
  4622                                  
  4623                                  NOBATCHSEG:
  4624                                  	; MSDOS 6.0
  4625                                  	;mov	bx,EnvirSeg                     ; get old environment segment
  4626                                  	;mov	OldEnv,bx                       ; save it
  4627                                  	;
  4628                                          ;mov	UsedEnv,0                       ; initialize env size counter
  4629                                  	;mov	ds,bx
  4630                                  	;assume	ds:nothing
  4631                                  	;
  4632                                  	;xor	si,si
  4633                                  	;mov	di,si
  4634                                  ;
  4635                                  ; This is the maximum allowed size for the environment
  4636                                  ;
  4637                                  	;mov	bx,4096 - 1 			; max. allowed env. size
  4638                                  	;mov	EnvMax,bx
  4639                                  				 
  4640                                  	;shl	bx,1
  4641                                  	;shl	bx,1
  4642                                  	;shl	bx,1
  4643                                  	;shl	bx,1
  4644                                  	;mov	EnvMax, bx			; convert envmax to bytes
  4645                                  	;dec	bx				; dec by one to leave room for double 0
  4646                                  	;xor	dx,dx				; use dx to indicate that there was
  4647                                  						; no environment size error.
  4648                                  ;public NxtStr
  4649                                  ;NxtStr:
  4650                                  	;call	GetStrLen			; get the size of the current env string
  4651                                  
  4652                                  ;Bugbug: Can use ss here to address UsedEnv
  4653                                  
  4654                                  	;push	ds                              ; get addressability to environment
  4655                                          ;push	cs                              ;                       counter
  4656                                          ;pop	ds                              ;
  4657                                          ;assume	ds:ResGroup
  4658                                          ;add	UsedEnv,cx                      ; add the string length to env size
  4659                                          ;pop	ds                              ;
  4660                                  	;assume	ds:nothing
  4661                                  	;cmp	cx,1				; end of environment was encountered.
  4662                                  	;jz	EnvExit
  4663                                  	;sub	bx,cx
  4664                                  	;jae	OkCpyStr			; can't fit in all of enviroment.
  4665                                  	;inc	dx				; out of env space msg must be displayed
  4666                                  	;jmp	short EnvExit
  4667                                  ;OkCpyStr:
  4668                                  	;jmp	NxtStr
  4669                                  ;EnvExit:
  4670                                  	;push	cs
  4671                                  	;pop	ds
  4672                                  	;assume	ds:ResGroup
  4673                                  	;or	dx,dx				; dx will be non-zero if error
  4674                                  	;jz	EnvNoErr
  4675                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  4676                                  	;call 	RPrint
  4677                                  	;
  4678                                  ;EnvNoErr:
  4679                                  	;mov	ax,EnvSiz			;env size previously set
  4680                                  	;mov	cl,4
  4681                                  	;shl	ax,cl				;get size in bytes
  4682                                  	;cmp	ax,UsedEnv			;is it a new env?
  4683                                  	;ja	st_envsize			;yes, store the size
  4684                                  	;
  4685                                  	;mov	ax,UsedEnv
  4686                                  	;add	ax,15				;round up
  4687                                  ;st_envsize:	
  4688                                  	;shr	ax,cl
  4689                                  	;mov	EnvSiz,ax			;store env size needed(paras)
  4690                                  ;if MSVER
  4691                                  	;cmp	SingleCom,0
  4692                                  	;jnz	nophead 			; don't print header if singlecom
  4693                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4694                                  	;call	RPrint
  4695                                  ;nophead:
  4696                                  ;endif
  4697                                  
  4698                                  	; MSDOS 3.3
  4699 000010C7 BBFFFF                  	mov     bx,0FFFFh ; 65535
  4700 000010CA B448                    	mov     ah,ALLOC ; 48h
  4701 000010CC CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4702                                  			; BX = number of 16-byte paragraphs desired
  4703 000010CE 2B1E[A514]              	sub     bx,[TRNSIZE]
  4704 000010D2 81EB8000                	sub     bx,128
  4705 000010D6 891E[9D14]              	mov     [ENVMAX],bx
  4706                                  
  4707 000010DA 81FB0010                	cmp     bx,4096
  4708 000010DE 7207                    	jb      short ALLOCENVIRSEG
  4709 000010E0 BBFF0F                  	mov     bx,4096-1		; max. allowed environment size
  4710 000010E3 891E[9D14]              	mov     [ENVMAX],bx
  4711                                  
  4712                                  ALLOCENVIRSEG:
  4713 000010E7 B448                    	mov     ah,ALLOC ; 48h
  4714 000010E9 CD21                    	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  4715                                  			; BX = number of 16-byte paragraphs desired
  4716 000010EB 8B1E[ED0B]              	mov     bx,[ENVIRSEG]		; get old environment segment
  4717 000010EF 891E[9F14]              	mov     [OLDENV],bx		; save it	
  4718 000010F3 C706[A114]0000          	mov     word [USEDENV],0	; initialize environment size counter
  4719 000010F9 8EDB                    	mov     ds,bx
  4720 000010FB 36A3[ED0B]              	mov     [ss:ENVIRSEG], ax	; save new environment segment
  4721 000010FF 8EC0                    	mov     es,ax
  4722 00001101 31F6                    	xor     si,si
  4723 00001103 89F7                    	mov     di,si
  4724 00001105 368B1E[9D14]            	mov     bx,[ss:ENVMAX]
  4725 0000110A D1E3                    	shl     bx,1
  4726 0000110C D1E3                    	shl     bx,1
  4727 0000110E D1E3                    	shl     bx,1
  4728 00001110 D1E3                    	shl     bx,1
  4729 00001112 36891E[9D14]            	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  4730 00001117 4B                      	dec     bx			; dec by one to leave room for double 0
  4731 00001118 31D2                    	xor     dx,dx			; use dx to indicate that there was
  4732                                  					; no environment size error.
  4733                                  
  4734                                  NXSTR:
  4735 0000111A E80D01                  	call    GETSTRLEN		; get the size of the current env string
  4736                                  
  4737 0000111D 1E                      	push    ds
  4738 0000111E 0E                      	push    cs
  4739 0000111F 1F                      	pop     ds
  4740 00001120 010E[A114]              	add     [USEDENV],cx		; add the string length to env size
  4741 00001124 1F                      	pop     ds
  4742 00001125 83F901                  	cmp     cx,1			; end of environment was encountered.
  4743 00001128 7409                    	je      short ENVEXIT
  4744 0000112A 29CB                    	sub     bx,cx
  4745 0000112C 7303                    	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  4746 0000112E 42                      	inc     dx			; out of env space msg must be displayed
  4747 0000112F EB02                    	jmp     short ENVEXIT
  4748                                  
  4749                                  	;nop
  4750                                  
  4751                                  OKCPYSTR:
  4752 00001131 EBE7                    	jmp     short NXSTR
  4753                                  
  4754                                  ENVEXIT: 
  4755 00001133 0E                      	push    cs
  4756 00001134 1F                      	pop     ds
  4757 00001135 09D2                    	or      dx, dx			; dx will be non-zero if error
  4758 00001137 7406                    	jz      short ENVNOERR
  4759 00001139 BA[1514]                	mov     dx,OUTENVMSG		; dx = ptr to msg
  4760 0000113C E81001                  	call    RPRINT
  4761                                  
  4762                                  ENVNOERR:
  4763 0000113F 8B0E[9D14]              	mov     cx,[ENVMAX]
  4764 00001143 29D9                    	sub     cx,bx			; current environment size in bytes
  4765 00001145 83C110                  	add     cx,16			; add memory arena to the size
  4766 00001148 D1E9                    	shr     cx,1
  4767 0000114A D1E9                    	shr     cx,1
  4768 0000114C D1E9                    	shr     cx,1
  4769 0000114E D1E9                    	shr     cx,1			; convert current env size to paragraphs
  4770 00001150 3B0E[9B14]              	cmp     cx,[ENVSIZ]		; compare with env size previously set
  4771                                  	;jb	short SET_ENVSIZE
  4772 00001154 7604                    	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  4773 00001156 890E[9B14]              	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  4774                                  
  4775                                  SET_ENVSIZE:
  4776 0000115A 8B1E[9B14]              	mov     bx,[ENVSIZ]
  4777 0000115E 8CC0                    	mov     ax,es
  4778 00001160 01D8                    	add     ax,bx			; get end segment of environemnt
  4779 00001162 3B06[A314]              	cmp     ax,[INITEND]		; compare with init code end segment
  4780 00001166 770E                    	ja      short NOPHEAD
  4781                                  					; free unused paragraghs		
  4782 00001168 8CC0                    	mov     ax,es
  4783 0000116A 8B1E[A314]              	mov     bx,[INITEND]
  4784 0000116E 29C3                    	sub     bx,ax
  4785                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  4786 00001170 C706[A714]0100          	mov	word [RESETENV],1	; environment segment reset sign
  4787                                  
  4788                                  NOPHEAD:
  4789                                  	; MSDOS 3.3
  4790 00001176 B44A                    	mov     ah,SETBLOCK ; 4Ah
  4791 00001178 CD21                    	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  4792                                  			; ES = segment address of block to change
  4793                                  			; BX = new size in paragraphs
  4794                                  
  4795                                  	; MSDOS 3.3 & 6.0
  4796 0000117A 833E[810A]00            	cmp     word [BATCH],0		; did we set up a batch segment?
  4797 0000117F 7503                    	jnz     short DODATE		; yes - go initialize it
  4798 00001181 E99100                  	jmp     NODTTM			; don't do autoexec or date time
  4799                                  
  4800                                  DODATE:
  4801                                  ;
  4802                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  4803                                  ;
  4804                                  
  4805 00001184 A1[810A]                	mov	ax,[BATCH]		; get batch segment
  4806 00001187 C606[D70A]03            	mov	byte [ECHOFLAG],3	; set batch echo
  4807 0000118C C706[E60A]0100          	mov	word [NEST],1		; set nest flag to 1 batch
  4808 00001192 8EC0                    	mov	es,ax
  4809                                  ;
  4810                                  ; initialize the segment
  4811                                  ;
  4812 00001194 31FF                    	xor	di,di
  4813 00001196 B000                    	mov	al,BATCHTYPE ; 0
  4814 00001198 AA                      	stosb
  4815 00001199 B001                    	mov	al,1			; initialize echo for batch exit
  4816 0000119B AA                      	stosb
  4817                                  ;
  4818                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  4819                                  ;
  4820 0000119C 31C0                    	xor	ax,ax			; initialize to zero
  4821                                  	;stosb	; MSDOS 6.0 		; clear out BatchEOF
  4822                                  
  4823 0000119E AB                      	stosw				; batch segment of last job - batlast
  4824 0000119F AB                      	stosw				; segment for FOR
  4825 000011A0 AA                      	stosb				; FOR flag
  4826 000011A1 AB                      	stosw				; position in file - batseek
  4827 000011A2 AB                      	stosw
  4828                                  ;
  4829                                  ; clean out the parameters
  4830                                  ;
  4831 000011A3 B8FFFF                  	mov	ax,-1			; initialize to no parameters
  4832 000011A6 B90A00                  	mov	cx,10
  4833 000011A9 F3AB                    	rep	stosw
  4834                                  ;
  4835                                  ; decide whether we should grab the default drive
  4836                                  ;
  4837 000011AB 803E[7314]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  4838 000011B0 7509                    	jnz	short NOAUTSET
  4839 000011B2 B419                    	mov	ah,GET_DEFAULT_DRIVE ; 19h
  4840 000011B4 CD21                    	int	21h
  4841                                  	; 02/03/2023
  4842 000011B6 0441                    	add	al,'A'
  4843                                  	;add	al,[letter_A] ; Ucasea
  4844 000011B8 A2[7314]                	mov	[AUTOBAT],al
  4845                                  
  4846                                  NOAUTSET:
  4847                                  ;
  4848                                  ; copy in the batch file name (including nul)
  4849                                  ;
  4850                                  	;mov	si,offset ResGroup:AutoBat
  4851 000011BB BE[7314]                	mov	si,AUTOBAT
  4852 000011BE B90800                  	mov	cx,8
  4853 000011C1 F3A5                    	rep	movsw
  4854                                  	;movsb	; MSDOS 6.0		; move in carriage return to terminate string
  4855                                  
  4856                                  	;mov	dx,offset ResGroup:AutoBat
  4857 000011C3 BA[7314]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  4858                                  
  4859                                  	;mov	ax,OPEN shl 8
  4860 000011C6 B8003D                  	mov	ax,OPEN*256 ; 3D00h  ; open for read
  4861 000011C9 CD21                    	int	21h			; see if autoexec.bat exists
  4862 000011CB 7208                    	jc	short NOABAT
  4863 000011CD 89C3                    	mov	bx,ax
  4864 000011CF B43E                    	mov	ah,CLOSE  ; 3Eh
  4865 000011D1 CD21                    	int	21h
  4866 000011D3 EB4D                    	jmp	short DRV0		; go process autoexec
  4867                                  NOABAT:
  4868 000011D5 50                      	push	ax
  4869 000011D6 E85A00                  	call	SETUP_SEG
  4870 000011D9 A3[8E14]                	mov	[TRIAGEADD+2],ax
  4871 000011DC 58                      	pop	ax
  4872 000011DD FF1E[8C14]              	call	far [TRIAGEADD]		; get extended error
  4873 000011E1 83F841                  	cmp	ax,65			; network access denied?
  4874 000011E4 7506                    	jne	short OPENERR		; no - go deallocate batch
  4875                                  
  4876                                  _ACCDENERROR:					; yes - put out message
  4877                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  4878 000011E6 BA[F813]                	mov	dx,ACCDENERR
  4879 000011E9 E86300                  	call	RPRINT
  4880                                  OPENERR:
  4881 000011EC 8E06[810A]              	mov	es,[BATCH]		; not found--turn off batch job
  4882 000011F0 B449                    	mov	ah,DEALLOC ; 49h
  4883 000011F2 CD21                    	int	21h
  4884 000011F4 C706[810A]0000          	mov	word [BATCH],0		; after dealloc in case of ^c
  4885 000011FA C606[D70A]01            	mov	byte [ECHOFLAG],1
  4886 000011FF C706[E60A]0000          	mov	word [NEST],0		; indicate no batch in progress
  4887                                  
  4888                                  DODTTM:
  4889                                  	;mov	ax,offset TranGroup:Datinit
  4890                                  
  4891 00001205 B8FC1F                  	mov	ax,DATINIT
  4892 00001208 A3[8414]                	mov	[INITADD],ax
  4893                                  
  4894                                  	; MSDOS 6.0
  4895                                  ;;;M004	mov	ax,TrnSeg	
  4896                                  ;
  4897                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  4898                                  ; M004; the transient starts on a para boundary at the label TranStart.
  4899                                  ; M004; We use TranStart to get the start of the transient segment.
  4900                                  ;
  4901                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  4902                                  	;mov	cl,4				; M004
  4903                                  	;shr	ax,cl				; get relative seg ; M004
  4904                                  	;mov	cx,cs
  4905                                  	;add	ax,cx				; ax = transient seg ; M004
  4906                                  
  4907                                  	; MSDOS 3.3
  4908                                  	; 25/09/2018
  4909 0000120B A1[C90A]                	mov     ax,[TRNSEG]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  4910                                  
  4911                                  	; MSDOS 3.3 & MSDOS 6.0
  4912 0000120E A3[8614]                	mov	[INITADD+2],ax
  4913                                  	;call	dword ptr InitAdd
  4914 00001211 FF1E[8414]              	call	far [INITADD]
  4915                                  NODTTM:
  4916                                  	; MSDOS 6.0
  4917                                  Copyright:
  4918                                  	;public	Copyright
  4919                                  ;	Bugbug:	remove Copyright label.
  4920                                  
  4921                                  ;if IBMVER
  4922                                  	;cmp	SingleCom,0
  4923                                  	;jnz	Drv0				; don't print header if singlecom
  4924                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  4925                                  	;call	RPrint
  4926                                  ;endif
  4927                                  
  4928                                  	; MSDOS 3.3
  4929 00001215 833E[DD0A]00            	cmp	word [SINGLECOM],0	; don't print header if singlecom
  4930 0000121A 7506                    	jnz     short DRV0
  4931 0000121C BA[5414]                	mov     dx,HEADERPTR	; dx = ptr to msg
  4932 0000121F E82D00                  	call    RPRINT
  4933                                  DRV0:
  4934                                  	; MSDOS 3.3
  4935 00001222 C606[430B]00                    mov     byte [INITFLAG],0
  4936 00001227 E9D1F1                  	jmp	ENDINIT
  4937                                  
  4938                                  	; MSDOS 6.0
  4939                                  ;Drv0:						; Reset APPEND state
  4940                                  ;	push	ds				; save data segment
  4941                                  ;	push	cs				; Get local segment into DS
  4942                                  ;	pop	ds				;
  4943                                  ;	mov	ax,APPENDSETSTATE		; Set the state of Append
  4944                                  ;	mov	bx,Append_State 		;  back to the original state
  4945                                  ;	int	2fh				;
  4946                                  ;	pop	ds				; get data segment back
  4947                                  ;;
  4948                                  ;;Check FirstCom set previously to see if this is the first instance of
  4949                                  ;;command.com. If not, we do not move command.com. Instead, we copy over the
  4950                                  ;;jump table from the previous stub to the current stub.
  4951                                  ;;
  4952                                  ;	cmp	FirstCom,1			;first command.com?
  4953                                  ;	jz	move_code			;yes, move it
  4954                                  ;
  4955                                  ;	push	es
  4956                                  ;	push	ds
  4957                                  ;
  4958                                  ;	push	ds
  4959                                  ;	pop	es
  4960                                  ;	mov	di,offset DATARES:Int2f_Entry
  4961                                  ;
  4962                                  ;	mov	ds,word ptr es:ResJmpTable+2	;get segment address
  4963                                  ;	mov	si,word ptr es:ResJmpTable	;get offset address
  4964                                  ;
  4965                                  ;	mov 	cx,NUM_RELOC_ENTRIES 		;number of dword ptrs
  4966                                  ;	shl	cx,1
  4967                                  ;	shl	cx,1				;size of table in bytes
  4968                                  ;
  4969                                  ;	cld
  4970                                  ;	rep	movsb				;copy the jump table
  4971                                  ;;
  4972                                  ;;Check if the resident code is in HMA. We assume that it is in HMA if its 
  4973                                  ;;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  4974                                  ;;
  4975                                  ;	cmp	es:[di-2],0f000h		;is resident code in HMA?
  4976                                  ;	jb	res_low				;no, dont set flag
  4977                                  ;
  4978                                  ;	mov	es:ComInHMA,1			;indicate code in HMA
  4979                                  ;
  4980                                  ;res_low:
  4981                                  ;	pop	ds
  4982                                  ;	pop	es
  4983                                  ;	jmp	short finish_init
  4984                                  ;;
  4985                                  ;;Now, we can move the resident code to its final location, either to HIMEM
  4986                                  ;;or to overlay the messages in the data segment if the user has not used the
  4987                                  ;;/msg switch.
  4988                                  ;;
  4989                                  ;move_code:
  4990                                  ;	call	Move_res_code			;move the code
  4991                                  ;
  4992                                  ;finish_init:
  4993                                  ;	jmp	RESGROUP:EndInit 		;g finish initializing
  4994                                  
  4995                                  
  4996                                  GETSTRLEN:
  4997                                  ;
  4998                                  ;	Get length of string pointed to by DS:SI.  Length includes NULL.
  4999                                  ;	Length is returned in CX
  5000                                  ;
  5001                                  	; MSDOS 3.3 & MSDOS 6.0
  5002 0000122A 31C9                    	xor	cx,cx
  5003                                  NXTCHAR:
  5004 0000122C AC                      	lodsb
  5005 0000122D 41                      	inc	cx
  5006 0000122E 08C0                    	or	al,al
  5007 00001230 75FA                    	jnz	short NXTCHAR
  5008 00001232 C3                      	retn
  5009                                  
  5010                                  SETUP_SEG:
  5011                                  ;
  5012                                  ; If the transient has been loaded in TranSeg, then we need to use that
  5013                                  ; segment for calls to routines in the transient area. Otherwise, the current
  5014                                  ; code segment is used
  5015                                  ; Segment returned in AX.
  5016                                  ;
  5017                                  	; MSDOS 3.3 & MSDOS 6.0
  5018 00001233 A1[C90A]                	mov	ax,[TRNSEG]
  5019 00001236 803E[CB0A]01            	cmp	byte [TRNMVFLG],1	; Has transient portion been moved
  5020 0000123B 7411                    	je	short SETUP_END
  5021 0000123D 53                      	push	bx
  5022 0000123E 8CCB                    	mov	bx,cs
  5023                                  	;mov	ax,offset ResGroup:TranStart
  5024 00001240 B8[E014]                	mov	ax,TRANSTART
  5025 00001243 D1E8                    	shr	ax,1
  5026 00001245 D1E8                    	shr	ax,1
  5027 00001247 D1E8                    	shr	ax,1
  5028 00001249 D1E8                    	shr	ax,1
  5029 0000124B 01D8                    	add	ax,bx
  5030 0000124D 5B                      	pop	bx
  5031                                  SETUP_END:
  5032 0000124E C3                      	retn
  5033                                  
  5034                                  RPRINT:
  5035                                  	; MSDOS 3.3
  5036 0000124F 50                      	push    ax
  5037 00001250 E8E0FF                  	call    SETUP_SEG
  5038 00001253 A3[8A14]                	mov     [PRINTADD+2], ax
  5039                                  	;call	dword ptr PRINTADD
  5040 00001256 FF1E[8814]              	call	far [PRINTADD]
  5041 0000125A 58                      	pop     ax
  5042 0000125B C3                      	retn
  5043                                  
  5044                                  	; MSDOS 6.0
  5045                                  ;***	RPrintParse - display parse error message
  5046                                  ;
  5047                                  ;	ENTRY	DX = parse error #
  5048                                  ;
  5049                                  ;	EXIT	nothing
  5050                                  ;
  5051                                  ;	USED	flags
  5052                                  ;
  5053                                  ;	EFFECTS
  5054                                  ;	  Message is displayed on stdout.
  5055                                  ;
  5056                                  ;RPrintParse	proc
  5057                                  ;
  5058                                  ;	assume	ds:ResGroup,ss:ResGroup
  5059                                  ;
  5060                                  ;	push	dx				; preserve DX
  5061                                  ;	xchg	bx,dx				; bx = parse error #
  5062                                  ;						; dx = saved BX
  5063                                  ;	dec	bx				; bx = parse error index, from 0
  5064                                  ;	shl	bx,1				; bx = offset in word table
  5065                                  ;	mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  5066                                  ;	xchg	bx,dx				; dx = ptr to error msg
  5067                                  ;						; bx = restored
  5068                                  ;	call	RPrint				; print the message
  5069                                  ;	pop	dx				; restore DX
  5070                                  ;	ret
  5071                                  ;
  5072                                  ;RPrintParse	endp
  5073                                  
  5074                                  PATHCHRCMPR:
  5075                                  	; MSDOS 3.3
  5076                                  	; 02/03/2023
  5077                                  	;push	dx
  5078                                  	;mov	dl,[slash_chr] ; '/'
  5079 0000125C 803E[010C]2F            	cmp	byte [RSWITCHAR],'/'
  5080                                  	;cmp	[RSWITCHAR],dl
  5081 00001261 7404                    	je	short RNOSLASHT
  5082 00001263 3C2F                    	cmp	al,'/'
  5083                                  	;cmp	al,dl
  5084 00001265 7402                    	je	short RET41 ; zf = 1 
  5085                                  RNOSLASHT:
  5086 00001267 3C5C                            cmp	al,'\'
  5087                                  	;cmp	al,[bslash_chr]
  5088                                  RET41:
  5089                                  	;pop	dx
  5090 00001269 C3                      	retn
  5091                                  
  5092                                  IFINDE:
  5093                                  	; MSDOS 3.3 & MSDOS 6.0
  5094 0000126A E80400                  	call	IFIND				; find the name
  5095 0000126D 722D                    	jc	short IFIND2			; carry means not found
  5096 0000126F EB3A                    	jmp	short ISCASB1 			; scan for = sign
  5097                                  ;
  5098                                  ; on return of find1, es:di points to beginning of name
  5099                                  ;
  5100                                  IFIND:
  5101 00001271 FC                      	cld
  5102 00001272 E82800                  	call	ICOUNT0 			; cx = length of name
  5103 00001275 8E06[ED0B]              	mov	es,[ENVIRSEG]
  5104 00001279 31FF                    	xor	di,di
  5105                                  IFIND1:
  5106 0000127B 51                      	push	cx
  5107 0000127C 56                      	push	si
  5108 0000127D 57                      	push	di
  5109                                  IFIND11:
  5110 0000127E AC                      	lodsb
  5111 0000127F E83500                  	call	IUPCONV
  5112 00001282 47                      	inc	di
  5113 00001283 263A45FF                	cmp	al,[es:di-1]
  5114 00001287 7502                    	jnz	short IFIND12
  5115 00001289 E2F3                    	loop	IFIND11
  5116                                  IFIND12:
  5117 0000128B 5F                      	pop	di
  5118 0000128C 5E                      	pop	si
  5119 0000128D 59                      	pop	cx
  5120 0000128E 740C                    	jz	short IFIND2
  5121 00001290 51                      	push	cx
  5122 00001291 E81B00                  	call	ISCASB2 			; scan for a nul
  5123 00001294 59                      	pop	cx
  5124 00001295 26803D00                	cmp	byte [es:di],0
  5125 00001299 75E0                    	jnz	short IFIND1
  5126 0000129B F9                      	stc					; indicate not found
  5127                                  IFIND2:
  5128 0000129C C3                      	retn
  5129                                  
  5130                                  ICOUNT0:
  5131 0000129D 1E                      	push	ds
  5132 0000129E 07                      	pop	es
  5133 0000129F 89F7                    	mov	di,si
  5134                                  
  5135 000012A1 57                      	push	di				; count number of chars until "="
  5136 000012A2 E80600                  	call	ISCASB1
  5137                                  	; 25/09/2018
  5138                                  	;jmp	short ICOUNTX
  5139                                  	;push	di				; count number of chars until nul
  5140                                  	;call	ISCASB2
  5141                                  ;ICOUNTX:
  5142 000012A5 59                      	pop	cx
  5143 000012A6 29CF                    	sub	di,cx
  5144 000012A8 87F9                    	xchg	di,cx
  5145 000012AA C3                      	retn
  5146                                  
  5147                                  ISCASB1:
  5148                                  	; 02/03/2023
  5149 000012AB B03D                    	mov	al,"="
  5150                                  	;mov	al,[equal_sign]			; scan for an =
  5151 000012AD EB02                    	jmp	short ISCASBX
  5152                                  ISCASB2:
  5153 000012AF 30C0                    	xor	al,al				; scan for a nul
  5154                                  ISCASBX:
  5155 000012B1 B90001                  	mov	cx,256 ; 100h
  5156 000012B4 F2AE                    	repnz	scasb
  5157 000012B6 C3                      	retn
  5158                                  
  5159                                  IUPCONV:
  5160                                  	; MSDOS 3.3
  5161 000012B7 3C61                    	cmp	al,"a"
  5162                                  	; 02/03/2023
  5163                                  	;cmp	al,[letter_a]
  5164 000012B9 7206                    	jb	short IRET22
  5165 000012BB 3C7A                    	cmp	al,"z"
  5166                                  	;cmp	al,[letter_z]
  5167 000012BD 7702                    	ja	short IRET22
  5168 000012BF 2C20                    	sub	al,20h			; Lower-case changed to upper-case
  5169                                  IRET22:
  5170 000012C1 C3                              retn
  5171                                  
  5172                                  	; MSDOS 6.0
  5173                                  ; ****************************************************************
  5174                                  ; *
  5175                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  5176                                  ; *
  5177                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  5178                                  ; *		 the character in AL from the file upper case table
  5179                                  ; *		 in DOS if character if above  ascii 128, else
  5180                                  ; *		 subtracts 20H if between "a" and "z".
  5181                                  ; *
  5182                                  ; * INPUT:	 DS	      set to resident
  5183                                  ; *		 AL	      char to be upper cased
  5184                                  ; *		 FUCASE_ADDR  set to the file upper case table
  5185                                  ; *
  5186                                  ; * OUTPUT:	 AL	      upper cased character
  5187                                  ; *
  5188                                  ; ****************************************************************
  5189                                  ;
  5190                                  ;IupConv proc	near				
  5191                                  ;	assume	ds:ResGroup			;
  5192                                  ;
  5193                                  ;	cmp	al,80h				; see if char is > ascii 128
  5194                                  ;	jb	other_fucase			; no - upper case math
  5195                                  ;	sub	al,80h				; only upper 128 chars in table
  5196                                  ;	push	ds				;
  5197                                  ;	push	bx				;
  5198                                  ;	lds	bx,dword ptr fucase_addr+1		; get table address
  5199                                  ;	add	bx,2				; skip over first word
  5200                                  ;	xlat	ds:byte ptr [bx]			; convert to upper case
  5201                                  ;	pop	bx				;
  5202                                  ;	pop	ds				;
  5203                                  ;	jmp	short iupconv_end			; we finished - exit
  5204                                  ;
  5205                                  ;other_fucase:					;
  5206                                  ;	cmp	al,Lcasea			; if between "a" and "z",
  5207                                  ;	jb	iupconv_end			;     subtract 20h to get
  5208                                  ;	cmp	al,Lcasez			; upper case equivalent.
  5209                                  ;	ja	iupconv_end			;
  5210                                  ;	sub	al,20h				; Change lower-case to upper
  5211                                  ;
  5212                                  ;iupconv_end:					;
  5213                                  ;	ret
  5214                                  ;
  5215                                  ;IupConv endp					;
  5216                                  
  5217                                  
  5218                                  INIT_CONTC_SPECIALCASE:
  5219                                  	; MSDOS 3.3 & MSDOS 6.0
  5220                                  						; This routine is called if control-C
  5221 000012C2 83C406                  	add	sp,6				;  is type during the date/time prompt
  5222 000012C5 56                      	push	si				;  at initialization time.  The desired
  5223 000012C6 89D6                    	mov	si,dx				;  response is to make it look like the
  5224 000012C8 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  5225 000012CD 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  5226 000012CE CF                      	iret					;  a <CR> in the user's buffer, and
  5227                                  						;  returning directly to the user.
  5228                                  						; In this case the user is TCODE.
  5229                                  
  5230                                  ;=============================================================================
  5231                                  ; UNINIT.ASM, MSDOS 6.0 ,1991
  5232                                  ;=============================================================================
  5233                                  ; 24/09/2018 - Retro DOS v3.0
  5234                                  
  5235                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  5236                                  
  5237                                  ; TITLE	COMMAND Initialization messages
  5238                                  
  5239                                  ;INIT	SEGMENT PUBLIC PARA
  5240                                  
  5241                                  	; 25/09/2018
  5242                                  	; (15 bytes filler)
  5243 000012CF 00                      	db 0
  5244                                  	;db "25/9/2018 ETAN"
  5245 000012D0 30332F30332F323032-     	db "03/03/2023 ETAN" ; 02/03/2023	
  5245 000012D9 33204554414E       
  5246 000012DF 00                      	db 0
  5247                                  
  5248                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  5249                                  	;dw 0
  5250                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  5251 000012E0 0D0A                    	db 0Dh,0Ah
  5252 000012E2 0D0A                    	db 0Dh,0Ah
  5253 000012E4 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  5253 000012ED 285229204D532D444F-
  5253 000012F6 532852292020566572-
  5253 000012FF 73696F6E20332E3330 
  5254 00001308 0D0A                    	db 0Dh,0Ah
  5255 0000130A 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1987               '
  5255 00001313 20202020284329436F-
  5255 0000131C 70797269676874204D-
  5255 00001325 6963726F736F667420-
  5255 0000132E 436F72702031393831-
  5255 00001337 2D3139383720202020-
  5255 00001340 202020202020202020-
  5255 00001349 2020               
  5256 0000134B 200D0A                  	db ' ',0Dh,0Ah
  5257 0000134E 202020202020202020-     	db '                                                   ',
  5257 00001357 202020202020202020-
  5257 00001360 202020202020202020-
  5257 00001369 202020202020202020-
  5257 00001372 202020202020202020-
  5257 0000137B 202020202020       
  5258 00001381 0D0A00                  	db 0Dh,0Ah,0
  5259                                  
  5260                                  	; 03/03/2023	
  5261                                  	;times	43 db 20h
  5262                                  
  5263 00001384 537065636966696564-     _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  5263 0000138D 20434F4D4D414E4420-
  5263 00001396 736561726368206469-
  5263 0000139F 726563746F72792062-
  5263 000013A8 61640D0A00         
  5264                                  BADCOMLKMES:
  5265 000013AD [8413]                  	dw _152Fh
  5266                                  
  5267 000013AF 537065636966696564-     _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  5267 000013B8 20434F4D4D414E4420-
  5267 000013C1 736561726368206469-
  5267 000013CA 726563746F72792062-
  5267 000013D3 616420616363657373-
  5267 000013DC 2064656E6965640D0A-
  5267 000013E5 00                 
  5268                                  BADCOMACCMSG:
  5269 000013E6 [AF13]                  	dw _155Ah
  5270                                  
  5271 000013E8 416363657373206465-     _1593h:	db 'Access denied',0Dh,0Ah,0
  5271 000013F1 6E6965640D0A00     
  5272                                  ACCDENERR:
  5273 000013F8 [E813]                  	dw _1593h
  5274                                  
  5275 000013FA 4F7574206F6620656E-     _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  5275 00001403 7669726F6E6D656E74-
  5275 0000140C 2073706163650D0A00 
  5276                                  OUTENVMSG:
  5277 00001415 [FA13]                  	dw _15A5h
  5278                                  
  5279                                  BADVERMSG:
  5280 00001417 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah,'$'
  5280 00001420 20444F532076657273-
  5280 00001429 696F6E0D0A24       
  5281                                  
  5282                                  BADENVSIZMSG:
  5283 0000142F 496E76616C69642065-     	db 'Invalid environment size specified',0Dh,0Ah,'$'
  5283 00001438 6E7669726F6E6D656E-
  5283 00001441 742073697A65207370-
  5283 0000144A 656369666965640D0A-
  5283 00001453 24                 
  5284                                  
  5285                                  HEADERPTR:
  5286 00001454 [E012]                  	dw COPYRIGHTMSG
  5287                                  
  5288                                  ICONDEV:
  5289 00001456 2F4445562F                      db '/DEV/'
  5290 0000145B 434F4E                  	db 'CON'
  5291 0000145E 000000000000            	db 0,0,0,0,0,0		; Room for 8 char device	
  5292                                  BADCSPFL:
  5293 00001464 00                      	db 0
  5294                                  COMSPECT:
  5295 00001465 2F434F4D4D414E442E-     	db '/COMMAND.COM',0
  5295 0000146E 434F4D00           
  5296 00001472 00                      	db 0
  5297                                  AUTOBAT:
  5298 00001473 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0 
  5298 0000147C 45432E42415400     
  5299                                  PRDATTM:
  5300 00001483 FF                      	db -1 ; 0FFh		 ; Init not to prompt for date time
  5301                                  INITADD:
  5302 00001484 00000000                	dd 0
  5303                                  	;dw 0
  5304                                  	;dw 0
  5305                                  PRINTADD:
  5306 00001488 0534                    	dw PRINTF_INIT
  5307 0000148A 0000                    	dw 0
  5308                                  TRIAGEADD:
  5309 0000148C 9C1E                    	dw TRIAGE_INIT
  5310 0000148E 0000                    	dw 0
  5311                                  CHUCKENV:
  5312 00001490 00                      	db 0
  5313                                  COMSPOFFSET:
  5314                                  ECOMLOC:
  5315                                  	;dw 0Eh
  5316                                  	;dw offset ENVIRONMENT:ECOMSPEC-10h
  5317 00001491 0E00                    	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  5318                                  COMSPSTRING:
  5319 00001493 434F4D535045433D        	db 'COMSPEC='
  5320                                  
  5321                                  ; 02/03/2023
  5322                                  ;equal_sign:
  5323                                  ;	db '='
  5324                                  ;letter_a:
  5325                                  ;	db 'a'
  5326                                  ;letter_z:
  5327                                  ;	db 'z'
  5328                                  ;slash_chr:
  5329                                  ;	db '/'
  5330                                  ;bslash_chr:
  5331                                  ;	db '\'
  5332                                  ;space_chr:
  5333                                  ;	db 20h
  5334                                  ;letter_p:
  5335                                  ;	db 'p'
  5336                                  ;letter_d:
  5337                                  ;	db 'd'
  5338                                  ;letter_c:
  5339                                  ;	db 'c'
  5340                                  ;letter_A:
  5341                                  ;	db 'A'
  5342                                  ENVSIZ:
  5343 0000149B 0000                    	dw 0
  5344                                  ENVMAX:
  5345 0000149D 0000                    	dw 0
  5346                                  OLDENV:
  5347 0000149F 0000                    	dw 0
  5348                                  USEDENV:
  5349 000014A1 0000                    	dw 0
  5350                                  INITEND:
  5351 000014A3 0000                    	dw 0
  5352                                  TRNSIZE:
  5353 000014A5 0000                    	dw 0
  5354                                  RESETENV:
  5355 000014A7 0000                    	dw 0
  5356                                  
  5357                                  ;INIT	ENDS
  5358                                  
  5359                                  ;	END
  5360                                  
  5361                                  ;-----------------------------------------------------------------------------
  5362                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  5363                                  ;-----------------------------------------------------------------------------
  5364                                  
  5365                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  5366                                  ; 12/01/2023
  5367 000014A9 526574726F20444F53-     db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018-2023]"
  5367 000014B2 2076332E3020434F4D-
  5367 000014BB 4D414E442E434F4D20-
  5367 000014C4 6279204572646F6761-
  5367 000014CD 6E2054616E205B3230-
  5367 000014D6 31382D323032335D   
  5368 000014DE 00                      db	0
  5369                                  
  5370                                  ;-----------------------------------------------------------------------------
  5371                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  5372                                  ;-----------------------------------------------------------------------------
  5373                                  
  5374                                  ;TAIL    SEGMENT PUBLIC PARA
  5375                                  ;        ORG     0
  5376                                  ;TRANSTART       LABEL   WORD
  5377                                  ;TAIL    ENDS
  5378                                  
  5379 000014DF 90                      ALIGN 16  ; 25/09/2018
  5380                                  
  5381                                  ;TRANSTART:
  5382                                  
  5383                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  5384                                  ;	times	128 db 0	
  5385                                  
  5386                                  ;-----------------------------------------------------------------------------
  5387                                  ; SEGMENT - TRANSCODE
  5388                                  ;-----------------------------------------------------------------------------
  5389                                  
  5390                                  TRANGROUP: ; 21/04/2018
  5391                                  
  5392                                  ;=============================================================================
  5393                                  ; TRANCODE.ASM
  5394                                  ;=============================================================================
  5395                                  ; 24/09/2018 - Retro DOS v3.0
  5396                                  
  5397                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  5398                                  
  5399                                  ; 21/04/2018 - Retro DOS v2.0
  5400                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  5401                                  ; (these values must be changed when transcom.s source code is changed
  5402                                  ; and data offsets are changed)
  5403                                  ;
  5404                                  ; 30/04/2018
  5405                                  ; 29/04/2018
  5406                                  
  5407                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5408                                  ;COMMAND      EQU  012CH
  5409                                  ;DATINIT      EQU  2091H
  5410                                  ;HEADCALL     EQU  428FH
  5411                                  ;TRANSPACEEND EQU  4D5CH
  5412                                  ;TRANDATAEND  EQU  3F44H
  5413                                  
  5414                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TRNSEG offset addresses)
  5415                                  ;TRIAGE_INIT  EQU  1F15H
  5416                                  ;PRINTF_INIT  EQU  34E0H 
  5417                                  
  5418                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  5419                                  
  5420                                  ;TPA	EQU  4293H
  5421                                  ;TRNLEN	EQU  04D6H
  5422                                  
  5423                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  5424                                  COMMAND      EQU  012CH
  5425                                  ;GETEXTERRNUM EQU 1ECCH ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  5426                                  ;TRIAGE_INIT EQU  1EF3H
  5427                                  ;DATINIT     EQU  206FH
  5428                                  ; 03/03/2023
  5429                                  GETEXTERRNUM EQU  1E75H
  5430                                  TRIAGE_INIT  EQU  1E9CH
  5431                                  DATINIT	     EQU  1FFCH		
  5432                                  PRINTF_INIT  EQU  3405H
  5433                                  TRANDATAEND  EQU  3E25H
  5434                                  HEADCALL     EQU  4164H
  5435                                  TRANSPACEEND EQU  4C32H
  5436                                  
  5437                                  ;-----------------------------------------------------------------------------
  5438                                  ;START OF TRANSIENT PORTION
  5439                                  ;This code is loaded at the end of memory and may be overwritten by
  5440                                  ;memory-intensive user programs.
  5441                                  ;-----------------------------------------------------------------------------
  5442                                  
  5443                                  ;TRANSTART EQU $
  5444                                  ; 29/09/2018 
  5445                                  TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  5446                                  
  5447                                  ; 25/09/2018
  5448                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  5449                                  ;
  5450                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  5451                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  5452                                  ;
  5453                                  TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  5454                                  ;
  5455                                  
  5456                                  ;COMTRANS:
  5457                                  
  5458                                  ; 20/10/2018 - Retro DOS v3.0	
  5459 000014E0 <bin 4C32h>             INCBIN	"TRANCOM3.BIN"
  5460                                  
  5461                                  ;COMLEN	EQU $-COMTRANS	; End of COMMAND load.
  5462                                  
  5463                                  ; 29/04/2018
  5464                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  5465                                  ;
  5466                                  ;TIMES BSS_SIZE db 0
  5467                                  ;
  5468                                  ;COMLEN	EQU $-COMTRANS	; 30/04/2018
  5469                                  
  5470                                  ;COMMANDCOMSIZE equ $ - 100h
