//
// +-------------------------------------------------------------------------+
// |   This file has been generated by The Interactive Disassembler (IDA)    |
// |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
// |                            Freeware version                             |
// +-------------------------------------------------------------------------+
//
//
//      This file should be used in the following way:
//         - reload executable into IDA with using switch -c
//         - use File, Load IDC file and load this file.
//
//      NOTE: This file doesn't contain all information from the database.
//

#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
  // set 'loading idc file' mode
  set_inf_attr(INF_GENFLAGS, INFFL_LOADIDC|get_inf_attr(INF_GENFLAGS));
  GenInfo();            // various settings
  Segments();           // segmentation
  Enums();              // enumerations
  Structures();         // structure types
  ApplyStrucTInfos();   // structure type infos
  Patches();            // manual patches
  SegRegs();            // segment register values
  Bytes();              // individual bytes (code,data)
  Functions();          // function definitions
  // clear 'loading idc file' mode
  set_inf_attr(INF_GENFLAGS, ~INFFL_LOADIDC&get_inf_attr(INF_GENFLAGS));
}

//------------------------------------------------------------------------
// General information

static GenInfo(void) {

        delete_all_segments();    // purge database
	set_processor_type("80386r", SETPROC_USER);
	set_inf_attr(INF_COMPILER, 0);
	set_inf_attr(INF_STRLIT_BREAK, 0xA);
	set_flag(INF_CMTFLAG, SW_ALLCMT, 0);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_VOID, 0);
	set_inf_attr(INF_XREFNUM, 2);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_AUTO, 1);
	set_inf_attr(INF_INDENT, 16);
	set_inf_attr(INF_COMMENT, 40);
	set_inf_attr(INF_MAXREF, 0x10);
}

//------------------------------------------------------------------------
// Information about segmentation

static Segments(void) {
	set_selector(0X1,0);
	;
	add_segm_ex(0,0X5F0,0X1,0,1,2,ADDSEG_NOSREG);
	SegRename(0,"MSLOAD");
	SegClass (0,"CODE");
	SegDefReg(0x0,"es",0x0);
	SegDefReg(0x0,"ss",0x0);
	SegDefReg(0x0,"ds",0x0);
	SegDefReg(0x0,"fs",0x0);
	SegDefReg(0x0,"gs",0x0);
	set_segm_type(0,2);
	add_segm_ex(0X5F0,0X3530,0X5F,0,1,2,ADDSEG_NOSREG);
	SegRename(0X5F0,"BIOSDATA");
	SegClass (0X5F0,"BIOSDATA");
	add_segm_ex(0X3530,0X5330,0X353,0,1,2,ADDSEG_NOSREG);
	SegRename(0X3530,"BIOSCODE");
	SegClass (0X3530,"BIOSCODE");
	add_segm_ex(0X5330,0XAE70,0X533,0,1,2,ADDSEG_NOSREG);
	SegRename(0X5330,"SYSINIT");
	SegClass (0X5330,"SYSINIT");
	set_inf_attr(INF_LOW_OFF, 0x0);
	set_inf_attr(INF_HIGH_OFF, 0xAE70);
}

//------------------------------------------------------------------------
// Information about enum types

static Enums(void) {
        auto id;
        begin_type_updating(UTP_ENUM);
        end_type_updating(UTP_ENUM);
}

//------------------------------------------------------------------------
// Information about type information for structure members

static ApplyStrucTInfos() {
}

//------------------------------------------------------------------------
// Information about structure types

static Structures(void) {
        auto id;
        begin_type_updating(UTP_STRUCT);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_0(void) {
        auto x;
#define id x

	update_extra_cmt		(0,	E_PREV + 0,	"; File Name   : C:\\Yedek\\pcdos_7_1\\IBMBIO.COM");
	update_extra_cmt		(0,	E_PREV + 1,	"; Format      : Binary file");
	update_extra_cmt		(0,	E_PREV + 2,	"; Base Address: 0000h Range: 0000h - AE70h Loaded length: AE70h");
	create_insn	(0);
	set_name	(0,	"START$");
	create_byte	(0X2);
	create_byte	(0X3);
	set_name	(0X3,	"SysVersionMajor");
	create_byte	(x=0X4);
	op_dec		(x,	0);
	set_name	(0X4,	"SysVersionMinor");
	create_word	(0X5);
	set_name	(0X5,	"NumHeads");
	create_word	(0X7);
	set_name	(0X7,	"ClusterSize");
	create_word	(0X9);
	set_name	(0X9,	"StartSecL");
	create_word	(0XB);
	set_name	(0XB,	"StartSecH");
	create_word	(0XD);
	set_name	(0XD,	"TempH");
	create_word	(0XF);
	set_name	(0XF,	"TempCluster");
	create_word	(0X11);
	set_name	(0X11,	"LastFatSectorL");
	create_word	(0X13);
	set_name	(0X13,	"LastFatSectorH");
	create_word	(0X15);
	set_name	(0X15,	"SectorCount");
	create_word	(0X17);
	set_name	(0X17,	"FATSectorsL");
	create_word	(0X19);
	set_name	(0X19,	"FATSectorsH");
	create_word	(0X1B);
	set_name	(0X1B,	"HiddenSectorsL");
	create_word	(0X1D);
	set_name	(0X1D,	"HiddenSectorsH");
	create_word	(0X1F);
	set_name	(0X1F,	"BytesPerSec");
	create_word	(0X21);
	set_name	(0X21,	"ReservSectors");
	create_word	(0X23);
	set_name	(0X23,	"CurrentClusterL");
	create_word	(0X25);
	set_name	(0X25,	"CurrentClusterH");
	create_word	(0X27);
	set_name	(0X27,	"NextBioLocation");
	create_word	(0X29);
	set_name	(0X29,	"FirstSectorL");
	create_word	(0X2B);
	set_name	(0X2B,	"FirstSectorH");
	create_word	(0X2D);
	set_name	(0X2D,	"TotalSectorsL");
	create_word	(0X2F);
	set_name	(0X2F,	"TotalSectorsH");
	create_word	(0X31);
	set_name	(0X31,	"SecPerTrack");
	create_byte	(0X33);
	set_name	(0X33,	"BootDrive");
	create_byte	(0X34);
	set_name	(0X34,	"FatType");
	create_byte	(0X35);
	set_name	(0X35,	"MediaByte");
	create_byte	(0X36);
	set_name	(0X36,	"EndOfFile");
	create_dword	(0X37);
	set_name	(0X37,	"OrgDasdPtr");
	create_word	(0X3B);
	set_name	(0X3B,	"FatSegment");
	create_byte	(0X3D);
	set_name	(0X3D,	"SecPerCluster");
	create_byte	(0X3E);
	set_name	(0X3E,	"NumFats");
	create_word	(0X3F);
	set_name	(0X3F,	"RootEntCnt");
	create_word	(0X41);
	set_name	(0X41,	"RootClusterL");
	create_word	(0X43);
	set_name	(0X43,	"RootClusterH");
	create_word	(0X45);
	make_array	(0X45,	0X2);
	set_name	(0X45,	"FirstCluster");
	set_cmt	(0X49,	"Start sector # of data\n(high word in ax and also in es)",	0);
	create_insn	(0X49);
	set_name	(0X49,	"SaveInputValues");
	set_cmt	(0X4E,	"BPB_Media",	0);
	set_cmt	(0X53,	"BS_DrvNum",	0);
	set_cmt	(0X58,	"from BS code..\nss:sp = 0:7BE4h, bp = 7BECh\nClear stack and load disk parameters table in ds:si\n\npop.. Original INT 1Eh vector address",	0);
	set_cmt	(0X5A,	"pop.. Original INT 1Eh disk table address",	0);
	set_cmt	(0X69,	"0",	0);
	set_cmt	(0X6B,	"0",	0);
	set_cmt	(0X6D,	"INT 1Eh disk parameters table address\n(it is set by boot sector code)",	0);
	create_insn	(x=0X6D);
	create_insn	(x=0X71);
	set_cmt	(0X75,	"Sec9 ; new location of DSK_PARMS",	0);
	set_cmt	(0X78,	"(11+3 bytes for IBM rombios)",	0);
	create_insn	(x=0X78);
	op_dec		(x,	1);
	set_cmt	(0X80,	"Offset Sec9",	0);
	create_insn	(x=0X80);
	op_hex		(x,	1);
	create_insn	(x=0X86);
	set_cmt	(0X8A,	"LW of IBMBIO.COM (IO.SYS) first cluster",	0);
	create_insn	(x=0X8A);
	set_cmt	(0X93,	"HW of IBMBIO.COM (IO.SYS) first cluster",	0);
	create_insn	(x=0X93);
	set_cmt	(0X9C,	"BPB_BytsPerSec ; 512",	0);
	create_insn	(x=0X9C);
	set_cmt	(0XA5,	"BPB_SecPerClus",	0);
	create_insn	(x=0XA5);
	set_cmt	(0XAE,	"BPB_SecPerTrk",	0);
	set_cmt	(0XB7,	"BPB_NumHeads",	0);
	create_insn	(x=0XB7);
	set_cmt	(0XC0,	"BPB_FATSz16",	0);
	set_cmt	(0XC9,	"BS_BootSig ; (FAT12 and FAT16)",	0);
	create_insn	(x=0XC9);
	set_cmt	(0XD1,	"BS_BootSig ; (FAT32)",	0);
	set_cmt	(0XD5,	"BPB_NumFATs",	0);
	set_name	(0XD5,	"not_fat32");
	set_cmt	(0XDE,	"BPB_RootEntCnt",	0);
	set_cmt	(0XE7,	"BPB_RsvdSecCnt",	0);
	set_cmt	(0XF0,	"BPB_HiddSec",	0);
	set_cmt	(0XF9,	"BPB_TotSec16",	0);
	create_insn	(x=0XF9);
	create_insn	(x=0X102);
	op_hex		(x,	1);
	set_cmt	(0X105,	"old boot sector,\nno need to copy high words",	0);
	set_cmt	(0X107,	"Start sector # of data, high word",	0);
	set_cmt	(0X10B,	"BPB_HiddSec+2",	0);
	set_cmt	(0X117,	"BPB_TotSec32",	0);
	set_cmt	(0X11E,	"BPB_TotSec32+2",	0);
	set_name	(0X125,	"not_big");
	set_cmt	(0X12B,	"FAT12 or FAT16 fs",	0);
	set_cmt	(0X12D,	"BPB_FATSz32 ; FAT32 fs",	0);
	create_insn	(x=0X12D);
	set_cmt	(0X136,	"BPB_FATSz32+2",	0);
	create_insn	(x=0X136);
	set_cmt	(0X13F,	"BPB_RootClus",	0);
	create_insn	(x=0X13F);
	set_cmt	(0X148,	"BPB_RootClus+2",	0);
	create_insn	(x=0X148);
	set_cmt	(0X151,	"copy code from start to top of memory\nthe length to copy is EndOfLoader\njump to relocated code",	0);
	set_name	(0X151,	"Relocate");
	set_cmt	(0X156,	"MEMORY SIZE - \nReturn: AX = number of contiguous 1K blocks of memory",	0);
	create_insn	(x=0X156);
	op_hex		(x,	0);
	set_cmt	(0X15C,	"Check if an RPL program is present at TOM\n and do not tromp over it",	0);
	set_cmt	(0X160,	"2Fh*4",	0);
	create_insn	(x=0X160);
	set_cmt	(0X164,	"2Fh*4+2",	0);
	create_insn	(x=0X164);
	set_cmt	(0X168,	"'RP' ; 'RPL'",	0);
	create_insn	(x=0X168);
	op_hex		(x,	1);
	set_cmt	(0X16F,	"'L'",	0);
	create_insn	(x=0X16F);
	op_hex		(x,	1);
	set_cmt	(0X175,	"get TOM into DX",	0);
	set_cmt	(0X17A,	"Get new TOM from any RPL",	0);
	create_insn	(x=0X17A);
	op_hex		(x,	0);
	set_name	(0X17E,	"Skip_RPL");
	set_cmt	(0X18E,	"Offset EndOfLoader (1520)",	0);
	set_cmt	(0X19A,	"Loader size = EndofLoader - 0",	0);
	create_insn	(x=0X19A);
	op_dec		(x,	1);
	set_cmt	(0X19F,	"Far jump to relocated MSLOAD code\n(via retf, far return)",	0);
	create_insn	(x=0X1A0);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	create_insn	(0X1A5);
	set_name	(0X1A5,	"SetupStack");
	set_cmt	(0X1A7,	"move ss to 400h backward for stack space\nthen set sp to the end of this stack space",	0);
	create_insn	(x=0X1A7);
	op_hex		(x,	1);
	create_insn	(x=0X1AC);
	op_hex		(x,	1);
	set_cmt	(0X1AF,	"ax = cs",	0);
	create_insn	(x=0X1AF);
	op_hex		(x,	1);
	set_name	(0X1B4,	"FindClusterSize");
	set_cmt	(0X1C6,	"cluster size in bytes",	0);
	create_insn	(0X1C6);
	set_name	(0X1C6,	"CalcFatSize");
	set_cmt	(0X1C9,	"FAT12",	0);
	set_cmt	(0X1D9,	"dx:ax = Total available sectors",	0);
	set_cmt	(0X1E6,	"calculate total FAT sectors",	0);
	set_cmt	(0X1F9,	"dx:ax = Total sectors - FAT sectors",	0);
	set_cmt	(0X201,	"16 directory entries per sector",	0);
	set_cmt	(0X205,	"dx:ax = data sectors\n(Note: [RootEntCnt] is 0 for FAT32 fs)",	0);
	set_cmt	(0X208,	"\n32 bit divide by sectors per\n cluster to find total number\n of clusters.",	0);
	set_cmt	(0X21F,	"set FAT type to FAT32 (CHS type disk R/W)",	0);
	set_cmt	(0X224,	"is cluster count > 65535 ?",	0);
	set_cmt	(0X229,	"yes, it is (it must be) FAT32 fs",	0);
	set_cmt	(0X22B,	"FAT16 limit (65536-10)",	0);
	set_cmt	(0X232,	"clear HW of FirstCluster",	0);
	set_cmt	(0X236,	"set FAT type fo FAT12",	0);
	set_cmt	(0X23B,	"4086 ; (4096-10)",	0);
	set_cmt	(0X240,	"set FAT type to FAT16",	0);
	set_cmt	(0X245,	"dx:ax = BIOS starting cluster",	0);
	set_name	(0X245,	"ReadInFirstCluster");
	set_cmt	(0X248,	"First cluster is 2 so\ndecrement to make 0 based",	0);
	set_cmt	(0X24E,	"Initialize to this cluster",	0);
	set_cmt	(0X255,	"(Note: PCDOS 7.1 bs loads 1st 4 sectors of IBMBIO.COM)\nIf cluster size > 3, al = 0, ah <> 0\nIf cluster size = 2, al = 1, ah = 1\nIf cluster size = 1, al = 3, ah = 0\nIf ah = 0, nothing remaining in last cluster",	0);
	set_cmt	(0X261,	"Calculate sector to start reading from\nin StartSecH and StartSecL",	0);
	set_cmt	(0X263,	"(*)",	0);
	set_cmt	(0X27C,	"Add number of sectors already loaded\n   to start sector",	0);
	set_cmt	(0X2A7,	"(*) number of clusters already loaded \n(0 or 1) \n(Note: if al=0, the 1st 4 sectors of the 1st cluster\n will be loaded again! -PCDOS 7.1-)",	0);
	set_cmt	(0X2AD,	"IBMBIO.COM (IO.SYS) loading address (segment = 0)",	0);
	set_cmt	(0X2B6,	"read 1 cluster",	0);
	set_cmt	(0X2C0,	"+1 cluster loaded",	0);
	set_cmt	(0X2C1,	"ax = total clusters read in based 2",	0);
	set_name	(0X2C1,	"SetNextClusterNum");
	set_cmt	(0X2C2,	"CurrentCluster = Last cluster read",	0);
	set_cmt	(0X2CB,	"ax = number of clusters loaded",	0);
	set_name	(0X2CC,	"SaveLoadedBios");
	set_cmt	(0X2CD,	"Get total bytes loaded by this is always < 64k,\nso lower 16 bits ok",	0);
	set_cmt	(0X2D1,	"get portion of iosys loaded\nEndOfLoader ; (Offset EndOfLoader)-(Offset Start)",	0);
	set_cmt	(0X2D6,	"Segment at 70h",	0);
	create_insn	(x=0X2D6);
	op_hex		(x,	1);
	set_cmt	(0X2DD,	"EndOfLoader",	0);
	set_cmt	(0X2E4,	"Save where location for next read",	0);
	set_cmt	(0X2EA,	"go find clusters as long as they are contiguous",	0);
	set_name	(0X2EA,	"GetContigClusters");
	set_cmt	(0X2F6,	"Returns next cluster to read in di:ax",	0);
	set_cmt	(0X30D,	"Zero base the cluster (32 bit as di:ax)",	0);
	set_cmt	(0X312,	"32 bit multiplication\n(dx:ax)*cx",	0);
	create_insn	(x=0X337);
	op_hex		(x,	1);
	set_cmt	(0X34A,	"Set up required registers for iosys,\n then jump to it (70:0)\n\nRestore regs required for msint",	0);
	create_insn	(0X34A);
	set_name	(0X34A,	"GoToBioInit");
	set_cmt	(0X34E,	"Physical drv number we booted from",	0);
	set_cmt	(0X356,	"bx:ax = first data sector of disk",	0);
	set_cmt	(0X359,	"Set ds:si to Original INT 1Eh disk(ette) table address\nand then push disk table address and INT 1Eh vector to stack\n(set stack content just as at the start of MSLOAD)",	0);
	set_cmt	(0X35D,	"INT 1Eh original table segment",	0);
	set_cmt	(0X35E,	"INT 1Eh original table offset",	0);
	set_cmt	(0X35F,	"0  ; INT 1Eh vector segment",	0);
	set_cmt	(0X362,	"1Eh*4 = 78h",	0);
	create_insn	(x=0X362);
	op_hex		(x,	1);
	set_cmt	(0X365,	"INT 1Eh vector offset",	0);
	set_cmt	(0X366,	"Far jump to IoSysAddr (DOSBIOS)",	0);
	create_insn	(x=0X366);
	create_insn	(0X36B);
	set_name	(0X36B,	"check_int13h_extensions");
	set_cmt	(0X36F,	"zero (buffer offset 24)\n(bytes per sector)",	0);
	create_insn	(x=0X372);
	op_dec		(x,	1);
	set_cmt	(0X375,	"info flags",	0);
	set_cmt	(0X376,	"Result buffer size",	0);
	create_insn	(x=0X376);
	op_dec		(x,	1);
	create_insn	(x=0X380);
	op_hex		(x,	1);
	set_cmt	(0X38A,	"DISK - IBM/MS Extension - GET DRIVE PARAMETERS\n(DL - drive, DS:SI - buffer)",	0);
	create_insn	(x=0X38A);
	op_hex		(x,	0);
	set_cmt	(0X38F,	"bytes per sector, buffer offset 24",	0);
	create_insn	(x=0X392);
	op_dec		(x,	1);
	create_insn	(0X39B);
	set_name	(0X39B,	"ReadSectors");
	set_cmt	(0X39E,	"(*)",	0);
	set_name	(0X39E,	"TryRead");
	set_cmt	(0X3A6,	"(**)",	0);
	set_cmt	(0X3AC,	"LBA read",	0);
	set_cmt	(0X3AE,	"0",	0);
	set_cmt	(0X3AF,	"0",	0);
	set_cmt	(0X3B1,	"0:0:dx:ax = start sector (8 bytes)",	0);
	set_cmt	(0X3B3,	"memory buffer address (seg:off)",	0);
	set_cmt	(0X3B4,	"number of sectors to read",	0);
	set_cmt	(0X3B8,	"size of DAP",	0);
	create_insn	(x=0X3B8);
	create_insn	(x=0X3BE);
	op_hex		(x,	1);
	set_cmt	(0X3C8,	"DISK - IBM/MS Extension - EXTENDED READ\n(DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X3C8);
	op_hex		(x,	0);
	set_cmt	(0X3CB,	"sector number, hw",	0);
	set_cmt	(0X3CE,	"size of DAP (disk address packet) = 16",	0);
	set_cmt	(0X3CF,	"number of sectors to read",	0);
	set_cmt	(0X3D0,	"(**) discard ax on stack (StartSectorL)",	0);
	set_cmt	(0X3D1,	"sp points to cx (*)",	0);
	set_cmt	(0X3D3,	"remaining retry count value",	0);
	create_insn	(0X3D7);
	set_name	(0X3D7,	"lba_read_err");
	set_cmt	(0X3D9,	"start sector, hw",	0);
	set_name	(0X3D9,	"chs_read");
	set_cmt	(0X3DD,	"hw of disk (LBA) address\n(must not be > sectors per track)",	0);
	set_name	(0X3E3,	"ErrorOut");
	create_insn	(x=0X3E5);
	op_plain_offset	(x,	1,	0);
	op_plain_offset	(x,	129,	0);
	set_name	(0X3E8,	"WriteTTY");
	set_cmt	(0X3F1,	"- VIDEO - ",	0);
	create_insn	(x=0X3F1);
	op_hex		(x,	0);
	create_insn	(0X3F5);
	set_name	(0X3F5,	"wait_key_reboot");
	set_cmt	(0X3F7,	"KEYBOARD - ",	0);
	create_insn	(x=0X3F7);
	op_hex		(x,	0);
	create_insn	(x=0X402);
	set_cmt	(0X40A,	"DISK BOOT\ncauses reboot of disk system",	0);
	create_insn	(x=0X40A);
	op_hex		(x,	0);
	set_cmt	(0X40C,	"32 bit division",	0);
	set_name	(0X40C,	"DoDivide");
	set_cmt	(0X413,	"start sector, lw",	0);
	set_cmt	(0X41C,	"dx = start sector on (same) track",	0);
	set_cmt	(0X41E,	"sectors to read on (same) track (remain sectors)",	0);
	set_cmt	(0X42A,	"Sector numbers are 1-based",	0);
	set_name	(0X42A,	"GotLength");
	set_cmt	(0X42E,	"dx:ax = Track",	0);
	set_cmt	(0X437,	"Start cyl in ax, head in dl",	0);
	set_cmt	(0X43F,	"[TempH]:ax = Cylinder, dx = Head\n\nAt this moment, we assume that TempH = 0,\nax <= 1024, dx <= 255",	0);
	set_cmt	(0X443,	"\nIssue one read request.\nes:bx have the transfer address,\nal is the number of sectors.",	0);
	set_cmt	(0X447,	"Shift cyl high bits up",	0);
	set_cmt	(0X449,	"Mix in with sector bits",	0);
	set_cmt	(0X44B,	"Setup cyl low",	0);
	set_cmt	(0X44D,	"Setup cyl/high - sector",	0);
	set_cmt	(0X44F,	"Get back OFFSET",	0);
	set_cmt	(0X451,	"Get drive",	0);
	set_cmt	(0X455,	"Get number of sectors to read (al)",	0);
	set_cmt	(0X457,	"Read",	0);
	set_cmt	(0X459,	"Save read count",	0);
	set_cmt	(0X45B,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X45B);
	set_cmt	(0X46C,	"DISK - RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)",	0);
	create_insn	(x=0X46C);
	set_cmt	(0X470,	"Get retry count back",	0);
	create_insn	(0X476);
	set_name	(0X476,	"ReadError");
	create_insn	(0X479);
	set_cmt	(0X47C,	" Mask out read command, just get # read",	0);
	create_insn	(0X47C);
	set_name	(0X47C,	"ReadOk");
	set_cmt	(0X47E,	"Bump number down",	0);
	set_cmt	(0X484,	"Where to start next time",	0);
	set_cmt	(0X48D,	"Get number sectors read",	0);
	set_cmt	(0X494,	"Get total bytes read",	0);
	set_cmt	(0X496,	"Add it to offset",	0);
	create_insn	(0X49B);
	set_name	(0X49B,	"EndRead");
	create_insn	(0X49C);
	set_name	(0X49C,	"GetNextFatEntry");
	set_cmt	(0X4A2,	"END_OF_FILE ; Assume last cluster",	0);
	set_cmt	(0X4A7,	"Get last cluster",	0);
	set_cmt	(0X4AE,	"FAT32 (CHS) fs ?",	0);
	set_name	(0X4AE,	"chk_fat32_type");
	set_cmt	(0X4B3,	"no",	0);
	set_cmt	(0X4B5,	"Multiply cluster number by 4",	0);
	set_name	(0X4B5,	"Got32Bit");
	set_cmt	(0X4BB,	"Get the FAT offset (di:si)",	0);
	set_cmt	(0X4C9,	"FAT32 cluster numbers are 28 bit numbers\n(higher 4 bits are -must be- zero)",	0);
	set_name	(0X4D2,	"GotFAT32ClusterDone");
	create_insn	(0X4D4);
	set_name	(0X4D4,	"chk_fat_type");
	set_name	(0X4DB,	"Got12Bit");
	create_insn	(x=0X4DF);
	op_hex		(x,	1);
	create_insn	(x=0X4E1);
	op_hex		(x,	1);
	set_cmt	(0X4E5,	"di:si = dx:ax * 1.5 = dx:ax + dx:ax/2",	0);
	set_cmt	(0X4F0,	"Spitted cluster number,\n read next FAT sector",	0);
	set_cmt	(0X4FF,	"Read next fat sector",	0);
	create_insn	(x=0X503);
	create_insn	(0X50F);
	set_name	(0X50F,	"ClusterOk");
	create_insn	(x=0X512);
	op_hex		(x,	1);
	set_name	(0X512,	"EvenOdd");
	create_insn	(x=0X51B);
	op_hex		(x,	1);
	create_insn	(0X520);
	set_name	(0X520,	"OddResult");
	set_name	(0X524,	"TestEOF");
	create_insn	(0X52D);
	set_name	(0X52D,	"Got16Bit");
	set_cmt	(0X530,	"Multiply cluster by 2",	0);
	create_insn	(x=0X530);
	op_hex		(x,	1);
	set_cmt	(0X534,	"Get the FAT offset (di:si)",	0);
	set_cmt	(0X53A,	"HW of cluster number is 0",	0);
	set_name	(0X542,	"GotClusterDoneJ");
	set_cmt	(0X544,	"NOT END_OF_FILE ; Assume not last cluster",	0);
	set_name	(0X544,	"NotLastCluster");
	set_name	(0X54A,	"GotClusterDone");
	set_cmt	(0X54C,	"di:si = byte offset in (entire) FAT",	0);
	create_insn	(0X54C);
	set_name	(0X54C,	"GetFatSector");
	set_cmt	(0X54F,	"32 bit division (dx:ax/512)",	0);
	set_cmt	(0X561,	"dx = byte offset in the FAT sector",	0);
	set_cmt	(0X563,	"FAT32 (32 bit cluster numbers)",	0);
	set_cmt	(0X569,	"The same fat sector?",	0);
	set_cmt	(0X56D,	"Don't need to read it again.",	0);
	set_cmt	(0X595,	"buffer address: es:0",	0);
	set_cmt	(0X59F,	"cx = sector size - 1  (= 511)",	0);
	set_cmt	(0X5A0,	"If last byte of sector, splitted entry.",	0);
	set_cmt	(0X5A2,	"set bx to dx",	0);
	set_cmt	(0X5A7,	"If zf = 1, it is splitted\n (next FAT12 sector will be read)",	0);
	set_cmt	(0X5A8,	"EndOfLoader (MSLOAD:05F0h)",	0);
	create_strlit	(0X5A8,	0X5F0);
	set_name	(0X5A8,	"NonSystemDiskMsg");
	set_cmt	(0X5F0,	"BData_start",	0);
	create_insn	(0X5F0);
	set_name	(0X5F0,	"hdrv_pat");
	create_word	(0X5F3);
	set_name	(0X5F3,	"DosDataSg");
	set_cmt	(0X5F5,	"far jump to int_2f",	0);
	create_byte	(0X5F5);
	set_name	(0X5F5,	"bios_i2f");
	create_word	(x=0X5F6);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X5F8,	"IOSYSCODESEG (IBMBIO.COM code segment)\nBIOSCODE (2F4h+070h) segment",	0);
	create_word	(0X5F8);
	set_name	(0X5F8,	"bios_i2f_seg");
	create_word	(0X5FA);
	set_name	(0X5FA,	"romstartaddr");
	create_byte	(0X5FC);
	set_name	(0X5FC,	"altah");
	create_byte	(0X5FD);
	set_name	(0X5FD,	"inHMA");
	create_dword	(0X5FE);
	set_name	(0X5FE,	"xms");
	create_dword	(0X602);
	set_name	(0X602,	"ptrsav");
	create_byte	(0X606);
	make_array	(0X606,	0X4);
	set_name	(0X606,	"auxbuf");
	create_word	(0X60A);
	set_name	(0X60A,	"zeroseg");
	create_word	(0X60C);
	set_name	(0X60C,	"i13_ds");
	create_word	(0X60E);
	set_name	(0X60E,	"prevoper");
	create_byte	(0X610);
	set_name	(0X610,	"number_of_sec");
	create_word	(0X611);
	set_name	(0X611,	"auxnum");
	set_cmt	(0X613,	"CONHeader\nHEADER FOR DEVICE \"CON\"",	0);
	create_word	(x=0X613);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X613,	"res_dev_list");
	create_word	(0X615);
	create_word	(0X617);
	create_word	(x=0X619);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X61B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X61D,	0X625);
	set_cmt	(0X625,	"HEADER FOR DEVICE \"AUX\"",	0);
	create_word	(x=0X625);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X625,	"auxdev2");
	create_word	(0X627);
	create_word	(0X629);
	create_word	(x=0X62B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X62D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X62F,	0X637);
	set_cmt	(0X637,	"HEADER FOR DEVICE \"PRN\"",	0);
	create_word	(x=0X637);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X637,	"prndev2");
	create_word	(0X639);
	create_word	(0X63B);
	create_word	(x=0X63D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X63F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X641,	0X649);
	set_cmt	(0X649,	"HEADER FOR DEVICE \"CLOCK$\"",	0);
	create_word	(x=0X649);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X649,	"timdev");
	create_word	(0X64B);
	create_word	(0X64D);
	create_word	(x=0X64F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X651);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X653,	0X65B);
	set_cmt	(0X65B,	"HEADER FOR DISK DEVICES",	0);
	create_word	(x=0X65B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X65B,	"dskdev");
	create_word	(0X65D);
	create_word	(0X65F);
	create_word	(x=0X661);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X663);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X665,	"maximum number of drives",	0);
	create_byte	(0X665);
	set_name	(0X665,	"drvmax");
	set_cmt	(0X666,	"-2 ; last drive accessed",	0);
	create_byte	(0X666);
	set_name	(0X666,	"step_drv");
	set_cmt	(0X667,	"96tpi support",	0);
	create_byte	(0X667);
	set_name	(0X667,	"fhave96");
	set_cmt	(0X668,	"used to detect single drive systems",	0);
	create_byte	(0X668);
	set_name	(0X668,	"single");
	set_cmt	(0X669,	"indicates if this is a k09 or not\nused by console driver.",	0);
	create_byte	(0X669);
	set_name	(0X669,	"fhavek09");
	set_cmt	(0X66A,	"= 1 if we are setting the owner of a drive.\n(examined by checksingle)",	0);
	create_byte	(0X66A);
	set_name	(0X66A,	"fsetowner");
	set_cmt	(0X66B,	"Device Header for device \"COM1\"",	0);
	create_word	(x=0X66B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X66B,	"com1dev");
	create_word	(0X66D);
	create_word	(0X66F);
	create_word	(x=0X671);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X673);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X675,	0X67D);
	set_cmt	(0X67D,	"Device Header for device LPT1",	0);
	create_word	(x=0X67D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X67D,	"lpt1dev");
	create_word	(0X67F);
	create_word	(0X681);
	create_word	(x=0X683);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X685);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X687,	0X68F);
	set_cmt	(0X68F,	"Device Header for device LPT2",	0);
	create_word	(x=0X68F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X68F,	"lpt2dev");
	create_word	(0X691);
	create_word	(0X693);
	create_word	(x=0X695);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X697);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X699,	0X6A1);
	create_byte	(0X6A1);
	make_array	(0X6A1,	0X3);
	set_cmt	(0X6A4,	"to make Orig13 offset 0B4h",	0);
	create_dword	(0X6A4);
	set_name	(0X6A4,	"Orig13");
	set_cmt	(0X6A8,	"Device Header for device LPT3",	0);
	create_word	(x=0X6A8);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X6A8,	"lpt3dev");
	create_word	(0X6AA);
	create_word	(0X6AC);
	create_word	(x=0X6AE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X6B0);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X6B2,	0X6BA);
	set_cmt	(0X6BA,	"Device Header for device \"COM2\"",	0);
	create_word	(x=0X6BA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X6BA,	"com2dev");
	create_word	(0X6BC);
	create_word	(0X6BE);
	create_word	(x=0X6C0);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X6C2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X6C4,	0X6CC);
	set_cmt	(0X6CC,	"Device Header for device \"COM3\"",	0);
	create_word	(x=0X6CC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X6CC,	"com3dev");
	create_word	(0X6CE);
	create_word	(0X6D0);
	create_word	(x=0X6D2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X6D4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X6D6,	0X6DE);
	set_cmt	(0X6DE,	"Device Header for device \"COM4\"",	0);
	create_word	(0X6DE);
	set_name	(0X6DE,	"com4dev");
	create_word	(0X6E0);
	create_word	(0X6E2);
	create_word	(x=0X6E4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X6E6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X6E8,	0X6F0);
	create_byte	(0X6F0);
	set_name	(0X6F0,	"RomVectors");
	create_dword	(0X6F1);
	set_name	(0X6F1,	"Old10");
	create_byte	(0X6F5);
	create_dword	(0X6F6);
	set_name	(0X6F6,	"Old13");
	create_byte	(0X6FA);
	create_dword	(0X6FB);
	set_name	(0X6FB,	"Old15");
	create_byte	(0X6FF);
	create_dword	(0X700);
	set_name	(0X700,	"Old19");
	create_byte	(0X704);
	set_cmt	(0X705,	";\nEndRomVectors equ $\nNUMROMVECTORS equ ((EndRomVectors - RomVectors)/5)\n;",	0);
	create_dword	(0X705);
	set_name	(0X705,	"Old1B");
	set_cmt	(0X709,	"Start of linked list of BDS's",	0);
	create_word	(x=0X709);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X709,	"start_bds");
	set_cmt	(0X70B,	"BIOSDATA segment",	0);
	create_word	(0X70B);
	create_byte	(0X70D);
	set_name	(0X70D,	"accesscount");
	create_byte	(0X70E);
	set_name	(0X70E,	"tim_drv");
	create_byte	(0X70F);
	set_name	(0X70F,	"medbyt");
	set_cmt	(0X710,	"2 for read, 3 for write",	0);
	create_byte	(0X710);
	set_name	(0X710,	"rflag");
	set_cmt	(0X711,	"1 if verify after write",	0);
	create_byte	(0X711);
	set_name	(0X711,	"verify");
	create_word	(0X712);
	set_name	(0X712,	"seccnt");
	set_cmt	(0X714,	"-- pad where hardnum was",	0);
	create_byte	(0X714);
	set_cmt	(0X715,	"number of diskette drives",	0);
	create_byte	(0X715);
	set_name	(0X715,	"dsktnum");
	set_cmt	(0X716,	"value from table",	0);
	create_byte	(0X716);
	set_name	(0X716,	"motorstartup");
	set_cmt	(0X717,	"value from table",	0);
	create_byte	(0X717);
	set_name	(0X717,	"settlecurrent");
	set_cmt	(0X718,	"slow settle value",	0);
	create_byte	(0X718);
	set_name	(0X718,	"settleslow");
	set_cmt	(0X719,	"value of speed to be used",	0);
	create_byte	(0X719);
	set_name	(0X719,	"nextspeed");
	set_cmt	(0X71A,	"used by read_sector routine",	0);
	create_byte	(0X71A);
	set_name	(0X71A,	"save_head_sttl");
	set_cmt	(0X71B,	"saved eot from the default DPT",	0);
	create_byte	(0X71B);
	set_name	(0X71B,	"save_eot");
	create_byte	(0X71C);
	set_name	(0X71C,	"eot");
	set_cmt	(0X71D,	"pointer to Disk Parameter Table",	0);
	create_dword	(0X71D);
	set_name	(0X71D,	"dpt");
	set_cmt	(0X721,	"current sector",	0);
	create_byte	(0X721);
	set_name	(0X721,	"cursec");
	set_cmt	(0X722,	"current head",	0);
	create_byte	(0X722);
	set_name	(0X722,	"curhd");
	set_cmt	(0X723,	"current track",	0);
	create_word	(0X723);
	set_name	(0X723,	"curtrk");
	set_cmt	(0X725,	"save the stack pointer",	0);
	create_word	(0X725);
	set_name	(0X725,	"spsav");
	set_cmt	(0X727,	"eot used for format",	0);
	create_byte	(0X727);
	set_name	(0X727,	"formt_eot");
	set_cmt	(0X728,	"head number",	0);
	create_byte	(0X728);
	set_name	(0X728,	"hdnum");
	set_cmt	(0X729,	"track being manipulated",	0);
	create_word	(0X729);
	set_name	(0X729,	"trknum");
	set_cmt	(0X72B,	"format gap patched into dpt",	0);
	create_byte	(0X72B);
	set_name	(0X72B,	"gap_patch");
	set_cmt	(0X72C,	"write fault (hard disk)",	0);
	create_byte	(0X72C);
	set_name	(0X72C,	"errin");
	set_cmt	(0X72D,	"timeout (not ready)",	0);
	create_byte	(0X72D);
	set_cmt	(0X72E,	"seek failed",	0);
	create_byte	(0X72E);
	set_cmt	(0X72F,	"uncorrectable CRC or ECC error on read",	0);
	create_byte	(0X72F);
	set_cmt	(0X730,	"DMA overrun",	0);
	create_byte	(0X730);
	set_cmt	(0X731,	"disk changed (floppy)",	0);
	create_byte	(0X731);
	set_cmt	(0X732,	"sector not found/read error",	0);
	create_byte	(0X732);
	set_cmt	(0X733,	"disk write-protected",	0);
	create_byte	(0X733);
	set_cmt	(0X734,	"invalid function in AH or invalid parameter",	0);
	create_byte	(0X734);
	set_cmt	(0X735,	"volume not removable",	0);
	create_byte	(0X735);
	create_byte	(0X736);
	set_name	(0X736,	"lsterr");
	set_cmt	(0X737,	"write fault error",	0);
	create_byte	(x=0X737);
	op_dec		(x,	0);
	set_name	(0X737,	"errout");
	set_cmt	(0X738,	"no response (timeout)",	0);
	create_byte	(0X738);
	set_cmt	(0X739,	"seek failure",	0);
	create_byte	(0X739);
	set_cmt	(0X73A,	"bad crc",	0);
	create_byte	(0X73A);
	set_cmt	(0X73B,	"dma overrun",	0);
	create_byte	(0X73B);
	set_cmt	(0X73C,	"invalid media change",	0);
	create_byte	(x=0X73C);
	op_dec		(x,	0);
	set_cmt	(0X73D,	"sector not found",	0);
	create_byte	(0X73D);
	set_cmt	(0X73E,	"write attempt to write-protect disk",	0);
	create_byte	(0X73E);
	set_cmt	(0X73F,	"unknown command error",	0);
	create_byte	(0X73F);
	set_cmt	(0X740,	"unknown command error",	0);
	create_byte	(0X740);
	set_cmt	(0X741,	"general error",	0);
	create_byte	(x=0X741);
	op_dec		(x,	0);
	set_cmt	(0X742,	"512 byte buffer",	0);
	create_byte	(x=0X742);
	make_array	(x,	0XAE);
	op_dec		(x,	0);
	set_name	(0X742,	"disksector");
	set_cmt	(0X7F0,	"'BJ' (nasm) ; dw 424Ah",	0);
	create_insn	(0X7F0);
	set_name	(0X7F0,	"JB_sign");
	set_cmt	(0X7F2,	"jmp BData_start",	0);
	create_strlit	(0X7F5,	0X823);
	set_name	(0X7F5,	"IBMBIOCOM$");
	create_byte	(x=0X823);
	make_array	(x,	0X11F);
	op_dec		(x,	0);
	set_cmt	(0X942,	"dword link to next structure",	0);
	create_word	(x=0X942);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X942,	"bds1");
	create_word	(0X944);
	set_cmt	(0X946,	"int 13h drive number",	0);
	create_byte	(0X946);
	set_cmt	(0X947,	"logical drive letter",	0);
	create_byte	(0X947);
	set_cmt	(0X948,	"physical sector size in bytes",	0);
	create_word	(x=0X948);
	op_dec		(x,	0);
	set_name	(0X948,	"fdrive1");
	set_cmt	(0X94A,	"sectors/allocation unit",	0);
	create_byte	(0X94A);
	set_cmt	(0X94B,	"reserved sectors for dos",	0);
	create_word	(0X94B);
	set_cmt	(0X94D,	"no of file allocation tables",	0);
	create_byte	(0X94D);
	set_cmt	(0X94E,	"number of root directory entries",	0);
	create_word	(x=0X94E);
	op_dec		(x,	0);
	set_cmt	(0X950,	"number of sectors (at 512 bytes each)",	0);
	create_word	(x=0X950);
	op_dec		(x,	0);
	set_cmt	(0X952,	"media descriptor, initially 0",	0);
	create_byte	(0X952);
	set_cmt	(0X953,	"number of fat sectors",	0);
	create_word	(0X953);
	set_cmt	(0X955,	"sector limit (sectors per track)",	0);
	create_word	(0X955);
	set_cmt	(0X957,	"head limit (number of heads - 1)",	0);
	create_word	(0X957);
	set_cmt	(0X959,	"hidden sector count",	0);
	create_dword	(0X959);
	set_cmt	(0X95D,	"number of sectors (32 bit)",	0);
	create_dword	(0X95D);
	set_cmt	(0X961,	"BPB_FATSz32 ; FAT32 FAT size in sectors ; 4 bytes\n  BS_DrvNum ; FAT INT 13h drive number ; 1 byte\n  BS_Reserved1 ; FAT reserved byte = 0 ; 1 byte\n  BS_BootSig ; FAT Extended boot signature = 29h ; 1 byte\n  BS_VolID ; FAT Volume serial number ; 4 bytes",	0);
	create_dword	(0X961);
	set_cmt	(0X962,	"BPB_FATSz32 ; FAT32 FAT size in sectors ; 4 bytes\n  BS_DrvNum ; FAT INT 13h drive number ; 1 byte\n  BS_Reserved1 ; FAT reserved byte = 0 ; 1 byte\n  BS_BootSig ; FAT Extended boot signature = 29h ; 1 byte\n  BS_VolID ; FAT Volume serial number ; 4 bytes",	0);
	set_cmt	(0X964,	"BPB_FATSz32 ; FAT32 FAT size in sectors ; 4 bytes\n  BS_DrvNum ; FAT INT 13h drive number ; 1 byte\n  BS_Reserved1 ; FAT reserved byte = 0 ; 1 byte\n  BS_BootSig ; FAT Extended boot signature = 29h ; 1 byte\n  BS_VolID ; FAT Volume serial number ; 4 bytes",	0);
	set_cmt	(0X965,	"BPB_ExtFlags ; FAT32 Extended Flags",	0);
	create_word	(0X965);
	set_cmt	(0X967,	"BPB_FSVer ; FAT32 fs/volume version",	0);
	create_word	(0X967);
	set_cmt	(0X969,	"BPB_RootClus ; FAT32 root directory's first cluster number",	0);
	create_dword	(0X969);
	set_cmt	(0X96D,	"BPB_FSInfo ; FAT32 FSINFO sector number = -1 (initial)",	0);
	create_word	(0X96D);
	set_cmt	(0X96F,	"BPB_BkBootSec ; FAT32 backup boot sector number = -1 (initial)",	0);
	create_word	(0X96F);
	set_cmt	(0X971,	"BPB_Reserved  ; FAT32 reserved field = 0, 12 bytes",	0);
	create_byte	(x=0X971);
	make_array	(x,	0XC);
	op_dec		(x,	0);
	set_cmt	(0X97D,	"true => large fats",	0);
	create_byte	(0X97D);
	set_cmt	(0X97E,	"open ref. count",	0);
	create_word	(0X97E);
	set_cmt	(0X980,	"form factor",	0);
	create_byte	(0X980);
	set_cmt	(0X981,	"various flags",	0);
	create_word	(0X981);
	set_cmt	(0X983,	"number of cylinders",	0);
	create_word	(x=0X983);
	op_dec		(x,	0);
	set_cmt	(0X985,	"recommended bps for this drive\nrecbpb1",	0);
	create_word	(x=0X985);
	op_dec		(x,	0);
	set_name	(0X985,	"recommended_bps");
	create_byte	(0X987);
	create_word	(0X988);
	create_byte	(0X98A);
	set_cmt	(0X98B,	"number of root directory entries",	0);
	create_word	(x=0X98B);
	op_dec		(x,	0);
	create_word	(x=0X98D);
	op_dec		(x,	0);
	set_cmt	(0X98F,	"media descriptor, initially 0F0h",	0);
	create_byte	(0X98F);
	create_word	(0X990);
	create_word	(0X992);
	create_word	(0X994);
	create_dword	(0X996);
	create_dword	(0X99A);
	create_dword	(0X99E);
	create_dword	(0X9A2);
	create_dword	(0X9A6);
	create_dword	(0X9AA);
	create_dword	(0X9AE);
	create_dword	(0X9B2);
	create_dword	(0X9B6);
	set_cmt	(0X9BA,	"last track accessed on this drive",	0);
	set_cmt	(0X9BB,	"keep these two contiguous (?)",	0);
	create_dword	(0X9BB);
	set_cmt	(0X9BF,	"volume id for this disk",	0);
	create_strlit	(0X9BF,	0X9CB);
	set_cmt	(0X9CB,	"current volume serial from boot record",	0);
	create_dword	(0X9CB);
	set_cmt	(0X9CF,	"current file system id from boot record",	0);
	create_strlit	(0X9CF,	0X9D8);
	create_word	(0X9D8);
	set_name	(0X9D8,	"bds2");
	create_word	(0X9DA);
	create_byte	(0X9DC);
	create_byte	(0X9DD);
	create_word	(x=0X9DE);
	op_dec		(x,	0);
	set_name	(0X9DE,	"fdrive2");
	create_word	(0X9E1);
	create_byte	(0X9E3);
	create_word	(x=0X9E4);
	op_dec		(x,	0);
	create_word	(x=0X9E6);
	op_dec		(x,	0);
	create_byte	(0X9E8);
	create_word	(0X9E9);
	create_word	(0X9EB);
	create_word	(0X9ED);
	create_dword	(0X9EF);
	create_dword	(0X9F3);
	create_dword	(0X9F7);
	create_dword	(0X9FB);
	create_dword	(0X9FF);
	create_dword	(0XA03);
	create_dword	(0XA07);
	create_dword	(0XA0B);
	create_dword	(0XA0F);
	create_byte	(0XA13);
	create_word	(0XA14);
	create_byte	(0XA16);
	create_word	(0XA17);
	create_word	(x=0XA19);
	op_dec		(x,	0);
	create_word	(x=0XA1B);
	op_dec		(x,	0);
	set_name	(0XA1B,	"recbpb2");
	create_byte	(0XA1D);
	create_word	(0XA1E);
	create_byte	(0XA20);
	create_word	(x=0XA21);
	op_dec		(x,	0);
	create_word	(x=0XA23);
	op_dec		(x,	0);
	create_byte	(0XA25);
	create_word	(0XA26);
	create_word	(0XA28);
	create_word	(0XA2A);
	create_dword	(0XA2C);
	create_dword	(0XA30);
	create_dword	(0XA34);
	create_dword	(0XA38);
	create_dword	(0XA3C);
	create_dword	(0XA40);
	create_dword	(0XA44);
	create_dword	(0XA48);
	create_dword	(0XA4C);
	create_byte	(0XA50);
	create_dword	(0XA51);
	create_strlit	(0XA55,	0XA61);
	create_dword	(0XA61);
	create_strlit	(0XA65,	0XA6E);
	create_byte	(0XA6E);
	set_name	(0XA6E,	"keyrd_func");
	create_byte	(0XA6F);
	set_name	(0XA6F,	"keysts_func");
	set_cmt	(0XA70,	"printer device index",	0);
	create_byte	(0XA70);
	set_name	(0XA70,	"printdev");
	set_cmt	(0XA71,	"retry counts for printers",	0);
	create_word	(0XA71);
	set_name	(0XA71,	"wait_count");
	create_word	(0XA73);
	create_word	(0XA75);
	create_word	(0XA77);
	set_cmt	(0XA79,	"flag for updating daycnt",	0);
	create_word	(0XA79);
	set_name	(0XA79,	"daycnt");
	create_byte	(0XA7B);
	set_name	(0XA7B,	"t_switch");
	create_byte	(0XA7C);
	set_name	(0XA7C,	"havecmoscloc");
	create_byte	(x=0XA7D);
	op_dec		(x,	0);
	set_name	(0XA7D,	"base_century");
	create_byte	(x=0XA7E);
	op_dec		(x,	0);
	set_name	(0XA7E,	"base_year");
	create_byte	(x=0XA7F);
	op_dec		(x,	0);
	set_name	(0XA7F,	"month_table");
	create_byte	(x=0XA80);
	op_dec		(x,	0);
	set_name	(0XA80,	"february");
	create_byte	(x=0XA81);
	op_dec		(x,	0);
	create_byte	(x=0XA82);
	op_dec		(x,	0);
	create_byte	(x=0XA83);
	op_dec		(x,	0);
	create_byte	(x=0XA84);
	op_dec		(x,	0);
	create_byte	(x=0XA85);
	op_dec		(x,	0);
	create_byte	(x=0XA86);
	op_dec		(x,	0);
	create_byte	(x=0XA87);
	op_dec		(x,	0);
	create_byte	(x=0XA88);
	op_dec		(x,	0);
	create_byte	(x=0XA89);
	op_dec		(x,	0);
	create_byte	(x=0XA8A);
	op_dec		(x,	0);
	set_cmt	(0XA8B,	"flag for getbp routine",	0);
	create_byte	(0XA8B);
	set_name	(0XA8B,	"set_id_flag");
	set_cmt	(0XA8C,	"starting sector number high word",	0);
	create_word	(0XA8C);
	set_name	(0XA8C,	"start_sec_h");
	set_cmt	(0XA8E,	"tempory saving place for a word",	0);
	create_word	(0XA8E);
	set_name	(0XA8E,	"saved_word");
	create_word	(0XA90);
	set_name	(0XA90,	"multrk_flag");
	set_cmt	(0XA92,	"flags for 3.5 inch disk drives",	0);
	create_byte	(0XA92);
	set_name	(0XA92,	"ec35_flag");
	create_word	(0XA93);
	set_name	(0XA93,	"vretry_cnt");
	create_word	(0XA95);
	set_name	(0XA95,	"soft_ecc_cnt");
	set_cmt	(0XA97,	"multi track format request flag",	0);
	create_byte	(0XA97);
	set_name	(0XA97,	"multitrk_format_flag");
	set_cmt	(0XA98,	"temp for transfer segment",	0);
	create_word	(0XA98);
	set_name	(0XA98,	"xfer_seg");
	create_word	(x=0XA9A);
	op_dec		(x,	0);
	set_name	(0XA9A,	"sectorspertrack");
	create_byte	(x=0XA9C);
	make_array	(x,	0X90);
	op_dec		(x,	0);
	set_name	(0XA9C,	"tracktable");
	create_word	(x=0XB2C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0XB2C,	"dskdrvs");
	create_word	(x=0XB2E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0XB30,	"times (((4*63)-144)-4) db 0\n4*max_sectors_curr_sup-($-tracktable)-4 dup (0)",	0);
	create_word	(x=0XB30);
	make_array	(x,	0X34);
	op_dec		(x,	0);
	create_byte	(0XB98);
	set_name	(0XB98,	"mediatype");
	set_cmt	(0XB99,	"1 if we have done an int 13h set media\ntype for format call",	0);
	create_byte	(0XB99);
	set_name	(0XB99,	"media_set_for_format");
	set_cmt	(0XB9A,	"1 if the previous format operation failed.",	0);
	create_byte	(0XB9A);
	set_name	(0XB9A,	"had_format_error");
	set_cmt	(0XB9B,	"-1 ; temp disk base table",	0);
	create_dword	(0XB9B);
	set_name	(0XB9B,	"tempdpt");
	set_cmt	(0XB9F,	"model byte set at init time",	0);
	create_byte	(0XB9F);
	set_name	(0XB9F,	"model_byte");
	create_byte	(0XBA0);
	set_name	(0XBA0,	"secondary_model_byte");
	set_cmt	(0XBA1,	"indicate that all int 19h initialization is complete\n\nirp    aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>\npublic int19old&aa\ndb     aa&h       ; store the number as a byte\nint19old&aa dd -1 ; original hardware int. vectors for int 19h.\nendm",	0);
	create_byte	(0XBA1);
	set_name	(0XBA1,	"int19sem");
	create_byte	(0XBA2);
	set_name	(0XBA2,	"i19_lst");
	set_cmt	(0XBA3,	"Int19old&aa\ndb aa&h \ndd -1 ; original hardware int. vectors for int 19h",	0);
	create_dword	(0XBA3);
	set_name	(0XBA3,	"int19old02");
	create_byte	(0XBA7);
	create_dword	(0XBA8);
	set_name	(0XBA8,	"int19old08");
	create_byte	(0XBAC);
	create_dword	(0XBAD);
	set_name	(0XBAD,	"int19old09");
	create_byte	(0XBB1);
	create_dword	(0XBB2);
	set_name	(0XBB2,	"int19old0A");
	create_byte	(0XBB6);
	create_dword	(0XBB7);
	set_name	(0XBB7,	"int19old0B");
	create_byte	(0XBBB);
	create_dword	(0XBBC);
	set_name	(0XBBC,	"int19old0C");
	create_byte	(0XBC0);
	create_dword	(0XBC1);
	set_name	(0XBC1,	"int19old0D");
	create_byte	(0XBC5);
	create_dword	(0XBC6);
	set_name	(0XBC6,	"int19old0E");
	create_byte	(0XBCA);
	create_dword	(0XBCB);
	set_name	(0XBCB,	"int19old70");
	create_byte	(0XBCF);
	create_dword	(0XBD0);
	set_name	(0XBD0,	"int19old72");
	create_byte	(0XBD4);
	create_dword	(0XBD5);
	set_name	(0XBD5,	"int19old73");
	create_byte	(0XBD9);
	create_dword	(0XBDA);
	set_name	(0XBDA,	"int19old74");
	create_byte	(0XBDE);
	create_dword	(0XBDF);
	set_name	(0XBDF,	"int19old76");
	create_byte	(0XBE3);
	create_dword	(0XBE4);
	set_name	(0XBE4,	"int19old77");
	create_dword	(0XBE8);
	set_name	(0XBE8,	"int6c_ret_addr");
	create_byte	(0XBEC);
	make_array	(0XBEC,	0X4);
	set_name	(0XBEC,	"bin_date_time");
	create_word	(0XBF0);
	set_name	(0XBF0,	"daycnt2");
	create_word	(x=0XBF2);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_name	(0XBF2,	"cdev");
	set_cmt	(0XBF4,	"BIOSCODE segment = 364h (for PCDOS 7.1 IBMBIO.COM)",	0);
	create_word	(0XBF4);
	set_name	(0XBF4,	"cdev_2");
	create_word	(x=0XBF6);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_name	(0XBF6,	"ttticks");
	set_cmt	(0XBF8,	"BIOSCODE segment (70h+2F4h)",	0);
	create_word	(0XBF8);
	create_word	(x=0XBFA);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_name	(0XBFA,	"i13x");
	set_cmt	(0XBFC,	"BIOSCODE segment",	0);
	create_word	(0XBFC);
	set_cmt	(0XBFE,	"indicate break key set",	0);
	create_insn	(0XBFE);
	set_name	(0XBFE,	"cbreak");
	set_name	(0XC04,	"intret");
	set_cmt	(0XC05,	"store es:bx (device driver request packet)\n     away at [ptrsav] for next driver function call",	0);
	create_insn	(0XC05);
	set_name	(0XC05,	"strategy");
	create_insn	(0XC10);
	set_name	(0XC10,	"con_entry");
	create_word	(x=0XC13);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_insn	(0XC15);
	set_name	(0XC15,	"prn0_entry");
	create_word	(x=0XC18);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC1A);
	make_array	(0XC1A,	0X2);
	create_insn	(0XC1C);
	set_name	(0XC1C,	"prn1_entry");
	create_word	(x=0XC1F);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC21);
	make_array	(0XC21,	0X2);
	create_insn	(0XC23);
	set_name	(0XC23,	"prn2_entry");
	set_cmt	(0XC26,	"364h:0FBh = BIOSCODE:0FBh = 70h:303Bh",	0);
	create_word	(x=0XC26);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC28);
	make_array	(0XC28,	0X2);
	create_insn	(0XC2A);
	set_name	(0XC2A,	"prn3_entry");
	create_word	(x=0XC2D);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC2F);
	make_array	(0XC2F,	0X2);
	create_insn	(0XC31);
	set_name	(0XC31,	"aux0_entry");
	create_word	(x=0XC34);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC36);
	create_insn	(0XC37);
	set_name	(0XC37,	"aux1_entry");
	set_cmt	(0XC3A,	"364h:130h = BIOSCODE:130h = 70h:3070h",	0);
	create_word	(x=0XC3A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC3C);
	create_insn	(0XC3D);
	set_name	(0XC3D,	"aux2_entry");
	create_word	(x=0XC40);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC42);
	create_insn	(0XC43);
	set_name	(0XC43,	"aux3_entry");
	create_word	(x=0XC46);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0XC48);
	create_insn	(0XC49);
	set_name	(0XC49,	"tim_entry");
	set_cmt	(0XC4C,	"364h:147h ; BIOSCODE:147h ; 70h:3087h",	0);
	create_word	(x=0XC4C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_insn	(0XC4E);
	set_name	(0XC4E,	"dsk_entry");
	set_cmt	(0XC51,	"364h:579h ; BIOSCODE:579h ; 70h:34B9h",	0);
	create_word	(x=0XC51);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_insn	(0XC53);
	set_name	(0XC53,	"cdev_entry");
	set_cmt	(0XC59,	"optimized for DOS in HMA",	0);
	set_cmt	(0XC66,	"jump is coded this way to fall thru\nin 99.99% of the cases",	0);
	set_cmt	(0XC68,	"jmp far [cs:cdev]",	0);
	create_insn	(x=0XC68);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0XC6D);
	set_cmt	(0XC72,	"INT 29h handler",	0);
	create_insn	(0XC72);
	set_name	(0XC72,	"outchr");
	set_cmt	(0XC78,	"0",	0);
	set_cmt	(0XC7A,	"(are we in) windows ?",	0);
	set_cmt	(0XC85,	"Running on Windows",	0);
	set_cmt	(0XC87,	"far call (simulate INT)",	0);
	set_cmt	(0XC89,	"far call to INT 10h vector",	0);
	create_insn	(x=0XC89);
	set_cmt	(0XC8F,	"- VIDEO - ",	0);
	create_insn	(x=0XC8F);
	op_hex		(x,	0);
	set_name	(0XC8F,	"win_outchr");
	set_name	(0XC91,	"outchr_ok");
	set_cmt	(0XC98,	"'PCI' signature",	0);
	create_dword	(0XC9B);
	set_name	(0XC9B,	"Orig1A");
	set_cmt	(0XC9F,	"(Y2K-fix)",	0);
	create_insn	(0XC9F);
	set_name	(0XC9F,	"Int1A");
	set_cmt	(0XCA2,	"Reads the date from the computer's real-time clock",	0);
	set_cmt	(0XCA4,	"jmp far [cs:Orig1A]",	0);
	create_insn	(0XCA9);
	set_name	(0XCA9,	"int1a_1");
	set_name	(0XCAA,	"int1a_2");
	set_cmt	(0XCB5,	"Year (BCD)",	0);
	set_cmt	(0XCBA,	"Century (BCD)",	0);
	create_insn	(x=0XCBF);
	op_hex		(x,	1);
	set_cmt	(0XCC1,	"Sets the date on the computer's real-time clock",	0);
	set_cmt	(0XCC4,	"dh = Month (BCD), dl = Day (BCD)",	0);
	set_cmt	(0XCC6,	"call far [cs:Orig1A]",	0);
	set_name	(0XCCF,	"int1a_3");
	set_cmt	(0XCD0,	"clear carry flag",	0);
	create_insn	(x=0XCD0);
	op_hex		(x,	1);
	create_insn	(0XCD6);
	set_name	(0XCD6,	"int1a_4");
	set_cmt	(0XCD7,	"set carry flag",	0);
	create_insn	(x=0XCD7);
	op_hex		(x,	1);
	set_name	(0XCDB,	"int1a_5");
	create_insn	(0XCDD);
	set_name	(0XCDD,	"block13");
	set_cmt	(0XCE5,	"assure a20 enabled",	0);
	set_cmt	(0XCE8,	"save caller's ds for call-through",	0);
	set_name	(0XCE8,	"skipa20");
	set_cmt	(0XCED,	"fake interrupt",	0);
	set_cmt	(0XCEE,	"call through Bios_Code entry table",	0);
	set_cmt	(0XCFB,	"get caller's ds register",	0);
	create_insn	(x=0XCFB);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0XCFB,	"call_orig13");
	set_cmt	(0XD0B,	"restore ds -> Bios_Data before return",	0);
	set_name	(0XD18,	"corig13_popf_retf");
	set_name	(0XD19,	"re_init");
	create_insn	(0XD1A);
	set_name	(0XD1A,	"EnsureA20On");
	set_cmt	(0XD1F,	"A20 line is OFF",	0);
	set_name	(0XD1F,	"EnableA20");
	set_cmt	(0XD21,	"local enable A20",	0);
	create_insn	(0XD2B);
	set_name	(0XD2B,	"IsA20Off");
	set_cmt	(0XD38,	"0FFFFh:0090h ; HiMem",	0);
	set_cmt	(0XD3A,	"0000h:0080h ; LoMem",	0);
	set_name	(0XD3D,	"cpu386_cmpsd");
	set_cmt	(0XD41,	"\nzf = 0 -> A20 line is ON\nzf = 1 -> A20 line is OFF",	0);
	create_insn	(0XD49);
	set_name	(0XD49,	"int19");
	create_insn	(x=0XD51);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0XD54,	"get int number",	0);
	set_name	(0XD54,	"_next_int");
	set_cmt	(0XD55,	"assume < 128",	0);
	create_insn	(x=0XD56);
	op_hex		(x,	1);
	set_cmt	(0XD58,	"int * 4",	0);
	create_insn	(x=0XD58);
	op_hex		(x,	1);
	set_cmt	(0XD5C,	"install the saved vector",	0);
	set_cmt	(0XD5F,	"0",	0);
	set_cmt	(0XD65,	"stacks code has changed these hardware interrupt vectors\nstkinit in sysinit1 will initialize int19oldxx values",	0);
	create_insn	(x=0XD65);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0XD68,	"num_i19",	0);
	create_insn	(x=0XD68);
	op_dec		(x,	1);
	set_cmt	(0XD6A,	"get interrupt number",	0);
	set_name	(0XD6A,	"i19_restore_loop");
	set_cmt	(0XD6B,	"assume < 128",	0);
	set_cmt	(0XD6D,	"get original vector offset",	0);
	set_cmt	(0XD6E,	"save it",	0);
	set_cmt	(0XD70,	"check for 0ffffh (unlikely segment)",	0);
	set_cmt	(0XD71,	"opt no need to check selector too",	0);
	set_cmt	(0XD7B,	"put the vector back",	0);
	set_name	(0XD7C,	"i19_restor_1");
	set_cmt	(0XD7E,	"Is dos running from HMA ?",	0);
	set_name	(0XD7E,	"doint19");
	set_cmt	(0XD82,	"no",	0);
	set_cmt	(0XD84,	"Then erase our VDISK header at 1MB boundary\nSome m/c's (AST 386 & HP QS/16 do not clear\nthe memory above 1MB during a warm boot.",	0);
	set_cmt	(0XD87,	"DISK BOOT\ncauses reboot of disk system",	0);
	create_insn	(x=0XD87);
	op_hex		(x,	0);
	set_name	(0XD87,	"SkipVDisk");
	set_cmt	(0XD89,	"del keystroke ?  (4F00h+DELKEY)",	0);
	set_name	(0XD89,	"Int15");
	set_name	(0XD8E,	"Old15_j");
	create_insn	(0XD93);
	set_name	(0XD93,	"int15_1");
	set_cmt	(0XD99,	"[KBFLAG]",	0);
	create_insn	(x=0XD99);
	set_cmt	(0XD9C,	"(CTRLSTATE | ALTSTATE)",	0);
	create_insn	(x=0XD9C);
	op_hex		(x,	1);
	set_cmt	(0XD9E,	"(CTRLSTATE | ALTSTATE)",	0);
	set_cmt	(0XDA2,	"is DOS running from HMA ?",	0);
	set_cmt	(0XDA7,	"no",	0);
	set_name	(0XDAC,	"int15_2");
	create_insn	(0XDB1);
	set_name	(0XDB1,	"EraseVDiskHead");
	set_cmt	(0XDB7,	"HMA seg",	0);
	set_cmt	(0XDBA,	"point to VDISK header",	0);
	set_cmt	(0XDBD,	"size of vdisk header = 16",	0);
	set_cmt	(0XDC1,	"clear it",	0);
	create_word	(0XDC7);
	set_name	(0XDC7,	"FreeHMAPtr");
	set_cmt	(0XDC9,	"SYSINITSEG:FTRYTOMOVDOSHI",	0);
	create_word	(x=0XDC9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0XDC9,	"MoveDOSIntoHMA");
	set_cmt	(0XDCB,	"SYSINITSEG",	0);
	create_word	(0XDCB);
	set_name	(0XDCB,	"MoveDOSIntoHMA_2");
	create_byte	(0XDCD);
	set_name	(0XDCD,	"SysinitPresent");
	create_byte	(0XDCE);
	make_array	(0XDCE,	0X2);
	set_name	(0XDCE,	"Win386_SI");
	create_dword	(0XDD0);
	set_name	(0XDD0,	"SI_Next");
	create_dword	(0XDD4);
	create_dword	(0XDD8);
	create_word	(x=0XDDC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(0XDDE);
	set_cmt	(0XDE0,	"print screen status",	0);
	create_word	(0XDE0);
	set_name	(0XDE0,	"Instance_Table");
	create_word	(0XDE2);
	set_cmt	(0XDE4,	"2 bytes",	0);
	create_word	(0XDE4);
	set_cmt	(0XDE6,	"ROM Basic data",	0);
	create_word	(0XDE6);
	create_word	(0XDE8);
	set_cmt	(0XDEA,	"20 bytes",	0);
	create_word	(0XDEA);
	set_cmt	(0XDEC,	"a con device buffer",	0);
	create_word	(x=0XDEC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(0XDEE);
	create_word	(0XDF0);
	set_cmt	(0XDF2,	"pointer to next stack to be used",	0);
	create_word	(0XDF2);
	make_array	(0XDF2,	0X2);
	set_name	(0XDF2,	"NextStack");
	set_cmt	(0XDF6,	"2 bytes",	0);
	create_word	(0XDF6);
	set_cmt	(0XDF8,	"location of hardware stacks",	0);
	create_dword	(0XDF8);
	set_name	(0XDF8,	"IT_StackLoc");
	set_cmt	(0XDFC,	"size of hardware stacks",	0);
	create_word	(0XDFC);
	set_name	(0XDFC,	"IT_StackSize");
	set_cmt	(0XDFE,	"terminate the instance table",	0);
	create_dword	(0XDFE);
	set_cmt	(0XE02,	"Flag to indicate whether\nWin386 is running or not",	0);
	create_byte	(0XE02);
	set_name	(0XE02,	"IsWin386");
	create_insn	(0XE03);
	set_name	(0XE03,	"V86_Crit_SetFocus");
	set_cmt	(0XE0B,	"Device ID of DOSMGR device",	0);
	set_name	(0XE0B,	"offset_081Bh");
	set_cmt	(0XE11,	"- Multiplex - MS WINDOWS - GET DEVICE API ENTRY POINT\nBX = virtual device (VxD) ID, ES:DI = 0000h:0000h\nReturn: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API",	0);
	create_insn	(x=0XE11);
	op_hex		(x,	0);
	create_insn	(x=0XE1A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0XE1E,	"API far call address",	0);
	set_cmt	(0XE1F,	"SetFocus function number",	0);
	set_cmt	(0XE22,	"do the call",	0);
	create_insn	(0XE23);
	set_name	(0XE23,	"Skip");
	create_byte	(0XE28);
	set_name	(0XE28,	"endfloppy");
	create_byte	(0XE29);
	make_array	(0XE29,	0X7);
	set_name	(0XE29,	"offset_0839h");
	create_strlit	(0XE30,	0XE3B);
	set_name	(0XE30,	"tmp_vid");
	create_byte	(0XE3B);
	set_name	(0XE3B,	"harddrv");
	set_cmt	(0XE3C,	"max_mini_dsk_num equ 23\nBDS_STRUC (2+max_mini_dsk_num) dup (<>)\ncurrently max. 25\n(MSDOS 6 BDS structure size = 100 bytes)\n(PCDOS 7.1 BDS structure size = 150 bytes)\nBDS.link",	0);
	create_word	(0XE3C);
	set_name	(0XE3C,	"bdss");
	create_word	(0XE3E);
	set_cmt	(0XE40,	"BDS.drivenum",	0);
	create_byte	(x=0XE40);
	op_dec		(x,	0);
	set_cmt	(0XE41,	"BDS.drivelet",	0);
	create_byte	(0XE41);
	set_cmt	(0XE42,	"BDS.BPB (BDS offset 6)\n53 bytes BPB for FAT32 fs\n25 bytes BPB for FAT16 and FAT12 fs\n.bytespersec",	0);
	create_word	(x=0XE42);
	op_dec		(x,	0);
	set_cmt	(0XE44,	".secperclus",	0);
	create_byte	(0XE44);
	set_cmt	(0XE45,	".resectors",	0);
	create_word	(0XE45);
	set_cmt	(0XE47,	".fats",	0);
	create_byte	(0XE47);
	set_cmt	(0XE48,	".direntries",	0);
	create_word	(x=0XE48);
	op_dec		(x,	0);
	set_cmt	(0XE4A,	".totalsec16",	0);
	create_word	(0XE4A);
	set_cmt	(0XE4C,	".media",	0);
	set_cmt	(0XE4D,	".fatsecs16",	0);
	create_word	(0XE4D);
	set_cmt	(0XE4F,	".secpertrack",	0);
	create_word	(0XE4F);
	set_cmt	(0XE51,	".heads",	0);
	create_word	(0XE51);
	set_cmt	(0XE53,	".hiddensectors",	0);
	create_dword	(0XE53);
	set_cmt	(0XE57,	".totalsecs32\n(End of FAT12/FAT16 BPB)\n\nFAT32 extensions to BDS",	0);
	create_dword	(0XE57);
	set_cmt	(0XE5B,	".fatsecs32 ; BPB_FATSz32 (BDS offset 31)",	0);
	create_dword	(0XE5B);
	set_cmt	(0XE5F,	".extflags ; BPB_ExtFlags",	0);
	create_word	(0XE5F);
	set_cmt	(0XE61,	".fsver ; BPB_FSVer",	0);
	create_word	(0XE61);
	set_cmt	(0XE63,	".rootdirclust ; BPB_RootClus (BDS offset 39)",	0);
	create_dword	(0XE63);
	set_cmt	(0XE67,	".fsinfo ; BPB_FSInfo ; initialized to -1",	0);
	create_word	(0XE67);
	set_cmt	(0XE69,	".bkbootsec ; BPB_BkBootSec ; initialized to -1",	0);
	create_word	(0XE69);
	set_cmt	(0XE6B,	".reserved ; BPB_Reserved (12 zero bytes)",	0);
	create_byte	(x=0XE6B);
	make_array	(x,	0XC);
	op_dec		(x,	0);
	set_cmt	(0XE77,	"BDS.fatsiz (BDS offset 59)",	0);
	create_byte	(0XE77);
	set_cmt	(0XE78,	"BDS.opcnt",	0);
	create_word	(0XE78);
	create_byte	(0XE7A);
	set_cmt	(0XE7B,	"BDS.flags (BDS offset 63)",	0);
	create_word	(0XE7B);
	create_word	(x=0XE7D);
	op_dec		(x,	0);
	create_byte	(x=0XE7F);
	make_array	(x,	0X25);
	op_dec		(x,	0);
	create_dword	(0XEA4);
	create_byte	(x=0XEA8);
	make_array	(x,	0XC);
	op_dec		(x,	0);
	set_cmt	(0XEB4,	"BDS.track (BDS offset 120)",	0);
	create_byte	(x=0XEB4);
	toggle_sign		(x,	0);
	op_dec		(x,	0);
	toggle_sign		(x,	1);
	set_cmt	(0XEB5,	"BDS.tim_lo ; BDS.bdsm_ismini",	0);
	create_word	(0XEB5);
	set_cmt	(0XEB7,	"BDS.tim_hi",	0);
	create_word	(0XEB7);
	set_cmt	(0XEB9,	"BDS.volid",	0);
	create_strlit	(0XEB9,	0XEC5);
	set_cmt	(0XEC5,	"BDS.vol_serial (BDS offset 137)",	0);
	create_dword	(0XEC5);
	set_cmt	(0XEC9,	"BDS.filesys_id",	0);
	create_strlit	(0XEC9,	0XED2);
	create_word	(0XED2);
	set_name	(0XED2,	"bds_1");
	create_byte	(0XED4);
	make_array	(0XED4,	0X94);
	create_word	(0XF68);
	set_name	(0XF68,	"bds_2");
	create_byte	(0XF6A);
	make_array	(0XF6A,	0X94);
	create_word	(0XFFE);
	set_name	(0XFFE,	"bds_3");
	create_byte	(0X1000);
	make_array	(0X1000,	0X94);
	create_word	(0X1094);
	set_name	(0X1094,	"bds_4");
	create_byte	(0X1096);
	make_array	(0X1096,	0X94);
	create_word	(0X112A);
	create_byte	(0X112C);
	make_array	(0X112C,	0X94);
	create_word	(0X11C0);
	create_byte	(0X11C2);
	make_array	(0X11C2,	0X94);
	create_word	(0X1256);
	create_byte	(0X1258);
	make_array	(0X1258,	0X94);
	create_word	(0X12EC);
	create_byte	(0X12EE);
	make_array	(0X12EE,	0X94);
	create_word	(0X1382);
	create_byte	(0X1384);
	make_array	(0X1384,	0X94);
	create_word	(0X1418);
	create_byte	(0X141A);
	make_array	(0X141A,	0X94);
	create_word	(0X14AE);
	create_byte	(0X14B0);
	make_array	(0X14B0,	0X94);
	create_word	(0X1544);
	create_byte	(0X1546);
	make_array	(0X1546,	0X94);
	create_word	(0X15DA);
	create_byte	(0X15DC);
	make_array	(0X15DC,	0X94);
	create_word	(0X1670);
	create_byte	(0X1672);
	make_array	(0X1672,	0X94);
	create_word	(0X1706);
	create_byte	(0X1708);
	make_array	(0X1708,	0X94);
	create_word	(0X179C);
	create_byte	(0X179E);
	make_array	(0X179E,	0X94);
	create_word	(0X1832);
	create_byte	(0X1834);
	make_array	(0X1834,	0X94);
	create_word	(0X18C8);
	create_byte	(0X18CA);
	make_array	(0X18CA,	0X94);
	create_word	(0X195E);
	create_byte	(0X1960);
	make_array	(0X1960,	0X94);
	create_word	(0X19F4);
	create_byte	(0X19F6);
	make_array	(0X19F6,	0X94);
	create_word	(0X1A8A);
	create_byte	(0X1A8C);
	make_array	(0X1A8C,	0X94);
	create_word	(0X1B20);
	create_byte	(0X1B22);
	make_array	(0X1B22,	0X94);
	create_word	(0X1BB6);
	create_byte	(0X1BB8);
	make_array	(0X1BB8,	0X94);
	create_word	(0X1C4C);
	set_name	(0X1C4C,	"bds_24");
	create_byte	(0X1C4E);
	make_array	(0X1C4E,	0X94);
	set_cmt	(0X1CE2,	"main routine, fixes at rom bug\npass through floppy disk calls",	0);
	create_insn	(0X1CE2);
	set_name	(0X1CE2,	"ibm_disk_io");
	set_cmt	(0X1CEA,	"intercept call 02h (read sectors)",	0);
	set_cmt	(0X1CEC,	"and call 0Ah (read long)",	0);
	set_cmt	(0X1CF1,	"use rom int 13h handler",	0);
	set_name	(0X1CF1,	"atd1");
	create_insn	(0X1CF6);
	set_name	(0X1CF6,	"atd2");
	set_cmt	(0X1CFD,	"rombios data segment",	0);
	create_insn	(x=0X1CFD);
	op_hex		(x,	1);
	set_cmt	(0X1D02,	"[disk_status1]\ninitially no error code",	0);
	set_cmt	(0X1D07,	"mask to hard disk number",	0);
	create_insn	(x=0X1D07);
	op_hex		(x,	1);
	set_cmt	(0X1D0A,	"[hf_num] ; 40h:75h",	0);
	set_cmt	(0X1D0E,	"disk number in range",	0);
	set_cmt	(0X1D10,	"[disk_status1]",	0);
	set_cmt	(0X1D15,	"disk number out of range error, return",	0);
	create_insn	(0X1D17);
	set_name	(0X1D17,	"atd3");
	set_cmt	(0X1D1A,	"make es:bx to seg:000x form",	0);
	create_insn	(x=0X1D1A);
	op_hex		(x,	1);
	create_insn	(x=0X1D22);
	op_hex		(x,	1);
	set_cmt	(0X1D29,	"abort if dma across segment boundary",	0);
	create_insn	(0X1D29);
	set_cmt	(0X1D2D,	"set up command block for disk op",	0);
	set_cmt	(0X1D30,	"hf_reg_port",	0);
	create_insn	(0X1D30);
	set_cmt	(0X1D33,	"AT only. Fixed disk register",	0);
	set_cmt	(0X1D34,	"carry out command",	0);
	create_insn	(0X1D37);
	set_name	(0X1D37,	"atd4");
	set_cmt	(0X1D38,	"[disk_status1]",	0);
	set_name	(0X1D41,	"atd5");
	set_cmt	(0X1D4A,	"[cmd_block+sec_cnt]",	0);
	create_insn	(0X1D4A);
	set_name	(0X1D4A,	"setcmd");
	create_insn	(x=0X1D4D);
	op_hex		(x,	1);
	set_cmt	(0X1D52,	"cmd_reg = 20h if function 02h (read)",	0);
	set_cmt	(0X1D57,	"[cmd_block+cmd_reg]\ncmd_reg = 22h if function 0Ah (read long)",	0);
	create_insn	(x=0X1D57);
	op_hex		(x,	1);
	set_cmt	(0X1D5E,	"mask sector number",	0);
	create_insn	(x=0X1D5E);
	op_hex		(x,	1);
	set_cmt	(0X1D60,	"[cmd_block+sec_num]",	0);
	set_cmt	(0X1D63,	"[cmd_block+cyl_low]",	0);
	set_cmt	(0X1D69,	"get two high bits of cylinder number",	0);
	create_insn	(x=0X1D69);
	op_hex		(x,	1);
	set_cmt	(0X1D6C,	"[cmd_block+cyl_high]",	0);
	set_cmt	(0X1D71,	"drive number",	0);
	create_insn	(x=0X1D71);
	op_hex		(x,	1);
	create_insn	(x=0X1D74);
	op_hex		(x,	1);
	set_cmt	(0X1D77,	"head number",	0);
	set_cmt	(0X1D79,	"set ecc and 512 bytes per sector",	0);
	create_insn	(x=0X1D79);
	op_hex		(x,	1);
	set_cmt	(0X1D7B,	"[cmd_block+drv_head]",	0);
	set_cmt	(0X1D84,	"[es:bx+fdp_precomp]\nwrite pre-comp from disk parameters",	0);
	create_insn	(0X1D84);
	create_insn	(x=0X1D88);
	op_hex		(x,	1);
	set_cmt	(0X1D8B,	"[cmd_block+pre_comp]",	0);
	set_cmt	(0X1D8E,	"[es:bx+fdp_control]\ncontrol byte modifier",	0);
	set_cmt	(0X1D94,	"[control_byte]",	0);
	set_cmt	(0X1D98,	"keep disable retry bits",	0);
	create_insn	(x=0X1D98);
	op_hex		(x,	1);
	create_insn	(0X1DA2);
	set_name	(0X1DA2,	"docmd");
	create_insn	(0X1DA8);
	set_cmt	(0X1DAB,	"wait for controller to complete read",	0);
	create_insn	(0X1DAE);
	create_insn	(x=0X1DB0);
	op_dec		(x,	1);
	set_cmt	(0X1DB3,	"hf_port",	0);
	set_cmt	(0X1DB8,	"read in sector",	0);
	set_cmt	(0X1DBC,	"[cmd_block+cmd_reg]",	0);
	create_insn	(x=0X1DBC);
	op_hex		(x,	1);
	create_insn	(0X1DC7);
	set_cmt	(0X1DC9,	"4 bytes of ecc",	0);
	set_cmt	(0X1DD0,	"read in ecc",	0);
	create_insn	(0X1DD7);
	set_cmt	(0X1DD9,	"[cmd_block+sec_cnt]",	0);
	set_name	(0X1DDF,	"doc3");
	set_cmt	(0X1DE0,	"get pointer to hard disk parameters",	0);
	create_insn	(0X1DE0);
	set_name	(0X1DE0,	"get_vec");
	create_insn	(x=0X1DE3);
	set_cmt	(0X1DE8,	"send contents of cmd_block to disk controller",	0);
	create_insn	(0X1DE8);
	set_name	(0X1DE8,	"command");
	create_insn	(x=0X1DEB);
	set_cmt	(0X1DF0,	"wait for disk interrupt",	0);
	create_insn	(0X1DF0);
	set_name	(0X1DF0,	"waitt");
	create_insn	(x=0X1DF3);
	set_cmt	(0X1DF8,	"wait for data request",	0);
	create_insn	(0X1DF8);
	set_name	(0X1DF8,	"wait_drq");
	create_insn	(x=0X1DFB);
	set_cmt	(0X1E00,	"check hard disk status",	0);
	create_insn	(0X1E00);
	set_name	(0X1E00,	"check_status");
	create_insn	(x=0X1E03);
	set_cmt	(0X1E08,	"check for dma overrun 64k segment",	0);
	create_insn	(0X1E08);
	set_name	(0X1E08,	"check_dma");
	create_insn	(x=0X1E0B);
	set_cmt	(0X1E10,	"compaq_disk_io",	0);
	create_insn	(0X1E10);
	set_name	(0X1E10,	"endatrom");
	set_name	(0X1E15,	"no_hookit");
	create_insn	(0X1E1A);
	set_name	(0X1E1A,	"mebbe_hookit");
	create_insn	(x=0X1E20);
	op_hex		(x,	0);
	create_byte	(0X1E2D);
	set_name	(0X1E2D,	"end_compaq_i13hook");
	set_cmt	(0X1E2E,	"The K09 requires the routines for reading the clock\nbecause of the suspend/resume facility.",	0);
	create_insn	(0X1E2E);
	set_name	(0X1E2E,	"int_6Ch");
	create_insn	(x=0X1E36);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X1E3B,	"int6c");
	set_cmt	(0X1E46,	"get the date from the clock",	0);
	set_cmt	(0X1E4A,	"update dos copy of date",	0);
	set_cmt	(0X1E4F,	"get the time from the   rtc",	0);
	set_cmt	(0X1E55,	"CLOCK - SET TIME OF DAY\nCX:DX = clock count\nReturn: time of day set",	0);
	create_insn	(x=0X1E55);
	op_hex		(x,	0);
	set_cmt	(0X1E58,	"jmp far [int6c_ret_addr] ; long jump",	0);
	create_insn	(0X1E5C);
	set_name	(0X1E5C,	"read_real_date");
	set_cmt	(0X1E5F,	"throw away clock roll over",	0);
	set_cmt	(0X1E61,	"CLOCK - GET TIME OF DAY\nReturn: CX:DX = clock count\nAL = 00h if clock was read or written (via AH=0,1) since the previous\nmidnight\nOtherwise, AL > 0",	0);
	create_insn	(x=0X1E61);
	op_hex		(x,	0);
	set_cmt	(0X1E72,	"CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: DL = day in BCD\nDH = month in BCD\nCL = year in BCD\nCH = century (19h or 20h)",	0);
	create_insn	(x=0X1E72);
	op_hex		(x,	0);
	create_insn	(0X1E79);
	set_cmt	(0X1E89,	"READ OF R-T CLOCK SUCCESSFUL",	0);
	set_cmt	(0X1E8F,	"verify bcd values in range",	0);
	set_cmt	(0X1E92,	"some value out of range",	0);
	set_cmt	(0X1EAC,	"20th century?",	0);
	create_insn	(x=0X1EAC);
	op_dec		(x,	1);
	set_cmt	(0X1EB3,	"add in a century",	0);
	create_insn	(x=0X1EB3);
	op_dec		(x,	1);
	set_cmt	(0X1EB6,	"subtract off 1-1-80",	0);
	create_insn	(x=0X1EB6);
	op_dec		(x,	1);
	set_cmt	(0X1EB9,	"leap year every 4",	0);
	set_cmt	(0X1EBB,	"al= # leap year blocks, ah= remainder",	0);
	set_cmt	(0X1EBD,	"save odd years",	0);
	set_cmt	(0X1EBF,	"zero ah",	0);
	set_cmt	(0X1EC0,	"366+(3*365)\n# of days in leap year blocks",	0);
	create_insn	(x=0X1EC0);
	op_dec		(x,	1);
	set_cmt	(0X1EC5,	"SAVE COUNT OF DAYS",	0);
	set_cmt	(0X1EC8,	"get odd years count",	0);
	set_cmt	(0X1ECF,	"days in year",	0);
	create_insn	(x=0X1ECF);
	op_dec		(x,	1);
	set_cmt	(0X1ED4,	"ADD ON DAYS IN ODD YEARS",	0);
	set_cmt	(0X1ED8,	"account for leap year\npossibly account for a leap day",	0);
	set_cmt	(0X1EDA,	"is month february?",	0);
	create_insn	(0X1EDA);
	set_cmt	(0X1EDF,	"jan or feb. no leap day yet",	0);
	set_cmt	(0X1EE1,	"account for leap day",	0);
	set_cmt	(0X1EE5,	"get days of month",	0);
	set_cmt	(0X1EEB,	"because of offset from day 1, not day 0",	0);
	set_cmt	(0X1EEC,	"GET DAYS IN MONTHS PRECEEDING",	0);
	set_cmt	(0X1EF0,	"get month",	0);
	set_cmt	(0X1EF4,	"january starts at offset 0",	0);
	create_insn	(x=0X1EF9);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(0X1F0C);
	create_insn	(0X1F12);
	set_name	(0X1F12,	"read_real_time");
	set_cmt	(0X1F14,	"CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: CH = hours in BCD\nCL = minutes in BCD\nDH = seconds in BCD",	0);
	create_insn	(x=0X1F14);
	op_hex		(x,	0);
	set_cmt	(0X1F24,	"unused for time",	0);
	set_cmt	(0X1F33,	"from bcd to bin",	0);
	set_cmt	(0X1F46,	"call far [ttticks]\nnote: indirect far call\ncx:dx = number of ticks\n(at 18.2 ticks per sec.)",	0);
	set_cmt	(0X1F4B,	"century or hours",	0);
	create_insn	(0X1F4B);
	set_name	(0X1F4B,	"in_bin");
	set_cmt	(0X1F54,	"years or minutes",	0);
	set_cmt	(0X1F5D,	"months or seconds",	0);
	set_cmt	(0X1F66,	"days (not used for time)",	0);
	set_cmt	(0X1F70,	"bcd_to_bin converts two bcd nibbles in al \n(value <= 99.) to a binary representation in al",	0);
	create_insn	(0X1F70);
	set_name	(0X1F70,	"bcd_to_bin");
	create_insn	(x=0X1F72);
	op_hex		(x,	1);
	set_cmt	(0X1F7B,	"century check",	0);
	create_insn	(x=0X1F7B);
	op_hex		(x,	1);
	set_name	(0X1F7B,	"date_verify");
	set_cmt	(0X1F82,	"jmp in 21th century",	0);
	set_cmt	(0X1F84,	"century check",	0);
	create_insn	(x=0X1F84);
	op_hex		(x,	1);
	set_cmt	(0X1F8B,	"year check",	0);
	create_insn	(x=0X1F8B);
	op_hex		(x,	1);
	set_cmt	(0X1F92,	"year check",	0);
	create_insn	(x=0X1F92);
	op_hex		(x,	1);
	set_cmt	(0X1F99,	"month check",	0);
	create_insn	(x=0X1F99);
	op_hex		(x,	1);
	set_cmt	(0X1FA7,	"day check",	0);
	create_insn	(x=0X1FA7);
	op_hex		(x,	1);
	create_insn	(0X1FB7);
	set_cmt	(0X1FB9,	"hour check",	0);
	create_insn	(x=0X1FB9);
	op_hex		(x,	1);
	set_name	(0X1FB9,	"time_verify");
	set_cmt	(0X1FC0,	"minute check",	0);
	create_insn	(x=0X1FC0);
	op_hex		(x,	1);
	set_cmt	(0X1FC7,	"second check",	0);
	create_insn	(x=0X1FC7);
	op_hex		(x,	1);
	create_insn	(0X1FD0);
	set_cmt	(0X1FD2,	"4 bytes to check",	0);
	create_insn	(0X1FD2);
	set_name	(0X1FD2,	"bcd_verify");
	create_insn	(x=0X1FD5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X1FD8,	"get a bcd number (0..99)",	0);
	set_cmt	(0X1FDC,	"10's place in high ah, 1's in al\nis 1's place in range?",	0);
	create_insn	(x=0X1FDC);
	op_hex		(x,	1);
	create_insn	(x=0X1FDF);
	op_dec		(x,	1);
	set_cmt	(0X1FE1,	"jmp out of range",	0);
	create_insn	(x=0X1FE3);
	op_hex		(x,	1);
	create_insn	(x=0X1FE5);
	op_hex		(x,	1);
	create_insn	(x=0X1FE7);
	op_hex		(x,	1);
	create_insn	(x=0X1FE9);
	op_hex		(x,	1);
	set_cmt	(0X1FEB,	"get rid of any erroneous bits",	0);
	create_insn	(x=0X1FEB);
	op_hex		(x,	1);
	set_cmt	(0X1FEE,	"is 10's place in range",	0);
	create_insn	(x=0X1FEE);
	op_dec		(x,	1);
	set_cmt	(0X1FF1,	"jmp out of range",	0);
	set_cmt	(0X1FF3,	"next byte",	0);
	set_cmt	(0X1FF7,	"set success flag",	0);
	set_cmt	(0X1FF9,	"set error flag",	0);
	create_insn	(0X1FF9);
	create_byte	(0X1FFB);
	set_name	(0X1FFB,	"endk09");
	create_word	(0X1FFC);
	set_name	(0X1FFC,	"drvfat");
	create_word	(0X1FFE);
	make_array	(0X1FFE,	0X2);
	set_name	(0X1FFE,	"First_Data_Sector");
	create_word	(0X2002);
	set_name	(0X2002,	"doscnt");
	create_byte	(0X2004);
	set_name	(0X2004,	"fbigfat");
	create_word	(0X2005);
	set_name	(0X2005,	"fatloc");
	create_word	(0X2007);
	set_name	(0X2007,	"init_bootseg");
	create_byte	(0X2009);
	set_name	(0X2009,	"rom_drv_num");
	create_word	(0X200A);
	set_name	(0X200A,	"md_sectorsize");
	create_word	(0X200C);
	set_name	(0X200C,	"temp_cluster");
	create_word	(0X200E);
	set_name	(0X200E,	"last_fat_sec_num");
	create_word	(0X2010);
	set_name	(0X2010,	"num_heads");
	create_byte	(0X2012);
	set_name	(0X2012,	"sec_trk");
	create_word	(x=0X2013);
	op_dec		(x,	0);
	set_name	(0X2013,	"num_cyln");
	create_byte	(0X2015);
	set_name	(0X2015,	"fakefloppydrv");
	set_cmt	(0X2016,	"\n08/08/2023\n; disktable.totalsectors: resd 1\n; disktable.shiftcount:   resb 1\n; disktable.secperclus:   resb 1\n; disktable.rdirentries:  resw 1\n; disktable.bigflag:      resw 1",	0);
	create_word	(0X2016);
	make_array	(0X2016,	0X2);
	set_name	(0X2016,	"Orig_Int1Eh_Table");
	create_word	(0X201A);
	set_name	(0X201A,	"disktable2");
	create_word	(x=0X201C);
	op_dec		(x,	0);
	create_word	(x=0X201E);
	op_hex		(x,	0);
	create_word	(x=0X2020);
	op_dec		(x,	0);
	set_cmt	(0X2022,	"for compatibility. (32680 sectors, 16340 KB)",	0);
	create_word	(0X2022);
	create_word	(0X2024);
	create_word	(0X2026);
	create_word	(0X2028);
	create_word	(x=0X202A);
	op_dec		(x,	0);
	set_cmt	(0X202C,	"covers upto 134 mb media. ; fbig = 40h\n(40000h sectors = 128 MB)",	0);
	create_word	(0X202C);
	create_word	(0X202E);
	create_word	(0X2030);
	create_word	(0X2032);
	create_word	(x=0X2034);
	op_dec		(x,	0);
	set_cmt	(0X2036,	"upto 268 mb (80000h sectors = 256 MB)",	0);
	create_word	(0X2036);
	create_word	(x=0X2038);
	op_dec		(x,	0);
	create_word	(0X203A);
	create_word	(0X203C);
	create_word	(x=0X203E);
	op_dec		(x,	0);
	set_cmt	(0X2040,	"upto 536 mb (100000h sectors = 512 MB)",	0);
	create_word	(0X2040);
	create_word	(x=0X2042);
	op_dec		(x,	0);
	create_word	(0X2044);
	create_word	(0X2046);
	create_word	(x=0X2048);
	op_dec		(x,	0);
	set_cmt	(0X204A,	"upto 1072 mb (200000h sectors = 1024 MB)",	0);
	create_word	(0X204A);
	create_word	(x=0X204C);
	op_dec		(x,	0);
	create_word	(0X204E);
	create_word	(0X2050);
	create_word	(x=0X2052);
	op_dec		(x,	0);
	set_cmt	(0X2054,	"upto 2144 mb (400000h sectors = 2048 MB)",	0);
	create_word	(x=0X2054);
	op_hex		(x,	0);
	set_cmt	(0X2056,	"if fs size > 2144 MB, it is FAT32 file system",	0);
	create_word	(0X2056);
	create_word	(0X2058);
	set_cmt	(0X205A,	"cluster shift 3, sec per clust = 8",	0);
	create_word	(0X205A);
	create_word	(0X205C);
	set_cmt	(0X205E,	"> 2144 MB ; FAT32 (fbigbig = 20h)\n(fbig and fbigbig flags are set)\n;",	0);
	create_word	(0X205E);
	create_byte	(0X2060);
	set_name	(0X2060,	"rom_minidisk_num");
	create_byte	(0X2061);
	set_name	(0X2061,	"hnum");
	create_word	(x=0X2062);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X2062,	"last_dskdrv_table");
	create_word	(x=0X2064);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X2064,	"end_of_bdss");
	create_word	(0X2066);
	set_name	(0X2066,	"mini_hdlim");
	create_word	(0X2068);
	set_name	(0X2068,	"mini_seclim");
	create_word	(x=0X206A);
	op_hex		(x,	0);
	set_name	(0X206A,	"ld_p_number");
	create_strlit	(0X206C,	0X2075);
	set_name	(0X206C,	"bios_date");
	create_byte	(0X2075);
	create_word	(x=0X2076);
	op_dec		(x,	0);
	set_name	(0X2076,	"bpb48t");
	create_byte	(0X2078);
	create_word	(0X2079);
	create_byte	(0X207B);
	create_word	(x=0X207C);
	op_dec		(x,	0);
	create_word	(x=0X207E);
	op_dec		(x,	0);
	create_word	(0X2081);
	create_word	(0X2083);
	create_word	(0X2085);
	create_word	(0X2087);
	create_word	(0X2089);
	create_word	(0X208B);
	create_word	(0X208D);
	set_cmt	(0X208F,	"FAT32 extensions (to BDS)",	0);
	create_byte	(x=0X208F);
	make_array	(x,	0X1C);
	op_dec		(x,	0);
	create_byte	(0X20AB);
	create_word	(x=0X20AC);
	op_dec		(x,	0);
	set_name	(0X20AC,	"bpb96t");
	create_byte	(0X20AE);
	create_word	(0X20AF);
	create_byte	(0X20B1);
	create_word	(x=0X20B2);
	op_dec		(x,	0);
	create_word	(x=0X20B4);
	op_dec		(x,	0);
	create_byte	(0X20B6);
	create_word	(0X20B7);
	create_word	(x=0X20B9);
	op_dec		(x,	0);
	create_word	(0X20BB);
	create_word	(0X20BD);
	create_word	(0X20BF);
	create_byte	(0X20C1);
	create_byte	(0X20C2);
	create_byte	(0X20C3);
	create_byte	(0X20C4);
	create_byte	(x=0X20C5);
	make_array	(x,	0X1C);
	op_dec		(x,	0);
	create_byte	(0X20E1);
	create_word	(x=0X20E2);
	op_dec		(x,	0);
	set_name	(0X20E2,	"bpb35");
	create_byte	(0X20E4);
	create_word	(0X20E5);
	create_byte	(0X20E7);
	create_word	(x=0X20E8);
	op_dec		(x,	0);
	create_word	(x=0X20EA);
	op_dec		(x,	0);
	create_byte	(0X20EC);
	create_word	(0X20ED);
	create_word	(0X20EF);
	create_word	(0X20F1);
	create_word	(0X20F3);
	create_word	(0X20F5);
	create_dword	(0X20F7);
	create_byte	(x=0X20FB);
	make_array	(x,	0X1C);
	op_dec		(x,	0);
	create_byte	(0X2117);
	create_word	(x=0X2118);
	op_dec		(x,	0);
	set_name	(0X2118,	"bpb288");
	create_byte	(0X211A);
	create_word	(0X211B);
	create_byte	(0X211D);
	create_word	(x=0X211E);
	op_dec		(x,	0);
	create_word	(x=0X2120);
	op_dec		(x,	0);
	create_byte	(0X2122);
	create_word	(0X2123);
	create_word	(x=0X2125);
	op_dec		(x,	0);
	create_word	(0X2127);
	create_word	(0X2129);
	create_word	(0X212B);
	create_dword	(0X212D);
	create_byte	(x=0X2131);
	make_array	(x,	0X1C);
	op_dec		(x,	0);
	create_byte	(0X214D);
	create_word	(x=0X214E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X214E,	"bpbtable");
	create_word	(x=0X2150);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X2152);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X2154);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X2156);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X2158);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X215A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X215C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X215E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X2160);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_word	(x=0X2162);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_name	(0X2162,	"addr_of_bcretf");
	set_cmt	(0X2164,	"set up near return to far return",	0);
	create_insn	(0X2164);
	set_name	(0X2164,	"call_bios_code");
	set_cmt	(0X2169,	"[cs:cdev+2] ; push Bios_Code segment",	0);
	create_byte	(0X2170);
	set_name	(0X2170,	"flp_drvs");
	create_word	(0X2171);
	set_name	(0X2171,	"firstcluster_hw");
	create_byte	(0X2173);
	set_name	(0X2173,	"Boot_Drv");
	create_insn	(0X2174);
	set_name	(0X2174,	"cd_boot_option");
	set_name	(0X2178,	"cdbo_1");
	set_cmt	(0X217A,	"KEYBOARD - ",	0);
	create_insn	(x=0X217A);
	op_hex		(x,	0);
	set_cmt	(0X2180,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character",	0);
	create_insn	(x=0X2180);
	op_hex		(x,	0);
	create_insn	(0X2184);
	set_name	(0X2184,	"cdbo_2");
	create_insn	(x=0X2186);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X218A,	"cdbo_3");
	set_cmt	(0X218F,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X218F);
	op_hex		(x,	0);
	create_insn	(x=0X2196);
	op_hex		(x,	1);
	set_cmt	(0X219B,	"0:46Ch = Daily timer counter (4 bytes)",	0);
	create_insn	(x=0X219B);
	create_insn	(x=0X219F);
	set_name	(0X21A3,	"wait_for_key");
	set_cmt	(0X21AA,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21AA);
	op_hex		(x,	0);
	set_cmt	(0X21AF,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21AF);
	op_hex		(x,	0);
	set_cmt	(0X21B4,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21B4);
	op_hex		(x,	0);
	set_cmt	(0X21B7,	"18.2 ticks per second",	0);
	create_insn	(x=0X21B7);
	op_dec		(x,	1);
	set_cmt	(0X21BA,	"next second (if carry flag is 1)",	0);
	set_name	(0X21BD,	"continue_to_wait");
	set_cmt	(0X21BF,	"KEYBOARD - ",	0);
	create_insn	(x=0X21BF);
	op_hex		(x,	0);
	set_cmt	(0X21C5,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character",	0);
	create_insn	(x=0X21C5);
	op_hex		(x,	0);
	set_name	(0X21CC,	"cdbo_4");
	set_cmt	(0X21D2,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21D2);
	op_hex		(x,	0);
	set_cmt	(0X21D7,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21D7);
	op_hex		(x,	0);
	create_insn	(0X21DE);
	set_name	(0X21DE,	"cdbo_5");
	set_name	(0X21E8,	"cdb0_6");
	set_name	(0X21F1,	"cdb0_7");
	set_cmt	(0X21F7,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21F7);
	op_hex		(x,	0);
	set_cmt	(0X21FC,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X21FC);
	op_hex		(x,	0);
	set_cmt	(0X2203,	"disk drive = 0 (fd)",	0);
	create_insn	(x=0X2205);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2208,	"DISK - Bootable CD-ROM - AL = TERMINATE DISK EMULATION",	0);
	create_insn	(x=0X2208);
	op_hex		(x,	0);
	set_cmt	(0X220A,	"DS:SI = Specification packet filled",	0);
	set_cmt	(0X2233,	"disk drive = 80h (hd)",	0);
	set_cmt	(0X2236,	"DISK - Bootable CD-ROM - AL = TERMINATE DISK EMULATION",	0);
	create_insn	(x=0X2236);
	op_hex		(x,	0);
	set_cmt	(0X223D,	"DISK - RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)",	0);
	create_insn	(x=0X223D);
	op_hex		(x,	0);
	create_insn	(x=0X2244);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X224D,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X224D);
	op_hex		(x,	0);
	set_name	(0X225A,	"cdbo_8");
	create_insn	(0X225D);
	set_name	(0X225D,	"cdbo_9");
	set_cmt	(0X226A,	"256",	0);
	create_insn	(x=0X2272);
	op_hex		(x,	1);
	create_byte	(x=0X2283);
	op_dec		(x,	0);
	set_name	(0X2283,	"empty_dap_buff");
	create_byte	(x=0X2284);
	make_array	(x,	0X12);
	op_dec		(x,	0);
	set_cmt	(0X2296,	"5 seconds",	0);
	create_byte	(0X2296);
	set_name	(0X2296,	"time_counter");
	create_strlit	(0X2297,	0X22CA);
	set_name	(0X2297,	"cd_boot_msg");
	create_insn	(0X22CA);
	set_name	(0X22CA,	"init");
	set_cmt	(0X22CB,	"DS:SI from MSLOAD (not boot sector)",	0);
	set_cmt	(0X22DB,	"AX:BX from MSLOAD",	0);
	set_cmt	(0X22E4,	"Boot Drive from MSLOAD ;;; [BootDrive]",	0);
	set_cmt	(0X22EF,	"SYSINIT segment\nSYSINITSEG (= IOSYSCODESEG+(SYSINITOFFSET>>4)",	0);
	set_cmt	(0X22F4,	"check (1st sector) of the root directory -of BOOT CD-\nfor special names (as boot option signature)",	0);
	set_cmt	(0X22F6,	"ROOT DIRECTORY BUFFER offset 40h\n(BOOT DRV's root directory the 3rd entry)",	0);
	set_name	(0X22F9,	"chk_boot_hdnoz");
	set_cmt	(0X22FE,	"'_BOOT_HDNOZ'",	0);
	create_insn	(x=0X22FE);
	op_hex		(x,	1);
	set_cmt	(0X2304,	"'OO'",	0);
	create_insn	(x=0X2304);
	op_hex		(x,	1);
	create_insn	(x=0X230B);
	op_hex		(x,	1);
	set_cmt	(0X2312,	"'HD'",	0);
	create_insn	(x=0X2312);
	op_hex		(x,	1);
	create_insn	(x=0X2319);
	op_hex		(x,	1);
	set_cmt	(0X2320,	"'Z'",	0);
	create_insn	(x=0X2320);
	op_hex		(x,	1);
	set_cmt	(0X232B,	"(next entry)",	0);
	create_insn	(x=0X232B);
	op_dec		(x,	1);
	set_name	(0X232B,	"chk_next_1");
	set_cmt	(0X2334,	"(BOOT DRV's root directory the 3rd entry)",	0);
	set_name	(0X2334,	"chk_no_logo_noz");
	set_name	(0X2337,	"chk_no_logo_noz2_nxt");
	set_cmt	(0X233C,	"'NO_LOGO NOZ'",	0);
	create_insn	(x=0X233C);
	op_hex		(x,	1);
	create_insn	(x=0X2342);
	op_hex		(x,	1);
	create_insn	(x=0X2349);
	op_hex		(x,	1);
	create_insn	(x=0X2350);
	op_hex		(x,	1);
	create_insn	(x=0X2357);
	op_hex		(x,	1);
	create_insn	(x=0X235E);
	op_hex		(x,	1);
	set_cmt	(0X2364,	"(next entry)",	0);
	create_insn	(x=0X2364);
	op_dec		(x,	1);
	set_name	(0X2364,	"chk_next_2");
	set_cmt	(0X236D,	"SYSINIT segment",	0);
	set_name	(0X236D,	"write_start_msg");
	create_insn	(x=0X236F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X2372,	"startmsg_nxt_chr");
	set_cmt	(0X237C,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X237C);
	op_hex		(x,	0);
	create_insn	(0X2380);
	set_name	(0X2380,	"startmsg_ok");
	create_insn	(x=0X2384);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2387,	"next_int");
	create_insn	(x=0X238A);
	op_hex		(x,	1);
	create_insn	(x=0X238C);
	op_hex		(x,	1);
	create_insn	(x=0X23AC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X23C4);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X23CE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X23D8);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X23DE,	"19h*4+2",	0);
	set_cmt	(0X23E3,	"EQUIPMENT DETERMINATION\nReturn: AX = equipment flag bits",	0);
	create_insn	(x=0X23E3);
	op_hex		(x,	0);
	set_cmt	(0X23E7,	"52h ; 'R'",	0);
	create_insn	(0X23E7);
	set_cmt	(0X23E8,	"50h ; 'P'",	0);
	set_cmt	(0X23E9,	"53h ; 'S'",	0);
	create_insn	(x=0X23EA);
	op_hex		(x,	1);
	set_name	(0X23EA,	"chk_fd_count");
	create_insn	(x=0X23ED);
	op_hex		(x,	1);
	set_cmt	(0X23FC,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter",	0);
	create_insn	(x=0X23FC);
	op_hex		(x,	0);
	set_name	(0X2405,	"_gdskp_error");
	create_insn	(0X241D);
	set_name	(0X241D,	"_set_fake_flpdrv");
	create_insn	(x=0X2428);
	op_hex		(x,	1);
	set_name	(0X2428,	"normalfloppydrv");
	create_insn	(x=0X242A);
	op_hex		(x,	1);
	create_insn	(x=0X242C);
	op_hex		(x,	1);
	set_name	(0X242C,	"got_num_flp_drvs");
	set_name	(0X2432,	"settwodrive");
	set_name	(0X2437,	"notsingle");
	create_insn	(x=0X243A);
	op_hex		(x,	1);
	set_name	(0X2445,	"gothrd");
	set_cmt	(0X244F,	"[MediaByte]",	0);
	set_cmt	(0X2454,	"SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)",	0);
	create_insn	(x=0X2454);
	op_hex		(x,	0);
	create_insn	(0X246F);
	set_name	(0X246F,	"no_rom_system_conf");
	create_insn	(x=0X247C);
	op_hex		(x,	1);
	set_name	(0X247C,	"turn_timer_on");
	set_cmt	(0X247E,	"Interrupt controller, 8259A.",	0);
	create_insn	(x=0X247E);
	op_hex		(x,	0);
	create_insn	(x=0X2488);
	op_hex		(x,	1);
	create_insn	(x=0X248A);
	op_hex		(x,	1);
	create_insn	(x=0X2490);
	op_hex		(x,	0);
	create_insn	(x=0X2492);
	op_hex		(x,	1);
	create_insn	(x=0X2494);
	op_hex		(x,	1);
	set_name	(0X2498,	"not_olivetti_m24");
	set_name	(0X24AC,	"skip_aux_port_init");
	set_cmt	(0X24C1,	"initspot\nIBMDOS.COM's first cluster - high word\n520h (the 2nd entry of root dir) + 14h",	0);
	create_insn	(x=0X24C1);
	set_cmt	(0X24C8,	"0",	0);
	set_cmt	(0X24CA,	"INITSPOT (0000h:0534h)\nIBM wants 4 zeros here",	0);
	create_insn	(x=0X24CA);
	op_hex		(x,	1);
	set_cmt	(0X24D1,	"INT 1Bh vector",	0);
	create_insn	(x=0X24D1);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X24D7);
	set_cmt	(0X24DA,	"INT 29h vector",	0);
	create_insn	(x=0X24DA);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X24E0);
	create_insn	(x=0X24E6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X24EA,	"int 1",	0);
	set_cmt	(0X24ED,	"skip int 2",	0);
	set_cmt	(0X24F1,	"int 3",	0);
	set_cmt	(0X24F5,	"int 4",	0);
	set_cmt	(0X24F8,	"set print screen & break = 0",	0);
	create_insn	(x=0X24F8);
	set_cmt	(0X24FC,	"clean out last drive spec",	0);
	create_insn	(x=0X24FC);
	set_cmt	(0X2500,	"SEC9+DISK_PARMS.DISK_MOTOR_STRT\nmotor start time in 1/8 seconds",	0);
	create_insn	(x=0X2500);
	set_cmt	(0X2507,	"is this an old rom?",	0);
	set_cmt	(0X250D,	"no",	0);
	set_cmt	(0X250F,	"[SEC9+DISK_PARMS.DISK_HEAD_STTL]\nhead settle time in milliseconds",	0);
	create_insn	(x=0X250F);
	set_cmt	(0X2515,	"[SEC9+DISK_PARMS.DISK_SPECIFY_1]\nset 1st specify byte on pc-1 pc-2 pc-xt hal0",	0);
	create_insn	(x=0X2515);
	set_cmt	(0X251A,	"MEMORY SIZE - \nReturn: AX = number of contiguous 1K blocks of memory",	0);
	create_insn	(x=0X251A);
	op_hex		(x,	0);
	set_name	(0X251A,	"no_diddle");
	set_cmt	(0X252D,	"INT 2Fh handler ; [2Fh*4]",	0);
	create_insn	(x=0X252D);
	set_cmt	(0X2531,	"[2Fh*4+2]",	0);
	create_insn	(x=0X2531);
	set_cmt	(0X2535,	"'RP' ; 'RPL'",	0);
	create_insn	(x=0X2535);
	op_hex		(x,	1);
	set_cmt	(0X253C,	"'L'",	0);
	create_insn	(x=0X253C);
	op_hex		(x,	1);
	set_cmt	(0X2542,	"get TOM into dx",	0);
	set_cmt	(0X2544,	"(multMULT shl 8) + multMULTRPLTOM",	0);
	set_cmt	(0X2547,	"Get new TOM from any RPL",	0);
	create_insn	(x=0X2547);
	op_hex		(x,	0);
	set_name	(0X254B,	"SkipRPL");
	create_insn	(x=0X254D);
	op_hex		(x,	1);
	set_cmt	(0X2550,	"location to read fat",	0);
	create_insn	(x=0X2554);
	op_hex		(x,	1);
	set_cmt	(0X255C,	"SYSINITSEG ; SYSINIT segment",	0);
	create_insn	(x=0X2561);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X2567);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X256B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X2570);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X2574,	"DOSLOADSEG\nDOSLOADSEG  = SYSINITSEG+((SYSINITSIZE+15)/16)",	0);
	create_insn	(x=0X2574);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X257A,	"SYSINITSEG",	0);
	set_cmt	(0X2583,	"INT 0Fh vector, segment",	0);
	create_insn	(x=0X2583);
	create_insn	(x=0X2586);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X2592);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2592,	"resetintf");
	create_insn	(x=0X2598);
	set_name	(0X259C,	"keepintf");
	set_cmt	(0X25A0,	"get keyboard flag",	0);
	create_insn	(x=0X25A0);
	set_cmt	(0X25A4,	"extended keyboard ?",	0);
	create_insn	(x=0X25A4);
	op_hex		(x,	1);
	set_cmt	(0X25A7,	"no",	0);
	set_cmt	(0X25A9,	"extended keyboard function",	0);
	create_insn	(x=0X25A9);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X25AF,	"extended keyboard function",	0);
	set_name	(0X25B5,	"org_key");
	set_cmt	(0X25B9,	"If cmos clock exists,\nthen set the system time according to that.\nalso, reset the cmos clock rate.\n;",	0);
	set_cmt	(0X25BC,	"BData_start",	0);
	create_insn	(x=0X25BC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X25C2,	"number of floppies and FAT ID",	0);
	set_cmt	(0X25C3,	"chuck fat id byte",	0);
	set_cmt	(0X25C5,	"remember which drive is hard disk",	0);
	set_cmt	(0X25C8,	"and set initial number of drives",	0);
	create_insn	(x=0X25CB);
	op_hex		(x,	1);
	set_cmt	(0X25D7,	"'COMPAQ'",	0);
	create_insn	(x=0X25D7);
	op_chr		(x,	1);
	create_insn	(x=0X25DF);
	op_chr		(x,	1);
	create_insn	(x=0X25E7);
	op_chr		(x,	1);
	create_insn	(x=0X25F2);
	op_hex		(x,	0);
	set_cmt	(0X25F6,	"or bx,40h ; enable mode 2\n(MSDOS 6.0)",	0);
	create_insn	(x=0X25F6);
	op_hex		(x,	1);
	set_cmt	(0X25F9,	"set advanced system info",	0);
	create_insn	(x=0X25FC);
	op_hex		(x,	0);
	set_name	(0X25FE,	"skip_mode2");
	set_cmt	(0X2603,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter",	0);
	create_insn	(x=0X2603);
	op_hex		(x,	0);
	set_cmt	(0X2607,	"save number of hard drives",	0);
	create_insn	(x=0X2607);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X260B,	"drive number = 0",	0);
	set_name	(0X260B,	"enddrv");
	create_insn	(x=0X2614);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X261E,	"[di+BDS.link]",	0);
	set_cmt	(0X2620,	" di <- second bds link",	0);
	set_cmt	(0X2622,	"-1 ; set end of link",	0);
	set_cmt	(0X2626,	"allocate/initialise bds for harddrives",	0);
	create_insn	(0X2629);
	set_name	(0X2629,	"loop_drive");
	set_cmt	(0X2632,	"zero all flags",	0);
	create_insn	(0X2632);
	set_name	(0X2632,	"got_more");
	set_cmt	(0X2634,	"[di+BDS.link] ; get next bds",	0);
	set_cmt	(0X2636,	"end of link ?",	0);
	set_cmt	(0X263B,	"drive number (0 based)",	0);
	create_insn	(x=0X2640);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2651,	"ff48tpi ; set form factor to 48 tpi",	0);
	set_name	(0X2651,	"not_last_bds");
	set_cmt	(0X2653,	"40 tracks per side",	0);
	create_insn	(x=0X2653);
	op_dec		(x,	1);
	set_cmt	(0X2665,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter",	0);
	create_insn	(x=0X2665);
	op_hex		(x,	0);
	set_cmt	(0X266D,	"ATAPI Removable Media Device",	0);
	create_insn	(0X266D);
	set_name	(0X266D,	"chk_drv_type");
	create_insn	(x=0X2676);
	op_dec		(x,	1);
	create_insn	(x=0X267C);
	op_dec		(x,	1);
	set_cmt	(0X2680,	"DS:SI = segment:offset pointer to Result Buffer",	0);
	create_insn	(x=0X2684);
	op_hex		(x,	1);
	set_cmt	(0X2686,	"DISK - IBM/MS Extension\nGET DRIVE PARAMETERS (DL - drive, DS:SI - buffer)",	0);
	create_insn	(x=0X2686);
	op_hex		(x,	0);
	set_cmt	(0X268A,	"physical number of heads",	0);
	create_insn	(x=0X268D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2690,	"physical number of cylinders",	0);
	create_insn	(x=0X2693);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2696,	"physical number of sectors per track",	0);
	create_insn	(x=0X2699);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X269C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X26A2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X26A5,	"_eotok");
	set_cmt	(0X26A7,	"information flags\nbit 4 = Device has change line support",	0);
	create_insn	(x=0X26A7);
	op_hex		(x,	1);
	set_cmt	(0X26AD,	"change line support",	0);
	create_insn	(x=0X26AD);
	op_hex		(x,	1);
	create_insn	(x=0X26AF);
	op_dec		(x,	1);
	set_name	(0X26AF,	"not_chgline_sup");
	create_insn	(x=0X26B9);
	op_hex		(x,	1);
	set_cmt	(0X26BF,	"Device has change line support",	0);
	create_insn	(x=0X26BF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X26C4,	"gotother_j");
	create_insn	(x=0X26C6);
	op_dec		(x,	1);
	set_name	(0X26C6,	"ext_gdp_err");
	set_cmt	(0X26CB,	"if ch=0, then cl,dh=0 too.",	0);
	set_name	(0X26CB,	"not_atapi_removable");
	set_cmt	(0X26CE,	"\nrom gave wrong info.\nlet's default to 360k.",	0);
	create_insn	(x=0X26D0);
	op_dec		(x,	1);
	set_name	(0X26D6,	"pfr_ok");
	set_cmt	(0X26DA,	"make number of heads 1-based",	0);
	create_insn	(x=0X26DB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X26E0);
	op_hex		(x,	1);
	create_insn	(x=0X26E3);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X26EA);
	op_hex		(x,	1);
	create_insn	(x=0X26EC);
	op_hex		(x,	1);
	create_insn	(x=0X26EE);
	op_hex		(x,	1);
	set_cmt	(0X26F1,	"make number of cylinders 1-based",	0);
	create_insn	(x=0X26F2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X26F6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X26FA);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X2700);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X2704,	"eotok");
	set_cmt	(0X270D,	"DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)\nDL = drive ID\nReturn: CF set on error, AH = disk type (3 = hard drive)\nCX:DX = number of sectors on the media",	0);
	create_insn	(x=0X270D);
	op_hex		(x,	0);
	set_cmt	(0X2718,	"fchangeline ; change line support",	0);
	create_insn	(x=0X2718);
	op_hex		(x,	1);
	set_cmt	(0X271B,	"remember that we have 96tpi disks",	0);
	create_insn	(x=0X271B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X2720);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_name	(0X2720,	"changeline_done");
	create_insn	(x=0X2727);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X272E,	"ffOther ; we have a \"strange\" medium",	0);
	set_name	(0X272E,	"gotother");
	create_insn	(x=0X2732);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_name	(0X2732,	"try_80");
	set_cmt	(0X2739,	"ff288 ; assume 2.88 MB drive",	0);
	set_cmt	(0X273B,	"is it ?",	0);
	create_insn	(x=0X273B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X2740,	"yes, go update",	0);
	create_insn	(x=0X2742);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	create_insn	(x=0X2749);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2750,	"ffSmall",	0);
	set_cmt	(0X2754,	"ff96tpi",	0);
	create_insn	(x=0X2754);
	op_dec		(x,	1);
	set_name	(0X2754,	"got96");
	create_insn	(0X2758);
	set_name	(0X2758,	"noparmsfromrom");
	set_cmt	(0X2761,	"DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)\nDL = drive ID\nReturn: CF set on error, AH = disk type (3 = hard drive)\nCX:DX = number of sectors on the media",	0);
	create_insn	(x=0X2761);
	op_hex		(x,	0);
	set_cmt	(0X2767,	"is there changeline?",	0);
	set_cmt	(0X276C,	"yes, this drive has change line supoort",	0);
	create_insn	(x=0X276C);
	op_hex		(x,	1);
	set_cmt	(0X276F,	"remember that we have 96tpi drives\n(change line support)",	0);
	create_insn	(x=0X276F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X2774);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X277A,	"ff96tpi",	0);
	create_insn	(x=0X277C);
	op_dec		(x,	1);
	create_insn	(x=0X277E);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X2784);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2787,	"fi_own_physical \nset this true for all drives",	0);
	create_insn	(x=0X2787);
	op_hex		(x,	1);
	set_name	(0X2787,	"nextdrive");
	set_cmt	(0X278A,	"save int13 drive number",	0);
	create_insn	(x=0X278C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2793,	"int13 drive number same for logical drive",	0);
	set_cmt	(0X2795,	"fi_own_physical\nreset ownership flag for logical drive",	0);
	create_insn	(x=0X2795);
	op_hex		(x,	1);
	create_insn	(x=0X2798);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2798,	"not_special");
	set_cmt	(0X279B,	"[di+BDS.rheads]",	0);
	create_insn	(x=0X27A0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X27A3,	"[di+BDS.rsecpertrack]",	0);
	set_cmt	(0X27A6,	"[di+BDS.flags]",	0);
	set_cmt	(0X27A9,	"[di+BDS.formfactor]",	0);
	set_cmt	(0X27AC,	"[di+BDS.drivelet]",	0);
	set_cmt	(0X27AF,	"[di+BDS.drivenum]",	0);
	create_insn	(x=0X27B3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X27B7,	"[di+BDS.cylinders]",	0);
	set_cmt	(0X27BB,	"Special case for single drive system",	0);
	create_insn	(x=0X27BB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X27C2,	"Don't forget we have single drive system",	0);
	create_insn	(x=0X27C2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X27C7,	"fi_am_mult\nset that this is one of several drives",	0);
	create_insn	(x=0X27C7);
	op_hex		(x,	1);
	set_cmt	(0X27CA,	"[di+BDS.flags] ; save flags",	0);
	set_cmt	(0X27CD,	"[di+BDS.link] ; move to next BDS in list",	0);
	set_cmt	(0X27CF,	"add a number",	0);
	set_cmt	(0X27D1,	"Use same info for BDS as previous",	0);
	create_insn	(0X27D3);
	set_name	(0X27D3,	"no_single");
	set_cmt	(0X27D8,	"-1",	0);
	create_insn	(0X27D8);
	set_name	(0X27D8,	"done_drives");
	create_insn	(x=0X27DC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X27DC,	"dohard");
	set_name	(0X27E6,	"dohard1");
	create_insn	(x=0X27E7);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X27EB);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X27FE,	"hardfile_err");
	create_insn	(x=0X2808);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X280E,	"dohardx1");
	set_name	(0X2810,	"dohardx2");
	create_insn	(x=0X2812);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X2816);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(0X282D);
	set_name	(0X282D,	"dohardx4");
	create_insn	(x=0X2835);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X283F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X283F,	"static_configure");
	create_insn	(x=0X2843);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2849,	"offset end96tpi",	0);
	create_insn	(x=0X2849);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X284C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X2853);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2856,	"dynamic_configure");
	set_cmt	(0X2859,	"AT?",	0);
	create_insn	(x=0X2859);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X285E,	"no",	0);
	set_cmt	(0X2860,	"No hard file?",	0);
	create_insn	(x=0X2860);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2867,	"save allocation pointer in ax",	0);
	create_insn	(x=0X286D);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2870,	"ROM BIOS string is at F000:FFF5",	0);
	set_cmt	(0X2873,	"Only patch ROM for bios 01/10/84",	0);
	set_cmt	(0X2876,	"check for date + zero on end",	0);
	set_cmt	(0X2878,	"restore allocation pointer",	0);
	create_insn	(x=0X287B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X287E);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(0X2883);
	set_name	(0X2883,	"checkcompaqbug");
	set_cmt	(0X2888,	"'CO'",	0);
	set_cmt	(0X2891,	"'MP'",	0);
	set_cmt	(0X289A,	"'AQ'",	0);
	set_cmt	(0X28A9,	"'68' (NASM syntax) (('86' in MASM syntax))",	0);
	set_cmt	(0X28B0,	"'97'",	0);
	set_name	(0X28B6,	"chkcompaqbug1");
	set_cmt	(0X28BE,	"'80'",	0);
	set_cmt	(0X28CB,	"'40'",	0);
	create_insn	(x=0X28D0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X28D0,	"do_compaq_patch");
	create_insn	(x=0X28D3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X28D6,	"install_int13_patch");
	create_insn	(x=0X28D8);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X28DC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X28E4,	"checkcmosclock");
	set_name	(0X28E6,	"checkk09");
	set_cmt	(0X28E7,	"wait for any external event (al=0)",	0);
	set_cmt	(0X28EA,	"wait for 4 clock ticks",	0);
	set_cmt	(0X28ED,	"SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)\nAL = condition type, BH = condition compare or mask value\nBL = timeout value times 55 milliseconds, 00h means no timeout\nDX = I/O port address if AL bit 4 set",	0);
	create_insn	(x=0X28ED);
	op_hex		(x,	0);
	set_cmt	(0X28F2,	"remember we have a k09 type",	0);
	create_insn	(x=0X28F2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X28FC,	"[6Ch*4]\nnew int 6ch handler",	0);
	create_insn	(x=0X28FC);
	create_insn	(x=0X2900);
	create_insn	(x=0X2905);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2908,	"endk09-int_6Ch (size of k09 routine)",	0);
	create_insn	(x=0X2908);
	op_dec		(x,	1);
	set_name	(0X290D,	"configdone");
	set_cmt	(0X290E,	"di is final ending address of msbio.",	0);
	set_cmt	(0X290F,	"round (up) to paragraph",	0);
	create_insn	(x=0X290F);
	op_dec		(x,	1);
	create_insn	(x=0X2912);
	op_hex		(x,	1);
	create_insn	(x=0X2914);
	op_hex		(x,	1);
	create_insn	(x=0X2916);
	op_hex		(x,	1);
	create_insn	(x=0X2918);
	op_hex		(x,	1);
	create_insn	(x=0X291A);
	op_hex		(x,	1);
	set_cmt	(0X291E,	"where the dos data segment will be",	0);
	create_insn	(x=0X2925);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	create_insn	(x=0X292C);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	create_insn	(x=0X2947);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	create_insn	(x=0X295C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X2967);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X296F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X297C,	"clus=*53Ah\n(First cluster field of 2nd dir entry\nof root directory in the buffer at 500h)",	0);
	create_insn	(x=0X297C);
	create_insn	(x=0X2987);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X298B,	"(*) save fbigfat flags",	0);
	create_insn	(x=0X298C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X2990);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2995,	"hard disk",	0);
	set_cmt	(0X2997,	"calculate cluster count and set fbig or fbigbig flag\nfor removable drives",	0);
	set_name	(0X2997,	"boot_drv_removable");
	set_cmt	(0X299A,	"[di+BDS.totalsecs16]",	0);
	set_cmt	(0X29A3,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X29A9,	"[di+BDS.resectors]",	0);
	set_name	(0X29A9,	"prep_totalsecs_ok");
	set_cmt	(0X29B1,	"[di+BDS.fatsecs16]",	0);
	set_cmt	(0X29BA,	"[di+BDS.fatsecs32]",	0);
	set_cmt	(0X29C0,	"ax:bx = 32 bit count of FAT sectors\n[di+BDS.fats]",	0);
	set_name	(0X29C0,	"prep_fatsecs_ok");
	set_cmt	(0X29CC,	"cx:bx = total (2*) fat sectors",	0);
	set_cmt	(0X29CF,	"dx:ax = totals sectors - reserved sectors",	0);
	set_cmt	(0X29D2,	"dx:ax = data sectors (includes root dir sectors)",	0);
	set_cmt	(0X29D4,	"[di+BDS.direntries]",	0);
	set_cmt	(0X29D7,	"16 directory entries per sector\n(round up sector count by adding 15)",	0);
	create_insn	(x=0X29D7);
	op_dec		(x,	1);
	set_cmt	(0X29DA,	"(rounded) dir entries / 16",	0);
	set_cmt	(0X29E2,	"dx:ax = data sectors (except root directory sectors)\n(will be used for cluster count calculation)",	0);
	set_cmt	(0X29E4,	"[di+BDS.secperclus]",	0);
	set_cmt	(0X29E7,	"32 bit division (data sectors / sector per cluster)",	0);
	set_cmt	(0X29F3,	"32 bit cluster count if bx > 0",	0);
	set_cmt	(0X29F5,	"too big cluster number",	0);
	set_cmt	(0X29FC,	"FAT32  ; fbigbig",	0);
	create_insn	(x=0X29FC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_name	(0X29FC,	"set_fbigbig_flag");
	set_cmt	(0X2A04,	"4096-10\nis this 16-bit fat?",	0);
	create_insn	(0X2A04);
	set_name	(0X2A04,	"set_fbig_flag");
	set_cmt	(0X2A07,	"no, small fat",	0);
	set_cmt	(0X2A09,	"FAT16 ; fbig",	0);
	create_insn	(x=0X2A09);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_name	(0X2A0F,	"set_fbig_flag_ok");
	set_name	(0X2A12,	"boot_drv_fixed");
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_1(void) {
        auto x;
#define id x

	set_cmt	(0X2A14,	"Load DOS kernel (IBMDOS.COM)\nSYSINIT segment = 544h",	0);
	set_name	(0X2A14,	"loadit");
	create_insn	(x=0X2A19);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X2A21,	"fbigbig ; FAT32 fs flag",	0);
	create_insn	(x=0X2A21);
	op_hex		(x,	1);
	set_cmt	(0X2A29,	"si:bx = 32 bit cluster number",	0);
	set_name	(0X2A29,	"eofbigbig");
	set_cmt	(0X2A34,	"fbig ; FAT16 fs flag",	0);
	create_insn	(x=0X2A34);
	op_hex		(x,	1);
	set_name	(0X2A34,	"iseof");
	create_insn	(0X2A42);
	set_name	(0X2A42,	"eofbig");
	set_name	(0X2A45,	"iseofx");
	set_cmt	(0X2A47,	"(*) restore fbigfat flags\n(after loading DOS kernel)",	0);
	set_cmt	(0X2A4F,	"SYSNIT:_SYSINIT",	0);
	create_insn	(x=0X2A4F);
	set_cmt	(0X2A54,	"get first bds",	0);
	create_insn	(x=0X2A54);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2A54,	"remap");
	set_cmt	(0X2A59,	"[di+BDS.drivenum] ; first hard disk??",	0);
	set_cmt	(0X2A5D,	"yes, continue",	0);
	set_cmt	(0X2A5F,	"[di+BDS.link] ; get next bds, assume segment",	0);
	set_cmt	(0X2A61,	"last bds?",	0);
	set_cmt	(0X2A66,	"yes, no hard drive on system",	0);
	set_cmt	(0X2A68,	"start with logical drv num=2",	0);
	create_insn	(0X2A68);
	set_cmt	(0X2A6A,	"[di+BDS.drivelet]",	0);
	set_cmt	(0X2A6D,	"[di+BDS.link] ; ds:di--> next bds",	0);
	set_cmt	(0X2A6F,	"set num for next drive",	0);
	set_cmt	(0X2A71,	"last hard drive ?",	0);
	set_cmt	(0X2A74,	"no - assign more disk drives",	0);
	create_insn	(x=0X2A76);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2A7B,	"[di+BDS.link] ; ds:di-->bds2",	0);
	set_cmt	(0X2A7D,	"get number of floppies to remap",	0);
	set_cmt	(0X2A82,	"adjust for a: & b:",	0);
	set_cmt	(0X2A85,	"[di+BDS.link] ; set new num to next floppy",	0);
	set_cmt	(0X2A87,	"[di+BDS.drivelet]",	0);
	set_cmt	(0X2A8A,	"new number for next floppy",	0);
	set_cmt	(0X2A8C,	"count down extra floppies",	0);
	set_cmt	(0X2A90,	"boot drive",	0);
	set_cmt	(0X2A94,	"is it a: or b: ?",	0);
	set_cmt	(0X2A98,	"is it one of the other floppies?",	0);
	set_cmt	(0X2A9D,	"brif so",	0);
	set_cmt	(0X2A9F,	"bootdrv -= (dsktnum-2)",	0);
	set_cmt	(0X2AA3,	"bootdrv += (drvmax-dsktnum)",	0);
	create_insn	(0X2AA3);
	set_cmt	(0X2AAF,	"SYSINIT segment",	0);
	create_insn	(x=0X2AB4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X2AB9);
	set_name	(0X2AB9,	"getboot");
	set_cmt	(0X2ABF,	"bootbias",	0);
	set_cmt	(0X2ACA,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X2ACA);
	op_hex		(x,	0);
	set_cmt	(0X2ACE,	"[es:bootbias+1FEh]\nDave Litton magic word?",	0);
	set_cmt	(0X2AD5,	"yes",	0);
	set_name	(0X2AD7,	"erret");
	set_name	(0X2AD8,	"norm_ret");
	set_cmt	(0X2AD9,	"inputs:\n    dl is rom drive number (80h...)\n    bh is partition number (0....) \n    ds:di points to bds\noutputs:\n    carry clear -> bpb is filled in\n    carry set -> bpb is left uninitialized due to error",	0);
	create_insn	(0X2AD9);
	set_name	(0X2AD9,	"sethard");
	set_cmt	(0X2ADD,	"[di+BDS.drivelet]",	0);
	set_cmt	(0X2AE0,	"[di+BDS.drivenum]",	0);
	set_cmt	(0X2AE3,	"[di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X2AE3);
	op_hex		(x,	1);
	set_cmt	(0X2AE7,	"[di+BDS.formfactor], ffHardFile",	0);
	set_cmt	(0X2AEB,	"assume 12 bit FAT",	0);
	create_insn	(x=0X2AEB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2AF5,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter",	0);
	create_insn	(x=0X2AF5);
	op_hex		(x,	0);
	set_cmt	(0X2AFC,	"[di+BDS.heads]",	0);
	set_cmt	(0X2B00,	"error if no hard disk",	0);
	create_insn	(x=0X2B02);
	op_hex		(x,	1);
	set_cmt	(0X2B05,	"[di+BDS.secpertrack]",	0);
	set_cmt	(0X2B0C,	"restore partition number",	0);
	create_insn	(0X2B12);
	set_name	(0X2B12,	"chk_act_part");
	set_cmt	(0X2B28,	"1C2h+bootbias",	0);
	create_insn	(x=0X2B2B);
	op_hex		(x,	1);
	set_cmt	(0X2B32,	"FAT12",	0);
	set_cmt	(0X2B38,	"FAT16 CHS (<= 32MB)",	0);
	set_cmt	(0X2B3E,	"FAT32 CHS",	0);
	set_cmt	(0X2B44,	"FAT32 LBA",	0);
	set_cmt	(0X2B4A,	"FAT16 LBA",	0);
	set_cmt	(0X2B50,	"FAT16 BIG CHS (> 32MB)",	0);
	set_name	(0X2B56,	"got_good_act");
	create_insn	(x=0X2B5C);
	op_dec		(x,	1);
	set_cmt	(0X2B5F,	"202h+bootbias\nlast entry done?",	0);
	set_cmt	(0X2B65,	"1C2h+bootbias\nrestore original value of bx",	0);
	create_insn	(x=0X2B68);
	op_hex		(x,	1);
	set_name	(0X2B68,	"get_primary");
	set_cmt	(0X2B6D,	"we've already scanned\nthe ACTIVE ones",	0);
	set_cmt	(0X2B6F,	"FAT12 fs",	0);
	set_cmt	(0X2B75,	"FAT16 fs",	0);
	set_cmt	(0X2B7B,	"FAT32 CHS file system",	0);
	set_cmt	(0X2B81,	"FAT32 LBA file system",	0);
	set_cmt	(0X2B87,	"FAT16 LBA file system",	0);
	set_cmt	(0X2B8D,	"FAT16 big fs (> 32 MB)",	0);
	set_name	(0X2B93,	"got_prim");
	create_insn	(x=0X2B99);
	op_dec		(x,	1);
	set_cmt	(0X2B9C,	"202h+bootbias",	0);
	set_cmt	(0X2BA0,	"loop till we've gone through table",	0);
	create_word	(0X2BA6);
	make_array	(0X2BA6,	0X2);
	set_name	(0X2BA6,	"ep_start_sector");
	create_word	(0X2BAA);
	make_array	(0X2BAA,	0X2);
	set_name	(0X2BAA,	"ep_hidden_secs");
	create_insn	(0X2BAE);
	set_name	(0X2BAE,	"set2");
	set_cmt	(0X2BB3,	"start sector (LBA) of the partition",	0);
	set_cmt	(0X2BBE,	"zero based sector count",	0);
	set_cmt	(0X2BC1,	"start LBA + partition size in sectors",	0);
	set_cmt	(0X2BCB,	"ftoobig",	0);
	create_insn	(x=0X2BCB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_name	(0X2BD0,	"okdrive");
	set_cmt	(0X2BDC,	"ftoobig",	0);
	create_insn	(x=0X2BDC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X2BE1,	"FAT32 LBA partition ID",	0);
	set_cmt	(0X2BE7,	"FAT16 LBA partition ID",	0);
	set_cmt	(0X2BED,	"if dx > [di+BDS.secpertrack] then",	0);
	set_cmt	(0X2BF0,	"set LBA r/w flag",	0);
	set_cmt	(0X2BFA,	"if ax (cylinder number) >= 1024\n set LBA r/w flag",	0);
	set_cmt	(0X2BFF,	"fLBArw ; LBA r/w flag",	0);
	create_insn	(x=0X2BFF);
	op_hex		(x,	1);
	set_cmt	(0X2C03,	"start sector (LBA) of the partition",	0);
	set_cmt	(0X2C0B,	"+ hidden secs of the extd dos partion",	0);
	set_cmt	(0X2C15,	"[di+BDS.hiddensectors]",	0);
	set_cmt	(0X2C1D,	"[di+BDS.bdsm_hidden_trks]",	0);
	set_cmt	(0X2C20,	"[di+BDS.totalsec16]",	0);
	set_cmt	(0X2C23,	"totals sectors (size) of the partition",	0);
	create_insn	(x=0X2C23);
	op_dec		(x,	1);
	create_insn	(x=0X2C27);
	op_hex		(x,	1);
	set_cmt	(0X2C2E,	"[di+BDS.totalsecs32]",	0);
	create_insn	(x=0X2C36);
	op_dec		(x,	1);
	set_cmt	(0X2C3B,	"[di+BDS.hiddensectors+2]",	0);
	set_cmt	(0X2C3E,	"[di+BDS.hiddensectors]",	0);
	set_cmt	(0X2C43,	"[di+BDS.secpertrack]",	0);
	set_cmt	(0X2C58,	"[di+BDS.heads]",	0);
	set_cmt	(0X2C6B,	"fLBArw ; LBA read/write flag",	0);
	create_insn	(x=0X2C6B);
	op_hex		(x,	1);
	set_name	(0X2C71,	"set3_lba_read");
	create_insn	(x=0X2C73);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2C78,	"0",	0);
	set_cmt	(0X2C7C,	"[di+BDS.hiddensectors+2]",	0);
	set_cmt	(0X2C80,	"[di+BDS.hiddensectors]",	0);
	set_cmt	(0X2C84,	"buffer address",	0);
	set_cmt	(0X2C86,	"sector (read) count",	0);
	set_cmt	(0X2C8A,	"DAP size",	0);
	create_insn	(x=0X2C8A);
	op_dec		(x,	1);
	create_insn	(x=0X2C99);
	op_hex		(x,	1);
	set_cmt	(0X2C9B,	"DISK - IBM/MS Extension\nEXTENDED READ (DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X2C9B);
	op_hex		(x,	0);
	create_insn	(x=0X2C9F);
	op_dec		(x,	1);
	set_name	(0X2CA4,	"set3_err");
	create_insn	(x=0X2CA7);
	op_dec		(x,	1);
	set_cmt	(0X2CAE,	"[di+BDS.bdsm_ismini] ; check for mini disk",	0);
	create_insn	(0X2CAE);
	set_name	(0X2CAE,	"set3_chs_read");
	set_cmt	(0X2CB4,	"[di+BDS.bdsm_hidden_trks]",	0);
	set_cmt	(0X2CB7,	"move high two bits of cyl to high",	0);
	create_insn	(x=0X2CB7);
	op_hex		(x,	1);
	set_cmt	(0X2CB9,	"two bits of upper byte",	0);
	create_insn	(x=0X2CB9);
	op_hex		(x,	1);
	set_cmt	(0X2CBB,	"turn off remainder of bits",	0);
	create_insn	(x=0X2CBB);
	op_hex		(x,	1);
	set_cmt	(0X2CBE,	"move two bits to correct spot",	0);
	set_cmt	(0X2CC0,	"ch is cylinder (low 8 bits)\ncl is sector + 2 high bits of cylinder",	0);
	set_cmt	(0X2CC2,	"dh is head",	0);
	set_cmt	(0X2CC4,	"dl is drive number",	0);
	create_insn	(x=0X2CCB);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2CD1,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X2CD1);
	op_hex		(x,	0);
	create_insn	(x=0X2CD5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2CE3,	"[bx+BPB_FATSz16] ; 16 bit FAT size is 0 if it is FAT32 bs",	0);
	set_cmt	(0X2CE8,	"FAT32",	0);
	create_insn	(x=0X2CEF);
	op_dec		(x,	1);
	set_cmt	(0X2CF2,	"move offset 36 to 63\n     to offset 64 (28 bytes)",	0);
	set_cmt	(0X2CF5,	"boot sector offset 64",	0);
	set_cmt	(0X2CFE,	"is it a near jump?",	0);
	set_cmt	(0X2D02,	"yes",	0);
	set_cmt	(0X2D04,	"is it a short jump?",	0);
	set_cmt	(0X2D08,	"no",	0);
	set_cmt	(0X2D0A,	"yes, is the next one a nop?",	0);
	set_cmt	(0X2D0F,	"no",	0);
	set_cmt	(0X2D11,	" disksector+EXT_BOOT.BPB ; disksector+11",	0);
	create_insn	(x=0X2D11);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2D14,	"[bx+EBPB.MEDIADESCRIPTOR]",	0);
	create_insn	(x=0X2D14);
	op_dec		(x,	1);
	set_cmt	(0X2D18,	"mask off low nibble",	0);
	create_insn	(x=0X2D18);
	op_hex		(x,	1);
	set_cmt	(0X2D1A,	"is high nibble = 0Fh?",	0);
	set_cmt	(0X2D1E,	"[bx+EBPB.BYTESPERSECTOR]",	0);
	create_insn	(x=0X2D1E);
	op_dec		(x,	1);
	set_cmt	(0X2D23,	"invalidate non 512 byte sectors",	0);
	set_cmt	(0X2D25,	"now make sure that \nthe sectorspercluster is a power of 2",	0);
	set_cmt	(0X2D29,	"is it zero?",	0);
	set_cmt	(0X2D2B,	"yes, invalid boot record",	0);
	set_cmt	(0X2D2D,	"shift until first bit emerges",	0);
	create_insn	(x=0X2D2D);
	op_hex		(x,	1);
	set_cmt	(0X2D35,	"jump to invalid boot record\nunformatted or illegal media.",	0);
	create_insn	(0X2D38);
	set_cmt	(0X2D39,	"\nSignature found. Now check version.",	0);
	set_cmt	(0X2D3A,	"'2.' (NASM syntax)",	0);
	create_insn	(0X2D4B);
	create_insn	(0X2D4E);
	set_cmt	(0X2D51,	"'0.' (NASM syntax)",	0);
	create_insn	(x=0X2D5F);
	op_hex		(x,	1);
	set_cmt	(0X2D61,	"accept either '1' or '2'",	0);
	set_cmt	(0X2D66,	"'3.' (NASM syntax)",	0);
	create_insn	(0X2D66);
	set_cmt	(0X2D7D,	"NOTE: This check is not proper for FAT32 boot sector (standard spec)\n(after PCDOS 7.1). So, it is not existing in Windows ME IO.SYS\nErdogan Tan - 01/09/2023",	0);
	set_cmt	(0X2D7F,	"BS_BootSig (FAT32)",	0);
	create_insn	(x=0X2D7F);
	op_hex		(x,	1);
	set_cmt	(0X2D87,	"BS_BootSig (FAT16/FAT12)",	0);
	create_insn	(x=0X2D87);
	op_hex		(x,	1);
	set_cmt	(0X2D8F,	"BPB.fats",	0);
	set_cmt	(0X2D9D,	"BIOSDATA:015Dh",	0);
	create_insn	(x=0X2D9D);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2DA0,	"add di,BDS.BPB",	0);
	set_cmt	(0X2DA3,	"[BPB.totalsecs16]",	0);
	set_cmt	(0X2DAA,	"[BPB.totalsecs32]",	0);
	set_cmt	(0X2DB1,	"[BPB.totalsecs32+2]",	0);
	set_cmt	(0X2DB8,	".. empty BPB (size) fields ..\nfill boot sector's BPB fields\n          with correct values",	0);
	set_cmt	(0X2DCD,	"copy contents of the bootsector's BPB\n                     to the BDS's BPB",	0);
	create_insn	(x=0X2DCD);
	op_dec		(x,	1);
	create_insn	(x=0X2DD9);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X2DE6,	"BIOSDATA:015Dh\ndisksector+11\ndisksector+EXT_BOOT.BPB",	0);
	create_insn	(x=0X2DE6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2DE6,	"copybpb_fat");
	set_cmt	(0X2DEB,	"BPB.totalsecs16",	0);
	set_cmt	(0X2DEF,	"get totsec from boot sec",	0);
	set_cmt	(0X2DF3,	"BPB.totalsecs32",	0);
	set_cmt	(0X2DF7,	"BPB.totalsecs32+2",	0);
	set_cmt	(0X2DFB,	"get the big version",	0);
	set_cmt	(0X2DFD,	"see if it is a big zero",	0);
	set_cmt	(0X2DFF,	"screw it. it was bogus.",	0);
	set_cmt	(0X2E01,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X2E04,	"[di+BDS.totalsecs32+2]",	0);
	set_cmt	(0X2E0D,	"BPB.resectors",	0);
	set_cmt	(0X2E11,	"[di+BDS.resectors]",	0);
	set_cmt	(0X2E19,	"BPB.fatsecs",	0);
	set_cmt	(0X2E1D,	"[di+BDS.fatsecs]",	0);
	set_cmt	(0X2E25,	"FAT32 file system (BUG!)\nBPB.FATSz32",	0);
	set_cmt	(0X2E29,	"BPB.FATSz32+2 (BUG!)",	0);
	set_cmt	(0X2E2D,	"BPB.FATSz32",	0);
	set_cmt	(0X2E31,	"[di+BDS.fatsecs32]",	0);
	set_cmt	(0X2E34,	"BPB.FATSz32+2",	0);
	set_cmt	(0X2E38,	"[di+BDS.fatsecs32+2]",	0);
	set_cmt	(0X2E3B,	"BPB.BPB_ExtFlags",	0);
	set_cmt	(0X2E3F,	"[di+BDS.extflags]",	0);
	set_cmt	(0X2E42,	"BPB.FSVer",	0);
	set_cmt	(0X2E46,	"[di+BDS.fsver]",	0);
	set_cmt	(0X2E49,	"BPB.RootClus",	0);
	set_cmt	(0X2E4D,	"[di+BDS.rootdirclust]",	0);
	set_cmt	(0X2E50,	"BPB.RootClus+2",	0);
	set_cmt	(0X2E54,	"[di+BDS.rootdirclust+2]",	0);
	set_cmt	(0X2E57,	"BPB.FSInfo",	0);
	set_cmt	(0X2E5B,	"[di+BDS.fsinfo]",	0);
	set_cmt	(0X2E5E,	"BPB.FSInfo+2",	0);
	set_cmt	(0X2E62,	"[di+BDS.fsinfo+2]",	0);
	set_cmt	(0X2E65,	"BUG! Erdogan Tan - 8/8/2023\ncorrect code (would be):\n  mov cl, [cs:si+05h] ; BPB_NumFATs\nsub_fat32_size:\n  sub ax, [cs:si+19h] ; BPB_FATSz32\n  sbb dx, [cs:si+1Bh] ; BPB_FATSz32+2\n  dec cl\n  jg short sub_fat32_size\n  jmp short fat_32bit",	0);
	set_cmt	(0X2E67,	"always 2 fats ! BUG!",	0);
	create_insn	(x=0X2E67);
	op_hex		(x,	1);
	set_cmt	(0X2E69,	"sub # fat sectors",	0);
	set_cmt	(0X2E6B,	"BUG! Erdogan Tan - 8/8/2023\ncorrect code (would be):\n  mov cl, [cs:si+05h] ; BPB_NumFATs\nsub_fat_size:\n  sub ax, bx ; BPB.fatsecs\n  sbb dx, 0\n  dec cl\n  jg short sub_fat_size",	0);
	set_cmt	(0X2E6E,	"BPB.direntries",	0);
	set_cmt	(0X2E72,	"[di+BDS.direntries]",	0);
	set_cmt	(0X2E79,	"- root dir sectors",	0);
	set_cmt	(0X2E7B,	"dx:ax = # of data sectors",	0);
	set_cmt	(0X2E80,	"BPB.secperclus",	0);
	set_cmt	(0X2E84,	"[di+BDS.secperclus]",	0);
	set_cmt	(0X2E8C,	"32 bit division",	0);
	set_cmt	(0X2E8E,	"hw of cluster number",	0);
	set_cmt	(0X2E98,	"16 bit fat sectors > 0 ; FAT12 or FAT16 fs",	0);
	set_cmt	(0X2EA3,	"FAT32 cluster number limit: 0FFFFFF6h",	0);
	set_cmt	(0X2EAF,	"FAT16 cluster number limit: 0FFF6h",	0);
	set_cmt	(0X2EB4,	"fbigbig ; FAT32 fs",	0);
	create_insn	(x=0X2EB4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	create_insn	(0X2EBB);
	set_cmt	(0X2EC3,	"FAT12 cluster number limit: 0FF6h",	0);
	set_cmt	(0X2EC6,	"FAT12 fs",	0);
	set_cmt	(0X2EC8,	"fbig ; FAT16 fs",	0);
	create_insn	(x=0X2EC8);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X2ED2,	"\nMOVMEDIAIDS equ mov_media_ids - DOSBIOSEG",	0);
	create_insn	(x=0X2ED2);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X2EDF,	"ftoobig ; too big (32 bit cluster #) for FAT16",	0);
	create_insn	(x=0X2EDF);
	op_hex		(x,	1);
	set_cmt	(0X2EE5,	"still drive letter is assigned\nbut useless. to big for\ncurrent pc dos fat file system",	0);
	set_cmt	(0X2EE8,	"[di+BDS.flags+1] ; unformatted_media\nSet unformatted media flag.",	0);
	create_insn	(x=0X2EE8);
	op_hex		(x,	1);
	set_name	(0X2EE8,	"unknown");
	set_cmt	(0X2EEC,	"skip setting unformatted_media bit\n[di+BDS.totalsecs32+2]",	0);
	set_name	(0X2EEC,	"unknown3_0");
	set_cmt	(0X2EEF,	"[di+BDS.totalsecs32]",	0);
	create_insn	(x=0X2EF2);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2EF5,	"total sectors hw",	0);
	set_cmt	(0X2EFC,	"total sectors lw",	0);
	create_insn	(x=0X2F02);
	op_dec		(x,	1);
	set_cmt	(0X2F07,	"bigfat flags \n(FAT16 fbig=40h, FAT32 fbigbig=20h)",	0);
	create_insn	(0X2F07);
	create_insn	(x=0X2F0A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X2F0E,	"shift count (cl) -log base 2 of ch-\nsector per cluster (ch)",	0);
	set_cmt	(0X2F12,	"root directory entries",	0);
	set_cmt	(0X2F16,	"[di+BDS.direntries]",	0);
	set_cmt	(0X2F19,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X2F1F,	"[di+BDS.secperclus]",	0);
	set_cmt	(0X2F22,	"fbig+fbigbig ; FAT16 or FAT32",	0);
	create_insn	(x=0X2F22);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X2F29,	"12 bit fat (FAT12 fs)",	0);
	set_cmt	(0X2F32,	"bx = 1+(bpb->maxsec+BDS.secperclus-1)\n     / BDS.secperclus",	0);
	set_cmt	(0X2F33,	"bx &= ~1; (=number of clusters)",	0);
	create_insn	(x=0X2F33);
	op_hex		(x,	1);
	create_insn	(x=0X2F38);
	op_hex		(x,	1);
	set_cmt	(0X2F3A,	"number of FAT bytes",	0);
	set_cmt	(0X2F3C,	"bx += 511 + bx/2",	0);
	create_insn	(x=0X2F3C);
	op_dec		(x,	1);
	set_cmt	(0X2F40,	"bh >>= 1; (=bx/512)",	0);
	create_insn	(x=0X2F40);
	op_hex		(x,	1);
	set_cmt	(0X2F42,	"[di+BDS.fatsecs]\nsave number of fat sectors",	0);
	set_cmt	(0X2F47,	"16 (2^4) directory entries per sector",	0);
	create_insn	(0X2F47);
	set_cmt	(0X2F49,	"save total sectors (high)",	0);
	set_cmt	(0X2F4A,	"[di+BDS.direntries]",	0);
	set_cmt	(0X2F4D,	"root dir sectors = BDS.direntries / 16;",	0);
	set_cmt	(0X2F51,	"restore total sectors (high)",	0);
	set_cmt	(0X2F52,	"dx:ax = total sectors - root dir sectors",	0);
	set_cmt	(0X2F55,	"- reserved sectors (1 for FAT16 fs)",	0);
	set_cmt	(0X2F58,	"dx:ax = t - r - d\ntotal secs - reserved secs - root dir secs",	0);
	set_cmt	(0X2F5D,	"[di+BDS.secperclus]\nbx = 256 * BDS.secperclus + 2\n\n; 29/12/2018 - Erdogan Tan (Retro DOS v4.0)\n; 27/09/2022\n; (Microsoft FAT32 File System Specification,\n; December 2000, Page 21)\n; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)\n; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs\n; 8/8/2023 (Retro DOS v5.0)\n; If(FATType == FAT32)\n;   TmpVal2 = TmpVal2 / 2;\n; FATsz = (TmpVal1+(TmpVal2-1))/TmpVal2\n; 8/8/2023 (Retro DOS v5.0)\n; If(FATType == FAT32) {\n;   BPB_FATSz16 = 0;\n;   BPB_FATSz32 = FATSz;\n;} else {\n;   BPB_FATSz16 = LOWORD(FATSz);\n;/* there is no BPB_FATSz32 in a FAT16 BPB */\n;}\n\ndx:ax = TmpVal1, bx = TmpVal2",	0);
	set_cmt	(0X2F62,	"dx:ax = TmpVal1+TmpVal2",	0);
	set_cmt	(0X2F68,	"dx:ax = TmpVal1+TmpVal2-1",	0);
	set_cmt	(0X2F6B,	"fbigbig (FAT32) flag",	0);
	create_insn	(x=0X2F6B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X2F72,	"TmpVal2 = TmpVal2 / 2\ndx:ax = TmpVal1+(2*TmpVal2)-1",	0);
	create_insn	(x=0X2F72);
	op_hex		(x,	1);
	set_cmt	(0X2F74,	"reserved sectors = 32 (for FAT32 fs) /// 1+31 = 32",	0);
	create_insn	(x=0X2F74);
	op_dec		(x,	1);
	set_cmt	(0X2F7C,	"dx:ax = TmpVal1+(2*TmpVal2)-TmpVal2-1\n      = TmpVal1+(TmpVal2-1)",	0);
	set_cmt	(0X2F7F,	"save lw of dividend",	0);
	set_cmt	(0X2F80,	"divide hw of dx:ax at first (as 1st stage)",	0);
	set_cmt	(0X2F84,	"32 bit division, dx:ax/bx\nremainder in dx is hw of 2nd stage dividend",	0);
	set_cmt	(0X2F86,	"hw of quotient",	0);
	set_cmt	(0X2F88,	"restore lw of dividend (of 1st stage)",	0);
	set_cmt	(0X2F8B,	"[di+BDS.fatsecs] ; number of fat sectors\nlw of quotient",	0);
	create_insn	(x=0X2F8E);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X2F92,	"[di+BDS.fatsiz] ; fat size flag",	0);
	set_cmt	(0X2F95,	"fbigbig (FAT32) flag",	0);
	create_insn	(x=0X2F95);
	op_hex		(x,	1);
	set_cmt	(0X2F98,	"not FAT32",	0);
	set_cmt	(0X2F9A,	"[di+BDS.fatsecs32]",	0);
	set_cmt	(0X2F9D,	"[di+BDS.fatsecs32+2]",	0);
	set_cmt	(0X2FA0,	"[di+BDS.fatsecs] = 0 \nclear 16 bit FAT size field",	0);
	set_cmt	(0X2FA5,	"[di+BDS.resectors]\nset reserved sectors to 32 (FAT32 de facto)",	0);
	create_insn	(x=0X2FA5);
	op_dec		(x,	1);
	set_cmt	(0X2FAA,	"set the default filesys_id, \n    volume label, serial number",	0);
	create_insn	(x=0X2FAF);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X2FB7,	"[di+BDS.totalsecs32+2]",	0);
	set_name	(0X2FB7,	"massage_bpb");
	set_cmt	(0X2FBA,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X2FC2,	"[di+BDS.hiddensecs+2]",	0);
	set_cmt	(0X2FC8,	"[di+BDS.hiddensecs]",	0);
	set_cmt	(0X2FCD,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X2FD0,	"[di+BDS.totalsecs16]",	0);
	create_insn	(x=0X2FD8);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X2FD8,	"goodret");
	set_cmt	(0X2FDC,	"[di+BDS.fatsiz]\nset size of fat on media",	0);
	set_name	(0X2FE0,	"ret_hard_err");
	set_cmt	(0X2FE5,	"fdisk of pc dos 3.3 and below, os2 1.0 has a bug.\nthe maximum number of sector that can be handled by pc dos 3.3 \nibmbio should be 0ffffh. instead, sometimes fdisk use 10000h to\ncalculate the maximum number. so, we are going to check that if\nBPB_TOTALSECTORS + hidden sector = 10000h then subtract 1 from\nBPB_TOTALSECTORS.",	0);
	create_insn	(0X2FE5);
	set_name	(0X2FE5,	"cover_fdisk_bug");
	set_cmt	(0X2FE8,	"BPB_FATSz16",	0);
	set_cmt	(0X2FEE,	"FAT32 boot sector",	0);
	set_cmt	(0X2FF0,	"\n[disksector+EXT_BOOT.SIG], EXT_BOOT_SIGNATURE",	0);
	set_cmt	(0X2FF6,	"if extended bpb, then >= pc dos 4.00",	0);
	set_cmt	(0X2FF8,	"'10' ; os2 1.0 = ibm 10.0",	0);
	set_cmt	(0X3007,	"15Dh\ndisksector+EXT_BOOT.BPB",	0);
	create_insn	(x=0X3007);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X300A,	"[cs:si+EBPB.TOTALSECTORS]",	0);
	set_cmt	(0X300F,	"just to make sure.",	0);
	set_cmt	(0X3015,	"[cs:si+EBPB.HIDDENSECTORS]",	0);
	set_cmt	(0X301B,	"\nif carry set and ax=0",	0);
	set_cmt	(0X301D,	"then decrease BPB_TOTALSECTORS by 1",	0);
	set_cmt	(0X3021,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X3025,	"[di+BDS.totalsecs32+2]",	0);
	create_word	(0X302D);
	set_name	(0X302D,	"word2");
	create_word	(0X302F);
	set_name	(0X302F,	"word3");
	create_word	(0X3031);
	set_name	(0X3031,	"word512");
	set_cmt	(0X3033,	"setdrvparms sets up the recommended bpb in each bds\nin the system based on the form factor.\nit is assumed that the bpbs for the various form factors\nare present in the bpbtable. for hard files, \nthe recommended bpb is the same as the bpb on the drive.",	0);
	create_insn	(0X3033);
	set_name	(0X3033,	"setdrvparms");
	set_cmt	(0X3035,	"get first bds in list",	0);
	create_insn	(x=0X3035);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X303B,	"[es:di+BDS.formfactor]",	0);
	set_cmt	(0X303F,	"ffHardFile",	0);
	set_cmt	(0X3046,	"[es:di+BDS.totalsecs16]",	0);
	set_cmt	(0X304E,	"[es:di+BDS.totalsecs32+2]",	0);
	set_cmt	(0X3052,	"[es:di+BDS.totalsecs32]",	0);
	set_cmt	(0X3058,	"[es:di+BDS.heads]",	0);
	set_cmt	(0X305C,	"[es:di+BDS.secpertrack]\nassume sectors per cyl. < 64k.",	0);
	set_cmt	(0X3060,	"cx has # sectors per cylinder",	0);
	set_cmt	(0X3063,	"dx:ax = total sectors",	0);
	set_cmt	(0X3070,	"div #sec by sec/cyl to get # cyl.",	0);
	set_cmt	(0X3076,	"round up",	0);
	set_cmt	(0X3077,	"[es:di+BDS.cylinders]",	0);
	set_cmt	(0X307D,	"[di+BDS.bytespersec]\nds:si -> bpb for hard file",	0);
	create_insn	(0X3082);
	set_cmt	(0X3083,	"if fake floppy drive variable is set \nthen we don't have to handle this bds.\nwe can just go and deal with the next bds\nat label go_to_next_bds.",	0);
	set_cmt	(0X308C,	"ffother\nspecial case \"other\" type of medium",	0);
	set_cmt	(0X3093,	"[di+BDS.cylinders]",	0);
	set_cmt	(0X3096,	"[di+BDS.rheads]",	0);
	set_cmt	(0X3099,	"[di+BDS.rsecpertrack]",	0);
	set_cmt	(0X309C,	"[di+BDS.rtotalsecs16]\nhave the total number of sectors",	0);
	set_cmt	(0X30A2,	"4096-10",	0);
	create_insn	(x=0X30A7);
	op_hex		(x,	1);
	create_insn	(x=0X30A9);
	op_hex		(x,	1);
	set_cmt	(0X30AD,	"is it a small disk ?",	0);
	create_insn	(0X30AD);
	set_cmt	(0X30B0,	"yes, 224 root entries is enuf",	0);
	set_cmt	(0X30B2,	"[di+BDS.rdirentries]",	0);
	create_insn	(x=0X30B2);
	op_dec		(x,	1);
	set_cmt	(0X30B7,	"[di+BDS.rsecperclus]",	0);
	set_cmt	(0X30BA,	"* 3",	0);
	set_cmt	(0X30BF,	"/ 2",	0);
	set_cmt	(0X30C6,	"/ 512",	0);
	set_cmt	(0X30CB,	"+ 1",	0);
	set_cmt	(0X30CC,	"[di+BDS.rfatsecs]",	0);
	set_cmt	(0X30D1,	"bx is word index into table of bpbs",	0);
	create_insn	(x=0X30D1);
	op_hex		(x,	1);
	create_insn	(x=0X30D3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X30D6,	"get address of bpb",	0);
	set_cmt	(0X30D8,	"[di+BDS.R_BPB]\nes:di -> recbpb",	0);
	set_cmt	(0X30DB,	"bpbx.size",	0);
	create_insn	(x=0X30DB);
	op_dec		(x,	1);
	set_cmt	(0X30DE,	"move (size bpbx) bytes",	0);
	set_cmt	(0X30E1,	"restore pointer to bds",	0);
	set_cmt	(0X30E2,	"[es:di+BDS.link]",	0);
	set_cmt	(0X30E5,	"-1",	0);
	create_insn	(0X30ED);
	create_insn	(0X30EE);
	set_name	(0X30EE,	"print_init");
	set_cmt	(0X30F3,	"PRINTER - INITIALIZE\nDX = printer port (0-3)\nReturn: AH = status",	0);
	create_insn	(x=0X30F3);
	op_hex		(x,	0);
	create_insn	(0X30F6);
	set_name	(0X30F6,	"aux_init");
	set_cmt	(0X30F9,	"RSINIT ; 0A3h\n2400,n,1,8 (msequ.inc)",	0);
	set_cmt	(0X30FD,	"SERIAL I/O - INITIALIZE USART\nAL = initializing parameters, DX = port number (0-3)\nReturn: AH = RS-232 status code bits, AL = modem status bits",	0);
	create_insn	(x=0X30FD);
	op_hex		(x,	0);
	set_cmt	(0X3100,	"mini disk initialization routine\nget number of hardfiles",	0);
	create_insn	(0X3100);
	set_name	(0X3100,	"domini");
	set_cmt	(0X3107,	"no hard file? then exit.",	0);
	set_cmt	(0X3109,	"start with hardfile 80h",	0);
	set_cmt	(0X3124,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter",	0);
	create_insn	(x=0X3124);
	op_hex		(x,	0);
	set_cmt	(0X3128,	"<= 255",	0);
	set_cmt	(0X312A,	"(0FFh -> 100h)",	0);
	set_cmt	(0X312B,	"# of heads",	0);
	create_insn	(x=0X3130);
	op_hex		(x,	1);
	set_cmt	(0X3133,	"# of sectors/track",	0);
	set_cmt	(0X313B,	"read master boot record into\ninitbootsegment:bootbias",	0);
	set_cmt	(0X3145,	"next hard file",	0);
	set_cmt	(0X314C,	"tries to find every extended partition on a disk\nbx -> file system id",	0);
	create_insn	(0X314C);
	set_name	(0X314C,	"find_mini_partition");
	create_insn	(x=0X3150);
	op_dec		(x,	1);
	create_insn	(x=0X3156);
	op_dec		(x,	1);
	set_cmt	(0X315B,	"64 logical disk partitions (64 EBRs)\n(64*4 = 256 pte's, 256*16 = 4096, + 26 = 4122)",	0);
	create_insn	(x=0X315B);
	op_dec		(x,	1);
	set_cmt	(0X3163,	"Extended DOS CHS",	0);
	set_cmt	(0X3169,	"Extended DOS LBA",	0);
	create_insn	(x=0X316F);
	op_dec		(x,	1);
	set_cmt	(0X3172,	"202h+bootbias",	0);
	set_cmt	(0X3178,	"extended partition not found",	0);
	set_cmt	(0X317B,	"check for drvmax already 26",	0);
	create_insn	(0X317B);
	set_cmt	(0X317E,	"done if too many",	0);
	set_cmt	(0X3180,	"get next free bds",	0);
	set_cmt	(0X3184,	"[di+BDS.bdsm_ismini]",	0);
	set_cmt	(0X3189,	"[di+BDS.flags],fNon_Removable",	0);
	create_insn	(x=0X3189);
	op_hex		(x,	1);
	set_cmt	(0X318D,	"[di+BDS.formfactor],ffHardFile",	0);
	set_cmt	(0X3191,	"assume 12 bit fat.",	0);
	set_cmt	(0X3199,	"[di+BDS.heads]",	0);
	set_cmt	(0X319F,	"[di+BDS.secpertrack]",	0);
	set_cmt	(0X31A5,	"[di+BDS.drivenum] ; set physical number",	0);
	set_cmt	(0X31AB,	"[di+BDS.drivelet] ; set logical number",	0);
	create_insn	(x=0X31AE);
	op_dec		(x,	0);
	set_cmt	(0X31B5,	"minimum 64 sectors",	0);
	create_insn	(x=0X31B5);
	op_hex		(x,	0);
	op_dec		(x,	1);
	set_cmt	(0X31BC,	"let bx point to the start of the entry",	0);
	set_cmt	(0X31BF,	"cylinder",	0);
	set_cmt	(0X31C3,	"get higher bits of cyl",	0);
	create_insn	(x=0X31C3);
	op_hex		(x,	1);
	create_insn	(x=0X31C6);
	op_hex		(x,	1);
	create_insn	(x=0X31C8);
	op_hex		(x,	1);
	set_cmt	(0X31CA,	"cyl byte",	0);
	set_cmt	(0X31CE,	"[di+BDS.bdsm_hidden_trks] ; set hidden trks",	0);
	set_cmt	(0X31D2,	"partition size, lw",	0);
	create_insn	(x=0X31D2);
	op_hex		(x,	1);
	set_cmt	(0X31D6,	"partition size, hw",	0);
	create_insn	(x=0X31D6);
	op_dec		(x,	1);
	set_cmt	(0X31FB,	"\nconvert start sector address to CHS",	0);
	set_cmt	(0X31FE,	"[di+BDS.secpertrack]",	0);
	set_cmt	(0X3208,	"[di+BDS.heads]",	0);
	set_cmt	(0X3218,	"cylinder number < 1024, CHS read is proper",	0);
	create_insn	(x=0X3218);
	op_dec		(x,	1);
	set_cmt	(0X321D,	"set fLBArw flag ; LBA read/write ok/ready",	0);
	create_insn	(x=0X321D);
	op_hex		(x,	1);
	set_cmt	(0X3227,	"push bp\nmov bp, sp ; (*)",	0);
	set_cmt	(0X3229,	"0",	0);
	set_cmt	(0X322A,	"0",	0);
	set_cmt	(0X3233,	"bootbias (buffer offset)",	0);
	set_cmt	(0X3236,	"buffer segment",	0);
	set_cmt	(0X323B,	"read count",	0);
	set_cmt	(0X323C,	"DAP size = 16",	0);
	set_cmt	(0X3244,	"ds:si = Disk Address Packet",	0);
	set_cmt	(0X3246,	"LBA read",	0);
	create_insn	(x=0X3246);
	op_hex		(x,	1);
	set_cmt	(0X3248,	"DISK - IBM/MS Extension\nEXTENDED READ (DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X3248);
	op_hex		(x,	0);
	set_cmt	(0X324A,	"BUG! Erdogan Tan - 08/08/2023",	0);
	create_insn	(x=0X324B);
	op_dec		(x,	1);
	set_cmt	(0X324E,	"BUG!\nmov sp, bp ; (*)\npop bp",	0);
	set_cmt	(0X3253,	"cylinder,cylinder/sector",	0);
	create_insn	(0X3253);
	set_cmt	(0X3257,	"head",	0);
	create_insn	(x=0X325B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X325F,	"bootbias",	0);
	set_cmt	(0X3265,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X3265);
	op_hex		(x,	0);
	set_cmt	(0X3269,	"1C2h+bootbias",	0);
	set_cmt	(0X326C,	"03C2h+03Ch = 3FEh",	0);
	set_cmt	(0X3272,	"not a valid boot sector !",	0);
	set_cmt	(0X3275,	"install a mini disk.\nbx value saved.",	0);
	set_cmt	(0X327B,	"-- install the bdsm into table",	0);
	create_insn	(0X3281);
	create_insn	(0X3282);
	set_name	(0X3282,	"setmini");
	set_cmt	(0X3286,	"FAT12 partition",	0);
	set_cmt	(0X328C,	"FAT16 (CHS) partition",	0);
	set_cmt	(0X3292,	"FAT16 Big (CHS) partition",	0);
	set_cmt	(0X3298,	"FAT32 (CHS) partition",	0);
	set_cmt	(0X329E,	"FAT32 (LBA) partition",	0);
	set_cmt	(0X32A4,	"FAT16 (LBA) partition",	0);
	create_insn	(x=0X32AA);
	op_dec		(x,	1);
	set_cmt	(0X32AD,	"202h+bootbias",	0);
	set_cmt	(0X32B9,	"branch into middle of sethard",	0);
	create_insn	(0X32B9);
	set_cmt	(0X32BC,	"checks for drvmax < 26",	0);
	create_insn	(x=0X32BC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_name	(0X32BC,	"dmax_check");
	set_cmt	(0X32C1,	"returns with carry if okay",	0);
	set_cmt	(0X32C4,	"SYSINIT segment",	0);
	create_insn	(x=0X32C9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X32D1,	"link next bds (at ds:di) into the chain.\nassume that the chain is entirely within ds == datagrp.\nalso update drvmax, dskdrv_table, and end_of_bdss.",	0);
	create_insn	(0X32D1);
	set_name	(0X32D1,	"xinstall_bds");
	set_cmt	(0X32D3,	"get first bds",	0);
	create_insn	(x=0X32D3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X32D7,	"is this the last one?",	0);
	set_cmt	(0X32DC,	"[si+BDS.link] ; chain through list",	0);
	set_cmt	(0X32E0,	"[si+BDS.link]",	0);
	create_insn	(0X32E0);
	set_cmt	(0X32E2,	"[si+BDS.link+2]",	0);
	set_cmt	(0X32E5,	"-1 ; make sure it is a null ptr.",	0);
	set_cmt	(0X32E9,	"might as well plug segment",	0);
	set_cmt	(0X32EC,	"[di+BDS.BPB]",	0);
	create_insn	(x=0X32EF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X32F5);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X32FA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X32FE,	"BDS.size = 150",	0);
	create_insn	(x=0X32FE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	create_insn	(0X3307);
	set_name	(0X3307,	"cmos_clock_read");
	set_cmt	(0X3313,	"CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: CH = hours in BCD\nCL = minutes in BCD\nDH = seconds in BCD",	0);
	create_insn	(x=0X3313);
	op_hex		(x,	0);
	set_cmt	(0X331F,	"read again after a slight delay, in case clock",	0);
	set_cmt	(0X3322,	"was at zero setting.",	0);
	set_cmt	(0X3324,	"only perform delay once.",	0);
	set_cmt	(0X3325,	"16384",	0);
	set_cmt	(0X332C,	"set the flag for cmos clock",	0);
	create_insn	(0X332C);
	set_cmt	(0X3332,	"reset cmos clock rate that may be\npossibly destroyed by cp dos and\npost routine did not restore that.",	0);
	set_cmt	(0X3336,	"read real-time clock for date",	0);
	set_cmt	(0X333A,	"set system date",	0);
	create_insn	(x=0X333A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3345,	"check and reset rtc rate bits\n\nthe following code is written by jack gulley in engineering group.\ncp dos (CP/DOS, OS/2) is changing cmos clock rate for its own purposes\nand if the use cold boot the system to use pc dos while running cp dos,\nthe cmos clock rate are still slow which slow down disk operations\nof pc dos which uses cmos clock. pc dos is put this code in msinit\nto fix this problem at the request of cp dos.",	0);
	create_insn	(0X3345);
	set_name	(0X3345,	"cmosck");
	set_cmt	(0X334C,	"Exit if not an AT model",	0);
	set_cmt	(0X334E,	"Is it 06 for the industral AT ?",	0);
	set_cmt	(0X3354,	"Go reset CMOS periodic rate if 06",	0);
	set_cmt	(0X3356,	"Is it 00, 01, 02, or 03 ?",	0);
	set_cmt	(0X335C,	"EXIT if problem fixed by POST\nAlso,Secondary_model_byte = 0\nwhen AH=0C0h, int 15h failed.\nRESET THE CMOS PERIODIC RATE\nModel=FC submodel=00,01,02,03 or 06",	0);
	set_cmt	(0X335E,	"cmos_reg_a|nmi\nNMI disabled on return",	0);
	set_cmt	(0X3360,	"00100110b\nSet divider & rate selection",	0);
	create_insn	(x=0X3360);
	op_hex		(x,	1);
	set_cmt	(0X3365,	"cmos_reg_b|nmi\nNMI disabled on return",	0);
	set_cmt	(0X336A,	"00000111b\nclear SET,PIE,AIE,UIE,SQWE",	0);
	create_insn	(x=0X336A);
	op_hex		(x,	1);
	set_cmt	(0X336E,	"cmos_reg_b\nNMI enabled on return",	0);
	set_cmt	(0X3375,	"read location (al) into (al)\nbit 7 = 0 for nmi enabled and 1 for nmi disabled on exit",	0);
	create_insn	(0X3375);
	set_name	(0X3375,	"cmos_read");
	create_insn	(x=0X3379);
	op_hex		(x,	1);
	set_cmt	(0X337B,	"CMOS Memory/RTC Index Register:\nRTC Seconds",	0);
	create_insn	(x=0X337B);
	op_hex		(x,	0);
	set_cmt	(0X337E,	"CMOS Memory/RTC Data Register",	0);
	create_insn	(x=0X337E);
	op_hex		(x,	1);
	create_insn	(x=0X3383);
	op_hex		(x,	1);
	create_insn	(x=0X3385);
	op_hex		(x,	1);
	set_cmt	(0X3387,	"CMOS Memory/RTC Index Register:\nRTC Seconds",	0);
	create_insn	(x=0X3387);
	op_hex		(x,	0);
	set_cmt	(0X338A,	"CMOS Memory/RTC Data Register",	0);
	create_insn	(x=0X338A);
	op_hex		(x,	1);
	set_cmt	(0X3394,	"popf for level b- parts\nreturn far and restore flags",	0);
	create_insn	(0X3394);
	set_name	(0X3394,	"cmos_popf");
	set_cmt	(0X3395,	"write (ah) to location (al)\nbit 7 = 0 for nmi enabled and 1 for nmi disabled on exit",	0);
	create_insn	(0X3395);
	set_name	(0X3395,	"cmos_write");
	create_insn	(x=0X3399);
	op_hex		(x,	1);
	set_cmt	(0X339B,	"CMOS Memory/RTC Index Register:\nRTC Seconds",	0);
	create_insn	(x=0X339B);
	op_hex		(x,	0);
	set_cmt	(0X33A0,	"CMOS Memory/RTC Data Register",	0);
	create_insn	(x=0X33A0);
	op_hex		(x,	0);
	create_insn	(x=0X33A3);
	op_hex		(x,	1);
	create_insn	(x=0X33A5);
	op_hex		(x,	1);
	set_cmt	(0X33A7,	"CMOS Memory/RTC Index Register:\nRTC Seconds",	0);
	create_insn	(x=0X33A7);
	op_hex		(x,	0);
	set_cmt	(0X33AA,	"CMOS Memory/RTC Data Register",	0);
	create_insn	(x=0X33AA);
	op_hex		(x,	1);
	set_cmt	(0X33AD,	"*place code segment in stack and",	0);
	set_cmt	(0X33AE,	"*handle popf for b- level 80286",	0);
	create_word	(0X33B2);
	set_name	(0X33B2,	"ClusterH");
	set_cmt	(0X33B4,	"1*\nsi:bx = (32 bit) cluster to read\ncx = sectors per cluster\nes:di = load location",	0);
	create_insn	(0X33B4);
	set_name	(0X33B4,	"getclus");
	set_cmt	(0X33B5,	"2*",	0);
	set_cmt	(0X33BD,	"high word of cluster number",	0);
	set_cmt	(0X33D9,	"convert to logical sector\ndx:ax = matching logical sector number\nstarting from the data sector",	0);
	set_cmt	(0X33E3,	"\ndx:ax = first logical sector to read",	0);
	set_cmt	(0X33E8,	"3*",	0);
	set_cmt	(0X33E9,	"4*",	0);
	set_cmt	(0X33EA,	"5*",	0);
	set_cmt	(0X33EB,	"6*",	0);
	set_cmt	(0X33F2,	"fbigbig\nFAT32 ?",	0);
	create_insn	(x=0X33F2);
	op_hex		(x,	1);
	set_cmt	(0X33F8,	"no",	0);
	set_cmt	(0X33FA,	"yes\n7*",	0);
	set_name	(0X33FA,	"unpack32");
	set_cmt	(0X3405,	"dx:si = 4*(si:bx)",	0);
	set_cmt	(0X340A,	"byte 16-31 of the FAT32 cluster number",	0);
	set_cmt	(0X340D,	"byte 0-15 of the FAT32 cluster number",	0);
	set_cmt	(0X340F,	"7*",	0);
	set_cmt	(0X3412,	"next cluster",	0);
	create_insn	(0X3412);
	set_cmt	(0X3414,	"fbig\nFAT16 ?",	0);
	create_insn	(x=0X3414);
	op_hex		(x,	1);
	set_cmt	(0X341A,	"yes",	0);
	create_insn	(x=0X341C);
	op_hex		(x,	1);
	set_name	(0X341C,	"unpack12");
	set_cmt	(0X341E,	"12 bit fat. si=si/2\nsi = clus + clus/2\n(si = byte offset of the cluster in the FAT)",	0);
	set_cmt	(0X3427,	"save cluster number into ax",	0);
	set_cmt	(0X3429,	"if not a splitted fat, check even-odd",	0);
	set_cmt	(0X342B,	"(not needed!) Erdogan Tan - 2023",	0);
	set_cmt	(0X342D,	"splitted fat",	0);
	set_cmt	(0X3431,	"(next byte)",	0);
	set_cmt	(0X3439,	"mov ah,[0]",	0);
	set_cmt	(0X3440,	"mov al,[cs:temp_cluster]",	0);
	set_cmt	(0X3444,	"restore old fat entry value",	0);
	set_cmt	(0X3445,	"6*",	0);
	set_cmt	(0X3446,	"was it even or odd?",	0);
	create_insn	(x=0X3446);
	op_hex		(x,	1);
	set_cmt	(0X3448,	"it was even",	0);
	set_cmt	(0X344A,	"odd. massage fat value and keep\nthe highest 12 bits.",	0);
	create_insn	(x=0X344A);
	op_hex		(x,	1);
	create_insn	(x=0X344C);
	op_hex		(x,	1);
	create_insn	(x=0X344E);
	op_hex		(x,	1);
	create_insn	(x=0X3450);
	op_hex		(x,	1);
	set_cmt	(0X3452,	"now bx = new fat entry",	0);
	set_cmt	(0X3454,	"keep low 12 bits",	0);
	create_insn	(x=0X3454);
	op_hex		(x,	1);
	create_insn	(0X345A);
	set_cmt	(0X345B,	"extend to 32 bit offset",	0);
	set_cmt	(0X345D,	"cluster number * 2",	0);
	create_insn	(x=0X345D);
	op_hex		(x,	1);
	set_cmt	(0X3466,	"bx = new fat entry",	0);
	set_cmt	(0X3468,	"high word of cluster number = 0\n(FAT12 or FAT16)",	0);
	set_cmt	(0X346A,	"6* - cluster number lw",	0);
	set_cmt	(0X346B,	"5* - cluster number hw",	0);
	set_cmt	(0X3470,	"previous - current (or current - new)",	0);
	set_cmt	(0X3477,	"one apart? (current = previous+1)",	0);
	create_insn	(x=0X3477);
	toggle_sign		(x,	1);
	op_dec		(x,	1);
	set_cmt	(0X347F,	"0FFFFh ; is [ClusterH]:ax = -1 ?",	0);
	create_insn	(x=0X347F);
	toggle_sign		(x,	1);
	op_dec		(x,	1);
	set_cmt	(0X3482,	"4* - low word of first logical sector",	0);
	set_cmt	(0X3483,	"3*",	0);
	set_cmt	(0X3486,	"consequental cluster read, +1 cluster sectors\n(cx = sectors per cluster)",	0);
	create_insn	(0X348E);
	set_cmt	(0X3490,	"sector to read (high)",	0);
	set_cmt	(0X3491,	"sector to read (low)",	0);
	set_cmt	(0X3492,	"get drive and fat spec",	0);
	set_cmt	(0X3496,	"dma and segment (64K boundary) overrun precaution \n(sector count will be decreased if it is required)",	0);
	set_cmt	(0X3498,	"cx = 65535 - cx",	0);
	set_cmt	(0X349A,	"cx = cx/2",	0);
	create_insn	(x=0X349A);
	op_hex		(x,	1);
	set_cmt	(0X349E,	"cx = cx/256",	0);
	set_cmt	(0X34A0,	"if sector read count > cx, decrease it to cx",	0);
	set_cmt	(0X34AC,	"sector to read for diskrd (low)",	0);
	set_cmt	(0X34AD,	"sector to read for diskrd (high)",	0);
	set_cmt	(0X34B6,	"simulate far call",	0);
	set_cmt	(0X34B7,	"BIOSCODE:0A2Bh ; 364h:0A2Bh",	0);
	create_insn	(x=0X34B7);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X34BE,	"sector count",	0);
	set_cmt	(0X34C1,	"2* - load location (es:di)",	0);
	set_cmt	(0X34C4,	"ax = ax * 512 ; byte count",	0);
	create_insn	(x=0X34C4);
	op_hex		(x,	1);
	set_cmt	(0X34C6,	"update load location",	0);
	set_cmt	(0X34C8,	"1* - restore sectors/cluster",	0);
	set_cmt	(0X34CA,	"dx:si = offset value (starting from fat entry 0)\n        of fat entry to find",	0);
	create_insn	(0X34CA);
	set_name	(0X34CA,	"get_fat_sector");
	set_cmt	(0X34D2,	"512",	0);
	set_cmt	(0X34D9,	"ax = sector number, dx = offset",	0);
	set_cmt	(0X34E0,	"get drive # and FAT id",	0);
	set_cmt	(0X34E4,	"BIOSCODE:05AEh",	0);
	create_insn	(x=0X34E4);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X34E7,	"simulate far call",	0);
	set_cmt	(0X34E8,	"get bds for drive",	0);
	set_cmt	(0X34EB,	"(sector number -without reserved and hidden sectors-)",	0);
	set_cmt	(0X34EC,	"[es:di+BDS.resectors]\nadd #reserved_sectors",	0);
	set_cmt	(0X34F8,	"don't need to read it again",	0);
	set_cmt	(0X34FA,	"sector number\n(in the partition, without hidden sectors)",	0);
	set_cmt	(0X34FF,	"prepare to read the fat sector\nstart_sec_h is always 0 for fat sector",	0);
	set_cmt	(0X3508,	"1 sector read",	0);
	set_cmt	(0X3511,	"es:di -> fatloc segment:0",	0);
	set_cmt	(0X3516,	"simulate far call",	0);
	set_cmt	(0X3517,	"BIOSCODE:0A2Bh ; 364h:0A2Bh",	0);
	create_insn	(x=0X3517);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X351F,	"512",	0);
	set_cmt	(0X3524,	"511",	0);
	set_cmt	(0X3525,	"if offset points to the last byte of this sector,\nthen splitted entry.",	0);
	set_cmt	(0X3527,	"offset value from fatloc segment",	0);
	create_byte	(0X3530);
	make_array	(0X3530,	0X30);
	set_name	(0X3530,	"BCode_start");
	set_cmt	(0X3560,	"BIOSDATA segment",	0);
	create_word	(0X3560);
	set_name	(0X3560,	"Bios_Data_Word");
	create_insn	(0X3562);
	set_name	(0X3562,	"_seg_reinit");
	set_cmt	(0X3567,	"(offset cdev+2)",	0);
	create_insn	(x=0X3567);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X356A,	"(it was 4 in MSDOS 6.21 IO.SYS)\n('bcode_i2f: dw i2f_handler, IOSYSCODESEG' is removed)",	0);
	set_cmt	(0X356D,	"ax = new code (BIOSCODE) segment value",	0);
	set_name	(0X356D,	"_seg_reinit_1");
	set_cmt	(0X3572,	"(direct jump to i2f_handler \n from BIOSDATA:bios_i2f)\n(instead of 'bcode_i2f: dw i2f_handler, IOSYSCODESEG'\n in MSDOS 6.21 IO.SYS)",	0);
	create_insn	(x=0X3572);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X3577);
	set_name	(0X3577,	"chardev_entry");
	set_cmt	(0X3582,	"get return address (dispatch table)",	0);
	create_insn	(x=0X3582);
	op_dec		(x,	1);
	set_cmt	(0X3585,	"BIOSDATA segment",	0);
	set_cmt	(0X358A,	"get the device number if present\nsi points to the device dispatch table",	0);
	create_insn	(x=0X358E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3591);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3595,	"get pointer to i/o packet",	0);
	create_insn	(x=0X3595);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3599,	"[es:bx+unit] ; al = unit code",	0);
	create_insn	(x=0X3599);
	op_dec		(x,	1);
	set_cmt	(0X359D,	"[es:bx+media] ; ah = media descrip",	0);
	create_insn	(x=0X359D);
	op_dec		(x,	1);
	set_cmt	(0X35A1,	"[es:bx+count] ; cx = count",	0);
	create_insn	(x=0X35A1);
	op_dec		(x,	1);
	set_cmt	(0X35A5,	"[es:bx+start] ; dx = start sector",	0);
	create_insn	(x=0X35A5);
	op_dec		(x,	1);
	set_cmt	(0X35A9,	"BIOSCODE:579h",	0);
	create_insn	(x=0X35A9);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	create_insn	(x=0X35AF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X35BA,	"[es:bx+start_h]\n32 bit dsk req",	0);
	create_insn	(x=0X35BA);
	op_dec		(x,	1);
	set_cmt	(0X35BE,	"start_sec_h = packet.start_h",	0);
	create_insn	(x=0X35BE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X35C2,	"[es:bx+start_l]\ndx = packet.start_l",	0);
	create_insn	(x=0X35C2);
	op_dec		(x,	1);
	set_name	(0X35C6,	"no_sector32_mapping");
	set_cmt	(0X35C7,	"[es:bx+cmd]",	0);
	create_insn	(x=0X35D1);
	op_hex		(x,	1);
	set_cmt	(0X35D6,	"[es:bx+trans]",	0);
	create_insn	(x=0X35D6);
	op_dec		(x,	1);
	set_name	(0X35E3,	"already_got_ah_status");
	create_insn	(x=0X35E8);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X35EC,	"[bx+status]\nmark operation complete",	0);
	set_cmt	(0X35F8,	"get rid of fake return address",	0);
	set_name	(0X35FA,	"bc_retf");
	create_insn	(0X35FB);
	set_name	(0X35FB,	"command_error");
	set_cmt	(0X3600,	"5 bytes from 0:C0h will be copied onto here\nwhich is the CP/M call 5 entry point",	0);
	create_byte	(0X3600);
	make_array	(0X3600,	0X5);
	set_name	(0X3600,	"_offset_D0h");
	set_cmt	(0X3605,	"unknown command error",	0);
	create_insn	(0X3605);
	set_name	(0X3605,	"bc_cmderr");
	create_insn	(x=0X3607);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3607,	"bc_err_cnt");
	set_cmt	(0X360B,	"mark error return",	0);
	create_insn	(x=0X360B);
	op_hex		(x,	1);
	set_cmt	(0X360D,	"[es:bx+count]\n# of successful i/o's",	0);
	create_insn	(x=0X360D);
	op_dec		(x,	0);
	set_cmt	(0X3611,	"indicate abnormal end",	0);
	set_cmt	(0X3614,	"((con_table_end - con_table)-1)/2 = 11",	0);
	create_byte	(x=0X3614);
	op_dec		(x,	0);
	set_name	(0X3614,	"con_table");
	create_word	(x=0X3615);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3617);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3619);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X361B);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X361D);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X361F);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3621);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3623);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3625);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3627);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3629);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X362B,	"((prn_table_end - prn_table)-1)/2 = 26",	0);
	create_byte	(x=0X362B);
	op_dec		(x,	0);
	set_name	(0X362B,	"prn_table");
	create_word	(x=0X362C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X362E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3630);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3632);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3634);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3636);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3638);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X363A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X363C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X363E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3640);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3642);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3644);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3646);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3648);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X364A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X364C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X364E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3650);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3652);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3654);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3656);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3658);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X365A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X365C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X365E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X3660,	"((aux_table_end - aux_table)-1)/2 = 11",	0);
	create_byte	(x=0X3660);
	op_dec		(x,	0);
	set_name	(0X3660,	"aux_table");
	create_word	(x=0X3661);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3663);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3665);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3667);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3669);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X366B);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X366D);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X366F);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3671);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3673);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3675);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X3677,	"((tim_table_end - tim_table)-1)/2 = 10",	0);
	create_byte	(x=0X3677);
	op_dec		(x,	0);
	set_name	(0X3677,	"tim_table");
	create_word	(x=0X3678);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X367A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X367C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X367E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3680);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3682);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3684);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3686);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3688);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X368A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X368C,	"read cx bytes from keyboard into buffer",	0);
	create_insn	(0X368C);
	set_name	(0X368C,	"con_read");
	set_cmt	(0X368E,	"get char in al",	0);
	set_name	(0X368E,	"con_loop");
	set_cmt	(0X3691,	"store char at es:di",	0);
	set_name	(0X3694,	"con_exit");
	set_cmt	(0X3696,	"set by msinit. 0 or 10h",	0);
	create_insn	(x=0X3696);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3696,	"chrin");
	set_cmt	(0X369C,	"get character & zero altah",	0);
	create_insn	(x=0X369C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X36A4,	"KEYBOARD - ",	0);
	create_insn	(x=0X36A4);
	op_hex		(x,	0);
	set_cmt	(0X36AA,	"check for ctrl-prtsc",	0);
	create_insn	(x=0X36AA);
	op_hex		(x,	1);
	create_insn	(x=0X36AF);
	op_hex		(x,	1);
	create_insn	(x=0X36B3);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X36BA);
	op_hex		(x,	1);
	set_cmt	(0X36C6,	"special case?",	0);
	create_insn	(0X36C6);
	set_cmt	(0X36CA,	"store special key",	0);
	create_insn	(x=0X36CA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X36CF,	"keyboard non destructive read, no wait",	0);
	create_insn	(x=0X36CF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X36CF,	"con_rdnd");
	create_insn	(x=0X36D6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X36DA,	"KEYBOARD - ",	0);
	create_insn	(x=0X36DA);
	op_hex		(x,	0);
	create_insn	(x=0X36DE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X36E5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X36E9,	"[es:bx+status]",	0);
	create_insn	(x=0X36E9);
	op_hex		(x,	0);
	op_hex		(x,	1);
	create_insn	(x=0X36F1);
	op_hex		(x,	1);
	set_cmt	(0X36F6,	"SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)\nAL = condition type, BH = condition compare or mask value\nBL = timeout value times 55 milliseconds, 00h means no timeout\nDX = I/O port address if AL bit 4 set",	0);
	create_insn	(x=0X36F6);
	op_hex		(x,	0);
	set_name	(0X36F8,	"z_bus_exit");
	set_cmt	(0X36F9,	"indicate busy status",	0);
	create_insn	(x=0X36F9);
	op_hex		(x,	1);
	create_insn	(0X36FC);
	set_name	(0X36FC,	"gotchr");
	set_cmt	(0X36FE,	"check for null after break",	0);
	set_cmt	(0X3700,	"issue keyboard read function",	0);
	create_insn	(x=0X3700);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3704,	"KEYBOARD - ",	0);
	create_insn	(x=0X3704);
	op_hex		(x,	0);
	set_cmt	(0X3706,	"get a real status",	0);
	set_cmt	(0X3708,	"check for ctrl-prtsc",	0);
	create_insn	(x=0X3708);
	op_hex		(x,	1);
	set_name	(0X3708,	"notbrk");
	set_cmt	(0X370D,	"('P' & 1Fh) ; return control p",	0);
	create_insn	(x=0X370D);
	op_hex		(x,	1);
	set_cmt	(0X3711,	"extended keyboard function?",	0);
	create_insn	(x=0X3711);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3711,	"rd_ext_chk");
	set_cmt	(0X3718,	"extended key value or greek alpha?",	0);
	create_insn	(x=0X3718);
	op_hex		(x,	1);
	set_cmt	(0X371C,	"scan code exist?",	0);
	set_cmt	(0X371F,	"yes. greek alpha char.",	0);
	set_cmt	(0X3721,	"no. extended key stroke.\nchange it for compatibility",	0);
	create_insn	(x=0X3723);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3723,	"rdexit");
	set_cmt	(0X3727,	"[es:bx+media]\nreturn keyboard character here",	0);
	create_insn	(x=0X3727);
	op_dec		(x,	0);
	set_cmt	(0X372B,	"indicate normal termination",	0);
	set_name	(0X372B,	"bc_exvec");
	set_cmt	(0X372D,	"console write routine",	0);
	create_insn	(0X372D);
	set_name	(0X372D,	"con_writ");
	set_name	(0X372F,	"con_lp");
	set_cmt	(0X3733,	"DOS 2+ internal - FAST PUTCHAR\nAL = character to display",	0);
	create_insn	(x=0X3733);
	op_hex		(x,	0);
	set_name	(0X3737,	"cc_ret");
	set_cmt	(0X3739,	"flush out keyboard queue\nclear out holding buffer",	0);
	create_insn	(x=0X3739);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3739,	"con_flush");
	set_cmt	(0X373E,	"while (charavail()) charread();",	0);
	set_name	(0X373E,	"flloop");
	set_cmt	(0X3740,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer",	0);
	create_insn	(x=0X3740);
	op_hex		(x,	0);
	set_cmt	(0X3746,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character",	0);
	create_insn	(x=0X3746);
	op_hex		(x,	0);
	set_cmt	(0X374A,	"reset count to zero\n(sub reqpkt.count,cx)",	0);
	create_insn	(0X374A);
	set_name	(0X374A,	"prn_input");
	set_cmt	(0X374D,	"but return with carry   reset for no error",	0);
	set_cmt	(0X374F,	"write cx bytes from es:di to printer device",	0);
	create_insn	(0X374F);
	set_name	(0X374F,	"prn_writ");
	set_cmt	(0X3751,	"retry count",	0);
	create_insn	(x=0X3751);
	op_hex		(x,	1);
	set_name	(0X3751,	"prn_loop");
	set_cmt	(0X3754,	"get status",	0);
	set_name	(0X3754,	"prn_out");
	set_cmt	(0X3759,	"get character to print",	0);
	set_cmt	(0X375E,	"print to printer",	0);
	set_cmt	(0X3761,	"no error - continue",	0);
	set_cmt	(0X3763,	"MODE_CTRLBRK",	0);
	create_insn	(x=0X3763);
	op_hex		(x,	1);
	set_cmt	(0X3768,	"error_I24_gen_failure",	0);
	create_insn	(x=0X3768);
	op_hex		(x,	1);
	create_insn	(x=0X376A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3771,	"timeoutstatus",	0);
	create_insn	(x=0X3771);
	op_hex		(x,	1);
	set_name	(0X3771,	"_prnwf");
	set_cmt	(0X3776,	"retry until count is exhausted",	0);
	set_name	(0X3776,	"TestPrnError");
	set_name	(0X3779,	"pmessg");
	set_cmt	(0X377C,	"point to next char and continue",	0);
	create_insn	(0X377C);
	set_name	(0X377C,	"prn_con");
	set_name	(0X377F,	"prn_done");
	set_cmt	(0X3781,	"device in dx",	0);
	create_insn	(0X3781);
	set_name	(0X3781,	"prn_stat");
	set_cmt	(0X3786,	"notbusystatus",	0);
	create_insn	(x=0X3786);
	op_hex		(x,	1);
	set_cmt	(0X378E,	"PRINTER - GET STATUS\nset command for get status\nDX = printer port (0-3)\nReturn: AH = status",	0);
	create_insn	(0X378E);
	set_name	(0X378E,	"prnstat");
	set_cmt	(0X3790,	"get printer number",	0);
	create_insn	(x=0X3790);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3790,	"prnop");
	set_cmt	(0X379B,	"simulate int 17h",	0);
	set_cmt	(0X379D,	"0:5Ch = INT 17h vector",	0);
	create_insn	(x=0X379D);
	create_insn	(x=0X37A3);
	op_hex		(x,	1);
	set_cmt	(0X37A6,	"noprinter error",	0);
	create_insn	(x=0X37A6);
	op_hex		(x,	1);
	set_cmt	(0X37AC,	"~nopaperstatus",	0);
	create_insn	(x=0X37AC);
	op_hex		(x,	1);
	set_cmt	(0X37AF,	"ioerrstatus",	0);
	create_insn	(x=0X37AF);
	op_hex		(x,	1);
	set_cmt	(0X37B2,	"(ioerrstatus+nopaperstatus)\ni/o error?",	0);
	create_insn	(x=0X37B2);
	op_hex		(x,	1);
	set_cmt	(0X37B5,	"no, try not ready",	0);
	set_cmt	(0X37B7,	"error_I24_out_of_paper\n first, assume out of paper",	0);
	create_insn	(x=0X37B7);
	op_hex		(x,	1);
	set_cmt	(0X37B9,	"out of paper set?",	0);
	create_insn	(x=0X37B9);
	op_hex		(x,	1);
	set_cmt	(0X37BC,	"yes, error is set",	0);
	set_cmt	(0X37BE,	"return al=10 (i/o error)",	0);
	set_cmt	(0X37C1,	"assume not-ready",	0);
	create_insn	(x=0X37C1);
	op_hex		(x,	1);
	create_insn	(x=0X37C3);
	op_hex		(x,	1);
	create_insn	(0X37C7);
	set_name	(0X37C7,	"prn_tilbusy");
	set_name	(0X37C9,	"prn_tilbloop");
	create_insn	(x=0X37CD);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X37D1);
	op_hex		(x,	1);
	set_cmt	(0X37D3,	"wait count times to come ready",	0);
	create_insn	(x=0X37D3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X37D8,	"get status",	0);
	set_name	(0X37D8,	"prn_getstat");
	set_cmt	(0X37DB,	"error",	0);
	set_cmt	(0X37DD,	"ready yet?",	0);
	create_insn	(x=0X37DD);
	op_hex		(x,	1);
	set_cmt	(0X37E0,	"no, go for more",	0);
	set_cmt	(0X37E2,	"get original count",	0);
	set_cmt	(0X37E3,	"still not ready => done",	0);
	set_cmt	(0X37F0,	"normal no-error return",	0);
	create_insn	(0X37F2);
	set_name	(0X37F2,	"prn_bperr");
	set_name	(0X37F3,	"prn_berr");
	create_insn	(x=0X37F6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X37F6,	"prn_genioctl");
	set_cmt	(0X37FA,	"[es:di+IOCTL_REQ.MAJORFUNCTION]\nioc_pc",	0);
	create_insn	(x=0X37FA);
	op_dec		(x,	0);
	op_hex		(x,	1);
	set_cmt	(0X3801,	"[es:di+IOCTL_REQ.MINORFUNCTION]",	0);
	create_insn	(x=0X3801);
	op_dec		(x,	1);
	set_cmt	(0X3805,	"[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	create_insn	(x=0X3805);
	op_dec		(x,	1);
	create_insn	(x=0X380B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X380F);
	op_hex		(x,	1);
	set_cmt	(0X3811,	"pull out retry count for device",	0);
	create_insn	(x=0X3811);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3815,	"get_retry_count",	0);
	create_insn	(x=0X3815);
	op_hex		(x,	1);
	set_cmt	(0X3819,	"set_retry_count",	0);
	create_insn	(x=0X3819);
	op_hex		(x,	1);
	create_insn	(x=0X3820);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3820,	"prngetcount");
	set_cmt	(0X3824,	"[es:di+A_RETRYCOUNT.RC_COUNT]\nreturn current retry count",	0);
	set_name	(0X3827,	"IOCtlSupported");
	create_insn	(x=0X3829);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3829,	"prn_ioctl_query");
	set_cmt	(0X382D,	"[es:di+IOCTL_REQ.MAJORFUNCTION]\nioc_pc",	0);
	create_insn	(x=0X382D);
	op_dec		(x,	0);
	set_cmt	(0X3834,	"[es:di+IOCTL_REQ.MINORFUNCTION]",	0);
	create_insn	(x=0X3834);
	op_dec		(x,	1);
	set_cmt	(0X3838,	"GET_RETRY_COUNT",	0);
	create_insn	(x=0X3838);
	op_hex		(x,	1);
	set_cmt	(0X383C,	"SET_RETRY_COUNT",	0);
	create_insn	(x=0X383C);
	op_hex		(x,	1);
	set_name	(0X3840,	"prn_query_err");
	set_name	(0X3841,	"prnfuncerr");
	create_insn	(0X3844);
	set_name	(0X3844,	"aux_read");
	set_cmt	(0X3846,	"put address of auxbuf   in bx",	0);
	set_cmt	(0X3851,	"get character from port\nwon't return if error",	0);
	set_name	(0X3851,	"aux1");
	set_name	(0X3854,	"aux2");
	set_cmt	(0X3855,	"if more characters, go around again",	0);
	set_cmt	(0X3857,	"all done, successful exit",	0);
	set_name	(0X3857,	"exvec2");
	set_name	(0X3858,	"auxin_retn");
	create_insn	(0X3859);
	set_name	(0X3859,	"auxin");
	set_cmt	(0X385E,	"flag_frame|flag_parity|flag_overrun",	0);
	create_insn	(x=0X385E);
	op_hex		(x,	1);
	set_name	(0X3863,	"arbad");
	set_cmt	(0X3864,	"flag_rec_sig|flag_dsr|flag_cts",	0);
	set_cmt	(0X3868,	"non-destructive aux port read",	0);
	create_insn	(0X3868);
	set_name	(0X3868,	"aux_rdnd");
	set_cmt	(0X386F,	"if al is non-zero (char in buffer)\nthen return character",	0);
	set_cmt	(0X3871,	"if not, get status of   aux device",	0);
	set_cmt	(0X3874,	"flag_data_ready - test data ready",	0);
	create_insn	(x=0X3874);
	op_hex		(x,	1);
	set_cmt	(0X3877,	"then device is busy (not ready)",	0);
	set_cmt	(0X3879,	"flag_dsr - test data set ready",	0);
	create_insn	(x=0X3879);
	op_hex		(x,	1);
	set_cmt	(0X387B,	"then device is busy (not ready)",	0);
	set_cmt	(0X387D,	"else aux is ready, get character",	0);
	set_cmt	(0X3882,	"return busy status",	0);
	set_name	(0X3882,	"auxrdx");
	create_insn	(0X3885);
	set_name	(0X3885,	"auxbus");
	set_cmt	(0X3888,	"return aux port write status",	0);
	create_insn	(0X3888);
	set_name	(0X3888,	"aux_wrst");
	set_cmt	(0X388B,	"test data set ready",	0);
	create_insn	(x=0X388B);
	op_hex		(x,	1);
	set_cmt	(0X388D,	"then device is busy (not ready)",	0);
	set_cmt	(0X388F,	"flag_tranhol_emp - test transmit hold reg",	0);
	create_insn	(x=0X388F);
	op_hex		(x,	1);
	set_cmt	(0X3892,	"then device is busy (not ready)",	0);
	set_cmt	(0X3896,	"auxfunc_status",	0);
	create_insn	(0X3896);
	set_name	(0X3896,	"auxstat");
	set_cmt	(0X3898,	"ah=function code\n0=init, 1=send, 2=receive, 3=status\nget port number",	0);
	create_insn	(x=0X3898);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3898,	"auxop");
	set_cmt	(0X38A3,	"simulate INT 14h",	0);
	set_cmt	(0X38A5,	"INT 14h vector (14h*4 = 50h)\nSERIAL I/O - GET USART STATUS\nDX = port number (0-3)\nReturn: AX = port status code",	0);
	create_insn	(x=0X38A5);
	set_cmt	(0X38AB,	"flush aux input buffer\nget bx to point to auxbuf\nzero out buffer\nall done, successful return",	0);
	create_insn	(0X38AB);
	set_name	(0X38AB,	"aux_flsh");
	set_cmt	(0X38B3,	"write to aux device (if cx > 0)",	0);
	create_insn	(0X38B3);
	set_name	(0X38B3,	"aux_writ");
	set_cmt	(0X38B5,	"get character to be written",	0);
	set_cmt	(0X38B5,	"move di pointer to next character",	1);
	set_name	(0X38B5,	"aux_loop");
	set_cmt	(0X38B8,	"move di pointer to next character",	0);
	set_cmt	(0X38B9,	"auxfunc_send - indicates a write",	0);
	set_cmt	(0X38BB,	"send character over aux port",	0);
	set_cmt	(0X38BE,	"check for error",	0);
	create_insn	(x=0X38BE);
	op_hex		(x,	1);
	set_cmt	(0X38C1,	"then no error",	0);
	set_cmt	(0X38C3,	"else indicate write fault",	0);
	create_insn	(x=0X38C3);
	op_dec		(x,	1);
	set_cmt	(0X38C5,	"call error routines",	0);
	set_name	(0X38C5,	"bc_err_cnt_j");
	create_insn	(0X38C8);
	set_name	(0X38C8,	"awok");
	set_cmt	(0X38CC,	"return bx -> single byte input buffer\nfor selected aux port ([auxnum])",	0);
	create_insn	(x=0X38CC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X38CC,	"getbx");
	create_insn	(x=0X38D0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X38D5,	"convert time to ticks\ninput : time in cx and dx\noutput: ticks returned in cx:dx\n\nthe clock ticks at the rate of:\n1193180/65536 ticks/second\n(about 18.2 ticks per second)",	0);
	create_insn	(x=0X38D5);
	op_dec		(x,	1);
	set_name	(0X38D5,	"time_to_ticks");
	set_cmt	(0X38D7,	"hours to minutes ///\nfirst convert from hour,min,sec,hund. to\ntotal number of 100th of seconds",	0);
	set_cmt	(0X38DB,	"total minutes",	0);
	set_cmt	(0X38DD,	"60*100",	0);
	create_insn	(x=0X38DD);
	op_dec		(x,	1);
	set_cmt	(0X38E2,	"convert to 1/100 sec",	0);
	create_insn	(x=0X38E6);
	op_dec		(x,	1);
	set_cmt	(0X38E8,	"convert seconds to 1/100 sec",	0);
	set_cmt	(0X38EA,	"combine seconds with hours and min",	0);
	set_cmt	(0X38F1,	"combine 1/100 sec",	0);
	set_cmt	(0X38F3,	"dx:cx is time in 1/100 sec",	0);
	set_cmt	(0X38F7,	"now time is in cx:ax",	0);
	create_insn	(x=0X38F8);
	op_dec		(x,	1);
	set_cmt	(0X38FB,	"multiply low half",	0);
	set_cmt	(0X38FF,	"cx->ax, ax->dx, dx->cx",	0);
	set_cmt	(0X3900,	"multiply high half",	0);
	set_cmt	(0X3902,	"combine overlapping products",	0);
	set_cmt	(0X3907,	"ax:dx=time*59659",	0);
	set_cmt	(0X390B,	"divide high half by 5",	0);
	set_cmt	(0X3911,	"remainder of divide-by-5",	0);
	set_cmt	(0X3914,	"use it to extend low half",	0);
	set_cmt	(0X3915,	"divide low half by 5",	0);
	set_cmt	(0X3917,	"cx:dx is now number of ticks in time",	0);
	set_cmt	(0X391A,	"sets the current time",	0);
	create_insn	(0X391A);
	set_name	(0X391A,	"tim_writ");
	set_cmt	(0X391D,	"daycnt. we need to set this at the very\nend to avoid tick windows",	0);
	create_insn	(x=0X391E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3925,	"get binary hours\nconvert to bcd",	0);
	set_cmt	(0X392C,	"ch = bcd hours",	0);
	set_cmt	(0X392E,	"get binary minutes",	0);
	set_cmt	(0X3935,	"cl = bcd minutes",	0);
	set_cmt	(0X3937,	"get binary seconds",	0);
	set_cmt	(0X393E,	"dh = bcd seconds",	0);
	set_cmt	(0X3940,	"dl = 0 (st) or 1 (dst)",	0);
	set_cmt	(0X3945,	"CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)\nCH = hours in BCD, CL = minutes in BCD\n DH = seconds in BCD,DL = 01h if daylight savings, 00h if standard time\nReturn: CMOS clock set",	0);
	create_insn	(x=0X3945);
	op_hex		(x,	0);
	set_name	(0X3948,	"no_cmos_1");
	set_cmt	(0X3950,	"convert time to ticks\ncx:dx now has time in ticks",	0);
	create_insn	(x=0X3950);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3954,	"turn off timer",	0);
	set_cmt	(0X3957,	"CLOCK - SET TIME OF DAY\nCX:DX = clock count\nReturn: time of day set",	0);
	create_insn	(x=0X3957);
	op_hex		(x,	0);
	create_insn	(x=0X3959);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X395E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X396B,	"CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)\nDL = day in BCD, DH = month in BCD, CL = year in BCD\nCH = century (19h or 20h)\nReturn: CMOS clock set",	0);
	create_insn	(x=0X396B);
	op_hex		(x,	0);
	set_name	(0X396E,	"no_cmos_2");
	set_cmt	(0X3970,	"entry: [daycnt] = number of days since 1-1-80\nreturn: ch - century in bcd\n        cl - year in bcd\n        dh - month in bcd\n        dl - day in bcd",	0);
	create_insn	(x=0X3970);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3970,	"daycnttoday");
	set_cmt	(0X3974,	"(365*20+(20/4))\n# days from 1-1-1980 to 1-1-2000",	0);
	create_insn	(x=0X3974);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X397C,	"base century = 19\nbase year = 80",	0);
	create_insn	(x=0X397C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X3984,	"base century = 20\nbase year = 0",	0);
	create_insn	(x=0X3984);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X398A,	"365*20+(20/4))\nadjust daycnt",	0);
	create_insn	(x=0X398A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	create_insn	(x=0X3992);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3995,	"366+365*3)\n# of days in a Leap year block",	0);
	create_insn	(x=0X3995);
	op_dec		(x,	1);
	set_cmt	(0X3998,	"ax = # of leap block, dx = daycnt",	0);
	set_cmt	(0X399A,	"save daycnt left",	0);
	create_insn	(x=0X399A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X39A2,	"ax = # of years. Less than 100",	0);
	create_insn	(x=0X39A2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X39A6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X39AA,	"daycnt = remainder of leap year block\nwithin 366+355+355+355 days",	0);
	create_insn	(x=0X39AA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X39B2,	"if daycnt <= 366, then leap year\nelse daycnt -= 366, base_year++",	0);
	create_insn	(x=0X39B2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X39B6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X39BC,	"And next three years are normal",	0);
	create_insn	(x=0X39BC);
	op_hex		(x,	1);
	set_cmt	(0X39BF,	"for(i=1; i>3 or daycnt <=365; i++)",	0);
	create_insn	(x=0X39BF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X39C5,	"{if (daycnt > 365)",	0);
	set_cmt	(0X39C7,	"{ daycnt -= 365",	0);
	create_insn	(x=0X39C7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X39CB,	"}",	0);
	create_insn	(x=0X39CB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_cmt	(0X39D1,	"}\nshould never fall through loop",	0);
	set_cmt	(0X39D3,	"leap year.\nchange month table.",	0);
	create_insn	(x=0X39D3);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	set_name	(0X39D3,	"leapyear");
	set_name	(0X39D8,	"yeardone");
	create_insn	(x=0X39DC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X39DF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X39E2);
	op_dec		(x,	1);
	set_cmt	(0X39E9,	"cmp daycnt for each month till fit\ndh=0",	0);
	set_cmt	(0X39ED,	"next month",	0);
	set_cmt	(0X39EE,	"adjust daycnt",	0);
	set_cmt	(0X39F0,	"\nshould never fall through loop",	0);
	set_cmt	(0X39F2,	"restore month table value",	0);
	create_insn	(x=0X39F2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_dec		(x,	1);
	create_insn	(x=0X39F9);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X39FD,	"al=day,dl=month,dh=year,cl=cntry",	0);
	create_insn	(x=0X39FD);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3A01,	"convert \"day\" to bcd\ndl = bcd day, al = month",	0);
	set_cmt	(0X3A06,	"dh = bcd month, al = year",	0);
	set_cmt	(0X3A0B,	"cl = bcd year, al = century",	0);
	set_cmt	(0X3A10,	"ch = bcd century",	0);
	set_cmt	(0X3A15,	"restore original value",	0);
	create_insn	(x=0X3A15);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3A1A,	"convert a binary input in al\n(less than 63h or 99 decimal)\ninto a bcd value in al. ah destroyed\n\nAH = AL/10, AL = AL MOD 10",	0);
	create_insn	(0X3A1A);
	set_name	(0X3A1A,	"bintobcd");
	set_cmt	(0X3A1C,	"db 0D5h,10h\nAL = (AH*10H)+AL, AH = 0",	0);
	set_cmt	(0X3A1F,	"gettime reads date and time\n\n65,536 seconds = 1,193,180 ticks\n\ntime in 100th of seconds\n   = ticks from clock  * 65,536 * 100 / 1,193,180\n   = ticks from clock * 5 * 65,536 / 59,659",	0);
	create_insn	(0X3A1F);
	set_name	(0X3A1F,	"tim_read");
	create_insn	(x=0X3A22);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3A28,	"start with ticks in cx:dx\nmultiply by 5",	0);
	create_insn	(x=0X3A2A);
	op_hex		(x,	1);
	create_insn	(x=0X3A2C);
	op_hex		(x,	1);
	create_insn	(x=0X3A2E);
	op_hex		(x,	1);
	create_insn	(x=0X3A30);
	op_hex		(x,	1);
	set_cmt	(0X3A37,	"multiply by 65536 and divide by 59659",	0);
	create_insn	(x=0X3A37);
	op_dec		(x,	1);
	set_cmt	(0X3A3A,	"dx has remainder\nax has high word of final quotient",	0);
	set_cmt	(0X3A3C,	"put high word in safe place",	0);
	set_cmt	(0X3A3D,	"multiply by 65536",	0);
	set_cmt	(0X3A3F,	"bx:ax has time in 100th of seconds",	0);
	set_cmt	(0X3A43,	"division by 200 is necessary \nto ensure no overflow--max result\nis number of seconds in a day/2 = 43200.",	0);
	create_insn	(x=0X3A43);
	op_dec		(x,	1);
	set_cmt	(0X3A48,	"remainder over 100?",	0);
	create_insn	(x=0X3A48);
	op_dec		(x,	1);
	set_cmt	(0X3A4D,	"keep 1/100's less than 100",	0);
	create_insn	(x=0X3A4D);
	op_dec		(x,	1);
	set_cmt	(0X3A50,	"if we subtracted 100, carry is now set",	0);
	set_name	(0X3A50,	"noadj");
	set_cmt	(0X3A51,	"save 1/100's",	0);
	set_cmt	(0X3A53,	"multiply by two",	0);
	create_insn	(x=0X3A53);
	op_hex		(x,	1);
	create_insn	(x=0X3A57);
	op_hex		(x,	1);
	set_cmt	(0X3A59,	"divide out seconds",	0);
	create_insn	(x=0X3A59);
	op_dec		(x,	1);
	set_cmt	(0X3A5D,	"save the seconds",	0);
	set_cmt	(0X3A5F,	"break into hours and minutes",	0);
	set_cmt	(0X3A61,	"time is now in ax:bx \n(hours, minutes, seconds, 1/100 sec)",	0);
	set_cmt	(0X3A63,	"daycnt",	0);
	set_cmt	(0X3A65,	"al = hours, ah = minutes",	0);
	set_cmt	(0X3A6A,	"[es:di] = count of days since 1-1-80\n   [es:di+2] = hours\n   [es:di+3] = minutes\n   [es:di+4] = seconds\n   [es:di+5] = hundredths of seconds",	0);
	set_cmt	(0X3A6C,	"Returns the tick count in cx:dx\nTakes care of DayCnt in case of rollover\nif ( rollover ) {\n    if ( t_switch )\n           daycnt++ ;\n    else\n           daycnt += rollover ;\n    }",	0);
	create_insn	(0X3A6C);
	set_name	(0X3A6C,	"GetTickCnt");
	set_cmt	(0X3A6E,	"CLOCK - GET TIME OF DAY\nReturn: CX:DX = clock count\nAL = 00h if clock was read or written (via AH=0,1) since the previous\nmidnight\nOtherwise, AL > 0",	0);
	create_insn	(x=0X3A6E);
	op_hex		(x,	0);
	set_cmt	(0X3A72,	"use old method ? (>0 is yes)",	0);
	create_insn	(x=0X3A72);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3A76,	"old method assumes that Int 1Ah returns rollover flag",	0);
	set_cmt	(0X3A78,	"new method assumes that Int 1Ah returns roll over count\nand not flag",	0);
	create_insn	(x=0X3A78);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X3A7D);
	create_insn	(x=0X3A81);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_strlit	(0X3A86,	0X3A8E);
	set_name	(0X3A86,	"fat_12_id");
	create_strlit	(0X3A8E,	0X3A96);
	set_name	(0X3A8E,	"fat_16_id");
	create_strlit	(0X3A96,	0X3A9E);
	set_name	(0X3A96,	"fat_32_id");
	create_strlit	(0X3A9E,	0X3AA9);
	set_name	(0X3A9E,	"nul_vid");
	create_byte	(x=0X3AA9);
	op_dec		(x,	0);
	set_name	(0X3AA9,	"DSKTBL");
	create_word	(x=0X3AAA);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AAC);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AAE);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X3AB0,	"PCDOS 7",	0);
	create_word	(x=0X3AB0);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AB2);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AB4);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AB6);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AB8);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ABA);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ABC);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ABE);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AC0);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X3AC2,	"PCDOS 7",	0);
	create_word	(x=0X3AC2);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AC4);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AC6);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AC8);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ACA);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ACC);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ACE);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AD0);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AD2);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AD4);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AD6);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3AD8);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ADA);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_word	(x=0X3ADC);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X3ADE,	"Point es:di to first bds",	0);
	create_insn	(x=0X3ADE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3ADE,	"SetDrive");
	set_cmt	(0X3AE2,	"logical drive number (BDS.drivelet)",	0);
	set_cmt	(0X3AE8,	"[es:di+BDS.link] ; Go to next bds",	0);
	create_insn	(0X3AF2);
	set_name	(0X3AF2,	"media_chk");
	set_cmt	(0X3AF8,	"[es:di+BDS.flags+1], fchanged_by_format",	0);
	create_insn	(x=0X3AF8);
	op_hex		(x,	1);
	set_cmt	(0X3AFF,	"[es:di+BDS.flags+1],\n~fchanged_by_format ; reset flag",	0);
	create_insn	(x=0X3AFF);
	op_hex		(x,	1);
	set_cmt	(0X3B04,	"-1\nEnsure that we ask the rom if media has changed",	0);
	create_insn	(x=0X3B04);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3B09,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X3B09);
	op_hex		(x,	1);
	set_cmt	(0X3B14,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X3B14);
	op_hex		(x,	1);
	set_name	(0X3B14,	"WeAreNotFakingIt");
	set_cmt	(0X3B1B,	"0 ; Presume \"I don't know\"",	0);
	set_name	(0X3B1B,	"wehaveafloppy");
	set_cmt	(0X3B1C,	"Do we have changeline support?",	0);
	create_insn	(x=0X3B1C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3B21,	"Brif not",	0);
	set_cmt	(0X3B23,	"Call into removable routine",	0);
	set_cmt	(0X3B2D,	"Presume no change",	0);
	set_name	(0X3B2D,	"mChk_NoChangeLine");
	set_cmt	(0X3B30,	"Last drive accessed",	0);
	create_insn	(x=0X3B30);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3B33,	"[es:di+BDS.drivenum]\nIs drive of last access the same?",	0);
	set_cmt	(0X3B37,	"No, then \"i don't know\"",	0);
	set_cmt	(0X3B3E,	"0 ; Return \"I don't know\"",	0);
	create_insn	(0X3B3E);
	set_name	(0X3B3E,	"Media_Unk");
	set_name	(0X3B3F,	"Media_Done");
	create_insn	(x=0X3B40);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3B44,	"[es:bx+trans]",	0);
	create_insn	(x=0X3B44);
	op_dec		(x,	0);
	set_cmt	(0X3B4B,	"volidok",	0);
	create_insn	(x=0X3B4D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3B57,	"-1\nMake sure we ask rom for media check",	0);
	create_insn	(x=0X3B57);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3B57,	"mChk1_NoChangeLine");
	set_cmt	(0X3B5C,	"volidok",	0);
	set_name	(0X3B5C,	"ret_carry_clear");
	set_cmt	(0X3B5E,	"guaranteed to set carry",	0);
	create_insn	(0X3B5E);
	set_name	(0X3B5E,	"err_exitj");
	set_cmt	(0X3B61,	"return error status",	0);
	set_name	(0X3B61,	"ret81");
	set_cmt	(0X3B63,	"return with carry set",	0);
	set_cmt	(0X3B64,	"presume no change",	0);
	create_insn	(0X3B64);
	set_name	(0X3B64,	"Check_Time_Of_Access");
	set_cmt	(0X3B67,	"cx:dx is the elapsed time",	0);
	set_cmt	(0X3B6A,	"[es:di+BDS.tim_lo]\nget stored time",	0);
	set_cmt	(0X3B70,	"[es:di+BDS.tim_hi]",	0);
	create_insn	(x=0X3B76);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3B79,	"cx<>0 => >1 hour",	0);
	set_cmt	(0X3B7B,	"time must pass",	0);
	set_cmt	(0X3B7D,	"yes, examine max value",	0);
	set_cmt	(0X3B83,	"if count is less than threshold, ok",	0);
	set_cmt	(0X3B89,	"18*2 ; 18.2 tics per second.\nmin elapsed time? (2 seconds)",	0);
	create_insn	(x=0X3B89);
	op_dec		(x,	1);
	set_cmt	(0X3B8E,	"presume i don't know",	0);
	create_insn	(x=0X3B8F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X3B93);
	set_cmt	(0X3B95,	"Build a valid bpb for the disk in the drive.\nget fat id byte read by dos",	0);
	create_insn	(0X3B95);
	set_name	(0X3B95,	"get_bpb");
	set_cmt	(0X3B98,	"get the correct bds for the drive",	0);
	set_cmt	(0X3B9B,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X3B9B);
	op_hex		(x,	1);
	set_cmt	(0X3BA0,	"no need to build for fixed disks",	0);
	set_cmt	(0X3BA5,	"indicate to set system id in bds",	0);
	create_insn	(x=0X3BA5);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3BAA,	"build a bpb if necessary",	0);
	set_cmt	(0X3BAF,	"already, volume_label set from boot",	0);
	create_insn	(x=0X3BAF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3BB4,	"record to bds table?",	0);
	create_insn	(x=0X3BB4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3BB9,	"do not set it again from root dir\notherwise, conventional boot record",	0);
	set_cmt	(0X3BBB,	"do we have changeline support?",	0);
	create_insn	(x=0X3BBB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3BC0,	"brif not",	0);
	set_cmt	(0X3BC5,	"BDS.BPB (BDS offset 6)",	0);
	set_name	(0X3BC5,	"already_gotbpb");
	set_cmt	(0X3BC8,	"return point for dsk_init",	0);
	set_name	(0X3BC8,	"SetPtrSav");
	create_insn	(x=0X3BC9);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3BCD,	"[bx+media]",	0);
	set_cmt	(0X3BD0,	"[bx+count]",	0);
	set_cmt	(0X3BD3,	"[bx+count+2]",	0);
	create_insn	(0X3BDB);
	set_name	(0X3BDB,	"clear_ids");
	set_cmt	(0X3BDC,	"0",	0);
	set_cmt	(0X3BDE,	"[es:di+BDS.vol_serial]",	0);
	set_cmt	(0X3BE3,	"[es:di+BDS.vol_serial+2]",	0);
	create_insn	(x=0X3BE8);
	op_dec		(x,	1);
	create_insn	(x=0X3BEA);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X3BED,	"BDS.volid",	0);
	create_insn	(x=0X3BED);
	op_dec		(x,	1);
	set_cmt	(0X3BF0,	"cs rep movsb",	0);
	set_cmt	(0X3BF3,	"(here, es:di points to the BDS offset +136)\n[es:di+BDS.fatsiz], fbigbig\n\n! NOTE - 26/06/2023 - Erdogan Tan\nMicrosoft/IBM code has a bug here because the BDS's\n.volid and .filesys_id fields will be reset\n(to their default text) according to 'BDS.fatsiz' flags\nat the BDS offset 59 but current (this) code checks flags\nat ES:DI+59 while DI points the BDS offset 136!?\n\nCorrect Code:\ntest byte [ES:DI+59-136],20h or\nDI_POSITION equ BDS.volid + size_of_EXT_BOOT_VOL_LABEL\ntest byte [ES:DI:BDS.fatsiz-DI_POSITION],20h ; fbigbig\n\n(Why this bug did not affect MSDOS and PCDOS 7.x applications:\n'clear_ids' is used for floppy disks only and the default\noption of 'clear_ids' is FAT12 volid and filesys_id text\nwhen the flag bit has wrong value for FAT16/40h or FAT32/20h.)",	0);
	create_insn	(x=0X3BF3);
	op_dec		(x,	0);
	op_hex		(x,	1);
	create_insn	(x=0X3BF8);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X3BFD,	"[es:di+BDS.fatsiz], fbig",	0);
	create_insn	(x=0X3BFD);
	op_dec		(x,	0);
	op_hex		(x,	1);
	create_insn	(x=0X3C02);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	create_insn	(x=0X3C07);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X3C0A,	"size_of_EXT_SYSTEM_ID",	0);
	set_cmt	(0X3C0C,	"(BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL\nBDS.filesys_id (BDS offset 141)",	0);
	set_cmt	(0X3C0F,	"0F3h,2Eh,0A4h\ncs rep movsb",	0);
	set_cmt	(0X3C12,	"restore bds pointer",	0);
	set_name	(0X3C13,	"getret_exit");
	set_cmt	(0X3C14,	"[es:di+BDS.flags],\nreturn_fake_bpb|fnon_removable",	0);
	create_insn	(x=0X3C14);
	op_hex		(x,	1);
	set_name	(0X3C14,	"GetBp");
	set_cmt	(0X3C23,	"bx is 0 if boot sector is valid",	0);
	set_cmt	(0X3C27,	"move bpb into registers",	0);
	create_insn	(0X3C2D);
	set_cmt	(0X3C30,	"puts media descriptor byte in ah",	0);
	create_insn	(0X3C30);
	set_cmt	(0X3C35,	"changeline support available?",	0);
	create_insn	(x=0X3C35);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3C3A,	"brif not",	0);
	set_cmt	(0X3C3F,	"[es:di+BDS.formfactor], ffSmall",	0);
	set_cmt	(0X3C46,	"is it a valid fat id byte for 3.5\" ?",	0);
	set_cmt	(0X3C49,	"yes",	0);
	set_cmt	(0X3C4E,	"bpbtype.sbf = 3",	0);
	create_insn	(x=0X3C4E);
	op_hex		(x,	1);
	set_name	(0X3C4E,	"Has720K");
	set_cmt	(0X3C50,	"bpbtype.csec = 1440",	0);
	create_insn	(x=0X3C50);
	op_dec		(x,	1);
	set_cmt	(0X3C53,	"dl = bpbtype.spau = 2\ndh = bpbtype.chead = 2",	0);
	create_insn	(x=0X3C53);
	op_hex		(x,	1);
	set_cmt	(0X3C56,	"bl = bpbtype.spt = 9\nbh = bpbtype.dire = 112",	0);
	create_insn	(x=0X3C56);
	op_hex		(x,	1);
	create_insn	(x=0X3C5B);
	set_cmt	(0X3C63,	"bpbtype.sbf = 1",	0);
	create_insn	(0X3C63);
	set_cmt	(0X3C65,	"bl = bpbtype.spt = 8\nbh = bpbtype.dire = 64",	0);
	create_insn	(x=0X3C65);
	set_cmt	(0X3C68,	"bpbtype.csec = 320",	0);
	create_insn	(x=0X3C68);
	op_dec		(x,	1);
	set_cmt	(0X3C6B,	"dl = bpbtype.spau = 1\ndh = bpbtype.chead = 1",	0);
	create_insn	(x=0X3C6B);
	create_insn	(x=0X3C6E);
	op_hex		(x,	1);
	set_cmt	(0X3C73,	"bpbtype.sbf = 2",	0);
	set_cmt	(0X3C74,	"bpbtype.spt = 9",	0);
	set_cmt	(0X3C75,	"180K (360 sectors)",	0);
	create_insn	(x=0X3C75);
	op_dec		(x,	1);
	set_cmt	(0X3C78,	"bpbtype.sbf = 1",	0);
	create_insn	(x=0X3C78);
	op_hex		(x,	1);
	set_cmt	(0X3C7F,	"bh = bpbtype.dire = 112",	0);
	create_insn	(x=0X3C7F);
	op_dec		(x,	1);
	set_cmt	(0X3C81,	"bpbtype.chead = 2",	0);
	set_cmt	(0X3C83,	"bpbtype.spau = 2",	0);
	set_name	(0X3C84,	"Has1");
	set_cmt	(0X3C87,	"[di+BDS.secperclus]",	0);
	set_cmt	(0X3C8A,	"0",	0);
	set_cmt	(0X3C8C,	"[di+BDS.heads]",	0);
	set_cmt	(0X3C91,	"[di+BDS.direntries]",	0);
	set_cmt	(0X3C94,	"[di+BDS.totalsecs16]",	0);
	set_cmt	(0X3C97,	"[di+BDS.totalsecs32]",	0);
	set_cmt	(0X3C9A,	"[di+BDS.media]",	0);
	set_cmt	(0X3C9F,	"[di+BDS.fatsecs]",	0);
	set_cmt	(0X3CA4,	"[di+BDS.secpertrack]",	0);
	set_cmt	(0X3CA7,	"0",	0);
	set_cmt	(0X3CA9,	"[di+BDS.hiddensecs+2]",	0);
	set_cmt	(0X3CAC,	"[di+BDS.hiddensecs]",	0);
	set_cmt	(0X3CAF,	"[di+BDS.totalsecs32+2]",	0);
	set_cmt	(0X3CB2,	"[di+BDS.fatsecs32] ; BPB_FATSz32",	0);
	set_cmt	(0X3CB5,	"[di+BDS.fatsecs32+2]",	0);
	set_cmt	(0X3CB8,	"[di+BDS.rootdirclust]",	0);
	set_cmt	(0X3CBB,	"[di+BDS.rootdirclust+2]",	0);
	set_cmt	(0X3CBE,	"[di+BDS.reserved]\n    BPB_Reserved (12 zero bytes)",	0);
	set_cmt	(0X3CD0,	"[di+BDS.extflags] ; BPB_ExtFlags",	0);
	set_cmt	(0X3CD3,	"[di+BDS.fsver] ; BPB_FSVer",	0);
	set_cmt	(0X3CD6,	"-1 ; 0FFFFFFFFh",	0);
	set_cmt	(0X3CD7,	"[di+BDS.fsinfo] ; BPB_FSInfo",	0);
	set_cmt	(0X3CDA,	"[di+BDS.bkbootsec] ; BPB_BkBootSec",	0);
	create_insn	(x=0X3CE2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3CEC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3CF6,	"head 0",	0);
	create_insn	(0X3CF6);
	set_name	(0X3CF6,	"readbootsec");
	set_cmt	(0X3CF8,	"cylinder 0, sector 1",	0);
	set_cmt	(0X3D00,	"bx = 0",	0);
	create_insn	(x=0X3D02);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3D05,	"is it a direct jump?",	0);
	create_insn	(x=0X3D05);
	op_hex		(x,	1);
	set_cmt	(0X3D07,	"don't need to find a nop",	0);
	set_cmt	(0X3D09,	"dos 2.0 jump?",	0);
	create_insn	(x=0X3D09);
	op_hex		(x,	1);
	set_cmt	(0X3D0B,	"no need for nop",	0);
	set_cmt	(0X3D0D,	"how about a short jump?",	0);
	create_insn	(x=0X3D0D);
	op_hex		(x,	1);
	set_cmt	(0X3D11,	"is next one a nop?",	0);
	create_insn	(x=0X3D11);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X3D18,	"\n[disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]",	0);
	create_insn	(x=0X3D18);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X3D1C);
	op_hex		(x,	1);
	set_cmt	(0X3D1E,	"allow for strange media",	0);
	create_insn	(x=0X3D27);
	op_hex		(x,	1);
	set_cmt	(0X3D2B,	"'3.'",	0);
	create_insn	(x=0X3D2B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3D33,	"2",	0);
	create_insn	(x=0X3D33);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3D3A,	"we must have a pre-3.20 diskette.\nset the sec/clus field to 1\n[disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]",	0);
	create_insn	(x=0X3D3A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3D3A,	"mustbeearlier");
	set_cmt	(0X3D41,	"indicate that boot sector invalid (bx = 1)",	0);
	create_insn	(0X3D41);
	set_name	(0X3D42,	"gooddsk");
	create_insn	(0X3D44);
	set_name	(0X3D44,	"movbpb");
	set_cmt	(0X3D45,	"BDS+6 = BDS.BPB",	0);
	create_insn	(x=0X3D48);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3D4C,	"copy bios parameters block\nfrom BPB_BytsPerSec to (FAT32) BS_DrvNum (excluded)",	0);
	create_insn	(x=0X3D4C);
	op_dec		(x,	1);
	set_cmt	(0X3D52,	"si = disksector+64 -> 64-45 = 19\ndisksektor+19 = BPB_TotSec16",	0);
	create_insn	(x=0X3D52);
	op_dec		(x,	1);
	set_cmt	(0X3D59,	"write 16 bit total sectors\nto 32 bit total sectors field",	0);
	create_insn	(x=0X3D59);
	op_dec		(x,	0);
	set_cmt	(0X3D5D,	"BPB_TotalSec32+2 (BDS offset 29, BPB offset 23)",	0);
	create_insn	(x=0X3D5D);
	op_dec		(x,	0);
	set_cmt	(0X3D61,	"BPB_FATSz16 = disksector+22",	0);
	create_insn	(x=0X3D61);
	op_dec		(x,	0);
	set_cmt	(0X3D66,	"\ndi = BDS offset 31 (BPB offset 25)",	0);
	create_insn	(x=0X3D66);
	op_dec		(x,	1);
	set_name	(0X3D66,	"movbpb_fat");
	set_cmt	(0X3D69,	"clear 12 byte extended BDS (FAT32) fields\n(which are used only for FAT32 disks)",	0);
	create_insn	(x=0X3D69);
	op_dec		(x,	1);
	set_cmt	(0X3D6E,	"-1 ; 0FFFFh",	0);
	set_cmt	(0X3D6F,	"set BDS offset 43 (dword) to -1\ndword [BDS.BPB_FSInfo] = 0FFFFFFFFh",	0);
	set_cmt	(0X3D71,	"ax = 0",	0);
	set_cmt	(0X3D72,	"clear BDS offset 47 to 59\n(BPB offset 41 to 53) (disksector offset 52 to 64)",	0);
	create_insn	(x=0X3D72);
	op_dec		(x,	1);
	set_cmt	(0X3D78,	"called by get_bpb?",	0);
	create_insn	(x=0X3D78);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3D82,	"conventional boot record?",	0);
	set_cmt	(0X3D84,	"signals that volume id is set",	0);
	create_insn	(x=0X3D84);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3D89);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3D90,	"reset flags in bds to not fchanged",	0);
	set_cmt	(0X3D95,	"BPB.FATSz16",	0);
	create_insn	(x=0X3D95);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3D95,	"mov_media_ids");
	set_cmt	(0X3D9C,	"[disksector+FAT32_EXT_BOOT.SIG],\n                    EXT_BOOT_SIGNATURE",	0);
	create_insn	(x=0X3D9C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X3DA3,	"[disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE",	0);
	create_insn	(x=0X3DA3);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X3DAF,	"BPB.FATSz16",	0);
	create_insn	(x=0X3DAF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3DB6,	"FAT32 system\nBS_FAT32_VolID",	0);
	create_insn	(x=0X3DB6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X3DB6,	"mmi_fat32");
	set_cmt	(0X3DBA,	"BS_FAT32_VolLab",	0);
	create_insn	(x=0X3DBA);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3DBD,	"BS_FAT32_FilSysType",	0);
	create_insn	(x=0X3DBD);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3DC2,	"BS_VolID",	0);
	create_insn	(x=0X3DC2);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3DC6,	"BS_VolLab",	0);
	create_insn	(x=0X3DC6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3DC9,	"BS_FilSysType",	0);
	create_insn	(x=0X3DC9);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3DCC,	"[es:di+BDS.vol_serial]\n(BDS offset 137)",	0);
	set_cmt	(0X3DD1,	"[es:di+BDS.vol_serial+2]",	0);
	create_insn	(x=0X3DD7);
	op_dec		(x,	1);
	set_cmt	(0X3DDA,	"di = di+125 = BDS.volid",	0);
	create_insn	(x=0X3DDA);
	op_dec		(x,	1);
	set_cmt	(0X3DDF,	"di = di+136",	0);
	set_cmt	(0X3DE1,	"BS_FilSysType or BS_FAT32_FilSysType",	0);
	set_cmt	(0X3DE3,	"di = di+141 = BDS.filesys_id",	0);
	set_cmt	(0X3DEC,	"this clc is not required (16/06/2019 - Erdogan Tan)\n(20/09/2022 - 27/06/2023) MSDOS 6.21 .. PCDOS 7.1",	0);
	create_insn	(0X3DEE);
	set_cmt	(0X3DF0,	"head 0",	0);
	create_insn	(0X3DF0);
	set_name	(0X3DF0,	"readfat");
	set_cmt	(0X3DF2,	"cylinder 0, sector 2",	0);
	set_cmt	(0X3DFA,	"media byte",	0);
	create_insn	(0X3DFD);
	set_name	(0X3DFD,	"read_sector");
	set_cmt	(0X3DFE,	"make 3 attempts",	0);
	set_cmt	(0X3E01,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X3E05,	"BIOSDATA:0152h",	0);
	create_insn	(x=0X3E05);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3E0E,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X3E0E);
	op_hex		(x,	0);
	set_cmt	(0X3E13,	"reset disk, decrement bp",	0);
	set_cmt	(0X3E18,	"[es:di+BDS.flags], fnon_removable\n(BDS offset 63)",	0);
	create_insn	(x=0X3E18);
	op_hex		(x,	1);
	create_insn	(x=0X3E1F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3E27,	"for retry, set the head settle time to 0Fh",	0);
	create_insn	(x=0X3E28);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3E2C,	"[si+DISK_PARMS.DISK_HEAD_STTL]",	0);
	set_cmt	(0X3E2F,	"NORMSETTLE",	0);
	create_insn	(x=0X3E2F);
	op_dec		(x,	1);
	create_insn	(x=0X3E34);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3E3E,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X3E3E);
	op_hex		(x,	0);
	create_insn	(x=0X3E42);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3E4A);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X3E4E);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3E52,	"[si+DISK_PARMS.DISK_HEAD_STTL]",	0);
	set_cmt	(0X3E5C,	"make sure we ask rom if media has changed",	0);
	create_insn	(0X3E5C);
	set_cmt	(0X3E5E,	"return error",	0);
	create_insn	(x=0X3E5F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3E63);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3E67,	"[es:di+BDS.track]\n(BDS offset 120)\nsave last track accessed on this drive",	0);
	set_cmt	(0X3E6F,	"restore flags",	0);
	create_insn	(x=0X3E72);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3E72,	"dsk_open");
	set_cmt	(0X3E77,	"done if no changeline support",	0);
	set_cmt	(0X3E79,	"get bds for drive",	0);
	set_cmt	(0X3E7C,	"[es:di+BDS.opcnt]\n(BDS offset 60)",	0);
	set_cmt	(0X3E80,	"CF is already ZERO here - Erdogan Tan",	0);
	set_name	(0X3E80,	"dsk_open_exit");
	create_insn	(x=0X3E82);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3E82,	"dsk_close");
	set_cmt	(0X3E87,	"done if no changeline support",	0);
	set_cmt	(0X3E89,	"get bds for drive",	0);
	set_cmt	(0X3E8C,	"[es:di+BDS.opcnt]",	0);
	set_cmt	(0X3E91,	"watch out for wrap",	0);
	set_cmt	(0X3E97,	"CF is already ZERO here - Erdogan Tan",	0);
	set_name	(0X3E97,	"exitjx");
	create_insn	(0X3E99);
	set_name	(0X3E99,	"dsk_rem");
	set_cmt	(0X3E9C,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X3E9C);
	op_hex		(x,	1);
	set_cmt	(0X3EA3,	"non_rem\nreturn busy status",	0);
	set_name	(0X3EA3,	"x_bus_exit");
	set_name	(0X3EA6,	"dsk_ret");
	set_cmt	(0X3EA7,	"write and verify",	0);
	create_insn	(x=0X3EA7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3EA7,	"dsk_writv");
	set_cmt	(0X3EAF,	"romwrite",	0);
	create_insn	(x=0X3EAF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3EAF,	"dsk_writ");
	set_cmt	(0X3EB5,	"prepare for rombios read/write",	0);
	set_name	(0X3EB5,	"dsk_cl");
	set_name	(0X3EB8,	"dsk_io");
	create_insn	(0X3EBD);
	set_name	(0X3EBD,	"dsk_read");
	create_insn	(0X3EC2);
	set_name	(0X3EC2,	"checksingle");
	set_cmt	(0X3EC4,	"[es:di+BDS.flags]",	0);
	set_cmt	(0X3EC8,	"fnon_removable|fi_own_physical",	0);
	create_insn	(x=0X3EC8);
	op_hex		(x,	1);
	set_cmt	(0X3ECD,	"fi_am_mult\nis there a drive sharing this physical drive?",	0);
	create_insn	(x=0X3ECD);
	op_hex		(x,	1);
	set_cmt	(0X3ED2,	"[es:di+BDS.drivenum]\nget physical drive number",	0);
	set_cmt	(0X3ED6,	"preserve pointer to current bds",	0);
	set_cmt	(0X3ED8,	"get first bds",	0);
	create_insn	(x=0X3ED8);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3EE0,	"Not our drive. Try next bds.",	0);
	set_cmt	(0X3EE2,	"fi_own_physical ; test ownership flag",	0);
	create_insn	(x=0X3EE2);
	op_hex		(x,	1);
	set_cmt	(0X3EE8,	"he doesn't own it either. continue",	0);
	set_cmt	(0X3EEA,	"reset ownership flag",	0);
	create_insn	(x=0X3EF4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3EFB,	"are we handling drive number 0 ?",	0);
	set_cmt	(0X3F02,	"[es:di+BDS.drivelet]\nget the DOS drive letter",	0);
	create_insn	(x=0X3F07);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3F0B,	"[es:LSTDRV]\nset up sdsb",	0);
	create_insn	(x=0X3F0B);
	set_cmt	(0X3F0F,	"restore bds pointer",	0);
	set_cmt	(0X3F12,	"if (single_drive_system)",	0);
	create_insn	(x=0X3F12);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3F1A,	"if (curr_drv == req_drv)",	0);
	create_insn	(x=0X3F21);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3F25,	"[es:LSTDRV]\nthen swap(curr_drv,req_drv)",	0);
	create_insn	(x=0X3F25);
	set_cmt	(0X3F2B,	"else",	0);
	set_cmt	(0X3F2D,	"swap(curr_drv,req_drv)",	0);
	set_cmt	(0X3F2E,	"issue swap_dsk_msg",	0);
	create_insn	(0X3F35);
	set_cmt	(0X3F38,	"-1  ; end of list?",	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_2(void) {
        auto x;
#define id x

	set_cmt	(0X3F3B,	"continue until hit end of list",	0);
	set_cmt	(0X3F3E,	"restore current bds",	0);
	set_cmt	(0X3F43,	"sector not found",	0);
	create_insn	(0X3F43);
	set_cmt	(0X3F47,	"unknown media",	0);
	create_insn	(0X3F47);
	set_name	(0X3F4A,	"ioret");
	set_cmt	(0X3F4B,	"DAP buffer",	0);
	create_byte	(x=0X3F4B);
	op_dec		(x,	0);
	set_name	(0X3F4B,	"LBA_Packet");
	create_byte	(0X3F4C);
	create_word	(0X3F4D);
	set_name	(0X3F4D,	"dap_block_cnt");
	create_word	(0X3F4F);
	make_array	(0X3F4F,	0X2);
	set_name	(0X3F4F,	"dap_trans_buf");
	create_word	(0X3F53);
	make_array	(0X3F53,	0X2);
	set_name	(0X3F53,	"dap_lba_value");
	create_byte	(0X3F57);
	make_array	(0X3F57,	0X4);
	set_cmt	(0X3F5B,	"romread",	0);
	create_insn	(x=0X3F5B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X3F5B,	"DISKRD");
	set_cmt	(0X3F60,	"al = drive number\ncx = sector count\ndx = first sector (low)\n[start_sec_h] = first sector (high)\n\nes:bx = transfer address",	0);
	create_insn	(0X3F60);
	set_name	(0X3F60,	"diskio");
	set_cmt	(0X3F62,	"save transfer segment",	0);
	create_insn	(x=0X3F62);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3F69,	"[es:di+BDS.media]",	0);
	create_insn	(x=0X3F6D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3F72,	"[es:di+BDS.flags+1]\n unformatted_media",	0);
	create_insn	(x=0X3F72);
	op_hex		(x,	1);
	set_cmt	(0X3F79,	"save sector count",	0);
	create_insn	(x=0X3F79);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3F7D,	"save sp",	0);
	create_insn	(x=0X3F7D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3F87);
	op_hex		(x,	1);
	set_cmt	(0X3F89,	"[es:di+BDS.totalsecs16]\n> 32 bit sector ?",	0);
	set_cmt	(0X3F94,	"[es:di+BDS.totalsecs16]",	0);
	create_insn	(x=0X3F9C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3FA0,	"[es:di+BDS.totalsecs32+2]",	0);
	set_cmt	(0X3FA8,	"[es:di+BDS.totalsecs32]",	0);
	create_insn	(x=0X3FAE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3FB2,	"[es:di+BDS.hiddensecs]",	0);
	set_cmt	(0X3FB6,	"[es:di+BDS.hiddensecs+2]",	0);
	set_cmt	(0X3FBA,	"save the sector number (low)",	0);
	create_insn	(x=0X3FBA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3FBE,	"0",	0);
	set_cmt	(0X3FC2,	"INT 1Eh vector address\n[es:DSKADR] - current disk parm table",	0);
	create_insn	(x=0X3FC2);
	create_insn	(x=0X3FC7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X3FCB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3FD0,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X3FD0);
	op_hex		(x,	1);
	set_cmt	(0X3FDA,	"do we have changeline support?",	0);
	create_insn	(x=0X3FDA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X3FDF,	"brif not",	0);
	set_cmt	(0X3FE7,	"[es:di+BDS.flags+1], fLBArw \nLBA read/write flag",	0);
	create_insn	(x=0X3FE7);
	op_hex		(x,	1);
	set_cmt	(0X3FF1,	"check for mini disk (logical dos drive/partition)",	0);
	create_insn	(x=0X3FF1);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X3FF4,	"[di+BDS.bdsm_ismini] ; logical dos partition",	0);
	set_cmt	(0X3FF9,	"not a logical dos partition/drive",	0);
	set_cmt	(0X3FFB,	"[di+BDS.bdsm_hidden_trks] (> 0)",	0);
	set_cmt	(0X4002,	"[es:di+BDS.hiddensecs]",	0);
	set_cmt	(0X4006,	"[es:di+BDS.hiddensecs+2]",	0);
	create_insn	(x=0X4018);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X401F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4029,	"verify op. retry cnt for write-verify",	0);
	create_insn	(x=0X4029);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X402D,	"soft ecc error retry count",	0);
	create_insn	(x=0X402D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4031,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X4035,	"get read/write indicator",	0);
	create_insn	(x=0X4035);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4039);
	op_hex		(x,	1);
	create_insn	(x=0X4041);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X4044,	"DISK - ",	0);
	create_insn	(x=0X4044);
	op_hex		(x,	0);
	set_cmt	(0X4051,	"Write fault (hard disk)",	0);
	create_insn	(x=0X4051);
	op_hex		(x,	1);
	create_insn	(x=0X405B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4063);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	create_insn	(x=0X406B);
	op_hex		(x,	1);
	set_cmt	(0X4070,	"DISK - IBM/MS Extension - VERIFY SECTORS\n (DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X4070);
	op_hex		(x,	0);
	set_cmt	(0X4075,	"ECC corrected data error (soft error - retried OK )",	0);
	create_insn	(x=0X4075);
	op_hex		(x,	1);
	create_insn	(x=0X407A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4083);
	op_hex		(x,	1);
	create_insn	(x=0X4088);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4091);
	op_hex		(x,	1);
	set_cmt	(0X409B,	"soft ecc error retry count",	0);
	create_insn	(x=0X409B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X40A3);
	create_insn	(0X40A6);
	set_cmt	(0X40AA,	"[es:di+BDS.secpertrack]\ndivide by sec per track",	0);
	create_insn	(x=0X40B1);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X40B4,	"[es:di+BDS.secpertrack]\nnow, bp:ax = track #, dx = sector\nsector number is 1 based.",	0);
	set_cmt	(0X40B7,	"save current sector",	0);
	create_insn	(x=0X40B7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X40BB,	"[es:di+BDS.heads]\nget number of heads",	0);
	set_cmt	(0X40C2,	"divide tracks by heads per cylinder",	0);
	set_cmt	(0X40C7,	"now, bp:ax = cylinder #, dx = head",	0);
	set_cmt	(0X40CE,	"2^10 currently maxium for track #.",	0);
	create_insn	(x=0X40CE);
	op_dec		(x,	1);
	set_cmt	(0X40D3,	"save current head",	0);
	create_insn	(x=0X40D3);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X40D7,	"save current track",	0);
	create_insn	(x=0X40D7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X40DA);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(0X40E4);
	set_cmt	(0X40E7,	"[es:di+BDS.drivenum]",	0);
	create_insn	(0X40E7);
	set_name	(0X40E7,	"iosetup");
	set_cmt	(0X40EB,	"save drive letter",	0);
	create_insn	(x=0X40EB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X40EE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X40F5,	"fetch up eot before changing ds",	0);
	create_insn	(x=0X40F5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X40F9,	"get pointer to disk base table",	0);
	create_insn	(x=0X40F9);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4100,	"[si+DISK_PARMS.DISK_MOTOR_STRT]",	0);
	create_insn	(x=0X4100);
	op_dec		(x,	1);
	set_cmt	(0X4103,	"[si+DISK_PARMS.DISK_EOT]",	0);
	create_insn	(x=0X4107);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X410A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X410F,	"get pointer to disk base table",	0);
	create_insn	(x=0X410F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4113,	"[es:di+BDS.formfactor], ffSmall",	0);
	create_insn	(x=0X4113);
	op_dec		(x,	0);
	set_cmt	(0X411C,	"[si+DISK_PARMS.DISK_MOTOR_STRT]",	0);
	create_insn	(x=0X411C);
	op_dec		(x,	1);
	set_cmt	(0X4121,	"ibm wants fast settle to be 1",	0);
	set_cmt	(0X4123,	"[si+DISK_PARMS.DISK_HEAD_STTL]\nget settle and set up for fast",	0);
	create_insn	(x=0X4127);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X412A,	"NORMSETTLE\nsomeone has diddled the settle",	0);
	create_insn	(x=0X412A);
	op_dec		(x,	1);
	create_insn	(x=0X412C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4130,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X4130);
	op_hex		(x,	1);
	set_name	(0X4130,	"done");
	set_cmt	(0X4135,	"do not set for non-removable media",	0);
	set_name	(0X413A,	"diddle_back");
	create_insn	(x=0X413B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4144);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4148);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X414B,	"[es:si+DISK_PARMS.DISK_EOT]",	0);
	create_insn	(x=0X414F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4152);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4156,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]",	0);
	set_cmt	(0X415A,	"[es:si+DISK_PARMS.DISK_SECTOR_SIZ]",	0);
	set_cmt	(0X415F,	"[es:si+DISK_PARMS.DISK_MOTOR_STRT]",	0);
	set_name	(0X4166,	"ddbx");
	create_insn	(0X4167);
	set_name	(0X4167,	"block");
	set_cmt	(0X416B,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X416B);
	op_hex		(x,	1);
	set_cmt	(0X4172,	"multrk_on",	0);
	create_insn	(x=0X4172);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X417F,	"[es:di+BDS.secpertrack]",	0);
	create_insn	(x=0X417F);
	op_dec		(x,	1);
	create_insn	(x=0X4184);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4199,	"reduce sectors-remaining by last i/o",	0);
	set_cmt	(0X419D,	"adjust transfer address",	0);
	create_insn	(0X41A1);
	set_cmt	(0X41A4,	"al = number of sectors (1-8, all on one track)\nes:di point to drive parameters\nxfer_seg:bx = transfer address \n     (must not cross a 64k physical boundary)\n[rflag] = 2 if read, 3 if write\n[verify] = 0 for normal, 1 for verify after write\n\nbp = MAXERR \n     retry_count",	0);
	create_insn	(0X41A4);
	set_name	(0X41A4,	"disk");
	set_cmt	(0X41A7,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X41A7);
	op_hex		(x,	1);
	set_cmt	(0X41AE,	"romverify ; Is this a track verify?",	0);
	set_cmt	(0X41B3,	"This is not verify so only 1 retry",	0);
	set_cmt	(0X41B6,	"verify op. retry cnt for write-verify",	0);
	create_insn	(x=0X41B6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X41BA,	"soft ecc error retry count",	0);
	create_insn	(x=0X41BA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X41BE,	"get read/write indicator",	0);
	create_insn	(x=0X41BE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X41C3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X41C7,	"[es:di+BDS.bdsm_ismini]\nis this a mini disk? ((logical dos partition))",	0);
	create_insn	(x=0X41C7);
	op_hex		(x,	1);
	set_cmt	(0X41CC,	"no. continue to next",	0);
	set_cmt	(0X41D5,	"[es:di+BDS.bdsm_hidden_trks]\nadd hidden tracks",	0);
	create_insn	(x=0X41D9);
	op_hex		(x,	1);
	create_insn	(x=0X41DB);
	op_hex		(x,	1);
	create_insn	(x=0X41DD);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X41E3,	"cl = sector, ch = cylinder",	0);
	set_cmt	(0X41E5,	"load current head number and",	0);
	create_insn	(x=0X41E5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X41E9,	"physical drive number\n[es:di+BDS.drivenum]",	0);
	set_cmt	(0X41ED,	"[es:di+BDS.formfactor], ffHardFile",	0);
	set_cmt	(0X41F2,	"hard files use fast speed",	0);
	set_cmt	(0X41F4,	"-1",	0);
	create_insn	(x=0X41F4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X41FB,	"romread",	0);
	set_cmt	(0X4200,	"romverify",	0);
	set_cmt	(0X420A,	"is there retry ?",	0);
	set_cmt	(0X420D,	"yes",	0);
	set_cmt	(0X420F,	"Undefined error (hard disk)",	0);
	create_insn	(x=0X420F);
	op_hex		(x,	1);
	create_insn	(x=0X4214);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4218,	"[es:di+BDS.track]",	0);
	set_cmt	(0X421C,	"check for write and verify",	0);
	create_insn	(x=0X421C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4225,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X4225);
	op_hex		(x,	1);
	set_cmt	(0X422C,	"multrk_on",	0);
	create_insn	(x=0X422C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X4233,	"eliminate cylinder bits from sector",	0);
	create_insn	(x=0X4233);
	op_hex		(x,	1);
	set_cmt	(0X4238,	"reduce count of sectors to go next sector",	0);
	create_insn	(x=0X4238);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X423E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4242,	"[es:di+BDS.secpertrack]\nsee if sector/track limit reached",	0);
	create_insn	(x=0X4248);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X424D);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4253,	"[es:di+BDS.heads]\nsee if head limit reached",	0);
	set_cmt	(0X4259,	"head 0",	0);
	set_cmt	(0X425B,	"next track",	0);
	create_insn	(x=0X425B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X425F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4265);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4269,	"we have changed drives",	0);
	set_cmt	(0X426B,	"[es:di+BDS.track]",	0);
	set_cmt	(0X426F,	"we are still on the same track",	0);
	create_insn	(0X4276);
	set_cmt	(0X427F,	"soft ecc error ?",	0);
	create_insn	(x=0X4284);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4288,	"no more retry",	0);
	set_cmt	(0X428D,	"retry",	0);
	create_insn	(0X428F);
	create_insn	(x=0X4292);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4298,	"do we have changeline support?",	0);
	create_insn	(x=0X4298);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X429D,	"brif not",	0);
	set_cmt	(0X42A2,	"multi trk format request?",	0);
	create_insn	(x=0X42A2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X42A7,	"no more retry",	0);
	set_cmt	(0X42AC,	"clear the flag",	0);
	create_insn	(x=0X42AC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X42B6,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X42B6);
	op_hex		(x,	1);
	set_cmt	(0X42BD,	"timeout?",	0);
	set_cmt	(0X42C2,	"write fault error?",	0);
	set_cmt	(0X42C5,	"then, don't retry.",	0);
	set_cmt	(0X42C7,	"MAXERR\nset soft_ecc_cnt back   to maxerr",	0);
	create_insn	(x=0X42C7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X42CD,	"restore sector count",	0);
	set_cmt	(0X42D1,	"just retry only once\nfor write fault error",	0);
	create_insn	(0X42D1);
	create_insn	(0X42D6);
	set_name	(0X42D6,	"harderr");
	set_cmt	(0X42D9,	"force a media check through rom",	0);
	create_insn	(x=0X42D9);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X42D9,	"harderr2");
	set_cmt	(0X42DE,	"get count of sectors to go",	0);
	create_insn	(x=0X42DE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X42E2,	"recover entry stack pointer",	0);
	create_insn	(x=0X42E2);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X42E9);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X42E9,	"normspeed");
	create_insn	(x=0X42F2);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X42F5,	"current disk parm table",	0);
	create_insn	(x=0X42F5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X42F9,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]",	0);
	create_insn	(x=0X4303);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4307,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]\n1 is fast settle value",	0);
	create_insn	(0X430D);
	set_name	(0X430D,	"fastspeed");
	create_insn	(x=0X430E);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4312,	"DISK - ",	0);
	create_insn	(x=0X4312);
	op_hex		(x,	0);
	create_insn	(x=0X4314);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X431A);
	set_name	(0X431A,	"maperror");
	set_cmt	(0X431D,	"set es=Bios_Data",	0);
	set_cmt	(0X4320,	"terminate list with error code",	0);
	create_insn	(x=0X4320);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4323,	"numerr (= errout-errin)\nnumber of possible error conditions",	0);
	create_insn	(x=0X4323);
	op_dec		(x,	1);
	create_insn	(x=0X4326);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X432B,	"[di+numerr-1]\nget translation",	0);
	create_insn	(x=0X432B);
	op_dec		(x,	1);
	set_cmt	(0X4331,	"flag error condition",	0);
	set_cmt	(0X4333,	"set the time of last access for this drive.\nthis is done only for removable media.\nes:di -> bds",	0);
	create_insn	(0X4333);
	set_name	(0X4333,	"set_tim");
	set_cmt	(0X4334,	"Does INT 1A ah=0 & updates daycnt",	0);
	set_cmt	(0X4337,	"[es:di+BDS.tim_lo]",	0);
	set_cmt	(0X433D,	"[es:di+BDS.tim_hi]",	0);
	set_cmt	(0X4343,	"the time has passed\nreset the threshold counter",	0);
	create_insn	(x=0X4343);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X4353);
	set_name	(0X4353,	"again");
	set_cmt	(0X4356,	"If it is a media change error\ndo not decrement retry count",	0);
	set_cmt	(0X435B,	"decrement retry count",	0);
	create_insn	(0X435D);
	create_byte	(0X4360);
	set_name	(0X4360,	"ioctl_drvnum");
	set_cmt	(0X4361,	"get physcial drive number\nINPUT: al = logical drive number (BDS.drivelet)\nOUTPUT: physical drive number (BDS.drivenum",	0);
	create_insn	(0X4361);
	set_name	(0X4361,	"get_phy_drv_num");
	set_cmt	(0X4364,	"[es:di+BDS.drivenum]",	0);
	create_insn	(0X4369);
	set_name	(0X4369,	"ioctl_output");
	create_insn	(x=0X4371);
	op_hex		(x,	1);
	set_cmt	(0X4376,	"DISK - Check for INT 13h Extensions\nBX = 55AAh, DL = drive number\nReturn: CF set if not supported\nAH = extensions version\nBX = AA55h\nCX = Interface support bit map",	0);
	create_insn	(x=0X4376);
	op_hex		(x,	0);
	create_insn	(x=0X437A);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X437A,	"ioctl_input_1");
	set_cmt	(0X437E,	"[es:di+IOCTL_REQ.MINORFUNCTION]",	0);
	create_insn	(x=0X437E);
	op_dec		(x,	1);
	set_cmt	(0X4384,	"Eject removable media",	0);
	set_cmt	(0X4387,	"al = 0 ; disk ioctl function = 0",	0);
	set_cmt	(0X438C,	"al = 1 ; disk ioctl function = 1",	0);
	set_cmt	(0X4392,	"Lock/unlock media\n(al, 0 = lock, 1 = unlock)",	0);
	set_cmt	(0X4395,	"unlock (reverse of INT 13h ah=45h)",	0);
	set_cmt	(0X439C,	"lock (reverse of INT 13h ah=45h)",	0);
	set_name	(0X43A3,	"ioctl_output_1");
	set_cmt	(0X43A8,	"DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X43A8);
	op_hex		(x,	0);
	set_name	(0X43AC,	"ioctl_lock_err");
	create_insn	(0X43AE);
	set_name	(0X43AE,	"ioctl_output_2");
	set_cmt	(0X43B0,	"volume not locked in drive",	0);
	set_name	(0X43B0,	"int13h_exts_err");
	set_cmt	(0X43B5,	"lock count exceeded",	0);
	create_insn	(0X43BD);
	set_name	(0X43BD,	"ioctl_input");
	set_cmt	(0X43C3,	"disk ioctl function = 6",	0);
	create_insn	(0X43C3);
	set_name	(0X43C3,	"ioctl_input_2");
	set_cmt	(0X43C9,	"get lock status",	0);
	set_cmt	(0X43CC,	"DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X43CC);
	op_hex		(x,	0);
	set_cmt	(0X43D0,	"bit 1 lock bit",	0);
	set_cmt	(0X43D3,	"not locked",	0);
	set_name	(0X43D9,	"ioctl_input_3");
	set_cmt	(0X43E1,	"DISK - VERIFY SECTORS\nAL = number of sectors to verify, CH = track, CL = sector\nDH = head, DL = drive\nReturn: CF set on error, AH = status\nAL = number of sectors verified",	0);
	create_insn	(x=0X43E1);
	op_hex		(x,	0);
	set_cmt	(0X43E4,	"no media in drive (IBM/MS INT 13 extensions)",	0);
	create_insn	(x=0X43E4);
	op_hex		(x,	1);
	set_cmt	(0X43E9,	"timeout (not ready)",	0);
	set_name	(0X43EE,	"ioctl_input_4");
	set_cmt	(0X43F4,	"bit 0 error bit (1 = error, 31h or 80h)\nbit 11 (not ready -removable media error- bit)\nif bit 11 = 0, another error (except 31h and 80h)",	0);
	create_insn	(x=0X43F4);
	op_hex		(x,	1);
	set_name	(0X43F4,	"ioctl_input_5");
	create_byte	(x=0X43FA);
	op_dec		(x,	0);
	set_name	(0X43FA,	"IoReadJumpTable");
	set_cmt	(0X43FB,	"60h",	0);
	create_word	(x=0X43FB);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X43FD,	"61h",	0);
	create_word	(x=0X43FD);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X43FF,	"62h",	0);
	create_word	(x=0X43FF);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4401,	"63h",	0);
	create_word	(x=0X4401);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4403,	"64h",	0);
	create_word	(x=0X4403);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4405,	"65h",	0);
	create_word	(x=0X4405);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4407,	"66h",	0);
	create_word	(x=0X4407);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4409,	"67h",	0);
	create_word	(x=0X4409);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X440B,	"68h",	0);
	create_word	(x=0X440B);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X440D,	"69h",	0);
	create_word	(x=0X440D);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X440F,	"6Ah",	0);
	create_word	(x=0X440F);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4411,	"6Bh",	0);
	create_word	(x=0X4411);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4413,	"6Ch",	0);
	create_word	(x=0X4413);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4415,	"6Dh",	0);
	create_word	(x=0X4415);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4417,	"6Eh",	0);
	create_word	(x=0X4417);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4419,	"6Fh",	0);
	create_word	(x=0X4419);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0X441B);
	set_name	(0X441B,	"IoWriteJumpTable");
	set_cmt	(0X441C,	"40h",	0);
	create_word	(x=0X441C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X441E,	"41h",	0);
	create_word	(x=0X441E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4420,	"42h",	0);
	create_word	(x=0X4420);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4422,	"43h",	0);
	create_word	(x=0X4422);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4424,	"44h",	0);
	create_word	(x=0X4424);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4426,	"45h",	0);
	create_word	(x=0X4426);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X4428,	"46h",	0);
	create_word	(x=0X4428);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X442A,	"47h",	0);
	create_word	(x=0X442A);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X442C,	"48h",	0);
	create_word	(x=0X442C);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_cmt	(0X442E,	"49h",	0);
	create_word	(x=0X442E);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	create_byte	(0X4430);
	make_array	(0X4430,	0XE);
	set_name	(0X4430,	"IOC_DC_Table");
	create_byte	(0X443E);
	set_name	(0X443E,	"new_genioctl");
	set_cmt	(0X443F,	"es:di points to bds for drive",	0);
	create_insn	(0X443F);
	set_name	(0X443F,	"do_generic_ioctl");
	set_cmt	(0X4442,	"0, old generic ioctl function",	0);
	set_cmt	(0X4449,	"es:bx points to request header",	0);
	create_insn	(x=0X4449);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X444D,	"[es:bx+IOCTL_REQ.MAJORFUNCTION],\nRAWIO",	0);
	set_cmt	(0X4454,	"1, new generic ioctl function (FAT32)",	0);
	set_cmt	(0X4459,	"Generic IOCtl Request support\n(called only if bit 6 of attribute is set to 1)",	0);
	create_insn	(x=0X4459);
	op_hex		(x,	1);
	set_cmt	(0X445E,	"[es:bx+IOCTL_REQ.MINORFUNCTION]",	0);
	set_name	(0X445E,	"chk_genioctl_minor");
	create_insn	(x=0X4465);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X4468,	"GEN_IOCTL_FN_TST ; test of req. function",	0);
	create_insn	(x=0X4468);
	op_hex		(x,	1);
	create_insn	(x=0X446C);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X446F,	"~GEN_IOCTL_FN_TST ; get rid of read/write",	0);
	create_insn	(x=0X446F);
	op_hex		(x,	1);
	set_name	(0X446F,	"NotGenericWrite");
	set_cmt	(0X4471,	"offset for base function",	0);
	create_insn	(x=0X4471);
	op_hex		(x,	1);
	set_cmt	(0X4486,	"Return this status in case of carry",	0);
	create_insn	(0X4489);
	set_name	(0X4489,	"Cmd_Error_Proc");
	set_name	(0X448A,	"IoctlFuncErr");
	set_cmt	(0X448D,	"ds:bx points to request header",	0);
	create_insn	(x=0X448D);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X448D,	"GetDeviceParameters");
	set_cmt	(0X4491,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]\n(ds:bx) = return buffer",	0);
	set_cmt	(0X4494,	"[es:di+BDS.formfactor]",	0);
	set_cmt	(0X4498,	"[bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]",	0);
	set_cmt	(0X449B,	"[es:di+BDS.flags]",	0);
	set_cmt	(0X449F,	"fnon_removable+fchangeline\nMask off other bits",	0);
	create_insn	(x=0X449F);
	op_hex		(x,	1);
	set_cmt	(0X44A2,	"[bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]",	0);
	set_cmt	(0X44A5,	"[es:di+BDS.cylinders]",	0);
	set_cmt	(0X44A9,	"[bx+A_DEVICEPARAMETERS.DP_CYLINDERS]",	0);
	set_cmt	(0X44AC,	"Set media type to default",	0);
	set_cmt	(0X44AE,	"[bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]",	0);
	set_cmt	(0X44B1,	"[di+BDS.rbytespersec] = [di+BDS.R_BPB]\n(copy recommended bpb)",	0);
	set_cmt	(0X44B4,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\nBUILD_DEVICE_BPB",	0);
	create_insn	(x=0X44B4);
	op_hex		(x,	1);
	set_cmt	(0X44BA,	"Point back to BIOSDATA",	0);
	set_cmt	(0X44C2,	"Build the bpb from scratch",	0);
	set_cmt	(0X44C8,	"[di+BDS.bytespersec] = [di+BSD.DP_BPB]\nUse this subfield of bds instead",	0);
	set_cmt	(0X44CB,	"[bx+A_DEVICEPARAMETERS.DP_BPB]\nThis is where the result goes",	0);
	set_name	(0X44CB,	"UseBpbPresent");
	set_cmt	(0X44D0,	"A_BPB.size = 31",	0);
	create_insn	(x=0X44D0);
	op_dec		(x,	1);
	set_cmt	(0X44D8,	"old type (FAT12 & FAT16) structure",	0);
	set_cmt	(0X44DA,	"FAT32 BPB size",	0);
	create_insn	(x=0X44DA);
	op_dec		(x,	1);
	set_cmt	(0X44DD,	"53+32 = 85 bytes (A_BPB_FAT32.size)",	0);
	create_insn	(x=0X44DD);
	op_dec		(x,	1);
	set_cmt	(0X44E0,	"reverse segments for copy",	0);
	set_name	(0X44E0,	"gdp_1");
	set_cmt	(0X44E6,	"0 or 32",	0);
	set_cmt	(0X44EA,	"32 zeros",	0);
	set_name	(0X44EE,	"gdp_2");
	set_name	(0X44EF,	"GetParmRet");
	set_cmt	(0X44F0,	"ds:bx points to request header",	0);
	create_insn	(x=0X44F0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X44F0,	"SetDeviceParameters");
	set_cmt	(0X44F4,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X44F7,	"[es:di+BDS.flags],\n fchanged_by_format|fchanged",	0);
	create_insn	(x=0X44F7);
	op_hex		(x,	1);
	set_cmt	(0X44FD,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n ONLY_SET_TRACKLAYOUT",	0);
	create_insn	(x=0X44FD);
	op_hex		(x,	1);
	set_cmt	(0X4505,	"[bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]",	0);
	create_insn	(0X4505);
	set_name	(0X4505,	"sdp_1");
	set_cmt	(0X4508,	"[es:di+BDS.formfactor]",	0);
	set_cmt	(0X450C,	"[bx+A_DEVICEPARAMETERS.DP_CYLINDERS]",	0);
	set_cmt	(0X450F,	"[es:di+BDS.cylinders]",	0);
	set_cmt	(0X4513,	"[bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]",	0);
	set_cmt	(0X4517,	"BIOSDATA segment",	0);
	create_insn	(x=0X451C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4522,	"we have changeline support",	0);
	create_insn	(x=0X4524);
	op_hex		(x,	1);
	set_cmt	(0X4527,	"Ignore all bits except non_removable and changeline\nfnon_removable|fchangeline",	0);
	create_insn	(x=0X4527);
	op_hex		(x,	1);
	set_name	(0X4527,	"HaveChange");
	set_cmt	(0X452A,	"[es:di+BDS.flags]",	0);
	set_cmt	(0X452E,	"~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)",	0);
	create_insn	(x=0X452E);
	op_hex		(x,	1);
	set_cmt	(0X4534,	"[es:di+BDS.flags]",	0);
	set_cmt	(0X4538,	"[bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]\nSet media type",	0);
	create_insn	(x=0X4541);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4544,	"FAT32 BPB size",	0);
	create_insn	(x=0X4544);
	op_dec		(x,	1);
	set_cmt	(0X454D,	"new type (FAT32) structure",	0);
	set_cmt	(0X454F,	"A_BPB.size = 31",	0);
	create_insn	(x=0X454F);
	op_dec		(x,	1);
	set_name	(0X4552,	"sdp_2");
	set_cmt	(0X4553,	"[es:di+BDS.flags],\nset_dasd_true (the next time we format a track)",	0);
	create_insn	(x=0X4553);
	op_hex		(x,	1);
	set_cmt	(0X455A,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n INSTALL_FAKE_BPB",	0);
	create_insn	(x=0X455A);
	op_hex		(x,	1);
	set_cmt	(0X455F,	"[es:di+BDS.flags], return_fake_bpb\nwere we returning a fake bpb when asked to build a bpb?",	0);
	create_insn	(x=0X455F);
	op_hex		(x,	1);
	set_cmt	(0X4567,	"[es:di+BDS.flags], ~return_fake_bpb\nwe were returning a fake bpb but we can stop now",	0);
	create_insn	(x=0X4567);
	op_hex		(x,	1);
	set_cmt	(0X456C,	"[di+BDS.R_BPB] = [di+BDS.rbytespersec]",	0);
	set_name	(0X456C,	"InstallRecommendedBpb");
	set_cmt	(0X4571,	"byte [es:di+BDS.flags], return_fake_bpb",	0);
	create_insn	(x=0X4571);
	op_hex		(x,	1);
	set_name	(0X4571,	"InstallFakeBpb");
	set_cmt	(0X4576,	"[es:di+BDS.BPB] = [es:di+BDS.bytespersec]",	0);
	set_cmt	(0X4579,	"[bx+A_DEVICEPARAMETERS.DP_BPB]",	0);
	set_name	(0X4579,	"CopyTheBpb");
	set_cmt	(0X457E,	"Save packet segment",	0);
	set_cmt	(0X457F,	"BIOSDATA segment",	0);
	set_cmt	(0X4589,	"[bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]\noffset 85+7 (A_BPB.size+7) (FAT32)",	0);
	set_name	(0X4589,	"setTrackTable");
	set_cmt	(0X4592,	"new type (FAT32) structure",	0);
	set_cmt	(0X4594,	"[bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]\noffset 31+7 (A_BPB.size+7)",	0);
	set_name	(0X4597,	"sdp_3");
	create_insn	(x=0X459D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X45A2,	"[es:di+BDS.flags], ~good_tracklayout",	0);
	create_insn	(x=0X45A2);
	op_hex		(x,	1);
	set_cmt	(0X45A7,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n TRACKLAYOUT_IS_GOOD",	0);
	create_insn	(x=0X45A7);
	op_hex		(x,	1);
	set_cmt	(0X45AC,	"[es:di+BDS.flags], good_tracklayout",	0);
	create_insn	(x=0X45AC);
	op_hex		(x,	1);
	set_cmt	(0X45B1,	"MAX_SECTORS_IN_TRACK",	0);
	create_insn	(x=0X45B1);
	op_dec		(x,	1);
	set_name	(0X45B1,	"UglyTrackLayOut");
	create_insn	(x=0X45B8);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X45BB,	"[bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]\noffset 85+9 (A_BPB.size+9) (FAT32)",	0);
	set_cmt	(0X45C4,	"new type (FAT32) structure",	0);
	set_cmt	(0X45C6,	"[bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]\noffset 31+9 (A_BPB.size+9)",	0);
	set_cmt	(0X45C9,	"BIOSDATA segment\nTrash our bds pointer",	0);
	set_name	(0X45C9,	"sdp_4");
	set_name	(0X45CE,	"StoreSectorInfo");
	set_cmt	(0X45CF,	"Skip over cylinder and head",	0);
	set_cmt	(0X45D0,	"Get sector id",	0);
	set_cmt	(0X45D1,	"Copy it",	0);
	set_cmt	(0X45D2,	"Get sector size\n\nSectSizeToSectIndex:\n    Input:  ax contains sector size in bytes\n    Output: al contains index",	0);
	set_cmt	(0X45D3,	"> 512 bytes per sector ?",	0);
	set_cmt	(0X45D6,	"yes",	0);
	set_cmt	(0X45D8,	"set index to 2 or 1 (256 bps) or 0 (128 bps)",	0);
	set_cmt	(0X45DC,	"1024 bytes per sector\nset index to 3",	0);
	create_insn	(0X45DC);
	set_name	(0X45DC,	"OneK");
	set_name	(0X45DE,	"sdp_5");
	set_name	(0X45E1,	"SectorInfoSaved");
	create_insn	(0X45E3);
	set_name	(0X45E3,	"TooManyPerTrack");
	create_insn	(x=0X45E7);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X45E7,	"FormatTrack");
	set_cmt	(0X45EB,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X45EE,	"bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n STATUS_FOR_FORMAT",	0);
	create_insn	(x=0X45EE);
	op_hex		(x,	1);
	set_cmt	(0X45F9,	"Also moves current Dpt to TempDpt",	0);
	set_cmt	(0X45FD,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]",	0);
	set_cmt	(0X4601,	"[es:di+BDS.formfactor], DEV_HARDDISK",	0);
	create_insn	(0X4601);
	set_name	(0X4601,	"DoFormatTrack");
	set_cmt	(0X4610,	"[bx+A_FORMATPACKET.FP_HEAD]",	0);
	create_insn	(0X4610);
	set_name	(0X4610,	"DoFormatDiskette");
	set_cmt	(0X4613,	"[bx+A_FORMATPACKET.FP_CYLINDER]",	0);
	set_cmt	(0X4616,	"[bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]\n    FP_TRACKCOUNT is only meaningful\n    when FP_SPECIALFUNCTIONS bit 1 = 1",	0);
	create_insn	(x=0X4616);
	op_hex		(x,	1);
	set_cmt	(0X4623,	"Also moves current Dpt to TempDpt",	0);
	create_insn	(0X4623);
	set_name	(0X4623,	"DoFormatDiskette_1");
	set_cmt	(0X4628,	"Old rom",	0);
	set_cmt	(0X462A,	"Time out error?",	0);
	set_cmt	(0X462C,	"No,fine. (at this point, don't care\nabout the illegal combination)",	0);
	create_insn	(0X4630);
	set_name	(0X4630,	"NeedToSetDasd");
	set_cmt	(0X4631,	"INT 13h, ah=17h",	0);
	set_cmt	(0X4635,	"Do any needed diskette swapping",	0);
	set_name	(0X4635,	"NoSetDasd");
	set_cmt	(0X4638,	"Get track from packet",	0);
	create_insn	(x=0X463A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X463D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4643);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4646);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X464C,	"Store into TrackTable",	0);
	set_name	(0X464C,	"StoreCylinderHead");
	set_cmt	(0X464E,	"Skip to next sector field",	0);
	set_cmt	(0X4653,	"MAXERR - Set up retry count",	0);
	set_name	(0X4653,	"set_fmt_retry_count");
	set_cmt	(0X4655,	"Now verify the sectors just formatted.\nNOTE: because of bug in some BIOSes \n      we have to set ES:BX to 00:00",	0);
	set_name	(0X4655,	"FormatRetry");
	create_insn	(x=0X4656);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4659);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X465C,	"romformat",	0);
	create_insn	(x=0X465E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X466C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4670);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4673,	"romverify",	0);
	set_name	(0X467E,	"FormatError");
	create_insn	(x=0X4681);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4693,	"WhileErr");
	set_cmt	(0X4698,	"Set the format error flag",	0);
	create_insn	(x=0X4698);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4698,	"FormatFailed");
	set_cmt	(0X469D,	"DSK_CHANGELINE_ERR\nconvert change line error to time out error",	0);
	set_cmt	(0X46A2,	"DSK_TIMEOUT_ERR",	0);
	set_name	(0X46A4,	"DoMapIt");
	set_cmt	(0X46A7,	"reset the format error flag",	0);
	create_insn	(x=0X46A7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X46A7,	"FormatOk");
	create_insn	(0X46AD);
	set_name	(0X46AD,	"VerifyTrack");
	set_cmt	(0X46AE,	"ds:bx points to request header.",	0);
	create_insn	(x=0X46AE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X46B2,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X46B5,	"[bx+A_VERIFYPACKET.VP_CYLINDER]",	0);
	set_cmt	(0X46B8,	"[bx+A_VERIFYPACKET.VP_HEAD]",	0);
	set_cmt	(0X46BB,	"[bx+A_FORMATPACKET.FP_TRACKCOUNT]",	0);
	set_cmt	(0X46BE,	"[bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]",	0);
	set_cmt	(0X46C1,	"romverify",	0);
	create_insn	(x=0X46C1);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X46C6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X46CA,	"assume heads < 256",	0);
	create_insn	(x=0X46CA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X46CD);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X46D1,	"DO_FAST_FORMAT",	0);
	create_insn	(x=0X46D1);
	op_hex		(x,	1);
	set_cmt	(0X46D6,	"Get ax = number of trks to verify",	0);
	set_cmt	(0X46DA,	"#tracks > 255",	0);
	set_cmt	(0X46E4,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X46E4);
	op_hex		(x,	1);
	set_cmt	(0X46EC,	"MULTI_TRK_ON",	0);
	create_insn	(x=0X46EC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	create_insn	(x=0X46F4);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X46F9,	"1st sector",	0);
	set_name	(0X46F9,	"NormVerifyTrack");
	set_cmt	(0X46FD,	"Use 0:0 as the transfer address for verify",	0);
	create_insn	(x=0X46FD);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4704);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X470A);
	set_name	(0X470A,	"VerifyTrack_Err");
	set_cmt	(0X470F,	"romread",	0);
	create_insn	(x=0X470F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X470F,	"ReadTrack");
	create_insn	(x=0X4716);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4716,	"WriteTrack");
	set_name	(0X471B,	"ReadWriteTrack");
	set_cmt	(0X471C,	"es:bx -> to request header",	0);
	create_insn	(x=0X471C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4720,	"[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4724,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]",	0);
	create_insn	(x=0X4728);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X472B,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]",	0);
	set_cmt	(0X472F,	"Assume heads < 256 !",	0);
	create_insn	(x=0X472F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4732,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]",	0);
	set_cmt	(0X4736,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]",	0);
	set_cmt	(0X473A,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]\nGet transfer address",	0);
	set_cmt	(0X473E,	"Pass transfer segment",	0);
	create_insn	(x=0X473E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4743,	"performs track read/write/verify\n\n input:\n  rFlag - 2 = read\n          3 = write\n          4 = verify\n  ax - Index into track table of first sector to io\n  cx - Number of sectors to io\n  Xfer_Seg:bx - Transfer address\n  es:di - Pointer to bds\n  CurTrk - Current cylinder\n  CurHd - Current head",	0);
	create_insn	(x=0X4743);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4743,	"TrackIo");
	set_cmt	(0X474A,	"See if we have already set disk",	0);
	create_insn	(x=0X474A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4751,	"set up tables and variables for i/o",	0);
	set_cmt	(0X4758,	"Point si at the table entry of the          \nfirst sector to be io'd",	0);
	create_insn	(x=0X4758);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4764,	"[es:di+BDS.flags], good_tracklayout",	0);
	create_insn	(x=0X4764);
	op_hex		(x,	1);
	set_cmt	(0X476C,	"We can read all secs in one blow",	0);
	set_cmt	(0X4771,	"Skip over the cylinder and head in\nthe track table",	0);
	set_cmt	(0X4772,	"Get sector ID from track table",	0);
	create_insn	(x=0X4773);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4776,	"[es:di+BDS.flags], fnon_removable\nFixed disk?",	0);
	create_insn	(x=0X4776);
	op_hex		(x,	1);
	set_cmt	(0X477C,	"No",	0);
	set_cmt	(0X477E,	"MULTI_TRK_ON",	0);
	create_insn	(x=0X477E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X4784,	"No,don't do that.",	0);
	create_insn	(x=0X4786);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4793,	"Get sector size index from track\ntable and save it",	0);
	create_insn	(0X4793);
	set_cmt	(0X4796,	"Save BIOSDATA",	0);
	set_cmt	(0X4798,	"Preserve whatever might be in ah\nFetch EOT while ds-> BIOSDATA",	0);
	create_insn	(x=0X4798);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X479C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X47A0,	"[si+DISK_PARMS.DISK_SECTOR_SIZ]",	0);
	set_cmt	(0X47A3,	"[si+DISK_PARMS.DISK_EOT]",	0);
	create_insn	(x=0X47AA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X47B0,	"Advance buffer pointer by adding\nsector size",	0);
	set_cmt	(0X47B2,	"SectorSizeIndexToSectorSize",	0);
	create_insn	(x=0X47BF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X47C6,	"set time of last access, and reset\nentries in Dpt.",	0);
	set_cmt	(0X47CB,	"See if we've previously set dasd type",	0);
	create_insn	(x=0X47CB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X47CB,	"SetDasd");
	set_cmt	(0X47D2,	"[es:di+BDS.flags], set_dasd_true",	0);
	create_insn	(x=0X47D2);
	op_hex		(x,	1);
	set_cmt	(0X47DA,	"[es:di+BDS.flags], ~set_dasd_true",	0);
	create_insn	(x=0X47DA);
	op_hex		(x,	1);
	set_cmt	(0X47E0,	"Reset it",	0);
	create_insn	(x=0X47E0);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X47E5,	"Format gap for 48tpi disks",	0);
	create_insn	(x=0X47E5);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X47EC,	"[es:di+BDS.formfactor]",	0);
	set_cmt	(0X47F0,	"DEV_3INCH720KB",	0);
	set_cmt	(0X47F5,	"DEV_5INCH96TPI",	0);
	set_cmt	(0X47FC,	"mov al, 2\n160/320k in a 1.2 meg drive",	0);
	create_insn	(x=0X47FD);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4804,	"mov al, 3\n1.2meg in a 1.2meg drive",	0);
	set_cmt	(0X4805,	"Format gap for 96 tpi, 1.2MB diskette",	0);
	create_insn	(x=0X4805);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X480E,	"0",	0);
	set_cmt	(0X4810,	"[DSKADR] (Int 1Eh)",	0);
	create_insn	(x=0X4810);
	set_cmt	(0X4814,	"[si+DISK_PARMS.DISK_HEAD_STTL]",	0);
	set_cmt	(0X4820,	"DISK - SET TYPE (AT,XT2,XT286,CONV,PS\nAL = disk type",	0);
	create_insn	(x=0X4820);
	op_hex		(x,	0);
	set_cmt	(0X4822,	"[es:di+BDS.secpertrack]",	0);
	create_insn	(x=0X4826);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X482B);
	set_name	(0X482B,	"SetMediaForFormat");
	create_insn	(x=0X482D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4834,	"If already done return 0",	0);
	create_insn	(x=0X4836);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X483D,	"Media already set",	0);
	create_insn	(0X4840);
	set_cmt	(0X4844,	"0 ; Point to interrupt vectors",	0);
	set_cmt	(0X4846,	"[es:DSKADR]\nGet pointer to disk base table",	0);
	create_insn	(x=0X4846);
	create_insn	(x=0X484B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X484F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4853,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]",	0);
	set_cmt	(0X485A,	"[es:di+BDS.cylinders]",	0);
	create_insn	(x=0X485F);
	op_hex		(x,	1);
	create_insn	(x=0X4862);
	op_hex		(x,	1);
	create_insn	(x=0X4864);
	op_hex		(x,	1);
	set_cmt	(0X4868,	"[es:di+BDS.secpertrack]",	0);
	set_cmt	(0X486C,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X4876,	"DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)\nDL = drive number, CH = lower 8 bits of number of tracks, \nCL = sectors per track",	0);
	create_insn	(x=0X4876);
	op_hex		(x,	0);
	create_insn	(x=0X487A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4886,	"[es:DSKADR] (Int 1Eh)\nGet current disk base table",	0);
	create_insn	(x=0X4886);
	create_insn	(x=0X488B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X488F,	"Save it",	0);
	create_insn	(x=0X488F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4895,	"0",	0);
	set_cmt	(0X4897,	"replace with one returned by rom",	0);
	create_insn	(x=0X4897);
	create_insn	(x=0X489C);
	create_insn	(x=0X48A1);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X48A6,	"Legal combination + rom support code",	0);
	set_cmt	(0X48A8,	"Reset the flag",	0);
	create_insn	(x=0X48A8);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X48AD,	"DSK_ILLEGAL_COMBINATION\nIllegal combination = 0Ch",	0);
	create_insn	(0X48AD);
	set_cmt	(0X48B2,	"DSK_TIMEOUT_ERR",	0);
	set_cmt	(0X48B7,	"Function not supported.",	0);
	set_cmt	(0X48BB,	"Function supported, but\nIllegal sect/trk,trk combination.",	0);
	create_insn	(0X48BB);
	set_cmt	(0X48BF,	"Function supported, but\nMedia not present",	0);
	create_insn	(0X48BF);
	create_insn	(0X48C8);
	set_name	(0X48C8,	"ResetDisk");
	set_cmt	(0X48C9,	"Reset while formatting?",	0);
	create_insn	(x=0X48CC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X48D2,	"Then verify operation in \"fmt & vrfy\"\nMight have failed.\nSo signals that we had a format error.",	0);
	create_insn	(x=0X48D2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X48D5,	"DISK - RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)",	0);
	create_insn	(x=0X48D5);
	op_hex		(x,	0);
	set_cmt	(0X48D7,	"-1\nZap up the speed",	0);
	create_insn	(x=0X48D7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X48DE);
	set_name	(0X48DE,	"ToRom");
	create_insn	(x=0X48E0);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X48E8,	"Save bds segment",	0);
	set_cmt	(0X48E9,	"[es:di+BDS.formfactor], ffSmall\nis it a 3.5\" drive?",	0);
	set_cmt	(0X48EE,	"0",	0);
	create_insn	(x=0X48EE);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X48F2,	"Get pointer to disk base table",	0);
	create_insn	(x=0X48F2);
	set_cmt	(0X48F7,	"Save pointer to table",	0);
	create_insn	(x=0X48F7);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X48FB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X48FF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4902,	"[es:si+DISK_PARMS.DISK_EOT]",	0);
	create_insn	(x=0X4906);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4909,	"[es:si+DISK_PARMS.DISK_FORMT_GAP]\nImportant for format",	0);
	set_cmt	(0X490D,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]\nAssume we are doing a seek operation\nSetup motor start correctly for 3.5\" drives",	0);
	create_insn	(x=0X490D);
	op_hex		(x,	1);
	set_cmt	(0X4914,	"[es:si+DISK_PARMS.DISK_MOTOR_STRT]",	0);
	set_cmt	(0X4919,	"Restore bds segment",	0);
	set_cmt	(0X491B,	"Set track number",	0);
	create_insn	(x=0X491B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X491F,	"Set low 8 bits in ch",	0);
	set_cmt	(0X4921,	"Set drive number",	0);
	set_cmt	(0X4925,	"Set head number",	0);
	create_insn	(x=0X4925);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4929,	"Save bds segment",	0);
	create_insn	(x=0X492A);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X492E,	"DISK - ",	0);
	create_insn	(x=0X492E);
	op_hex		(x,	0);
	set_cmt	(0X4930,	"Restore bds segment",	0);
	create_insn	(0X4934);
	set_name	(0X4934,	"ioctl_getown");
	set_cmt	(0X4937,	"[es:di+BDS.drivenum]\nGet physical drive number",	0);
	set_cmt	(0X493B,	"Get start of bds chain",	0);
	create_insn	(x=0X493B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X493F,	"[es:di+BDS.drivenum]",	0);
	set_name	(0X493F,	"ownloop");
	set_cmt	(0X4945,	"[es:di+BDS.flags], fi_own_physical",	0);
	create_insn	(x=0X4945);
	op_hex		(x,	1);
	set_cmt	(0X494D,	"[es:di+BDS.link]",	0);
	set_name	(0X494D,	"getnextBDS");
	create_insn	(0X4952);
	set_name	(0X4952,	"ioctl_setown");
	set_cmt	(0X4955,	"set flag for CheckSingle to look at.",	0);
	create_insn	(x=0X4955);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X495D,	"0 ; set ownership of drive reset flag",	0);
	create_insn	(x=0X495D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4961,	"exitown");
	set_cmt	(0X4963,	"[es:di+BDS.flags], fi_am_mult",	0);
	create_insn	(x=0X4963);
	op_hex		(x,	1);
	set_cmt	(0X496B,	"[es:di+BDS.drivelet]\nGet logical drive number",	0);
	set_cmt	(0X496F,	"Get it 1-based",	0);
	create_insn	(x=0X4970);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4974,	"[bx+unit]\nExit normal termination",	0);
	create_insn	(0X4979);
	set_name	(0X4979,	"RestoreOldDpt");
	set_cmt	(0X497C,	"Reset flag and",	0);
	create_insn	(x=0X497C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X497F,	"get current flag setting",	0);
	create_insn	(x=0X497F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X498A);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4993,	"es = 0",	0);
	create_insn	(x=0X4993);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4998,	"[es:DSKADR] (Int 1Eh)",	0);
	create_insn	(x=0X4998);
	set_cmt	(0X499D,	"[es:DSKADR+2]",	0);
	create_insn	(x=0X499D);
	set_cmt	(0X49A8,	"get volume serial number",	0);
	create_insn	(0X49A8);
	set_name	(0X49A8,	"GetMediaId");
	set_cmt	(0X49AB,	"[es:di+BDS.drivelet] ; Logical drive number",	0);
	set_cmt	(0X49AF,	"Read operation",	0);
	create_insn	(x=0X49AF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X49B4,	"Read boot sector into DiskSector",	0);
	set_cmt	(0X49B9,	"Valid? (0F0h-0FFh?)",	0);
	create_insn	(x=0X49B9);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X49BE,	"brif not valid (0F0h - 0FFh)",	0);
	set_cmt	(0X49C0,	"BS_FAT32_VolID",	0);
	create_insn	(x=0X49C0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X49C3,	"BPB.FATSz16",	0);
	create_insn	(x=0X49C3);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X49C8,	"FAT32 fs",	0);
	set_cmt	(0X49CA,	"FAT (12-16) fs ; 43h-1Ch = 27h ; BS_VolID",	0);
	create_insn	(x=0X49CA);
	op_hex		(x,	1);
	set_cmt	(0X49CD,	"si-1 = offset disksector+26h (FAT)\n      or  = offset disksector+42h (FAT32)\n            disksector+EXT_BOOT.SIG\nBS_BootSig",	0);
	create_insn	(x=0X49CD);
	op_hex		(x,	1);
	set_name	(0X49CD,	"IOCtl_If3");
	create_insn	(x=0X49D3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X49D7,	"[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	create_insn	(x=0X49D7);
	op_dec		(x,	1);
	set_cmt	(0X49DB,	"A_MEDIA_ID_INFO.MI_SERIAL",	0);
	set_cmt	(0X49DE,	"size_of_EXT_BOOT_SERIAL\n+ size_of_EXT_BOOT_VOL_LABEL\n+ size_of_EXT_SYSTEM_ID",	0);
	create_insn	(x=0X49DE);
	op_dec		(x,	1);
	set_name	(0X49DE,	"IOCtl_If4");
	create_insn	(0X49E5);
	set_name	(0X49E5,	"IOCtl_If2");
	set_name	(0X49E8,	"IOCtl_If1");
	create_insn	(0X49E9);
	set_name	(0X49E9,	"SetMediaId");
	set_cmt	(0X49EC,	"[es:di+BDS.drivelet]\nLogical drive number",	0);
	set_cmt	(0X49F2,	"romread",	0);
	create_insn	(x=0X49F2);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X49F8,	"Read boot sector to BIOSDATA:DiskSector",	0);
	set_cmt	(0X49FE,	"Valid? (0F0h-0FFh?)\n[disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]",	0);
	create_insn	(x=0X49FE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4A03,	"Brif not",	0);
	set_cmt	(0X4A09,	"disksector+EXT_BOOT.SERIAL",	0);
	create_insn	(x=0X4A09);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4A0C,	"BPB.FATSz16",	0);
	create_insn	(x=0X4A0C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4A11,	"FAT32 fs",	0);
	set_cmt	(0X4A13,	"67-28 ; offset disksektor+27h",	0);
	create_insn	(x=0X4A13);
	op_hex		(x,	1);
	set_cmt	(0X4A16,	"[disksector+EXT_BOOT.SIG], EXT_BOOT_SIGNATURE",	0);
	create_insn	(x=0X4A16);
	op_hex		(x,	1);
	set_name	(0X4A16,	"IOCtl_If5");
	set_cmt	(0X4A1C,	"not extended boot record",	0);
	create_insn	(x=0X4A20);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4A20,	"IOCtl_If8");
	set_cmt	(0X4A24,	"[si+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4A27,	"A_MEDIA_ID_INFO.MI_SERIAL",	0);
	set_cmt	(0X4A2A,	"copy volume serial, label and system id",	0);
	set_cmt	(0X4A2D,	"point ds back to BIOSDATA",	0);
	set_cmt	(0X4A2F,	"restore bds pointer",	0);
	set_cmt	(0X4A31,	"update the bds media id info.",	0);
	set_cmt	(0X4A36,	"romwrite",	0);
	create_insn	(x=0X4A36);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4A3B,	"write it back",	0);
	set_cmt	(0X4A3E,	"make sure chk_media check the driver\nreturn with error code from BootIo",	0);
	create_insn	(x=0X4A3E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4A44,	"error_unknown_media",	0);
	create_insn	(0X4A44);
	set_name	(0X4A44,	"IOCtl_If7");
	set_name	(0X4A47,	"IOCtl_If6");
	create_insn	(0X4A48);
	set_name	(0X4A48,	"BootIo");
	set_cmt	(0X4A4D,	"es:di -> transfer address",	0);
	create_insn	(x=0X4A4D);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4A50,	"First sector (h) -> 0",	0);
	set_cmt	(0X4A52,	"Start sector (h) -> 0",	0);
	create_insn	(x=0X4A52);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4A60,	"[es:di+BDS.drivenum]",	0);
	create_insn	(0X4A60);
	set_name	(0X4A60,	"ChangeLineChk");
	set_cmt	(0X4A64,	"Fixed disk?",	0);
	set_cmt	(0X4A68,	"[es:di+BDS.flags], return_fake_bpb",	0);
	create_insn	(x=0X4A68);
	op_hex		(x,	1);
	set_cmt	(0X4A70,	"This rom support change line?",	0);
	create_insn	(x=0X4A70);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4A75,	"no",	0);
	set_cmt	(0X4A7A,	"Do nothing",	0);
	set_cmt	(0X4A7E,	"DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)\nDL = drive to check\nReturn: AH = disk change status",	0);
	create_insn	(x=0X4A7E);
	op_hex		(x,	0);
	set_cmt	(0X4A83,	"fchanged\nUpdate flag in BDS for this physical drive",	0);
	create_insn	(x=0X4A83);
	op_hex		(x,	1);
	set_cmt	(0X4A8B,	"ds:bx points to request header",	0);
	create_insn	(x=0X4A8B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4A8B,	"GetAccessFlag");
	set_cmt	(0X4A8F,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4A92,	"Assume result is unformatted",	0);
	set_cmt	(0X4A94,	"[es:di+BDS.flags], unformatted_media",	0);
	create_insn	(x=0X4A94);
	op_hex		(x,	1);
	set_cmt	(0X4A9A,	"Done if unformatted",	0);
	set_cmt	(0X4A9C,	"Return true for formatted",	0);
	set_cmt	(0X4A9D,	"[bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]",	0);
	set_name	(0X4A9D,	"GafDone");
	set_cmt	(0X4AA1,	"ds:bx points to request header",	0);
	create_insn	(x=0X4AA1);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4AA1,	"SetAccessFlag");
	set_cmt	(0X4AA5,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4AA8,	"[es:di+BDS.flags], ~unformatted_media",	0);
	create_insn	(x=0X4AA8);
	op_hex		(x,	1);
	set_cmt	(0X4AAE,	"[bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]",	0);
	set_cmt	(0X4AB4,	"[es:di+BDS.flags], unformatted_media",	0);
	create_insn	(x=0X4AB4);
	op_hex		(x,	1);
	set_name	(0X4ABA,	"saf_Done");
	create_insn	(0X4ABB);
	set_name	(0X4ABB,	"ioctl_support_query");
	set_cmt	(0X4ABC,	"es:bx points to request header.",	0);
	create_insn	(x=0X4ABC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4AC0,	"[es:bx+IOCTL_REQ.MAJORFUNCTION]\nal == Major, ah == Minor",	0);
	set_cmt	(0X4AC4,	"IOC_NEW_DC\nnew generic ioctl function (FAT32)",	0);
	create_insn	(x=0X4AC4);
	op_hex		(x,	1);
	set_cmt	(0X4AC8,	"IOC_DC\n(old) generic ioctl function (FAT12-FAT16)",	0);
	set_name	(0X4ACC,	"ioctl_support");
	set_cmt	(0X4ACE,	"IOC_DC_TABLE_LEN",	0);
	create_insn	(x=0X4ACE);
	op_dec		(x,	1);
	create_insn	(x=0X4AD1);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	create_insn	(0X4AE0);
	set_name	(0X4AE0,	"nosupport");
	set_cmt	(0X4AE4,	"ds:bx points to request header.",	0);
	create_insn	(x=0X4AE4);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4AE4,	"SenseMediaType");
	set_cmt	(0X4AE8,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4AEB,	"0 ; Initialize the 2 packet bytes",	0);
	set_cmt	(0X4AED,	"invalidate drive type (byte 1) \nand default type flag (byte 0)",	0);
	set_cmt	(0X4AEF,	"[es:di+BDS.drivenum]",	0);
	create_insn	(x=0X4AF3);
	op_hex		(x,	1);
	set_cmt	(0X4AF5,	"Compaq, ATAPI Removable Media Device\nGET CURRENT MEDIA FORMAT\n  AH = 20h\n  DL = drive number (00h,01h)\nReturn: CF clear if successful\n  AL = media type\n  AH = 00h\n  CF set on error\n     AH = error code\n\n(Ref: Ralf Brown's Interrupt List, INTERRUP.B)",	0);
	create_insn	(x=0X4AF5);
	op_hex		(x,	0);
	set_cmt	(0X4AF9,	"[bx+A_MEDIA_SENSE.MS_ISDEFAULT]\n1 = default media type",	0);
	set_cmt	(0X4AFB,	"3 -> 2, 4 -> 3, 6 -> 5",	0);
	set_name	(0X4AFB,	"DetermineMediaType");
	set_cmt	(0X4AFD,	"3.5 inch, 720 KB",	0);
	set_cmt	(0X4B01,	"3 -> 6, 4 -> 7, 6 -> 9",	0);
	set_cmt	(0X4B03,	"3.5 inch, 1.44 MB",	0);
	set_cmt	(0X4B07,	"3.5 inch, 2.88 MB",	0);
	set_cmt	(0X4B09,	"Just didn't recognize media type",	0);
	set_cmt	(0X4B0B,	"[bx+A_MEDIA_SENSE.MS_DEVICETYPE]",	0);
	set_name	(0X4B0B,	"GotMediaType");
	set_cmt	(0X4B10,	"non-default media / \ndrive does not support media type",	0);
	create_insn	(x=0X4B10);
	op_hex		(x,	1);
	set_name	(0X4B10,	"MediaSenseErr");
	set_cmt	(0X4B15,	"function supported but, drive not ready",	0);
	set_cmt	(0X4B17,	"no such drive / media not present",	0);
	create_insn	(x=0X4B17);
	op_hex		(x,	1);
	set_cmt	(0X4B1C,	"error_unknown_media",	0);
	set_name	(0X4B1C,	"UnknownMediaType");
	set_cmt	(0X4B1E,	"Return this status in case of carry",	0);
	set_name	(0X4B1E,	"SenseErrExit");
	set_cmt	(0X4B22,	"set media lock state",	0);
	create_insn	(x=0X4B22);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4B22,	"SetLockState");
	set_cmt	(0X4B26,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4B29,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X4B30,	"unknown command error",	0);
	set_cmt	(0X4B34,	"[bx+A_LOCKSTATE_CONTROL.LOCKSTATE_FUNCTIONS]",	0);
	create_insn	(x=0X4B36);
	op_hex		(x,	1);
	set_cmt	(0X4B38,	"DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE\n(DL - drive, DS:SI - disk address packet)",	0);
	create_insn	(x=0X4B38);
	op_hex		(x,	0);
	set_cmt	(0X4B3A,	"1 = locked, 0 = not locked\n[bx+A_LOCKSTATE_CONTROL.LOCKSTATE_FLAG]",	0);
	set_cmt	(0X4B44,	"Return this status in case of carry",	0);
	set_cmt	(0X4B47,	"eject media in drive\n[es:di+BDS.drivenum]",	0);
	create_insn	(0X4B47);
	set_name	(0X4B47,	"EjectMedia");
	set_cmt	(0X4B4E,	"unknown command error",	0);
	set_cmt	(0X4B55,	"DISK - IBM/MS Extension - EJECT MEDIA\n(DL - drive)",	0);
	create_insn	(x=0X4B55);
	op_hex		(x,	0);
	set_cmt	(0X4B5E,	"Return this status in case of carry",	0);
	set_name	(0X4B5E,	"ejectm_ret");
	create_insn	(x=0X4B61);
	op_hex		(x,	1);
	set_name	(0X4B61,	"check_int13h_exts_present");
	set_cmt	(0X4B67,	"DISK - Check for INT 13h Extensions\nBX = 55AAh, DL = drive number\nReturn: CF set if not supported\nAH = extensions version\nBX = AA55h\nCX = Interface support bit map",	0);
	create_insn	(x=0X4B67);
	op_hex		(x,	0);
	set_cmt	(0X4B70,	"bit 1 - drive locking and ejecting subset",	0);
	create_insn	(x=0X4B70);
	op_hex		(x,	1);
	set_cmt	(0X4B77,	"get drive map information\n\nes:di points to BDS which belongs to \n      the requested logical/dos drive number\n\nFormat of parameter block:\nOffset  Description (Table 01570)\n 00h    (call) length of this buffer (in bytes)\n 01h    (ret) number of bytes in parameter block                      \n        actually used\n 02h    (ret) drive flags\n 03h    (ret) physical drive number\n        00h-7Fh floppy\n        80h-FEh hard\n        FFh no physical drive\n 04h    (ret) bitmap of logical drives associated with   \n        physical drive\n        bit 0 = drive A:, etc.\n 08h    (ret) relative block address of partition start\n        qword\n\nRef: Ralf Brown's Interrupt List, INTERRUP.G",	0);
	create_insn	(0X4B77);
	set_name	(0X4B77,	"GetDrvMapInfo");
	create_insn	(x=0X4B79);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4B7D,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]",	0);
	set_cmt	(0X4B80,	"ah = generic ioctl error code (81h)\nal = unknown command error (03h)",	0);
	set_cmt	(0X4B83,	"parameter buffer length = 16 bytes",	0);
	set_cmt	(0X4B88,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X4B8C,	"parameter block - offset 3 - physical drive number",	0);
	set_cmt	(0X4B8F,	"parameter block - actually used length",	0);
	set_cmt	(0X4B93,	"[es:di+BDS.hiddensectors]",	0);
	set_cmt	(0X4B97,	"parameter block - offset 8 - partition start LBA",	0);
	set_cmt	(0X4B9A,	"[es:di+BDS.hiddensectors+2]",	0);
	set_cmt	(0X4B9E,	"parameter block - offset 10",	0);
	set_cmt	(0X4BA3,	"drive flags = 0 (protected mode flags etc.)",	0);
	set_cmt	(0X4BA6,	"high dword of partition start address (LBA) is 0",	0);
	set_cmt	(0X4BAC,	"logical drive bitmap of same physical drive\ninitialized as 0",	0);
	set_cmt	(0X4BB4,	"1st BDS",	0);
	create_insn	(x=0X4BB4);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4BB9,	"bit 0 (drive A:)",	0);
	set_cmt	(0X4BBC,	"last BDS ?",	0);
	set_name	(0X4BBC,	"gdmi_1");
	set_cmt	(0X4BBF,	"yes",	0);
	set_cmt	(0X4BC1,	"[es:di+BDS.drivenum], dl\nis it same physical drive ?",	0);
	set_cmt	(0X4BC5,	"no",	0);
	set_cmt	(0X4BC7,	"set bit for logical drive index of this BDS\n(previously) shifted bit (which is 1/ON) is in ax:cx",	0);
	set_cmt	(0X4BCD,	"shift one left for setting the next drive's bit",	0);
	create_insn	(x=0X4BCD);
	op_hex		(x,	1);
	set_name	(0X4BCD,	"gdmi_2");
	set_cmt	(0X4BCF,	"set high word of the bit select (set) value",	0);
	create_insn	(x=0X4BCF);
	op_hex		(x,	1);
	set_cmt	(0X4BD1,	"next BDS",	0);
	set_cmt	(0X4BD4,	"loop until di = -1 (last BDS sign)",	0);
	set_cmt	(0X4BD6,	"success",	0);
	create_insn	(0X4BD6);
	set_name	(0X4BD6,	"gdmi_3");
	set_name	(0X4BD9,	"gdmi_4");
	create_insn	(0X4BDA);
	set_name	(0X4BDA,	"i2f_handler");
	set_cmt	(0X4BE4,	"MultWin386",	0);
	set_cmt	(0X4BE9,	"multMULT",	0);
	create_insn	(x=0X4BE9);
	op_hex		(x,	1);
	create_insn	(0X4BF1);
	set_name	(0X4BF1,	"i2f_handler_iret");
	create_insn	(0X4BF2);
	set_name	(0X4BF2,	"int2f_replace_int13");
	create_insn	(x=0X4BFB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4BFF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4C03);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4C07);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4C0A);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4C0E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4C15,	"i2f_iret");
	set_cmt	(0X4C16,	"iret on reserved functions",	0);
	create_insn	(0X4C16);
	set_name	(0X4C16,	"mine");
	set_cmt	(0X4C1A,	"a get installed state request?",	0);
	set_cmt	(0X4C21,	"request for installing bds?",	0);
	create_insn	(0X4C21);
	set_name	(0X4C21,	"disp_func");
	set_cmt	(0X4C25,	"get bds vector?",	0);
	create_insn	(x=0X4C2F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4C33);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4C38,	"BIOSDATA:dsk_entry\n\nNOTE: jump to a FAR function, not an\nIRET type function. Callers of\nthis int2f subfunction will have\nto be careful to do a popf",	0);
	create_insn	(x=0X4C38);
	create_insn	(0X4C3D);
	set_name	(0X4C3D,	"do_subfun_01");
	set_cmt	(0X4C41,	"BIOSDATA segment",	0);
	create_insn	(0X4C4C);
	set_name	(0X4C4C,	"do_get_bds_vector");
	create_insn	(x=0X4C51);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(0X4C56);
	set_name	(0X4C56,	"win386call");
	set_cmt	(0X4C57,	"BIOSDATA segment",	0);
	set_cmt	(0X4C5C,	"Win386_Init\nis it win386 initializing?",	0);
	set_cmt	(0X4C60,	"Win386_Exit\nis it win386 exiting?",	0);
	set_cmt	(0X4C64,	"is it win386 or win286 dos extender?",	0);
	create_insn	(x=0X4C64);
	op_hex		(x,	1);
	set_cmt	(0X4C68,	"if not win386, then continue",	0);
	set_cmt	(0X4C6A,	"indicate that win386 is not present",	0);
	create_insn	(x=0X4C6A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X4C71,	"is it win386 or win286 dos extender?",	0);
	create_insn	(x=0X4C71);
	op_hex		(x,	1);
	set_name	(0X4C71,	"Win386Init");
	set_cmt	(0X4C75,	"if not win386, then continue",	0);
	create_insn	(x=0X4C77);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	create_insn	(x=0X4C7C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4C80,	"Hook our structure into chain",	0);
	create_insn	(x=0X4C80);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4C84,	"point es:bx to Win386_SI",	0);
	create_insn	(x=0X4C84);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4C89,	"win_iret");
	set_cmt	(0X4C8A,	"return back up the chain",	0);
	create_insn	(0X4C8B);
	set_name	(0X4C8B,	"handle_multmult");
	set_cmt	(0X4C90,	"get offset of free HMA",	0);
	set_cmt	(0X4C96,	"seg of HMA",	0);
	set_name	(0X4CA1,	"try_1");
	set_cmt	(0X4CA3,	"multMULTALLOCHMA",	0);
	create_insn	(0X4CA3);
	set_name	(0X4CA3,	"try_2");
	set_cmt	(0X4CA8,	"assume not enough space",	0);
	set_cmt	(0X4CAD,	"get offset of free HMA",	0);
	set_cmt	(0X4CB5,	"free space in HMA",	0);
	create_insn	(0X4CC0);
	set_name	(0X4CC0,	"try_4");
	create_insn	(x=0X4CC3);
	op_dec		(x,	1);
	create_insn	(x=0X4CC6);
	op_hex		(x,	1);
	set_cmt	(0X4CC9,	"update the free pointer",	0);
	create_insn	(x=0X4CC9);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4CCF,	"-1\nno more HMA if we have wrapped",	0);
	create_insn	(x=0X4CCF);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4CD5,	"InsuffHMA");
	set_name	(0X4CD6,	"try_3");
	create_insn	(0X4CD7);
	set_name	(0X4CD7,	"HMAptr");
	create_insn	(x=0X4CDC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4CE5);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4CEC,	"call far [MoveDOSIntoHMA]",	0);
	create_insn	(x=0X4CEC);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X4CF0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4CF0,	"get_FreeHMAPtr");
	set_name	(0X4CF4,	"HMAPtr_retn");
	create_insn	(0X4CF5);
	set_name	(0X4CF5,	"move_sector");
	create_insn	(x=0X4CF7);
	op_dec		(x,	1);
	create_insn	(x=0X4D0A);
	op_hex		(x,	1);
	create_insn	(0X4D10);
	set_name	(0X4D10,	"check_wrap");
	set_cmt	(0X4D14,	"get pointer to bds for drive in dl",	0);
	set_cmt	(0X4D19,	"[es:di+BDS.flags],fnon_removable",	0);
	create_insn	(x=0X4D19);
	op_hex		(x,	1);
	set_cmt	(0X4D1F,	"no wrapping for removable media",	0);
	set_cmt	(0X4D21,	"[es:di+BDS.secpertrack]",	0);
	set_cmt	(0X4D27,	"extract sector number",	0);
	create_insn	(x=0X4D27);
	op_hex		(x,	1);
	set_cmt	(0X4D2A,	"are we going to wrap?",	0);
	set_cmt	(0X4D2E,	"ah=new sector #, al=# of head wraps",	0);
	set_cmt	(0X4D34,	"set sector=BDS_BPB.BPB_SECTORSPERTRACK",	0);
	set_cmt	(0X4D36,	"if on boundary\nalso decrement # of head wrap",	0);
	set_cmt	(0X4D38,	"zero out sector #",	0);
	create_insn	(x=0X4D38);
	op_hex		(x,	1);
	set_cmt	(0X4D3B,	"or in new sector #",	0);
	set_cmt	(0X4D3D,	"ax = # of head wraps",	0);
	set_cmt	(0X4D40,	"add in starting head #",	0);
	set_cmt	(0X4D42,	"catch any carry",	0);
	set_cmt	(0X4D45,	"[es:di+BDS.heads]\nare we going to wrap around a head?",	0);
	set_cmt	(0X4D4B,	"preserve drive number and head number",	0);
	set_cmt	(0X4D4E,	"[es:di+BDS.heads]\ndx = new head #, ax = # of cylinder wraps",	0);
	set_cmt	(0X4D54,	"if new head # is 0, then we are on the last head",	0);
	set_cmt	(0X4D58,	"on boundary. set to BDS_BPB.BPB_HEADS",	0);
	set_cmt	(0X4D5A,	"if we had some cylinder wraps,\nwe need to reduce them by on",	0);
	set_cmt	(0X4D5E,	"reduce number of cylinder wraps",	0);
	set_cmt	(0X4D5F,	"bh has new head number",	0);
	set_cmt	(0X4D61,	"restore drive number and head number",	0);
	set_cmt	(0X4D68,	"preserve sector number",	0);
	create_insn	(x=0X4D68);
	op_hex		(x,	1);
	set_cmt	(0X4D6F,	"get ms cylinder bits to ls end",	0);
	set_cmt	(0X4D71,	"add in cylinder wrap",	0);
	set_cmt	(0X4D73,	"add in high byte",	0);
	set_cmt	(0X4D75,	"move up to ms end",	0);
	set_cmt	(0X4D77,	"restore cylinder bits into cl",	0);
	set_cmt	(0X4D79,	"or in sector number",	0);
	set_cmt	(0X4D81,	"do not lose new head number",	0);
	create_insn	(0X4D81);
	set_cmt	(0X4D83,	"get it 0-based",	0);
	set_cmt	(0X4D87,	"point es:di to first bds",	0);
	create_insn	(x=0X4D87);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4D87,	"find_bds");
	set_cmt	(0X4D8B,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X4D91,	"[es:di+BDS.link]\ngo to next bds",	0);
	set_cmt	(0X4D9B,	"[bp+INT13FRAME.olddx]\nget physical drive number",	0);
	create_insn	(0X4D9B);
	set_name	(0X4D9B,	"doint");
	set_cmt	(0X4DA3,	"if zero sectors, return ax=0",	0);
	set_cmt	(0X4DA5,	"[bp+INT13FRAME.oldax+1]\nget request code",	0);
	set_cmt	(0X4DA9,	"[bp+INT13FRAME.oldf]",	0);
	set_cmt	(0X4DAE,	"call BIOSDATA:call_orig13\ncall DOSBIOSSEG:call_orig13",	0);
	create_insn	(x=0X4DAE);
	set_cmt	(0X4DB4,	"[bp+INT13FRAME.oldf]",	0);
	set_cmt	(0X4DB9,	"40h:90h is drive type array",	0);
	create_dword	(0X4DB9);
	set_name	(0X4DB9,	"dtype_array");
	set_cmt	(0X4DBD,	"do we have changeline support?",	0);
	create_insn	(x=0X4DBD);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4DBD,	"format_special_stuff");
	set_cmt	(0X4DC2,	"brif not",	0);
	set_cmt	(0X4DC5,	"fchanged_by_format+fchanged",	0);
	set_cmt	(0X4DC8,	"indicate that media changed by format",	0);
	set_cmt	(0X4DCE,	"floppy or hard disk?",	0);
	create_insn	(0X4DCE);
	set_name	(0X4DCE,	"ec35_special_stuff");
	set_cmt	(0X4DD0,	"if hard drive, we're done",	0);
	set_cmt	(0X4DD2,	"see if this PARTICULAR drive is ec35",	0);
	set_cmt	(0X4DD4,	"turn drive number into bit map",	0);
	set_cmt	(0X4DD6,	"assume drive 0",	0);
	set_cmt	(0X4DD8,	"shift over correct number of times",	0);
	set_cmt	(0X4DDA,	"electrically compatible 3.5 incher?",	0);
	create_insn	(x=0X4DDA);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4DE0,	"done if this floppy is not an ec35",	0);
	set_cmt	(0X4DE2,	"free up a far pointer (es:bx)",	0);
	set_cmt	(0X4DEB,	"find entry for this drive",	0);
	set_cmt	(0X4DEE,	"establish drive type as:\n(360k disk in 360k drive,\nno double-stepping, 250 kbs transfer rate)",	0);
	set_cmt	(0X4DF6,	"(ps2_30)\nread driver parm?",	0);
	create_insn	(x=0X4DF6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4DF6,	"ps2_special_stuff");
	set_cmt	(0X4DFD,	"apparently function 15h fails, too",	0);
	create_insn	(x=0X4DFD);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4E04,	"ps2_30_problem");
	set_cmt	(0X4E07,	"call BIOSDATA:call_orig13",	0);
	create_insn	(x=0X4E07);
	create_insn	(0X4E0F);
	set_name	(0X4E0F,	"i13z");
	set_cmt	(0X4E15,	"save request",	0);
	create_insn	(x=0X4E15);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4E18,	"romformat",	0);
	set_cmt	(0X4E1D,	"any electrically compat 3.5 inchers?",	0);
	create_insn	(x=0X4E1D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4E1D,	"format_special_stuff_done");
	set_cmt	(0X4E22,	"go handle it out of line if so",	0);
	set_cmt	(0X4E24,	"call BIOSDATA:call_orig13",	0);
	create_insn	(x=0X4E24);
	set_name	(0X4E24,	"ec35_special_stuff_done");
	set_cmt	(0X4E2A,	"is this a ps2/30?\nmdl_ps2_30",	0);
	create_insn	(x=0X4E2A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4E2F,	"exit mainline to address special",	0);
	set_name	(0X4E31,	"ps2_special_stuff_done");
	set_cmt	(0X4E32,	"error on original orig13 call-thru?",	0);
	set_name	(0X4E34,	"ret_from_i13");
	set_cmt	(0X4E35,	"restore ds & iret w/flags",	0);
	set_cmt	(0X4E38,	"done if not an error termination",	0);
	create_insn	(0X4E38);
	set_name	(0X4E38,	"i13ret_ck_chglinerr");
	set_cmt	(0X4E3A,	"did i see a change event?",	0);
	set_name	(0X4E3A,	"i13_ret_error");
	set_cmt	(0X4E3D,	"skip if wrong error",	0);
	set_cmt	(0X4E3F,	"is this for the hard disk?",	0);
	set_cmt	(0X4E41,	"yes, ignore",	0);
	create_insn	(x=0X4E43);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4E48,	"just in case ROM returned this\nerror even though it told us it\nnever would",	0);
	set_cmt	(0X4E4B,	"fchanged",	0);
	create_insn	(x=0X4E4B);
	op_hex		(x,	1);
	set_cmt	(0X4E52,	"now return the error",	0);
	set_name	(0X4E52,	"int13b");
	set_cmt	(0X4E55,	"dma error?",	0);
	create_insn	(0X4E55);
	set_name	(0X4E55,	"goterr13");
	set_cmt	(0X4E5A,	"ecc error?",	0);
	set_name	(0X4E5A,	"goterr13_xxxx");
	set_cmt	(0X4E5D,	"other error. just return back.",	0);
	set_cmt	(0X4E5F,	"formatting?",	0);
	create_insn	(x=0X4E5F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4E66,	"ecc-corrected error\n(2 = romread)\nECC correction only applies to reads",	0);
	create_insn	(x=0X4E66);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4E6F,	"call BIOSDATA:call_orig13\ncall DOSBIOSSEG:call_orig13",	0);
	create_insn	(x=0X4E6F);
	create_insn	(x=0X4E74);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4E77,	"return code = no error",	0);
	set_cmt	(0X4E79,	"if request for one sector, assume ok",	0);
	set_cmt	(0X4E7B,	"return with carry clear",	0);
	create_insn	(x=0X4E80);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X4E83,	"read one sector",	0);
	set_name	(0X4E83,	"loop_ecc");
	set_cmt	(0X4E86,	"get correct parameters for int 13",	0);
	set_cmt	(0X4E89,	"call BIOSDATA:call_orig13\ncall DOSBIOSSEG:call_orig13",	0);
	create_insn	(x=0X4E89);
	set_cmt	(0X4E90,	"DMA error during ECC read?",	0);
	set_cmt	(0X4E95,	"only allow ecc errors",	0);
	set_cmt	(0X4E9A,	"ecc error. reset the system again.\nclear the error code so that if this\nwas the last sector, no error code\nwill be returned for the corrected read.\n(clear carry too.)",	0);
	create_insn	(x=0X4E9C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X4E9C,	"ok11_op");
	set_cmt	(0X4EA0,	"all done?",	0);
	set_cmt	(0X4EA2,	"advance sector number\nadd 200h to address",	0);
	set_cmt	(0X4EAA,	"set carry bit again.",	0);
	create_insn	(0X4EAA);
	set_name	(0X4EAA,	"ok11_exit_err");
	set_name	(0X4EAB,	"ok11_exit");
	create_insn	(0X4EB0);
	set_name	(0X4EB0,	"handle_dma_during_ecc");
	set_cmt	(0X4EB2,	"BIOSDATA:0152h",	0);
	create_insn	(x=0X4EB2);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4EB6,	"point es:bx to buffer",	0);
	set_cmt	(0X4EB7,	"read one sector",	0);
	set_cmt	(0X4EBA,	"call BIOSDATA:call_orig13",	0);
	create_insn	(x=0X4EBA);
	set_name	(0X4EC8,	"handle_dma_during_ecc_noerr");
	create_insn	(x=0X4ECC);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X4ED6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4ED6,	"gotdmaerr");
	set_cmt	(0X4EDA,	"romread",	0);
	set_cmt	(0X4EDF,	"romverify",	0);
	set_cmt	(0X4EE4,	"romformat",	0);
	set_cmt	(0X4EEB,	"set up stack frame here!",	0);
	set_cmt	(0X4EF2,	"check for 64k boundary error",	0);
	set_cmt	(0X4EFA,	"dx = dx*16",	0);
	create_insn	(x=0X4EFE);
	op_dec		(x,	1);
	set_cmt	(0X4F04,	"restore dh=head & do buffer",	0);
	set_cmt	(0X4F07,	"dh = number of sectors before address",	0);
	create_insn	(x=0X4F07);
	op_hex		(x,	1);
	set_name	(0X4F07,	"no_skip_first");
	set_cmt	(0X4F09,	"ah = max number of sectors in segment",	0);
	create_insn	(x=0X4F09);
	op_dec		(x,	1);
	set_cmt	(0X4F0D,	"can we fit it in?",	0);
	set_cmt	(0X4F0F,	"no, perform blocking.\nyes, the request fits. let it happen",	0);
	set_cmt	(0X4F11,	"[bp+INT13FRAME.olddx+1]\nset up head number",	0);
	set_cmt	(0X4F17,	"and return from this place",	0);
	set_cmt	(0X4F1A,	"pass dma error thru to caller",	0);
	create_insn	(0X4F1A);
	set_name	(0X4F1A,	"i13_done_dmaerr");
	set_cmt	(0X4F1D,	"return with error,\nwe know it's not a changeline error",	0);
	set_cmt	(0X4F20,	"save caller's dma address",	0);
	create_insn	(0X4F20);
	set_name	(0X4F20,	"intverify");
	set_cmt	(0X4F23,	"es:bx -> BIOSDATA:disksector",	0);
	create_insn	(x=0X4F24);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X4F24,	"dosimple");
	set_cmt	(0X4F27,	"call DOSBIOSSEG:call_orig13\ncall BIOSDATA:call_orig13",	0);
	create_insn	(x=0X4F27);
	create_insn	(0X4F31);
	set_name	(0X4F31,	"intformat");
	create_insn	(x=0X4F3C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4F3F,	"user's data into BIOSDATA:disksector",	0);
	set_cmt	(0X4F44,	"do the i/o from",	0);
	set_cmt	(0X4F45,	"BIOSDATA:disksector",	0);
	set_cmt	(0X4F47,	"[bp+INT13FRAME.olddx]\nget head #, drive #",	0);
	create_insn	(0X4F47);
	set_name	(0X4F47,	"doblock");
	set_cmt	(0X4F4C,	"ah - # of sectors before dma boundary\nal - requested # of sectors for i/o.",	0);
	set_cmt	(0X4F50,	"[es:di+BDS.secpertrack]",	0);
	set_cmt	(0X4F54,	"[es:di+BDS.flags], fnon_removable",	0);
	create_insn	(x=0X4F54);
	op_hex		(x,	1);
	set_cmt	(0X4F5C,	"set al=ah for floppies",	0);
	set_cmt	(0X4F5E,	"they are track by track operation",	0);
	set_cmt	(0X4F60,	"ah = 63-secpt (# safe sectors??)",	0);
	create_insn	(x=0X4F60);
	op_dec		(x,	1);
	set_cmt	(0X4F62,	"al - # of sectors before dma boundary",	0);
	set_name	(0X4F64,	"doblockflop");
	set_cmt	(0X4F65,	"if safe_# >= #_of_sectors_to_go_before dma,",	0);
	set_name	(0X4F65,	"doblockcontinue");
	set_cmt	(0X4F67,	"then #_of_sectors_to_go as it is for doint.",	0);
	set_cmt	(0X4F6A,	"otherwise, set al to ah to operate.",	0);
	create_insn	(0X4F6E);
	set_name	(0X4F6E,	"doblocklast");
	set_cmt	(0X4F71,	"let ah = al = # of sectors for this shot",	0);
	set_name	(0X4F71,	"doblockdoint");
	set_cmt	(0X4F74,	"something happened, bye!",	0);
	set_cmt	(0X4F77,	"sub [bp+INT13FRAME.oldax], ah\ndecrement by the successful operation",	0);
	set_cmt	(0X4F7A,	"advance sector #. safety gauranteed.",	0);
	set_cmt	(0X4F7C,	"advance dma address",	0);
	set_cmt	(0X4F7E,	"twice for 512 byte sectors",	0);
	set_cmt	(0X4F80,	"check the previous value",	0);
	set_cmt	(0X4F82,	"if #_of_sectors_to_go < safe_#,\nthen we are done already.",	0);
	set_cmt	(0X4F84,	"otherwise,\n#_sector_to_go = #_of_sector_to_go - safe_#",	0);
	set_cmt	(0X4F86,	"get new cx, dh for the next operation.",	0);
	set_cmt	(0X4F89,	"handles next sectors left.",	0);
	set_cmt	(0X4F8B,	"[bp+INT13FRAME.olddx+1]\nset up head number",	0);
	create_insn	(0X4F8B);
	set_name	(0X4F8B,	"bufferx");
	set_name	(0X4F8E,	"buffer");
	set_cmt	(0X4F8F,	"[bp+INT13FRAME.oldax+1]",	0);
	set_cmt	(0X4F92,	"romwrite",	0);
	set_cmt	(0X4F9B,	"exchange segment registers",	0);
	set_cmt	(0X4F9F,	"where to move",	0);
	create_insn	(x=0X4F9F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4FA2,	"save it",	0);
	set_cmt	(0X4FA3,	"source",	0);
	set_cmt	(0X4FA5,	"move sector into local buffer",	0);
	set_cmt	(0X4FA8,	"new transfer address\n(es:bx = BIOSDATA:disksector)",	0);
	set_cmt	(0X4FA9,	"restore caller's di & si",	0);
	set_cmt	(0X4FAB,	"restore BIOSDATA",	0);
	set_cmt	(0X4FAE,	"[bp+INT13FRAME.olddx]\nget drive number",	0);
	set_cmt	(0X4FB1,	"sets up registers if wrap-around\n\nah is function\nal is 1 for single sector transfer\nes:bx is local transfer addres\ncx is track/sector number\ndx is head/drive number\nsi, di unchanged",	0);
	set_cmt	(0X4FB7,	"restore caller's dma segment",	0);
	set_cmt	(0X4FB8,	"go clean up",	0);
	create_insn	(0X4FBC);
	set_name	(0X4FBC,	"doread");
	set_cmt	(0X4FBF,	"es = BIOSCODE segment",	0);
	create_insn	(x=0X4FC0);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4FC5,	"[bp+INT13FRAME.olddx]\nget drive number",	0);
	set_cmt	(0X4FC8,	"ah = function\nal = 1 for single sector\nes:bx points to local   buffer\ncx, dx are track/sector, head/drive",	0);
	create_insn	(x=0X4FD6);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X4FDE,	"retrieve new dma area",	0);
	set_name	(0X4FDE,	"dotail");
	set_cmt	(0X4FDF,	"advance over sector",	0);
	set_cmt	(0X4FE3,	"[bp+INT13FRAME.oldax]",	0);
	set_cmt	(0X4FE9,	"no more i/o",	0);
	set_cmt	(0X4FEB,	"[bp+INT13FRAME.olddx]",	0);
	set_name	(0X4FF4,	"bad13");
	set_cmt	(0X4FFB,	"go handle ECC errors",	0);
	set_cmt	(0X4FFD,	"non-error exit",	0);
	create_insn	(0X5000);
	set_name	(0X5000,	"xgoterr13_xxxx");
	create_insn	(x=0X5004);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X5004,	"dsk_init");
	set_cmt	(0X5008,	"pass result in es:di",	0);
	create_insn	(x=0X5008);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X5010,	"save Bios_Data (BIOSDATA) segment",	0);
	create_insn	(0X5010);
	set_name	(0X5010,	"install_bds");
	set_cmt	(0X5011,	"beginning of chain",	0);
	create_insn	(x=0X5011);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X5014,	"[si+BDS.link]\nfetch next bds",	0);
	set_cmt	(0X5016,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X501A,	"does this one share a physical\ndrive with new one?",	0);
	set_cmt	(0X501F,	"fi_am_mult",	0);
	set_cmt	(0X5021,	"[es:di+BDS.flags]\nset both of them to i_am_mult if so",	0);
	set_cmt	(0X5025,	"[si+BDS.flags]",	0);
	set_cmt	(0X5028,	"[es:di+BDS.flags],~fi_own_physical\nwe don't own it",	0);
	create_insn	(x=0X5028);
	op_hex		(x,	1);
	set_cmt	(0X502D,	"[si+BDS.flags]\ndetermine if changeline available",	0);
	set_cmt	(0X5030,	"fchangeline",	0);
	create_insn	(x=0X5030);
	op_hex		(x,	1);
	set_cmt	(0X5033,	"[es:di+BDS.flags]",	0);
	set_cmt	(0X503A,	"[si+BDS.link],-1\nare we at end of list?",	0);
	set_cmt	(0X503E,	"[si+BDS.link+2], es\ninstall bds",	0);
	set_cmt	(0X5043,	"[es:di+BDS.link],-1\nset next pointer to null",	0);
	set_cmt	(0X5047,	"[es:di+BDS.rsecpertrack]",	0);
	create_insn	(x=0X504B);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X5051);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5055,	"Is win386 present?",	0);
	create_insn	(x=0X5055);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_name	(0X5055,	"swpdsk");
	set_cmt	(0X505A,	"no, skip SetFocus",	0);
	set_cmt	(0X505C,	"call DOSBIOSSEG:V86_Crit_SetFocus\ncall BIOSDATA:V86_Crit_SetFocus",	0);
	create_insn	(x=0X505C);
	set_cmt	(0X5063,	"[es:di+BDS.drivelet]\nget the drive letter",	0);
	create_insn	(x=0X5069);
	op_hex		(x,	1);
	set_cmt	(0X506C,	"nobody has handled swap disk",	0);
	set_cmt	(0X506E,	"multMULT<<8)|multMULTSWPDSK\nbroadcast code for swap disk\nBroadcast it",	0);
	create_insn	(x=0X5071);
	op_hex		(x,	0);
	create_insn	(x=0X5076);
	op_chr		(x,	1);
	create_insn	(x=0X507E);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X5082,	"get the next character of the message",	0);
	set_cmt	(0X5084,	"DOS 2+ internal - FAST PUTCHAR\nAL = character to display",	0);
	create_insn	(x=0X5084);
	op_hex		(x,	0);
	set_cmt	(0X5086,	"cs lodsb\nget the next character of the message",	0);
	set_cmt	(0X508C,	"flush out keyboard queue\ncall rom-bios",	0);
	set_cmt	(0X5091,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character",	0);
	create_insn	(x=0X5091);
	op_hex		(x,	0);
	create_strlit	(0X5097,	0X50B3);
	set_name	(0X5097,	"sngmsg");
	create_strlit	(0X50B3,	0X50D6);
	set_name	(0X50B3,	"drvlet");
	set_cmt	(0X50D6,	"make sure correct disk is in place",	0);
	create_insn	(0X50D6);
	set_name	(0X50D6,	"mediacheck");
	set_cmt	(0X50E0,	"[es:di+BDS.flags], fchanged ; 40h\n(BDS offset 63)",	0);
	create_insn	(x=0X50E0);
	op_hex		(x,	1);
	set_cmt	(0X50E6,	"media changed",	0);
	set_cmt	(0X50EA,	"[es:di+BDS.drivenum]",	0);
	set_cmt	(0X50F0,	"DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)\nDL = drive to check\nReturn: AH = disk change status",	0);
	create_insn	(x=0X50F0);
	op_hex		(x,	0);
	set_cmt	(0X50F9,	"get last drive accessed",	0);
	create_insn	(x=0X50F9);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X50FD,	"[es:di+BDS.drivenum]\n(If the last drive accessed is not current drive\nmedia change status may be incorrect. So,\n\"I don't now\" will be returned even if it is indicated\nas media is not changed.)",	0);
	set_cmt	(0X5101,	"(same drive, media changeline indication is reliable)",	0);
	set_cmt	(0X510E,	"check_time says \">= 2 secs passed\"\n(volume id will be checked)",	0);
	set_cmt	(0X5110,	"return \"i don't know\"",	0);
	set_cmt	(0X5113,	"build a new bpb in current bds",	0);
	create_insn	(0X5113);
	set_cmt	(0X511D,	"fix up al for return to dos",	0);
	set_cmt	(0X5120,	"[di+BDS.opcnt]",	0);
	create_insn	(0X5120);
	set_name	(0X5120,	"checklatchio");
	set_cmt	(0X5125,	"done if zero",	0);
	set_cmt	(0X5127,	"test [es:di+BDS.flags], fchanged ; 40h",	0);
	create_insn	(x=0X5127);
	op_hex		(x,	1);
	set_cmt	(0X512D,	"not changed",	0);
	set_cmt	(0X512F,	"build bpb in current bds",	0);
	set_cmt	(0X5132,	"disk error trying to read in",	0);
	set_cmt	(0X5137,	"disk error trying to read in",	0);
	set_cmt	(0X5139,	"is changed for sure?",	0);
	set_cmt	(0X513B,	"no",	0);
	set_cmt	(0X513D,	"yes",	0);
	set_cmt	(0X5140,	"fix up al for return to dos",	0);
	set_cmt	(0X5144,	"pop off return address",	0);
	set_name	(0X5145,	"checkret");
	set_cmt	(0X5146,	"check the fat and the vid",	0);
	create_insn	(0X5146);
	set_name	(0X5146,	"checkfatvid");
	set_cmt	(0X514B,	"\nfall into check_vid",	0);
	set_cmt	(0X514D,	"BPB_FATSz16",	0);
	create_insn	(x=0X514D);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X514D,	"check_vid");
	set_cmt	(0X5154,	"BS_FAT32_BootSig\n[disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE",	0);
	create_insn	(x=0X5154);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X515B,	"BS_FAT_BootSig ; BS_BootSig\n[disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE",	0);
	create_insn	(x=0X515B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X5169,	"BPB_NumFATs\n[disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]",	0);
	create_insn	(x=0X5169);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X516E,	"don't read vol id if not fat system",	0);
	set_cmt	(0X5178,	"-1\ndefinitely changed",	0);
	set_name	(0X5182,	"checkfatret");
	set_cmt	(0X5183,	"cas -- return no error",	0);
	create_insn	(0X5183);
	set_name	(0X5183,	"changed_drv");
	set_cmt	(0X5184,	"ensure that we ask rom for media\n  check next time round",	0);
	create_insn	(x=0X5184);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X518A);
	set_cmt	(0X518C,	"BS_FAT32_VolID\n[DiskSector+EXT_BOOT.SERIAL]",	0);
	create_insn	(x=0X518C);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X518F,	"BPB_FATSz16",	0);
	create_insn	(x=0X518F);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5196,	"offset disksector+27h ; BS_VolID",	0);
	create_insn	(x=0X5196);
	op_dec		(x,	1);
	set_cmt	(0X5199,	"BDS.vol_serial",	0);
	create_insn	(x=0X5199);
	op_dec		(x,	1);
	set_cmt	(0X519D,	"[DiskSector+EXT_BOOT.SERIAL] = [di+BDS.vol_serial] ?",	0);
	set_cmt	(0X51A0,	"[DiskSector+EXT_BOOT.SERIAL+2] =\n         [di+BDS.vol_serial+2] ?",	0);
	set_cmt	(0X51A3,	"not equal/same",	0);
	set_cmt	(0X51A5,	"0 ; don't know",	0);
	set_cmt	(0X51A7,	"reset the flag",	0);
	set_cmt	(0X51A9,	"-1\ndisk changed!",	0);
	create_insn	(0X51A9);
	set_name	(0X51A9,	"ext_changed");
	create_insn	(0X51AF);
	set_name	(0X51AF,	"checkio");
	set_cmt	(0X51C3,	"disk error trying to read in.",	0);
	set_cmt	(0X51C5,	"is changed for sure?",	0);
	set_cmt	(0X51C7,	"yes changed",	0);
	set_cmt	(0X51C9,	"allow a retry",	0);
	create_insn	(0X51CB);
	set_cmt	(0X51CE,	"make sure carry gets passed through",	0);
	create_insn	(0X51D2);
	set_cmt	(0X51D5,	"trans+8\noffset into pointer to return value",	0);
	create_insn	(x=0X51D5);
	op_dec		(x,	1);
	set_name	(0X51D5,	"returnvid");
	set_cmt	(0X51DF,	"trans+1",	0);
	create_insn	(x=0X51DF);
	op_dec		(x,	1);
	set_name	(0X51DF,	"media_set_vid");
	set_name	(0X51E2,	"vid_into_packet");
	create_insn	(x=0X51E3);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X51E7,	"BDS.volid (BDS offset 125)",	0);
	create_insn	(x=0X51E7);
	op_dec		(x,	1);
	set_cmt	(0X51EC,	"BDS start (BDS offset 0)",	0);
	create_insn	(x=0X51EC);
	op_dec		(x,	1);
	set_name	(0X51F3,	"dofloppy");
	set_cmt	(0X51F4,	"check for correct drive\nis it special?  \n[es:di+BDS.flags], fchangeline",	0);
	create_insn	(x=0X51F4);
	op_hex		(x,	1);
	set_name	(0X51F4,	"hidensity");
	set_cmt	(0X51FA,	"no, do normal floppy test",	0);
	set_cmt	(0X51FC,	"is it single-media?",	0);
	set_cmt	(0X5201,	"[es:di+BDS.formfactor], ffSmall\nyes, use fatid.",	0);
	set_cmt	(0X5208,	"[es:di+BDS.formfactor]",	0);
	set_cmt	(0X520C,	"ffOther ?",	0);
	set_cmt	(0X5214,	"seven sectors / fat",	0);
	set_cmt	(0X5216,	"224*256+0Fh (57359)\n224 root dir entries & 0Fh sector max",	0);
	create_insn	(x=0X5216);
	op_hex		(x,	1);
	set_cmt	(0X5219,	"80*15*2\n80 tracks, 15 sectors/track, 2 sides",	0);
	create_insn	(x=0X5219);
	op_dec		(x,	1);
	set_cmt	(0X521C,	"pop off return address",	0);
	set_cmt	(0X521D,	"1*256+2\nsectors/allocation unit & head max",	0);
	create_insn	(x=0X521D);
	op_dec		(x,	1);
	set_cmt	(0X5220,	"return to tail of getbp",	0);
	set_cmt	(0X5223,	"pop off return address",	0);
	create_insn	(0X5223);
	set_cmt	(0X5224,	"return to 720K code",	0);
	create_insn	(0X5227);
	set_name	(0X5227,	"Set_Changed_DL");
	create_insn	(x=0X5229);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X522D,	"[es:di+BDS.drivenum]",	0);
	set_name	(0X522D,	"scan_bds");
	set_cmt	(0X5233,	"[es:di+BDS.flags]\nsignal change on other drive",	0);
	set_cmt	(0X5237,	"[es:di+BDS.link]\ngo to next bds",	0);
	set_cmt	(0X523D,	"loop unless end of chain",	0);
	set_cmt	(0X5242,	"[es:di+BDS.flags], ~fchanged",	0);
	create_insn	(x=0X5242);
	op_hex		(x,	1);
	set_name	(0X5242,	"resetchanged");
	set_cmt	(0X5248,	"[es:di+BDS.flags], fchangeline",	0);
	create_insn	(x=0X5248);
	op_hex		(x,	1);
	set_name	(0X5248,	"haschange");
	create_insn	(0X524F);
	set_name	(0X524F,	"set_volume_id");
	set_cmt	(0X5251,	"does drive have changeline support?",	0);
	set_cmt	(0X5254,	"no, get out",	0);
	set_cmt	(0X525B,	"copy the volume id to special drive",	0);
	set_cmt	(0X525E,	"restore value of change line",	0);
	set_cmt	(0X5265,	"pop stack but don't overwrite ax",	0);
	create_insn	(0X5265);
	set_cmt	(0X5268,	"root sector #",	0);
	create_word	(0X5268);
	set_name	(0X5268,	"root_sec");
	create_insn	(0X526A);
	set_name	(0X526A,	"read_volume_id");
	set_cmt	(0X526E,	"stack the bds last",	0);
	set_cmt	(0X5270,	"point es to Bios_Data (BIOSDATA)",	0);
	create_insn	(x=0X5272);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X5275);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X5278,	"(cx = 12 in MSDOS 6 IO:SYS)\ninitialize tmp_vid to null vi_id",	0);
	create_insn	(x=0X5278);
	op_dec		(x,	1);
	set_cmt	(0X5280,	"[es:di+BDS.fats]\n# of fats",	0);
	set_cmt	(0X5284,	"[es:di+BDS.fatsecs]\nsectors / fat",	0);
	set_cmt	(0X528A,	"[es:di+BDS.resectors]\nadd on reserved sectors\nnow, ax is sector # (0 based)",	0);
	set_cmt	(0X5292,	"[es:di+BDS.direntries]\n# root dir entries",	0);
	set_cmt	(0X5296,	"16 entries/sector",	0);
	set_cmt	(0X5298,	"divide by 16",	0);
	set_cmt	(0X529A,	"cx is # of sectors to scan",	0);
	set_cmt	(0X529C,	"get sector #",	0);
	set_cmt	(0X52A0,	"[es:di+BDS.secpertrack]\nsectors / track",	0);
	set_cmt	(0X52A8,	"dx = sectors into track\nax = track count from 0",	0);
	set_cmt	(0X52A9,	"sector to read",	0);
	set_cmt	(0X52AD,	"[es:di+BDS.heads]\n# heads on this disc",	0);
	set_cmt	(0X52B1,	"head number",	0);
	set_cmt	(0X52B3,	"track #",	0);
	set_cmt	(0X52B5,	"get first sector of the root directory,\nds:bx -> directory sector",	0);
	set_cmt	(0X52BA,	"# of dir entries in a block of root",	0);
	create_insn	(x=0X52BA);
	op_dec		(x,	1);
	set_cmt	(0X52BD,	"volume label bit",	0);
	set_cmt	(0X52BF,	"0 ; end of dir?",	0);
	set_cmt	(0X52C1,	"yes, no vol id",	0);
	set_cmt	(0X52C3,	"empty entry?",	0);
	set_cmt	(0X52C6,	"yes, skip",	0);
	set_cmt	(0X52C8,	"is volume label bit set in fcb?",	0);
	set_cmt	(0X52CB,	"yes",	0);
	set_cmt	(0X52CD,	"add length of directory entry",	0);
	create_insn	(x=0X52CD);
	op_dec		(x,	1);
	set_cmt	(0X52D2,	"outer loop",	0);
	set_cmt	(0X52D3,	"inc word [root_sec]\nnext sector",	0);
	set_cmt	(0X52D8,	"continue",	0);
	set_cmt	(0X52DE,	"clean stack of outer loop counter",	0);
	create_insn	(0X52DE);
	set_cmt	(0X52DF,	"point to volume_id",	0);
	set_cmt	(0X52E1,	"preserve current bds",	0);
	set_cmt	(0X52E3,	"point es to Bios_Data (BIOSDATA)",	0);
	create_insn	(x=0X52E5);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X52E8,	"VOLID_SIZ-1\nlength of string minus nul",	0);
	create_insn	(x=0X52E8);
	op_dec		(x,	1);
	set_cmt	(0X52EE,	"null terminate",	0);
	set_cmt	(0X52F0,	"restore current bds",	0);
	set_cmt	(0X52F8,	"clean stack of outer loop counter",	0);
	create_insn	(0X52F8);
	set_cmt	(0X52FB,	"trash the outer loop counter",	0);
	create_insn	(0X52FB);
	set_cmt	(0X52FC,	"caller's ax, return error code instead",	0);
	create_insn	(x=0X52FF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_name	(0X52FF,	"preset_volid_addr");
	set_cmt	(0X5302,	"BDS.volid",	0);
	create_insn	(x=0X5302);
	op_dec		(x,	1);
	set_cmt	(0X5305,	"VOLID_SIZ (12 for MSDOS 5.0-6.22 versions)",	0);
	create_insn	(x=0X5305);
	op_dec		(x,	1);
	create_insn	(0X530A);
	set_name	(0X530A,	"transfer_volume_id");
	create_insn	(0X5316);
	set_name	(0X5316,	"check_volume_id");
	create_insn	(0X531F);
	set_name	(0X531F,	"fat_check");
	set_cmt	(0X5320,	"say fat id's are same.",	0);
	create_insn	(x=0X5322);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X5325,	"[es:di+BDS.media]\ncompare it with the bds medbyte",	0);
	create_byte	(0X532E);
	make_array	(0X532E,	0X2);
	create_word	(0X5330);
	set_name	(0X5330,	"SYSINIT$");
	create_word	(0X5332);
	set_name	(0X5332,	"stackcount");
	create_word	(0X5334);
	set_name	(0X5334,	"stackat");
	create_word	(0X5336);
	set_name	(0X5336,	"stacksize");
	create_word	(0X5338);
	make_array	(0X5338,	0X2);
	set_name	(0X5338,	"stacks");
	create_word	(x=0X533C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X533C,	"firstentry");
	set_cmt	(0X533E,	"stacks+(defaultcount*entrysize)-entrysize",	0);
	create_word	(0X533E);
	set_name	(0X533E,	"lastentry");
	set_cmt	(0X5340,	"stacks+(defaultcount*entrysize)-entrysize",	0);
	create_word	(0X5340);
	set_name	(0X5340,	"nextentry");
	create_dword	(0X5342);
	set_name	(0X5342,	"old02");
	create_insn	(0X5346);
	set_name	(0X5346,	"int02");
	set_cmt	(0X534D,	"mdl_convert ; check if convertible",	0);
	set_cmt	(0X5356,	"PC/XT PPI port C. Bits:\n0-3: values of DIP switches\n5: 1=Timer 2 channel out\n6: 1=I/O channel check\n7: 1=RAM parity check error occurred.",	0);
	create_insn	(x=0X5356);
	op_hex		(x,	1);
	create_insn	(x=0X5358);
	op_hex		(x,	1);
	create_insn	(0X5362);
	set_name	(0X5362,	"normal02");
	create_word	(x=0X5366);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_dword	(0X5368);
	set_name	(0X5368,	"old08");
	create_insn	(0X536C);
	set_name	(0X536C,	"int08");
	create_word	(x=0X536F);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_dword	(0X5371);
	set_name	(0X5371,	"old09");
	create_insn	(0X5375);
	set_name	(0X5375,	"int09");
	create_insn	(0X5377);
	create_byte	(0X5378);
	create_insn	(0X5379);
	set_name	(0X5379,	"keyboard_lbl");
	create_word	(x=0X537C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_dword	(0X537E);
	set_name	(0X537E,	"old70");
	create_insn	(0X5382);
	set_name	(0X5382,	"int70");
	create_word	(x=0X5385);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X5387);
	set_name	(0X5387,	"int0A");
	create_dword	(0X5389);
	set_name	(0X5389,	"old0A");
	create_word	(0X538D);
	create_byte	(0X538F);
	set_name	(0X538F,	"firstflag0A");
	create_insn	(0X5390);
	create_byte	(0X5392);
	make_array	(0X5392,	0X7);
	create_insn	(0X5399);
	set_name	(0X5399,	"entry_int0A_stk");
	create_word	(x=0X539C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X539E);
	set_name	(0X539E,	"intret_0A");
	create_insn	(0X539F);
	set_name	(0X539F,	"int0B");
	create_dword	(0X53A1);
	set_name	(0X53A1,	"old0B");
	create_word	(0X53A5);
	create_byte	(0X53A7);
	set_name	(0X53A7,	"firstflag0B");
	create_insn	(0X53A8);
	create_byte	(0X53AA);
	make_array	(0X53AA,	0X7);
	create_insn	(0X53B1);
	set_name	(0X53B1,	"entry_int0B_stk");
	create_word	(x=0X53B4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X53B6);
	set_name	(0X53B6,	"intret_0B");
	create_insn	(0X53B7);
	set_name	(0X53B7,	"int0C");
	create_dword	(0X53B9);
	set_name	(0X53B9,	"old0C");
	create_word	(0X53BD);
	create_byte	(0X53BF);
	set_name	(0X53BF,	"firstflag0C");
	create_insn	(0X53C0);
	create_byte	(0X53C2);
	make_array	(0X53C2,	0X7);
	create_insn	(0X53C9);
	set_name	(0X53C9,	"entry_int0C_stk");
	create_word	(x=0X53CC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X53CE);
	set_name	(0X53CE,	"intret_0C");
	create_insn	(0X53CF);
	set_name	(0X53CF,	"int0D");
	create_dword	(0X53D1);
	set_name	(0X53D1,	"old0D");
	create_word	(0X53D5);
	create_byte	(0X53D7);
	set_name	(0X53D7,	"firstflag0D");
	create_insn	(0X53D8);
	create_byte	(0X53DA);
	make_array	(0X53DA,	0X7);
	create_insn	(0X53E1);
	set_name	(0X53E1,	"int0D_stk");
	create_word	(x=0X53E4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X53E6);
	set_name	(0X53E6,	"intret_0D");
	create_insn	(0X53E7);
	set_name	(0X53E7,	"int0E");
	create_dword	(0X53E9);
	set_name	(0X53E9,	"old0E");
	create_word	(0X53ED);
	create_byte	(0X53EF);
	set_name	(0X53EF,	"firstflag0E");
	create_insn	(0X53F0);
	create_byte	(0X53F2);
	make_array	(0X53F2,	0X7);
	create_insn	(0X53F9);
	set_name	(0X53F9,	"entry_int0E_stk");
	create_word	(x=0X53FC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X53FE);
	set_name	(0X53FE,	"intret_0E");
	create_insn	(0X53FF);
	set_name	(0X53FF,	"int72");
	create_dword	(0X5401);
	set_name	(0X5401,	"old72");
	create_word	(0X5405);
	create_byte	(0X5407);
	set_name	(0X5407,	"firstflag72");
	create_insn	(0X5408);
	create_byte	(0X540A);
	make_array	(0X540A,	0X7);
	create_insn	(0X5411);
	set_name	(0X5411,	"entry_int72_stk");
	create_word	(x=0X5414);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X5416);
	set_name	(0X5416,	"intret_72");
	create_insn	(0X5417);
	set_name	(0X5417,	"int73");
	create_dword	(0X5419);
	set_name	(0X5419,	"old73");
	create_word	(0X541D);
	create_byte	(0X541F);
	set_name	(0X541F,	"firstflag73");
	create_insn	(0X5420);
	create_byte	(0X5422);
	make_array	(0X5422,	0X7);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_3(void) {
        auto x;
#define id x

	create_insn	(0X5429);
	set_name	(0X5429,	"entry_int73_stk");
	create_word	(x=0X542C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X542E);
	set_name	(0X542E,	"intret_73");
	create_insn	(0X542F);
	set_name	(0X542F,	"int74");
	create_dword	(0X5431);
	set_name	(0X5431,	"old74");
	create_word	(0X5435);
	create_byte	(0X5437);
	set_name	(0X5437,	"firstflag74");
	create_insn	(0X5438);
	create_byte	(0X543A);
	make_array	(0X543A,	0X7);
	create_insn	(0X5441);
	set_name	(0X5441,	"entry_int74_stk");
	create_word	(x=0X5444);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X5446);
	set_name	(0X5446,	"intret_74");
	create_insn	(0X5447);
	set_name	(0X5447,	"int76");
	create_dword	(0X5449);
	set_name	(0X5449,	"old76");
	create_word	(0X544D);
	create_byte	(0X544F);
	set_name	(0X544F,	"firstflag76");
	create_insn	(0X5450);
	create_byte	(0X5452);
	make_array	(0X5452,	0X7);
	create_insn	(0X5459);
	set_name	(0X5459,	"entry_int76_stk");
	create_word	(x=0X545C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X545E);
	set_name	(0X545E,	"intret_76");
	create_insn	(0X545F);
	set_name	(0X545F,	"int77");
	create_dword	(0X5461);
	set_name	(0X5461,	"old77");
	create_word	(0X5465);
	create_byte	(0X5467);
	set_name	(0X5467,	"firstflag77");
	create_insn	(0X5468);
	create_byte	(0X546A);
	make_array	(0X546A,	0X7);
	create_insn	(0X5471);
	set_name	(0X5471,	"entry_int77_stk");
	create_word	(x=0X5474);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X5476);
	set_name	(0X5476,	"intret_77");
	create_insn	(0X5477);
	set_name	(0X5477,	"do_int_stacks");
	set_cmt	(0X547A,	"Get segment of stacks",	0);
	set_cmt	(0X547F,	"get most likely candidate",	0);
	set_cmt	(0X5484,	"allocated",	0);
	set_cmt	(0X5486,	"grab the entry",	0);
	set_cmt	(0X548A,	"free ; still avail?",	0);
	set_cmt	(0X548E,	"entrysize ; set for next interrupt",	0);
	set_cmt	(0X5494,	"[es:bp+savedsp],sp ; save sp value",	0);
	set_cmt	(0X5498,	"[es:bp+savedss],ss ; save ss also",	0);
	set_cmt	(0X549C,	"temp save of table offset",	0);
	set_cmt	(0X549E,	"[es:bp+newsp] ; get new SP value",	0);
	set_cmt	(0X54A2,	"check for offset into table",	0);
	set_cmt	(0X54A8,	"point ss,sp to the new stack",	0);
	set_cmt	(0X54BB,	"go execute the real interrupt handler",	0);
	set_cmt	(0X54BC,	"which will iret back to here\ncall far [cs:bp]",	0);
	set_cmt	(0X54C0,	"retrieve the table offset for us",	0);
	set_cmt	(0X54C2,	"but leave it on the stack",	0);
	set_cmt	(0X54C6,	"[es:bp+savedss] ; get old stack back",	0);
	set_cmt	(0X54CA,	"[es:bp+savedsp]",	0);
	set_cmt	(0X54CE,	"[es:bp+allocbyte],free ; free the entry",	0);
	set_cmt	(0X54D3,	"setup to use next time",	0);
	set_cmt	(0X54D8,	"saved on entry",	0);
	set_cmt	(0X54D9,	"saved on entry",	0);
	set_cmt	(0X54DA,	"saved on entry",	0);
	set_cmt	(0X54DB,	"(skip near call return addr)",	0);
	create_insn	(x=0X54DB);
	op_hex		(x,	1);
	set_cmt	(0X54DE,	"done with this interrupt",	0);
	set_cmt	(0X54DF,	"allocated ; error flag",	0);
	create_insn	(0X54DF);
	set_cmt	(0X54E1,	"no, continue",	0);
	set_cmt	(0X54E3,	"[es:bp+allocbyte] ; yes, restore error value",	0);
	create_insn	(0X54EC);
	set_cmt	(0X54F3,	"flag this entry",	0);
	set_cmt	(0X54F5,	"clobbered",	0);
	set_cmt	(0X54FA,	"keep looking",	0);
	set_cmt	(0X54FC,	"start with last entry in table",	0);
	create_insn	(0X54FC);
	set_name	(0X54FC,	"longpath");
	set_cmt	(0X5501,	"free ?",	0);
	set_cmt	(0X5506,	"no, try next one",	0);
	set_cmt	(0X550A,	"[es:bp+allocbyte] ; allocate entry",	0);
	set_cmt	(0X550E,	"is it still free?",	0);
	set_cmt	(0X5510,	"yes, go use it",	0);
	set_cmt	(0X5512,	"allocated ?\nis it other than Allocated or Free?",	0);
	set_cmt	(0X5514,	"no, check the next one",	0);
	set_cmt	(0X5516,	"yes, put back the error state",	0);
	create_insn	(0X5526);
	create_insn	(0X5527);
	set_cmt	(0X5528,	"look at the model byte",	0);
	set_cmt	(0X552D,	"mdl_convert ; convertible?",	0);
	set_cmt	(0X5535,	"disable pc convertible nmis",	0);
	set_cmt	(0X5537,	"CMOS Memory/RTC Index Register (Extended RAM)",	0);
	create_insn	(x=0X5537);
	op_hex		(x,	0);
	set_cmt	(0X5539,	"disable and mask",	0);
	set_name	(0X5539,	"skip_nmis");
	set_cmt	(0X553A,	"all other ints",	0);
	set_cmt	(0X553C,	"Interrupt controller, 8259A.",	0);
	create_insn	(x=0X553C);
	op_hex		(x,	0);
	set_cmt	(0X553E,	"Interrupt Controller #2, 8259A",	0);
	create_insn	(x=0X553E);
	op_hex		(x,	0);
	create_insn	(x=0X5544);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5549,	"DOSBIODATASEG (BIOSDATA segment)",	0);
	create_insn	(x=0X5549);
	op_hex		(x,	1);
	set_cmt	(0X554E,	"BIOSDATA:0812h",	0);
	create_insn	(x=0X554E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X5557,	"call DOSBIODATASEG:V86_Crit_SetFocus",	0);
	create_insn	(x=0X5557);
	set_cmt	(0X5565,	"(whoops, this enables ints)\n- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X5565);
	op_hex		(x,	0);
	create_insn	(0X5569);
	set_name	(0X5569,	"fatal_done");
	create_strlit	(0X556B,	0X5599);
	set_name	(0X556B,	"fatal_msg");
	create_insn	(0X5599);
	set_name	(0X5599,	"_SYSINIT");
	create_byte	(0X559C);
	set_name	(0X559C,	"runhigh");
	set_cmt	(0X559D,	"address of the DOS Sysini Variables",	0);
	create_dword	(0X559D);
	set_name	(0X559D,	"DOSINFO");
	create_word	(0X55A1);
	set_name	(0X55A1,	"dosinit");
	create_word	(0X55A3);
	set_name	(0X55A3,	"CURRENTDOSLOCATION");
	create_dword	(0X55A5);
	set_name	(0X55A5,	"DEVICE_LIST");
	set_cmt	(0X55A9,	"pointer to country table in dos",	0);
	create_dword	(0X55A9);
	set_name	(0X55A9,	"sysi_country");
	set_cmt	(0X55AD,	"room for dword",	0);
	create_dword	(0X55AD);
	set_name	(0X55AD,	"dos_segreinit");
	set_cmt	(0X55B1,	"dos code size when in low mem",	0);
	create_word	(0X55B1);
	set_name	(0X55B1,	"lo_doscod_size");
	set_cmt	(0X55B3,	"dos code size when in HMA",	0);
	create_word	(0X55B3);
	set_name	(0X55B3,	"hi_doscod_size");
	create_word	(0X55B5);
	set_name	(0X55B5,	"def_php");
	set_cmt	(0X55B7,	"BIOSCODE:0032h",	0);
	create_word	(x=0X55B7);
	op_plain_offset	(x,	0,	0X3530);
	op_plain_offset	(x,	128,	0X3530);
	set_name	(0X55B7,	"_seg_reinit_ptr");
	set_cmt	(0X55B9,	"DOSBIOCODESEG (BIOSCODE)",	0);
	create_word	(0X55B9);
	set_name	(0X55B9,	"temp_bcode_seg");
	set_cmt	(0X55BB,	"set to 1 if this machine\ndoes not have any floppies!!!",	0);
	create_byte	(0X55BB);
	set_name	(0X55BB,	"fake_floppy_drv");
	set_cmt	(0X55BC,	"defaultcount ; 9",	0);
	create_word	(0X55BC);
	set_name	(0X55BC,	"stack_count");
	set_cmt	(0X55BE,	"defaultsize  ; 128",	0);
	create_word	(x=0X55BE);
	op_dec		(x,	0);
	set_name	(0X55BE,	"stack_size");
	create_word	(0X55C0);
	make_array	(0X55C0,	0X2);
	set_name	(0X55C0,	"stack_addr");
	create_word	(0X55C4);
	set_name	(0X55C4,	"MEMORY_SIZE");
	create_word	(0X55C6);
	set_name	(0X55C6,	"RPLMemTop");
	set_cmt	(0X55C8,	"initialized by ibminit",	0);
	create_byte	(0X55C8);
	set_name	(0X55C8,	"DEFAULT_DRIVE");
	set_cmt	(0X55C9,	"initialized during buffer allocation",	0);
	create_word	(0X55C9);
	set_name	(0X55C9,	"buffers");
	set_cmt	(0X55CB,	"# of the heuristic buffers. initially 0.",	0);
	create_word	(0X55CB);
	set_name	(0X55CB,	"h_buffers");
	set_cmt	(0X55CD,	"maximum sector size + buffer head",	0);
	create_word	(0X55CD);
	set_name	(0X55CD,	"singlebuffersize");
	set_cmt	(0X55CF,	"enough files for pipe",	0);
	create_byte	(0X55CF);
	set_name	(0X55CF,	"FILES");
	set_cmt	(0X55D0,	"performance for recycling",	0);
	create_byte	(0X55D0);
	set_name	(0X55D0,	"FCBS");
	set_cmt	(0X55D1,	"keep original set",	0);
	create_byte	(0X55D1);
	set_name	(0X55D1,	"KEEP");
	set_cmt	(0X55D2,	"5 net drives",	0);
	create_byte	(0X55D2);
	set_name	(0X55D2,	"NUM_CDS");
	create_word	(0X55D3);
	set_name	(0X55D3,	"CONFBOT");
	create_word	(0X55D5);
	set_name	(0X55D5,	"ALLOCLIM");
	create_word	(0X55D7);
	set_name	(0X55D7,	"top_of_cdss");
	set_cmt	(0X55D9,	"string for the root directory of a drive",	0);
	create_strlit	(0X55D9,	0X55DD);
	set_name	(0X55D9,	"DirStrng");
	create_byte	(0X55DD);
	set_name	(0X55DD,	"ZERO");
	create_byte	(0X55DE);
	set_name	(0X55DE,	"sepchr");
	set_cmt	(0X55DF,	"line count in config.sys",	0);
	create_word	(0X55DF);
	set_name	(0X55DF,	"linecount");
	set_cmt	(0X55E1,	"used to convert linecount to ascii.",	0);
	create_strlit	(0X55E1,	0X55E9);
	set_name	(0X55E1,	"showcount");
	set_cmt	(0X55E9,	"line count for \"buffers=\" command if entered.",	0);
	create_word	(0X55E9);
	set_name	(0X55E9,	"buffer_linenum");
	set_cmt	(0X55EB,	"model byte used in sysinit",	0);
	create_byte	(0X55EB);
	set_name	(0X55EB,	"sys_model_byte");
	set_cmt	(0X55EC,	"secondary model byte used in sysinit",	0);
	create_byte	(0X55EC);
	set_name	(0X55EC,	"sys_scnd_model_byte");
	create_word	(0X55ED);
	set_name	(0X55ED,	"buf_prev_off");
	set_cmt	(0X55EF,	"COMEXE  ; seg addr of environment",	0);
	create_word	(0X55EF);
	set_name	(0X55EF,	"EXEC0_ENVIRON");
	set_cmt	(0X55F1,	"pointer to asciz command line",	0);
	create_word	(x=0X55F1);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X55F1,	"EXEC0_COM_LINE");
	set_cmt	(0X55F3,	"SYSINIT segment",	0);
	create_word	(0X55F3);
	create_word	(x=0X55F5);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X55F5,	"EXEC0_5C_FCB");
	set_cmt	(0X55F7,	"SYSINIT segment",	0);
	create_word	(0X55F7);
	create_word	(x=0X55F9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X55F9,	"EXEC0_6C_FCB");
	set_cmt	(0X55FB,	"SYSINIT segment",	0);
	create_word	(0X55FB);
	set_cmt	(0X55FD,	"parameter passed to multi_pass\nindicating the pass number\n 0 - do scan for DOS=HIGH/LOW\n 1 - load device drivers\n 2 - was to load IFS\n     now it is unused\n 3 - do install=\n>3 - nop",	0);
	create_byte	(0X55FD);
	set_name	(0X55FD,	"multi_pass_id");
	set_cmt	(0X55FE,	"bit 0 - config.sys has install= commands\nbit 1 - sysinit_base installed",	0);
	create_word	(0X55FE);
	set_name	(0X55FE,	"install_flag");
	set_cmt	(0X5600,	"size of config.sys file",	0);
	create_word	(0X5600);
	set_name	(0X5600,	"config_size");
	set_cmt	(0X5602,	"pointer to sysinit_base",	0);
	create_dword	(0X5602);
	set_name	(0X5602,	"sysinit_base_ptr");
	set_cmt	(0X5606,	"returning address from sysinit_base",	0);
	create_word	(0X5606);
	make_array	(0X5606,	0X2);
	set_name	(0X5606,	"sysinit_ptr");
	set_cmt	(0X560A,	"used by sum_up",	0);
	create_word	(0X560A);
	set_name	(0X560A,	"checksum");
	set_cmt	(0X560C,	"db 20 dup (' ') ; big enough",	0);
	create_byte	(x=0X560C);
	make_array	(x,	0X14);
	op_hex		(x,	0);
	set_name	(0X560C,	"ldexec_fcb");
	set_cmt	(0X5620,	"# of parm characters",	0);
	create_byte	(0X5620);
	set_name	(0X5620,	"ldexec_line");
	create_byte	(x=0X5621);
	op_chr		(x,	0);
	set_name	(0X5621,	"ldexec_start");
	set_cmt	(0X5622,	"times 80 db 0",	0);
	create_byte	(x=0X5622);
	make_array	(x,	0X50);
	op_dec		(x,	0);
	set_name	(0X5622,	"ldexec_parm");
	set_cmt	(0X5672,	"instexe ; seg addr of environment",	0);
	create_word	(0X5672);
	set_name	(0X5672,	"iexec.environ");
	set_cmt	(0X5674,	"pointer to asciiz command line",	0);
	create_word	(x=0X5674);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X5674,	"iexec_ldexec_line");
	create_word	(0X5676);
	set_name	(0X5676,	"iexec_ldexec_line_seg");
	set_cmt	(0X5678,	"default fcb at 5Ch",	0);
	create_word	(x=0X5678);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X5678,	"iexec_ldexec_5c_fcb");
	create_word	(0X567A);
	set_name	(0X567A,	"iexec_ldexec_5c_fcb_seg");
	set_cmt	(0X567C,	"default fcb at 6Ch",	0);
	create_word	(x=0X567C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X567C,	"iexec_ldexec_6c_fcb");
	create_word	(0X567E);
	set_name	(0X567E,	"iexec_ldexec_6c_fcb_seg");
	set_cmt	(0X5680,	"level of \" \" in command line",	0);
	create_byte	(0X5680);
	set_name	(0X5680,	"com_level");
	set_cmt	(0X5681,	"length of comment string token",	0);
	create_byte	(0X5681);
	set_name	(0X5681,	"cmmt");
	set_cmt	(0X5682,	"token",	0);
	create_byte	(0X5682);
	set_name	(0X5682,	"cmmt1");
	set_cmt	(0X5683,	"token",	0);
	create_byte	(0X5683);
	set_name	(0X5683,	"cmmt2");
	create_byte	(0X5684);
	set_name	(0X5684,	"cmd_indicator");
	create_byte	(0X5685);
	set_name	(0X5685,	"donotshownum");
	create_word	(0X5686);
	set_name	(0X5686,	"count");
	create_word	(0X5688);
	set_name	(0X5688,	"org_count");
	create_word	(0X568A);
	set_name	(0X568A,	"chrptr");
	create_word	(0X568C);
	set_name	(0X568C,	"cntryfilehandle");
	create_word	(0X568E);
	set_name	(0X568E,	"old_area");
	set_cmt	(0X5690,	"paragraph",	0);
	create_word	(0X5690);
	set_name	(0X5690,	"impossible_owner_size");
	set_cmt	(0X5692,	"bufptr, bucketptr (dword)",	0);
	create_word	(0X5692);
	set_name	(0X5692,	"memlo");
	set_cmt	(0X5694,	"prmblk (word)",	0);
	create_word	(0X5694);
	set_name	(0X5694,	"memhi");
	create_word	(0X5696);
	set_name	(0X5696,	"ldoff");
	create_word	(0X5698);
	set_name	(0X5698,	"area");
	create_word	(0X569A);
	set_name	(0X569A,	"prev_memhi");
	create_word	(0X569C);
	set_name	(0X569C,	"prev_alloclim");
	create_byte	(0X569E);
	set_name	(0X569E,	"dosdata_umb");
	set_cmt	(0X569F,	"was 24 (in MSDOS 6.21)",	0);
	create_byte	(x=0X569F);
	op_dec		(x,	0);
	set_name	(0X569F,	"packet");
	create_byte	(0X56A0);
	set_cmt	(0X56A1,	"initialize code",	0);
	create_byte	(0X56A1);
	create_word	(0X56A2);
	create_byte	(0X56A4);
	make_array	(0X56A4,	0X8);
	create_byte	(0X56AC);
	set_name	(0X56AC,	"unitcount");
	create_word	(0X56AD);
	make_array	(0X56AD,	0X2);
	set_name	(0X56AD,	"break_addr");
	create_dword	(0X56B1);
	set_name	(0X56B1,	"bpb_addr");
	create_byte	(0X56B5);
	set_name	(0X56B5,	"devdrivenum");
	set_cmt	(0X56B6,	"used to control \"error in config.sys line #\" message\n(configmsgflag is the last word of the 25 byte packet)\n((default value is 0, device driver init may change? it))",	0);
	create_byte	(0X56B6);
	set_name	(0X56B6,	"configmsgflag");
	create_byte	(0X56B7);
	create_byte	(0X56B8);
	set_name	(0X56B8,	"drivenumber");
	set_cmt	(0X56B9,	">24 fixed disk partitions flag",	0);
	create_byte	(0X56B9);
	set_name	(0X56B9,	"toomanydrivesflag");
	set_cmt	(0X56BA,	"DOSBIOCODESEG (BIOSCODE segment)",	0);
	create_word	(0X56BA);
	set_name	(0X56BA,	"BCodeSeg");
	create_word	(0X56BC);
	set_name	(0X56BC,	"_timer_lw_");
	create_byte	(0X56BE);
	set_name	(0X56BE,	"F5_key");
	create_byte	(0X56BF);
	set_name	(0X56BF,	"F8_key");
	create_dword	(0X56C0);
	set_name	(0X56C0,	"MagicBackdoor");
	create_insn	(0X56C4);
	set_name	(0X56C4,	"NullBackdoor");
	set_cmt	(0X56C5,	"BIOSDATA:07DDh",	0);
	create_word	(x=0X56C5);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_name	(0X56C5,	"BiosComBlock");
	set_cmt	(0X56C7,	"BIOSDATA segment",	0);
	create_word	(0X56C7);
	create_byte	(x=0X56C9);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0X56C9,	"tempstack");
	create_insn	(x=0X5749);
	op_hex		(x,	1);
	set_name	(0X5749,	"goinit");
	set_cmt	(0X574B,	"SYSTEM - GET CONFIGURATION \n(XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)",	0);
	create_insn	(x=0X574B);
	op_hex		(x,	0);
	set_cmt	(0X5754,	"[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]",	0);
	set_cmt	(0X575C,	"[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]",	0);
	create_insn	(0X5766);
	set_name	(0X5766,	"no_rom_config");
	set_cmt	(0X5772,	"EQUIPMENT DETERMINATION\nReturn: AX = equipment flag bits",	0);
	create_insn	(x=0X5772);
	op_hex		(x,	0);
	set_cmt	(0X5776,	"'RPS' sign",	0);
	set_cmt	(0X5779,	"(nonsense! this may be overwritten/disabled\nby using 'RPS' sign position) 03/07/2023 - Erdogan Tan",	0);
	create_insn	(x=0X5779);
	op_hex		(x,	1);
	set_name	(0X5779,	"check_for_fake_floppy");
	set_cmt	(0X577C,	"have any floppies?",	0);
	create_insn	(x=0X577C);
	op_hex		(x,	1);
	set_cmt	(0X577F,	"yes,normal system",	0);
	set_cmt	(0X5784,	"get disk parameters",	0);
	set_cmt	(0X5788,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter",	0);
	create_insn	(x=0X5788);
	op_hex		(x,	0);
	set_cmt	(0X578B,	"if error lets assume that the ROM BIOS lied",	0);
	set_cmt	(0X578D,	"double check (max sec no cannot be 0)",	0);
	set_cmt	(0X5792,	"number of flp drvs == 0?",	0);
	set_cmt	(0X5796,	"set fake flag",	0);
	set_cmt	(0X579C,	"set up move",	0);
	set_name	(0X579C,	"move_myself");
	set_cmt	(0X57AB,	"0",	0);
	set_cmt	(0X57AD,	"Int 2Fh vector (4*2Fh)",	0);
	create_insn	(x=0X57AD);
	create_insn	(x=0X57B2);
	set_cmt	(0X57B7,	"'RP'",	0);
	create_insn	(x=0X57B7);
	op_hex		(x,	1);
	set_cmt	(0X57BF,	"'L'",	0);
	create_insn	(x=0X57BF);
	op_hex		(x,	1);
	set_cmt	(0X57C6,	"get TOM into DX",	0);
	set_cmt	(0X57C9,	"(multMULT<<8)+multMULTRPLTOM",	0);
	set_cmt	(0X57CC,	"Get new TOM from any RPL",	0);
	create_insn	(x=0X57CC);
	op_hex		(x,	0);
	set_cmt	(0X57DB,	"SI_end ; need this much room for sysinit\n(SI_end == sysinit code size)",	0);
	set_name	(0X57DB,	"NoRPL");
	set_cmt	(0X57E3,	"DOSSIZE/16 (2816)\nleave this much room for DOS",	0);
	set_cmt	(0X57E7,	"BCODE_END",	0);
	set_cmt	(0X57EA,	"leave this much room for BIOS code",	0);
	set_cmt	(0X57EF,	"offset where sysinit will be located",	0);
	set_cmt	(0X57F1,	"SI_end ; (sysinit code size)",	0);
	set_cmt	(0X57F4,	"divide by 2 to get words",	0);
	create_insn	(x=0X57F4);
	op_hex		(x,	1);
	set_cmt	(0X57F6,	"relocate sysinit",	0);
	set_cmt	(0X57F8,	"push relocated segment",	0);
	set_cmt	(0X57F9,	"SYSINIT:04F3h",	0);
	create_insn	(x=0X57F9);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X57FC,	"push relocated entry point",	0);
	set_cmt	(0X57FD,	"far jump to relocated sysinit",	0);
	create_insn	(0X57FE);
	set_name	(0X57FE,	"get_cpu_type");
	create_insn	(x=0X5808);
	op_hex		(x,	1);
	create_insn	(x=0X5817);
	op_hex		(x,	1);
	set_name	(0X581C,	"cpu_386");
	create_insn	(x=0X5823);
	op_hex		(x,	1);
	set_name	(0X5823,	"SYSIN");
	set_cmt	(0X5826,	"DOSBIODATASEG",	0);
	set_cmt	(0X5829,	"not needed (*) E.TAN - 03/07/2023",	0);
	set_cmt	(0X582B,	"determine if 386 system",	0);
	set_cmt	(0X582E,	"0 = 8086, 1 = 286, 2 = 386",	0);
	set_cmt	(0X5833,	"80386",	0);
	set_cmt	(0X5835,	"change A20 line on/off check code",	0);
	create_insn	(x=0X5836);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X5839,	"mov cx,4 ; B90400",	0);
	set_cmt	(0X583D,	"repz  ; F3",	0);
	set_cmt	(0X5841,	"cmpsd ; 66A7",	0);
	set_name	(0X5845,	"not_386_system");
	set_cmt	(0X5846,	"not needed (*) E.TAN - 03/07/2023",	0);
	set_cmt	(0X5848,	"set seg of routine to move DOS\nupdate SYSINITSEG field\nMoveDOSIntoHMA+2",	0);
	create_insn	(x=0X5848);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X584C,	"flag that MoveDOSIntoHMA can be called",	0);
	create_insn	(x=0X584C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5851,	"SI_end ; how big is sysinitseg?",	0);
	set_cmt	(0X5857,	"pick a buffer for msdos above us",	0);
	set_cmt	(0X5861,	"where it is (set by msinit)",	0);
	set_cmt	(0X5866,	"DOSSIZE/2 (22528)",	0);
	set_cmt	(0X5870,	"get offset of dos\nax = 3F10h for IBMDOS 7.1 kernel\n (IBMDOS.SYS, offset 3)",	0);
	set_cmt	(0X5877,	"subtract this much from segment",	0);
	set_cmt	(0X587A,	"FINAL_DOS_LOCATION",	0);
	set_cmt	(0X5881,	"DOSSIZE/16 ; DOSSIZE = 0B000h = 45056",	0);
	set_cmt	(0X5886,	"swap with original home of Bios_Code",	0);
	set_cmt	(0X588B,	"point to loaded image of Bios_Code",	0);
	set_cmt	(0X588D,	"BCODESTART (= BiosDataWord)\nBIOSCODE:BCODESTART (BIOSCODE:0030h)",	0);
	create_insn	(x=0X588D);
	op_plain_offset	(x,	1,	0X3530);
	op_plain_offset	(x,	129,	0X3530);
	set_cmt	(0X5892,	"BCODE_END = (SYSINITSEG-DOSBIOCODESEG)*16\n(544h-364h)*10h = 1E00h (for PCDOS 7.1 IBMBIO.COM)",	0);
	create_insn	(x=0X5897);
	op_hex		(x,	1);
	set_cmt	(0X5899,	"move Bios_Code into place",	0);
	set_cmt	(0X589B,	"tell it what segment it's in",	0);
	create_insn	(x=0X589D);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X58B6,	"set stack\nmov sp, 586h ; mov sp, locstack\n%define locstack ($ - SYSINIT$) & 0FFFEh\nlocstack = $ & 0FFFEh (SYSINIT:SYSINITŞ=544h:0)",	0);
	create_insn	(x=0X58B6);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X58B6,	"locstack");
	set_cmt	(0X58BA,	"call dosinit\nes:di -> sysinitvars_ext",	0);
	set_cmt	(0X58BF,	"save pointer to PSP",	0);
	set_cmt	(0X58C4,	"size of doscode (including exepatch)",	0);
	set_cmt	(0X58C8,	"(as exepatch excluded)",	0);
	set_cmt	(0X58CD,	"save offset of segreinit",	0);
	set_cmt	(0X58D2,	"[es:di+SysInitVars_Ext.SYSI_InitVars]",	0);
	set_cmt	(0X58E1,	"[es:di+SysInitVars_Ext.SYSI_Country_Tab]",	0);
	set_cmt	(0X58E9,	"[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]",	0);
	set_cmt	(0X58F1,	"= [FINAL_DOS_LOCATION]",	0);
	create_insn	(x=0X5906);
	op_hex		(x,	1);
	set_cmt	(0X5908,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5908);
	op_hex		(x,	0);
	create_insn	(x=0X590A);
	op_hex		(x,	1);
	set_cmt	(0X590C,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X590C);
	op_hex		(x,	0);
	set_cmt	(0X5910,	"resize upto RPL mem",	0);
	create_insn	(x=0X591B);
	op_hex		(x,	1);
	set_cmt	(0X591D,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs",	0);
	create_insn	(x=0X591D);
	op_hex		(x,	0);
	create_insn	(x=0X5922);
	op_hex		(x,	1);
	set_cmt	(0X5924,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5924);
	op_hex		(x,	0);
	create_insn	(x=0X5926);
	op_hex		(x,	1);
	set_cmt	(0X5928,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5928);
	op_hex		(x,	0);
	set_cmt	(0X592D,	"[es:arena_owner]",	0);
	set_cmt	(0X5934,	"[es:arena_name],'RP'",	0);
	set_cmt	(0X593B,	"[es:arena_name+2],'L'",	0);
	create_insn	(x=0X593B);
	op_dec		(x,	0);
	set_cmt	(0X5942,	"[es:arena_name+4]",	0);
	create_insn	(x=0X5942);
	op_dec		(x,	0);
	set_cmt	(0X5949,	"[es:arena_name+6]",	0);
	create_insn	(x=0X5949);
	op_dec		(x,	0);
	set_cmt	(0X5951,	"Dealloc",	0);
	create_insn	(x=0X5951);
	op_hex		(x,	1);
	set_cmt	(0X5953,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed",	0);
	create_insn	(x=0X5953);
	op_hex		(x,	0);
	set_name	(0X5955,	"NoRPLArena");
	set_cmt	(0X595D,	"Get Extended Memory Size\nReturn: CF clear on success\nAX = size of memory above 1M in K",	0);
	create_insn	(x=0X595D);
	op_hex		(x,	0);
	set_cmt	(0X5961,	"[es:di+SYSI_EXT_MEM]",	0);
	set_cmt	(0X596C,	"[es:di+SYSI_MAXSEC]",	0);
	set_name	(0X596C,	"no_ext_memory");
	set_cmt	(0X5970,	"bufinsiz\nsize of buffer header = 24 (PCDOS v7.1 IBMBIO.COM)\n(it was 20 in MSDOS 6.21 IO:SYS)",	0);
	create_insn	(x=0X5970);
	op_dec		(x,	1);
	set_cmt	(0X5973,	"total size for a buffer",	0);
	set_cmt	(0X597B,	"[es:di+SYSI_BOOT_DRIVE]",	0);
	set_name	(0X597F,	"_get_cpu_type");
	create_insn	(x=0X5989);
	op_hex		(x,	1);
	create_insn	(x=0X5998);
	op_hex		(x,	1);
	set_name	(0X599D,	"_cpu_386");
	set_name	(0X599E,	"_cpu_286");
	set_name	(0X599F,	"_cpu_8086");
	set_cmt	(0X59A8,	"[es:di+SYSI_DWMOVE],1 \nset doubleword moving flag",	0);
	set_cmt	(0X59AD,	"[es:di+SYSI_NUMIO]",	0);
	set_name	(0X59AD,	"_not_386_cpu");
	set_cmt	(0X59B1,	"save start of installable block drvs",	0);
	set_cmt	(0X59B7,	"room for PSP we will copy shortly",	0);
	set_cmt	(0X59BA,	"temporary single buffer area",	0);
	create_insn	(x=0X59BF);
	op_hex		(x,	1);
	create_insn	(x=0X59C1);
	op_hex		(x,	1);
	create_insn	(x=0X59C3);
	op_hex		(x,	1);
	set_cmt	(0X59C5,	"divide size by 16..\n...to get paragraphs...",	0);
	create_insn	(x=0X59C5);
	op_hex		(x,	1);
	set_cmt	(0X59C7,	"... and round up",	0);
	set_cmt	(0X59CA,	"temp \"unsafe\" location",	0);
	set_cmt	(0X59D0,	"save pointer for buffer",	0);
	set_cmt	(0X59D2,	"sub ax,((26 *(curdirlen))+15)/16\n(curdirlen=88)",	0);
	create_insn	(x=0X59D2);
	op_dec		(x,	1);
	set_cmt	(0X59DD,	"[es:di+SYSI_BUF]",	0);
	set_cmt	(0X59E1,	"[es:di+BUFFINF.Dirty_Buff_Count]",	0);
	set_cmt	(0X59E7,	"[es:di+BUFFINF.Buff_Queue]",	0);
	set_cmt	(0X59EC,	"[es:di+BUFFINF.Buff_Queue+2]\ncx = [top_of_cdss]",	0);
	set_cmt	(0X59F6,	"[es:di+buffinfo.buf_next],0",	0);
	set_cmt	(0X59F9,	"[es:di+buffinfo.buf_prev],0",	0);
	set_cmt	(0X59FD,	"[es:di+buffinfo.buf_ID],00FFh\nfree buffer,clear flag",	0);
	set_cmt	(0X5A03,	"[es:di+buffinfo.buf_sector]",	0);
	set_cmt	(0X5A09,	"[es:di+buffinfo.buf_sector+2]",	0);
	set_cmt	(0X5A13,	"set up cdss so re_init and sysinit\ncan make disk system calls\ntempcds trashes ds",	0);
	set_cmt	(0X5A16,	"retrieve pointer to PSP returned by DOSINIT",	0);
	set_cmt	(0X5A1B,	"call DOSBIODATASEG:re_init",	0);
	create_insn	(x=0X5A1B);
	create_insn	(x=0X5A24);
	op_hex		(x,	1);
	create_insn	(x=0X5A2D);
	op_dec		(x,	1);
	set_cmt	(0X5A32,	"[es:PDB.JFN_POINTER+2],es ; Relocate",	0);
	create_insn	(x=0X5A32);
	create_insn	(x=0X5A37);
	op_hex		(x,	1);
	set_cmt	(0X5A39,	"DOS - 2+ internal - SET PSP SEGMENT\nBX = segment address of new PSP",	0);
	create_insn	(x=0X5A39);
	op_hex		(x,	0);
	set_cmt	(0X5A3E,	"set up int 24h handler",	0);
	create_insn	(x=0X5A3E);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X5A41);
	op_hex		(x,	1);
	set_cmt	(0X5A44,	"DOS - SET INTERRUPT VECTOR\nAL = interrupt number\nDS:DX = new vector to be used for specified interrupt",	0);
	create_insn	(x=0X5A44);
	op_hex		(x,	0);
	create_insn	(x=0X5A4D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5A53,	"no_err");
	create_insn	(x=0X5A5F);
	op_hex		(x,	1);
	set_cmt	(0X5A61,	"DOS - SELECT DISK\nDL = new default drive number (0 = A, 1 = B, etc.)\nReturn: AL = number of logical drives",	0);
	create_insn	(x=0X5A61);
	op_hex		(x,	0);
	set_name	(0X5A63,	"nodrvset");
	set_cmt	(0X5A66,	"0  ; ROMBIOS data area",	0);
	set_cmt	(0X5A68,	"Counter for Interrupt 1Ah\ntimer tick count (18.2 ticks per second)",	0);
	create_insn	(x=0X5A68);
	create_insn	(x=0X5A77);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X5A7E);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5A7E,	"set_drvspc_size");
	set_name	(0X5A81,	"set_dblspc_size");
	create_insn	(x=0X5A86);
	op_chr		(x,	1);
	create_insn	(x=0X5A99);
	op_chr		(x,	1);
	set_name	(0X5A99,	"set_drvspc_name");
	set_cmt	(0X5AA1,	"'RV' ; DRVSPACE.BIN",	0);
	create_insn	(x=0X5AA1);
	op_chr		(x,	1);
	create_insn	(x=0X5AAA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5AAA,	"set_stacker_name");
	create_insn	(x=0X5AB0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X5AB5);
	set_name	(0X5AB5,	"wait_for_key_2s");
	set_cmt	(0X5ABD,	"0 ; ROMBIOS data area",	0);
	set_cmt	(0X5ABF,	"Counter for Interrupt 1Ah",	0);
	create_insn	(x=0X5ABF);
	set_name	(0X5AC3,	"wfk2s_1");
	set_cmt	(0X5AC5,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer",	0);
	create_insn	(x=0X5AC5);
	op_hex		(x,	0);
	set_cmt	(0X5ACB,	"KEYBOARD - GET SHIFT STATUS\nAL = shift status bits",	0);
	create_insn	(x=0X5ACB);
	op_hex		(x,	0);
	create_insn	(x=0X5ACD);
	op_hex		(x,	1);
	set_cmt	(0X5AD1,	"tick count",	0);
	create_insn	(x=0X5AD1);
	set_cmt	(0X5AD6,	"2 seconds",	0);
	create_insn	(x=0X5AD6);
	op_dec		(x,	1);
	set_cmt	(0X5AD8,	"wait for user's key press",	0);
	set_cmt	(0X5ADA,	"read/check the pressed key",	0);
	set_name	(0X5ADA,	"wfk2s_2");
	set_cmt	(0X5ADB,	"bx = 0",	0);
	set_cmt	(0X5ADF,	"KEYBOARD - GET SHIFT STATUS\nAL = shift status bits",	0);
	create_insn	(x=0X5ADF);
	op_hex		(x,	0);
	set_cmt	(0X5AE1,	"Left or Right SHIFT key pressed ?",	0);
	create_insn	(x=0X5AE1);
	op_hex		(x,	1);
	set_cmt	(0X5AE3,	"no",	0);
	set_cmt	(0X5AE6,	"bx = 2",	0);
	set_name	(0X5AE7,	"wfk2s_3");
	set_cmt	(0X5AE9,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer",	0);
	create_insn	(x=0X5AE9);
	op_hex		(x,	0);
	set_cmt	(0X5AED,	"F8 key pressed ?",	0);
	create_insn	(x=0X5AED);
	op_hex		(x,	1);
	set_cmt	(0X5AF2,	"F5 key pressed ?",	0);
	create_insn	(x=0X5AF2);
	op_hex		(x,	1);
	set_cmt	(0X5AFD,	"continue (as normal/default state)",	0);
	set_name	(0X5AFD,	"wfk2s_4");
	create_insn	(0X5AFF);
	set_name	(0X5AFF,	"wfk2s_5");
	set_cmt	(0X5B07,	"get the largest free block from DOS",	0);
	create_insn	(0X5B07);
	set_name	(0X5B07,	"wfk2s_6");
	set_cmt	(0X5B0A,	"**** PRE-LOAD MAGICDRV!!! ****",	0);
	set_cmt	(0X5B0D,	"error?",	0);
	set_name	(0X5B0D,	"wfk2s_7");
	set_cmt	(0X5B11,	"Dealloc ; free the block if no load",	0);
	create_insn	(x=0X5B11);
	op_hex		(x,	1);
	set_name	(0X5B11,	"PreloadFailed");
	set_cmt	(0X5B18,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed",	0);
	create_insn	(x=0X5B18);
	op_hex		(x,	0);
	create_insn	(0X5B1C);
	set_name	(0X5B1C,	"wfk2s_8");
	set_cmt	(0X5B26,	"get desired block size in paras",	0);
	create_insn	(x=0X5B2B);
	op_hex		(x,	1);
	set_cmt	(0X5B2D,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs",	0);
	create_insn	(x=0X5B2D);
	op_hex		(x,	0);
	set_cmt	(0X5B32,	"get Magicdrv arena",	0);
	set_cmt	(0X5B34,	"[es:arena_owner], 8 ; set impossible owner",	0);
	set_cmt	(0X5B3B,	"[es:arena_name],'SD' ; System Data",	0);
	set_cmt	(0X5B42,	"get MCB length",	0);
	set_cmt	(0X5B47,	"get to arena header",	0);
	set_cmt	(0X5B4C,	"get addr of next MCB",	1);
	set_cmt	(0X5B4D,	"store that",	0);
	set_name	(0X5B50,	"ProcessConfig");
	set_cmt	(0X5B53,	"Did user choose to run low ?",	0);
	set_cmt	(0X5B59,	"yes, don't install dos low mem stub",	0);
	set_cmt	(0X5B60,	"ax = 0 --> install stub",	0);
	set_cmt	(0X5B62,	"call far [dos_segreinit]",	0);
	create_insn	(0X5B69);
	set_name	(0X5B69,	"dont_install_stub");
	set_cmt	(0X5B76,	"call far [cs:dos_segreinit]\ninform dos about new seg",	0);
	set_cmt	(0X5B7B,	"allocate all the free mem & update [memhi]\n& [area] start of free memory.",	0);
	set_name	(0X5B7B,	"do_multi_pass");
	set_cmt	(0X5B8E,	"bx=0 ; magic backdoor to place int hooks",	0);
	set_cmt	(0X5B95,	"multi_pass_id = 1",	0);
	set_name	(0X5B95,	"skip_magicbackdoor");
	set_cmt	(0X5B9A,	"load device drivers",	0);
	set_cmt	(0X5BA0,	"unlink all UMBs",	0);
	set_cmt	(0X5BA3,	"multi_pass_id = 2",	0);
	set_cmt	(0X5BBB,	"make sure Magicdrv is final placed",	0);
	set_cmt	(0X5BBE,	"setup fcbs, files, buffers etc",	0);
	set_cmt	(0X5BC1,	"disable CDSs of reserved drives",	0);
	create_insn	(0X5BC6);
	set_name	(0X5BC6,	"skip_magicpostload");
	set_cmt	(0X5BC9,	"DOSBIODATASEG",	0);
	create_insn	(x=0X5BC9);
	op_hex		(x,	1);
	set_name	(0X5BC9,	"_@_");
	set_cmt	(0X5BCC,	"BIOSDATA segment",	0);
	set_cmt	(0X5BCE,	"clear SysinitPresent flag",	0);
	create_insn	(x=0X5BCE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5BD4,	"have_install_cmd\nare there install commands?",	0);
	create_insn	(x=0X5BD4);
	op_hex		(x,	1);
	set_cmt	(0X5BE5,	"are we still waiting to be moved?",	0);
	set_name	(0X5BE5,	"dolast");
	set_cmt	(0X5BEB,	"no, our job is over",	0);
	create_insn	(x=0X5BED);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X5BF0,	"are we running low",	0);
	set_name	(0X5BF0,	"_@@_");
	set_cmt	(0X5BF6,	"yes, no CPM hack needed",	0);
	set_cmt	(0X5BF8,	"make ffff:d0 same as 0:c0",	0);
	set_name	(0X5BFB,	"ConfigDone");
	set_cmt	(0X5C06,	"DEALLOC ; free allocated memory for command.com",	0);
	create_insn	(x=0X5C06);
	op_hex		(x,	1);
	set_cmt	(0X5C08,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed",	0);
	create_insn	(x=0X5C08);
	op_hex		(x,	0);
	set_cmt	(0X5C0A,	"has_installed",	0);
	create_insn	(x=0X5C0A);
	op_hex		(x,	1);
	set_cmt	(0X5C11,	"no",	0);
	create_insn	(x=0X5C1F);
	op_hex		(x,	1);
	set_cmt	(0X5C21,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs",	0);
	create_insn	(x=0X5C21);
	op_hex		(x,	0);
	set_cmt	(0X5C26,	"point to arena",	0);
	set_cmt	(0X5C28,	"[es:ARENA.OWNER],8 ; set impossible owner",	0);
	set_cmt	(0X5C2F,	"[es:ARENA.NAME],'SD' ; System Data",	0);
	set_name	(0X5C38,	"skip_free_sysinitbase");
	set_cmt	(0X5C40,	"Install VDISK header (allocates some mem from DOS)",	0);
	set_name	(0X5C43,	"_@@@_");
	set_cmt	(0X5C45,	"set special code for query_user",	0);
	set_cmt	(0X5C4A,	"to issue the AUTOEXEC prompt",	0);
	set_cmt	(0X5C4E,	"Note: This flag is useless because it is not set before \nE.TAN 04/07/2023",	0);
	create_insn	(x=0X5C4E);
	op_hex		(x,	1);
	set_cmt	(0X5C53,	"F5 clean/interactive boot option (has been) disabled",	0);
	set_cmt	(0X5C5A,	"F5 key pressed, bypass AUTOEXEC.BAT (clean boot)",	0);
	set_name	(0X5C5C,	"_@@@@_");
	set_cmt	(0X5C5D,	"we should process autoexec normally",	0);
	set_cmt	(0X5C61,	"cf status at the return from 'query_user' call",	0);
	create_insn	(0X5C61);
	set_name	(0X5C61,	"_@@@@@_");
	set_cmt	(0X5C62,	"set \"skip all\" flag",	0);
	create_insn	(x=0X5C62);
	op_hex		(x,	1);
	set_name	(0X5C62,	"bypass_autoexec");
	set_cmt	(0X5C67,	"no, we should disable it",	0);
	set_name	(0X5C6A,	"process_autoexec");
	create_insn	(x=0X5C74);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5C77,	"retry-4",	0);
	set_cmt	(0X5C79,	"cr-terminate command line",	0);
	create_insn	(x=0X5C7C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5C7C,	"retry");
	set_cmt	(0X5C7F,	"save pointer to file name",	0);
	set_cmt	(0X5C80,	"get biggest piece (second time gets it)",	0);
	create_insn	(x=0X5C83);
	op_hex		(x,	1);
	set_cmt	(0X5C85,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5C85);
	op_hex		(x,	0);
	create_insn	(x=0X5C87);
	op_hex		(x,	1);
	set_cmt	(0X5C89,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5C89);
	op_hex		(x,	0);
	set_cmt	(0X5C8B,	"oooops!",	0);
	create_insn	(x=0X5C8F);
	op_hex		(x,	1);
	set_cmt	(0X5C91,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed",	0);
	create_insn	(x=0X5C91);
	op_hex		(x,	0);
	set_cmt	(0X5C95,	"get location of end of memory",	0);
	set_cmt	(0X5C99,	"get location of beginning of sysinit",	0);
	set_cmt	(0X5C9F,	"use config_wrkseg only if there's env data",	0);
	set_name	(0X5CA4,	"no_env");
	set_cmt	(0X5CA6,	"add the sysinit php",	0);
	create_insn	(x=0X5CA6);
	op_hex		(x,	1);
	set_cmt	(0X5CA9,	"sub sysinit size from amount of free memory",	0);
	set_cmt	(0X5CAB,	"if there isn't even this much memory, give up",	0);
	set_cmt	(0X5CB1,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read",	0);
	create_insn	(x=0X5CB1);
	op_hex		(x,	0);
	set_cmt	(0X5CB7,	"was a new shell selected?",	0);
	set_cmt	(0X5CBC,	"yes",	0);
	set_cmt	(0X5CBE,	"SYSINIT:0948h",	0);
	create_insn	(x=0X5CBE);
	create_insn	(x=0X5CC4);
	op_hex		(x,	1);
	set_cmt	(0X5CC6,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer",	0);
	create_insn	(x=0X5CC6);
	op_hex		(x,	0);
	create_insn	(x=0X5CC8);
	op_hex		(x,	1);
	set_cmt	(0X5CCF,	"COMMAND.COM Version 7.10\n((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)",	0);
	create_insn	(x=0X5CCF);
	op_hex		(x,	1);
	set_name	(0X5CD6,	"skip_validation");
	set_cmt	(0X5CDE,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from end of file",	0);
	create_insn	(x=0X5CDE);
	op_hex		(x,	0);
	set_cmt	(0X5CE2,	"convert size in dx:ax to para in ax",	0);
	set_cmt	(0X5CE5,	"round up size for conversion to para",	0);
	create_insn	(x=0X5CEB);
	op_dec		(x,	1);
	set_cmt	(0X5CED,	"low nibble of dx to high nibble",	0);
	set_cmt	(0X5CEF,	"ax is now # of para for file",	0);
	set_cmt	(0X5CF1,	"100h byte php",	0);
	set_cmt	(0X5CF4,	"will command fit in available mem?",	0);
	set_cmt	(0X5CF6,	"jump if yes.",	0);
	create_insn	(x=0X5CF8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5CF8,	"memerrjx");
	create_insn	(x=0X5D00);
	op_hex		(x,	1);
	set_name	(0X5D00,	"okld");
	set_cmt	(0X5D02,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X5D02);
	op_hex		(x,	0);
	set_cmt	(0X5D06,	"offset COMEXE\npoint to exec block",	0);
	create_insn	(x=0X5D06);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5D14,	"set segments\n[bx+EXEC0.ENVIRON],cx",	0);
	set_name	(0X5D14,	"no_envdata");
	set_cmt	(0X5D16,	"[bx+EXEC0.COM_LINE+2],cs",	0);
	set_cmt	(0X5D19,	"[bx+EXEC0.5C_FCB+2],cs",	0);
	set_cmt	(0X5D1C,	"[bx+EXEC0.6C_FCB+2],cs",	0);
	set_cmt	(0X5D1F,	"(EXEC<<8)",	0);
	set_cmt	(0X5D23,	"DOS - 2+ - LOAD OR EXECUTE (EXEC)\nDS:DX -> ASCIZ filename\nES:BX -> parameter block\nAL = subfunc: load & execute program",	0);
	create_insn	(x=0X5D23);
	op_hex		(x,	0);
	set_name	(0X5D28,	"comerr");
	set_cmt	(0X5D2D,	"all defaults exhausted, print err msg",	0);
	set_cmt	(0X5D34,	"don't print err msg for defaults just yet",	0);
	create_insn	(x=0X5D36);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5D36,	"comerr2");
	set_name	(0X5D3C,	"continue");
	create_insn	(x=0X5D3D);
	op_hex		(x,	1);
	set_cmt	(0X5D3F,	"DOS - GET DEFAULT DISK NUMBER",	0);
	create_insn	(x=0X5D3F);
	op_hex		(x,	0);
	create_insn	(x=0X5D41);
	op_chr		(x,	1);
	set_cmt	(0X5D43,	"dl == default drive letter",	0);
	create_insn	(x=0X5D45);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5D48,	"if a SHELL= was given",	0);
	set_cmt	(0X5D4D,	"then try the 2nd alternate;",	0);
	set_cmt	(0X5D4F,	"otherwise, the default SHELL= was tried,",	0);
	set_cmt	(0X5D52,	"which is the same as our 2nd alt, so skip it",	0);
	set_cmt	(0X5D54,	"has 2nd alternate been tried?",	0);
	create_insn	(0X5D54);
	set_name	(0X5D54,	"do_def2");
	set_cmt	(0X5D57,	"no",	0);
	create_insn	(x=0X5D59);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X5D59,	"do_def3");
	set_cmt	(0X5D5C,	"has 3rd alternate been tried?",	0);
	set_cmt	(0X5D5F,	"no",	0);
	create_insn	(x=0X5D61);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5D64,	"has 4th alternate been tried?",	0);
	set_cmt	(0X5D67,	"no",	0);
	create_insn	(x=0X5D6A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5D70,	"recover default drive letter in dl",	0);
	set_cmt	(0X5D71,	"STD_CON_OUTPUT",	0);
	create_insn	(x=0X5D71);
	op_hex		(x,	1);
	set_name	(0X5D71,	"request_input");
	set_cmt	(0X5D73,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0X5D73);
	op_hex		(x,	0);
	set_cmt	(0X5D76,	"3Eh",	0);
	create_insn	(x=0X5D76);
	op_chr		(x,	1);
	set_cmt	(0X5D78,	"DOS - ",	0);
	create_insn	(x=0X5D78);
	op_hex		(x,	0);
	set_cmt	(0X5D7A,	"[tmplate] = max. chars buffer can hold = 64",	0);
	create_insn	(x=0X5D80);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X5D85);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5D88,	"STD_CON_STRING_INPUT",	0);
	create_insn	(x=0X5D88);
	op_hex		(x,	1);
	set_cmt	(0X5D8A,	"DOS - BUFFERED KEYBOARD INPUT\nDS:DX -> buffer",	0);
	create_insn	(x=0X5D8A);
	op_hex		(x,	0);
	create_insn	(x=0X5D8C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5D97,	"was anything typed?",	0);
	set_cmt	(0X5D9B,	"disable validation for user-specified binaries",	0);
	set_cmt	(0X5DA0,	"NULL-terminate it before execing it",	0);
	create_insn	(x=0X5DA0);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X5DAD);
	set_name	(0X5DAD,	"do_alt");
	set_cmt	(0X5DAF,	"force validation for alternate binaries",	0);
	create_insn	(x=0X5DB4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5DB7,	"copy the alternate, zapping it as we go",	0);
	set_name	(0X5DB7,	"do_alt1");
	set_cmt	(0X5DB8,	"so that we know it's been tried",	0);
	create_insn	(x=0X5DC1);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X5DC4);
	op_chr		(x,	1);
	set_cmt	(0X5DCA,	"stuff default drive into alt. command line",	0);
	set_name	(0X5DCD,	"do_alt2");
	set_cmt	(0X5DD3,	"cr",	0);
	set_name	(0X5DE2,	"do_exec");
	create_insn	(0X5DE5);
	set_name	(0X5DE5,	"AllocFreeMem");
	create_insn	(x=0X5DE8);
	op_hex		(x,	1);
	set_cmt	(0X5DEA,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5DEA);
	op_hex		(x,	0);
	create_insn	(x=0X5DEC);
	op_hex		(x,	1);
	set_cmt	(0X5DEE,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5DEE);
	op_hex		(x,	0);
	create_strlit	(0X5DF9,	0X5E1E);
	set_name	(0X5DF9,	"DOSLOMSG");
	create_strlit	(0X5E1E,	0X5E4C);
	set_name	(0X5E1E,	"FEmsg");
	set_cmt	(0X5E4C,	"Try moving it into HMA",	0);
	create_insn	(0X5E4C);
	set_name	(0X5E4C,	"LoadDOSHiOrLo");
	set_cmt	(0X5E4F,	"If that don't work...",	0);
	create_insn	(0X5E52);
	set_name	(0X5E52,	"LdngLo");
	create_insn	(x=0X5E56);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X5E59,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"",	0);
	create_insn	(x=0X5E59);
	op_hex		(x,	0);
	set_cmt	(0X5E5B,	"use int 21 alloc for mem",	0);
	set_cmt	(0X5E61,	"give dos its temporary loc.",	0);
	set_cmt	(0X5E6D,	"mark that we are running lo",	0);
	create_insn	(0X5E74);
	set_name	(0X5E74,	"TryToMovDOSHi");
	set_cmt	(0X5E79,	"give dos its temporary loc.",	0);
	set_cmt	(0X5E7E,	"ax = 0 --> install stub",	0);
	set_cmt	(0X5E8D,	"did we get HMA?",	0);
	create_insn	(0X5E8D);
	set_name	(0X5E8D,	"MovDOSHi");
	set_cmt	(0X5E90,	"no",	0);
	set_cmt	(0X5E92,	"yes, HMA seg = 0ffffh",	0);
	set_cmt	(0X5E97,	"First move BIOS into HMA",	0);
	set_cmt	(0X5E9A,	"when it is in HMA",	0);
	set_cmt	(0X5E9F,	"and move it",	0);
	set_cmt	(0X5EA7,	"incestuosly!",	0);
	create_insn	(0X5EA7);
	set_name	(0X5EA7,	"MovDOSLo");
	set_cmt	(0X5EAA,	"pass the segment to MovBIOS",	0);
	set_cmt	(0X5EAF,	"DOS code size when loaded",	0);
	create_insn	(0X5EB8);
	set_name	(0X5EB8,	"MovBIOS");
	set_cmt	(0X5EBD,	"BCODE_START",	0);
	create_insn	(x=0X5EBD);
	op_hex		(x,	1);
	set_cmt	(0X5EC2,	"BCODE_END",	0);
	set_cmt	(0X5EC5,	"size of BIOS",	0);
	set_cmt	(0X5EC7,	"Both the labels are para aligned",	0);
	create_insn	(x=0X5EC7);
	op_hex		(x,	1);
	set_cmt	(0X5ECC,	"save end of BIOS",	0);
	set_cmt	(0X5ECF,	"save it for later use",	0);
	set_cmt	(0X5ED3,	"far call to seg_reinit\ncall far [cs:seg_reinit_ptr]",	0);
	set_cmt	(0X5ED8,	"get back end of BIOS",	0);
	create_insn	(0X5EDB);
	set_name	(0X5EDB,	"MovDOS");
	set_cmt	(0X5EE4,	"get back offset into which DOS was moved",	0);
	set_cmt	(0X5EE5,	"get the offset at which DOS wants to run",	0);
	set_cmt	(0X5EEE,	"get the segment at which we moved DOS into",	0);
	set_cmt	(0X5EEF,	"Adjust segment",	0);
	set_cmt	(0X5EF1,	"and save it",	0);
	set_cmt	(0X5EF7,	"BCODE_END",	0);
	create_insn	(0X5EF7);
	set_name	(0X5EF7,	"AllocMemForDOS");
	set_cmt	(0X5EFA,	"BCODE_START\nBCODE_END-BCODE_START = BIOS code size",	0);
	create_insn	(x=0X5EFA);
	op_hex		(x,	1);
	create_insn	(x=0X5F02);
	op_dec		(x,	1);
	set_cmt	(0X5F05,	"convert to para",	0);
	set_cmt	(0X5F08,	"can we use int 21h for alloc ?",	0);
	set_cmt	(0X5F0C,	"no",	0);
	create_insn	(x=0X5F0E);
	op_hex		(x,	1);
	set_cmt	(0X5F10,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X5F10);
	op_hex		(x,	0);
	set_cmt	(0X5F14,	"Take care ORG 30h of BIOS code",	0);
	set_cmt	(0X5F19,	"[es:20h+ARENA.OWNER],08h",	0);
	set_cmt	(0X5F20,	"'SC' ; mark it as system code area",	0);
	create_insn	(0X5F28);
	set_cmt	(0X5F2C,	"get ptr to DOS var",	0);
	set_cmt	(0X5F32,	"Arena head is immediately before sysvar",	0);
	set_cmt	(0X5F33,	"es = arena head",	0);
	set_cmt	(0X5F35,	"[es:ARENA.SIZE] ; total low mem size",	0);
	set_cmt	(0X5F3A,	"is it sufficient ?",	0);
	set_cmt	(0X5F3C,	"no, fatal error",	0);
	set_cmt	(0X5F3E,	"[es:ARENA.SIGNATURE]",	0);
	set_cmt	(0X5F45,	"ax = new arena head",	0);
	set_cmt	(0X5F47,	"store it in DOS data area",	0);
	set_cmt	(0X5F4B,	"[ARENA.SIGNATURE] ; type of arena",	0);
	set_cmt	(0X5F4F,	"[ARENA.OWNER],0 ; free",	0);
	set_cmt	(0X5F55,	"size of the new block",	0);
	set_cmt	(0X5F57,	"[ARENA.SIZE],cx ; store it in the arena",	0);
	set_cmt	(0X5F5B,	"return seg to the caller",	0);
	set_cmt	(0X5F5D,	"Take care ORG 30h of BIOS code",	0);
	create_insn	(0X5F65);
	create_insn	(x=0X5F67);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X5F6A);
	op_hex		(x,	1);
	set_cmt	(0X5F6C,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"",	0);
	create_insn	(x=0X5F6C);
	op_hex		(x,	0);
	create_insn	(0X5F71);
	set_name	(0X5F71,	"AllocHMA");
	set_cmt	(0X5F72,	"DOSBIODATASEG ; BIOSDATA segment",	0);
	create_insn	(x=0X5F72);
	op_hex		(x,	1);
	set_cmt	(0X5F7F,	"- Multiplex - XMS - GET DRIVER ADDRESS\nReturn: ES:BX -> driver entry point",	0);
	create_insn	(x=0X5F7F);
	op_hex		(x,	0);
	create_insn	(x=0X5F81);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X5F85);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5F89,	"request HMA",	0);
	set_cmt	(0X5F8E,	"call far [xms]",	0);
	create_insn	(x=0X5F8E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5F93,	"error if not able to allocate HMA",	0);
	set_cmt	(0X5F97,	"Get Extended Memory Size\nReturn: CF clear on success\nAX = size of memory above 1M in K",	0);
	create_insn	(x=0X5F97);
	op_hex		(x,	0);
	set_cmt	(0X5F99,	"less than 64 K of hma ?",	0);
	create_insn	(x=0X5F99);
	op_dec		(x,	1);
	set_cmt	(0X5F9E,	"localenableA20",	0);
	create_insn	(x=0X5FA0);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X5FA5,	"error if couldn't enable A20",	0);
	set_cmt	(0X5FAA,	"yes, we cant use HMA",	0);
	set_cmt	(0X5FB1,	"see if we can really read/write there",	0);
	create_insn	(x=0X5FB1);
	create_insn	(x=0X5FB8);
	set_cmt	(0X5FBF,	"don't try to load there if XMS lied",	0);
	create_insn	(0X5FC4);
	create_insn	(0X5FC7);
	set_name	(0X5FC7,	"IsXMSLoaded");
	set_cmt	(0X5FCA,	"- Multiplex - XMS - INSTALLATION CHECK\nReturn: AL = 80h XMS driver installed\nAL <> 80h no driver",	0);
	create_insn	(x=0X5FCA);
	op_hex		(x,	0);
	set_cmt	(0X5FCC,	"XMS installed?",	0);
	create_insn	(0X5FCF);
	set_name	(0X5FCF,	"FTRYTOMOVDOSHI");
	set_name	(0X5FE2,	"_ftymdh_1");
	create_byte	(0X5FEB);
	set_cmt	(0X5FEC,	"link to next device driver",	0);
	create_dword	(0X5FEC);
	set_name	(0X5FEC,	"StartVDHead");
	set_cmt	(0X5FF0,	"device attribute",	0);
	create_word	(0X5FF0);
	set_cmt	(0X5FF2,	"strategy routine offset",	0);
	create_word	(0X5FF2);
	set_cmt	(0X5FF4,	"interrupt routine offset",	0);
	create_word	(0X5FF4);
	create_byte	(0X5FF6);
	set_cmt	(0X5FF7,	"reserved area",	0);
	create_byte	(0X5FF7);
	make_array	(0X5FF7,	0X7);
	create_strlit	(0X5FFE,	0X6003);
	set_name	(0X5FFE,	"VDiskSig1");
	set_cmt	(0X6003,	"vdisk label ; VLEN1 equ ($-VDiskSig1)",	0);
	create_strlit	(0X6003,	0X6009);
	set_cmt	(0X6009,	"pad",	0);
	create_byte	(x=0X6009);
	make_array	(x,	0XF);
	op_dec		(x,	0);
	set_cmt	(0X6018,	"bits 0-15 of free HMA",	0);
	create_word	(0X6018);
	set_cmt	(0X601A,	"bits 16-23 of free HMA (1M + 64K)",	0);
	create_byte	(0X601A);
	set_cmt	(0X601B,	"jmp to old vector",	0);
	create_byte	(0X601B);
	set_name	(0X601B,	"VDInt19");
	create_word	(0X601C);
	make_array	(0X601C,	0X2);
	set_name	(0X601C,	"OldVDInt19");
	set_cmt	(0X6020,	"EndVDHead\nnon-bootable disk",	0);
	create_byte	(0X6020);
	make_array	(0X6020,	0X3);
	set_name	(0X6020,	"VDiskHMAHead");
	create_strlit	(0X6023,	0X6028);
	set_name	(0X6023,	"VDiskSig2");
	set_cmt	(0X6028,	"VLEN2 equ ($-VDiskSig2)\nOEM - signature",	0);
	create_strlit	(0X6028,	0X602B);
	set_cmt	(0X602B,	"number of bytes/sector",	0);
	create_word	(x=0X602B);
	op_dec		(x,	0);
	set_cmt	(0X602D,	"sectors/cluster",	0);
	create_byte	(0X602D);
	set_cmt	(0X602E,	"reserved sectors",	0);
	create_word	(0X602E);
	set_cmt	(0X6030,	"number of FAT copies",	0);
	create_byte	(0X6030);
	set_cmt	(0X6031,	"number of root dir entries",	0);
	create_word	(x=0X6031);
	op_dec		(x,	0);
	set_cmt	(0X6033,	"number of sectors",	0);
	create_word	(x=0X6033);
	op_dec		(x,	0);
	set_cmt	(0X6035,	"media descriptor",	0);
	create_byte	(0X6035);
	set_cmt	(0X6036,	"number of sectors/FAT",	0);
	create_word	(0X6036);
	set_cmt	(0X6038,	"sectors per track",	0);
	create_word	(0X6038);
	set_cmt	(0X603A,	"number of heads",	0);
	create_word	(0X603A);
	set_cmt	(0X603C,	"number of hidden sectors",	0);
	create_word	(0X603C);
	set_cmt	(0X603E,	"Start of free HMA in K (1M+64K)",	0);
	create_word	(0X603E);
	set_cmt	(0X6040,	"EndVDiskHMAHead (SYSINIT:0D10h)",	0);
	create_insn	(0X6040);
	set_name	(0X6040,	"InstVDiskHeader");
	set_cmt	(0X6042,	"seg of int vect table\nsave old int 19 vector",	0);
	set_cmt	(0X6044,	"[19h*4]",	0);
	create_insn	(x=0X6044);
	set_cmt	(0X604B,	"[19h*4+2]",	0);
	create_insn	(x=0X604B);
	create_insn	(x=0X6052);
	op_hex		(x,	1);
	set_cmt	(0X6057,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X6057);
	op_hex		(x,	0);
	set_cmt	(0X605C,	"[es:ARENA.OWNER],8 ; owner = System",	0);
	set_cmt	(0X6063,	"[es:ARENA.NAME],'SC' ; System Code",	0);
	set_cmt	(0X606B,	"get back to allocated memory",	0);
	set_cmt	(0X606D,	"no reboots at this time\ninstall new int 19 vector",	0);
	set_cmt	(0X606E,	"(VDInt19-StartVDHead)\n0CEBh-0CBCh = 2Fh = 47",	0);
	create_insn	(x=0X606E);
	op_dec		(x,	1);
	create_insn	(x=0X6074);
	set_cmt	(0X6077,	"(EndVDHead-StartVDHead)",	0);
	create_insn	(x=0X6077);
	op_dec		(x,	1);
	set_cmt	(0X607A,	"SYSINIT:0CBCh",	0);
	create_insn	(x=0X607A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6084,	"mov the HMA VDisk head into HMA",	0);
	create_insn	(x=0X608C);
	op_hex		(x,	1);
	set_cmt	(0X608F,	"(EndVDiskHMAHead-VDiskHMAHead)",	0);
	create_insn	(x=0X608F);
	op_dec		(x,	1);
	set_cmt	(0X6092,	"SYSINIT:0CF0h",	0);
	create_insn	(x=0X6092);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X609A,	"bmove",	0);
	create_byte	(0X609A);
	make_array	(0X609A,	0X8);
	set_name	(0X609A,	"dummy");
	set_cmt	(0X60A2,	"times desc.size db 0",	0);
	create_byte	(0X60A2);
	make_array	(0X60A2,	0X8);
	set_name	(0X60A2,	"gdt");
	set_cmt	(0X60AA,	"des <0ffffh,0,0,93h,0>",	0);
	create_word	(0X60AA);
	set_name	(0X60AA,	"src_desc");
	create_word	(0X60AC);
	set_name	(0X60AC,	"desc_lo_word");
	create_byte	(0X60AE);
	set_name	(0X60AE,	"desc_hi_byte");
	create_byte	(0X60AF);
	create_word	(0X60B0);
	set_cmt	(0X60B2,	"desc <0ffffh,0,10h,93h,0>  ; 1MB\ndesc.seg_lim",	0);
	create_word	(0X60B2);
	set_name	(0X60B2,	"tgt_desc");
	set_cmt	(0X60B4,	"desc.lo_word",	0);
	create_word	(0X60B4);
	set_cmt	(0X60B6,	"desc.hi_byte",	0);
	create_byte	(0X60B6);
	set_cmt	(0X60B7,	"desc.acc_rights",	0);
	create_byte	(0X60B7);
	set_cmt	(0X60B8,	"desc.reserved",	0);
	create_word	(0X60B8);
	set_cmt	(0X60BA,	"times desc.size db 0",	0);
	create_byte	(0X60BA);
	make_array	(0X60BA,	0X8);
	set_name	(0X60BA,	"rombios_code");
	create_byte	(0X60C2);
	make_array	(0X60C2,	0X8);
	set_name	(0X60C2,	"temp_stack");
	create_byte	(x=0X60CA);
	make_array	(x,	0X20);
	op_dec		(x,	0);
	set_name	(0X60CA,	"ClrdVDISKHead");
	set_cmt	(0X60EA,	"8042 keyboard controller status register\n7:  PERR    1=parity error in data received from keyboard\n   +----------- AT Mode ----------+------------ PS/2 Mode ------------+\n6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|\n5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |\n   +------------------------------+-----------------------------------+\n4:  INH     0=keyboard communications inhibited\n3:  A2      0=60h was the port last written to, 1=64h was last\n2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot\n1:  IBF     1=input buffer full (keyboard can't accept data)\n0:  OBF     1=output buffer full (data from keyboard is available)",	0);
	create_insn	(x=0X60EA);
	op_hex		(x,	1);
	set_name	(0X60EA,	"ClrVDISKHeader");
	set_cmt	(0X60EC,	"test bit 4 - Is keyboard inhibited?",	0);
	create_insn	(x=0X60EC);
	op_hex		(x,	1);
	set_cmt	(0X60EE,	"No, go do block move",	0);
	set_cmt	(0X60F0,	"check for TORTUGA models",	0);
	set_cmt	(0X60F7,	"do not use INT 15h block move code\n(while 8042 is disabled)",	0);
	set_cmt	(0X60F9,	"Check for PS/2 30-286 model",	0);
	create_insn	(0X6103);
	create_insn	(x=0X6108);
	op_dec		(x,	1);
	set_cmt	(0X610A,	"dx = higher 4 bits of the segment number\n   = segment number / 4096 (= byte address / 65536)",	0);
	set_cmt	(0X610E,	"ax = (lower 12 bits of the segment number)*16",	0);
	create_insn	(x=0X6110);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6113,	"dl:ax = 24 bit linear address",	0);
	set_cmt	(0X611F,	"16 words",	0);
	create_insn	(x=0X611F);
	op_dec		(x,	1);
	set_cmt	(0X6124,	"offset bmove",	0);
	create_insn	(x=0X6124);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6129,	"EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)\nCX = number of words to move, ES:SI -> global descriptor table\nReturn: CF set on error, AH = status",	0);
	create_insn	(x=0X6129);
	op_hex		(x,	0);
	create_insn	(0X612D);
	set_name	(0X612D,	"SaveFreeHMAPtr");
	set_cmt	(0X612F,	"HMA segment",	0);
	set_cmt	(0X6134,	"para round",	0);
	create_insn	(x=0X6134);
	op_dec		(x,	1);
	create_insn	(x=0X6137);
	op_hex		(x,	1);
	set_cmt	(0X6141,	"DOSBIODATASEG ; BIOSDATA segment",	0);
	create_insn	(x=0X6141);
	op_hex		(x,	1);
	set_cmt	(0X6146,	"BIOSDATA:07D7h",	0);
	create_insn	(x=0X6146);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X614A,	"BIOSDATA:000Dh",	0);
	create_insn	(x=0X614A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(0X6151);
	set_name	(0X6151,	"IsVDiskInstalled");
	set_cmt	(0X6155,	"[13h*4+2]",	0);
	create_insn	(x=0X6155);
	set_cmt	(0X6159,	"VDiskSig1-StartVDHead",	0);
	set_cmt	(0X615C,	"VLEN1",	0);
	create_insn	(x=0X6161);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X616D,	"10h+(VDiskSig2-VDiskHMAHead)",	0);
	create_insn	(x=0X6170);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6179);
	set_name	(0X6179,	"CPMHack");
	set_cmt	(0X6181,	"0",	0);
	set_cmt	(0X618D,	"move 5 bytes from 0:C0h to FFFFh:D0h",	0);
	create_insn	(x=0X6191);
	op_hex		(x,	1);
	set_name	(0X6191,	"_off_to_para");
	create_insn	(x=0X6193);
	op_hex		(x,	1);
	create_insn	(x=0X6195);
	op_hex		(x,	1);
	create_insn	(x=0X6197);
	op_hex		(x,	1);
	create_insn	(x=0X619A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X619A,	"TempCDS");
	set_cmt	(0X619E,	"[es:di+SYSI_NUMIO]",	0);
	set_cmt	(0X61A2,	"(cx) = # of block devices",	0);
	set_cmt	(0X61A4,	"[es:di+SYSI_NCDS] ; one CDS per device",	0);
	set_cmt	(0X61AA,	"curdirlen ; curdir_list.size",	0);
	create_insn	(x=0X61AA);
	op_dec		(x,	1);
	create_insn	(x=0X61B1);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X61B7,	"[es:di+SYSI_CDS+2]",	0);
	set_cmt	(0X61BD,	"[es:di+SYSI_CDS]\nset address of CDS list",	0);
	set_cmt	(0X61C3,	"lds si,[es:di+SYSI_DPB]\n(ds:si) = address of first DPB",	0);
	set_cmt	(0X61C8,	"(es:di) = address of 1st CDS",	0);
	set_cmt	(0X61CA,	"\"A:\\\"",	0);
	create_insn	(0X61CA);
	set_name	(0X61CA,	"fooset");
	set_cmt	(0X61CE,	"setup the root as the curdir",	0);
	set_cmt	(0X61CF,	"get dpb for drive in dpb\n(ds:si) = address of DPB\n   (si) = -1 if no drive",	0);
	set_cmt	(0X61D2,	"\"\\\",0",	0);
	set_cmt	(0X61D7,	"\"A:\\\"",	0);
	set_cmt	(0X61DC,	"0",	0);
	set_cmt	(0X61DF,	"curdir_list.cdir_flags - 4",	0);
	create_insn	(x=0X61DF);
	op_dec		(x,	1);
	set_cmt	(0X61E2,	"zero out rest of CURDIR_TEXTs\n(ax) = 0\n(es:di) = CURDIR_FLAGS in the CDS records\n(ds:si) = Next DPB (-1 if none)",	0);
	set_cmt	(0X61E4,	"-1",	0);
	set_cmt	(0X61EF,	"machine has floppy drives",	0);
	set_cmt	(0X61F1,	"cmp [si+DPB.drive],1\nif dpb_drive = 0 (A) or 1 (B).",	0);
	set_cmt	(0X61F6,	"the next dbp pointer",	0);
	set_cmt	(0X61F8,	"ax should be zero here",	0);
	create_insn	(0X61FD);
	set_cmt	(0X6202,	"jmp short fincds",	0);
	create_insn	(0X6204);
	set_cmt	(0X6205,	"[si+DPB.FAT_COUNT] ; non fat system?",	0);
	set_cmt	(0X6209,	"yes. set curdir_flags to 0. ax = 0 now.",	0);
	set_cmt	(0X620B,	"curdir_inuse ; else,fat system.\nset the flag to curdir_inuse.",	0);
	set_cmt	(0X620E,	"curdir_flags",	0);
	set_cmt	(0X6211,	"curdir_devptr",	0);
	set_cmt	(0X6215,	"entry point for fake_fooset_zero\nmov ax,-1",	0);
	set_cmt	(0X6218,	"curdir_id",	0);
	set_cmt	(0X6219,	"curdir_id",	0);
	set_cmt	(0X621A,	"curdir_user_word",	0);
	set_cmt	(0X621B,	"curdir_end",	0);
	set_cmt	(0X621F,	"clear out 7 bytes (curdir_type,",	0);
	set_cmt	(0X6222,	"curdir_ifs_hdr,curdir_fsda)",	0);
	set_cmt	(0X6227,	"\"A:\\\",0",	0);
	create_insn	(x=0X6227);
	op_chr		(x,	1);
	set_cmt	(0X622E,	"point to first DPB",	0);
	create_insn	(0X622E);
	set_name	(0X622E,	"get_dpb_for_drive_al");
	set_cmt	(0X6233,	"(ds:si) = address of first DPB",	0);
	create_insn	(x=0X6235);
	op_chr		(x,	1);
	set_cmt	(0X6237,	"cmp al,[si+DPB.DRIVE] ; match?",	0);
	set_cmt	(0X623B,	"lds si,[si+DPB.NEXT_DPB]",	0);
	set_cmt	(0X6241,	"loop until hit end of DPBs",	0);
	set_cmt	(0X6244,	"Build DOS structures",	0);
	create_insn	(0X6244);
	set_name	(0X6244,	"endfile");
	set_cmt	(0X6245,	"DOSBIODATASEG",	0);
	create_insn	(x=0X6245);
	op_hex		(x,	1);
	set_cmt	(0X624A,	"multrk_off1 \nmultrack= command entered?",	0);
	create_insn	(x=0X624A);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X6251,	"or [multrk_flag],multrk_on",	0);
	create_insn	(x=0X6251);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_hex		(x,	1);
	set_cmt	(0X627E,	"devmark_files",	0);
	create_insn	(x=0X627E);
	op_chr		(x,	1);
	set_cmt	(0X6280,	"set devmark for sfts (files)",	0);
	set_cmt	(0X6284,	"do not use cbw instruction!\nit does sign extend.",	0);
	set_cmt	(0X6290,	"get pointer to dos data",	0);
	set_cmt	(0X6295,	"lds di,[di+SYSI_SFT] ; ds:di points to sft",	0);
	set_cmt	(0X6298,	"[di+SF.SFLink],bx",	0);
	set_cmt	(0X629A,	"[di+SF.SFLink+2],dx ; set pointer to new sft",	0);
	set_cmt	(0X629F,	"point to new sft",	0);
	set_cmt	(0X62A4,	"mov word [es:di+SF.SFLink],-1",	0);
	set_cmt	(0X62A9,	"mov [es:di+SF.SFCount],ax",	0);
	set_cmt	(0X62AD,	"SF_ENTRY.size",	0);
	create_insn	(x=0X62AD);
	op_dec		(x,	1);
	set_cmt	(0X62B1,	"ax = number of bytes to clear",	0);
	set_cmt	(0X62B3,	"allocate memory",	0);
	set_cmt	(0X62BB,	"remember the header too",	0);
	set_cmt	(0X62C0,	"for_devmark",	0);
	create_insn	(x=0X62C0);
	op_hex		(x,	1);
	set_cmt	(0X62C6,	"check for mem error before the stosb",	0);
	set_cmt	(0X62C9,	"ax = 6",	0);
	set_cmt	(0X62CD,	"clean out the stuff",	0);
	set_cmt	(0X62D4,	"devmark_fcbs",	0);
	create_insn	(x=0X62D4);
	op_chr		(x,	1);
	set_cmt	(0X62DD,	"do not use cbw instruction!\nit does sign extend.",	0);
	set_cmt	(0X62E9,	"get pointer to dos data",	0);
	set_cmt	(0X62EE,	"[di+SYSI_FCB]",	0);
	set_cmt	(0X62F1,	"[di+SYSI_FCB+2] ; set pointer to new table",	0);
	set_cmt	(0X62FB,	"[di+SYSI_KEEP]",	0);
	set_cmt	(0X6300,	"point to new table",	0);
	set_cmt	(0X6304,	"[es:di+SF.SFLink],-1",	0);
	set_cmt	(0X6309,	"[es:di+SF.SFCount]",	0);
	set_cmt	(0X630D,	"SF_ENTRY.size",	0);
	create_insn	(x=0X630D);
	op_dec		(x,	1);
	set_cmt	(0X6313,	"ax = number of bytes to clear",	0);
	set_cmt	(0X6317,	"SF.size-2",	0);
	set_cmt	(0X631A,	"remember the header too",	0);
	set_cmt	(0X631E,	"for_devmark",	0);
	create_insn	(x=0X631E);
	op_hex		(x,	1);
	set_cmt	(0X6323,	"check for mem error before the stosb",	0);
	set_cmt	(0X6326,	"skip over header",	0);
	create_insn	(x=0X6328);
	op_chr		(x,	1);
	set_cmt	(0X632A,	"save count",	0);
	set_cmt	(0X632B,	"number of bytes to fill",	0);
	create_insn	(x=0X632B);
	op_dec		(x,	1);
	set_cmt	(0X632F,	"filled",	0);
	set_cmt	(0X6331,	"[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count]",	0);
	set_cmt	(0X6337,	"[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position]",	0);
	set_cmt	(0X633D,	"[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2]",	0);
	set_cmt	(0X6346,	"-1 ; has buffers been already set?",	0);
	set_cmt	(0X634D,	"the user entered the buffers=.",	0);
	set_cmt	(0X6350,	"default is no heuristic (secondary) buffers.",	0);
	create_insn	(0X6350);
	set_cmt	(0X6356,	"default to 2 buffers",	0);
	set_cmt	(0X635E,	"search through the dpb's",	0);
	set_cmt	(0X6363,	"[es:bp+SYSI_DPB] ; get first dpb",	0);
	set_cmt	(0X6369,	"[es:bp+DPB.drive]",	0);
	create_insn	(x=0X636F);
	op_hex		(x,	1);
	set_cmt	(0X6372,	"DOS - 2+ - IOCTL - ",	0);
	create_insn	(x=0X6372);
	op_hex		(x,	0);
	set_cmt	(0X6374,	"0 = removable disk, 1 = fixed disk",	0);
	set_cmt	(0X6376,	"ax is nonzero if disk is nonremoveable",	0);
	set_cmt	(0X6378,	"get parameters of (removable) drive",	0);
	set_cmt	(0X637A,	"[es:bp+DPB.drive]",	0);
	create_insn	(x=0X6380);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6383,	"(IOCTL<<8)|GENERIC_IOCTL",	0);
	set_cmt	(0X6386,	"(RAWIO<<8)|GET_DEVICE_PARAMETERS",	0);
	set_cmt	(0X6389,	"DOS - 2+ - IOCTL - ",	0);
	create_insn	(x=0X6389);
	op_hex		(x,	0);
	set_cmt	(0X638B,	"get next dpb if driver doesn't support\ngeneric ioctl",	0);
	set_cmt	(0X638D,	"[deviceparameters+15]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]",	0);
	set_cmt	(0X6391,	"[deviceparameters+7]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]",	0);
	set_cmt	(0X6396,	"scale sector size in factor of 512 bytes",	0);
	create_insn	(x=0X6396);
	op_dec		(x,	1);
	set_cmt	(0X639B,	"ax = #sectors * size factor",	0);
	set_cmt	(0X639D,	"just in case of large floppies",	0);
	set_cmt	(0X63A1,	"720 sectors * size factor of 1",	0);
	create_insn	(x=0X63A1);
	op_dec		(x,	1);
	set_cmt	(0X63AC,	"now check the memory size\nfor default buffer count",	0);
	set_cmt	(0X63AE,	"[es:bp+DPB.NEXT_DPB],-1",	0);
	create_insn	(0X63AE);
	set_cmt	(0X63B5,	"les bp,[es:bp+DPB.NEXT_DPB]",	0);
	set_cmt	(0X63BB,	"128kb",	0);
	create_insn	(0X63BB);
	set_cmt	(0X63C9,	"256kb",	0);
	create_insn	(x=0X63D1);
	op_dec		(x,	1);
	set_cmt	(0X63D7,	"512kb",	0);
	create_insn	(x=0X63DF);
	op_dec		(x,	1);
	set_cmt	(0X63E7,	"ds:bx -> sysinitvar",	0);
	set_cmt	(0X63F0,	"[bx+SYSI_BUFFERS] ; set sysi_buffers",	0);
	set_cmt	(0X63F7,	"[bx+SYSI_BUFFERS+2]",	0);
	set_cmt	(0X63FA,	"[bx+SYSI_BUF] ; now, ds:bx -> buffinfo",	0);
	set_cmt	(0X63FD,	"get [memhi]:[memlo]",	0);
	set_cmt	(0X6400,	"devmark_buf",	0);
	create_insn	(x=0X6400);
	op_chr		(x,	1);
	set_cmt	(0X6405,	"save buffer info. ptr.",	0);
	set_cmt	(0X640A,	"restore buffer info. ptr.",	0);
	set_cmt	(0X640C,	"set the secondary buffer if specified",	0);
	set_cmt	(0X641C,	"[bx+BUFFINF.Cache_ptr]",	0);
	set_cmt	(0X6424,	"[bx+BUFFINF.Cache_ptr+2]",	0);
	set_cmt	(0X642C,	"[bx+BUFFINF.Cache_count]",	0);
	set_cmt	(0X642F,	"512 bytes",	0);
	create_insn	(x=0X642F);
	op_dec		(x,	1);
	set_cmt	(0X6438,	"for_devmark",	0);
	create_insn	(x=0X6438);
	op_hex		(x,	1);
	set_cmt	(0X6441,	"buf1",	0);
	set_cmt	(0X6445,	"devmark_cds",	0);
	create_insn	(x=0X6445);
	op_chr		(x,	1);
	set_cmt	(0X6451,	"[es:di+SYSI_NUMIO]",	0);
	set_cmt	(0X645A,	"user setting must be at least numio",	0);
	set_cmt	(0X6463,	"[es:di+SYSI_NCDS]",	0);
	set_cmt	(0X646B,	"[es:di+SYSI_CDS+2]",	0);
	set_cmt	(0X6473,	"[es:di+SYSI_CDS]",	0);
	set_cmt	(0X6479,	"curdirlen ; curdir_list.size",	0);
	create_insn	(x=0X6479);
	op_dec		(x,	1);
	set_cmt	(0X6485,	"for_devmark",	0);
	create_insn	(x=0X6485);
	op_hex		(x,	1);
	set_cmt	(0X648B,	"check for mem error before initializing",	0);
	set_cmt	(0X648E,	"lds si,[es:di+SYSI_DPB] ; [es:di+0]",	0);
	set_cmt	(0X6491,	"les di,[es:di+SYSI_CDS] ; [es:di+22]",	0);
	set_cmt	(0X6495,	"Initialize temporary CDSs.",	0);
	set_cmt	(0X649A,	"-1 ; has the user entered \"stacks=\" command?",	0);
	set_cmt	(0X649F,	"then install as specified by the user",	0);
	set_cmt	(0X64A1,	"pc1,xt has the secondary model byte = 0",	0);
	set_cmt	(0X64A6,	"other model should have default stack of 9,128",	0);
	set_cmt	(0X64A8,	"pc1, pc/xt or pc portable ?",	0);
	set_cmt	(0X64AF,	"stack_count = 0?",	0);
	set_cmt	(0X64B2,	"then, stack size must be 0 too.",	0);
	set_cmt	(0X64B4,	"don't install stack.",	0);
	set_cmt	(0X64B6,	"dynamic relocation of stack code.",	0);
	set_cmt	(0X64B9,	"devmark_stk",	0);
	create_insn	(x=0X64B9);
	op_chr		(x,	1);
	set_cmt	(0X64C1,	"es -> seg. the stack code is going to move.",	0);
	set_cmt	(0X64C5,	"! we know that stack code is at the beginning of sysinit.",	0);
	set_cmt	(0X64C9,	"offset endstackcode = offset _SYSINIT\nSYSINIT:0269h",	0);
	create_insn	(x=0X64C9);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X64D0,	"have enough space for relocation?",	0);
	set_cmt	(0X64D6,	"DOSBIODATASEG",	0);
	create_insn	(x=0X64D6);
	op_hex		(x,	1);
	set_cmt	(0X64DB,	"[BIOSDATA:NextStack],\n offset SYSINIT:nextentry (SYSINIT:0010h)",	0);
	create_insn	(x=0X64DB);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X64E1);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X64E9,	"set for stack area initialization",	0);
	set_cmt	(0X64ED,	"pass it as Instance Data, too",	0);
	create_insn	(x=0X64ED);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X64F0,	"this will be used by stack_init routine.",	0);
	create_insn	(x=0X64F8);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X64FB,	"entrysize",	0);
	set_cmt	(0X6508,	"pass through to Instance Table",	0);
	create_insn	(x=0X6508);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X6514,	"for_devmark\nto set the devmark_size for stack by round routine.",	0);
	create_insn	(x=0X6514);
	op_hex		(x,	1);
	set_cmt	(0X651A,	"check for memory error before continuing",	0);
	set_cmt	(0X651D,	"initialize hardware stack.\ncs=ds=sysinitseg,es=relocated stack code & data",	0);
	set_cmt	(0X6522,	"PCDOS 7 feature - DOSDATA=UMB/NOUMB configuration\n1 = DOSDATA=UMB, 2 = (UMB) done, 0 = NOUMB",	0);
	set_cmt	(0X6527,	"2 - done",	0);
	set_cmt	(0X6529,	"0 - DOSDATA=NOUMB",	0);
	create_insn	(x=0X652B);
	create_insn	(x=0X6532);
	op_hex		(x,	1);
	set_cmt	(0X6535,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state",	0);
	create_insn	(x=0X6535);
	op_hex		(x,	0);
	set_cmt	(0X6538,	"al = 01h -> UMBs in DOS memory chain\nsave current (previous) UMB link state",	0);
	set_cmt	(0X653A,	"bx = 01h -> add UMBs to DOS memory chain",	0);
	create_insn	(x=0X653D);
	op_hex		(x,	1);
	set_cmt	(0X6540,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X6540);
	op_hex		(x,	0);
	create_insn	(x=0X6544);
	op_hex		(x,	1);
	set_cmt	(0X6547,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: get allocation strategy",	0);
	create_insn	(x=0X6547);
	op_hex		(x,	0);
	set_cmt	(0X6549,	"ax = current strategy\nsave current (previous) allocation strategy",	0);
	set_cmt	(0X654B,	"bl = new strategy = 40h - high memory first fit",	0);
	create_insn	(x=0X654B);
	op_hex		(x,	1);
	create_insn	(x=0X654E);
	op_hex		(x,	1);
	set_cmt	(0X6551,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: set allocation strategy",	0);
	create_insn	(x=0X6551);
	op_hex		(x,	0);
	create_insn	(x=0X655B);
	op_hex		(x,	1);
	set_cmt	(0X655D,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X655D);
	op_hex		(x,	0);
	set_cmt	(0X655F,	"ax = segment of allocated block",	0);
	set_cmt	(0X6561,	"restore previous UMB link state",	0);
	create_insn	(x=0X6563);
	op_hex		(x,	1);
	set_cmt	(0X6566,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X6566);
	op_hex		(x,	0);
	set_cmt	(0X6568,	"restore previous allocation strategy",	0);
	create_insn	(x=0X656A);
	op_hex		(x,	1);
	set_cmt	(0X656D,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: set allocation strategy",	0);
	create_insn	(x=0X656D);
	op_hex		(x,	0);
	set_cmt	(0X656F,	"Is the allocated memory block (segment) a UMB?",	0);
	set_cmt	(0X6573,	"no",	0);
	set_cmt	(0X6586,	"point to arena/mcb",	0);
	set_cmt	(0X6588,	"[es:arena_owner], 8 ; set impossible owner",	0);
	set_cmt	(0X658F,	"[es:arena_name],'SD' ; System Data",	0);
	set_cmt	(0X6596,	"1 -> 2 ; DOSDATA=UMB done.",	0);
	set_cmt	(0X659D,	"(recent memory block/segment before UMBs)",	0);
	create_insn	(0X659D);
	set_cmt	(0X65AC,	"do not use cbw instruction!\nit does sign extend.",	0);
	set_cmt	(0X65B0,	"close standard input",	0);
	create_insn	(x=0X65B2);
	op_hex		(x,	1);
	set_cmt	(0X65B4,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X65B4);
	op_hex		(x,	0);
	set_cmt	(0X65B6,	"close everybody but standard output\nneed output so we can print message\n in case we can't get new one open.",	0);
	create_insn	(x=0X65B9);
	op_hex		(x,	1);
	set_cmt	(0X65BB,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X65BB);
	op_hex		(x,	0);
	create_insn	(x=0X65C0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X65C5,	"open con for read/write",	0);
	create_insn	(x=0X65C5);
	op_hex		(x,	1);
	set_cmt	(0X65C7,	"set for possible int 24",	0);
	set_cmt	(0X65C8,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n2 - read & write",	0);
	create_insn	(x=0X65C8);
	op_hex		(x,	0);
	create_insn	(0X65D1);
	set_cmt	(0X65D2,	"close standard output",	0);
	create_insn	(x=0X65D5);
	op_hex		(x,	1);
	set_cmt	(0X65D7,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X65D7);
	op_hex		(x,	0);
	set_cmt	(0X65DA,	"new device handle",	0);
	set_cmt	(0X65DC,	"XDUP ; dup to 1, stdout",	0);
	create_insn	(x=0X65DC);
	op_hex		(x,	1);
	set_cmt	(0X65DE,	"DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)\nBX = file handle to duplicate",	0);
	create_insn	(x=0X65DE);
	op_hex		(x,	0);
	set_cmt	(0X65E0,	"XDUP ; dup to 2, stderr",	0);
	create_insn	(x=0X65E0);
	op_hex		(x,	1);
	set_cmt	(0X65E2,	"DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)\nBX = file handle to duplicate",	0);
	create_insn	(x=0X65E2);
	op_hex		(x,	0);
	create_insn	(x=0X65E4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X65E7,	"read/write access",	0);
	create_insn	(x=0X65EC);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X65EF,	"write only",	0);
	set_cmt	(0X65F8,	"reset h/w by writing to port",	0);
	set_cmt	(0X65FA,	"get starting address",	0);
	set_cmt	(0X65FD,	"out 02f2h,0ffh",	0);
	set_cmt	(0X6607,	"out 02f7h,0ffh",	0);
	set_cmt	(0X6608,	"get machine type",	0);
	set_cmt	(0X660D,	"is it a AT type machine",	0);
	set_cmt	(0X6613,	"*if AT no need to check",	0);
	set_cmt	(0X6617,	"SYSTEM - GET CONFIGURATION \n(XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)",	0);
	create_insn	(x=0X6617);
	op_hex		(x,	0);
	set_cmt	(0X6619,	"*jmp if old rom",	0);
	set_cmt	(0X661B,	"[es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],\nScndIntController",	0);
	create_insn	(x=0X661B);
	op_hex		(x,	1);
	set_cmt	(0X6622,	"write any pattern to port",	0);
	set_cmt	(0X6624,	"get starting address",	0);
	set_cmt	(0X6629,	"out 06f3h,0ffh",	0);
	set_cmt	(0X662B,	"out 06f4h,0ffh",	0);
	set_cmt	(0X662E,	"out 06f6h,0ffh",	0);
	set_cmt	(0X6630,	"out 06f7h,0ffh",	0);
	set_cmt	(0X6635,	"sysinit_base will be established \nin the secure area of lower memory\nwhen it handles the first install= command.\nif sysinit module (in high memory) has been broken,\nthen \"memory error...\" message is displayed\nby sysinit_base",	0);
	set_name	(0X6635,	"set_sysinit_base");
	set_cmt	(0X663D,	"remember the size in case.",	0);
	set_cmt	(0X6640,	"devmark_inst",	0);
	create_insn	(x=0X6640);
	op_chr		(x,	1);
	set_cmt	(0X664C,	"save this entry for the next use.",	0);
	set_cmt	(0X6652,	"es:di -> destination.",	0);
	set_cmt	(0X6656,	"ds:si -> source code to be relocated.",	0);
	create_insn	(x=0X6656);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6659,	"end_sysinit_base-sysinit_base ; 129",	0);
	create_insn	(x=0X6659);
	op_dec		(x,	1);
	set_cmt	(0X6660,	"for_devmark",	0);
	create_insn	(x=0X6660);
	op_hex		(x,	1);
	set_cmt	(0X666B,	"returning address from\nsysinit_base back to sysinit",	0);
	create_insn	(x=0X666B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6675,	"for_devmark",	0);
	create_insn	(x=0X6675);
	op_hex		(x,	1);
	set_cmt	(0X6684,	"save [area]",	0);
	set_cmt	(0X6687,	"calc what we needed",	0);
	set_cmt	(0X668B,	"SETBLOCK",	0);
	create_insn	(x=0X668B);
	op_hex		(x,	1);
	set_cmt	(0X668D,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs",	0);
	create_insn	(x=0X668D);
	op_hex		(x,	0);
	set_cmt	(0X6693,	"point to arena",	0);
	set_cmt	(0X6695,	"[es:ARENA.OWNER],8 ; set impossible owner",	0);
	set_cmt	(0X669C,	"[es:ARENA.NAME],'SD' ; System Data",	0);
	create_insn	(x=0X66A7);
	op_hex		(x,	1);
	set_cmt	(0X66A9,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X66A9);
	op_hex		(x,	0);
	set_cmt	(0X66AB,	"allocate the rest of the memory",	0);
	create_insn	(x=0X66AB);
	op_hex		(x,	1);
	set_cmt	(0X66AD,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X66AD);
	op_hex		(x,	0);
	set_cmt	(0X66AF,	"start of the allocated memory",	0);
	set_cmt	(0X66B2,	"to be used next.",	0);
	set_cmt	(0X66BE,	"confbot - memhi",	0);
	set_cmt	(0X66C0,	"make a room for the memory block id.",	0);
	set_cmt	(0X66C1,	"make sure!",	0);
	set_cmt	(0X66C2,	"this will free (confbot to top of memory)",	0);
	create_insn	(x=0X66C2);
	op_hex		(x,	1);
	set_cmt	(0X66C4,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs",	0);
	create_insn	(x=0X66C4);
	op_hex		(x,	0);
	create_insn	(x=0X66C9);
	op_hex		(x,	1);
	set_cmt	(0X66CB,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X66CB);
	op_hex		(x,	0);
	set_cmt	(0X66CD,	"allocate (confbot to top of memory)",	0);
	create_insn	(x=0X66CD);
	op_hex		(x,	1);
	set_cmt	(0X66CF,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X66CF);
	op_hex		(x,	0);
	set_cmt	(0X66D1,	"save allocated memory segment.\nneed this to free this area for command.com.",	0);
	set_cmt	(0X66D8,	"free allocated memory\nfree (memhi to confbot(=area))",	0);
	create_insn	(x=0X66D8);
	op_hex		(x,	1);
	set_cmt	(0X66DA,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed",	0);
	create_insn	(x=0X66DA);
	op_hex		(x,	0);
	set_cmt	(0X66DD,	"EXEC a program being loaded via the \n\"install=\" mechanism in config.sys",	0);
	create_insn	(0X66DD);
	set_name	(0X66DD,	"do_install_exec");
	set_cmt	(0X66E1,	"es->sysinitseg,ds->confbot seg",	0);
	set_cmt	(0X66E2,	"ds:dx->file name,0 in config.sys image.",	0);
	set_cmt	(0X66E7,	"clear out the parm area",	0);
	create_insn	(x=0X66ED);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X66F0,	"skip the file name\nal = ds:si; si++",	0);
	set_cmt	(0X66F7,	"copy the parameters to ldexec_parm",	0);
	create_insn	(0X66F7);
	set_cmt	(0X66FB,	"lf ; line feed?",	0);
	set_cmt	(0X66FF,	"# of char. in the parm.",	0);
	set_cmt	(0X6704,	"length of the parm.",	0);
	create_insn	(0X6704);
	set_cmt	(0X6709,	"if no parm,then",	0);
	set_cmt	(0X670C,	"let the parm area",	0);
	set_cmt	(0X670E,	"cr ; starts with cr.",	0);
	set_cmt	(0X6714,	"make a null environment segment",	0);
	create_insn	(x=0X6714);
	set_cmt	(0X671B,	"by overlap jmp instruction of sysinitseg.",	0);
	set_cmt	(0X672C,	"[cs:instexe.exec0_environ]\nset the environment seg.",	0);
	set_cmt	(0X6731,	"[cs:instexe.exec0_com_line+2]\nset the seg.",	0);
	set_cmt	(0X6735,	"[cs:instexe.exec0_5c_fcb+2",	0);
	set_cmt	(0X6739,	"[cs:instexe.exec0_6c_fcb+2]]",	0);
	set_cmt	(0X6740,	"save the value of the sum",	0);
	set_cmt	(0X6746,	"EXEC ; load/exec",	0);
	create_insn	(x=0X6746);
	op_hex		(x,	1);
	set_cmt	(0X6748,	"instexe ; es:bx -> parm block.",	0);
	create_insn	(x=0X6748);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X674B,	"save es,ds for load/exec",	0);
	set_cmt	(0X674C,	"these registers will be restored in sysinit_base.",	0);
	set_cmt	(0X674D,	"jmp to sysinit_base to execute\nload/exec function and check sum.",	0);
	set_cmt	(0X6752,	"returning far address from sysinit_base\nrestore si for config.sys file.",	0);
	create_insn	(0X6752);
	set_name	(0X6752,	"sysinitptr");
	set_cmt	(0X6756,	"now ds - sysinitseg, es - confbot",	0);
	set_cmt	(0X6759,	"error in loading the file for install=.",	0);
	set_cmt	(0X675A,	"es:si-> path,filename,0.",	0);
	set_name	(0X675E,	"install_exit_ret");
	set_cmt	(0X675F,	"round up length in paragraphs\n0Fh",	0);
	create_insn	(x=0X675F);
	op_dec		(x,	1);
	set_name	(0X675F,	"ParaRound");
	create_insn	(x=0X6762);
	op_hex		(x,	1);
	create_insn	(x=0X6764);
	op_hex		(x,	1);
	create_insn	(x=0X6766);
	op_hex		(x,	1);
	create_insn	(x=0X6768);
	op_hex		(x,	1);
	set_cmt	(0X676B,	"sysinit_base module",	0);
	create_insn	(x=0X676B);
	set_name	(0X676B,	"sysinit_base");
	create_insn	(x=0X6770);
	set_cmt	(0X6775,	"load/exec dos call.",	0);
	create_insn	(x=0X6775);
	op_hex		(x,	0);
	set_cmt	(0X6777,	"restore stack",	0);
	create_insn	(x=0X6777);
	create_insn	(x=0X677C);
	create_insn	(x=0X6788);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X678F,	"memory broken. \nshow \"memory allocation error\" message and stall.",	0);
	set_cmt	(0X6793,	"mem_alloc_err_msgx-sysinit_base ; 66h",	0);
	create_insn	(x=0X6793);
	op_dec		(x,	1);
	set_cmt	(0X6796,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"",	0);
	create_insn	(x=0X6796);
	op_hex		(x,	0);
	set_cmt	(0X6798,	"use HLT to minimize energy consumption",	0);
	set_name	(0X6798,	"stall");
	create_insn	(0X6799);
	set_cmt	(0X679B,	"return back to sysinit module",	0);
	create_insn	(x=0X679B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X679B,	"sysinit_base_end");
	create_insn	(0X67A0);
	set_name	(0X67A0,	"sum_up");
	create_insn	(x=0X67A1);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X67AB,	"if config_size has been broken, then this\nwhole test better fail.",	0);
	create_insn	(x=0X67AB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X67B0);
	op_hex		(x,	1);
	set_cmt	(0X67B2,	"when config.sys file not exist.",	0);
	set_cmt	(0X67BA,	"586h\nstarting after the stack.\nthis does not cover the possible stack code!",	0);
	create_insn	(x=0X67BA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X67BD,	"SI_end (23360)\nSI_end is the label at the end of sysinit\nfrom after_checksum to SI_end",	0);
	create_insn	(x=0X67C2);
	op_hex		(x,	1);
	set_cmt	(0X67CD,	"sysinit_base_ss equ $-sysinit_base ; 62",	0);
	create_word	(0X67CD);
	set_name	(0X67CD,	"sysinit_base_ssx");
	set_cmt	(0X67CF,	"sysinit_base_sp equ $-sysinit_base ; 64",	0);
	create_word	(0X67CF);
	set_name	(0X67CF,	"sysinit_base_spx");
	create_strlit	(0X67D1,	0X67EC);
	set_name	(0X67D1,	"mem_alloc_err_msgx");
	set_cmt	(0X67EC,	"input:\n  ds:bx -> buffinfo.\n  [memhi]:[memlo=0] = available space for the hash bucket.    \n  singlebuffersize = buff header size + sector size       \noutput:\n  buffers Queue established.\n  [memhi]:[memlo] = addr of the next available free space.\n\nassume buffers not in HMA",	0);
	create_insn	(0X67EC);
	set_name	(0X67EC,	"set_buffer");
	set_cmt	(0X67F3,	"buffers in HMA",	0);
	set_cmt	(0X67F5,	"[bx+BUFFINF.Buff_Queue] ; head of Buff Q",	0);
	set_cmt	(0X67F7,	"[bx+BUFFINF.Buff_Queue+2]",	0);
	set_cmt	(0X67FA,	"[bx+BUFFINF.Dirty_Buff_Count] ; set dirty_count to 0.",	0);
	set_cmt	(0X6806,	"remember first buffer",	0);
	set_cmt	(0X6807,	"set buf_link,buf_id...",	0);
	set_cmt	(0X680E,	"point to last buffer",	0);
	set_cmt	(0X6813,	"get first buffer",	0);
	set_cmt	(0X6814,	"[es:di+buffinfo.buf_next] ; last->next = first",	0);
	set_cmt	(0X6819,	"[es:di+buffinfo.buf_prev] ; first->prev = last",	0);
	set_cmt	(0X681D,	"In HMa ?",	0);
	set_cmt	(0X681F,	"no",	0);
	set_cmt	(0X6821,	"mov byte [bx+BUFFINF.Buff_In_HMA],1",	0);
	set_cmt	(0X6825,	"seg of scratch buff",	0);
	set_cmt	(0X6829,	"[bx+BUFFINF.Lo_Mem_Buff] ; offset of scratch buff is 0",	0);
	set_cmt	(0X682E,	"mov [bx+BUFFINF.Lo_Mem_Buff+2],ax",	0);
	set_cmt	(0X6831,	"size of scratch buff",	0);
	set_cmt	(0X6835,	"bufinsiz ; 24 ; buffer head not required\n(bufinsiz is 20 in MSDOS 6.21 IO.SYS)",	0);
	create_insn	(x=0X6835);
	op_dec		(x,	1);
	set_cmt	(0X683D,	"for_devmark = 2",	0);
	create_insn	(x=0X683D);
	op_hex		(x,	1);
	create_insn	(0X6847);
	set_name	(0X6847,	"GetBufferAddr");
	set_cmt	(0X6849,	"is dosdata moved to UMB ? (DOSDATA=UMB done)",	0);
	set_cmt	(0X684F,	"no",	0);
	set_cmt	(0X6851,	"is the buffer (already) in HMA ?",	0);
	set_cmt	(0X6855,	"yes",	0);
	set_cmt	(0X6860,	"15",	0);
	create_insn	(x=0X6860);
	op_hex		(x,	1);
	set_cmt	(0X6863,	"~15 ; not 0Fh",	0);
	create_insn	(x=0X6863);
	op_hex		(x,	1);
	set_cmt	(0X6868,	"((multMULT<<8)+multMULTALLOCHMA)",	0);
	set_cmt	(0X686B,	"DOS 5+ - ALLOCATE HMA SPACE\n    AX = 4A02h\n    BX = number of bytes\nReturn:\n    ES:DI -> start of allocated HMA block or FFFFh:FFFFh\n    BX = number of bytes actually allocated (rounded up to next  \n         paragraph for DOS 5.0 and 6.0)\nNotes:\n    this call is not valid unless DOS is loaded in the HMA (DOS=HIGH)\n    \n    called by Windows 3.1 DOSX.EXE\n    supported by Novell DOS 7",	0);
	create_insn	(x=0X686B);
	op_hex		(x,	0);
	set_cmt	(0X6872,	"dont xor di,di Z flag needed\n\n05/09/2023 - Erdogan Tan\n(above msdos source code comment is wrong\nbecause ZF is already 1 here and\n'xor di,di' sets ZF to 1 again;\n'inc di' would be most proper instruction here)",	0);
	create_insn	(0X687D);
	set_cmt	(0X6884,	"es:di -> buffer header to be set.\nax = di",	0);
	create_insn	(0X6884);
	set_name	(0X6884,	"set_buffer_info");
	set_cmt	(0X6889,	"[es:di+buffinfo.buf_prev]",	0);
	set_cmt	(0X6891,	"adjust ax",	0);
	set_cmt	(0X6896,	"[es:di+buffinfo.buf_next]",	0);
	set_cmt	(0X6899,	"[es:di+buffinfo.buf_ID]\nnew buffer free",	0);
	set_cmt	(0X689F,	"[es:di+buffinfo.buf_sector]",	0);
	set_cmt	(0X68A5,	"[es:di+buffinfo.buf_sector+2]",	0);
	set_cmt	(0X68AC,	"ibmstack initialization routine\nin - cs, ds -> sysinitseg,\n     es -> relocated stack code & data.",	0);
	create_insn	(0X68AC);
	set_name	(0X68AC,	"stackinit");
	create_insn	(x=0X68B9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X68BD);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X68C0);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X68C4,	"offset",	0);
	create_insn	(x=0X68C8);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X68CC,	"segment",	0);
	create_insn	(x=0X68D0);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X68D4,	"\"firstentry\" will always be at stacks\nthe stacks will always immediately follow the table entries",	0);
	create_insn	(x=0X68D4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X68D9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X68DE,	"entrysize",	0);
	create_insn	(x=0X68E1);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X68EA);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X68F3,	"zero the entire stack area to start with",	0);
	create_insn	(x=0X68F3);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X68F8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6903,	"ds = relocated stack code seg.",	0);
	set_cmt	(0X6904,	"get segment of stack area.",	0);
	create_insn	(x=0X6904);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6909,	"0",	0);
	set_cmt	(0X690B,	"loop for \"count\" times, building a table entry\ncs = sysinitseg, ds = relocated stack code seg,\nes = segment of stack space\ncx = number of entries\nes:bp => base of stacks - 2\nes:bx => first table entry",	0);
	create_insn	(x=0X690B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X690F,	"[es:bp+allocbyte],free",	0);
	set_cmt	(0X6914,	"[es:bp+intlevel]\nax = 0",	0);
	set_cmt	(0X6918,	"[es:bp+savedsp]",	0);
	set_cmt	(0X691C,	"[es:bp+savedss]",	0);
	create_insn	(x=0X6920);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6924,	"[es:bp+newsp]",	0);
	set_cmt	(0X692B,	"entrysize",	0);
	set_cmt	(0X6930,	"entrysize",	0);
	create_insn	(x=0X6933);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X6937);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X693C,	"look at the model byte",	0);
	set_cmt	(0X6941,	"mdl_convert ; convertible?",	0);
	set_cmt	(0X6949,	"disable convertible nmis",	0);
	set_cmt	(0X694B,	"CMOS Memory/RTC Index Register (Extended RAM)",	0);
	create_insn	(x=0X694B);
	op_hex		(x,	0);
	set_cmt	(0X6952,	"Int 02h vector table offset",	0);
	set_name	(0X6952,	"stkinit_02");
	create_insn	(x=0X6955);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6958);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X695B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6961,	"Int 08h vector table offset",	0);
	create_insn	(x=0X6961);
	op_dec		(x,	1);
	set_name	(0X6961,	"stkinit_08");
	create_insn	(x=0X6964);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6967);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X696A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6970,	"Int 09h vector table offset",	0);
	create_insn	(x=0X6970);
	op_dec		(x,	1);
	set_name	(0X6970,	"stkinit_09");
	create_insn	(x=0X6973);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6976);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6979);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X697F,	"Int 70h vector table offset",	0);
	create_insn	(x=0X697F);
	op_dec		(x,	1);
	set_name	(0X697F,	"stkinit_70");
	create_insn	(x=0X6982);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6985);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6988);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X698E,	"0Ah*4 ; 40\nInt 0Ah vector table offset",	0);
	create_insn	(x=0X698E);
	op_hex		(x,	1);
	set_name	(0X698E,	"stkinit_0A");
	set_cmt	(0X6991,	"save relocated stack code segment",	0);
	set_cmt	(0X6992,	"ds:bx -> original interrupt handler",	0);
	set_cmt	(0X6996,	"dx = segment value",	0);
	set_cmt	(0X699C,	"does vector point to an iret?",	0);
	set_cmt	(0X69A1,	"magic offset (see int&aa, msstack.inc)",	0);
	set_cmt	(0X69A8,	"rom bios segment",	0);
	set_cmt	(0X69BE,	"not the first. we are going to hook vector.",	0);
	set_cmt	(0X69BF,	"we have to set old&aa for int19 handler too.",	0);
	create_insn	(x=0X69BF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X69C2,	"pass where to save original owner pointer",	0);
	create_insn	(x=0X69C2);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X69C5,	"pass where new handler is",	0);
	create_insn	(x=0X69C5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X69C8,	"adjust the vector to new handler,\nsaving pointer to original owner.",	0);
	set_cmt	(0X69CD,	"the first. don't have to hook stack code.",	0);
	create_insn	(0X69CD);
	set_cmt	(0X69CE,	"Int 0Bh vector table offset",	0);
	create_insn	(x=0X69CE);
	op_hex		(x,	1);
	create_insn	(x=0X69FF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6A02);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6A05);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6A0D);
	set_cmt	(0X6A0E,	"Int 0Ch vector table offset",	0);
	create_insn	(x=0X6A0E);
	op_hex		(x,	1);
	create_insn	(x=0X6A3F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6A42);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6A45);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6A4D);
	set_cmt	(0X6A4E,	"Int 0Dh vector table offset",	0);
	create_insn	(x=0X6A4E);
	op_hex		(x,	1);
	create_insn	(x=0X6A7F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6A82);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6A85);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6A8D);
	set_cmt	(0X6A8E,	"0Eh*4 ; Int 0Eh vector table offset",	0);
	create_insn	(x=0X6A8E);
	op_hex		(x,	1);
	create_insn	(x=0X6ABF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6AC2);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6AC5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6ACD);
	set_cmt	(0X6ACE,	"72h*4 ; 456\nInt 72h vector table offset",	0);
	create_insn	(x=0X6AFF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6B02);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6B05);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6B0D);
	set_cmt	(0X6B0E,	"73h*4 ; 460",	0);
	create_insn	(x=0X6B3F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6B42);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6B45);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6B4D);
	create_insn	(x=0X6B7F);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6B82);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6B85);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6B8D);
	set_cmt	(0X6B8E,	"76h*4 ; 472",	0);
	create_insn	(x=0X6BBF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X6BC2);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X6BC5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X6BCD);
	set_cmt	(0X6BCE,	"mov si,77h*4 ; 476\nInt 77h vector table offset",	0);
	set_cmt	(0X6BD1,	"save relocated stack code segment",	0);
	set_cmt	(0X6BD2,	"ds:bx -> original interrupt handler",	0);
	set_cmt	(0X6BD6,	"dx = segment value",	0);
	set_cmt	(0X6BDC,	"does vector point to an iret?",	0);
	set_cmt	(0X6BE1,	"magic offset (see int&aa, msstack.inc)",	0);
	set_cmt	(0X6BE8,	"rom bios segment",	0);
	set_cmt	(0X6BFE,	"not the first. we are going to hook vector.",	0);
	set_cmt	(0X6BFF,	"we have to set old&aa for int19 handler too.",	0);
	create_insn	(x=0X6BFF);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	set_cmt	(0X6C02,	"pass where to save original owner pointer",	0);
	create_insn	(x=0X6C02);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6C05,	"pass where new handler is",	0);
	create_insn	(x=0X6C05);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6C08,	"adjust the vector to new handler,\nsaving pointer to original owner.",	0);
	set_cmt	(0X6C0D,	"the first. don't have to hook stack code.",	0);
	create_insn	(0X6C0D);
	set_cmt	(0X6C14,	"mdl_convert ; pc convertible?",	0);
	set_cmt	(0X6C1C,	"enable convertible nmis",	0);
	create_insn	(x=0X6C1C);
	op_hex		(x,	1);
	set_cmt	(0X6C1E,	"CMOS Memory/RTC Index Register (Extended RAM)",	0);
	create_insn	(x=0X6C1E);
	op_hex		(x,	0);
	set_cmt	(0X6C21,	"DOSBIODATASEG",	0);
	create_insn	(x=0X6C21);
	op_hex		(x,	1);
	set_cmt	(0X6C26,	"indicate that int 19h\ninitialization is complete",	0);
	create_insn	(x=0X6C26);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X6C35,	"is DOSDATA=UMB done ? (DOSDATA is in UMB)",	0);
	create_insn	(0X6C35);
	set_name	(0X6C35,	"new_init_loop");
	set_cmt	(0X6C3D,	"restore original/previous interrupt handler\n(from int19old?? field in BIOSDATA)",	0);
	create_insn	(x=0X6C3E);
	op_hex		(x,	1);
	set_cmt	(0X6C43,	"restore original Int ?? handler addr from int19old?? field",	0);
	set_cmt	(0X6C45,	"copy the original int handler addr to its int vector addr",	0);
	set_cmt	(0X6C4D,	"new stack initialization\n(dx = new handler offset,\n bx = original handler saving addr,\n si = int vector table offset\n di = int19old?? field offset -in DOSBIOSDATASEG-\n es = zero, segid of vector table\n ds = relocated stack code segment)",	0);
	set_cmt	(0X6C5A,	"DOSBIODATASEG",	0);
	create_insn	(x=0X6C5A);
	op_hex		(x,	1);
	set_cmt	(0X6C74,	"set the devmark for mem command.\nin:\n  [memhi] - the address to place devmark\n  [memlo] = 0\n  al = id for devmark_id\nout:\n  devmark established.\n  the address saved in cs:[devmark_addr]\n  [memhi] increase by 1.",	0);
	create_insn	(0X6C74);
	set_name	(0X6C74,	"setdevmark");
	set_cmt	(0X6C82,	"[es:devmark.id]",	0);
	set_cmt	(0X6C87,	"[es:devmark.seg]",	0);
	create_word	(x=0X6C94);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X6C94,	"MagicDDNamePtr");
	create_strlit	(0X6C96,	0X6C98);
	create_strlit	(0X6C98,	0X6CA6);
	set_name	(0X6C98,	"MagicDDName");
	create_strlit	(0X6CA6,	0X6CB5);
	set_name	(0X6CA6,	"StackerName");
	set_cmt	(0X6CB5,	"phony device driver link",	0);
	create_word	(0X6CB5);
	set_name	(0X6CB5,	"tiny_stub_start");
	set_cmt	(0X6CB7,	"dw -1, -1",	0);
	create_word	(0X6CB7);
	set_cmt	(0X6CB9,	"mark as character device for MEM display",	0);
	create_word	(0X6CB9);
	set_cmt	(0X6CBB,	"strat and irpt",	0);
	create_word	(0X6CBB);
	make_array	(0X6CBB,	0X2);
	set_cmt	(0X6CBF,	"magic default load\n(tiny_stub_end-tiny_stub_start = 18)",	0);
	create_strlit	(0X6CBF,	0X6CC7);
	set_cmt	(0X6CC7,	"not for devmark",	0);
	create_insn	(0X6CC7);
	set_name	(0X6CC7,	"MagicPreload");
	set_cmt	(0X6CD2,	"not to be loaded in UMB",	0);
	set_cmt	(0X6CDF,	"calculate seg after DD load",	0);
	set_cmt	(0X6CE4,	"choke if overflows address space",	0);
	set_cmt	(0X6CE6,	"does it overflow available space?",	0);
	set_cmt	(0X6CED,	"we're golden if not",	0);
	set_name	(0X6CED,	"_LoadDev");
	set_cmt	(0X6CF4,	"load device driver using exec call",	0);
	set_cmt	(0X6CF9,	"point to the Magic DD header",	0);
	set_cmt	(0X6CFE,	"is it our stamp? ; ',.'",	0);
	create_insn	(x=0X6CFE);
	op_hex		(x,	1);
	set_cmt	(0X6D06,	"save the backdoor entry.\n(initial IP -EXE header offset 20-)",	0);
	create_insn	(x=0X6D06);
	create_insn	(x=0X6D0D);
	create_insn	(x=0X6D14);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6D26,	"pass drive number to DBLSPACE as if",	0);
	set_cmt	(0X6D2A,	"it is a normal block device driver",	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_4(void) {
        auto x;
#define id x

	set_cmt	(0X6D2E,	"DS_INTERNAL_REVISION\ntell it what revision we expect",	0);
	create_insn	(x=0X6D2E);
	op_dec		(x,	1);
	set_cmt	(0X6D31,	"first time call is init entry point\nwith a standard device driver\ninit packet at es:bx",	0);
	create_insn	(x=0X6D31);
	set_cmt	(0X6D36,	"skip if not a version failure",	0);
	set_cmt	(0X6D38,	"DS_INTERNAL_REVISION_6 ; (Stacker ?)\ntell it what revision we expect",	0);
	create_insn	(x=0X6D3B);
	create_insn	(x=0X6D44);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6D47,	"display the message",	0);
	create_insn	(x=0X6D4A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X6D4F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6D56,	"SYSPRE_BADFILE_ERROR\n(problem loading dblspace.bin)",	0);
	create_insn	(x=0X6D56);
	op_hex		(x,	1);
	set_cmt	(0X6D5A,	"error code returned?",	0);
	create_insn	(0X6D5A);
	set_name	(0X6D5E,	"magic_is_resident");
	set_cmt	(0X6D62,	"convert to paragraphs",	0);
	set_cmt	(0X6D6E,	"store normalized end here",	0);
	set_cmt	(0X6D75,	"inquire how many paragraphs it wants",	0);
	set_cmt	(0X6D7D,	"get top of free memory",	0);
	set_cmt	(0X6D82,	"see how much we'll lower it",	0);
	set_cmt	(0X6D84,	"is there that much room free?",	0);
	set_cmt	(0X6D8B,	"(mov [cs:ALLOCLIM],bx)",	0);
	set_cmt	(0X6D95,	"tell the driver to move itself",	0);
	set_cmt	(0X6D9D,	"save end of low stub",	0);
	set_cmt	(0X6DA1,	"get terminate segment",	0);
	set_name	(0X6DA1,	"cant_move_driver");
	set_cmt	(0X6DA5,	"terminate size TOO big?",	0);
	set_cmt	(0X6DAA,	"error out if so",	0);
	set_cmt	(0X6DAC,	"if no units found, erase the device",	0);
	set_name	(0X6DAC,	"_isblock");
	set_cmt	(0X6DB6,	"set ds:si to header",	0);
	set_cmt	(0X6DBB,	"mov [si+SYSDEV.NAME],al\nnumber of units in name field \ndevice drivers are *supposed*\nto do this for themselves.",	0);
	create_insn	(x=0X6DBB);
	op_dec		(x,	0);
	set_cmt	(0X6DC0,	"es:di point to dos info",	0);
	set_cmt	(0X6DC5,	"[es:di+SYSI_NUMIO]\nget number of devices",	0);
	set_cmt	(0X6DCB,	"check for too many devices",	0);
	set_cmt	(0X6DCD,	"'A' - 'Z' is 26 devices",	0);
	create_insn	(x=0X6DCD);
	op_dec		(x,	1);
	create_insn	(x=0X6DD2);
	op_hex		(x,	1);
	set_cmt	(0X6DE0,	"[es:di+SYSI_NUMIO] ; update the amount",	0);
	create_insn	(0X6DE0);
	set_cmt	(0X6DE4,	"point to bpb array (*)",	0);
	set_name	(0X6DEB,	"_perunit");
	set_cmt	(0X6DF0,	"es:[bp.sysi_dpb]\nget first dpb\n[es:bp+SysInitvars.SYSI_DPB] ; [es:bp+0]",	0);
	set_cmt	(0X6DF4,	"-1 ; es:[bp.dpb_next_dpb]",	0);
	set_cmt	(0X6DFB,	"les bp,es:[bp.dpb_next_dpb]\n[es:bp+DPB.NEXT_DPB]",	0);
	create_insn	(0X6E01);
	set_cmt	(0X6E05,	"es:[bp.dpb_next_dpb] ; DPB.NEXT_DPB",	0);
	set_cmt	(0X6E0D,	"es:[bp.dpb_next_dpb+2] ; DPB.NEXT_DPB+2",	0);
	set_cmt	(0X6E16,	"-1",	0);
	set_cmt	(0X6E1C,	"es:[bp.dpb_first_access],-1\nDPB.FIRST_ACCESS",	0);
	set_cmt	(0X6E21,	"DPBSIZ ; 3Dh",	0);
	create_insn	(x=0X6E21);
	op_dec		(x,	1);
	set_cmt	(0X6E2A,	"ds:si points to bpb (*)\n(mov si,[bx] ..and then.. add bx,2)\nNote: If unit count > 1, bx points to a BPB in the BPB array,\nthe array address is in [bpb_addr] (*) \nErdogan Tan - 07/07/2023",	0);
	set_cmt	(0X6E2C,	"mov word ptr es:[bp.dpb_drive],dx\n[es:bp+DPB.DRIVE],dl",	0);
	set_cmt	(0X6E30,	"[es:bp+DPB.UNIT],dh",	0);
	set_cmt	(0X6E36,	"DX = signature 4152h ('AR') for FAT32 extended BPB/DPB",	0);
	set_cmt	(0X6E39,	"0",	0);
	set_cmt	(0X6E3B,	"DPB.NEXT_FREE ; last allocated cluster #",	0);
	set_cmt	(0X6E3F,	"BPB.fatsecs16 ; [si+A_BPB.BPB_SECTORSPERFAT]",	0);
	set_cmt	(0X6E42,	"FAT DPB (33 bytes)\nFAT32 DPB (61 bytes)",	0);
	set_cmt	(0X6E44,	"DPB.RESERVED = 0",	0);
	set_cmt	(0X6E48,	"DPB.RESERVED+2 = 0",	0);
	set_cmt	(0X6E4C,	"0FFFFh ; -1",	0);
	set_cmt	(0X6E4D,	"DPB.FREE_CNT (-1 = unknown)",	0);
	set_cmt	(0X6E51,	"DPB.FREE_CNT+2 (-1 = unknown)",	0);
	set_cmt	(0X6E55,	"CX = signature 4558h ('EX') for FAT32 extended BPB/DPB",	0);
	set_cmt	(0X6E58,	"SETDPB ; hidden system call",	0);
	create_insn	(x=0X6E58);
	op_hex		(x,	1);
	set_cmt	(0X6E5A,	"DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK\nDS:SI -> BPB (BIOS Parameter Block)\nES:BP -> buffer for DOS Drive Parameter Block\n(if CX=4558h & DX=4152h, FAT32 Extended DPB will be set)",	0);
	create_insn	(x=0X6E5A);
	op_hex		(x,	0);
	set_cmt	(0X6E5E,	"es:[bp.dpb_sector_size]  ; [es:bp+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X6E68,	"es:[di.sysi_maxsec] ; [es:di+SysInitvars.SYSI_MAXSEC]",	0);
	set_cmt	(0X6E6F,	"SYSPRE_BADFILE_ERROR ; (pre_exit_err)\n(problem loading dblspace.bin)",	0);
	create_insn	(x=0X6E6F);
	op_hex		(x,	1);
	create_insn	(0X6E73);
	set_cmt	(0X6E79,	"[es:bp+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0X6E7D,	"[es:bp+DPB.DRIVER_ADDR+2]",	0);
	set_cmt	(0X6E82,	"increment drive number",	0);
	set_cmt	(0X6E84,	"increment unit number",	0);
	set_cmt	(0X6E87,	"point to next BPB\n(in the BPB array) (*) -add bx,2-",	0);
	set_cmt	(0X6E88,	"loop _foundpb",	0);
	create_insn	(0X6E8E);
	set_cmt	(0X6E90,	"set cds for new drives",	0);
	set_cmt	(0X6E93,	"es:di = dos table (SysInitVars)",	0);
	set_cmt	(0X6E98,	"[es:di+SYSI_DEV] ; dx:cx = head of list",	0);
	set_cmt	(0X6E9C,	"[es:di+SYSI_DEV+2]",	0);
	set_cmt	(0X6EA0,	"ds:si = device location",	0);
	set_cmt	(0X6EA5,	"link in the driver",	0);
	set_cmt	(0X6EAA,	"[es:di+SYSI_DEV] ; set head of list in dos",	0);
	set_cmt	(0X6EAE,	"[es:di+SYSI_DEV+2]",	0);
	set_cmt	(0X6EB2,	"mark successful install",	0);
	set_cmt	(0X6EB5,	"pass it a work buffer",	0);
	set_cmt	(0X6EBA,	"address in cx (segment)",	0);
	set_cmt	(0X6EBF,	"for len dx (paragraphs)",	0);
	set_cmt	(0X6EC1,	"we're shuffle aware, but don't move\nany drives at this point.",	0);
	set_cmt	(0X6EC4,	"switch what we can now",	0);
	set_cmt	(0X6ECC,	"no errors!\nzf=1",	0);
	set_name	(0X6ECC,	"pre_exit");
	set_cmt	(0X6ECF,	"is it there?",	0);
	create_insn	(0X6ECF);
	set_name	(0X6ECF,	"MagicPostload");
	set_cmt	(0X6ED2,	"done if not",	0);
	set_cmt	(0X6ED4,	"is it already permanent?",	0);
	create_insn	(x=0X6ED4);
	op_hex		(x,	1);
	set_cmt	(0X6ED8,	"no, done if so (not in final position)",	0);
	set_cmt	(0X6EDA,	"-1 ; how much space does it want?",	0);
	set_cmt	(0X6EDD,	"multMagicdrv\nDBLSPACE.BIN - GET RELOCATION SIZE",	0);
	set_cmt	(0X6EE0,	"get paragraphs into ax",	0);
	create_insn	(x=0X6EE0);
	op_hex		(x,	0);
	set_cmt	(0X6EE2,	"extra 2 paragraphs for the stub",	0);
	set_cmt	(0X6EE3,	"((tiny_stub_end-tiny_stub_start)+15)/16\n(18+15)/16 = 2",	0);
	set_cmt	(0X6EE4,	"store that (**)",	0);
	set_cmt	(0X6EE8,	"not to be loaded in UMB",	0);
	set_cmt	(0X6EEE,	"pass name so that\narena header can be set",	0);
	create_insn	(x=0X6EF3);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6EFA,	"normalize memhi:memlo",	0);
	set_cmt	(0X6EFD,	"set up sub-arena, DevLoadAddr,\nDevLoadEnd, and DevEntry\ngets arena name from bpb_addr",	0);
	set_cmt	(0X6F00,	"(**) (InitDevload sets this)",	0);
	set_cmt	(0X6F05,	"move a little header in place\nso that this looks to the mem command\nlike a legitimate driver load",	0);
	create_insn	(x=0X6F07);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X6F0A,	"(tiny_stub_end-tiny_stub_start)",	0);
	create_insn	(x=0X6F0A);
	op_dec		(x,	1);
	set_cmt	(0X6F0D,	"move it!",	0);
	set_cmt	(0X6F0F,	"advance es appropriately",	0);
	set_cmt	(0X6F11,	"add ax,((tiny_stub_end-tiny_stub_start)+15)/16",	0);
	set_cmt	(0X6F15,	"-2 ; final placement!",	0);
	set_cmt	(0X6F18,	"multMagicdrv",	0);
	set_cmt	(0X6F1B,	"DBLSPACE.BIN - RELOCATE\nes = segment to which to relocate DBLSPACE.BIN",	0);
	create_insn	(x=0X6F1B);
	op_hex		(x,	0);
	set_cmt	(0X6F1D,	"(**)",	0);
	set_cmt	(0X6F21,	"calculate seg after DD load",	0);
	set_cmt	(0X6F26,	"save as ending address!",	0);
	set_cmt	(0X6F31,	"go ahead and alloc mem for device",	0);
	set_cmt	(0X6F38,	"is it there?",	0);
	create_insn	(0X6F38);
	set_name	(0X6F38,	"MagicSetCdss");
	set_cmt	(0X6F3B,	"done if not\n...\ncl = first DblSpace drive in ASCII\nch = number of DblSpace drive letters",	0);
	set_cmt	(0X6F3D,	"point to DOS data area (SysInitVars)",	0);
	set_cmt	(0X6F42,	"lds si,[si+SYSI_CDS] ; fetch CDSs",	0);
	set_cmt	(0X6F45,	"curdirLen",	0);
	create_insn	(x=0X6F45);
	op_dec		(x,	1);
	set_cmt	(0X6F47,	"make it zero based.",	0);
	create_insn	(x=0X6F47);
	op_chr		(x,	1);
	set_cmt	(0X6F4A,	"get first DblSpace drive letter",	0);
	set_cmt	(0X6F4C,	"find first DblSpace CDS",	0);
	set_cmt	(0X6F4E,	"cds pointer",	0);
	set_cmt	(0X6F50,	"save for drive testing loop",	0);
	set_cmt	(0X6F52,	"get DblSpace drive count into cx",	0);
	set_cmt	(0X6F5A,	"multMagicdrv",	0);
	set_cmt	(0X6F5D,	"MD_DRIVE_MAP ; inquire drive map",	0);
	set_cmt	(0X6F60,	"DBLSPACE.BIN - \"GetDriveMapping\"\nsee if this is an unused DblSpace drive",	0);
	create_insn	(x=0X6F60);
	op_hex		(x,	0);
	set_cmt	(0X6F66,	"if mapped to itself, it is vacant",	0);
	set_cmt	(0X6F68,	"skip if used",	0);
	set_cmt	(0X6F6A,	"reset the bit in flags (curdir_inuse bit)\n[si+curdir_list.cdir_flags],~curdir_inuse ; word\n(.. [si+1+curdir_list.cdir_flags],0BFh ; byte)",	0);
	create_insn	(x=0X6F6A);
	op_hex		(x,	1);
	set_cmt	(0X6F6F,	"curdirLen",	0);
	create_insn	(x=0X6F6F);
	op_dec		(x,	1);
	set_cmt	(0X6F72,	"next drive",	0);
	set_cmt	(0X6F77,	"multMagicdrv\nDBLSPACE.BIN - \"GetVersion\" - INSTALLATION CHECK\n(BX = 0)",	0);
	create_insn	(0X6F77);
	set_name	(0X6F77,	"get_dblspace_version");
	set_cmt	(0X6F7A,	"MD_VERSION = 0",	0);
	set_cmt	(0X6F7C,	"Return:\n AX = 0000h (successful)\n BX = 444Dh (\"DM\")\n CL = first drive letter used by DBLSPACE (41h = A:)\n CH = number of drive letters used by DBLSPACE\n DX = internal DBLSPACE.BIN version number (bits 14-0)\n bit 15 set if DBLSPACE.BIN has not yet been relocated\n to final position in memory (i.e. DBLSPACE.SYS /MOVE)",	0);
	create_insn	(x=0X6F7C);
	op_hex		(x,	0);
	set_cmt	(0X6F7E,	"ax = 0 (successful, zf=1)",	0);
	create_byte	(0X6F81);
	set_cmt	(0X6F82,	"when config_wrkseg is being used as\na scratch env, this is its length",	0);
	create_word	(0X6F82);
	set_name	(0X6F82,	"config_envlen");
	set_cmt	(0X6F84,	"config work area (above confbot)\nsegment of work area",	0);
	create_word	(0X6F84);
	set_name	(0X6F84,	"config_wrkseg");
	set_cmt	(0X6F86,	"current config cmd\n(with CONFIG_OPTION_QUERY bit intact)",	0);
	create_byte	(0X6F86);
	set_name	(0X6F86,	"config_cmd");
	set_cmt	(0X6F87,	"non-zero if multi-config config.sys",	0);
	create_byte	(0X6F87);
	set_name	(0X6F87,	"config_multi");
	create_byte	(0X6F88);
	set_name	(0X6F88,	"multdeviceflag");
	set_cmt	(0X6F89,	"segment address for devmark.",	0);
	create_word	(0X6F89);
	set_name	(0X6F89,	"devmark_addr");
	set_cmt	(0X6F8B,	"flag used for devmark",	0);
	create_byte	(0X6F8B);
	set_name	(0X6F8B,	"setdevmarkflag");
	set_cmt	(0X6F8C,	"total unitcount for driver",	0);
	create_byte	(0X6F8C);
	set_name	(0X6F8C,	"drivers_units");
	set_cmt	(0X6F8D,	"(not used)",	0);
	create_byte	(0X6F8D);
	set_name	(0X6F8D,	"ems_stub_installed");
	set_cmt	(0X6F8E,	"badparm_off equ badparm_ptr\nbadparm_seg equ badparm_ptr+2",	0);
	create_dword	(0X6F8E);
	set_name	(0X6F8E,	"badparm_ptr");
	set_cmt	(0X6F92,	"Operand ordinal save area",	0);
	create_word	(0X6F92);
	set_name	(0X6F92,	"_$P_ORDINAL");
	set_cmt	(0X6F94,	"Return code from parser",	0);
	create_word	(0X6F94);
	set_name	(0X6F94,	"_$P_RC");
	set_cmt	(0X6F96,	"Pointer of command buffer",	0);
	create_word	(0X6F96);
	set_name	(0X6F96,	"_$P_SI_Save");
	set_cmt	(0X6F98,	"Return result buffer address",	0);
	create_word	(0X6F98);
	set_name	(0X6F98,	"_$P_DX");
	set_cmt	(0X6F9A,	"Terminator code (ASCII)",	0);
	create_byte	(0X6F9A);
	set_name	(0X6F9A,	"_$P_Terminator");
	set_cmt	(0X6F9B,	"Offset of DBCS EV",	0);
	create_word	(0X6F9B);
	set_name	(0X6F9B,	"_$P_DBCSEV_OFF");
	set_cmt	(0X6F9D,	"Segment of DBCS EV",	0);
	create_word	(0X6F9D);
	set_name	(0X6F9D,	"_$P_DBCSEV_SEG");
	set_cmt	(0X6F9F,	"Parser internal flags\n%define _$P_Flags1 _$P_Flags\n        to reference 1st byte flags\n%define _$P_Flags2 _$P_Flags+1\n        to reference 2nd byte flags only",	0);
	create_byte	(0X6F9F);
	set_name	(0X6F9F,	"_$P_Flags");
	create_byte	(0X6FA0);
	set_name	(0X6FA0,	"_$P_Flags2");
	set_cmt	(0X6FA1,	"save si for later use by complex",	0);
	create_word	(0X6FA1);
	set_name	(0X6FA1,	"_$P_SaveSI_Cmpx");
	set_cmt	(0X6FA3,	"points next to \"=\" or \":\" code",	0);
	create_word	(0X6FA3);
	set_name	(0X6FA3,	"_$P_KEYorSW_Ptr");
	set_cmt	(0X6FA5,	"save pointer to EOB",	0);
	create_word	(0X6FA5);
	set_name	(0X6FA5,	"_$P_Save_EOB");
	set_cmt	(0X6FA7,	"es:@ points to found synonym",	0);
	create_word	(0X6FA7);
	set_name	(0X6FA7,	"_$P_Found_SYNONYM");
	set_cmt	(0X6FA9,	"Pick a operand from command line",	0);
	create_byte	(x=0X6FA9);
	make_array	(x,	0X80);
	op_dec		(x,	0);
	set_name	(0X6FA9,	"_$P_STRING_BUF");
	set_cmt	(0X7029,	"info id",	0);
	create_byte	(0X7029);
	set_name	(0X7029,	"_$P_Char_CAP_Ptr");
	set_cmt	(0X702A,	"offset of char case map table",	0);
	create_word	(0X702A);
	set_cmt	(0X702C,	"segment of char case map table",	0);
	create_word	(0X702C);
	set_cmt	(0X702E,	"delimitters of file spec\n_$P_FileSp_Len equ $-_$P_FileSp_Char",	0);
	create_strlit	(0X702E,	0X7037);
	set_name	(0X702E,	"_$P_FileSp_Char");
	set_cmt	(0X7037,	"flag set if filespec parsing error\nwas detected.",	0);
	create_byte	(0X7037);
	set_name	(0X7037,	"_$P_err_flag");
	set_cmt	(0X7038,	"Clear all internal flags",	0);
	create_insn	(0X7038);
	set_name	(0X7038,	"SysParse");
	set_cmt	(0X703F,	"confirm forward direction",	0);
	set_cmt	(0X7040,	"save operand ordinal",	0);
	set_cmt	(0X7045,	"_$P_No_Error ; assume no error",	0);
	set_cmt	(0X704C,	"initalize synonym pointer",	0);
	set_cmt	(0X7053,	"The table of special chars _$P_FileSp_Char\nshould be initialized on every entry to SysParse",	0);
	set_cmt	(0X7076,	"Move si to 1st non white space",	0);
	set_cmt	(0X7079,	"If EOL is not encountered, do parse",	0);
	set_cmt	(0X707B,	"_$P_RC_EOL  ; set exit code to -1",	0);
	set_cmt	(0X707F,	"[es:di+_$P_PARMS_Blk.PARMSX_Address]\nGet the PARMSX address to",	0);
	set_cmt	(0X7082,	"[es:bx+_$P_PARMSX_Blk.MinP]\ncheck ORDINAL to see if the minimum",	0);
	set_cmt	(0X7085,	"positional found.",	0);
	set_cmt	(0X7087,	"$P_Op_Missing ; If no, set exit code to missing operand",	0);
	set_cmt	(0X708B,	"return to the caller",	0);
	set_cmt	(0X708E,	"save ptr to command line for later use\nby complex quoted string or file spec.",	0);
	create_insn	(0X708E);
	set_cmt	(0X7096,	"set buffer to copy from command string",	0);
	create_insn	(x=0X7096);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X709A,	"_$P_Extra ; 3/9 extra delimiter encountered ?",	0);
	create_insn	(x=0X709A);
	op_hex		(x,	1);
	set_cmt	(0X70A0,	"3/9 if yes, no need to copy",	0);
	set_cmt	(0X70A2,	"Pick a operand from buffer",	0);
	set_cmt	(0X70A3,	"Check switch character",	0);
	set_cmt	(0X70A6,	"if carry set found delimiter type slash, \nneed backup si, else continue",	0);
	set_cmt	(0X70A8,	"Check EOL character",	0);
	set_cmt	(0X70AB,	"need backup si",	0);
	set_cmt	(0X70AD,	"Check delimiter",	0);
	set_cmt	(0X70B0,	"If no, process next byte",	0);
	set_cmt	(0X70B2,	"_$P_Extra ; 3/9 If yes and white spec,",	0);
	create_insn	(x=0X70B2);
	op_hex		(x,	1);
	set_cmt	(0X70B8,	"3/9 then",	0);
	set_cmt	(0X70BA,	"skip subsequent white space,too",	0);
	set_cmt	(0X70BD,	"finish copy by placing NUL at end",	0);
	set_cmt	(0X70BF,	"_$P_SW+_$P_equ",	0);
	create_insn	(x=0X70BF);
	op_hex		(x,	1);
	set_cmt	(0X70CA,	"move byte to STRING_BUF",	0);
	create_insn	(0X70CA);
	set_cmt	(0X70CD,	"_$P_Keyword ; if it is equal character,",	0);
	set_cmt	(0X70CF,	"then",	0);
	set_cmt	(0X70D1,	"_$P_equ ; remember it in flag",	0);
	create_insn	(x=0X70D1);
	op_hex		(x,	1);
	set_cmt	(0X70D7,	"ready to see next byte",	0);
	set_cmt	(0X70D8,	"was it 1st byte of DBCS ?",	0);
	set_cmt	(0X70DB,	"if no, process to next byte",	0);
	set_cmt	(0X70DE,	"if yes, store 2nd byte of DBCS",	0);
	set_cmt	(0X70E1,	"update pointer",	0);
	set_cmt	(0X70E2,	"process to next byte",	0);
	set_cmt	(0X70E4,	"backup si pointer",	0);
	create_insn	(0X70E4);
	set_cmt	(0X70E5,	"save next pointer, SI",	0);
	set_cmt	(0X70EA,	"_$P_NULL ; put NULL at the end",	0);
	set_cmt	(0X70EE,	"keep the address for later use of complex",	0);
	set_cmt	(0X70F3,	"[es:di+_$P_PARMS_Blk.PARMSX_Address]\nget PARMSX address",	0);
	create_insn	(x=0X70F6);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X70FA,	"the operand begins w/ switch char ?\n_$P_Switch",	0);
	set_cmt	(0X70FE,	"if yes, process as switch",	0);
	set_cmt	(0X7100,	"_$P_DQuote  ; is it a string?",	0);
	set_cmt	(0X7104,	"if so, process as one!",	0);
	set_cmt	(0X7106,	"$P_equ ; the operand includes equal",	0);
	create_insn	(x=0X7106);
	op_hex		(x,	1);
	set_cmt	(0X710C,	"if yes, process as keyword",	0);
	set_cmt	(0X710E,	"else process as positional\nget maxp",	0);
	set_cmt	(0X7112,	"ax = maxp",	0);
	set_cmt	(0X7114,	"too many positional ?",	0);
	set_cmt	(0X7119,	"if yes, set exit code to too many",	0);
	set_cmt	(0X711B,	"see what the current ordinal",	0);
	set_cmt	(0X711F,	"ax = ax*2",	0);
	create_insn	(x=0X711F);
	op_hex		(x,	1);
	set_cmt	(0X7122,	"add '2' to bx reg\nnow bx points to 1st CONTROL",	0);
	set_cmt	(0X7123,	"now bx points to specified CONTROL address",	0);
	set_cmt	(0X7125,	"now bx points to specified CONTROL itself",	0);
	set_cmt	(0X7128,	"Do process for positional",	0);
	set_cmt	(0X712B,	"and return to the caller",	0);
	set_cmt	(0X712D,	"set exit code",	0);
	create_insn	(0X712D);
	set_cmt	(0X7134,	"and return to the caller",	0);
	set_cmt	(0X7136,	"[es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp",	0);
	create_insn	(0X7136);
	set_name	(0X7136,	"get_maxp");
	create_insn	(x=0X713D);
	op_hex		(x,	1);
	set_cmt	(0X713F,	"now bx points to maxs",	0);
	create_insn	(0X7142);
	set_cmt	(0X7148,	"cx = maxs\nat least one switch ?",	0);
	set_cmt	(0X714A,	"no",	0);
	set_cmt	(0X714C,	"now bx points to 1st CONTROL address",	0);
	set_cmt	(0X714E,	"bx points to Switch CONTROL itself",	0);
	set_cmt	(0X7155,	"\nif the CONTROL is for the switch, exit",	0);
	set_cmt	(0X7158,	"   add '2' to bx reg\nelse bx points to the next CONTROL",	0);
	set_cmt	(0X7159,	"and loop",	0);
	set_cmt	(0X715B,	"_$P_Not_In_SW \nhere no CONTROL for the switch has",	0);
	create_insn	(0X7164);
	set_cmt	(0X716A,	"ax = maxs",	0);
	create_insn	(x=0X716C);
	op_hex		(x,	1);
	set_cmt	(0X716E,	"ax = ax*2+1",	0);
	set_cmt	(0X716F,	"now bx points to maxk",	0);
	set_cmt	(0X7171,	"cx = maxk",	0);
	set_cmt	(0X7174,	"at least one keyword ?",	0);
	set_cmt	(0X7176,	"no",	0);
	set_cmt	(0X7178,	"now bx points to 1st CONTROL",	0);
	set_cmt	(0X717A,	"bx points to keyword CONTROL itself",	0);
	set_cmt	(0X717D,	"do process for keyword",	0);
	set_cmt	(0X7181,	"\nif the CONTROL is for the keyword, exit",	0);
	set_cmt	(0X7184,	"   add '2' to bx reg\nelse bx points to the next CONTROL",	0);
	set_cmt	(0X7185,	"and loop",	0);
	set_cmt	(0X7187,	"_$P_Not_In_Key\nhere no CONTROL for the keyword has",	0);
	set_cmt	(0X7191,	"return next ordinal",	0);
	set_cmt	(0X7196,	"return exit code",	0);
	set_cmt	(0X719A,	"return next operand pointer",	0);
	set_cmt	(0X719F,	"return result buffer address",	0);
	set_cmt	(0X71A4,	"return delimiter code found",	0);
	create_insn	(0X71AB);
	set_name	(0X71AB,	"_$P_Chk_Pos_Control");
	set_cmt	(0X71AC,	"[es:bx+_$P_Control_Blk.Match_Flag]",	0);
	set_cmt	(0X71AF,	"$P_Repeat ; repeat allowed ?",	0);
	create_insn	(x=0X71AF);
	op_hex		(x,	1);
	set_cmt	(0X71B2,	"then do not increment ORDINAL",	0);
	set_cmt	(0X71B4,	"update the ordinal",	0);
	set_cmt	(0X71B9,	"_$P_NULL ; no data ?",	0);
	set_cmt	(0X71BF,	"_$P_Optional ; yes, then is it optional ?",	0);
	create_insn	(x=0X71BF);
	op_hex		(x,	1);
	set_cmt	(0X71C4,	"_$P_Op_Missing ; no, then error",	0);
	create_insn	(0X71CD);
	set_cmt	(0X71CE,	"(_$P_No_Tag<<8)|_$P_String\nif it is optional return NULL\nno item tag indication",	0);
	create_insn	(0X71D7);
	set_cmt	(0X71DC,	"this logic works \nwhen the KeySW is reset.",	0);
	create_insn	(0X71DC);
	set_name	(0X71DC,	"_$P_Chk_Key_Control");
	create_insn	(0X71DE);
	set_name	(0X71DE,	"_$P_Search_KEYorSW");
	set_cmt	(0X71E0,	"[es:bx+_$P_Control_Blk.nid] ; Get synonym count",	0);
	set_cmt	(0X71E4,	"and set it to cx",	0);
	set_cmt	(0X71E6,	"No synonyms specified ?\nthen indicate not found by CY",	0);
	set_cmt	(0X71E8,	"[bx+_$P_Control_Blk.KEYorSW]",	0);
	set_cmt	(0X71EB,	"compare string in buffer w/ the synonym",	0);
	set_cmt	(0X71EE,	"If match, set it to synonym pointer",	0);
	set_cmt	(0X71F0,	"else, bp points to the next string",	0);
	set_cmt	(0X71F3,	"loop nid times",	0);
	set_cmt	(0X71F5,	"indicate not found in synonym list",	0);
	set_cmt	(0X71F6,	"and exit",	0);
	set_cmt	(0X71F8,	"set synonym pointer",	0);
	create_insn	(0X71F8);
	set_cmt	(0X71FD,	"indicate found",	0);
	set_cmt	(0X7201,	"_$P_NULL\nIncrement BP that points",	0);
	create_insn	(0X7201);
	set_name	(0X7201,	"_$P_MoveBP_NUL");
	set_cmt	(0X7206,	"to the synomym list",	0);
	set_cmt	(0X7208,	"until",	0);
	set_cmt	(0X7209,	"NULL encountered.\n_$P_MBP_Loop",	0);
	set_cmt	(0X720B,	"bp points to next to NULL",	0);
	create_insn	(0X720B);
	set_cmt	(0X720D,	"(Check if switch is supported)\n_$P_SW_Cmp\nIndicate switch for later string comparison",	0);
	create_insn	(x=0X720D);
	op_hex		(x,	1);
	set_name	(0X720D,	"_$P_Chk_SW_Control");
	set_cmt	(0X7213,	"Search the switch in the CONTROL block",	0);
	set_cmt	(0X7216,	"not found, then try next CONTROL",	0);
	set_cmt	(0X7218,	"and byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp\nreset the indicator previously set /switch",	0);
	create_insn	(x=0X7218);
	op_hex		(x,	1);
	set_cmt	(0X7223,	"[si] = KEY or SW",	0);
	set_cmt	(0X7225,	"update for complex list",	0);
	set_cmt	(0X722B,	"set si at the end or colon",	0);
	set_cmt	(0X7230,	"_$P_NULL ; any data after colon ?",	0);
	set_cmt	(0X7234,	"if yes, process match flags",	0);
	set_cmt	(0X7236,	"_$P_Colon\nif no, the switch terminated by colon ?",	0);
	create_insn	(x=0X7236);
	op_chr		(x,	1);
	set_cmt	(0X723B,	"\nif yes,",	0);
	set_cmt	(0X723D,	"_$P_Syntax ; return syntax error",	0);
	set_cmt	(0X7246,	"[es:bx+_$P_Control_Blk.Match_Flag]\nshould have data? \nzero match flag means switch followed by nothing is OK",	0);
	create_insn	(0X7246);
	set_cmt	(0X724A,	"match flags not zero so \nshould have something if optional bit is not on",	0);
	set_cmt	(0X724C,	"_$P_Optional ; see if no value is valid",	0);
	create_insn	(x=0X724C);
	op_hex		(x,	1);
	set_cmt	(0X7251,	"if so, then leave, else yell",	0);
	set_cmt	(0X7253,	"_$P_Op_Missing\nreturn required operand missing",	0);
	set_cmt	(0X725C,	"process match flag",	0);
	create_insn	(0X725C);
	set_cmt	(0X725F,	"indicate match",	0);
	set_cmt	(0X7262,	"not found in switch synonym list",	0);
	create_insn	(0X7262);
	create_insn	(0X7264);
	set_cmt	(0X7265,	"(_$P_No_Tag<<8)|_$P_String",	0);
	set_cmt	(0X7268,	"set result buffer",	0);
	create_insn	(0X726E);
	set_name	(0X726E,	"_$P_Fill_Result");
	set_cmt	(0X726F,	"[es:bx+_$P_Control_Blk.Result_Buf]\ndi points to result buffer",	0);
	set_cmt	(0X7273,	"set returned result address",	0);
	set_cmt	(0X7278,	"[es:di+_$P_Result_Blk.Type] ; store type",	0);
	set_cmt	(0X727B,	"[es:di+_$P_Result_Blk.Item_Tag] ; store item tag",	0);
	set_cmt	(0X7284,	"[es:di+_$P_Result_Blk.SYNONYM_Ptr]",	0);
	set_cmt	(0X7289,	"\n_$P_Number ; if number",	0);
	set_name	(0X7289,	"_$P_RLT04");
	set_cmt	(0X728B,	"\nthen store 32 bit",	0);
	set_cmt	(0X728D,	"[es:di+_$P_Result_Blk.Picked_Val]",	0);
	set_cmt	(0X7291,	"[es:di+_$P_Result_Blk.Picked_Val+2]",	0);
	set_cmt	(0X7297,	"_$P_List_Idx ; if list index",	0);
	create_insn	(0X7297);
	set_cmt	(0X7299,	"\nthen store list index",	0);
	set_cmt	(0X729B,	"[es:di+_$P_Result_Blk.Picked_Val]",	0);
	set_cmt	(0X72A1,	"_$P_Date_F ; Date format ?",	0);
	create_insn	(0X72A1);
	set_cmt	(0X72A5,	"_$P_Time_F ; Time format ?",	0);
	set_cmt	(0X72A9,	"_$P_Drive ; drive format ?",	0);
	set_cmt	(0X72AD,	"[es:di+_$P_Result_Blk.Picked_Val]\nstore drive number",	0);
	set_cmt	(0X72B3,	"_$P_Complex ; complex format ?",	0);
	create_insn	(0X72B3);
	set_cmt	(0X72B7,	"\nthen get pointer in command buffer",	0);
	set_cmt	(0X72BB,	"skip left Parentheses",	0);
	set_cmt	(0X72BC,	"[es:di+_$P_Result_Blk.Picked_Val]\nstore offset",	0);
	set_cmt	(0X72C0,	"[es:di+_$P_Result_Blk.Picked_Val+2]\nstore segment",	0);
	set_cmt	(0X72C6,	"AL = 3, 5, or 9\n[es:di+_$P_Result_Blk.Picked_Val]\nstore offset of STRING_BUF",	0);
	create_insn	(0X72C6);
	set_cmt	(0X72CA,	"[es:di+_$P_Result_Blk.Picked_Val+2]\nstore segment of STRING_BUF",	0);
	set_cmt	(0X72CF,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_CAP_File \nneed CAPS by file table?",	0);
	create_insn	(x=0X72CF);
	op_hex		(x,	1);
	set_cmt	(0X72D6,	"_$P_DOSTBL_File ; use file upper case table",	0);
	set_cmt	(0X72DA,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_CAP_Char \nneed CAPS by char table",	0);
	create_insn	(x=0X72DA);
	op_hex		(x,	1);
	set_cmt	(0X72E1,	"_$P_DOSTBL_Char\nuse character upper case table",	0);
	set_cmt	(0X72E3,	"process CAPS along the table",	0);
	set_cmt	(0X72E7,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_Rm_Colon \nremoving colon at end ?",	0);
	create_insn	(x=0X72E7);
	op_hex		(x,	1);
	set_cmt	(0X72EE,	"then process it.",	0);
	set_cmt	(0X72F3,	"_$P_NULL ; clear filespec error flag.",	0);
	create_insn	(0X72F3);
	set_name	(0X72F3,	"_$P_Check_Match_Flags");
	set_cmt	(0X72FA,	"[es:bx+_$P_Control_Blk.Match_Flag]\nload match flag (16bit) to ax",	0);
	set_cmt	(0X72FD,	"test ax for zero",	0);
	set_cmt	(0X7305,	"_$P_Syntax",	0);
	create_insn	(0X7318);
	create_insn	(0X731A);
	set_cmt	(0X731C,	"90h",	0);
	create_insn	(0X731C);
	set_cmt	(0X731D,	"_$P_Num_Val ; Numeric value",	0);
	create_insn	(x=0X731D);
	op_hex		(x,	1);
	set_cmt	(0X7322,	"_$P_No_Error ; assume no error",	0);
	set_cmt	(0X7329,	"do process",	0);
	set_cmt	(0X732C,	"_$P_Syntax ; if error, examine the next type",	0);
	set_cmt	(0X7334,	"_$P_SNum_Val ; Signed numeric value",	0);
	create_insn	(x=0X7334);
	op_hex		(x,	1);
	set_name	(0X7334,	"_$P_Match04");
	set_cmt	(0X7339,	"_$P_No_Error ; assume no error",	0);
	set_cmt	(0X7340,	"do process",	0);
	set_cmt	(0X7343,	"_$P_Syntax ; if error, examine the next type",	0);
	set_cmt	(0X734B,	"_$P_Drv_Only ; Drive only",	0);
	create_insn	(x=0X734B);
	op_hex		(x,	1);
	set_cmt	(0X7350,	"_$P_No_Error ; assume no error",	0);
	set_cmt	(0X7357,	"1st, call file format",	0);
	set_cmt	(0X735A,	"check drive format, next",	0);
	set_cmt	(0X735D,	"_$P_Syntax ; if error, examine the next type",	0);
	set_cmt	(0X7365,	"_$P_File_Spc ; File spec",	0);
	create_insn	(x=0X7365);
	op_hex		(x,	1);
	set_cmt	(0X736A,	"_$P_No_Error ; assume no error",	0);
	set_cmt	(0X7371,	"do process",	0);
	set_cmt	(0X7374,	"_$P_Syntax ; if error, examine the next type",	0);
	set_cmt	(0X737C,	"_$P_Simple_S ; Simple string",	0);
	create_insn	(x=0X737C);
	op_hex		(x,	1);
	set_cmt	(0X7381,	"_$P_No_Error ; assume no error",	0);
	set_cmt	(0X7388,	"do process",	0);
	set_cmt	(0X738B,	"_$P_error_filespec ; bad filespec ?",	0);
	set_cmt	(0X7391,	"no, continue",	0);
	set_cmt	(0X7393,	"_$P_No_Error ; check for other errors ?",	0);
	set_cmt	(0X7399,	"no, continue",	0);
	set_cmt	(0X739B,	"_$P_Syntax ; set error flag",	0);
	create_insn	(0X73A4);
	set_name	(0X73A4,	"_$P_Remove_Colon");
	set_cmt	(0X73A6,	"get character",	0);
	set_cmt	(0X73A9,	"end of string ?",	0);
	set_cmt	(0X73AB,	"if yes, just exit",	0);
	set_cmt	(0X73AD,	"_$P_Colon ; is it colon ?",	0);
	create_insn	(x=0X73AD);
	op_chr		(x,	1);
	set_cmt	(0X73B1,	"_$P_NULL\nif so, next is NULL ?",	0);
	set_cmt	(0X73B6,	"no, then next char",	0);
	set_cmt	(0X73B8,	"_$P_NULL ; yes, remove colon",	0);
	set_cmt	(0X73BC,	"and exit.",	0);
	set_cmt	(0X73BE,	"if not colon, then check if\nDBCS leading byte.",	0);
	create_insn	(0X73BE);
	set_cmt	(0X73C3,	"if yes, skip trailing byte",	0);
	set_cmt	(0X73C4,	"si points to next byte",	0);
	set_cmt	(0X73C5,	"loop until NULL encountered",	0);
	create_insn	(0X73C7);
	create_insn	(0X73CA);
	set_name	(0X73CA,	"_$P_Do_CAPS_String");
	set_cmt	(0X73CC,	"save info id",	0);
	set_cmt	(0X73CE,	"load charater and",	0);
	set_cmt	(0X73D1,	"check if DBCS leading byte",	0);
	set_cmt	(0X73D4,	"if yes, do not need CAPS",	0);
	set_cmt	(0X73D6,	"end of string ?",	0);
	set_cmt	(0X73D8,	"then exit.",	0);
	set_cmt	(0X73DA,	"Here a SBCS char need to be CAPS",	0);
	set_cmt	(0X73DD,	"stored upper case char to buffer",	0);
	set_cmt	(0X73E0,	"process next",	0);
	set_cmt	(0X73E2,	"skip DBCS leading and trailing byte",	0);
	create_insn	(0X73E2);
	set_cmt	(0X73E3,	"si points to next byte",	0);
	set_cmt	(0X73E4,	"loop until NULL encountered",	0);
	create_insn	(0X73E6);
	set_cmt	(0X73E9,	"_$P_ASCII80 ; need upper case table ?",	0);
	create_insn	(0X73E9);
	set_name	(0X73E9,	"_$P_Do_CAPS_Char");
	set_cmt	(0X73EB,	"no",	0);
	set_cmt	(0X73ED,	"check if  \"a\" <= AL <= \"z\"",	0);
	create_insn	(x=0X73ED);
	op_chr		(x,	1);
	create_insn	(x=0X73F1);
	op_chr		(x,	1);
	set_cmt	(0X73F5,	"_$P_Make_Upper ; make CAPS",	0);
	create_insn	(x=0X73F5);
	op_hex		(x,	1);
	create_insn	(0X73F8);
	set_cmt	(0X73FB,	"or use char CAPS table ?",	0);
	create_insn	(x=0X73FB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X73FF,	"already got table address ?",	0);
	set_cmt	(0X7402,	"no",	0);
	set_cmt	(0X740A,	"_$P_DOS_Get_TBL",	0);
	create_insn	(x=0X740A);
	op_hex		(x,	1);
	set_cmt	(0X740C,	"_$P_DOSTBL_Def = -1",	0);
	set_cmt	(0X740F,	"_$P_DOSTBL_BL",	0);
	set_cmt	(0X7412,	"_$P_DOSTBL_Def",	0);
	set_cmt	(0X7414,	"DOS - 4.x internal\nCOUNTRY-DEPENDENT FILENAME CAPITALIZATION\nAL = function -\n\nDI already set to point to buffer",	0);
	create_insn	(x=0X7414);
	op_hex		(x,	0);
	set_cmt	(0X7419,	"bx = [cs:di+_$P_DOS_TBL.Off] ; [cs:di+1]\nes = [cs:di+_$P_DOS_TBL.Seg] ; [cs:di+3]",	0);
	set_cmt	(0X741E,	"add 2 to bx reg",	0);
	set_cmt	(0X741F,	"_$P_ASCII80 ; make char to index",	0);
	set_cmt	(0X7421,	"perform case map",	0);
	create_insn	(0X7427);
	set_name	(0X7427,	"_$P_SValue");
	set_cmt	(0X7428,	"_$P_Signed ; indicate a signed numeric",	0);
	create_insn	(x=0X7428);
	op_hex		(x,	1);
	set_cmt	(0X742E,	"0FFh-_$P_Neg ; assume positive value\nand byte [cs:$_Flags2],~_$P_Neg ; ~2",	0);
	create_insn	(x=0X742E);
	op_hex		(x,	1);
	set_cmt	(0X7434,	"get sign",	0);
	set_cmt	(0X7437,	"_$P_Plus",	0);
	create_insn	(x=0X7437);
	op_chr		(x,	1);
	set_cmt	(0X743B,	"_$P_Minus",	0);
	create_insn	(x=0X743B);
	op_chr		(x,	1);
	set_cmt	(0X743F,	"_$P_Neg\nset this is negative value",	0);
	create_insn	(x=0X743F);
	op_hex		(x,	1);
	set_cmt	(0X7445,	"skip sign char",	0);
	set_cmt	(0X7446,	"and process value",	0);
	create_insn	(0X744B);
	set_name	(0X744B,	"_$P_Value");
	set_cmt	(0X744F,	"cx = higher 16 bits",	0);
	set_cmt	(0X7451,	"dx = lower 16 bits",	0);
	set_cmt	(0X7454,	"get character",	0);
	set_cmt	(0X7457,	"end of line ?",	0);
	set_cmt	(0X745B,	"make asc(0..9) to bin(0..9)",	0);
	set_cmt	(0X7462,	"save binary number",	0);
	set_cmt	(0X7464,	"multiply cx:dx by 2 and then check overflow",	0);
	set_cmt	(0X7467,	"ax:bx = 2*(cx:dx)",	0);
	set_cmt	(0X746B,	"multiply cx:dx by 2 and then check overflow",	0);
	set_cmt	(0X746E,	"multiply cx:dx by 2 and then check overflow",	0);
	set_cmt	(0X7471,	"8*(cx:dx)+2*(cx:dx) = 10*(cx:dx)",	0);
	set_cmt	(0X7478,	"Add the current one degree decimal\nif carry, add 1 to high 16bit",	0);
	set_cmt	(0X747D,	"Overflow occurred ?\nthen error, exit (without return here)",	0);
	set_cmt	(0X7480,	"update pointer",	0);
	set_cmt	(0X7483,	"to have 2*x",	0);
	create_insn	(x=0X7483);
	op_hex		(x,	1);
	set_cmt	(0X7485,	"shift left w/ carry",	0);
	create_insn	(x=0X7485);
	op_hex		(x,	1);
	set_cmt	(0X7487,	"check overflow (for the last shift or add)",	0);
	set_cmt	(0X748D,	"skip \"call\" return address to the caller",	0);
	create_insn	(0X748D);
	set_cmt	(0X7490,	"bridge",	0);
	set_cmt	(0X7493,	"restore control pointer\nhere cx,dx = 32bit value",	0);
	create_insn	(0X7493);
	set_name	(0X7493,	"_$P_Value00");
	set_cmt	(0X7494,	"_$P_Neg ; was it negative ?",	0);
	create_insn	(x=0X7494);
	op_hex		(x,	1);
	set_cmt	(0X749C,	"| Make 2's complement",	0);
	set_cmt	(0X749E,	"|",	0);
	set_cmt	(0X74A0,	"|",	0);
	set_cmt	(0X74A3,	"|",	0);
	set_cmt	(0X74A6,	"[es:bx+_$P_Control_Blk.Value_List]\nsi points to value list",	0);
	set_cmt	(0X74AA,	"get nval",	0);
	set_cmt	(0X74AD,	"_$P_nval_None ; no value list ?",	0);
	set_cmt	(0X74B1,	"(_$P_No_Tag<<8)|_$P_Number\nNo ITEM_TAG set",	0);
	create_insn	(0X74B6);
	set_cmt	(0X74B8,	"al = number of range",	0);
	set_cmt	(0X74BB,	"_$P_No_nrng",	0);
	set_cmt	(0X74BD,	"_$P_Value03",	0);
	set_cmt	(0X74BF,	"si points to 1st item_tag",	0);
	set_cmt	(0X74C0,	"_$P_Signed",	0);
	create_insn	(x=0X74C0);
	op_hex		(x,	1);
	set_cmt	(0X74C8,	"[es:si+_$P_Val_List.Val_XH]\ncomp cx with XH",	0);
	set_cmt	(0X74D0,	"[es:si+_$P_Val_List.Val_XL]\ncomp dx with XL",	0);
	set_cmt	(0X74D6,	"[es:si+_$P_Val_List.Val_YH]\ncomp cx with YH",	0);
	set_cmt	(0X74DE,	"[es:si+_$P_Val_List.Val_YL]\ncomp dx with YL",	0);
	set_cmt	(0X74E6,	"[es:si+_$P_Val_List.Val_XH]\ncomp cx with XH",	0);
	create_insn	(0X74E6);
	set_cmt	(0X74EE,	"[es:si+_$P_Val_List.Val_XL]\ncomp dx with XL",	0);
	set_cmt	(0X74F4,	"[es:si+_$P_Val_List.Val_YH]\ncomp cx with YH",	0);
	set_cmt	(0X74FC,	"[es:si+_$P_Val_List.Val_YL]\ncomp dx with YL",	0);
	set_cmt	(0X7504,	"_$P_Len_Range",	0);
	create_insn	(0X7504);
	set_cmt	(0X7507,	"loop nrng times in AL",	0);
	set_cmt	(0X750B,	"_$P_Out_Of_Range",	0);
	set_cmt	(0X7512,	"(_$P_No_Tag<<8)|_$P_Number",	0);
	set_cmt	(0X7517,	"_$P_Number",	0);
	create_insn	(0X7517);
	set_cmt	(0X7519,	"found ITEM_TAG set",	0);
	set_cmt	(0X751E,	"_$P_Syntax",	0);
	create_insn	(0X751E);
	set_cmt	(0X7525,	"(_$P_No_Tag<<8)|_$P_String\nNo ITEM_TAG set",	0);
	create_insn	(0X7530);
	set_name	(0X7530,	"_$P_Check_OVF");
	set_cmt	(0X7531,	"_$P_Neg ; is it negative value ?",	0);
	create_insn	(x=0X7531);
	op_hex		(x,	1);
	set_cmt	(0X7539,	"if no, check overflow by the CY bit",	0);
	set_cmt	(0X753B,	"else, check overflow by the OF",	0);
	create_insn	(0X753B);
	set_cmt	(0X753E,	"indicate it with CY bit\nCY=0 means no overflow",	0);
	set_cmt	(0X7540,	"and CY=1 means overflow",	0);
	create_insn	(0X7540);
	set_cmt	(0X7542,	"must be 0 =< al =< 9",	0);
	create_insn	(x=0X7542);
	op_chr		(x,	1);
	set_name	(0X7542,	"_$P_0099");
	create_insn	(x=0X7546);
	op_chr		(x,	1);
	set_cmt	(0X754A,	"sub al,30h ; make char -> bin",	0);
	create_insn	(x=0X754A);
	op_chr		(x,	1);
	set_cmt	(0X754C,	"indicate no error\n(clc is not required here, cf=0)",	0);
	set_cmt	(0X754E,	"indicate error (cf=1)",	0);
	create_insn	(0X754E);
	create_insn	(0X7550);
	set_name	(0X7550,	"_$P_Simple_String");
	set_cmt	(0X7554,	"[es:bx+_$P_Control_Blk.Value_List]\ndi points to value list",	0);
	set_cmt	(0X7558,	"get nval",	0);
	set_cmt	(0X755B,	"no value list ?",	0);
	set_cmt	(0X755F,	"_$P_No_Tag ; then, No ITEM_TAG set",	0);
	set_cmt	(0X7561,	"and set result buffer",	0);
	set_cmt	(0X7563,	"Check if keyword or value list id #3 is supported\n_$P_nval_String ; String choice list provided ?",	0);
	create_insn	(0X7563);
	set_cmt	(0X7565,	"if no, syntax error",	0);
	set_cmt	(0X7568,	"al = nrng",	0);
	set_cmt	(0X756B,	"_$P_Len_Range",	0);
	set_cmt	(0X756D,	"Skip nrng field",	0);
	set_cmt	(0X756F,	"ax = (nrng*9)+1",	0);
	set_cmt	(0X7570,	"di points to nnval",	0);
	set_cmt	(0X7572,	"get nnval",	0);
	set_cmt	(0X7575,	"_$P_Len_Value",	0);
	set_cmt	(0X7577,	"skip nnval field",	0);
	set_cmt	(0X7579,	"ax = (nnval*5)+1",	0);
	set_cmt	(0X757A,	"di points to nstrval",	0);
	set_cmt	(0X757C,	"get nstrval c",	0);
	set_cmt	(0X7580,	"add '2' to di reg\ndi points to 1st string in list",	0);
	set_cmt	(0X7581,	"get string pointer",	0);
	set_cmt	(0X7584,	"compare it with operand",	0);
	set_cmt	(0X7587,	"found on list",	0);
	set_cmt	(0X7589,	"_$P_Len_String ; if no, point to next choice",	0);
	set_cmt	(0X758C,	"loop nstval times in AL",	0);
	set_cmt	(0X7590,	"/ Not found ; _$P_Not_In_Str",	0);
	set_cmt	(0X7597,	"_$P_No_Tag  ; No ITEM_TAG set",	0);
	set_cmt	(0X759B,	"set item_tag",	0);
	create_insn	(0X759B);
	set_cmt	(0X759F,	"_$P_List_Idx",	0);
	set_cmt	(0X75A1,	"get address of STRING",	0);
	set_cmt	(0X75A6,	"_$P_Syntax",	0);
	create_insn	(0X75A6);
	set_cmt	(0X75AD,	"_$P_No_Tag",	0);
	set_cmt	(0X75AF,	"_$P_String ; Set type",	0);
	create_insn	(0X75B9);
	set_name	(0X75B9,	"_$P_String_Comp");
	set_cmt	(0X75BD,	"_$P_DOSTBL_Char ; use character case map table",	0);
	set_cmt	(0X75BF,	"get command character",	0);
	set_cmt	(0X75C2,	"DBCS ?",	0);
	set_cmt	(0X75C5,	"yes",	0);
	set_cmt	(0X75C7,	"else, upper case map before comparison",	0);
	set_cmt	(0X75CA,	"Check if keyword or switch is supported\n_$P_Key_Cmp ; keyword search ?",	0);
	create_insn	(x=0X75CA);
	op_hex		(x,	1);
	set_cmt	(0X75D2,	"_$P_Keyword  ; \"=\" is delimiter",	0);
	create_insn	(x=0X75D2);
	op_chr		(x,	1);
	set_cmt	(0X75D4,	"IF \"=\" on command line AND \n(bp+1=> char after the \"=\" in synonym list)",	0);
	set_cmt	(0X75D6,	"_$P_NULL ; at end of keyword string \n                 in the control block THEN",	0);
	set_cmt	(0X75DD,	"keyword found in synonym list",	0);
	set_cmt	(0X75DF,	"_$P_SW_Cmp ; switch search ?",	0);
	create_insn	(x=0X75DF);
	op_hex		(x,	1);
	set_cmt	(0X75E7,	"_$P_Colon ; \":\" is delimiter, \n           at end of switch on command line",	0);
	create_insn	(x=0X75E7);
	op_chr		(x,	1);
	set_cmt	(0X75EB,	"_$P_NULL\nIF at end of switch on command AND",	0);
	set_cmt	(0X75F0,	"\nat end of switch string \nin the control block THEN",	0);
	set_cmt	(0X75F2,	"found a match\nsi points to just after \"=\" or \":\"",	0);
	set_cmt	(0X75F3,	"exit",	0);
	set_cmt	(0X75F5,	"compare operand w/ a synonym",	0);
	create_insn	(0X75F5);
	set_cmt	(0X75F9,	"if different, \ncheck ignore colon option",	0);
	set_cmt	(0X75FB,	"end of line ?",	0);
	set_cmt	(0X75FD,	"if so, exit",	0);
	set_cmt	(0X75FF,	"update operand pointer",	0);
	set_cmt	(0X7600,	"and synonym pointer",	0);
	set_cmt	(0X7601,	"loop until NULL or \"=\" or \":\"\n found in case",	0);
	set_cmt	(0X7603,	"Here al is DBCS leading byte\ncompare leading byte",	0);
	create_insn	(0X7603);
	set_cmt	(0X7607,	"if not match, say different",	0);
	set_cmt	(0X7609,	"else, load next byte",	0);
	set_cmt	(0X760E,	"and compare 2nd byte",	0);
	set_cmt	(0X7612,	"if not match, say different, too",	0);
	set_cmt	(0X7614,	"else update operand pointer",	0);
	set_cmt	(0X7615,	"and synonym pointer",	0);
	set_cmt	(0X7616,	"loop until NULL or \"=\" \nor \"/\" found in case",	0);
	set_cmt	(0X7618,	"_$P_SW",	0);
	create_insn	(x=0X7618);
	op_hex		(x,	1);
	set_cmt	(0X7620,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_colon_is_not_necessary",	0);
	create_insn	(x=0X7620);
	op_hex		(x,	1);
	set_cmt	(0X7628,	"_$P_NULL",	0);
	set_cmt	(0X762F,	"[es:bx+_$P_Control_Blk.Match_Flag],\n_$P_Ig_Colon \nignore colon option specified ?",	0);
	create_insn	(x=0X762F);
	op_hex		(x,	1);
	set_cmt	(0X7636,	"_$P_Colon ; End up with \":\" and subseqently",	0);
	create_insn	(x=0X7636);
	op_chr		(x,	1);
	set_cmt	(0X763A,	"_$P_NULL ; null ?",	0);
	set_cmt	(0X763F,	"if no, say different",	0);
	set_cmt	(0X7641,	"else, say same",	0);
	set_cmt	(0X7643,	"_$P_NULL ; end up NULL and :",	0);
	create_insn	(0X7643);
	set_cmt	(0X7647,	"_$P_Colon ; if no, say different",	0);
	create_insn	(x=0X7647);
	op_chr		(x,	1);
	set_cmt	(0X764C,	"else, say same",	0);
	set_cmt	(0X764E,	"indicate not found",	0);
	set_cmt	(0X7651,	"for later use by keyword or switch",	0);
	create_insn	(0X7651);
	set_cmt	(0X7656,	"indicate found\n(cf is already 0 here.. clc is not needed)",	0);
	create_insn	(0X765C);
	set_name	(0X765C,	"_$P_File_Format");
	set_cmt	(0X765F,	"get user buffer address",	0);
	set_cmt	(0X7664,	"/ skip special characters\nload character",	0);
	set_name	(0X7664,	"_$P_FileF_Loop0");
	set_cmt	(0X7667,	"end of line ?",	0);
	set_cmt	(0X7669,	"if yes, error exit",	0);
	set_cmt	(0X766B,	"else, check if file special character",	0);
	set_cmt	(0X7670,	"$P_error_filespec\nset error flag - bad char.",	0);
	set_cmt	(0X7677,	"_$P_NULL",	0);
	create_insn	(0X767E);
	set_cmt	(0X767F,	"_$P_NULL",	0);
	set_cmt	(0X7684,	"[es:bx+_$P_Control_Blk.Match_Flag],\n_$P_Optional",	0);
	create_insn	(x=0X7684);
	op_hex		(x,	1);
	set_cmt	(0X768B,	"_$P_Op_Missing",	0);
	set_cmt	(0X7694,	"discard si on top of stack",	0);
	create_insn	(0X7694);
	set_cmt	(0X7695,	"save new si",	0);
	set_cmt	(0X7696,	"load character (not special char)",	0);
	set_cmt	(0X7699,	"end of line ?",	0);
	set_cmt	(0X769D,	"File special character ?",	0);
	set_cmt	(0X76A2,	"no, then DBCS ?",	0);
	set_cmt	(0X76A7,	"if yes, skip next byte",	0);
	create_insn	(0X76AD);
	set_cmt	(0X76B1,	"_$P_NULL ; update end of string",	0);
	set_cmt	(0X76B6,	"update next pointer in command line",	0);
	set_cmt	(0X76BE,	"_$P_File_Spc",	0);
	create_insn	(x=0X76BE);
	op_hex		(x,	1);
	set_cmt	(0X76C4,	"(_$P_No_Tag<<8)|_$P_File_Spec\nset result buffer to file spec",	0);
	create_insn	(0X76CC);
	set_name	(0X76CC,	"_$P_FileSp_Chk");
	create_insn	(x=0X76CE);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X76D2,	"_$P_FileSp_Len\nload length of special character table\nat SYSINIT:1CFEh (for PCDOS 7.1 IBMBIO.COM)",	0);
	set_cmt	(0X76D5,	"is it one of special character ?",	0);
	set_cmt	(0X76DD,	"reset ZF",	0);
	create_insn	(0X76E1);
	set_name	(0X76E1,	"_$P_Drive_Format");
	set_cmt	(0X76E6,	"if null string",	0);
	set_cmt	(0X76E8,	"do nothing",	0);
	set_cmt	(0X76EA,	"is it leading byte ?",	0);
	set_cmt	(0X76ED,	"yes, error",	0);
	set_cmt	(0X76EF,	"_$P_Colon\n\"d\", \":\", 0 ?",	0);
	set_cmt	(0X76F6,	"[es:bx+_$P_Control_Blk.Match_Flag],\n_$P_Ig_Colon\ncolon can be ignored?",	0);
	create_insn	(x=0X76F6);
	op_hex		(x,	1);
	set_cmt	(0X76FD,	"_$P_NULL ; \"d\", 0 ?",	0);
	set_cmt	(0X7704,	"_$P_Make_Lower ; lower case",	0);
	create_insn	(x=0X7704);
	op_hex		(x,	1);
	set_cmt	(0X7706,	"drive letter must",	0);
	set_cmt	(0X7708,	"in range of",	0);
	set_cmt	(0X770A,	"\"a\"-\"z\"",	0);
	set_cmt	(0X770C,	"if no, error",	0);
	set_cmt	(0X770E,	"\"a\"-1 ; make text drive to binary drive",	0);
	create_insn	(x=0X770E);
	op_hex		(x,	1);
	set_cmt	(0X7712,	"_$P_No_Tag",	0);
	set_cmt	(0X7714,	"_$P_Drive\nmov ax,(_$P_No_Tag<<8)|_$P_Drive ; 0FF06h",	0);
	set_cmt	(0X7716,	"set result buffer to drive",	0);
	set_cmt	(0X771B,	"_$P_Syntax",	0);
	create_insn	(0X771B);
	create_insn	(0X7725);
	set_name	(0X7725,	"_$P_Skip_Delim");
	set_cmt	(0X7726,	"is it EOL character ?",	0);
	set_cmt	(0X7729,	"if yes, exit w/ CY on",	0);
	set_cmt	(0X772B,	"is it one of delimiters ?",	0);
	set_cmt	(0X772E,	"if no, exit w/ CY off",	0);
	set_cmt	(0X7730,	"_$P_Extra ; extra delim or comma found",	0);
	create_insn	(x=0X7730);
	op_hex		(x,	1);
	set_cmt	(0X7736,	"_$P_Skip_Delim_Loop\nif no, loop",	0);
	set_cmt	(0X7738,	"_$P_SW+_$P_equ ; /x , or xxx=zzz ,",	0);
	create_insn	(x=0X7738);
	op_hex		(x,	1);
	set_cmt	(0X773E,	"no switch, no keyword",	0);
	set_cmt	(0X7743,	"indicate EOL",	0);
	create_insn	(0X7743);
	set_cmt	(0X7746,	"indicate non delim",	0);
	create_insn	(0X7746);
	set_cmt	(0X7747,	"in this case, need backup index pointer",	0);
	set_cmt	(0X7749,	"indicate extra delim",	0);
	create_insn	(0X7749);
	create_insn	(0X774B);
	set_name	(0X774B,	"_$P_Chk_EOL");
	set_cmt	(0X774D,	"_$P_CR ; Carriage return ?",	0);
	set_cmt	(0X7751,	"_$P_NULL ; zero ?",	0);
	set_cmt	(0X7755,	"_$P_LF ; Line feed ?",	0);
	set_cmt	(0X7759,	"[es:di+_$P_PARMS_Blk.Num_Extra],\n_$P_I_Have_EOL",	0);
	set_cmt	(0X7762,	"[es:di+_$P_PARMS_Blk.Len_Extra_Delim]\nget length of delimiter list",	0);
	set_cmt	(0X7766,	"_$P_Len_PARMS ; skip it",	0);
	set_cmt	(0X7769,	"_$P_I_Use_Default\nNo extra EOL character ?",	0);
	set_cmt	(0X776F,	"Get number of extra character",	0);
	set_cmt	(0X7775,	"Check extra EOL character",	0);
	set_cmt	(0X777C,	"_$P_CR ; reset ZF",	0);
	create_insn	(0X7781);
	set_name	(0X7781,	"_$P_Chk_Delim");
	set_cmt	(0X7783,	"_$P_Space \nassume terminated by space",	0);
	set_cmt	(0X7789,	"0FFh-_$P_Extra ; ~$P_Extra ; ~20h",	0);
	create_insn	(x=0X7789);
	op_hex		(x,	1);
	set_cmt	(0X778F,	"_$P_Space ; Space ?",	0);
	set_cmt	(0X7793,	"_$P_TAB ; TAB ?",	0);
	set_cmt	(0X7797,	"_$P_Comma ; Comma ?",	0);
	set_cmt	(0X779B,	"Note: _$P_Chk_Delim00 part of code is nonsense\n      here because _$P_Space = _$P_DBSP1 = 20h\n      Erdogan Tan - 08/07/2023\n\n_$P_DBSP1 ; 1st byte of DBCS Space ?",	0);
	set_name	(0X779B,	"_$P_Chk_Delim00");
	set_cmt	(0X779F,	"_$P_DBSP2 ; 2nd byte of DBCS Space ?",	0);
	set_cmt	(0X77A4,	"_$P_Space",	0);
	set_cmt	(0X77A6,	"make si point to next character",	0);
	set_cmt	(0X77A7,	"Set ZF",	0);
	set_cmt	(0X77AB,	"[es:di-_$P_PARMS_Blk.Num_Extra],\n_$P_I_Have_Delim \ndelimiter character specified ?",	0);
	create_insn	(0X77AB);
	set_cmt	(0X77B0,	"no",	0);
	set_cmt	(0X77B4,	"[es:di+_$P_PARMS_Blk.Len_Extra_Delim] \nget length of delimiter list",	0);
	set_cmt	(0X77B8,	"no extra delim character",	0);
	set_cmt	(0X77BA,	"_$P_Len_PARMS-1\nset bx to 1st extra delimiter",	0);
	set_cmt	(0X77BE,	"check extra delim character",	0);
	set_cmt	(0X77C3,	"examine all extra delimiter",	0);
	set_cmt	(0X77C5,	"_$P_Space ; reset ZF",	0);
	set_cmt	(0X77CA,	"keep terminated delimiter",	0);
	create_insn	(0X77CA);
	set_cmt	(0X77CE,	"_$P_equ ; if terminating a key=",	0);
	create_insn	(x=0X77CE);
	op_hex		(x,	1);
	set_cmt	(0X77D4,	"then do not set the EXTRA bit",	0);
	set_cmt	(0X77D6,	"_$P_Extra \nflag terminated extra delim or comma",	0);
	create_insn	(x=0X77D6);
	op_hex		(x,	1);
	set_cmt	(0X77DC,	"set ZF",	0);
	set_cmt	(0X77E0,	"BP = Offset of _$P_String_Buf\n(mov bp, offset _$P_STRING_BUF)",	0);
	create_insn	(x=0X77E0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X77E0,	"_$P_Chk_Switch");
	set_cmt	(0X77E4,	"IF not first char THEN",	0);
	set_cmt	(0X77E8,	"_$P_Switch ; see if a slash",	0);
	set_cmt	(0X77EC,	"not in first position and is slash",	0);
	set_cmt	(0X77EE,	"not a slash",	0);
	create_insn	(0X77EE);
	set_cmt	(0X77F0,	"_$P_Switch",	0);
	create_insn	(0X77F0);
	set_cmt	(0X77F2,	"not a slash",	0);
	set_cmt	(0X77F4,	"_$P_SW\ncould be valid switch,\nfirst char and is slash",	0);
	create_insn	(x=0X77F4);
	op_hex		(x,	1);
	set_cmt	(0X77FA,	"is first char in the buffer, ZF=0\n(CF=0 indicating first char)",	0);
	create_insn	(0X77FC);
	set_name	(0X77FC,	"_$P_Chk_DBCS");
	set_cmt	(0X77FF,	"already set ?",	0);
	set_cmt	(0X7805,	"yes",	0);
	set_cmt	(0X7812,	"_$P_DOS_GetEV ; GET DBCS EV CALL",	0);
	create_insn	(x=0X7812);
	op_hex		(x,	1);
	set_cmt	(0X7815,	"DOS - 3.2+ only\nGET DOUBLE BYTE CHARACTER SET LEAD TABLE",	0);
	create_insn	(x=0X7815);
	op_hex		(x,	0);
	set_cmt	(0X7824,	"save EV offset",	0);
	set_cmt	(0X7829,	"save EV segment",	0);
	set_cmt	(0X782E,	"load EV offset and segment",	0);
	set_cmt	(0X7833,	"zero vector ?",	0);
	set_cmt	(0X7836,	"then exit",	0);
	set_cmt	(0X7838,	"Check if AL is in range of the vector",	0);
	set_cmt	(0X7841,	"if yes, indicate DBCS and exit",	0);
	set_cmt	(0X7844,	"add 2 to si reg",	0);
	create_insn	(0X7844);
	set_cmt	(0X7845,	"get next vector",	0);
	set_cmt	(0X7846,	"loop until zero vector found",	0);
	set_cmt	(0X7848,	"indicate SBCS\n(note: cf is already 0 here)",	0);
	create_insn	(0X7848);
	set_cmt	(0X784D,	"buffer = [n | n,m] {/e}",	0);
	create_word	(x=0X784D);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X784D,	"buf_parms");
	set_cmt	(0X784F,	"an extra delimiter list",	0);
	create_byte	(0X784F);
	set_cmt	(0X7850,	"length is 1",	0);
	create_byte	(0X7850);
	set_cmt	(0X7851,	"delimiter",	0);
	create_byte	(x=0X7851);
	op_chr		(x,	0);
	create_byte	(0X7852);
	set_name	(0X7852,	"buf_parmsx");
	set_cmt	(0X7853,	"min 1, max 2 positionals",	0);
	create_byte	(0X7853);
	create_word	(x=0X7854);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7856);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7858,	"one switch",	0);
	create_byte	(0X7858);
	create_word	(x=0X7859);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X785B,	"no keywords\n\nbuf_pos1 p_pos <8000h,0,result_val,buf_range_1>\nnumeric",	0);
	create_byte	(0X785B);
	set_cmt	(0X785C,	"match_flags - numeric value",	0);
	create_word	(0X785C);
	set_name	(0X785C,	"buf_pos1");
	set_cmt	(0X785E,	"function flags",	0);
	create_word	(0X785E);
	set_cmt	(0X7860,	"result value buffer",	0);
	create_word	(x=0X7860);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7862,	"value list",	0);
	create_word	(x=0X7862);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7864,	"no switches/keywords",	0);
	create_byte	(0X7864);
	set_cmt	(0X7865,	"range definition",	0);
	create_byte	(0X7865);
	set_name	(0X7865,	"buf_range_1");
	set_cmt	(0X7866,	"1 definition of range",	0);
	create_byte	(0X7866);
	set_cmt	(0X7867,	"item tag for this range",	0);
	create_byte	(0X7867);
	set_cmt	(0X7868,	"numeric min",	0);
	create_dword	(0X7868);
	set_cmt	(0X786C,	"numeric max\n\nbuf_pos2 p_pos <8001h,0,result_val,buf_range_2>\noptional num.",	0);
	create_dword	(x=0X786C);
	op_dec		(x,	0);
	create_word	(0X7870);
	set_name	(0X7870,	"buf_pos2");
	create_word	(0X7872);
	create_word	(x=0X7874);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7876);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7878,	"\nbuf_range_2 p_range <,,,0,8>",	0);
	create_byte	(0X7878);
	create_byte	(0X7879);
	set_name	(0X7879,	"buf_range_2");
	create_byte	(0X787A);
	create_byte	(0X787B);
	create_dword	(0X787C);
	set_cmt	(0X7880,	"\nsw_x_ctrl p_pos <0,0,result_val,noval,1>\nfollowed by one switch",	0);
	create_dword	(0X7880);
	create_word	(0X7884);
	set_name	(0X7884,	"sw_x_ctrl");
	create_word	(0X7886);
	create_word	(x=0X7888);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X788A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X788C,	"1 switch",	0);
	create_byte	(0X788C);
	create_strlit	(0X788D,	0X7890);
	set_name	(0X788D,	"switch_x");
	create_word	(0X7890);
	set_name	(0X7890,	"p_buffers");
	create_word	(0X7892);
	set_name	(0X7892,	"p_h_buffers");
	set_cmt	(0X7894,	"\ncommon definitions",	0);
	create_byte	(0X7894);
	set_name	(0X7894,	"p_buffer_slash_x");
	create_byte	(0X7895);
	set_name	(0X7895,	"noval");
	set_cmt	(0X7896,	"type returned",	0);
	create_byte	(0X7896);
	set_name	(0X7896,	"result_val");
	set_cmt	(0X7897,	"item tag returned",	0);
	create_byte	(0X7897);
	set_name	(0X7897,	"result_val_itag");
	set_cmt	(0X7898,	"es:offset of the switch defined",	0);
	create_word	(0X7898);
	set_name	(0X7898,	"result_val_swoff");
	set_cmt	(0X789A,	"rv_byte\nvalue if number, or seg:offset to string.\n;;",	0);
	create_dword	(0X789A);
	set_name	(0X789A,	"rv_dword");
	set_cmt	(0X789E,	"break = [ on | off ]",	0);
	create_word	(x=0X789E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X789E,	"brk_parms");
	set_cmt	(0X78A0,	"an extra delimiter list",	0);
	create_byte	(0X78A0);
	set_cmt	(0X78A1,	"length is 1",	0);
	create_byte	(0X78A1);
	set_cmt	(0X78A2,	"delimiter",	0);
	create_byte	(x=0X78A2);
	op_chr		(x,	0);
	set_cmt	(0X78A3,	"min,max = 1 positional",	0);
	create_byte	(0X78A3);
	set_name	(0X78A3,	"brk_parmsx");
	create_byte	(0X78A4);
	create_word	(x=0X78A5);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X78A7,	"no switches",	0);
	create_byte	(0X78A7);
	set_cmt	(0X78A8,	"no keywords",	0);
	create_byte	(0X78A8);
	create_word	(0X78A9);
	set_name	(0X78A9,	"brk_pos");
	create_word	(0X78AB);
	create_word	(x=0X78AD);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X78AF);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X78B1);
	set_cmt	(0X78B2,	"signals that there is a string choice",	0);
	create_byte	(0X78B2);
	set_name	(0X78B2,	"on_off_string");
	set_cmt	(0X78B3,	"no range definition",	0);
	create_byte	(0X78B3);
	set_cmt	(0X78B4,	"no numeric values choice",	0);
	create_byte	(0X78B4);
	set_cmt	(0X78B5,	"2 strings for choice",	0);
	create_byte	(0X78B5);
	set_cmt	(0X78B6,	"the 1st string tag",	0);
	create_byte	(0X78B6);
	create_word	(x=0X78B7);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X78B9,	"the 2nd string tag",	0);
	create_byte	(0X78B9);
	create_word	(x=0X78BA);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_strlit	(0X78BC,	0X78BF);
	set_name	(0X78BC,	"_on_string");
	create_strlit	(0X78BF,	0X78C3);
	set_name	(0X78BF,	"_off_string");
	set_cmt	(0X78C3,	"local variable\n;;",	0);
	create_byte	(0X78C3);
	set_name	(0X78C3,	"p_ctrl_break");
	set_cmt	(0X78C4,	"country = n {m {path}} \nor country = n,,path",	0);
	create_word	(x=0X78C4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X78C4,	"cntry_parms");
	create_byte	(0X78C6);
	create_byte	(0X78C7);
	create_byte	(x=0X78C8);
	op_chr		(x,	0);
	set_cmt	(0X78C9,	"min 1, max 3 pos.",	0);
	create_byte	(0X78C9);
	set_name	(0X78C9,	"cntry_parmsx");
	create_byte	(0X78CA);
	create_word	(x=0X78CB);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X78CD);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X78CF);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X78D1,	"no switches",	0);
	create_byte	(0X78D1);
	set_cmt	(0X78D2,	"no keywords",	0);
	create_byte	(0X78D2);
	set_cmt	(0X78D3,	"cntry_pos1 p_pos <8000h,0,result_val,cc_range>\nnumeric value",	0);
	create_word	(0X78D3);
	set_name	(0X78D3,	"cntry_pos1");
	create_word	(0X78D5);
	create_word	(x=0X78D7);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X78D9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X78DB);
	set_cmt	(0X78DC,	"cc_range p_range <,,,1,999>",	0);
	create_byte	(0X78DC);
	set_name	(0X78DC,	"cc_range");
	create_byte	(0X78DD);
	create_byte	(0X78DE);
	create_dword	(0X78DF);
	create_dword	(x=0X78E3);
	op_dec		(x,	0);
	set_cmt	(0X78E7,	"cntry_pos2 p_pos <8001h,0,result_val,cc_range>\noptional num.",	0);
	create_word	(0X78E7);
	set_name	(0X78E7,	"cntry_pos2");
	create_word	(0X78E9);
	create_word	(x=0X78EB);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X78ED);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X78EF);
	set_cmt	(0X78F0,	"cntry_pos3 p_pos <201h,0,result_val,noval>\noptional filespec",	0);
	create_word	(0X78F0);
	set_name	(0X78F0,	"cntry_pos3");
	create_word	(0X78F2);
	create_word	(x=0X78F4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X78F6);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X78F8);
	set_cmt	(0X78F9,	"local variable",	0);
	create_word	(0X78F9);
	set_name	(0X78F9,	"p_cntry_code");
	set_cmt	(0X78FB,	"local variable\n;;",	0);
	create_word	(0X78FB);
	set_name	(0X78FB,	"p_code_page");
	set_cmt	(0X78FD,	"files = n",	0);
	create_word	(x=0X78FD);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X78FD,	"files_parms");
	create_byte	(0X78FF);
	create_byte	(0X7900);
	create_byte	(x=0X7901);
	op_chr		(x,	0);
	create_byte	(0X7902);
	set_name	(0X7902,	"files_parmsx");
	set_cmt	(0X7903,	"min,max 1 positional",	0);
	create_byte	(0X7903);
	create_word	(x=0X7904);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7906,	"no switches",	0);
	create_byte	(0X7906);
	set_cmt	(0X7907,	"no keywords",	0);
	create_byte	(0X7907);
	set_cmt	(0X7908,	"files_pos p_pos <8000h,0,result_val,files_range,0>\nnumeric value",	0);
	create_word	(0X7908);
	set_name	(0X7908,	"files_pos");
	create_word	(0X790A);
	create_word	(x=0X790C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X790E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7910);
	set_cmt	(0X7911,	"files_range p_range <,,,8,255>",	0);
	create_byte	(0X7911);
	set_name	(0X7911,	"files_range");
	create_byte	(0X7912);
	create_byte	(0X7913);
	create_dword	(0X7914);
	create_dword	(x=0X7918);
	op_dec		(x,	0);
	set_cmt	(0X791C,	"local variable\n;;",	0);
	create_byte	(0X791C);
	set_name	(0X791C,	"p_files");
	set_cmt	(0X791D,	"fcbs = n,m",	0);
	create_word	(x=0X791D);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X791D,	"fcbs_parms");
	create_byte	(0X791F);
	create_byte	(0X7920);
	create_byte	(x=0X7921);
	op_chr		(x,	0);
	create_byte	(0X7922);
	set_name	(0X7922,	"fcbs_parmsx");
	create_byte	(0X7923);
	create_word	(x=0X7924);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7926);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7928,	"no switches",	0);
	create_byte	(0X7928);
	set_cmt	(0X7929,	"no keywords",	0);
	create_byte	(0X7929);
	set_cmt	(0X792A,	"fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range>\nnumeric value",	0);
	create_word	(0X792A);
	set_name	(0X792A,	"fcbs_pos_1");
	create_word	(0X792C);
	create_word	(x=0X792E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7930);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7932);
	set_cmt	(0X7933,	"fcbs_range p_range <,,,1,255>",	0);
	create_byte	(0X7933);
	set_name	(0X7933,	"fcbs_range");
	create_byte	(0X7934);
	create_byte	(0X7935);
	create_dword	(0X7936);
	create_dword	(x=0X793A);
	op_dec		(x,	0);
	set_cmt	(0X793E,	"fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range>\nnumeric value",	0);
	create_word	(0X793E);
	set_name	(0X793E,	"fcbs_pos_2");
	create_word	(0X7940);
	create_word	(x=0X7942);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7944);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7946);
	set_cmt	(0X7947,	"fcbs_keep_range p_range <,,,0,255>",	0);
	create_byte	(0X7947);
	set_name	(0X7947,	"fcbs_keep_range");
	create_byte	(0X7948);
	create_byte	(0X7949);
	create_dword	(0X794A);
	create_dword	(x=0X794E);
	op_dec		(x,	0);
	set_cmt	(0X7952,	"local variable",	0);
	create_byte	(0X7952);
	set_name	(0X7952,	"p_fcbs");
	set_cmt	(0X7953,	"local variable\n;;",	0);
	create_byte	(0X7953);
	set_name	(0X7953,	"p_keep");
	set_cmt	(0X7954,	"lastdrive = x",	0);
	create_word	(x=0X7954);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X7954,	"ldrv_parms");
	create_byte	(0X7956);
	create_byte	(0X7957);
	create_byte	(x=0X7958);
	op_chr		(x,	0);
	create_byte	(0X7959);
	set_name	(0X7959,	"ldrv_parmsx");
	set_cmt	(0X795A,	"min,max = 1 positional",	0);
	create_byte	(0X795A);
	create_word	(x=0X795B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X795D,	"no switches",	0);
	create_byte	(0X795D);
	set_cmt	(0X795E,	"no keywords",	0);
	create_byte	(0X795E);
	set_cmt	(0X795F,	"ldrv_pos p_pos <110h,10h,result_val,noval>\ndrive only, ignore colon at end",	0);
	create_word	(x=0X795F);
	op_hex		(x,	0);
	set_name	(0X795F,	"ldrv_pos");
	create_word	(0X7961);
	create_word	(x=0X7963);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7965);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7967);
	set_cmt	(0X7968,	"local variable\n;;",	0);
	create_byte	(0X7968);
	set_name	(0X7968,	"p_ldrv");
	set_cmt	(0X7969,	"stacks = n,m",	0);
	create_word	(x=0X7969);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X7969,	"stks_parms");
	create_byte	(0X796B);
	create_byte	(0X796C);
	create_byte	(x=0X796D);
	op_chr		(x,	0);
	create_byte	(0X796E);
	set_name	(0X796E,	"stks_parmsx");
	set_cmt	(0X796F,	"min,max = 2 positionals",	0);
	create_byte	(0X796F);
	create_word	(x=0X7970);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7972);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7974,	"no switches",	0);
	create_byte	(0X7974);
	set_cmt	(0X7975,	"no keywords",	0);
	create_byte	(0X7975);
	set_cmt	(0X7976,	"stks_pos_1 p_pos <8000h,0,result_val,stks_range>\nnumeric value",	0);
	create_word	(0X7976);
	set_name	(0X7976,	"stks_pos_1");
	create_word	(0X7978);
	create_word	(x=0X797A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X797C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X797E);
	set_cmt	(0X797F,	"stks_range p_range <,,,0,64>",	0);
	create_byte	(0X797F);
	set_name	(0X797F,	"stks_range");
	create_byte	(0X7980);
	create_byte	(0X7981);
	create_dword	(0X7982);
	create_dword	(x=0X7986);
	op_dec		(x,	0);
	set_cmt	(0X798A,	"stks_pos_2 p_pos <8000h,0,result_val,stk_size_range>\nnumeric value",	0);
	create_word	(0X798A);
	set_name	(0X798A,	"stks_pos_2");
	create_word	(0X798C);
	create_word	(x=0X798E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7990);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7992);
	set_cmt	(0X7993,	"stk_size_range p_range <,,,0,512>",	0);
	create_byte	(0X7993);
	set_name	(0X7993,	"stk_size_range");
	create_byte	(0X7994);
	create_byte	(0X7995);
	create_dword	(0X7996);
	create_dword	(x=0X799A);
	op_dec		(x,	0);
	set_cmt	(0X799E,	"local variable",	0);
	create_word	(0X799E);
	set_name	(0X799E,	"p_stack_count");
	set_cmt	(0X79A0,	"local variable\n;;",	0);
	create_word	(0X79A0);
	set_name	(0X79A0,	"p_stack_size");
	set_cmt	(0X79A2,	"multitrack = [ on | off ]",	0);
	create_word	(x=0X79A2);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X79A2,	"mtrk_parms");
	create_byte	(0X79A4);
	create_byte	(0X79A5);
	create_byte	(x=0X79A6);
	op_chr		(x,	0);
	set_cmt	(0X79A7,	"min,max = 1 positional",	0);
	create_byte	(0X79A7);
	set_name	(0X79A7,	"mtrk_parmsx");
	create_byte	(0X79A8);
	create_word	(x=0X79A9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79AB,	"no switches",	0);
	create_byte	(0X79AB);
	set_cmt	(0X79AC,	"no keywords",	0);
	create_byte	(0X79AC);
	set_cmt	(0X79AD,	"mtrk_pos p_pos <2000h,0,result_val,on_off_string>\nsimple string",	0);
	create_word	(0X79AD);
	set_name	(0X79AD,	"mtrk_pos");
	create_word	(0X79AF);
	create_word	(x=0X79B1);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X79B3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X79B5);
	set_cmt	(0X79B6,	"local variable\n;;",	0);
	create_byte	(0X79B6);
	set_name	(0X79B6,	"p_mtrk");
	set_cmt	(0X79B7,	"switches=/k",	0);
	create_word	(x=0X79B7);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X79B7,	"swit_parms");
	create_byte	(0X79B9);
	create_byte	(0X79BA);
	create_byte	(x=0X79BB);
	op_chr		(x,	0);
	set_cmt	(0X79BC,	"no positionals",	0);
	create_word	(0X79BC);
	set_name	(0X79BC,	"swit_parmsx");
	set_cmt	(0X79BE,	"# of switches (6 for PCDOS 7.1 IBMBIO.COM)\n (5 for MSDOS 6.21 IO.SYS)",	0);
	create_byte	(0X79BE);
	set_cmt	(0X79BF,	"/k control",	0);
	create_word	(x=0X79BF);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79C1,	"/n control (for MULTI_CONFIG only)",	0);
	create_word	(x=0X79C1);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79C3,	"/f control (for MULTI_CONFIG only)",	0);
	create_word	(x=0X79C3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79C5,	"/t control",	0);
	create_word	(x=0X79C5);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79C7,	"/w control",	0);
	create_word	(x=0X79C7);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79C9,	"/i control\n(6th switch for PCDOS 7.1 IBMBIO.COM)",	0);
	create_word	(x=0X79C9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X79CB,	"no keywords",	0);
	create_byte	(0X79CB);
	set_cmt	(0X79CC,	"swit_k_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows",	0);
	create_word	(0X79CC);
	set_name	(0X79CC,	"swit_k_ctrl");
	create_word	(0X79CE);
	create_word	(x=0X79D0);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X79D2);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X79D4);
	create_strlit	(0X79D5,	0X79D8);
	set_name	(0X79D5,	"swit_k");
	set_cmt	(0X79D8,	"swit_n_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows",	0);
	create_word	(0X79D8);
	set_name	(0X79D8,	"swit_n_ctrl");
	create_word	(0X79DA);
	create_word	(x=0X79DC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X79DE);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X79E0);
	create_strlit	(0X79E1,	0X79E4);
	set_name	(0X79E1,	"swit_n");
	set_cmt	(0X79E4,	"swit_f_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows",	0);
	create_word	(0X79E4);
	set_name	(0X79E4,	"swit_f_ctrl");
	create_word	(0X79E6);
	create_word	(x=0X79E8);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X79EA);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X79EC);
	create_strlit	(0X79ED,	0X79F0);
	set_name	(0X79ED,	"swit_f");
	set_cmt	(0X79F0,	"swit_t_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows",	0);
	create_word	(0X79F0);
	set_name	(0X79F0,	"swit_t_ctrl");
	create_word	(0X79F2);
	create_word	(x=0X79F4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X79F6);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X79F8);
	create_strlit	(0X79F9,	0X79FC);
	set_name	(0X79F9,	"swit_t");
	set_cmt	(0X79FC,	"swit_w_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows",	0);
	create_word	(0X79FC);
	set_name	(0X79FC,	"swit_w_ctrl");
	create_word	(0X79FE);
	create_word	(x=0X7A00);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A02);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A04);
	create_strlit	(0X7A05,	0X7A08);
	set_name	(0X7A05,	"swit_w");
	set_cmt	(0X7A08,	"swit_i_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows",	0);
	create_word	(0X7A08);
	set_name	(0X7A08,	"swit_i_ctrl");
	create_word	(0X7A0A);
	create_word	(x=0X7A0C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A0E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A10);
	create_strlit	(0X7A11,	0X7A14);
	set_name	(0X7A11,	"swit_i");
	set_cmt	(0X7A14,	"! (/C, /D, /E switches are not used) !\nErdogan Tan - 09/07/2023",	0);
	create_word	(0X7A14);
	set_name	(0X7A14,	"swit_c_ctrl");
	create_word	(0X7A16);
	create_word	(x=0X7A18);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A1A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A1C);
	create_strlit	(0X7A1D,	0X7A20);
	set_name	(0X7A1D,	"swit_c");
	create_word	(0X7A20);
	set_name	(0X7A20,	"swit_d_ctrl");
	create_word	(0X7A22);
	create_word	(x=0X7A24);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A26);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A28);
	create_strlit	(0X7A29,	0X7A2C);
	set_name	(0X7A29,	"swit_d");
	create_word	(0X7A2C);
	set_name	(0X7A2C,	"swit_e_ctrl");
	create_word	(0X7A2E);
	create_word	(x=0X7A30);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A32);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A34);
	create_strlit	(0X7A35,	0X7A38);
	set_name	(0X7A35,	"swit_e");
	create_byte	(0X7A38);
	create_byte	(0X7A39);
	create_byte	(0X7A3A);
	set_cmt	(0X7A3B,	"local variable",	0);
	create_byte	(0X7A3B);
	set_name	(0X7A3B,	"p_swit_k");
	set_cmt	(0X7A3C,	"local variable",	0);
	create_byte	(0X7A3C);
	set_name	(0X7A3C,	"p_swit_t");
	set_cmt	(0X7A3D,	"local variable",	0);
	create_byte	(0X7A3D);
	set_name	(0X7A3D,	"p_swit_w");
	set_cmt	(0X7A3E,	"local variable\n;;",	0);
	create_byte	(0X7A3E);
	set_name	(0X7A3E,	"p_swit_i");
	set_cmt	(0X7A3F,	"DOS = [ high | low ] \nDOS = HIGH|LOW[,UMB|,NOUMB]",	0);
	create_word	(x=0X7A3F);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X7A3F,	"dos_parms");
	create_byte	(0X7A41);
	create_byte	(0X7A42);
	create_byte	(x=0X7A43);
	op_chr		(x,	0);
	set_cmt	(0X7A44,	"min parameters",	0);
	create_byte	(0X7A44);
	set_name	(0X7A44,	"dos_parmsx");
	set_cmt	(0X7A45,	"max parameters",	0);
	create_byte	(0X7A45);
	create_word	(x=0X7A46);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A48);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7A4A,	"no switches",	0);
	create_byte	(0X7A4A);
	set_cmt	(0X7A4B,	"no keywords",	0);
	create_byte	(0X7A4B);
	create_word	(0X7A4C);
	set_name	(0X7A4C,	"dos_pos");
	create_word	(0X7A4E);
	create_word	(x=0X7A50);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A52);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A54);
	set_cmt	(0X7A55,	"dos_pos p_pos <2000h,0,result_val,dos_strings>\nsimple string\n(this is not needed) - E.TAN - 08/07/2023",	0);
	create_word	(0X7A55);
	set_name	(0X7A55,	"dos_pos2");
	create_word	(0X7A57);
	create_word	(x=0X7A59);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A5B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A5D);
	set_cmt	(0X7A5E,	"signals that there is a string choice",	0);
	create_byte	(0X7A5E);
	set_name	(0X7A5E,	"dos_strings");
	set_cmt	(0X7A5F,	"no range definition",	0);
	create_byte	(0X7A5F);
	set_cmt	(0X7A60,	"no numeric values choice",	0);
	create_byte	(0X7A60);
	set_cmt	(0X7A61,	"4 strings for choice",	0);
	create_byte	(0X7A61);
	set_cmt	(0X7A62,	"the 1st string tag",	0);
	create_byte	(0X7A62);
	create_word	(x=0X7A63);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7A65,	"the 2nd string tag",	0);
	create_byte	(0X7A65);
	create_word	(x=0X7A66);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A68);
	create_word	(x=0X7A69);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A6B);
	create_word	(x=0X7A6C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7A6E,	"DOSDATA = UMB|NOUMB",	0);
	create_word	(x=0X7A6E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X7A6E,	"dosdata_parms");
	create_byte	(0X7A70);
	create_byte	(0X7A71);
	create_byte	(x=0X7A72);
	op_chr		(x,	0);
	create_byte	(0X7A73);
	set_name	(0X7A73,	"dosdata_parmsx");
	set_cmt	(0X7A74,	"min,max = 1 positional",	0);
	create_byte	(0X7A74);
	create_word	(x=0X7A75);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7A77,	"no switches",	0);
	create_byte	(0X7A77);
	set_cmt	(0X7A78,	"no keywords",	0);
	create_byte	(0X7A78);
	set_cmt	(0X7A79,	"dosdata_pos p_pos <2000h,0,result_val,dosdata_strings>\nsimple string",	0);
	create_word	(0X7A79);
	set_name	(0X7A79,	"dosdata_pos");
	create_word	(0X7A7B);
	create_word	(x=0X7A7D);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_word	(x=0X7A7F);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_byte	(0X7A81);
	set_cmt	(0X7A82,	"signals that there is a string choice",	0);
	create_byte	(0X7A82);
	set_name	(0X7A82,	"dosdata_strings");
	set_cmt	(0X7A83,	"no range definition",	0);
	create_byte	(0X7A83);
	set_cmt	(0X7A84,	"no numeric values choice",	0);
	create_byte	(0X7A84);
	set_cmt	(0X7A85,	"4 strings for choice",	0);
	create_byte	(0X7A85);
	set_cmt	(0X7A86,	"the 1st string tag",	0);
	create_byte	(0X7A86);
	create_word	(x=0X7A87);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X7A89,	"the 2nd string tag",	0);
	create_byte	(0X7A89);
	create_word	(x=0X7A8A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_strlit	(0X7A8C,	0X7A91);
	set_name	(0X7A8C,	"hi_string");
	create_strlit	(0X7A91,	0X7A95);
	set_name	(0X7A91,	"lo_string");
	create_strlit	(0X7A95,	0X7A99);
	set_name	(0X7A95,	"umb_string");
	create_strlit	(0X7A99,	0X7A9F);
	set_name	(0X7A99,	"noumb_string");
	set_cmt	(0X7A9F,	"local variable (parser does not use this)",	0);
	create_byte	(0X7A9F);
	set_name	(0X7A9F,	"p_dos_hi");
	set_cmt	(0X7AA0,	"\nfor LoadHigh and DeviceHigh:\n   fInHigh  - Is set to 1 during HideUMBs(), and back to zero in\n              UnHideUMBs().\n   fUmbTiny - Is set to 1 iff the user has specified /S on the     \n              command line.\n   SegLoad  - Segment address for first UMB specified; set                        \n              automatically.\n   UmbLoad  - The load UMB number; for example, this is 3 if the  \n              user has given a command-line like \"/L:3,500;4\"\n   fm_umb   - Set to the old UMB link-state (0x80 or 0x00)\n   fm_strat - Set to the old memory-allocation strategy (0$00000???)\n   fm_argc  - Number of arguments received by ParseVar()",	0);
	create_byte	(0X7AA0);
	create_byte	(0X7AA1);
	set_name	(0X7AA1,	"fInHigh");
	create_byte	(0X7AA2);
	set_name	(0X7AA2,	"fUmbTiny");
	create_word	(0X7AA3);
	set_name	(0X7AA3,	"SegLoad");
	set_cmt	(0X7AA5,	"UmbUsed - An array of characters, each of which is 1 if the UMB\n          matching its index number was specified on the \n          command line;\n       for example, after \"/L:3,500;4;7\", UmbUsed[3],[4] & [7]\n       will be set to 1. All others will be set to 0.\nUmbSize - An array of words, each of which is interpereted as a   \n          size specified by the user for a UMB (in the above \n          example, all elements would be zero save UmbSize[3], \n          which would be 500.",	0);
	create_byte	(0X7AA5);
	set_name	(0X7AA5,	"UmbLoad");
	set_cmt	(0X7AA6,	"times MAXUMB db 0",	0);
	create_byte	(x=0X7AA6);
	make_array	(x,	0X10);
	op_dec		(x,	0);
	set_name	(0X7AA6,	"UmbUsed");
	set_cmt	(0X7AB6,	"times MAXUMB dw 0",	0);
	create_word	(x=0X7AB6);
	make_array	(x,	0X10);
	op_dec		(x,	0);
	set_name	(0X7AB6,	"UmbSize");
	create_byte	(0X7AD6);
	set_name	(0X7AD6,	"fm_umb");
	create_byte	(0X7AD7);
	set_name	(0X7AD7,	"fm_strat");
	create_byte	(0X7AD8);
	set_name	(0X7AD8,	"fm_argc");
	set_cmt	(0X7AD9,	"size of the device driver being loaded (paras)",	0);
	create_word	(0X7AD9);
	set_name	(0X7AD9,	"DevSize");
	set_cmt	(0X7ADB,	"Mem addr where the device driver is 2 b loaded",	0);
	create_word	(0X7ADB);
	set_name	(0X7ADB,	"DevLoadAddr");
	set_cmt	(0X7ADD,	"MaxAddr to which device can be loaded",	0);
	create_word	(0X7ADD);
	set_name	(0X7ADD,	"DevLoadEnd");
	set_cmt	(0X7ADF,	"Entry point to the device driver",	0);
	create_dword	(0X7ADF);
	set_name	(0X7ADF,	"DevEntry");
	set_cmt	(0X7AE3,	"Break address of the device driver",	0);
	create_dword	(0X7AE3);
	set_name	(0X7AE3,	"DevBrkAddr");
	set_cmt	(0X7AE7,	"Use conventional (dos 5 style) InitDevLoad?",	0);
	create_byte	(0X7AE7);
	set_name	(0X7AE7,	"ConvLoad");
	set_cmt	(0X7AE8,	"byte indicating whether to load DDs in UMBs",	0);
	create_byte	(0X7AE8);
	set_name	(0X7AE8,	"DevUMB");
	set_cmt	(0X7AE9,	"current UMB used for loading devices (paras)",	0);
	create_word	(0X7AE9);
	set_name	(0X7AE9,	"DevUMBAddr");
	set_cmt	(0X7AEB,	"Size of the current UMB being used (paras)",	0);
	create_word	(0X7AEB);
	set_name	(0X7AEB,	"DevUMBSize");
	set_cmt	(0X7AED,	"Start of free mem blk in the current UMB (paras)",	0);
	create_word	(0X7AED);
	set_name	(0X7AED,	"DevUMBFree");
	create_dword	(0X7AEF);
	set_name	(0X7AEF,	"DevXMSAddr");
	set_cmt	(0X7AF3,	"Device load address parameter to Exec call",	0);
	create_word	(0X7AF3);
	set_name	(0X7AF3,	"DevExecAddr");
	set_cmt	(0X7AF5,	"Device load relocation factor",	0);
	create_word	(0X7AF5);
	set_name	(0X7AF5,	"DevExecReloc");
	set_cmt	(0X7AF7,	"Flag indicating whether the current device\nis being loaded into UMB",	0);
	create_byte	(0X7AF7);
	set_name	(0X7AF7,	"DeviceHi");
	set_cmt	(0X7AF8,	"SIZE= option",	0);
	create_word	(0X7AF8);
	set_name	(0X7AF8,	"DevSizeOption");
	set_cmt	(0X7AFA,	"did we trap int 12h ?",	0);
	create_byte	(0X7AFA);
	set_name	(0X7AFA,	"Int12Lied");
	set_cmt	(0X7AFB,	"value in 40:13h (int 12h ram)",	0);
	create_word	(0X7AFB);
	set_name	(0X7AFB,	"OldInt12Mem");
	set_cmt	(0X7AFD,	"3Com Device name",	0);
	create_strlit	(0X7AFD,	0X7B05);
	set_name	(0X7AFD,	"ThreeComName");
	create_byte	(0X7B05);
	set_name	(0X7B05,	"FirstUMBLinked");
	set_cmt	(0X7B06,	"segment of DOS Data",	0);
	create_word	(0X7B06);
	set_name	(0X7B06,	"DevDOSData");
	set_cmt	(0X7B08,	"Current Command line",	0);
	create_word	(0X7B08);
	make_array	(0X7B08,	0X2);
	set_name	(0X7B08,	"DevCmdLine");
	set_cmt	(0X7B0C,	"The delimiter which was replaced with null\nto use the file name in the command line",	0);
	create_byte	(0X7B0C);
	set_name	(0X7B0C,	"DevSavedDelim");
	set_cmt	(0X7B0D,	"set non-zero when MagicDrv is final placed",	0);
	create_byte	(0X7B0D);
	set_name	(0X7B0D,	"MagicHomeFlag");
	create_insn	(0X7B0E);
	set_name	(0X7B0E,	"doconf");
	set_cmt	(0X7B10,	"(CHAR_OPER<<8)",	0);
	create_insn	(x=0X7B10);
	op_hex		(x,	1);
	set_cmt	(0X7B13,	"DOS - 2+ internal - GET SWITCHAR/AVAILDEV\nReturn: AL = FFh unsupported subfunction\nDL = current switch character",	0);
	create_insn	(x=0X7B13);
	op_hex		(x,	0);
	set_cmt	(0X7B19,	"save default switchchar",	0);
	create_insn	(x=0X7B1D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7B20,	"OPEN<<8",	0);
	set_cmt	(0X7B23,	"(in case of int 24h)",	0);
	set_cmt	(0X7B24,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read",	0);
	create_insn	(x=0X7B24);
	op_hex		(x,	0);
	set_cmt	(0X7B26,	"brif opened okay\n\nconfig.sys file open error",	0);
	set_cmt	(0X7B28,	"we still want to give the guy\na chance to select clean boot!\n(ie, no autoexec.bat processing)",	0);
	set_cmt	(0X7B2B,	"set it to unreasonable number",	0);
	create_insn	(x=0X7B2B);
	op_dec		(x,	1);
	set_cmt	(0X7B31,	"get file size (note < 64k!!)\nFile handle",	0);
	create_insn	(0X7B31);
	set_cmt	(0X7B37,	"(LSEEK<<8)|2",	0);
	create_insn	(x=0X7B37);
	op_hex		(x,	1);
	set_cmt	(0X7B3A,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from end of file",	0);
	create_insn	(x=0X7B3A);
	op_hex		(x,	0);
	set_cmt	(0X7B3F,	"reset pointer to beginning of file",	0);
	create_insn	(x=0X7B41);
	op_hex		(x,	1);
	set_cmt	(0X7B44,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file",	0);
	create_insn	(x=0X7B44);
	op_hex		(x,	0);
	set_cmt	(0X7B46,	"use current alloclim value",	0);
	set_cmt	(0X7B4D,	"save the size of config.sys file.",	0);
	set_cmt	(0X7B55,	"reserve 1 additional paragraph",	0);
	set_cmt	(0X7B56,	"this is the segment to be used for",	0);
	set_cmt	(0X7B5A,	"rebuilding the config.sys memory image",	0);
	set_cmt	(0X7B5C,	"room for header",	0);
	set_cmt	(0X7B5F,	"config starts here. new alloclim value.",	0);
	create_insn	(x=0X7B72);
	op_hex		(x,	1);
	set_cmt	(0X7B74,	"(in case of int 24h)",	0);
	set_cmt	(0X7B75,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer",	0);
	create_insn	(x=0X7B75);
	op_hex		(x,	0);
	set_cmt	(0X7B78,	"find the eof mark in the file.\nif present,then trim length.",	0);
	set_cmt	(0X7B7B,	"eof mark",	0);
	set_cmt	(0X7B7D,	"point to buffer",	0);
	set_cmt	(0X7B7F,	"no chars",	0);
	set_cmt	(0X7B81,	"find end",	0);
	set_cmt	(0X7B83,	"none found and count exhausted",	0);
	set_cmt	(0X7B85,	"backup past 1Ah",	0);
	set_cmt	(0X7B86,	"cr,lf",	0);
	set_cmt	(0X7B8C,	"difference moved",	0);
	set_cmt	(0X7B8E,	"new count",	0);
	create_insn	(x=0X7B99);
	op_hex		(x,	1);
	set_cmt	(0X7B9B,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X7B9B);
	op_hex		(x,	0);
	set_cmt	(0X7B9F,	"we've got a problem",	0);
	set_cmt	(0X7BA3,	"if ax <(>) cx\ncouldn't read the file",	0);
	create_insn	(x=0X7BA5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7BA8,	"print config error",	0);
	set_name	(0X7BAB,	"endconv");
	create_insn	(0X7BAC);
	set_name	(0X7BAC,	"multi_pass");
	set_cmt	(0X7BAE,	"do nothing. just return.",	0);
	create_insn	(x=0X7BAE);
	op_dec		(x,	1);
	set_name	(0X7BB3,	"jae_endconv");
	set_cmt	(0X7BB9,	"es = [confbot] (CONFIG.SYS image seg)",	0);
	set_cmt	(0X7BBE,	"set count",	0);
	set_cmt	(0X7BC2,	"0",	0);
	set_cmt	(0X7BC4,	"reset chrptr",	0);
	set_cmt	(0X7BC8,	"reset linecount",	0);
	set_cmt	(0X7BD1,	"organize the file",	0);
	create_insn	(0X7BD1);
	set_name	(0X7BD7,	"conflp");
	set_cmt	(0X7BD9,	"increase linecount",	0);
	set_cmt	(0X7BDD,	"reset multdeviceflag.",	0);
	set_cmt	(0X7BE2,	"reset setdevmarkflag.",	0);
	set_cmt	(0X7BE7,	"lf ; linefeed?",	0);
	set_cmt	(0X7BE9,	"then ignore this line.\n\nIf this is a genuine CONFIG.SYS command,\nthen there should be a line number\nimmediately following it",	0);
	set_cmt	(0X7BEB,	"save original command code",	0);
	set_cmt	(0X7BEE,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0X7BEE);
	op_hex		(x,	1);
	set_cmt	(0X7BF0,	"is this a multi-config config.sys?",	0);
	set_cmt	(0X7BF5,	"no, line number is not embedded",	0);
	set_cmt	(0X7BF8,	"ignore end-of-image errors",	0);
	set_cmt	(0X7BFB,	"because if there's an error",	0);
	set_cmt	(0X7BFD,	"fetching the line number that's",	0);
	set_cmt	(0X7C00,	"supposed to be there, the next",	0);
	set_cmt	(0X7C02,	"getchr call will get the same error",	0);
	set_cmt	(0X7C06,	"final pass?",	0);
	set_cmt	(0X7C0B,	"no",	0);
	set_cmt	(0X7C0D,	"have_install_cmd\nare there install commands?",	0);
	create_insn	(x=0X7C0D);
	op_hex		(x,	1);
	set_cmt	(0X7C13,	"no install cmds, yes it is",	0);
	set_cmt	(0X7C15,	"final pass?",	0);
	set_cmt	(0X7C1A,	"no",	0);
	set_cmt	(0X7C1C,	"save backward-compatible command code",	0);
	set_name	(0X7C1C,	"final");
	set_name	(0X7C1F,	"not_final");
	set_cmt	(0X7C2B,	"it would be 'jnb short endconv' \n(E.TAN - 09/07/2023)\ndo not show badop again for multi_pass.",	0);
	create_insn	(0X7C30);
	create_insn	(0X7C37);
	create_insn	(0X7C3C);
	set_cmt	(0X7C3E,	"the initial pass for DOS=HI",	0);
	set_cmt	(0X7C48,	"the second pass was for ifs=",	0);
	create_insn	(0X7C48);
	set_cmt	(0X7C4D,	"now it is NOPs\n\nThis pass can be made use of if\nwe want do some config.sys process\nafter device drivers are loaded and\nbefore install= commands are processed",	0);
	set_cmt	(0X7C4F,	"the third pass for install= ?",	0);
	set_cmt	(0X7C56,	"CONFIG_DOS",	0);
	set_cmt	(0X7C5B,	"CONFIG_INSTALL ; install= command?",	0);
	set_cmt	(0X7C5E,	"\nthe first pass is for normal operation.",	0);
	set_cmt	(0X7C60,	"have_install_cmd ; set the flag",	0);
	create_insn	(x=0X7C60);
	op_hex		(x,	1);
	set_cmt	(0X7C65,	"and handles the next command",	0);
	set_cmt	(0X7C67,	"CONFIG_INSTALLHIGH ; signifier for INSTALLHIGH",	0);
	create_insn	(0X7C67);
	set_cmt	(0X7C6A,	"carry on with normal processing",	0);
	set_cmt	(0X7C6C,	"have_install_cmd",	0);
	create_insn	(x=0X7C6C);
	op_hex		(x,	1);
	set_cmt	(0X7C73,	"CONFIG_INSTALL ; install= command?",	0);
	create_insn	(0X7C73);
	set_cmt	(0X7C76,	"no, check for installhigh",	0);
	set_cmt	(0X7C78,	"query the user if config_cmd",	0);
	set_cmt	(0X7C7B,	"has the CONFIG_OPTION_QUERY bit set",	0);
	set_cmt	(0X7C7D,	"install it.",	0);
	set_cmt	(0X7C80,	"to handle next install= command.",	0);
	set_cmt	(0X7C82,	"CONFIG_INSTALLHIGH ; installhigh= command?",	0);
	create_insn	(0X7C82);
	set_cmt	(0X7C87,	"query the user if config_cmd",	0);
	set_cmt	(0X7C8A,	"has the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X7C8C);
	op_hex		(x,	1);
	set_cmt	(0X7C8F,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: get allocation strategy",	0);
	create_insn	(x=0X7C8F);
	op_hex		(x,	0);
	set_cmt	(0X7C93,	"save for the return",	0);
	set_cmt	(0X7C94,	"HIGH_FIRST ; set alloc to HighFirst",	0);
	create_insn	(x=0X7C94);
	op_hex		(x,	1);
	set_cmt	(0X7C98,	"(ALLOCOPER<<8)|1",	0);
	create_insn	(x=0X7C98);
	op_hex		(x,	1);
	set_cmt	(0X7C9B,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: set allocation strategy",	0);
	create_insn	(x=0X7C9B);
	op_hex		(x,	0);
	create_insn	(x=0X7C9D);
	op_hex		(x,	1);
	set_cmt	(0X7CA0,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state",	0);
	create_insn	(x=0X7CA0);
	op_hex		(x,	0);
	set_cmt	(0X7CA4,	"save for the return",	0);
	set_cmt	(0X7CA5,	"(ALLOCOPER<<8)|3",	0);
	set_cmt	(0X7CA8,	"link in UMBs",	0);
	set_cmt	(0X7CAB,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X7CAB);
	op_hex		(x,	0);
	set_cmt	(0X7CAD,	"install it.",	0);
	set_cmt	(0X7CB3,	"recover original link state",	0);
	set_cmt	(0X7CB4,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X7CB4);
	op_hex		(x,	0);
	set_cmt	(0X7CB6,	"recover original alloc strategy",	0);
	create_insn	(x=0X7CB7);
	op_hex		(x,	1);
	set_cmt	(0X7CBA,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: set allocation strategy",	0);
	create_insn	(x=0X7CBA);
	op_hex		(x,	0);
	set_cmt	(0X7CBC,	"to handle next install= commands.",	0);
	set_cmt	(0X7CBF,	"CONFIG_COMMENT ; comment?",	0);
	create_insn	(0X7CBF);
	set_cmt	(0X7CC4,	"CONFIG_UNKNOWN ; bad command?",	0);
	set_cmt	(0X7CC9,	"CONFIG_REM ; rem?",	0);
	set_cmt	(0X7CCC,	"ignore the rest of the commands.",	0);
	set_cmt	(0X7CCE,	"these commands need to\nadjust chrptr,count",	0);
	set_cmt	(0X7CD2,	"for newline proc.",	0);
	set_cmt	(0X7CD6,	"to handle next install= commands.",	0);
	set_cmt	(0X7CD9,	"CONFIG_BUFFERS",	0);
	create_insn	(0X7CD9);
	set_cmt	(0X7CDE,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X7CE8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7CF2,	"\nparse error,\nand show messages and end the search",	0);
	set_cmt	(0X7CF9,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X7CF9);
	set_cmt	(0X7CFC,	"then jmp to $endloop for semantic check",	0);
	set_cmt	(0X7CFE,	"(/X switch)\n[result_val+_$P_Result_Blk.SYNONYM_Ptr]",	0);
	create_insn	(x=0X7CFE);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7D08,	"[result_val+_$P_Result_Blk.Picked_Val]",	0);
	create_insn	(0X7D08);
	create_insn	(0X7D15);
	create_insn	(x=0X7D1A);
	op_dec		(x,	1);
	set_cmt	(0X7D2C,	"we don't have any problem.",	0);
	create_insn	(0X7D2C);
	set_cmt	(0X7D2F,	"now,let's set it really.",	0);
	set_cmt	(0X7D3B,	"save the line number\nfor the future use",	0);
	set_cmt	(0X7D41,	"CONFIG_BREAK",	0);
	create_insn	(0X7D41);
	set_cmt	(0X7D46,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X7D4B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7D55,	"\nparse error",	0);
	set_cmt	(0X7D5C,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X7D5C);
	set_cmt	(0X7D5F,	"then end the $endloop",	0);
	set_cmt	(0X7D61,	"[result_val+_$P_Result_Blk.Item_Tag]",	0);
	set_cmt	(0X7D68,	"turn it on",	0);
	set_cmt	(0X7D6F,	"turn it off",	0);
	create_insn	(0X7D6F);
	set_cmt	(0X7D74,	"we actually set the ctrl break",	0);
	set_cmt	(0X7D76,	"SET_CTRL_C_TRAPPING \nif we don't have any parse error.",	0);
	create_insn	(x=0X7D76);
	op_hex		(x,	1);
	set_cmt	(0X7D7E,	"DOS - EXTENDED CONTROL-BREAK CHECKING\nAL = 00h get state / 01h set state / 02h set AND get\nDL = 00h for OFF or 01h for ON",	0);
	create_insn	(x=0X7D7E);
	op_hex		(x,	0);
	set_cmt	(0X7D83,	"CONFIG_MULTITRACK",	0);
	create_insn	(0X7D83);
	set_cmt	(0X7D88,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X7D8D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7D97,	"\nparse_error",	0);
	set_cmt	(0X7D99,	"show message and end the search loop.",	0);
	set_cmt	(0X7D9E,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X7D9E);
	set_cmt	(0X7DA3,	"[result_val+_$P_Result_Blk.Item_Tag]",	0);
	set_cmt	(0X7DAA,	"turn it on temporarily.",	0);
	set_cmt	(0X7DB1,	"turn it off temporarily.",	0);
	create_insn	(0X7DB1);
	set_cmt	(0X7DB6,	"we actually set the multrk_flag here",	0);
	create_insn	(0X7DB8);
	set_cmt	(0X7DB9,	"DOSBIODATASEG ; BIOSDATA segment",	0);
	create_insn	(x=0X7DB9);
	op_hex		(x,	1);
	set_cmt	(0X7DC6,	"multrk_off2",	0);
	create_insn	(x=0X7DC6);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X7DCE,	"multrk_on",	0);
	create_insn	(x=0X7DCE);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X7DD8,	"CONFIG_DOS",	0);
	create_insn	(0X7DD8);
	set_cmt	(0X7DE0,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X7DE0);
	create_insn	(x=0X7DE5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7DF1,	"parse error\nshow message and end the search loop.",	0);
	set_name	(0X7DF1,	"h_badparm");
	set_cmt	(0X7DF6,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X7DF6);
	set_cmt	(0X7DF9,	"then end the $endloop",	0);
	create_insn	(0X7E00);
	set_cmt	(0X7E03,	"CONFIG_DEVICEHIGH",	0);
	create_insn	(x=0X7E03);
	op_chr		(x,	1);
	set_cmt	(0X7E0B,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X7E0B);
	set_cmt	(0X7E13,	"process the size= option",	0);
	set_cmt	(0X7E16,	"\nstash it there in case of an error",	0);
	create_insn	(0X7E28);
	set_cmt	(0X7E35,	"\nIf ParseVar up there failed, then\nES:SI points to its problem area..",	0);
	set_cmt	(0X7E3F,	"so all we have to do is choke and\ndie, rather verbosely.",	0);
	create_insn	(0X7E45);
	set_cmt	(0X7E4A,	"cr",	0);
	set_cmt	(0X7E4C,	"(_tryu_4) (*)",	0);
	set_cmt	(0X7E4E,	"lf",	0);
	set_cmt	(0X7E50,	"(*) this would be 'jz short tryu_5'\nErdogan Tan - 10/07/2023",	0);
	set_cmt	(0X7E55,	"(*) al <> cr \n    this would be 'jz short tryu_5'",	0);
	set_cmt	(0X7E5A,	"(*) cr ? (this 2nd check woul not be\nneeded because al value would be 0Dh here)",	0);
	create_insn	(0X7E5A);
	set_cmt	(0X7E5E,	"\nblank instead of cr",	0);
	set_name	(0X7E5E,	"_tryu_4");
	set_cmt	(0X7E60,	"Save the delimiter\nbefore replacing it with null",	0);
	set_cmt	(0X7E6A,	"See if UMBs are around...",	0);
	set_cmt	(0X7E6D,	"yep. So do that normal thang.",	0);
	set_cmt	(0X7E6F,	"nope... so load low.",	0);
	create_insn	(0X7E77);
	set_cmt	(0X7E7D,	"do we support UMBs ?",	0);
	set_cmt	(0X7E83,	"no, we don't",	0);
	set_cmt	(0X7E8D,	"CONFIG_DEVICE",	0);
	create_insn	(x=0X7E8D);
	set_cmt	(0X7E95,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X7E95);
	set_cmt	(0X7E9A,	"not to be loaded in UMB",	0);
	set_cmt	(0X7EA7,	"In case of DEVICE= \nthe null has to be replaced with a ' '",	0);
	set_cmt	(0X7EAF,	"\npass the command line to the device",	0);
	set_cmt	(0X7EB7,	"save it for ourself",	0);
	set_cmt	(0X7EBF,	"clear total block units for driver",	0);
	set_cmt	(0X7ECC,	"Doesn't matter if DeviceHi==0",	0);
	set_cmt	(0X7ED1,	"If not using upper memory,\n('mov al, [DeviceHi]' is not needed here\n because al value is not used after here)",	0);
	set_cmt	(0X7ED4,	"(or al, al) - Erdogan Tan - 10/07/2023",	0);
	create_insn	(x=0X7ED4);
	op_hex		(x,	1);
	set_cmt	(0X7ED9,	"Skip all this and go on \nto the actual load.",	0);
	set_cmt	(0X7EDB,	"('mov al, [UmbLoad]' would be better here)",	0);
	set_cmt	(0X7EDE,	"-1 ; If umb0 not specified, it's old style",	0);
	set_cmt	(0X7EE0,	"so load high even if SIZE= is smaller",	0);
	set_cmt	(0X7EE2,	"0 ; They specified /L, so use new loader",	0);
	set_cmt	(0X7EE6,	"Returns size of first UMB specified",	0);
	set_cmt	(0X7EEB,	"If size is not specified..",	0);
	set_cmt	(0X7EED,	"/L:...,Size < DevSize?",	0);
	set_cmt	(0X7EF3,	"Size < DevSize, so write DevSize as",	0);
	set_cmt	(0X7EF6,	"minsize for load UMB.",	0);
	set_cmt	(0X7F0E,	"Does nothing if didn't call HideUMBs",	0);
	create_insn	(0X7F0E);
	set_cmt	(0X7F11,	"blank/space",	0);
	create_insn	(0X7F1A);
	create_insn	(0X7F20);
	set_cmt	(0X7F22,	"ds:dx points to file name",	0);
	set_cmt	(0X7F24,	"load device driver using exec call",	0);
	set_cmt	(0X7F28,	"es:si back to config.sys",	0);
	set_cmt	(0X7F2A,	"ds back to sysinit",	0);
	set_cmt	(0X7F3D,	"[si+SYSDEV.ATT],DEVTYP\nblock device driver?",	0);
	create_insn	(x=0X7F3D);
	op_hex		(x,	1);
	set_cmt	(0X7F42,	"no.",	0);
	set_cmt	(0X7F44,	"ds:si -> sys_var",	0);
	set_cmt	(0X7F49,	"[si+SYSI_NUMIO]\nno more than 26 drive number",	0);
	create_insn	(x=0X7F49);
	op_dec		(x,	1);
	set_cmt	(0X7F51,	"clear the stack",	0);
	set_cmt	(0X7F53,	"Do this before we leave",	0);
	create_insn	(0X7F59);
	set_cmt	(0X7F5E,	"update the PSP:2 value",	0);
	set_cmt	(0X7F61,	"Pass limit only for\nthe 1st device driver in the file",	0);
	set_cmt	(0X7F69,	"pass the limit to the DD",	0);
	set_cmt	(0X7F7B,	"ds:bx -> sys_var",	0);
	set_cmt	(0X7F80,	"temporarily use this next drv value",	0);
	set_cmt	(0X7F84,	"pass drive number in packet to driver",	0);
	set_cmt	(0X7F8A,	"[bx+SYSI_NUMIO]\nswap with existing values",	0);
	set_cmt	(0X7F8E,	"save real sysi_numio/ncds in ax",	0);
	set_cmt	(0X7F8F,	"disable (reset msg option)\n\"error in config.sys line #\" msg\n(before loading -next- device driver)",	0);
	set_cmt	(0X7F96,	"SYSDEV.STRAT",	0);
	set_cmt	(0X7F99,	"calldev (sdevstrat);",	0);
	set_cmt	(0X7F9C,	"SYSDEV.INT",	0);
	set_cmt	(0X7F9F,	"calldev (sdevint);",	0);
	set_cmt	(0X7FA2,	"get real sysi_numio value",	0);
	set_cmt	(0X7FA4,	"ds:bx -> sys_var",	0);
	set_cmt	(0X7FA9,	"[bx+SYSI_NUMIO]\nrestore previous/real value",	0);
	set_cmt	(0X7FB0,	"move break addr from the req packet",	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_5(void) {
        auto x;
#define id x

	set_cmt	(0X7FC0,	"There we go... all done.",	0);
	set_cmt	(0X7FD6,	"move DOS into HMA if requsted",	0);
	set_cmt	(0X7FDB,	"*p = 0;",	0);
	create_insn	(0X7FE2);
	create_insn	(x=0X7FE4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X7FEE,	"is error_line msg disabled ?",	0);
	set_cmt	(0X7FF4,	"yes",	0);
	set_cmt	(0X7FF6,	"show \"error in config.sys ...\" message.",	0);
	set_cmt	(0X7FF9,	"set the default value again.",	0);
	create_insn	(0X8003);
	set_cmt	(0X8013,	"set ds:dx to header",	0);
	create_insn	(0X8013);
	set_cmt	(0X801A,	"es:di point to dos info",	0);
	set_cmt	(0X801F,	"[si+SYSDEV.ATT] ; get attributes",	0);
	set_cmt	(0X8022,	"DEVTYP ; test if block dev",	0);
	create_insn	(x=0X8022);
	op_hex		(x,	1);
	set_cmt	(0X8027,	"for_devmark",	0);
	create_insn	(x=0X8027);
	op_hex		(x,	1);
	set_cmt	(0X802D,	"go ahead and alloc mem for device",	0);
	set_cmt	(0X8030,	"device driver's init routine failed.",	0);
	set_cmt	(0X8032,	"ISCIN ; is it a console in?",	0);
	create_insn	(x=0X8032);
	op_hex		(x,	1);
	set_cmt	(0X8037,	"[es:di+SYSI_CON]",	0);
	set_cmt	(0X803B,	"[es:di+SYSI_CON+2]",	0);
	set_cmt	(0X803F,	"ISCLOCK ; is it a clock device?",	0);
	create_insn	(x=0X803F);
	op_hex		(x,	1);
	set_cmt	(0X8044,	"[es:di+SYSI_CLOCK]",	0);
	set_cmt	(0X8048,	"[es:di+SYSI_CLOCK+2]",	0);
	create_insn	(0X804F);
	set_cmt	(0X8053,	"if no units found, erase the device",	0);
	set_cmt	(0X8057,	"[si+SYSDEV.NAME]\nnumber of units in name field",	0);
	set_cmt	(0X805A,	"keep total for all drivers in file",	0);
	set_cmt	(0X805F,	"warning no device > 127 units",	0);
	set_name	(0X805F,	"perdrv");
	set_cmt	(0X8064,	"[es:di+SYSI_NUMIO]\nget number of devices",	0);
	set_cmt	(0X806A,	"check for too many devices",	0);
	set_cmt	(0X806C,	"'A' - 'Z' is 26 devices",	0);
	create_insn	(x=0X806C);
	op_dec		(x,	1);
	set_cmt	(0X8074,	"for_devmark",	0);
	create_insn	(x=0X8074);
	op_hex		(x,	1);
	set_cmt	(0X807A,	"alloc the device",	0);
	set_cmt	(0X807F,	"[es:di+SYSI_NUMIO]\nupdate the amount",	0);
	set_cmt	(0X8083,	"remember amount for next device",	0);
	set_cmt	(0X8088,	"point to bpb array",	0);
	set_cmt	(0X8092,	"[es:bp+SYSI_DPB] ; get first dpb",	0);
	set_cmt	(0X8096,	"[es:bp+DPB.NEXT_DPB],-1",	0);
	set_cmt	(0X809D,	"[es:bp+DPB.NEXT_DPB] ; [es:bp+25]",	0);
	create_insn	(0X80A3);
	set_cmt	(0X80A7,	"[es:bp+DPB.NEXT_DPB]",	0);
	set_cmt	(0X80AF,	"[es:bp+DPB.NEXT_DPB+2]",	0);
	set_cmt	(0X80B8,	"DPBSIZ = 61\n(33 in MSDOS 6.21 IO.SYS)",	0);
	create_insn	(x=0X80B8);
	op_dec		(x,	1);
	set_cmt	(0X80C1,	"[es:bp+DPB.NEXT_DPB],-1",	0);
	set_cmt	(0X80C7,	"[es:bp+DPB.FIRST_ACCESS],-1 ; byte",	0);
	set_cmt	(0X80CC,	"ds:si points to bpb",	0);
	set_cmt	(0X80CF,	"point to next bpb",	0);
	set_cmt	(0X80D0,	"[es:bp+DPB.DRIVE]",	0);
	set_cmt	(0X80D5,	"initialize FAT32 extended DPB parameters/fields",	0);
	set_cmt	(0X80D6,	"'AR' signature for FAT32 extended DPB",	0);
	create_insn	(x=0X80D6);
	op_hex		(x,	1);
	set_cmt	(0X80D9,	"0",	0);
	set_cmt	(0X80DB,	"DPB.NEXT_FREE ; last allocated cluster #",	0);
	set_cmt	(0X80DF,	"BPB.fatsecs16 ; [si+A_BPB.BPB_SECTORSPERFAT]",	0);
	set_cmt	(0X80E2,	"FAT DPB (33 bytes)   -jnz-\nFAT32 DPB (61 bytes) -jz-",	0);
	set_cmt	(0X80E4,	"DPB.RESERVED = 0",	0);
	set_cmt	(0X80E8,	"DPB.RESERVED+2 = 0",	0);
	set_cmt	(0X80EC,	"0FFFFh ; -1",	0);
	set_cmt	(0X80ED,	"DPB.FREE_CNT (-1 = unknown)",	0);
	set_cmt	(0X80F1,	"DPB.FREE_CNT+2 (-1 = unknown)",	0);
	set_cmt	(0X80F5,	"'EX' signature for FAT32 extended DPB",	0);
	create_insn	(x=0X80F5);
	op_hex		(x,	1);
	set_cmt	(0X80F8,	"SETDPB ; hidden system call",	0);
	create_insn	(x=0X80F8);
	op_hex		(x,	1);
	set_cmt	(0X80FA,	"DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK\nDS:SI -> BPB (BIOS Parameter Block)\nES:BP -> buffer for DOS Drive Parameter Block\n(if CX=4558h & DX=4152h, FAT32 Extd/PCDOS7.1 DPB will be set)\n((if DX=4152h but CX<>4558h, FAT Extd/PCDOS7.1 DPB will be set))",	0);
	create_insn	(x=0X80FA);
	op_hex		(x,	0);
	set_cmt	(0X80FE,	"[es:bp+DPB.SECTOR_SIZE]",	0);
	set_cmt	(0X8103,	"es:di point to dos info",	0);
	set_cmt	(0X8108,	"[es:di+SYSI_MAXSEC]",	0);
	create_insn	(0X8112);
	set_cmt	(0X8119,	"[es:bp+DPB.DRIVER_ADDR]",	0);
	set_cmt	(0X811D,	"[es:bp+DPB.DRIVER_ADDR+2]",	0);
	set_cmt	(0X8126,	"cx = cx - 1\ncx = remain count from [cs:unitcount]",	0);
	set_cmt	(0X8127,	"cx = 0 -> done",	0);
	set_cmt	(0X8129,	"loop until cx is 0",	0);
	create_insn	(0X812C);
	set_cmt	(0X812E,	"set cds for new drives",	0);
	set_cmt	(0X8131,	"es:di = dos table",	0);
	set_cmt	(0X8136,	"[es:di+SYSI_DEV] ; dx:cx = head of list",	0);
	set_cmt	(0X813A,	"[es:di+SYSI_DEV+2]",	0);
	set_cmt	(0X813E,	"ds:si = device location",	0);
	set_cmt	(0X8143,	"set head of list in dos\n[es:di+SYSI_DEV]",	0);
	set_cmt	(0X8147,	"[es:di+SYSI_DEV+2]",	0);
	set_cmt	(0X814B,	"get pointer to next device",	0);
	set_cmt	(0X814D,	"and save it",	0);
	set_cmt	(0X8151,	"link in the driver",	0);
	set_cmt	(0X8158,	"ax = 0FFFFh (no more devs if yes)?",	0);
	set_cmt	(0X815B,	"possibly multiple device driver.",	0);
	set_cmt	(0X8163,	"otherwise pretend we loaded it in",	0);
	set_cmt	(0X8166,	"reset the flag",	0);
	create_insn	(0X8166);
	set_cmt	(0X8172,	"inquire of MagicDrv whether it is present,\nand final located",	0);
	create_insn	(x=0X8172);
	op_hex		(x,	1);
	set_name	(0X8172,	"CheckDoubleSpace");
	set_cmt	(0X8178,	"already home?\nnothing more to do if so",	0);
	set_cmt	(0X817A,	"is it there?",	0);
	set_cmt	(0X817D,	"done if not",	0);
	set_cmt	(0X817F,	"is it final placed?",	0);
	create_insn	(x=0X817F);
	op_hex		(x,	1);
	set_cmt	(0X8185,	"add number of MagicDrv volumes to\nthe drive number we'll pass to the\nnext loadable block device.",	0);
	set_cmt	(0X818A,	"set the flag!",	0);
	create_insn	(0X8193);
	set_cmt	(0X8195,	"pass it a work buffer",	0);
	set_cmt	(0X8199,	"address in cx (segment)",	0);
	set_cmt	(0X819E,	"for len dx (paragraphs)",	0);
	set_cmt	(0X81A3,	"shuffle magicdrives and new drives\nby this many units",	0);
	set_cmt	(0X81A7,	"backdoor won't shuffle unless it\nsees this, to prevent bad things\nfrom happening if people run the\nnew driver with an old (dos) BIOS",	0);
	create_insn	(x=0X81A7);
	op_hex		(x,	1);
	create_insn	(0X81B3);
	create_insn	(x=0X81B5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X81B8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X81C1,	"CONFIG_COUNTRY",	0);
	create_insn	(0X81C1);
	set_cmt	(0X81C9,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X81C9);
	set_cmt	(0X81CE,	"\nreset the drive,path to default value.",	0);
	create_insn	(x=0X81DB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X81E5,	"parse error,check error code and",	0);
	set_cmt	(0X81E7,	"show message and end the search loop.",	0);
	set_cmt	(0X81EA,	"-1 ; signals that parse error.",	0);
	set_cmt	(0X81F3,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X81F3);
	set_cmt	(0X81F8,	"_$P_Number",	0);
	set_cmt	(0X8200,	"\n[cs:result_val+_$P_Result_Blk.Picked_Val]",	0);
	create_insn	(0X820F);
	set_cmt	(0X8213,	"path entered",	0);
	create_insn	(0X8215);
	set_cmt	(0X821B,	"move the path to known place.",	0);
	create_insn	(x=0X8220);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X822C,	"-1 ; had a parse error?",	0);
	create_insn	(0X822C);
	create_insn	(0X8237);
	create_insn	(x=0X8238);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X823E);
	create_insn	(x=0X8246);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X824B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X824E,	"open a file",	0);
	set_cmt	(0X8252,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read",	0);
	create_insn	(x=0X8252);
	op_hex		(x,	0);
	set_cmt	(0X8256,	"save file handle",	0);
	set_cmt	(0X8260,	"ax=country id, bx=filehandle",	0);
	set_cmt	(0X826A,	"need 6k buffer to handle country.sys\n(384*16 bytes)",	0);
	create_insn	(x=0X826A);
	op_dec		(x,	1);
	set_cmt	(0X8273,	"cannot allocate the buffer for country.sys",	0);
	create_insn	(x=0X8275);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8278,	"default path?",	0);
	set_cmt	(0X827B,	"no",	0);
	set_cmt	(0X827E,	"ds:si -> cntry_root",	0);
	set_cmt	(0X827F,	"es:di -> country info tab in dos",	0);
	set_cmt	(0X8284,	"save di",	0);
	set_cmt	(0X8285,	"country_cdpg_info.ccPath_CountrySys",	0);
	set_cmt	(0X8288,	"set the path to country.sys in dos.",	0);
	set_cmt	(0X828B,	"es:di -> country info tab again.",	0);
	set_cmt	(0X8293,	"ds:si -> 2k buffer to be used.",	0);
	set_cmt	(0X8295,	"now do the job!",	0);
	set_cmt	(0X8298,	"read error or could not find country,\ncode page combination",	0);
	set_cmt	(0X829A,	"-1\ncould not find matching country_id, code page?",	0);
	set_cmt	(0X829D,	"then \"invalid country code or code page\"",	0);
	set_cmt	(0X82A1,	"is the default file used?",	0);
	create_insn	(x=0X82A9);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X82AE,	"default file has been used.\nes:si -> \\country.sys in sysinit_seg",	0);
	create_insn	(x=0X82AE);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X82B9,	"restore es -> confbot.",	0);
	create_insn	(x=0X82BD);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X82C5,	"restore es -> confbot seg",	0);
	set_cmt	(0X82C8,	"restore ds to sysinit_seg",	0);
	set_cmt	(0X82C9,	"if no error,then exit",	0);
	set_cmt	(0X82CB,	"else show error message",	0);
	set_cmt	(0X82D1,	"close a file. \ndon't care even if it fails.",	0);
	create_insn	(x=0X82D6);
	op_hex		(x,	1);
	set_cmt	(0X82D8,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X82D8);
	op_hex		(x,	0);
	set_cmt	(0X82DD,	"_$P_Out_Of_Range",	0);
	create_insn	(0X82DD);
	set_name	(0X82DD,	"cntry_error");
	create_insn	(x=0X82E2);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X82E7);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X82F1,	"CONFIG_FILES",	0);
	create_insn	(0X82F1);
	set_cmt	(0X82F6,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X82FB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8305,	"\nparse error\nshow messages and end the search loop.",	0);
	set_cmt	(0X830C,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X830C);
	set_cmt	(0X830F,	"then end the $endloop",	0);
	set_cmt	(0X8311,	"\n[result_val+_$P_Result_Blk.Picked_Val]",	0);
	set_cmt	(0X8315,	"save it temporarily",	0);
	create_insn	(0X831B);
	set_cmt	(0X831F,	"no error. really set the value now.",	0);
	set_cmt	(0X8326,	"CONFIG_LASTDRIVE",	0);
	create_insn	(0X8326);
	set_cmt	(0X832B,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X8330);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X833A,	"\nparse error\nshow messages and end the search loop.",	0);
	set_cmt	(0X8341,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X8341);
	set_cmt	(0X8344,	"then end the $endloop",	0);
	set_cmt	(0X8346,	"[rv_byte]\npick up the drive number",	0);
	set_cmt	(0X834A,	"save it temporarily",	0);
	create_insn	(0X8350);
	set_cmt	(0X8354,	"no error.\nreally set the value now.",	0);
	set_cmt	(0X835B,	"CONFIG_DRIVPARM",	0);
	create_insn	(0X835B);
	set_cmt	(0X8360,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X8373);
	set_cmt	(0X8376,	"CONFIG_STACKS",	0);
	create_insn	(0X8376);
	set_cmt	(0X837E,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X837E);
	create_insn	(x=0X8383);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X838D,	"parse error",	0);
	create_insn	(x=0X838F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8392,	"show messages and end the search loop.",	0);
	set_cmt	(0X8398,	"(jmp coff)",	0);
	set_cmt	(0X839B,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X839B);
	set_cmt	(0X839E,	"then end the $endloop",	0);
	set_cmt	(0X83A0,	"\n[cs:result_val+_$P_Result_Blk.Picked_Val]",	0);
	create_insn	(0X83AF);
	create_insn	(0X83B5);
	set_cmt	(0X83BD,	"mincount",	0);
	create_insn	(x=0X83BD);
	op_hex		(x,	1);
	set_cmt	(0X83C5,	"minsize",	0);
	create_insn	(x=0X83C5);
	op_dec		(x,	1);
	set_cmt	(0X83CD,	"-1 ; invalid",	0);
	create_insn	(0X83D6);
	set_cmt	(0X83DE,	"-1 ; invalid",	0);
	set_cmt	(0X83E5,	"-1 ; invalid?",	0);
	set_cmt	(0X83ED,	"defaultcount\nreset to default value.",	0);
	set_cmt	(0X83F4,	"defaultsize",	0);
	create_insn	(x=0X83F4);
	op_dec		(x,	1);
	set_cmt	(0X83FB,	"stacks= been accepted.",	0);
	create_insn	(x=0X8402);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X840D);
	set_cmt	(0X841D,	"-1 ; stacks= been accepted.",	0);
	set_cmt	(0X8427,	"CONFIG_SHELL",	0);
	create_insn	(0X8427);
	set_cmt	(0X842C,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	set_cmt	(0X8437,	"\nzap length, first byte of command-line",	0);
	set_cmt	(0X843E,	"we already have the first char",	0);
	create_insn	(x=0X843E);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8441,	"of the new shell in AL, save it now",	0);
	set_cmt	(0X8447,	"this is the normal case: \"organize\"",	0);
	set_cmt	(0X8449,	"put a ZERO right after the filename",	0);
	set_cmt	(0X844B,	"this may happen if there are no args",	0);
	set_cmt	(0X844D,	"I suppose...",	0);
	set_cmt	(0X8452,	"commnd+63\nthis makes sure we don't overflow\ncommnd (the filename)",	0);
	create_insn	(x=0X8452);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X845A,	"zero-terminate the filename",	0);
	create_insn	(0X845A);
	set_cmt	(0X845D,	"\nprepare to process the command-line",	0);
	create_insn	(x=0X845D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X846A,	"command_line+126",	0);
	create_insn	(x=0X846A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X8472);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X847B,	"zero-terminate the filename\n(or the command-line as the case may be)",	0);
	set_cmt	(0X847E,	"lf ; the safest way to eat the rest of",	0);
	set_cmt	(0X8480,	"the line: watch for ever-present LF",	0);
	set_cmt	(0X848A,	"CONFIG_FCBS",	0);
	create_insn	(0X848A);
	set_cmt	(0X848F,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(x=0X8494);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X84A0,	"parse error\nshow messages and end the search loop.",	0);
	set_cmt	(0X84A5,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X84A5);
	set_cmt	(0X84A8,	"then end the $endloop",	0);
	set_cmt	(0X84AA,	"\n[cs:result_val+_$P_Result_Blk.Picked_Val]",	0);
	set_cmt	(0X84AE,	"the first positional?",	0);
	create_insn	(0X84B9);
	create_insn	(0X84BF);
	set_cmt	(0X84D0,	"CONFIG_SWITCHES\nswitches= command entered?",	0);
	create_insn	(0X84D0);
	set_cmt	(0X84D3,	"yes",	0);
	set_cmt	(0X84D8,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	create_insn	(0X84D8);
	create_insn	(x=0X84DD);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X84E7,	"\nparse error\nshow messages and end the search loop.",	0);
	set_cmt	(0X84EF,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X84EF);
	set_cmt	(0X84F2,	"then jmp to $endloop for semantic check",	0);
	set_cmt	(0X84F4,	"offset \"/K\"\n[cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]",	0);
	create_insn	(x=0X84F4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X84FD,	"set the flag",	0);
	set_cmt	(0X8505,	"offset \"/T\"\n[cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]",	0);
	create_insn	(x=0X8505);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X850E,	"set the flag",	0);
	set_cmt	(0X8516,	"offset \"/I\"\n[cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]",	0);
	create_insn	(x=0X8516);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X851F,	"set the flag",	0);
	set_cmt	(0X8527,	"offset \"/W\"\n[cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]",	0);
	create_insn	(x=0X8527);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8530,	"set the flag",	0);
	set_cmt	(0X8538,	"if /k entered,",	0);
	create_insn	(0X8538);
	set_cmt	(0X853F,	"DOSBIODATASEG ; BIOSDATA segment",	0);
	create_insn	(x=0X853F);
	op_hex		(x,	1);
	set_cmt	(0X8546,	"BIOSDATA:047Eh\nuse the conventional keyboard functions",	0);
	create_insn	(x=0X8546);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X854B,	"BIOSDATA:047Fh",	0);
	create_insn	(x=0X854B);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	create_insn	(x=0X8554);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X8561,	"GET_IN_VARS",	0);
	create_insn	(x=0X8561);
	op_hex		(x,	1);
	set_cmt	(0X8563,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists",	0);
	create_insn	(x=0X8563);
	op_hex		(x,	0);
	set_cmt	(0X8565,	"[es:DOS_FLAG_OFFSET], SUPPRESS_WINA20",	0);
	create_insn	(x=0X8565);
	op_hex		(x,	1);
	set_cmt	(0X856D,	"if /i entered ; new switch for PCDOS 7.1",	0);
	create_insn	(x=0X8577);
	op_hex		(x,	1);
	set_cmt	(0X8579,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists",	0);
	create_insn	(x=0X8579);
	op_hex		(x,	0);
	set_cmt	(0X857B,	"set DOS_FLAG bit 6",	0);
	create_insn	(x=0X857B);
	op_hex		(x,	1);
	set_cmt	(0X8587,	"CONFIG_SET ; set var=value<cr/lf>",	0);
	create_insn	(0X8587);
	set_cmt	(0X858C,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	set_cmt	(0X8591,	"copy var at ES:SI to \"config_wrkseg\"",	0);
	set_cmt	(0X8594,	"no error",	0);
	set_cmt	(0X8596,	"whoops, display error in line XXX",	0);
	set_cmt	(0X8599,	"jump to coff (to skip to next line)",	0);
	set_cmt	(0X859B,	"CONFIG_NUMLOCK ; numlock=on|off",	0);
	create_insn	(0X859B);
	set_cmt	(0X85A0,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set",	0);
	set_cmt	(0X85AA,	"all done",	0);
	set_cmt	(0X85AC,	"CONFIG_DOSDATA ; PCDOS 7 new config cmd",	0);
	create_insn	(0X85AC);
	create_insn	(x=0X85B6);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X85C7,	"_$P_RC_EOL ; end of line?",	0);
	create_insn	(0X85C7);
	set_cmt	(0X85CC,	"tag 1 (UMB)\n[result_val+_$P_Result_Blk.Item_Tag]",	0);
	create_insn	(x=0X85CC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X85D3,	"DOSDATA=UMB (1) NOUMB (0)",	0);
	create_insn	(x=0X85D3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X85DA,	"DOSDATA=UMB (1) NOUMB (0)",	0);
	create_insn	(x=0X85DA);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X85E1);
	set_cmt	(0X85E4,	"CONFIG_COMMENT\n(do nothing with this line.)",	0);
	create_insn	(0X85E4);
	create_insn	(x=0X85E9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X85ED);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X85F4,	"CONFIG_REM\n(do nothing with this line.)",	0);
	create_insn	(0X85F4);
	set_cmt	(0X85F9,	"null/bogus command?",	0);
	create_insn	(x=0X85FE);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X8602);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X8608,	"adjusts alloclim if Protman$ \nreduced our arena through a manual hack",	0);
	create_insn	(0X8608);
	set_name	(0X8608,	"CheckProtmanArena");
	set_cmt	(0X8609,	"get our arena header",	0);
	set_cmt	(0X8610,	"[es:ARENA.SIZE] ; find end of arena",	0);
	set_cmt	(0X8623,	"set up registers for sysparse\nin:\n   es:si -> command line in confbot\n      di -> offset of the parse control definition.\nout:\n   calls sysparse.\n   carry will set if parse error.\n   *** the caller should check the eol condition by looking at ax\n   *** after each call.\n   *** if no parameters are found,then ax will contain a error code.\n   *** if the caller needs to look at the synomym@ of the result,\n   *** the caller should use cs:@ instead of es:@.\n   cx should be set to 0 at the 1st time the caller calls this proc.\n   ax - exit code\n   bl - terminated delimeter code\n   cx - new positional ordinal\n   si - set to pase scanned operand\n   dx - selected result buffer",	0);
	create_insn	(0X8623);
	set_name	(0X8623,	"sysinit_parse");
	set_cmt	(0X8625,	"now ds:si -> command line",	0);
	set_cmt	(0X8628,	"now es:di -> control definition",	0);
	set_cmt	(0X8629,	"save the pointer to the parm",	0);
	set_cmt	(0X862E,	"we are about to parse for badparm msg.",	0);
	set_cmt	(0X8639,	"_$P_No_Error ; no error",	0);
	set_cmt	(0X863C,	"cf=0",	0);
	set_cmt	(0X863E,	"_$P_RC_EOL ; end of line?",	0);
	set_cmt	(0X8641,	"or the end of line?",	0);
	create_insn	(0X8646);
	set_cmt	(0X864A,	"'badop_p' is not used in \nMSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM\n(but it was/is not removed)\nErdogan Tan - 11/07/2023",	0);
	create_insn	(0X864A);
	set_name	(0X864A,	"badop_p");
	create_insn	(x=0X864C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X8656);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X8662);
	set_name	(0X8662,	"badparm_p");
	create_insn	(x=0X8667);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8671,	"print \"xxxx\" until cr.",	0);
	set_cmt	(0X8673,	"cr ?",	0);
	set_cmt	(0X8676,	"yes",	0);
	set_cmt	(0X8678,	"display character",	0);
	create_insn	(x=0X8678);
	op_hex		(x,	1);
	set_cmt	(0X867A,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0X867A);
	op_hex		(x,	0);
	create_insn	(0X867F);
	create_insn	(x=0X8681);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X868E);
	set_name	(0X868E,	"getchr");
	create_insn	(x=0X868F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X8695);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X869C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X86A0);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X86A7);
	set_cmt	(0X86AA,	"'incorrect_order' is not used in \nMSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM\n(but it was/is not removed)\nErdogan Tan - 11/07/2023",	0);
	create_insn	(x=0X86AA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X86AA,	"incorrect_order");
	create_insn	(0X86B4);
	set_name	(0X86B4,	"error_line");
	create_insn	(x=0X86B6);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0X86C0);
	set_name	(0X86C0,	"showlinenum");
	set_cmt	(0X86C7,	"\ndi -> the least significant decimal field.",	0);
	create_insn	(x=0X86C7);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X86CA);
	op_dec		(x,	1);
	set_cmt	(0X86CD,	"(ds = cs !)",	0);
	set_cmt	(0X86D1,	"< 10 ?",	0);
	create_insn	(x=0X86D1);
	op_dec		(x,	1);
	set_cmt	(0X86D4,	"yes",	0);
	set_cmt	(0X86D8,	"cx = 10",	0);
	set_cmt	(0X86DA,	"convert to ascii numeric char (\"0\" to \"9\")",	0);
	create_insn	(x=0X86DA);
	op_hex		(x,	1);
	set_cmt	(0X86E2,	"convert to ascii numeric char (\"0\" to \"9\")",	0);
	create_insn	(x=0X86E2);
	op_hex		(x,	1);
	set_cmt	(0X86E8,	"show it",	0);
	create_insn	(0X86EF);
	set_name	(0X86EF,	"ProcDOS");
	set_cmt	(0X86F1,	"\n[cs:result_val+_$P_Result_Blk.Item_Tag]\n\nresult_val._$P_item_tag\n         = 1 for DOS=HIGH\n         = 2 for DOS=LOW\n         = 3 for DOS=UMB\n         = 4 for DOS=NOUMB",	0);
	create_insn	(0X8705);
	create_insn	(0X870C);
	create_insn	(0X8713);
	set_cmt	(0X871A,	"lie INT 12h as alloclim\nassuming that it is 3Com",	0);
	create_insn	(0X871A);
	set_name	(0X871A,	"LieInt12Mem");
	set_cmt	(0X871E,	"Is it 3Com driver?",	0);
	set_cmt	(0X8721,	"yes, lie to him differently",	0);
	set_cmt	(0X8723,	"Is the DD being loaded in UMB",	0);
	set_cmt	(0X8729,	"no, don't lie",	0);
	set_cmt	(0X872B,	"lie INT 12h as end of UMB",	0);
	create_insn	(0X8733);
	set_name	(0X8733,	"SetInt12Mem");
	set_cmt	(0X8734,	"ROMBIOS data area segment",	0);
	create_insn	(x=0X8734);
	op_hex		(x,	1);
	set_cmt	(0X8739,	"memory size (KB)",	0);
	create_insn	(x=0X8739);
	set_cmt	(0X8742,	"16*64 = 1024",	0);
	set_cmt	(0X8744,	"convert paragraphs to kilobyte",	0);
	create_insn	(x=0X8746);
	set_cmt	(0X8749,	"mark that we are lying",	0);
	set_cmt	(0X8751,	"were we lying so far?",	0);
	create_insn	(0X8751);
	set_name	(0X8751,	"TrueInt12Mem");
	set_cmt	(0X875D,	"yes\nno, we weren't",	0);
	create_insn	(x=0X8760);
	op_hex		(x,	1);
	set_cmt	(0X8769,	"restore INT 12h memory",	0);
	create_insn	(x=0X8769);
	create_insn	(0X876E);
	set_name	(0X876E,	"IsIt3Com");
	set_cmt	(0X8771,	"ptr to device header",	0);
	set_cmt	(0X8776,	"SYSDEV.NAME ; ptr device name",	0);
	create_insn	(x=0X8776);
	op_dec		(x,	1);
	create_insn	(x=0X877B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X877E,	"name length",	0);
	create_insn	(0X8787);
	set_name	(0X8787,	"UpdatePDB");
	create_insn	(x=0X8788);
	op_hex		(x,	1);
	set_cmt	(0X878A,	"DOS - 3+ - GET PSP ADDRESS",	0);
	create_insn	(x=0X878A);
	op_hex		(x,	0);
	set_cmt	(0X8793,	"[PDB.BLOCK_LEN]",	0);
	create_insn	(0X8799);
	set_name	(0X8799,	"InitVar");
	set_cmt	(0X879F,	"0",	0);
	set_cmt	(0X87A1,	"Shrink UMBs? (made 1 if /S given)",	0);
	set_cmt	(0X87A5,	"Set to 1 when DH/LH has been called",	0);
	set_cmt	(0X87A9,	"Load Address (seg), used for DH only",	0);
	set_cmt	(0X87AD,	"UNSPECIFIED\nLater is the # of the 1st spec'd UMB",	0);
	set_cmt	(0X87B3,	"Start with zero args having been read",	0);
	set_cmt	(0X87B8,	"MAXUMB",	0);
	create_insn	(x=0X87B8);
	op_dec		(x,	1);
	set_cmt	(0X87BB,	"\nFor each entry on the UmbUsed array,",	0);
	create_insn	(x=0X87BB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X87BE,	"Store 0",	0);
	set_cmt	(0X87C0,	"MAXUMB",	0);
	create_insn	(x=0X87C0);
	op_dec		(x,	1);
	set_cmt	(0X87C3,	"Okay... \nfor each entry on the UmbSize array,",	0);
	create_insn	(x=0X87C3);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X87C6,	"Store 0",	0);
	set_cmt	(0X87CD,	"scans the upper memory chain \nand concatenates adjacent free MCBs",	0);
	create_insn	(0X87CD);
	set_name	(0X87CD,	"FixMem");
	set_cmt	(0X87D2,	"Link in UMBs",	0);
	set_cmt	(0X87D5,	"Get first upper-memory MCB address (0x9FFF)",	0);
	set_cmt	(0X87D8,	"(if couldn't get it, leave now).",	0);
	set_cmt	(0X87DA,	"It returns in AX, so move it to ES.",	0);
	set_cmt	(0X87DC,	"We're keeping the address of the last MCB",	0);
	set_cmt	(0X87DE,	"in CX... and the last owner",	0);
	set_cmt	(0X87E0,	"in dx as we go through the loop",	0);
	set_cmt	(0X87E1,	"[es:ARENA.SIGNATURE]\nif 'Z', don't repeat loop",	0);
	set_cmt	(0X87E5,	"[es:ARENA.OWNER] ; if not zero, do nothing",	0);
	set_cmt	(0X87EA,	"dx was owner of previous MCB",	0);
	set_cmt	(0X87EC,	"If not both zero, don't cat.",	0);
	set_cmt	(0X87EE,	"[es:ARENA.SIZE]\nGrab this block's Size,",	0);
	set_name	(0X87EE,	"fm20");
	set_cmt	(0X87F3,	"Go back to prev MCB's address",	0);
	set_cmt	(0X87F5,	"[es:ARENA.SIGNATURE]\n& move the SECOND sig here",	0);
	create_insn	(x=0X87F5);
	set_cmt	(0X87F9,	"[es:ARENA.SIZE]\nSize += first MCB's size",	0);
	create_insn	(x=0X87F9);
	set_cmt	(0X87FE,	"And add one for the header",	0);
	set_cmt	(0X8801,	"[es:ARENA.SIZE] ; Write the size",	0);
	create_insn	(x=0X8801);
	set_cmt	(0X8806,	"Save MCB address",	0);
	set_cmt	(0X8808,	"[es:ARENA.OWNER] ; And remember its owner",	0);
	create_insn	(x=0X8808);
	set_cmt	(0X880D,	"Move to the next MCB",	0);
	set_cmt	(0X880F,	"[es:ARENA.SIZE]",	0);
	create_insn	(x=0X880F);
	set_cmt	(0X8817,	"arena_signature_end",	0);
	set_cmt	(0X8819,	"If signature != 'Z', there are more.",	0);
	set_cmt	(0X881B,	"Unlink UMBs",	0);
	set_cmt	(0X8824,	"DOS_CHECK_UMBLINK",	0);
	create_insn	(x=0X8824);
	op_hex		(x,	1);
	set_name	(0X8824,	"fm_link");
	set_cmt	(0X8827,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state",	0);
	create_insn	(x=0X8827);
	op_hex		(x,	0);
	set_cmt	(0X882C,	"store current link-state (to use/set later)",	0);
	set_cmt	(0X8831,	"DOS_SET_UMBLINK",	0);
	set_cmt	(0X8837,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X8837);
	op_hex		(x,	0);
	create_insn	(0X883A);
	set_name	(0X883A,	"fm_unlink");
	set_cmt	(0X883F,	"old link-state (to set again)",	0);
	set_cmt	(0X8844,	"DOS_SET_UMBLINK",	0);
	create_insn	(x=0X8844);
	op_hex		(x,	1);
	set_cmt	(0X8847,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X8847);
	op_hex		(x,	0);
	set_cmt	(0X884A,	"parses [/S][/L:umb[,size][;umb[,size]]*] \n  and builds the table laid out in highvar.inc\nENTRY: \n  ES:SI points to command tail of LoadHigh/DeviceHigh\n      (whitespace ok)\nEXIT:\n  ES:SI points to first character in child program name",	0);
	create_insn	(0X884A);
	set_name	(0X884A,	"ParseVar");
	set_cmt	(0X884D,	"Make DS:SI point to it, as well as ES:SI",	0);
	set_cmt	(0X884E,	"(regardless if we're in devhigh or loadhigh)",	0);
	set_cmt	(0X8850,	"here, ES:SI==\"  /L...\"--must eat whitespace",	0);
	set_cmt	(0X8854,	"ES:SI==\" /L...\"--keep eating.",	0);
	set_cmt	(0X8856,	"SWTCH ; ES:SI==\"/L...\"--go process a switch",	0);
	set_cmt	(0X885A,	"Backup--it's now \"odule options\", and we need",	0);
	set_cmt	(0X885B,	"that \"m\" we just read (or whatever it is).",	0);
	set_cmt	(0X885C,	"Then return with carry clear == we're done.",	0);
	set_cmt	(0X885E,	"Just read 'S' or 'L', hopefully",	0);
	create_insn	(0X885E);
	set_cmt	(0X885F,	"So we make it upper-case, and...",	0);
	create_insn	(x=0X885F);
	op_hex		(x,	1);
	set_cmt	(0X8861,	"just read 'S'?",	0);
	set_cmt	(0X8865,	"If it's /S, it's another arg for LH to skip.\n\nNote: 'inc byte [cs:fm_argc]' would be enough here\nErdogan Tan - 19/04/2019 (Retro DOS v4) - 11/07/2023",	0);
	set_cmt	(0X886B,	"/S, so ES:SI==\"  /L...\" or \" module opts\", or",	0);
	set_cmt	(0X8872,	"possibly even \"/L...\".",	0);
	set_cmt	(0X8874,	"If it's not 'L' either, then it's a bad switch!",	0);
	create_insn	(0X8874);
	set_cmt	(0X887E,	"If no carry, go back and look for more",	0);
	set_cmt	(0X8880,	"Else, back up and exit.",	0);
	set_cmt	(0X8883,	"PV_InvSwt ; Unrecognized switch passed",	0);
	create_insn	(0X8883);
	create_insn	(0X888D);
	set_name	(0X888D,	"parseL");
	set_cmt	(0X888E,	"Make sure they did /L:",	0);
	set_cmt	(0X8890,	"If they didn't, return with carry set.",	0);
	set_cmt	(0X8892,	"After this, it's \",size\" or \";umb\" or \" mod\"",	0);
	set_cmt	(0X8895,	"And error if it's a bad number.",	0);
	set_cmt	(0X8897,	"Convert any address to a UMB number",	0);
	set_cmt	(0X889A,	"Remember the UMB number",	0);
	set_cmt	(0X889C,	"Mark this UMB # as used;",	0);
	set_cmt	(0X889F,	"If it was already marked, it'll error",	0);
	set_cmt	(0X88A1,	"Each UMB number is another arg for LH to skip\n('inc byte [cs:fm_argc]' would be enough)\nErdogan Tan - 08/04/2019 (Retro DOS v4) - 11/07/2023",	0);
	set_cmt	(0X88A5,	"Did \"umb;\" ?",	0);
	set_cmt	(0X88A7,	"Yep: go back and get another UMB.",	0);
	set_cmt	(0X88A9,	"Did \"umb \" ?",	0);
	set_cmt	(0X88AC,	"Yep: return (it'll go back to whitespace)",	0);
	set_cmt	(0X88AE,	"Did \"umb\" ?",	0);
	set_cmt	(0X88B1,	"If so, backup and exit like everything's ok",	0);
	set_cmt	(0X88B3,	"Did \"umb/\" ? (as in, \"/L:1,100;2/S\")",	0);
	set_cmt	(0X88B5,	"If so, back up ES:SI one character and return",	0);
	set_cmt	(0X88B7,	"Did \"umb,\" ?",	0);
	set_cmt	(0X88B9,	"Just what the heck DID they do? Return error.",	0);
	set_cmt	(0X88BB,	"Stop on \"size;\" or \"size \" or anything else",	0);
	set_cmt	(0X88BE,	"And error if it's a bad size.",	0);
	set_cmt	(0X88C0,	"Convert from bytes to paragraphs",	0);
	create_insn	(x=0X88C0);
	op_bin		(x,	0);
	set_cmt	(0X88C3,	"CL still has the UMB number for this routine",	0);
	set_cmt	(0X88C6,	"Each UMB size is another arg for LH to skip\n('inc byte [cs:fm_argc]')",	0);
	set_cmt	(0X88CA,	"They did \"umb,size;\", so get another UMB.",	0);
	set_cmt	(0X88CE,	"Did it end with whitespace?",	0);
	set_cmt	(0X88D1,	"If so, we're done here--go back.",	0);
	set_cmt	(0X88D3,	"Did they do \"umb,size\" and end??? (stupid)",	0);
	set_cmt	(0X88D6,	"If so, backup and exit like everything's ok",	0);
	set_cmt	(0X88D8,	"SWTCH ; Did they do \"umb,size/\" ?",	0);
	set_cmt	(0X88DA,	"If so, again, we're done here.",	0);
	set_cmt	(0X88DC,	"PV_InvArg ; If not, we don't know WHAT they did.",	0);
	set_cmt	(0X88E2,	"In this case, they've specified a UMB twice",	0);
	create_insn	(0X88E2);
	set_cmt	(0X88E7,	"If we hit a '/' character, back up one char\nso the whitespace checker will see it too.",	0);
	create_insn	(0X88E7);
	set_cmt	(0X88E8,	"Then just return with carry clear, so\nParseVar will go about its business.",	0);
	set_cmt	(0X88EA,	"increments fm_argc,\nfor use with LoadHigh command-line parsing\n***\n('inc byte [cs:fm_argc]' would be enough)\nErdogan Tan - 11/07/2023",	0);
	create_insn	(0X88EA);
	set_name	(0X88EA,	"incArgc");
	set_cmt	(0X88EE,	"Obtain previous value of fm_argc,",	0);
	set_cmt	(0X88F2,	"Increment it,",	0);
	set_cmt	(0X88F7,	"And store it right back.",	0);
	set_cmt	(0X88FE,	"Null-terminator",	0);
	create_insn	(0X88FE);
	set_name	(0X88FE,	"isEOL");
	set_cmt	(0X8902,	"CR ; Carriage Return",	0);
	set_cmt	(0X8906,	"LF ; LineFeed",	0);
	set_cmt	(0X8908,	"zf=1 if AL contains EOL character",	0);
	set_cmt	(0X8909,	"Space",	0);
	create_insn	(0X8909);
	set_name	(0X8909,	"isWhite");
	set_cmt	(0X890D,	"Equals (treat as whitespace)",	0);
	set_cmt	(0X8911,	"Tab",	0);
	set_cmt	(0X8913,	"zf=1 if AL contains space,\n        tab or equals character",	0);
	set_cmt	(0X8914,	"marks a given UMB as unused\nAL contains UMB number",	0);
	create_insn	(0X8914);
	set_name	(0X8914,	"unMarkUMB");
	create_insn	(x=0X891E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X8929,	"If unmarked the load UMB,\nload into convent.",	0);
	set_cmt	(0X8936,	"MAXUMB",	0);
	create_insn	(x=0X8936);
	op_dec		(x,	1);
	set_name	(0X8936,	"stowUMB");
	set_cmt	(0X893A,	"Ooops-- UMB # >= MAXUMB",	0);
	create_insn	(0X893C);
	set_cmt	(0X8945,	"UNSPECIFIED\nIf this, we haven't been here before",	0);
	set_cmt	(0X894C,	"So remember this UMB as the load UMB slot.",	0);
	set_cmt	(0X894F,	"If they gave UMB 0, there's really nothing",	0);
	set_cmt	(0X8951,	"that we should do here.",	0);
	set_cmt	(0X8957,	"Now, AX = 1, and BX = UMB Number",	0);
	create_insn	(x=0X895A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X895F,	"If it was already 1,\nthen al==1... and that means an error.",	0);
	set_cmt	(0X8963,	"OOOPS! This one's been used before. :(",	0);
	create_insn	(0X896A);
	set_name	(0X896A,	"stowSiz");
	set_cmt	(0X896E,	"mov [cs:bx+UmbSize],ax !!! ; 08/09/2023",	0);
	set_cmt	(0X896F,	"Now bl==UMB number, AX==size",	0);
	set_cmt	(0X8971,	"bx==UMB number, AX==size",	0);
	set_cmt	(0X8973,	"bx==offset into array",	0);
	create_insn	(x=0X8973);
	op_hex		(x,	1);
	set_cmt	(0X8975,	"Store the size",	0);
	create_insn	(x=0X8975);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X897E,	"Must be a word--16x16 multiplication",	0);
	create_word	(0X897E);
	set_name	(0X897E,	"gnradix");
	create_insn	(0X8980);
	set_name	(0X8980,	"toDigit");
	set_cmt	(0X8986,	"Don't check hex digits if radix isn't 16",	0);
	set_cmt	(0X8990,	"Nothing valid above 'f' at all...",	0);
	set_cmt	(0X8992,	"'a'-10 ; 87 ; Make 'a'==10 and return.",	0);
	create_insn	(x=0X8992);
	op_hex		(x,	1);
	set_cmt	(0X8996,	"Below 'A'? Not a letter...",	0);
	create_insn	(0X8996);
	set_cmt	(0X899B,	"Above 'F'? Not a digit.",	0);
	set_cmt	(0X89A0,	"'A'-10 ; 55 ; Make 'A'==10 and return.",	0);
	create_insn	(x=0X89A0);
	op_hex		(x,	1);
	set_cmt	(0X89A4,	"If less than zero,",	0);
	create_insn	(0X89A4);
	set_cmt	(0X89A7,	"Done.",	0);
	set_cmt	(0X89A9,	"Or, if greater than nine,",	0);
	set_cmt	(0X89AC,	"Done.",	0);
	set_cmt	(0X89AE,	"Okay--make '0'==0 and return.",	0);
	create_insn	(0X89B2);
	set_cmt	(0X89B4,	"reads a 32-bit ASCII number at ES:SI\nand returns it in DX:AX",	0);
	create_insn	(0X89B4);
	set_name	(0X89B4,	"GetXNum");
	set_cmt	(0X89BE,	"Start with 0 (makes sense)",	0);
	set_cmt	(0X89C0,	"And default to a radix of 10 (dec)",	0);
	create_insn	(x=0X89C0);
	op_dec		(x,	1);
	set_cmt	(0X89CD,	"If it's not a digit, leave now.",	0);
	set_cmt	(0X89D1,	"Doesn't have '0x'",	0);
	set_cmt	(0X89D7,	"Either 'x'...",	0);
	create_insn	(x=0X89D7);
	op_chr		(x,	1);
	create_insn	(x=0X89DC);
	op_chr		(x,	1);
	create_insn	(x=0X89E1);
	op_dec		(x,	1);
	set_cmt	(0X89E8,	"Since we read \"0x\", march over it.",	0);
	set_cmt	(0X89EA,	"Now DX:AX=current total, CH=0/CL=char",	0);
	set_cmt	(0X89EE,	"Accepts only valid digits, A-F -> 10-16",	0);
	set_cmt	(0X89F1,	"<- Ah... wasn't a digit. Stop.",	0);
	create_insn	(0X8A00);
	create_insn	(0X8A03);
	set_cmt	(0X8A09,	"multiplies the number in DX:AX by gnradix\nDX=old:hi, AX=old:lo, TOS=old:lo, BX=0",	0);
	create_insn	(0X8A09);
	set_name	(0X8A09,	"mul32");
	set_cmt	(0X8A0C,	"DX=?, AX=new:hi, TOS=old:lo, BX=0",	0);
	set_cmt	(0X8A11,	"Too big?",	0);
	set_cmt	(0X8A13,	"DX=new:hi, AX=new:hi, TOS=old:lo, BX=0",	0);
	set_cmt	(0X8A15,	"DX=new:hi, AX=old:lo, TOS=orig, BX=0",	0);
	set_cmt	(0X8A16,	"DX=0, AX=old:lo, TOS=orig, BX=new:hi",	0);
	set_cmt	(0X8A18,	"DX=carry, AX=new:lo, TOS=orig, BX=new:hi",	0);
	set_cmt	(0X8A1F,	"DX=new:hi, AX=new:lo, TOS=orig, BX=carry",	0);
	set_cmt	(0X8A21,	"BX=0",	0);
	create_insn	(0X8A24);
	set_cmt	(0X8A26,	"divides DX:AX by 16; result in AX only",	0);
	create_insn	(0X8A26);
	set_name	(0X8A26,	"toPara");
	set_cmt	(0X8A27,	"DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll",	0);
	set_cmt	(0X8A29,	"DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll",	0);
	set_cmt	(0X8A2B,	"DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh",	0);
	create_insn	(x=0X8A2C);
	op_dec		(x,	1);
	set_cmt	(0X8A2E,	"DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000",	0);
	set_cmt	(0X8A30,	"AX=hhhh LLLL llll llll",	0);
	create_insn	(0X8A34);
	set_name	(0X8A34,	"UmbHead");
	set_cmt	(0X8A37,	"GET_IN_VARS",	0);
	create_insn	(x=0X8A37);
	op_hex		(x,	1);
	set_cmt	(0X8A39,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists",	0);
	create_insn	(x=0X8A39);
	op_hex		(x,	0);
	set_cmt	(0X8A3B,	"[es:DOS_UMB_HEAD]",	0);
	create_insn	(0X8A47);
	set_cmt	(0X8A4C,	"sets ZF if ES points to an MCB owned by \"SC\"",	0);
	create_insn	(0X8A4C);
	set_name	(0X8A4C,	"isSysMCB");
	set_cmt	(0X8A4D,	"[es:ARENA.OWNER]",	0);
	set_cmt	(0X8A51,	"SystemPSPOwner ; 8 (for US or Japan) is valid",	0);
	set_cmt	(0X8A56,	"JapanPSPOwner ; 9 (for Japan) is valid",	0);
	set_cmt	(0X8A5D,	"[es:ARENA.NAME]",	0);
	create_insn	(0X8A5D);
	set_cmt	(0X8A61,	"'SC'",	0);
	set_cmt	(0X8A66,	"converts a segment address in AX\nto its appropriate UMB number",	0);
	create_insn	(0X8A66);
	set_name	(0X8A66,	"AddrToUmb");
	set_cmt	(0X8A69,	"DX = address to search for",	0);
	set_cmt	(0X8A6B,	"AX = first segment",	0);
	set_cmt	(0X8A6E,	"If it couldn't get it, error out",	0);
	set_cmt	(0X8A72,	"0",	0);
	set_cmt	(0X8A76,	"Present segment >= given segment?",	0);
	set_cmt	(0X8A78,	"yes, done.",	0);
	set_cmt	(0X8A7A,	"Returns with ZF set if this is a system MCB",	0);
	set_cmt	(0X8A7F,	"If it _was_ a system MCB, we're in a new UMB.",	0);
	set_cmt	(0X8A80,	"[es:ARENA.SIGNATURE]",	0);
	set_cmt	(0X8A86,	"'Z' means this was the last MCB... that's it.",	0);
	set_cmt	(0X8A8A,	"[es:ARENA.SIZE]",	0);
	create_insn	(0X8A94);
	set_cmt	(0X8A96,	"[es:ARENA.SIZE]",	0);
	set_cmt	(0X8A9B,	"Present >= given?",	0);
	set_cmt	(0X8A9D,	"Yep! It _was_ inside.",	0);
	set_cmt	(0X8AA1,	"Address is above UM Range,\nAX will return as 0FFFFh.",	0);
	set_cmt	(0X8AA2,	"Return the UMB number in AX (0==conv)",	0);
	set_cmt	(0X8AA8,	"convert address to UMB number after GetXNum\n(GetXNum has read a hex number)",	0);
	create_insn	(0X8AA8);
	set_name	(0X8AA8,	"convUMB");
	set_cmt	(0X8AAE,	"GetXNum didn't read in hex, it is not an addr",	0);
	set_cmt	(0X8AB0,	"convert the address to a UMB number",	0);
	set_cmt	(0X8AB8,	"If too high, ignore it (make it conventional)",	0);
	create_insn	(0X8ABA);
	set_name	(0X8ABA,	"setUMBs");
	set_cmt	(0X8AC2,	"loadLow subroutine is not used anywhere\nof PCDOS 7.1 IBMBIO.COM (& MSDOS 6.21 IO.SYS)\nErdogan Tan - 18/07/2023",	0);
	create_insn	(0X8AC2);
	set_name	(0X8AC2,	"loadLow");
	set_cmt	(0X8AC8,	"UNSPECIFIED ; -1",	0);
	create_insn	(0X8AD1);
	set_name	(0X8AD1,	"ll10");
	set_name	(0X8AD8,	"llx");
	set_cmt	(0X8ADA,	"links UMBs and hides upper-memory as appropriate",	0);
	create_insn	(0X8ADA);
	set_name	(0X8ADA,	"HideUMBs");
	set_cmt	(0X8ADE,	"cf=0 if UMBs are available",	0);
	set_cmt	(0X8AE1,	"there is nothing to do.",	0);
	set_cmt	(0X8AE3,	"Concatenate adjacent free MCBs in upper mem",	0);
	set_cmt	(0X8AE6,	"Link UMBs and set memory-allocation strategy",	0);
	set_cmt	(0X8AEC,	"Remember that we're now running high",	0);
	set_cmt	(0X8AF3,	"See if they gave us a list to leave free",	0);
	set_cmt	(0X8AF6,	"UNSPECIFIED ; If they didn't,",	0);
	set_cmt	(0X8AF8,	"then we shouldn't do this loop:",	0);
	set_cmt	(0X8AFA,	"0",	0);
	set_cmt	(0X8AFC,	"+1 for each UMB",	0);
	set_cmt	(0X8AFD,	"MAXUMB",	0);
	create_insn	(x=0X8AFD);
	op_dec		(x,	1);
	set_cmt	(0X8B05,	"ES:0 points to first MCB in UMB\nCarry set if couldn't reach UMB",	0);
	set_cmt	(0X8B09,	"outside of the valid range of UMBs",	0);
	set_cmt	(0X8B0B,	"hide what we need to hide.",	0);
	set_cmt	(0X8B10,	"mov al,[cs:UmbLoad]",	0);
	create_insn	(0X8B10);
	set_cmt	(0X8B13,	"or byte [cs:UmbLoad],0\nIs the load UMB 0? (-1==unspecified)",	0);
	set_cmt	(0X8B15,	"no, done.",	0);
	set_cmt	(0X8B17,	"fix UMBs and strategy.",	0);
	set_cmt	(0X8B1F,	"Returns the load UMB number in AL\n (-1 if not specified)\n\nInstead of calling this subroutine\n\"or byte [cs:UmbLoad],0\" then \"jz/jnz ..\"\nwould be enough. Erdogan Tan - 18/07/2023",	0);
	create_insn	(0X8B1F);
	set_name	(0X8B1F,	"GetLoadUMB");
	set_cmt	(0X8B27,	"Returns the load UMB minimum size\n (0 if not specified)",	0);
	create_insn	(0X8B27);
	set_name	(0X8B27,	"GetLoadSize");
	set_cmt	(0X8B31,	"array",	0);
	create_insn	(x=0X8B31);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X8B34);
	op_hex		(x,	1);
	set_cmt	(0X8B3A,	"ax==size",	0);
	set_cmt	(0X8B3F,	"Returns the UMB in AL's minimum size\n (0 if not specified)",	0);
	create_insn	(0X8B3F);
	set_name	(0X8B3F,	"GetSize");
	set_cmt	(0X8B46,	"array",	0);
	create_insn	(x=0X8B46);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X8B49);
	op_hex		(x,	1);
	set_cmt	(0X8B4F,	"ax==size",	0);
	set_cmt	(0X8B54,	"StoLoadUMB subroutine is not used anywhere\nof PCDOS 7.1 IBMBIO.COM (& MSDOS 6.21 IO.SYS)\nErdogan Tan - 18/07/2023",	0);
	create_insn	(0X8B54);
	set_name	(0X8B54,	"StoLoadUMB");
	set_cmt	(0X8B56,	"mov [cs:UmbLoad], al !!!! ; 08/09/2023",	0);
	set_cmt	(0X8B57,	"Overrides the load UMB number with what's in AL",	0);
	set_cmt	(0X8B5D,	"Overrides the load UMB min. size with what's in AX",	0);
	create_insn	(0X8B5D);
	set_name	(0X8B5D,	"StoLoadSize");
	set_cmt	(0X8B61,	"Put UMB# in DL\n\nBUG ! CL would/must be used here instead of DL (*)\n18/07/2023",	0);
	set_cmt	(0X8B66,	"UNSPECIFIED ?",	0);
	set_cmt	(0X8B6B,	"We've got a function to do just this\n\nBUG ! stowSiz uses CL instead of DL !\n(CL is set in ParseL which calls stowSiz)\n(This BUG existing in MSDOS 6.21 IO.SYS also)\nErdogan Tan - 18/07/2023",	0);
	set_cmt	(0X8B70,	"marks as HIDDEN all FREE elements in UMB passed as AL",	0);
	create_insn	(0X8B70);
	set_name	(0X8B70,	"hideUMB");
	set_cmt	(0X8B72,	"Returns with carry if err, else ES == MCB",	0);
	set_cmt	(0X8B77,	"Returns with ZF set if owner is SYSTEM",	0);
	set_cmt	(0X8B7C,	"or word [es:ARENA.OWNER],0",	0);
	set_cmt	(0X8B84,	"[es:ARENA.SIGNATURE]",	0);
	set_cmt	(0X8B88,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8B8C,	"Go on forward.",	0);
	set_cmt	(0X8B8E,	"[es:ARENA.SIZE]",	0);
	create_insn	(0X8B98);
	set_cmt	(0X8B9B,	"returns with ZF set if user didn't specify /S",	0);
	create_insn	(0X8B9B);
	set_name	(0X8B9B,	"isTiny");
	set_cmt	(0X8BA7,	"or word [es:ARENA.OWNER],0",	0);
	create_insn	(x=0X8BA7);
	op_hex		(x,	1);
	set_name	(0X8BA7,	"isFreeMCB");
	set_cmt	(0X8BAE,	"marks as HIDDEN the MCB at ES:0",	0);
	create_insn	(0X8BAE);
	set_name	(0X8BAE,	"hideMCB");
	set_cmt	(0X8BB5,	"'HI'",	0);
	set_cmt	(0X8BBC,	"'DD'",	0);
	set_cmt	(0X8BC3,	"'EN'",	0);
	set_cmt	(0X8BCA,	"'  '",	0);
	set_cmt	(0X8BD2,	"marks as FREE the MCB at ES:0",	0);
	create_insn	(0X8BD2);
	set_name	(0X8BD2,	"unHideMCB");
	set_cmt	(0X8BD3,	"[es:ARENA.OWNER],FreePSPOwner",	0);
	set_cmt	(0X8BDA,	"'  '",	0);
	set_cmt	(0X8BDD,	"[es:ARENA.NAME+0]",	0);
	set_cmt	(0X8BE1,	"[es:ARENA.NAME+2]",	0);
	set_cmt	(0X8BE5,	"[es:ARENA.NAME+4]",	0);
	set_cmt	(0X8BE9,	"[es:ARENA.NAME+6]",	0);
	set_cmt	(0X8BEF,	"makes ES:0 point to the first MCB in UMB given as AL",	0);
	create_insn	(0X8BEF);
	set_name	(0X8BEF,	"findUMB");
	set_cmt	(0X8BF4,	"Store the to-be-found UMB number in DX",	0);
	set_cmt	(0X8BF6,	"Returns first UMB segment in AX",	0);
	set_cmt	(0X8BFB,	"Pretend we're on UMB 0 for now...",	0);
	set_cmt	(0X8BFD,	"If CX==DX, the UMB is found",	0);
	set_cmt	(0X8C01,	"Returns with ZF set if owner is SYSTEM",	0);
	set_cmt	(0X8C0B,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8C0D,	"'Z' means this was the last MCB",	0);
	set_cmt	(0X8C0F,	"Go on forward.",	0);
	set_cmt	(0X8C11,	"[es:ARENA.SIZE]",	0);
	create_insn	(0X8C1B);
	set_cmt	(0X8C1E,	"The address is already in ES.",	0);
	set_cmt	(0X8C20,	"makes ES:0 point to the largest free MCB\nin UMB given as AL",	0);
	create_insn	(0X8C20);
	set_name	(0X8C20,	"BigFree");
	set_cmt	(0X8C22,	"Returns with CF if err, else ES==MCB",	0);
	set_cmt	(0X8C27,	"Segment address of largest free MCB",	0);
	set_cmt	(0X8C29,	"Size of largest free MCB",	0);
	set_cmt	(0X8C2B,	"If we've left the MCB, we're done.",	0);
	set_cmt	(0X8C30,	"or word [es:ARENA.OWNER],0",	0);
	set_cmt	(0X8C35,	"[es:ARENA.SIZE] ; Compare sizes..",	0);
	set_cmt	(0X8C3C,	"Unless we're bigger,",	0);
	set_cmt	(0X8C3E,	"Store this new element's addr and size.",	0);
	set_cmt	(0X8C47,	"[es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8C4B,	"NextMCB es,ax ; (macro) ; Go on forward.",	0);
	set_cmt	(0X8C4D,	"es:ARENA.SIZE]",	0);
	set_cmt	(0X8C57,	"Return the address",	0);
	create_insn	(0X8C57);
	set_cmt	(0X8C59,	"Return the size",	0);
	set_cmt	(0X8C5F,	"(if size==0, there's nothing free)",	0);
	set_cmt	(0X8C63,	"sets ZF if UMB in AL wasn't specified in DH/LH line.",	0);
	create_insn	(0X8C63);
	set_name	(0X8C63,	"isSpecified");
	create_insn	(x=0X8C6B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X8C70,	"ets ZF if al==0 (ie, if unspecified)",	0);
	set_cmt	(0X8C74,	"breaks an MCB into two pieces, the lowest one's size==AX\nAX == new size, ES:0 == current MCB",	0);
	create_insn	(0X8C74);
	set_name	(0X8C74,	"shrinkMCB");
	set_cmt	(0X8C77,	"requested size (lowest one)",	0);
	set_cmt	(0X8C7B,	"[es:ARENA.SIZE]",	0);
	set_cmt	(0X8C80,	"MIN_SPLIT_SIZE = 32",	0);
	create_insn	(x=0X8C80);
	op_dec		(x,	1);
	set_cmt	(0X8C83,	"{New size} vs {Current Size-20h}",	0);
	set_cmt	(0X8C85,	"if wanted_size > cur-20h, abort.",	0);
	set_cmt	(0X8C87,	"[es:ARENA.SIGNATURE]",	0);
	set_cmt	(0X8C91,	"[es:ARENA.SIZE]",	0);
	set_cmt	(0X8C96,	"[es:ARENA.SIGNATURE],'M'",	0);
	set_cmt	(0X8C9F,	"Move to new arena area",	0);
	set_cmt	(0X8CA5,	"And prepare the new size",	0);
	set_cmt	(0X8CA6,	"[es:ARENA.SIGNATURE],dl",	0);
	set_cmt	(0X8CAB,	"[es:ARENA.OWNER]",	0);
	set_cmt	(0X8CB2,	"[es:ARENA.SIZE]",	0);
	set_cmt	(0X8CB6,	"'  '",	0);
	set_cmt	(0X8CB9,	"[es:ARENA.NAME+0]",	0);
	set_cmt	(0X8CBD,	"[es:ARENA.NAME+2]",	0);
	set_cmt	(0X8CC1,	"[es:ARENA.NAME+4]",	0);
	set_cmt	(0X8CC5,	"[es:ARENA.NAME+6]",	0);
	create_insn	(0X8CCC);
	set_cmt	(0X8CD1,	"hides as appropriate the UMB in CL",	0);
	create_insn	(0X8CD1);
	set_name	(0X8CD1,	"_hideUMB_");
	set_cmt	(0X8CD6,	"Returns ZF set if al's umb was NOT specified",	0);
	set_cmt	(0X8CDD,	"Retrieve the size of the largest free element\nin AX, put its address in ES.",	0);
	set_cmt	(0X8CE2,	"TOS==size of BigFree in UMB",	0);
	set_cmt	(0X8CE3,	"Retrieve the user's specified",	0);
	set_cmt	(0X8CE5,	"minimum size for this umb (into AX)",	0);
	set_cmt	(0X8CE8,	"BX==BigFree, AX==Specified Size",	0);
	set_cmt	(0X8CE9,	"If they didn't specify one,\nskip over all this.",	0);
	set_cmt	(0X8CED,	"if (specified > max free)",	0);
	set_cmt	(0X8CF1,	"then mark that UMB as unused.",	0);
	set_cmt	(0X8CF8,	"or byte [cs:fUmbTiny],0",	0);
	create_insn	(0X8CF8);
	set_cmt	(0X8CFD,	"They specified /S, so shrink the MCB to AX",	0);
	set_cmt	(0X8D04,	"Skip the spec check.. we wanna hide this one.",	0);
	create_insn	(0X8D06);
	set_cmt	(0X8D08,	"If they specified this UMB, we're done.",	0);
	set_cmt	(0X8D0B,	"so leave.",	0);
	set_cmt	(0X8D0D,	"0",	0);
	set_cmt	(0X8D11,	"Hides everything in UMB #al",	0);
	set_cmt	(0X8D14,	"Did we shrink a UMB? If not, DX==0,",	0);
	set_cmt	(0X8D16,	"So we should leave.",	0);
	set_cmt	(0X8D18,	"Ah, but if it isn't, DX==the MCB's address;",	0);
	set_cmt	(0X8D1A,	"Un-hides the lower portion of that MCB.",	0);
	set_cmt	(0X8D21,	"Marks FROZEN elements as FREE",	0);
	create_insn	(0X8D21);
	set_name	(0X8D21,	"UnFreeze");
	set_cmt	(0X8D23,	"Returns with carry if err, else ES == MCB",	0);
	set_cmt	(0X8D2A,	"Returns with ZF set if MCB is FROZEN",	0);
	set_cmt	(0X8D36,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8D3C,	"[es:ARENA.SIZE]",	0);
	create_insn	(0X8D46);
	create_insn	(0X8D49);
	set_name	(0X8D49,	"isFrozMCB");
	set_cmt	(0X8D4A,	"[es:ARENA.OWNER] ; Check the owner..",	0);
	set_cmt	(0X8D4E,	"8 (for US OR Japan) is valid",	0);
	set_cmt	(0X8D53,	"[es:ARENA.NAME+0]",	0);
	set_cmt	(0X8D57,	"'FR'",	0);
	set_cmt	(0X8D5C,	"[es:ARENA.NAME+2]",	0);
	set_cmt	(0X8D60,	"'OZ'",	0);
	set_cmt	(0X8D65,	"[es:ARENA.NAME+4]",	0);
	set_cmt	(0X8D69,	"'EN'",	0);
	set_cmt	(0X8D6E,	"[es:ARENA.NAME+6]",	0);
	set_cmt	(0X8D72,	"'  '",	0);
	set_cmt	(0X8D77,	"marks as 8+FROZEN the MCB at ES:0\nmov word [es:ARENA.OWNER],SystemPSPOwner",	0);
	create_insn	(0X8D77);
	set_name	(0X8D77,	"frezMCB");
	set_cmt	(0X8D7E,	"[es:ARENA.NAME+0],'FR'",	0);
	set_cmt	(0X8D85,	"[es:ARENA.NAME+2],'OZ'",	0);
	set_cmt	(0X8D8C,	"[es:ARENA.NAME+4],'EN'",	0);
	set_cmt	(0X8D93,	"[es:ARENA.NAME+6],'  '",	0);
	set_cmt	(0X8D9B,	"Marks FROZEN all UM elements now FREE,\nsave those in load UMB",	0);
	create_insn	(0X8D9B);
	set_name	(0X8D9B,	"FreezeUM");
	set_cmt	(0X8D9F,	"mov al,[cs:UmbLoad]",	0);
	set_cmt	(0X8DA2,	"0",	0);
	set_cmt	(0X8DA4,	"Store the load UMB in DX, so we can skip it",	0);
	set_cmt	(0X8DA6,	"Returns first UMB segment in AX",	0);
	set_cmt	(0X8DAB,	"Pretend we're on UMB 0 for now..",	0);
	set_cmt	(0X8DAD,	"Returns with ZF set if owner is SYSTEM",	0);
	set_cmt	(0X8DB2,	"If it _was_ SYSTEM, we're in a new UMB.",	0);
	set_cmt	(0X8DB3,	"DX - UMB number to skip (load UMB)\n\nIf this is the load UMB, we don't want to\nfreeze anything.. so skip that section.",	0);
	set_cmt	(0X8DB7,	"or word [es:ARENA.OWNER],0\nIf it's not free, we can't freeze it",	0);
	set_cmt	(0X8DC3,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8DC7,	"NextMCB es, ax (macro) ; Go on forward.",	0);
	set_cmt	(0X8DC9,	"[es:ARENA.SIZE]",	0);
	create_insn	(0X8DD3);
	set_cmt	(0X8DD8,	"returns with carry set if UMBs are not available,\n else CF==false",	0);
	create_insn	(0X8DD8);
	set_name	(0X8DD8,	"UmbTest");
	set_cmt	(0X8DDC,	"Link in UMBs (if not already linked)",	0);
	set_cmt	(0X8DDF,	"Check to see if they're really linked",	0);
	set_cmt	(0X8DE2,	"And remember what we found out",	0);
	set_cmt	(0X8DE3,	"Unlink UMBs (if we have linked 'em)",	0);
	set_cmt	(0X8DE6,	"And restore what we found out.",	0);
	set_cmt	(0X8DEC,	"WalkMem - travels memory chain and\nreturns carry clear if UMBs are linked",	0);
	create_insn	(0X8DEC);
	set_name	(0X8DEC,	"WalkMem");
	create_insn	(x=0X8DEF);
	op_hex		(x,	1);
	set_cmt	(0X8DF1,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists",	0);
	create_insn	(x=0X8DF1);
	op_hex		(x,	0);
	set_cmt	(0X8DF7,	"ES = Current MCB pointer",	0);
	set_cmt	(0X8DFD,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8E01,	"Move to the next MCB",	0);
	set_cmt	(0X8E03,	"[es:ARENA.SIZE]",	0);
	create_insn	(0X8E0D);
	set_cmt	(0X8E0F,	"This sets CF if ax < 9FFFh.",	0);
	set_cmt	(0X8E16,	"unlinks UMBs if fm_umb is set to 0;\n restores strategy too",	0);
	create_insn	(0X8E16);
	set_name	(0X8E16,	"hl_unlink");
	set_cmt	(0X8E20,	"DOS_SET_UMBLINK",	0);
	create_insn	(x=0X8E20);
	op_hex		(x,	1);
	set_cmt	(0X8E23,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X8E23);
	op_hex		(x,	0);
	set_cmt	(0X8E26,	"Marks HIDDEN elements as FREE",	0);
	create_insn	(0X8E26);
	set_name	(0X8E26,	"UnHideUMBs");
	set_cmt	(0X8E2A,	"mov al,[cs:fInHigh]",	0);
	set_cmt	(0X8E30,	"If didn't call loadhigh/devicehigh earlier,",	0);
	set_cmt	(0X8E32,	"then there's nothing to do here.",	0);
	set_cmt	(0X8E35,	"Make sure UMBs are linked in.",	0);
	create_insn	(0X8E35);
	set_cmt	(0X8E3E,	"We're leaving, so update fInHigh.",	0);
	set_cmt	(0X8E45,	"Unlink UMBs",	0);
	set_cmt	(0X8E4B,	"unlinks UMBs if fm_umb is set to 0",	0);
	create_insn	(0X8E4B);
	set_name	(0X8E4B,	"he_unlink");
	create_insn	(x=0X8E55);
	op_hex		(x,	1);
	set_cmt	(0X8E58,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X8E58);
	op_hex		(x,	0);
	set_cmt	(0X8E5B,	"frees all HIDDEN memory elements in upper-memory",	0);
	create_insn	(0X8E5B);
	set_name	(0X8E5B,	"FreeUMBs");
	set_cmt	(0X8E5D,	"Returns with carry if err, else ES == MCB",	0);
	set_cmt	(0X8E62,	"Prepare for the loop; ES = current MCB addr.",	0);
	set_cmt	(0X8E64,	"Returns with ZF set if owner is 0",	0);
	set_cmt	(0X8E70,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X8E76,	"[es:ARENA.SIZE]",	0);
	set_cmt	(0X8E7C,	"Go on forward.",	0);
	create_insn	(0X8E7E);
	set_cmt	(0X8E81,	"returns with ZF set if current MCB (ES:0) is HIDDEN",	0);
	create_insn	(0X8E81);
	set_name	(0X8E81,	"isHideMCB");
	set_cmt	(0X8E82,	"[es:ARENA.OWNER],SystemPSPOwner\nIf the owner's SYSTEM then check for HIDDEN",	0);
	set_cmt	(0X8E8E,	"cmp word [es:ARENA.NAME+0],'HI'",	0);
	set_cmt	(0X8E97,	"cmp word [es:ARENA.NAME+2],'DD'",	0);
	set_cmt	(0X8EA0,	"cmp word [es:ARENA.NAME+4],'EN'",	0);
	set_cmt	(0X8EA9,	"[es:ARENA.NAME+6],'  '",	0);
	set_cmt	(0X8EAE,	"marks as free the MCB at ES:0",	0);
	create_insn	(0X8EAE);
	set_name	(0X8EAE,	"freeMCB");
	set_cmt	(0X8EB5,	"'  '",	0);
	set_cmt	(0X8EB8,	"mov word [es:ARENA.NAME+0],'  '",	0);
	set_cmt	(0X8EC4,	"[es:ARENA.NAME+6]",	0);
	set_cmt	(0X8EC9,	"returns in AX the addr of the 1st UMB block (0x9FFF)",	0);
	create_insn	(0X8EC9);
	set_name	(0X8EC9,	"HeadUmb");
	create_insn	(x=0X8ECA);
	op_hex		(x,	1);
	set_cmt	(0X8ECC,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists",	0);
	create_insn	(x=0X8ECC);
	op_hex		(x,	0);
	set_cmt	(0X8ECE,	"[es:UMB_HeadIdx]",	0);
	set_cmt	(0X8ED5,	"If it's 0xFFFF, it's an error...",	0);
	set_cmt	(0X8ED7,	"AX contains 0x9FFF for most systems",	0);
	set_cmt	(0X8EDA,	"error",	0);
	create_insn	(0X8EDA);
	set_cmt	(0X8EDD,	"DOS_GET_UMBLINK",	0);
	create_insn	(x=0X8EDD);
	op_hex		(x,	1);
	set_name	(0X8EDD,	"linkumb");
	set_cmt	(0X8EE0,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state",	0);
	create_insn	(x=0X8EE0);
	op_hex		(x,	0);
	set_cmt	(0X8EE2,	"Current link-state is now in al\nal = 01h -> UMBs in DOS memory chain",	0);
	set_cmt	(0X8EE4,	"Jumps if UMBs already linked in",	0);
	set_cmt	(0X8EE6,	"DOS_SET_UMBLINK",	0);
	set_cmt	(0X8EE9,	"bx = 01h -> add UMBs to DOS memory chain",	0);
	set_cmt	(0X8EEC,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state",	0);
	create_insn	(x=0X8EEC);
	op_hex		(x,	0);
	set_cmt	(0X8EEF,	"Are we loading in UMB ?",	0);
	create_insn	(0X8EEF);
	set_name	(0X8EEF,	"InitDevLoad");
	set_cmt	(0X8EF5,	"no, init for lo mem",	0);
	set_cmt	(0X8EF7,	"Are we loading as per Dos 5?",	0);
	set_cmt	(0X8EFF,	"Stop using the old device arena",	0);
	set_cmt	(0X8F02,	"Mark up the UM area as we see fit",	0);
	set_cmt	(0X8F05,	"Hide everything BUT the load area",	0);
	set_cmt	(0X8F08,	"And grab that load area as needed",	0);
	set_cmt	(0X8F0C,	"Then unhide everything frozen",	0);
	set_cmt	(0X8F10,	" (if carry, it's loading low)",	0);
	set_cmt	(0X8F14,	"Do we have space left in the current UMB ?",	0);
	create_insn	(0X8F14);
	set_cmt	(0X8F17,	"yes, we have",	0);
	set_cmt	(0X8F19,	"shrink the current UMB in use",	0);
	set_cmt	(0X8F1C,	"else try to allocate new UMB",	0);
	set_cmt	(0X8F1F,	"we didn't succeed, so load in low memory",	0);
	set_cmt	(0X8F21,	"get Para addr of free mem",	0);
	set_cmt	(0X8F25,	"UMB start addr",	0);
	set_cmt	(0X8F2A,	"dx = UMB End addr",	0);
	set_cmt	(0X8F31,	"in case we failed to load into UMB\nindicate that we are loading low",	0);
	create_insn	(0X8F31);
	set_cmt	(0X8F37,	"start of Low memory",	0);
	set_cmt	(0X8F3B,	"end of Low memory",	0);
	set_cmt	(0X8F40,	"setup a sub-arena for DD",	0);
	set_cmt	(0X8F43,	"init the Device load address",	0);
	set_cmt	(0X8F47,	"init the limit of the block",	0);
	set_cmt	(0X8F4C,	"init Entry point to DD",	0);
	create_insn	(0X8F58);
	set_name	(0X8F58,	"SpaceInUMB");
	set_cmt	(0X8F5C,	"End of UMB",	0);
	set_cmt	(0X8F61,	"- Free = Remaining space",	0);
	set_cmt	(0X8F66,	"Nospace ?",	0);
	set_cmt	(0X8F6C,	"space for sub-arena",	0);
	create_insn	(0X8F6C);
	set_cmt	(0X8F6D,	"do we have space ?",	0);
	create_insn	(0X8F73);
	set_name	(0X8F73,	"PrepareMark");
	set_cmt	(0X8F76,	"[ARENA.OWNER]",	0);
	set_cmt	(0X8F7C,	"[ARENA.NAME],'SD'",	0);
	set_cmt	(0X8F8C,	"update the UMB Variables",	0);
	create_insn	(0X8F92);
	set_name	(0X8F92,	"GetUMBForDev");
	create_insn	(x=0X8F95);
	op_hex		(x,	1);
	set_cmt	(0X8F98,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X8F98);
	op_hex		(x,	0);
	create_insn	(x=0X8FA7);
	op_hex		(x,	1);
	set_cmt	(0X8FAA,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired",	0);
	create_insn	(x=0X8FAA);
	op_hex		(x,	0);
	set_cmt	(0X8FB4,	"0",	0);
	create_insn	(0X8FB4);
	set_cmt	(0X8FB6,	"erase the previous values",	0);
	set_cmt	(0X8FC4,	"Input : \nAX - Free segment were device is going to be loaded\nOutput :\nAX - Segment at which device can be loaded (AX=AX+1)\n\nCreates a sub-arena for the device driver\nputs 'D' marker in the sub-arena",	0);
	create_insn	(0X8FC4);
	set_name	(0X8FC4,	"DevSetMark");
	set_cmt	(0X8FCA,	"[es:devmark.id],devmark_device ; 'D'",	0);
	set_cmt	(0X8FD1,	"[es:devmark.seg]",	0);
	set_cmt	(0X8FD5,	"save load address",	0);
	set_cmt	(0X8FD6,	"command line is still there",	0);
	create_insn	(0X8FE7);
	create_insn	(0X8FEF);
	set_cmt	(0X8FF5,	"devmark.filename ; 8",	0);
	set_cmt	(0X8FF8,	"maximum 8 characters",	0);
	set_cmt	(0X900B,	"blank out the rest",	0);
	set_cmt	(0X900D,	"restore load address",	0);
	set_cmt	(0X9013,	"Calculates the size of the device file in paras\nand stores it in DevSize",	0);
	create_insn	(0X9013);
	set_name	(0X9013,	"SizeDevice");
	create_insn	(x=0X9018);
	op_hex		(x,	1);
	set_cmt	(0X901B,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read",	0);
	create_insn	(x=0X901B);
	op_hex		(x,	0);
	set_cmt	(0X901F,	"BX - file handle",	0);
	set_cmt	(0X9028,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from end of file",	0);
	create_insn	(x=0X9028);
	op_hex		(x,	0);
	create_insn	(x=0X902C);
	op_dec		(x,	1);
	set_cmt	(0X9032,	"size > 0ffffh paras ?",	0);
	create_insn	(x=0X9032);
	op_hex		(x,	1);
	set_cmt	(0X9036,	"no",	0);
	set_cmt	(0X9038,	"invalid device size\nassuming that we fail later",	0);
	set_cmt	(0X9041,	"convert it to paras",	0);
	create_insn	(0X9041);
	create_insn	(x=0X9045);
	op_dec		(x,	1);
	set_cmt	(0X904B,	"save file size (in paragraphs)",	0);
	set_cmt	(0X904F,	"CLC is not needed here\n(OR instruction clears CF) - E.TAN 22/07/2023",	0);
	set_cmt	(0X9050,	"save carry flag",	0);
	create_insn	(x=0X9051);
	op_hex		(x,	1);
	set_cmt	(0X9054,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0X9054);
	op_hex		(x,	0);
	set_cmt	(0X9056,	"restore carry flag\n(we are not checking for 'close file' err)",	0);
	create_insn	(0X9059);
	set_name	(0X9059,	"ExecDev");
	set_cmt	(0X905E,	"Load the parameter block",	0);
	set_cmt	(0X9063,	"block for exec with Load address",	0);
	set_cmt	(0X906C,	"es:bx points to parameters",	0);
	create_insn	(x=0X906C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X906F,	"(load program only)",	0);
	set_cmt	(0X9071,	"load in the device driver",	0);
	create_insn	(x=0X9071);
	op_hex		(x,	1);
	set_cmt	(0X9073,	"DOS - 2+ - LOAD OR EXECUTE (EXEC)\nDS:DX -> ASCIZ filename\nES:BX -> parameter block\nAL = type of load",	0);
	create_insn	(x=0X9073);
	op_hex		(x,	0);
	create_insn	(0X9076);
	set_name	(0X9076,	"RetFromUM");
	set_cmt	(0X9077,	"ConvLoad set if didn't previously call HideUMBs",	0);
	set_cmt	(0X9082,	"ConvLoad clear if did.",	0);
	create_insn	(0X908A);
	set_name	(0X908A,	"RemoveNull");
	set_cmt	(0X908D,	"null ?",	0);
	set_cmt	(0X9091,	"advance the pointer",	0);
	create_insn	(0X9094);
	set_cmt	(0X9099,	"replace null with blank",	0);
	set_cmt	(0X909D,	"Rounds DevBrkAddr to a para addr\nso that it is of the form xxxx:0",	0);
	create_insn	(0X909D);
	set_name	(0X909D,	"RoundBreakAddr");
	create_insn	(0X90BE);
	create_insn	(0X90BF);
	set_name	(0X90BF,	"DevSetBreak");
	set_cmt	(0X90C0,	"remove the init code",	0);
	set_cmt	(0X90CA,	"do not check it.",	0);
	set_cmt	(0X90D1,	"if not same, then o.k.",	0);
	set_cmt	(0X90D9,	"[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0",	0);
	create_insn	(0X90E1);
	set_cmt	(0X90E4,	"Marks a succesful install of a device driver\nSets device size field in sub-arena &\nUpdates Free ptr in UMB or adjusts memhi",	0);
	create_insn	(0X90E4);
	set_name	(0X90E4,	"DevBreak");
	set_cmt	(0X90EE,	"seg of sub-arena",	0);
	set_cmt	(0X90F1,	"Back to Device segment",	0);
	set_cmt	(0X90F4,	"size of device in paras",	0);
	set_cmt	(0X90F6,	"[devmark.size]\nstore it in sub-arena",	0);
	set_cmt	(0X9101,	"update Free ptr in UMB",	0);
	create_insn	(0X9108);
	set_cmt	(0X9116,	"Parses the command line for SIZE= command",	0);
	create_insn	(0X9116);
	set_name	(0X9116,	"ParseSize");
	set_cmt	(0X9119,	"init the value",	0);
	set_cmt	(0X912D,	"'SI'",	0);
	set_cmt	(0X9134,	"'ZE'",	0);
	set_cmt	(0X9143,	"cf=0 here",	0);
	set_cmt	(0X9154,	"cf=0 here",	0);
	set_cmt	(0X9159,	"cf=0 here (clc is not needed)\n22/07/2023 - Erdogan Tan",	0);
	create_insn	(0X915B);
	set_cmt	(0X915E,	"Skips delimiters in the string pointed to by ES:SI\nReturns ptr to first non-delimiter character in ES:SI",	0);
	create_insn	(0X915E);
	set_name	(0X915E,	"SkipDelim");
	create_insn	(0X9169);
	set_cmt	(0X916A,	"Converts an ascii string \nterminated by a delimiter into binary.\nAssumes that the ES:SI\npoints to a Hexadecimal string",	0);
	create_insn	(0X916A);
	set_name	(0X916A,	"GetHexNum");
	set_cmt	(0X9171,	"cr",	0);
	set_cmt	(0X9176,	"lf",	0);
	create_insn	(x=0X918C);
	op_hex		(x,	1);
	create_insn	(x=0X918E);
	op_hex		(x,	1);
	create_insn	(x=0X9197);
	op_dec		(x,	1);
	create_insn	(x=0X919D);
	op_hex		(x,	1);
	create_insn	(x=0X91A7);
	op_hex		(x,	1);
	create_insn	(x=0X91A9);
	op_hex		(x,	1);
	set_cmt	(0X91AD,	"AX = number of paras equivalent to the\nhex number of bytes specified \nby the hexadecimal string.",	0);
	set_cmt	(0X91AF,	"encountered a non-hex character or crlf",	0);
	create_insn	(0X91AF);
	set_cmt	(0X91B1,	"Convert one nibble (hex digit) in BL into binary",	0);
	create_insn	(0X91B1);
	set_name	(0X91B1,	"GetNibble");
	create_insn	(0X91BF);
	set_cmt	(0X91C9,	"'A'- 10",	0);
	create_insn	(0X91CD);
	set_cmt	(0X91CF,	"Allocate all UMBs and link it to DOS arena chain\nlink in the first UMB",	0);
	create_insn	(0X91CF);
	set_name	(0X91CF,	"AllocUMB");
	set_cmt	(0X91D2,	"quit on error",	0);
	set_cmt	(0X91D4,	"allocate",	0);
	set_cmt	(0X91D9,	"& insert till no UMBs",	0);
	set_cmt	(0X91DE,	"coalesce all UMBs",	0);
	create_insn	(0X91DE);
	create_insn	(0X91E2);
	set_name	(0X91E2,	"InitAllocUMB");
	set_cmt	(0X91E5,	"quit on no XMS driver",	0);
	create_insn	(x=0X91E7);
	op_hex		(x,	1);
	set_cmt	(0X91E9,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists",	0);
	create_insn	(x=0X91E9);
	op_hex		(x,	0);
	set_cmt	(0X91EB,	"save dos data segment",	0);
	set_cmt	(0X91F3,	"- Multiplex - XMS - GET DRIVER ADDRESS\nReturn: ES:BX -> driver entry point",	0);
	create_insn	(x=0X91F3);
	op_hex		(x,	0);
	set_cmt	(0X91F5,	"get XMS driver address",	0);
	set_cmt	(0X91FF,	"have we already linked a UMB?",	0);
	set_cmt	(0X9205,	"quit if we already did it",	0);
	set_cmt	(0X9207,	"else link the first UMB",	0);
	set_cmt	(0X920C,	"mark that 1st UMB linked",	0);
	set_cmt	(0X9212,	"(cf is already zero here)\nErdogan tan - 27/07/2023",	0);
	create_insn	(0X9214);
	create_insn	(0X9216);
	set_name	(0X9216,	"umb_allocate");
	set_cmt	(0X9217,	"XMM_REQUEST_UMB",	0);
	create_insn	(x=0X9217);
	op_dec		(x,	1);
	set_cmt	(0X9219,	"try to allocate largest possible",	0);
	create_insn	(x=0X9225);
	op_dec		(x,	1);
	set_cmt	(0X922C,	"Q: was the reqst successful",	0);
	set_cmt	(0X922F,	"N: error",	0);
	create_insn	(0X9234);
	set_cmt	(0X9237,	"links the UMB into the arena chain",	0);
	create_insn	(0X9237);
	set_name	(0X9237,	"umb_insert");
	set_cmt	(0X923D,	"[UMB_ARENA]  ; ds = UMB_HEAD",	0);
	set_cmt	(0X9245,	"BX = seg address of UMB to be linked in",	0);
	set_cmt	(0X9247,	"current block above new block, insert it",	0);
	set_cmt	(0X9249,	"[es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X924F,	"if current block is the last,\nappend new block to chain",	0);
	set_cmt	(0X9256,	"ax = es = next block",	0);
	set_cmt	(0X9258,	"ds = previous arena",	0);
	create_insn	(0X9258);
	set_cmt	(0X925A,	"top of previous block",	0);
	set_cmt	(0X925D,	"cx = size of used block",	0);
	set_cmt	(0X925F,	"[ARENA.SIGNATURE],arena_signature_normal",	0);
	set_cmt	(0X9264,	"[ARENA.OWNER],8 ; mark as system owned",	0);
	set_cmt	(0X926A,	"[ARENA.SIZE],cx",	0);
	set_cmt	(0X926E,	"[ARENA.NAME],'SC'",	0);
	set_cmt	(0X9274,	"prepare the arena at start of new block",	0);
	set_cmt	(0X9276,	"[es:ARENA.SIGNATURE],arena_signature_normal",	0);
	set_cmt	(0X927C,	"[es:ARENA.OWNER],arena_owner_system ; mark as free",	0);
	set_cmt	(0X9283,	"DX = size of UMB to be linked in paras\nmake room for arena at start & end of new block",	0);
	set_cmt	(0X9286,	"[es:ARENA.SIZE],dx",	0);
	set_cmt	(0X928B,	"prepare arena at end of new block",	0);
	set_cmt	(0X928E,	"es = arena at top of new block",	0);
	set_cmt	(0X9290,	"bx = top of new block",	0);
	set_cmt	(0X9291,	"ax contains arena just above this block\nresult: ax = size of used block",	0);
	set_cmt	(0X9293,	"[es:ARENA.SIGNATURE],arena_signature_normal",	0);
	set_cmt	(0X9299,	"[es:ARENA.OWNER],8 ; mark as system owned",	0);
	set_cmt	(0X92A0,	"[es:ARENA.SIZE],ax",	0);
	set_cmt	(0X92A4,	"[es:ARENA.NAME],'SC'",	0);
	set_cmt	(0X92AD,	"es = arena of last block\n[es:ARENA.SIZE] ; ax=top of last block-1 para",	0);
	create_insn	(0X92AD);
	set_cmt	(0X92B2,	"reserve space on top of this\nblock for the next arena.",	0);
	set_cmt	(0X92B8,	"[es:ARENA.SIGNATURE],arena_signature_normal",	0);
	set_cmt	(0X92BE,	"cx = top of prev block-1",	0);
	set_cmt	(0X92C1,	"ax = top of prev block - seg. addr of new block",	0);
	set_cmt	(0X92C5,	"es = arena of unused block",	0);
	set_cmt	(0X92C7,	"[es:ARENA.SIGNATURE],arena_signature_normal",	0);
	set_cmt	(0X92CD,	"[es:ARENA.OWNER],8 ; mark as system owned",	0);
	set_cmt	(0X92D4,	"mov [es:ARENA.SIZE],ax",	0);
	set_cmt	(0X92D8,	"mov word [es:ARENA.NAME],'SC'",	0);
	set_cmt	(0X92DF,	"prepare the arena at start of new block",	0);
	set_cmt	(0X92E1,	"[es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X92E7,	"[es:ARENA.OWNER],arena_owner_system\nmark as free",	0);
	set_cmt	(0X92EE,	"make room for arena",	0);
	set_cmt	(0X92EF,	"mov [es:ARENA.SIZE],dx",	0);
	set_cmt	(0X92F6,	"Combine free blocks ahead with current block",	0);
	create_insn	(0X92F6);
	set_name	(0X92F6,	"umb_coalesce");
	set_cmt	(0X92FD,	"[es:UMB_ARENA] ; es = UMB_HEAD",	0);
	set_cmt	(0X9306,	"[es:ARENA.OWNER],di\nQ: is current arena free",	0);
	set_cmt	(0X930B,	"Y: try to coalesce with next block\nN: get next arena",	0);
	set_cmt	(0X930D,	"es, ax = next arena",	0);
	set_cmt	(0X9314,	"es, ax = next arena",	0);
	create_insn	(0X9314);
	set_cmt	(0X9319,	"[es:ARENA.OWNER],di\nQ: is arena free",	0);
	set_cmt	(0X931E,	"N: get next free arena\nY: coalesce",	0);
	set_cmt	(0X9320,	"[es:ARENA.SIZE]\ncx = next block size",	0);
	set_cmt	(0X9325,	"cx = cx + 1 (for header size)",	0);
	set_cmt	(0X9326,	"[ARENA.SIZE],cx\ncurrent size = current size + cx",	0);
	set_cmt	(0X932A,	"move up signature",	0);
	set_cmt	(0X932F,	"try again",	0);
	create_insn	(0X9331);
	set_cmt	(0X9332,	"Find Next item in Arena\ncmp byte [ARENA.SIGNATURE],arena_signature_end",	0);
	create_insn	(0X9332);
	set_name	(0X9332,	"get_next");
	set_cmt	(0X9339,	"ax = current block",	0);
	set_cmt	(0X933B,	"add ax,[ARENA.SIZE]\nax = ax + current block length",	0);
	set_cmt	(0X933F,	"remember that header!",	0);
	create_insn	(0X9344);
	create_insn	(0X9346);
	set_name	(0X9346,	"LinkFirstUMB");
	set_cmt	(0X934B,	"MEMORY SIZE - \nReturn: AX = number of contiguous 1K blocks of memory",	0);
	create_insn	(x=0X934B);
	op_hex		(x,	0);
	set_cmt	(0X934F,	"ax = size in paragraphs",	0);
	set_cmt	(0X9353,	"bx = segment of allocated UMB\nax = - size of unused block",	0);
	set_cmt	(0X9357,	"cx = first umb_arena",	0);
	set_cmt	(0X935A,	"es = first umb_arena",	0);
	set_cmt	(0X935C,	"[es:ARENA.SIGNATURE],arena_signature_normal",	0);
	set_cmt	(0X9362,	"[es:ARENA.OWNER],8 ; mark as system owned",	0);
	set_cmt	(0X9369,	"mov [es:ARENA.SIZE],ax",	0);
	set_cmt	(0X936D,	"[es:ARENA.NAME],'SC'",	0);
	set_cmt	(0X9374,	"put in the arena for the first UMB\nes has first free umb seg",	0);
	set_cmt	(0X9376,	"[es:ARENA.SIGNATURE],arena_signature_end",	0);
	set_cmt	(0X937C,	"es:ARENA.OWNER],arena_owner_system\nmark as free",	0);
	set_cmt	(0X9383,	"dx = size of UMB\nmake room for arena",	0);
	set_cmt	(0X9384,	"[es:ARENA.SIZE],dx",	0);
	set_cmt	(0X938E,	"UMB_ARENA",	0);
	create_insn	(x=0X938E);
	op_hex		(x,	1);
	set_cmt	(0X9391,	"initialize umb_head in DOS data segment\nwith the arena just below Top of Memory\n\nwe must now scan the arena chain and\nupdate the size of the last arena",	0);
	set_cmt	(0X9394,	"DOS_ARENA",	0);
	create_insn	(x=0X9394);
	op_hex		(x,	1);
	set_cmt	(0X9397,	"es = start arena",	0);
	set_cmt	(0X939C,	"arena_signature_end",	0);
	set_cmt	(0X93A4,	"[es:ARENA.SIZE]",	0);
	set_cmt	(0X93AE,	"sub word [es:ARENA.SIZE],1",	0);
	create_insn	(0X93AE);
	set_cmt	(0X93B4,	"[es:ARENA.SIGNATURE],arena_signature_normal",	0);
	create_insn	(0X93BC);
	set_cmt	(0X93BE,	"Shrinks the current UMB in use, \nso that the unused portions of the UMB\nis given back to the DOS free mem pool",	0);
	create_insn	(0X93BE);
	set_name	(0X93BE,	"ShrinkUMB");
	create_insn	(x=0X93D7);
	op_hex		(x,	1);
	set_cmt	(0X93DA,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs",	0);
	create_insn	(x=0X93DA);
	op_hex		(x,	0);
	set_cmt	(0X93E1,	"[es:ARENA.OWNER]",	0);
	set_cmt	(0X93EB,	"Unlinks the UMBs from the DOS arena chain",	0);
	create_insn	(0X93EB);
	set_name	(0X93EB,	"UnlinkUMB");
	set_cmt	(0X93F3,	"nothing to unlink",	0);
	set_cmt	(0X93F5,	"get DOS data seg",	0);
	set_cmt	(0X93FA,	"[es:DOS_ARENA]",	0);
	set_cmt	(0X93FF,	"[es:UMB_ARENA]",	0);
	set_cmt	(0X9409,	"is the next one UMB ?",	0);
	set_cmt	(0X9411,	"[ARENA.SIGNATURE],arena_signature_end",	0);
	create_insn	(0X9411);
	create_byte	(0X9419);
	make_array	(0X9419,	0X2);
	create_insn	(0X941B);
	set_name	(0X941B,	"setparms");
	set_cmt	(0X9428,	"get it correct for ioctl call\n(1=A,2=A...)",	0);
	set_cmt	(0X942A,	"offset deviceparameters",	0);
	create_insn	(x=0X942A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X942D,	"IOCTL",	0);
	create_insn	(x=0X942D);
	op_hex		(x,	1);
	set_cmt	(0X942F,	"GENERIC_IOCTL",	0);
	create_insn	(x=0X942F);
	op_hex		(x,	1);
	set_cmt	(0X9431,	"RAWIO",	0);
	create_insn	(x=0X9431);
	op_dec		(x,	1);
	set_cmt	(0X9433,	"SET_DEVICE_PARAMETERS",	0);
	create_insn	(x=0X9433);
	op_hex		(x,	1);
	set_cmt	(0X9435,	"DOS - 2+ - IOCTL - ",	0);
	create_insn	(x=0X9435);
	op_hex		(x,	0);
	set_cmt	(0X9437,	"DOSBIODATASEG ; BIOSDATA segment",	0);
	create_insn	(x=0X9437);
	op_hex		(x,	1);
	set_cmt	(0X943C,	"flagec35",	0);
	create_insn	(x=0X943C);
	op_hex		(x,	1);
	set_cmt	(0X9445,	"which drive was this for?",	0);
	set_cmt	(0X944A,	"assume drive 0",	0);
	set_cmt	(0X944C,	"set proper bit depending on drive",	0);
	set_cmt	(0X944E,	"set the bit in the permanent flags",	0);
	create_insn	(x=0X944E);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X9452,	"mov al,[cs:deviceparameters+20]\n[cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n+A_BPB.BPB_SECTORSPERTRACK]",	0);
	create_insn	(x=0X9456);
	op_plain_offset	(x,	1,	0X5F0);
	op_plain_offset	(x,	129,	0X5F0);
	create_insn	(x=0X945C);
	op_plain_offset	(x,	0,	0X5F0);
	op_plain_offset	(x,	128,	0X5F0);
	set_cmt	(0X9465,	"replace default values for further drivparm commands",	0);
	create_insn	(0X9465);
	set_name	(0X9465,	"diddleback");
	set_cmt	(0X9468,	"[deviceparameters+4],80\n[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80",	0);
	create_insn	(x=0X9468);
	op_dec		(x,	1);
	set_cmt	(0X946E,	"[deviceparameters+1],2\n[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB",	0);
	set_cmt	(0X9473,	"[deviceparameters+2],0\n[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0",	0);
	set_cmt	(0X9479,	"zero all switches",	0);
	create_insn	(0X9481);
	set_name	(0X9481,	"parseline");
	set_cmt	(0X9484,	"al contains the first character in command line.",	0);
	set_cmt	(0X9486,	"cr",	0);
	set_cmt	(0X948A,	"lf ; put it back and done",	0);
	set_cmt	(0X948E,	"skip over space",	0);
	set_cmt	(0X9494,	"mark error invalid-character-in-input",	0);
	create_insn	(0X9497);
	set_cmt	(0X949A,	"save switches read so far",	0);
	set_cmt	(0X94A7,	"exit if error",	0);
	create_insn	(0X94A7);
	set_cmt	(0X94A9,	"flagdrive ; see if drive specified",	0);
	create_insn	(x=0X94A9);
	op_hex		(x,	1);
	set_cmt	(0X94B1,	"mark error no-drive-specified",	0);
	create_insn	(0X94B4);
	set_cmt	(0X94B7,	"get flag bits for changeline and non-rem",	0);
	create_insn	(x=0X94B7);
	op_hex		(x,	1);
	set_cmt	(0X94BA,	"[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]",	0);
	set_cmt	(0X94BD,	"[deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]",	0);
	create_insn	(x=0X94BD);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X94C3,	"everything is fine",	0);
	set_cmt	(0X94C9,	"one more char to scan",	0);
	create_insn	(x=0X94C9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X94CD,	"back up over linefeed",	0);
	create_insn	(x=0X94CD);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X94D3);
	set_name	(0X94D3,	"check_switch");
	set_cmt	(0X94D8,	"convert it to upper case",	0);
	create_insn	(x=0X94D8);
	op_hex		(x,	1);
	set_cmt	(0X94E5,	"get number of valid switches",	0);
	create_insn	(x=0X94E5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X94E9,	"point to string of valid switches",	0);
	create_insn	(x=0X94EB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X94F6,	"set bit to indicate switch",	0);
	set_cmt	(0X94F8,	"get switches so far",	0);
	create_insn	(x=0X94F8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X94FC,	"save this with other switches",	0);
	set_cmt	(0X9500,	"switchnum ; 0F8h\ntest against switches that require number to follow",	0);
	create_insn	(x=0X9500);
	op_hex		(x,	1);
	create_insn	(x=0X950A);
	op_chr		(x,	1);
	set_cmt	(0X9511,	"preserve switches",	0);
	set_cmt	(0X9512,	"allow space separators",	0);
	set_cmt	(0X9521,	"restore switches",	0);
	set_cmt	(0X9527,	"remove this switch from the records",	0);
	create_insn	(0X9527);
	set_cmt	(0X952B,	"if this switch has been done before,",	0);
	create_insn	(x=0X952B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0X952B,	"process_num");
	set_cmt	(0X952F,	"ignore this one.",	0);
	set_cmt	(0X9531,	"flagdrive",	0);
	create_insn	(x=0X9531);
	op_hex		(x,	1);
	create_insn	(x=0X9537);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X953C,	"flagff",	0);
	create_insn	(x=0X953C);
	op_hex		(x,	1);
	create_insn	(x=0X9542);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9547,	"if number entered was 0, assume default value",	0);
	create_insn	(0X9547);
	set_cmt	(0X954B,	"flagcyln",	0);
	create_insn	(x=0X954B);
	op_hex		(x,	1);
	set_cmt	(0X9551,	"[deviceparameters+4],ax\n[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]",	0);
	create_insn	(x=0X9551);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9556,	"flagseclim",	0);
	create_insn	(x=0X9556);
	op_hex		(x,	1);
	set_cmt	(0X955A,	"must be for number of heads",	0);
	create_insn	(x=0X955C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9561);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9564,	"(test instruction resets cf)",	0);
	create_insn	(0X9566);
	set_name	(0X9566,	"setdeviceparameters");
	set_cmt	(0X956B,	"[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]",	0);
	create_insn	(x=0X956B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X956F,	"DEV_5INCH",	0);
	set_cmt	(0X9574,	"[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]\n48 tpi = 40 cyl",	0);
	create_insn	(x=0X9574);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_dec		(x,	1);
	set_cmt	(0X957A,	"get index into bpb table",	0);
	create_insn	(x=0X957A);
	op_hex		(x,	1);
	set_name	(0X957A,	"got_80");
	set_cmt	(0X957C,	"get address of bpb",	0);
	create_insn	(x=0X957C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9580,	"deviceparameters+7  \ndeviceparameters+A_DEVICEPARAMETERS.DP_BPB\nes:di -> bpb",	0);
	create_insn	(x=0X9580);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9583,	"A_BPB.size",	0);
	create_insn	(x=0X9583);
	op_dec		(x,	1);
	set_cmt	(0X958A,	"flagseclim",	0);
	create_insn	(x=0X958A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0X9592);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9595,	"[deviceparameters+20]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERTRACK]",	0);
	create_insn	(x=0X9595);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9598,	"flagheads",	0);
	create_insn	(x=0X9598);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0X95A0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X95A3,	"[deviceparameters+22]   \n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]",	0);
	create_insn	(x=0X95A3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95A6,	"[deviceparameters+9],2\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB   \n +A_BPB.BPB_SECTORSPERCLUSTER]",	0);
	create_insn	(x=0X95A6);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95AB,	"get default mediabyte",	0);
	set_cmt	(0X95AD,	"[deviceparameters+17]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]",	0);
	create_insn	(x=0X95AD);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X95B1);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95B6,	"just use default if heads>2",	0);
	set_cmt	(0X95B8,	"one head, do one head stuff",	0);
	set_cmt	(0X95BC,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERTRACK]",	0);
	create_insn	(x=0X95BC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_dec		(x,	1);
	set_cmt	(0X95C3,	"[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]",	0);
	create_insn	(x=0X95C3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_dec		(x,	1);
	set_cmt	(0X95CA,	"cyl=80, heads=2, secpertrack=18.\n Set cluster size to 1.",	0);
	set_cmt	(0X95CC,	"check for 320K",	0);
	create_insn	(x=0X95CC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_dec		(x,	1);
	create_insn	(x=0X95D3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95DE,	"[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH",	0);
	create_insn	(x=0X95DE);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95E5,	"single sided 9 sector media id",	0);
	set_cmt	(0X95E7,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n+A_BPB.BPB_SECTORSPERTRACK],8",	0);
	create_insn	(x=0X95E7);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95EC,	"okay if anything besides 8",	0);
	set_cmt	(0X95EE,	"160K mediaid",	0);
	set_cmt	(0X95F0,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERCLUSTER],1",	0);
	create_insn	(x=0X95F0);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95F5,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_MEDIADESCRIPTOR],bl",	0);
	create_insn	(x=0X95F5);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X95F9,	"[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]",	0);
	create_insn	(x=0X95F9);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X95FC,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]",	0);
	create_insn	(x=0X95FC);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9600,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]",	0);
	create_insn	(x=0X9600);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9604,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]",	0);
	create_insn	(x=0X9604);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X9609);
	set_name	(0X9609,	"organize");
	set_cmt	(0X961F,	"found a comment string and skipped.",	0);
	set_cmt	(0X9621,	"not a comment string. then get a char.",	0);
	set_cmt	(0X9624,	"lf",	0);
	set_cmt	(0X9626,	"starts with a blank line.",	0);
	set_cmt	(0X962A,	"skip leading control characters",	0);
	set_cmt	(0X962E,	"store line feed char in buffer for the linecount.",	0);
	create_insn	(0X962E);
	set_cmt	(0X962F,	"reset the command level.",	0);
	create_insn	(0X9637);
	set_cmt	(0X9639,	"prepare to search command table",	0);
	create_insn	(0X9639);
	create_insn	(x=0X963F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X964B,	"CONFIG_SEMICOLON",	0);
	set_cmt	(0X9655,	"~20h ; force upper case",	0);
	create_insn	(x=0X9655);
	op_hex		(x,	1);
	set_cmt	(0X9658,	"compare to byte @es:di",	0);
	set_cmt	(0X965E,	"bump to next position without affecting flags",	0);
	set_cmt	(0X9664,	"the next char might be cr,lf",	0);
	set_cmt	(0X966A,	"such as in \"rem\",cr,lf case.",	0);
	set_cmt	(0X9670,	"CONFIG_BEGIN",	0);
	set_cmt	(0X9675,	"now the next char. should be a delim.",	0);
	set_cmt	(0X9678,	"explicit interactive command?",	0);
	set_cmt	(0X967A,	"no",	0);
	set_cmt	(0X967C,	"yes, so retrieve the original code",	0);
	set_cmt	(0X967D,	"CONFIG_OPTION_QUERY ; and set the QUERY bit",	0);
	create_insn	(x=0X967D);
	op_hex		(x,	1);
	set_cmt	(0X9681,	"CONFIG_REM",	0);
	create_insn	(0X9681);
	create_insn	(0X9685);
	create_insn	(0X9690);
	set_cmt	(0X9693,	"CONFIG_UNKNOWN",	0);
	set_cmt	(0X9695,	"save indicator char.",	0);
	set_cmt	(0X9699,	"lf ; skip this bad command line",	0);
	set_cmt	(0X969F,	"save indicator char in buffer",	0);
	create_insn	(0X969F);
	set_cmt	(0X96A0,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0X96A0);
	op_hex		(x,	1);
	set_cmt	(0X96A2,	"save it for the future use.",	0);
	set_cmt	(0X96A6,	"CONFIG_BEGIN",	0);
	set_cmt	(0X96AA,	"CONFIG_SUBMENU",	0);
	set_cmt	(0X96AE,	"CONFIG_MENUITEM",	0);
	set_cmt	(0X96B2,	"CONFIG_MENUDEFAULT",	0);
	set_cmt	(0X96B6,	"CONFIG_INCLUDE",	0);
	set_cmt	(0X96BA,	"map case of rest of line to UPPER",	0);
	set_cmt	(0X96BD,	"skip the command name until delimiter",	0);
	set_cmt	(0X96C0,	"lf",	0);
	set_cmt	(0X96C4,	"cr",	0);
	set_cmt	(0X96C8,	"Added to allow DEVHIGH/L:...",	0);
	set_cmt	(0X96CA,	"to be parsed properly",	0);
	set_cmt	(0X96D3,	"if cr or lf then",	0);
	create_insn	(0X96D3);
	set_cmt	(0X96D4,	"undo si, cx register and continue",	0);
	set_cmt	(0X96D5,	"CONFIG_COMMENT",	0);
	set_cmt	(0X96DD,	"CONFIG_DEVICE",	0);
	set_cmt	(0X96E5,	"CONFIG_INSTALL",	0);
	set_cmt	(0X96ED,	"CONFIG_INSTALLHIGH",	0);
	set_cmt	(0X96F5,	"CONFIG_SHELL",	0);
	set_cmt	(0X96FD,	"CONFIG_SWITCHES",	0);
	create_insn	(0X9708);
	set_cmt	(0X9719,	"get the filename and put 0 at end",	0);
	create_insn	(0X9719);
	set_cmt	(0X971E,	"not a comment",	0);
	set_cmt	(0X9724,	"skip the possible delimiters",	0);
	set_cmt	(0X9726,	"copy the first non delim char found in buffer",	0);
	set_cmt	(0X9727,	"comment char in the filename?",	0);
	set_cmt	(0X972A,	"then stop copying filename at that point",	0);
	set_cmt	(0X972F,	"a switch char? (device=filename/xxx)",	0);
	set_cmt	(0X9731,	"this will be the special case.",	0);
	set_cmt	(0X9733,	"save the char. in buffer",	0);
	set_cmt	(0X973B,	"keep copying",	0);
	set_cmt	(0X973D,	"otherwise, assume end of the filename.",	0);
	set_cmt	(0X973F,	"get the token. just max. 2 char.",	0);
	create_insn	(0X973F);
	set_cmt	(0X9742,	"skip white spaces or \"=\" char.",	0);
	set_cmt	(0X9744,	"(we are allowing the other special",	0);
	set_cmt	(0X9746,	"characters can used for comment id.",	0);
	set_cmt	(0X9748,	"character.)",	0);
	set_cmt	(0X974A,	"= is special in this case.",	0);
	set_cmt	(0X9750,	"cannot accept the carriage return",	0);
	set_cmt	(0X9756,	"store it",	0);
	set_cmt	(0X975A,	"1 char. so far.",	0);
	set_cmt	(0X9763,	"space",	0);
	set_cmt	(0X9767,	"tab",	0);
	set_cmt	(0X976B,	"cr",	0);
	set_cmt	(0X976F,	"lf",	0);
	set_cmt	(0X977F,	"lf",	0);
	set_cmt	(0X9781,	"skip it.",	0);
	set_cmt	(0X9783,	"else jmp to end_commd_line",	0);
	set_cmt	(0X9786,	"make the filename in front of\nthe comment string to be an asciiz.",	0);
	create_insn	(0X9786);
	set_cmt	(0X978B,	"(maybe null if device=/*)",	0);
	set_cmt	(0X978E,	"al = \"/\" option char.\nmake a filename an asciiz",	0);
	create_insn	(0X978E);
	set_cmt	(0X9792,	"and",	0);
	set_cmt	(0X9793,	"store \"/\" after that.",	0);
	set_cmt	(0X9794,	"continue with the rest of the line",	0);
	set_cmt	(0X9796,	"make it an asciiz and handle the next char.",	0);
	create_insn	(0X9796);
	set_cmt	(0X979B,	"lf",	0);
	set_cmt	(0X97A1,	"org4 skips all delimiters\nafter the command name except for '/'",	0);
	create_insn	(0X97A1);
	set_cmt	(0X97A9,	"skip delimiters except '/'",	0);
	set_cmt	(0X97B0,	"rest of the line is",	0);
	create_insn	(0X97B0);
	set_cmt	(0X97B3,	"comment.",	0);
	set_cmt	(0X97B5,	"not a comment.",	0);
	set_cmt	(0X97B8,	"copy the character",	0);
	set_cmt	(0X97B9,	"a quote ?",	0);
	set_cmt	(0X97BD,	"cmp al,0Ah\njne short org5\njmp org1 (Erdogan Tan - 28/07/2023)",	0);
	set_cmt	(0X97C1,	"cmp al,lf",	0);
	create_insn	(0X97C7);
	create_insn	(0X97CA);
	set_cmt	(0X97D2,	"reset it",	0);
	set_cmt	(0X97DA,	"set it",	0);
	create_insn	(0X97DA);
	create_insn	(0X97E1);
	set_name	(0X97E1,	"get2");
	set_cmt	(0X97E7,	"This was the rather kludgy way\nout of procedure \"organize\", \nbut instead of returning to doconf,\nwe now want to check config.sys BEGIN/END blocks\nand the new boot menu stuff",	0);
	create_insn	(0X97E7);
	set_name	(0X97E7,	"noget");
	set_cmt	(0X97FE,	"get out of the organize routine.\n...\nskip the commented string until lf,\nif current es:si-> a comment string.\n...",	0);
	create_insn	(0X97FE);
	set_name	(0X97FE,	"skip_comment");
	set_cmt	(0X9800,	"only check it if parameter level is 0.",	0);
	set_cmt	(0X9806,	"(not inside quotations)",	0);
	set_cmt	(0X982D,	"get out of organize routine.",	0);
	set_cmt	(0X9834,	"lf ; line feed ?",	0);
	set_cmt	(0X9839,	"wait for keystroke",	0);
	create_insn	(x=0X9839);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_name	(0X9839,	"kbd_read");
	set_cmt	(0X983E,	"\nthe bios timer tick count is incremented\n18.2 times per second;\nwatch the timer tick count for 37 transitions\nget initial value",	0);
	set_cmt	(0X9845,	"peek the keyboard",	0);
	set_cmt	(0X9847,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer",	0);
	create_insn	(x=0X9847);
	op_hex		(x,	0);
	set_cmt	(0X984D,	"KEYBOARD - GET SHIFT STATUS\nAL = shift status bits",	0);
	create_insn	(x=0X984D);
	op_hex		(x,	0);
	set_cmt	(0X984F,	"either right or left shift key bits set?",	0);
	create_insn	(x=0X984F);
	op_hex		(x,	1);
	set_cmt	(0X9851,	"yes",	0);
	set_cmt	(0X9853,	"system timer, lw",	0);
	create_insn	(x=0X9853);
	set_cmt	(0X9856,	"get difference",	0);
	set_cmt	(0X985B,	"reached limit? ; (2 seconds)",	0);
	create_insn	(x=0X985B);
	op_dec		(x,	1);
	set_cmt	(0X9860,	"delay complete!",	0);
	set_cmt	(0X9861,	"assume clean boot",	0);
	set_cmt	(0X9863,	"peek the shift states",	0);
	set_cmt	(0X9865,	"KEYBOARD - GET SHIFT STATUS\nAL = shift status bits",	0);
	create_insn	(x=0X9865);
	op_hex		(x,	0);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_6(void) {
        auto x;
#define id x

	set_cmt	(0X9867,	"either right or left shift key bits set?",	0);
	create_insn	(x=0X9867);
	op_hex		(x,	1);
	set_cmt	(0X9869,	"no",	0);
	set_cmt	(0X986B,	"yes",	0);
	create_insn	(x=0X986D);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9872,	"peek the keyboard",	0);
	set_cmt	(0X9874,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer",	0);
	create_insn	(x=0X9874);
	op_hex		(x,	0);
	set_cmt	(0X9876,	"no key present",	0);
	set_cmt	(0X9878,	"is it a function key?",	0);
	set_cmt	(0X987A,	"no",	0);
	set_cmt	(0X987C,	"CTRL F5",	0);
	create_insn	(x=0X987C);
	op_hex		(x,	1);
	set_cmt	(0X9881,	"F5 function key?",	0);
	create_insn	(x=0X9881);
	op_hex		(x,	1);
	set_cmt	(0X9884,	"no",	0);
	create_insn	(x=0X9886);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X988C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9891,	"yes, clean boot selected",	0);
	set_cmt	(0X9893,	"CTRL F8",	0);
	create_insn	(x=0X9893);
	op_hex		(x,	1);
	set_cmt	(0X9898,	"F8",	0);
	create_insn	(x=0X9898);
	op_hex		(x,	1);
	create_insn	(x=0X989D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X98A3,	"yes, interactive-boot option enabled",	0);
	set_cmt	(0X98A5,	"change default setting",	0);
	create_insn	(x=0X98A5);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X98A9,	"eat the key we assumed was a signal",	0);
	set_cmt	(0X98AB,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character",	0);
	create_insn	(x=0X98AB);
	op_hex		(x,	0);
	set_cmt	(0X98AD,	"-1",	0);
	create_insn	(x=0X98AD);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X98BB,	"yes, tell COMMAND to skip autoexec.bat",	0);
	set_cmt	(0X98BE,	"set carry to indicate abort",	0);
	set_cmt	(0X98C0,	"clear carry to indicate success",	0);
	create_insn	(0X98C0);
	set_cmt	(0X98C2,	"set numlock LED",	0);
	create_insn	(0X98C2);
	set_name	(0X98C2,	"set_numlock");
	set_cmt	(0X98C4,	"8042 keyboard controller status register\n7:  PERR    1=parity error in data received from keyboard\n   +----------- AT Mode ----------+------------ PS/2 Mode ------------+\n6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|\n5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |\n   +------------------------------+-----------------------------------+\n4:  INH     0=keyboard communications inhibited\n3:  A2      0=60h was the port last written to, 1=64h was last\n2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot\n1:  IBF     1=input buffer full (keyboard can't accept data)\n0:  OBF     1=output buffer full (data from keyboard is available)",	0);
	create_insn	(x=0X98C4);
	op_hex		(x,	1);
	create_insn	(x=0X98C6);
	op_hex		(x,	1);
	set_cmt	(0X98C8,	"keyboard communications inhibited",	0);
	set_cmt	(0X98CE,	"get 1st 2 bytes of value (ON or OF)",	0);
	set_cmt	(0X98D8,	"~20h ; turn it off",	0);
	create_insn	(x=0X98D8);
	op_hex		(x,	1);
	create_insn	(0X98DF);
	set_cmt	(0X98E7,	"turn it on",	0);
	create_insn	(x=0X98E7);
	op_hex		(x,	1);
	set_cmt	(0X98EF,	"Search for SWITCHES,\ndetermine if /N or /F are present;\nif so, then disable clean/interactive boot options",	0);
	create_insn	(0X98EF);
	set_name	(0X98EF,	"menu_check");
	set_cmt	(0X98F1,	"remains ZERO until first block",	0);
	set_cmt	(0X98F3,	"get first char of current line",	0);
	set_cmt	(0X98F6,	"hit eof",	0);
	set_cmt	(0X98F8,	"CONFIG_BEGIN",	0);
	set_cmt	(0X98FC,	"remember that we've seen a block",	0);
	set_cmt	(0X98FF,	"CONFIG_NUMLOCK",	0);
	create_insn	(0X98FF);
	set_cmt	(0X9903,	"only do NUMLOCK commands that exist",	0);
	set_cmt	(0X9905,	"before the first block",	0);
	set_cmt	(0X9907,	"REM it out so we don't act on it later, too",	0);
	set_cmt	(0X990A,	"CONFIG_REM",	0);
	set_cmt	(0X9911,	"CONFIG_SWITCHES",	0);
	create_insn	(0X9911);
	set_cmt	(0X9913,	"this line ain't it",	0);
	set_cmt	(0X9915,	"look for /N or /F",	0);
	set_cmt	(0X9918,	"LF ; end of line ?",	0);
	set_cmt	(0X991C,	"switch-char?",	0);
	set_cmt	(0X991E,	"no",	0);
	set_cmt	(0X9923,	"~20h ; convert to upper case",	0);
	create_insn	(x=0X9923);
	op_hex		(x,	1);
	create_insn	(x=0X9925);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9929,	"no",	0);
	create_insn	(x=0X992B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9930,	"continue looking for switches of interest",	0);
	create_insn	(x=0X9932);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9936,	"no",	0);
	create_insn	(x=0X9938);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X993D,	"continue looking for switches of interest",	0);
	create_insn	(0X993F);
	create_insn	(0X9944);
	set_cmt	(0X9945,	"\nDo the keyboard tests for clean/interactive boot now,\nbut only if the DisableUI flag is still clear",	0);
	create_insn	(x=0X9946);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X994B,	"\nWait for 2 seconds first, \nUNLESS the /F bit was set in bDisableUI, or\nthere is anything at all in the keyboard buffer",	0);
	set_cmt	(0X9955,	"Search for MENU block; \nit is allowed to be anywhere in config.sys",	0);
	create_insn	(0X9955);
	create_insn	(x=0X9957);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X995A,	"find the MENU block\nif no MENU, default to zero for no_selection",	0);
	create_insn	(x=0X995F);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9964,	"not found",	0);
	set_cmt	(0X9967,	"Process the requested menu color(s)",	0);
	create_insn	(0X9967);
	set_cmt	(0X9969,	"default color setting",	0);
	set_cmt	(0X996C,	"get first number",	0);
	set_cmt	(0X996F,	"first # is foreground color (for low nibble)",	0);
	create_insn	(x=0X996F);
	op_hex		(x,	1);
	set_cmt	(0X9972,	"save it in CH",	0);
	create_insn	(x=0X9974);
	op_hex		(x,	1);
	set_cmt	(0X9979,	"did we hit a delimiter",	0);
	set_cmt	(0X997C,	"no, all done",	0);
	set_cmt	(0X997E,	"get next number",	0);
	set_cmt	(0X9981,	"second # is background color (for high nibble)",	0);
	create_insn	(x=0X9981);
	op_hex		(x,	1);
	set_cmt	(0X9984,	"save it in DH",	0);
	create_insn	(x=0X9986);
	op_hex		(x,	1);
	set_cmt	(0X998F,	"are foreground/background the same?",	0);
	set_cmt	(0X9991,	"no",	0);
	set_cmt	(0X9993,	"yes, so modify the fgnd intensity",	0);
	create_insn	(x=0X9993);
	op_hex		(x,	1);
	create_insn	(x=0X9996);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X999F);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X99A4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X99AA,	"-1",	0);
	create_insn	(x=0X99AA);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X99AF,	"~2",	0);
	create_insn	(x=0X99AF);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X99B4,	"skip to next line",	0);
	set_cmt	(0X99B7,	"initialize total block count (0 => none yet)",	0);
	set_cmt	(0X99B9,	"get first char of current line",	0);
	set_cmt	(0X99BC,	"could happen if menu block at end (rare)",	0);
	set_cmt	(0X99BE,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0X99BE);
	op_hex		(x,	1);
	set_cmt	(0X99C0,	"CONFIG_BEGIN",	0);
	set_cmt	(0X99C2,	"BEGIN implies END",	0);
	set_cmt	(0X99C4,	"CONFIG_SUBMENU",	0);
	set_cmt	(0X99C6,	"go process sub-menu",	0);
	set_cmt	(0X99C8,	"CONFIG_MENUITEM",	0);
	set_cmt	(0X99CA,	"go process menu item",	0);
	set_cmt	(0X99CC,	"CONFIG_MENUDEFAULT",	0);
	set_cmt	(0X99CE,	"go process menu default",	0);
	set_cmt	(0X99D0,	"CONFIG_MENUCOLOR",	0);
	set_cmt	(0X99D2,	"go process menu color",	0);
	set_cmt	(0X99D4,	"CONFIG_NUMLOCK",	0);
	set_cmt	(0X99D8,	"CONFIG_REM",	0);
	set_cmt	(0X99DA,	"allow remarks in menu block",	0);
	set_cmt	(0X99DC,	"allow blank lines and such",	0);
	set_cmt	(0X99E2,	"non-MENU command!",	0);
	create_insn	(0X99E7);
	create_insn	(0X99EC);
	set_cmt	(0X99EE,	"save address of default block name",	0);
	create_insn	(x=0X99EE);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X99F2);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X99F7,	"secElapsed is only zero for the FIRST menu,",	0);
	set_cmt	(0X99F9,	"and for subsequent menus IF nothing was typed;",	0);
	set_cmt	(0X99FC,	"secElapsed becomes -1 forever as soon as",	0);
	set_cmt	(0X99FE,	"something is typed",	0);
	set_cmt	(0X9A05,	"get number (of seconds for timeout)",	0);
	set_cmt	(0X9A08,	"limit it to a reasonable number",	0);
	create_insn	(x=0X9A08);
	op_dec		(x,	1);
	set_cmt	(0X9A0B,	"(besides, 99 is the largest # my simple",	0);
	create_insn	(x=0X9A0D);
	op_dec		(x,	1);
	create_insn	(x=0X9A0F);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9A15,	"MAX_MULTI_CONFIG\nhave we reached the max # of items yet?",	0);
	create_insn	(0X9A15);
	set_cmt	(0X9A1A,	"DS:DI -> block name to search for",	0);
	set_cmt	(0X9A1F,	"srch_block, having succeeded,\nreturns DI -> past the token that it just matched,\nwhich in this case should be a descriptive string;\nES:SI and CX are unmodified",	0);
	set_cmt	(0X9A22,	"print error and pause",	0);
	set_cmt	(0X9A25,	"if not found, ignore this menu item",	0);
	set_cmt	(0X9A27,	"otherwise, increment total block count",	0);
	create_insn	(0X9A27);
	set_cmt	(0X9A28,	"and use it to index the arrays of offsets",	0);
	create_insn	(x=0X9A2A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9A2E,	"of recorded block names and descriptions",	0);
	set_cmt	(0X9A30,	"\nThere should be a description immediately following\nthe block name on MENUITEM line; failing that,\nwe'll just use the block name as the description...",	0);
	create_insn	(x=0X9A30);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9A34);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9A38,	"skip_delim modifies BX, so stash it in DI",	0);
	set_cmt	(0X9A3D,	"hit eol/eof",	0);
	set_cmt	(0X9A42,	"hit eol/eof",	0);
	create_insn	(x=0X9A46);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9A4D,	"go back for more lines",	0);
	set_cmt	(0X9A50,	"Display menu items now, \nafter determining which one is default\n\nwhere there any valid blocks at all?",	0);
	create_insn	(0X9A50);
	set_cmt	(0X9A52,	"yes",	0);
	set_cmt	(0X9A54,	"no, so force autoselect of 0",	0);
	set_cmt	(0X9A56,	"(meaning: process common blocks only)",	0);
	create_insn	(0X9A59);
	set_cmt	(0X9A5B,	"first, record how many blocks we found",	0);
	create_insn	(x=0X9A5B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9A5F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9A63,	"does a default block exist?",	0);
	set_cmt	(0X9A65,	"no",	0);
	set_cmt	(0X9A67,	"yes, walk name table, looking for default",	0);
	create_insn	(x=0X9A6B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9A6F,	"arbitrary maximum length of a name",	0);
	create_insn	(x=0X9A6F);
	op_dec		(x,	1);
	set_cmt	(0X9A75,	"is this block the same as the default?",	0);
	set_cmt	(0X9A7A,	"yes",	0);
	set_cmt	(0X9A7D,	"all done searching?",	0);
	create_insn	(x=0X9A7D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9A81,	"not yet",	0);
	set_cmt	(0X9A83,	"if no default, force default to #1",	0);
	set_cmt	(0X9A85,	"yes, this will be the initial current block\n\nIf the timeout was explicitly set to 0 (or technically,\nanything that failed to resolve to a number, like \"NONE\"\nor \"EAT POTATOES\"), then we're supposed to skip menu display\nand run with the specified default block; however,\nif the user hit Enter prior to boot, thereby requesting fully\nINTERACTIVE boot, then we shall display the menu block anyway\n(though still with no timeout)",	0);
	create_insn	(x=0X9A85);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9A89,	"is timeout zero? (ie, assume default)",	0);
	create_insn	(x=0X9A89);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9A8E,	"no",	0);
	set_cmt	(0X9A90,	"yes, but was INTERACTIVE requested?",	0);
	create_insn	(x=0X9A90);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9A95,	"yes, so *don't* assume default after all",	0);
	set_cmt	(0X9A9A,	"Reset the mode,\nso that we know screen is clean and cursor is home\n;",	0);
	create_insn	(0X9A9A);
	set_cmt	(0X9A9C,	"- VIDEO - GET CURRENT VIDEO MODE\nReturn: AH = number of columns on screen\nAL = current video mode\nBH = current active display page",	0);
	create_insn	(x=0X9A9C);
	op_hex		(x,	0);
	set_cmt	(0X9AA0,	"- VIDEO - SET VIDEO MODE\nAL = mode",	0);
	create_insn	(x=0X9AA0);
	op_hex		(x,	0);
	set_cmt	(0X9AA3,	"reach down into the ROM BIOS data area",	0);
	create_insn	(x=0X9AA3);
	op_hex		(x,	1);
	set_cmt	(0X9AA6,	"and save the current (default) video page",	0);
	set_cmt	(0X9AA8,	"start address and page #, in case the",	0);
	create_insn	(x=0X9AA8);
	set_cmt	(0X9AAC,	"undocumented QUIET option was enabled",	0);
	create_insn	(x=0X9AAC);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9AAF);
	create_insn	(x=0X9AB3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9AB6,	"select new page for menu",	0);
	create_insn	(x=0X9AB6);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9AB9,	"- VIDEO - ",	0);
	create_insn	(x=0X9AB9);
	op_hex		(x,	0);
	set_cmt	(0X9ABB,	"clear entire screen",	0);
	set_cmt	(0X9ABE,	"using this color",	0);
	create_insn	(x=0X9ABE);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9AC2,	"upper left row/col",	0);
	set_cmt	(0X9AC4,	"[es:CRT_Cols]",	0);
	create_insn	(x=0X9AC4);
	set_cmt	(0X9ACB,	"[es:CRT_Rows]",	0);
	create_insn	(x=0X9ACB);
	set_cmt	(0X9AD0,	"# of rows valid?",	0);
	set_cmt	(0X9AD2,	"hopefully",	0);
	set_cmt	(0X9AD4,	"no, use a default",	0);
	create_insn	(x=0X9AD4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9AD8,	"clear the screen using the req. attribute\n\n- VIDEO - SCROLL PAGE UP\nAL = number of lines to scroll window (0 = blank whole window)\nBH = attributes to be used on blanked lines\nCH,CL = row,column of upper left corner of window to scroll\nDH,DL = row,column of lower right corner of window",	0);
	create_insn	(x=0X9AD8);
	op_hex		(x,	0);
	set_cmt	(0X9ADB,	"save DH",	0);
	create_insn	(x=0X9ADB);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9ADF);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9AE2,	"cursor now on row 3 (numbered from 0)",	0);
	create_insn	(x=0X9AE5);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0X9AEC);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9AF0,	"restore DH",	0);
	create_insn	(x=0X9AF0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9AF4,	"print the status line on row DH, col 0,",	0);
	set_cmt	(0X9AF6,	"now that we can trash the cursor position",	0);
	set_cmt	(0X9AF8,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9AF8);
	op_hex		(x,	0);
	create_insn	(x=0X9AFA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B00,	"get cursor position",	0);
	set_cmt	(0X9B02,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line",	0);
	create_insn	(x=0X9B02);
	op_hex		(x,	0);
	set_cmt	(0X9B07,	"save column where status char will go",	0);
	create_insn	(x=0X9B07);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9B0B,	"now prepare to display all the menu items",	0);
	set_cmt	(0X9B0E,	"print item #BL",	0);
	set_cmt	(0X9B11,	"why \"inc bx\"? because it's a 1-byte opcode",	0);
	set_cmt	(0X9B12,	"all done?",	0);
	create_insn	(x=0X9B12);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B16,	"not yet",	0);
	set_cmt	(0X9B18,	"Set cursor position to just below the menu items\ncolumn 0",	0);
	set_cmt	(0X9B1C,	"select row below menu",	0);
	create_insn	(x=0X9B1F);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B23,	"set cursor position beneath the block list",	0);
	set_cmt	(0X9B25,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9B25);
	op_hex		(x,	0);
	create_insn	(x=0X9B27);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B2D,	"make a selection, return # in BX",	0);
	create_insn	(x=0X9B30);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X9B36);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9B3A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9B3F,	"clear the status line now",	0);
	set_cmt	(0X9B42,	"\nNow begins the \"re-organization\" process...",	0);
	create_insn	(x=0X9B42);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9B46,	"-1 ; clean boot requested?",	0);
	set_cmt	(0X9B53,	"-2 ; back to top-level menu?",	0);
	create_insn	(0X9B53);
	set_cmt	(0X9B56,	"no",	0);
	set_cmt	(0X9B58,	"yes, start all over",	0);
	create_insn	(x=0X9B58);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B61,	"CONFIG_SUBMENU",	0);
	create_insn	(x=0X9B61);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0X9B6A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B6E,	"THIS CANNOT FAIL!",	0);
	set_cmt	(0X9B73,	"ES:SI and CX are ready for another round",	0);
	set_cmt	(0X9B78,	"get BX -> name of selected block",	0);
	create_insn	(0X9B78);
	set_cmt	(0X9B7A,	"\nBX should now either be ZERO\n(meaning no block has been selected) or the offset\nrelative to ES of the block name to be processed\n(along with all the \"common\" lines of course)",	0);
	create_insn	(x=0X9B7A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B7E,	"save selection",	0);
	create_insn	(x=0X9B7E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9B82,	"reset ES:SI and CX for reprocessing",	0);
	create_insn	(x=0X9B82);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B89,	"this is where we'll store new config.sys image",	0);
	create_insn	(x=0X9B89);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9B8D,	"\nES:SI-> config.sys, DS:DI -> new config.sys workspace\n\nWork our way through the config.sys image again, this time copying\nall lines that are (A) \"common\" lines outside any block or (B) lines\nwithin the requested block. Lines inside INCLUDEd blocks are \ntransparently copied by copy_block in a recursive fashion;\nthe amount of recursion is limited by the fact INCLUDE statements are\nREMed by copy_block as they are processed and by the number of unique\nINCLUDE stmts in config.sys...",	0);
	set_cmt	(0X9B8F,	"save selected block name",	0);
	set_cmt	(0X9B90,	"process (named or common) block",	0);
	set_cmt	(0X9B94,	"hit eof",	0);
	set_cmt	(0X9B96,	"copy_block can only return for two reasons:\n it hit eof or a new block",	0);
	set_cmt	(0X9B99,	"always do \"common\" blocks",	0);
	create_insn	(x=0X9B9A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9BAA,	"is there a block name to check?",	0);
	set_cmt	(0X9BAC,	"no",	0);
	set_cmt	(0X9BAF,	"check block against given block name",	0);
	set_cmt	(0X9BB4,	"is this the block we really want to do?",	0);
	set_cmt	(0X9BB9,	"hit eof",	0);
	set_cmt	(0X9BC2,	"this ain't the block we wanted, so skip it",	0);
	create_insn	(0X9BC2);
	set_cmt	(0X9BC8,	"hit eof",	0);
	set_cmt	(0X9BCA,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0X9BCA);
	op_hex		(x,	1);
	set_cmt	(0X9BCC,	"CONFIG_BEGIN",	0);
	set_cmt	(0X9BD0,	"anything else is just skipped",	0);
	set_cmt	(0X9BD2,	"To create as little risk to the rest of SysInit\nas little as possible, and to free the workspace\nat \"config_wrkseg\" for creating an environment,\ncopy the new config.sys image to \"confbot\".\n\nnow copy workspace at DS:DI to \"confbot\"",	0);
	create_insn	(0X9BD2);
	set_cmt	(0X9BD4,	"\nBut first, copy the CONFIG=<configuration><0> string\nto the workspace, since the configuration name only \ncurrently exists in the \"confbot\" area.\n;",	0);
	set_cmt	(0X9BD5,	"szMenu-szBoot-1\nfirst copy the CONFIG= part",	0);
	create_insn	(x=0X9BD8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9BDB,	"skip a byte, in case absolutely nothing\nwas copied to the workspace, because we always\nzero the first byte of the workspace (below)",	0);
	set_cmt	(0X9BE3,	"then copy the configuration name",	0);
	set_cmt	(0X9BE4,	"128-7 ; put an upper limit on the name, to be safe",	0);
	create_insn	(x=0X9BE4);
	op_dec		(x,	1);
	set_cmt	(0X9BE7,	"ES:SI -> default block name",	0);
	set_cmt	(0X9BEC,	"valid?",	0);
	set_cmt	(0X9BEE,	"yes",	0);
	create_insn	(x=0X9BF2);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9C03,	"terminate the configuration string",	0);
	set_cmt	(0X9C07,	"Now we can copy \"config_wrkseg\" (DS) to \"confbot\" (ES)",	0);
	set_cmt	(0X9C10,	"recover the size of \"config_wrkseg\"",	0);
	set_cmt	(0X9C12,	"moved!",	0);
	set_cmt	(0X9C17,	"Now that the config_wrkseg is available once again,\nwe shall use it to create an environment. The first\nthing to go in will be the \"CONFIG=configuration\" thing.\nIt is also important to zero the first byte of the workspace,\nso that copy_envvar knows the buffer is empty.",	0);
	set_cmt	(0X9C1B,	"ES:SI -> \"CONFIG=configuration\"",	0);
	set_cmt	(0X9C1C,	"empty the environment block",	0);
	set_cmt	(0X9C22,	"copy envvar at ES:SI to \"config_wrkseg\"",	0);
	set_cmt	(0X9C25,	"\nBefore returning, restore the default video page setting\nbut do NOT do it using INT 10h's Set Active Page function,\nbecause if the menu was displayed on a different page,\nthen it's because we don't want to see all the device\ndriver/TSR goop (which goes to the default page)",	0);
	create_insn	(x=0X9C26);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9C2E);
	op_hex		(x,	1);
	create_insn	(x=0X9C33);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X9C36);
	create_insn	(x=0X9C3A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X9C3D);
	create_insn	(x=0X9C42);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(x=0X9C46);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9C4B,	"copy the envvar at ES:SI to \"config_wrkseg\"\nES:SI -> environment variable \n         (in the form \"var=string<cr/lf>\")",	0);
	create_insn	(0X9C4B);
	set_name	(0X9C4B,	"copy_envvar");
	set_cmt	(0X9C50,	"ES:DI to point to next available byte",	0);
	create_insn	(x=0X9C50);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9C54,	"DS:SI to point to envvar",	0);
	set_cmt	(0X9C58,	"NULL?",	0);
	set_cmt	(0X9C5B,	"yes, abort",	0);
	set_cmt	(0X9C5D,	"cr",	0);
	set_cmt	(0X9C62,	"lf",	0);
	set_cmt	(0X9C6E,	"save char after '='",	0);
	set_cmt	(0X9C70,	"back up to given varname",	0);
	set_cmt	(0X9C72,	"CX == # of bytes in varname",	0);
	set_cmt	(0X9C73,	"start looking for DS:SI at ES:0",	0);
	set_cmt	(0X9C78,	"search failed, just copy var",	0);
	set_cmt	(0X9C7A,	"ES:BX -> start of this varname",	0);
	set_cmt	(0X9C82,	"no match, skip to next varname",	0);
	create_insn	(x=0X9C84);
	op_chr		(x,	1);
	set_cmt	(0X9C88,	"no match, there's more characters\n\nPrevious occurrence of variable has been found;\ndetermine the entire length and then destroy it",	0);
	set_cmt	(0X9C8A,	"-1",	0);
	set_cmt	(0X9C8D,	"guaranteed to get null (since we put it there)",	0);
	set_cmt	(0X9C99,	"destroy variable now",	0);
	set_cmt	(0X9C9F,	"if there is nothing after the '='",	0);
	create_insn	(0X9CAB);
	set_cmt	(0X9CAC,	"-1",	0);
	create_insn	(0X9CB4);
	set_cmt	(0X9CB5,	"cr",	0);
	set_cmt	(0X9CB9,	"lf",	0);
	set_cmt	(0X9CC0,	"do SUB to clear carry as well",	0);
	create_insn	(0X9CC0);
	set_cmt	(0X9CC2,	"always null-terminate these puppies",	0);
	set_cmt	(0X9CC3,	"and stick another null to terminate the env.",	0);
	set_cmt	(0X9CD0,	"copy the current block to the new config.sys workspace\n\nCX == remaining bytes in \"organized\" config.sys memory image\nES:SI -> remaining bytes in \"organized\" config.sys memory image\nDS:DI -> new config.sys workspace (equal in size to the original\n       config.sys image) where the current block is to be copied\n\ncheck for include",	0);
	create_insn	(0X9CD0);
	set_name	(0X9CD0,	"copy_block");
	set_cmt	(0X9CD5,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0X9CD5);
	op_hex		(x,	1);
	set_cmt	(0X9CD7,	"CONFIG_BEGIN\nanother BEGIN implies END as well",	0);
	set_cmt	(0X9CDB,	"CONFIG_INCLUDE ; 'J'",	0);
	set_cmt	(0X9CDD,	"AL == the original line code",	0);
	set_cmt	(0X9CDF,	"not an \"include\" line\n\nWe have hit an \"INCLUDE\" line; first, REM out the line\nso that we never try to include the block again\n(no infinite include loops please), then search for\nthe named block and call copy_block again.",	0);
	set_cmt	(0X9CE1,	"CONFIG_REM",	0);
	create_insn	(x=0X9CE7);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9CEA,	"don't allow INCLUDE MENU",	0);
	create_insn	(x=0X9CEF);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9CF2,	"don't allow INCLUDE COMMON",	0);
	set_cmt	(0X9CF7,	"try to find the block",	0);
	set_cmt	(0X9CFF,	"no such block",	0);
	set_cmt	(0X9D08,	"skip the rest of the \"block name\" line",	0);
	set_cmt	(0X9D0B,	"and copy in the rest of that block",	0);
	set_cmt	(0X9D10,	"force skip_opt_line to skip...",	0);
	create_insn	(0X9D14);
	set_cmt	(0X9D16,	"note that carry is clear, no pause",	0);
	set_cmt	(0X9D1B,	"Copy the line at ES:SI\n to the current location at DS:DI",	0);
	create_insn	(0X9D1B);
	set_cmt	(0X9D1E,	"is this is a \"real\" line with a \"real\" code?",	0);
	set_cmt	(0X9D20,	"no",	0);
	set_cmt	(0X9D28,	"not a multi-config config.sys, don't embed #s",	0);
	set_cmt	(0X9D2A,	"BX == line # of line @ES:SI",	0);
	set_cmt	(0X9D2D,	"stash it immediately following the line code",	0);
	create_insn	(0X9D33);
	set_cmt	(0X9D36,	"end of file",	0);
	set_cmt	(0X9D3B,	"lf ; done with line?",	0);
	set_cmt	(0X9D3D,	"nope",	0);
	create_insn	(0X9D44);
	set_cmt	(0X9D45,	"return line # (in BX) of current line (@ES:SI)",	0);
	create_insn	(0X9D45);
	set_name	(0X9D45,	"get_linenum");
	set_cmt	(0X9D46,	"BX == line # (to be returned)",	0);
	set_cmt	(0X9D49,	"DX == the offset we're looking for",	0);
	set_cmt	(0X9D51,	"prepare to scan entire file",	0);
	set_cmt	(0X9D59,	"have we exceeded the desired offset yet?",	0);
	set_cmt	(0X9D5B,	"no",	0);
	set_cmt	(0X9D61,	"searches entire config.sys\nfor block name @ES:DI",	0);
	create_insn	(0X9D61);
	set_name	(0X9D61,	"srch_block");
	set_cmt	(0X9D71,	"ES:DI -> just past the name in the block heading, if found",	0);
	set_cmt	(0X9D73,	"BX == # bytes remaining from that point, if found",	0);
	set_cmt	(0X9D7A,	"searches rest of config.sys for block name @DS:DI\nget line code",	0);
	create_insn	(0X9D7A);
	set_name	(0X9D7A,	"find_block");
	set_cmt	(0X9D7D,	"end of file",	0);
	set_cmt	(0X9D7F,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0X9D7F);
	op_hex		(x,	1);
	set_cmt	(0X9D81,	"CONFIG_BEGIN ; beginning of a block?",	0);
	set_cmt	(0X9D83,	"no",	0);
	set_cmt	(0X9D85,	"CONFIG_INCLUDE",	0);
	create_insn	(x=0X9D89);
	op_hex		(x,	1);
	create_insn	(x=0X9D91);
	op_hex		(x,	1);
	set_cmt	(0X9D97,	"compare block names",	0);
	set_cmt	(0X9D9A,	"end of file, or names matched",	0);
	set_cmt	(0X9D9C,	"no, so skip to next line",	0);
	create_insn	(0X9DA1);
	set_cmt	(0X9DA2,	"compares keyword @DS:DI \n to position in config.sys @ES:SI",	0);
	create_insn	(0X9DA2);
	set_name	(0X9DA2,	"comp_names");
	set_cmt	(0X9DA8,	"is next character a delimiter?",	0);
	set_cmt	(0X9DAB,	"(get next character we're supposed to match)",	0);
	set_cmt	(0X9DAD,	"yes, it *could* be a match",	0);
	set_cmt	(0X9DB0,	"~2020h",	0);
	create_insn	(x=0X9DB0);
	op_hex		(x,	1);
	set_cmt	(0X9DB3,	"match?",	0);
	set_cmt	(0X9DB5,	"yes, keep looking at the characters",	0);
	set_cmt	(0X9DB7,	"prevent erroneous eof indication: clear carry",	0);
	set_cmt	(0X9DBA,	"we don't know for sure if it's a match",	0);
	create_insn	(0X9DBA);
	set_cmt	(0X9DBC,	"until we verify that the second string",	0);
	set_cmt	(0X9DBF,	"has been exhausted also...",	0);
	set_cmt	(0X9DC1,	"if we are, this call to any_delim will tell...",	0);
	create_insn	(0X9DC3);
	set_name	(0X9DC3,	"comp_names_safe");
	set_cmt	(0X9DD1,	"display menu item #BL",	0);
	create_insn	(0X9DD1);
	set_name	(0X9DD1,	"print_item");
	set_cmt	(0X9DD6,	"get cursor position",	0);
	set_cmt	(0X9DD8,	"always page zero",	0);
	create_insn	(x=0X9DD8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9DDC,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line",	0);
	set_cmt	(0X9DDF,	"set cursor position for correct row/col",	0);
	set_cmt	(0X9DE8,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9DE8);
	op_hex		(x,	0);
	set_cmt	(0X9DEC,	"convert menu item # to ASCII digit",	0);
	set_cmt	(0X9DEE,	"normal attribute",	0);
	create_insn	(x=0X9DEE);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9DF2,	"are we printing the current block?",	0);
	create_insn	(x=0X9DF2);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9DF6,	"no",	0);
	set_cmt	(0X9DF8,	"yes, set bgnd color to white",	0);
	create_insn	(x=0X9DF8);
	op_hex		(x,	1);
	set_cmt	(0X9E01,	"are fgnd/bgnd the same?",	0);
	set_cmt	(0X9E03,	"no",	0);
	set_cmt	(0X9E05,	"yes, so modify the fgnd intensity",	0);
	create_insn	(x=0X9E05);
	op_hex		(x,	1);
	create_insn	(x=0X9E0C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9E10,	"put the attribute in the correct register now",	0);
	set_cmt	(0X9E12,	"get correct video page #",	0);
	create_insn	(x=0X9E12);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9E16,	"write char/attr",	0);
	set_cmt	(0X9E1B,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character",	0);
	create_insn	(x=0X9E1B);
	op_hex		(x,	0);
	set_cmt	(0X9E1D,	"increment column",	0);
	set_cmt	(0X9E21,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9E21);
	op_hex		(x,	0);
	set_cmt	(0X9E23,	"display '.'",	0);
	set_cmt	(0X9E26,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character",	0);
	create_insn	(x=0X9E26);
	op_hex		(x,	0);
	set_cmt	(0X9E28,	"increment column",	0);
	set_cmt	(0X9E2C,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9E2C);
	op_hex		(x,	0);
	set_cmt	(0X9E2E,	"display ' '",	0);
	set_cmt	(0X9E31,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character",	0);
	create_insn	(x=0X9E31);
	op_hex		(x,	0);
	set_cmt	(0X9E33,	"increment column",	0);
	set_cmt	(0X9E37,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9E37);
	op_hex		(x,	0);
	set_cmt	(0X9E3A,	"get a character of the description",	0);
	set_cmt	(0X9E3E,	"TAB ; substitute spaces for tabs",	0);
	set_cmt	(0X9E46,	"stop at the 1st character < space",	0);
	set_cmt	(0X9E4A,	"also stop on $",	0);
	set_cmt	(0X9E4E,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character",	0);
	create_insn	(x=0X9E4E);
	op_hex		(x,	0);
	set_cmt	(0X9E50,	"increment column",	0);
	set_cmt	(0X9E52,	"far enough?",	0);
	create_insn	(x=0X9E52);
	op_dec		(x,	1);
	set_cmt	(0X9E55,	"yes",	0);
	set_cmt	(0X9E59,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9E59);
	op_hex		(x,	0);
	create_insn	(0X9E5D);
	set_cmt	(0X9E5F,	"restore previous row/col",	0);
	set_cmt	(0X9E61,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9E61);
	op_hex		(x,	0);
	set_cmt	(0X9E69,	"wait for user to select menu item, with time-out\n\nreturns digit value in BX (trashes AX/CX/DX)",	0);
	create_insn	(x=0X9E69);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0X9E69,	"select_item");
	set_cmt	(0X9E6D,	"BL will be the default block #",	0);
	set_cmt	(0X9E72,	"display current interactive status",	0);
	set_cmt	(0X9E75,	"-1",	0);
	create_insn	(x=0X9E75);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9E7A,	"no time-out, just go to input",	0);
	set_cmt	(0X9E7C,	"GET_TIME",	0);
	create_insn	(x=0X9E7C);
	op_hex		(x,	1);
	set_cmt	(0X9E7E,	"DOS - GET CURRENT TIME\nReturn: CH = hours, CL = minutes, DH = seconds\nDL = hundredths of seconds\n;",	0);
	create_insn	(x=0X9E7E);
	op_hex		(x,	0);
	set_cmt	(0X9E80,	"BH = initial # of seconds",	0);
	create_insn	(x=0X9E82);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X9E85);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9E8B,	"disable all further prompting",	0);
	create_insn	(x=0X9E8B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0X9E90);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9E95,	"time's up!",	0);
	create_insn	(0X9E98);
	set_cmt	(0X9E99,	"save # in BL",	0);
	create_insn	(x=0X9E9B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9EA1,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line",	0);
	create_insn	(x=0X9EA1);
	op_hex		(x,	0);
	set_cmt	(0X9EA4,	"move cursor to the right",	0);
	set_cmt	(0X9EA9,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9EA9);
	op_hex		(x,	0);
	create_insn	(x=0X9EAB);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9EAE,	"print the \"Time remaining: \" prompt",	0);
	set_cmt	(0X9EB1,	"recover # from BL",	0);
	set_cmt	(0X9EB3,	"this works because AL is always <= 90",	0);
	create_insn	(x=0X9EB4);
	op_dec		(x,	1);
	set_cmt	(0X9EB6,	"AL = tens digit, AH = ones digit",	0);
	set_cmt	(0X9EBA,	"write TTY tens digit",	0);
	create_insn	(x=0X9EBA);
	op_chr		(x,	1);
	set_cmt	(0X9EBE,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X9EBE);
	op_hex		(x,	0);
	set_cmt	(0X9EC2,	"write TTY ones digit",	0);
	create_insn	(x=0X9EC2);
	op_chr		(x,	1);
	set_cmt	(0X9EC6,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X9EC6);
	op_hex		(x,	0);
	set_cmt	(0X9EC9,	"set cursor position back to where it was",	0);
	set_cmt	(0X9ECB,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9ECB);
	op_hex		(x,	0);
	set_cmt	(0X9ECE,	"RAW_CON_IO",	0);
	set_cmt	(0X9ED0,	"input request",	0);
	set_cmt	(0X9ED2,	"DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT\nDL = character <> FFh\n Return: ZF set = no character\n  ZF clear = character recieved, AL = character",	0);
	create_insn	(x=0X9ED2);
	op_hex		(x,	0);
	set_cmt	(0X9ED6,	"-1 ; is there a time-out?",	0);
	create_insn	(x=0X9ED6);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9EDB,	"no, just go back to input",	0);
	set_cmt	(0X9EDD,	"GET_TIME",	0);
	create_insn	(x=0X9EDD);
	op_hex		(x,	1);
	set_cmt	(0X9EDF,	"DOS - GET CURRENT TIME\nReturn: CH = hours, CL = minutes, DH = seconds\nDL = hundredths of seconds",	0);
	create_insn	(x=0X9EDF);
	op_hex		(x,	0);
	set_cmt	(0X9EE3,	"should generally be zero or one",	0);
	set_cmt	(0X9EE9,	"it wrapped back to zero, so assume one",	0);
	set_cmt	(0X9EEB,	"any change?",	0);
	set_cmt	(0X9EED,	"no",	0);
	create_insn	(x=0X9EEF);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	create_insn	(0X9EF5);
	set_cmt	(0X9EF6,	"-1 ; zap both secTimeOut and secElapsed",	0);
	create_insn	(x=0X9EF9);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9EFD,	"-1 ; was time-out already disabled?",	0);
	set_cmt	(0X9EFF,	"yes",	0);
	set_cmt	(0X9F01,	"let's disable # seconds display",	0);
	set_cmt	(0X9F02,	"write multiple spaces",	0);
	create_insn	(x=0X9F05);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9F09,	"80 of them, to be safe\nto completely obliterate # seconds display",	0);
	create_insn	(x=0X9F09);
	op_dec		(x,	1);
	set_cmt	(0X9F0C,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character",	0);
	create_insn	(x=0X9F0C);
	op_hex		(x,	0);
	set_cmt	(0X9F10,	"extended key pressed?",	0);
	set_cmt	(0X9F12,	"no",	0);
	set_cmt	(0X9F14,	"get the next part of the key then",	0);
	create_insn	(x=0X9F14);
	op_hex		(x,	0);
	set_cmt	(0X9F16,	"what happened to the second part!?",	0);
	set_cmt	(0X9F18,	"up arrow?",	0);
	create_insn	(x=0X9F18);
	op_hex		(x,	1);
	set_cmt	(0X9F1A,	"no",	0);
	set_cmt	(0X9F1C,	"are we as up as up can get?",	0);
	set_cmt	(0X9F1F,	"yes, ignore it",	0);
	create_insn	(x=0X9F21);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9F25,	"re-print the current item",	0);
	set_cmt	(0X9F28,	"and then print the new current item",	0);
	set_cmt	(0X9F2C,	"down arrow?",	0);
	create_insn	(0X9F2C);
	set_cmt	(0X9F2E,	"no",	0);
	set_cmt	(0X9F30,	"are we as down as down can get?",	0);
	create_insn	(x=0X9F30);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9F34,	"yes, ignore it",	0);
	create_insn	(x=0X9F36);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9F3A,	"re-print the current item",	0);
	set_cmt	(0X9F3D,	"and then print the new current item",	0);
	create_insn	(x=0X9F48);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9F4D,	"don't allow F8 or F5",	0);
	set_cmt	(0X9F4F,	"F8 function key?",	0);
	create_insn	(x=0X9F4F);
	op_hex		(x,	1);
	set_cmt	(0X9F51,	"no",	0);
	create_insn	(x=0X9F53);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9F5E,	"F5 function key?",	0);
	create_insn	(x=0X9F5E);
	op_hex		(x,	1);
	set_cmt	(0X9F60,	"no",	0);
	set_cmt	(0X9F62,	"no more queries",	0);
	create_insn	(x=0X9F62);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9F67,	"special return code (-1) indicating clean boot",	0);
	set_cmt	(0X9F6A,	"don't want to display anything really;",	0);
	set_cmt	(0X9F6E,	"Enter?",	0);
	create_insn	(0X9F6E);
	set_cmt	(0X9F70,	"yes",	0);
	set_cmt	(0X9F72,	"backspace?",	0);
	set_cmt	(0X9F74,	"no",	0);
	set_cmt	(0X9F76,	"-2 ; yes, special return code",	0);
	set_cmt	(0X9F7A,	"is greater than '0'?",	0);
	create_insn	(0X9F7A);
	set_cmt	(0X9F7C,	"no",	0);
	set_cmt	(0X9F7E,	"is less than or equal to the maximum digit?",	0);
	create_insn	(x=0X9F7E);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9F82,	"no",	0);
	create_insn	(x=0X9F84);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9F87,	"redisplay the current selection",	0);
	set_cmt	(0X9F8A,	"set new selection",	0);
	set_cmt	(0X9F8E,	"return a full 16-bit value (for indexing)",	0);
	create_insn	(0X9F8E);
	set_cmt	(0X9F92,	"convert it into a digit, then display it",	0);
	create_insn	(0X9F94);
	set_name	(0X9F94,	"disp_input");
	set_cmt	(0X9F9D,	"STD_CON_OUTPUT",	0);
	create_insn	(x=0X9F9D);
	op_hex		(x,	1);
	set_cmt	(0X9F9F,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0X9F9F);
	op_hex		(x,	0);
	create_insn	(x=0X9FA1);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9FA9,	"display a single character + cr/lf",	0);
	create_insn	(0X9FA9);
	set_name	(0X9FA9,	"disp_num");
	create_insn	(x=0X9FAA);
	op_chr		(x,	1);
	create_insn	(x=0X9FAE);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9FB5,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character",	0);
	create_insn	(x=0X9FB5);
	op_hex		(x,	0);
	set_cmt	(0X9FB9,	"display current interactive mode setting (on/off/none)",	0);
	create_insn	(0X9FB9);
	set_name	(0X9FB9,	"show_status");
	create_insn	(x=0X9FBA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9FC0,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line",	0);
	create_insn	(x=0X9FC0);
	op_hex		(x,	0);
	set_cmt	(0X9FC5,	"set correct row/col",	0);
	create_insn	(x=0X9FC5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0X9FC9);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0X9FCE,	"just show on/off",	0);
	set_cmt	(0X9FD2,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9FD2);
	op_hex		(x,	0);
	set_cmt	(0X9FD4,	"write multiple spaces",	0);
	set_cmt	(0X9FD7,	"80 of them, to be exact to obliterate the status line",	0);
	create_insn	(x=0X9FD7);
	op_dec		(x,	1);
	set_cmt	(0X9FDA,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character",	0);
	create_insn	(x=0X9FDA);
	op_hex		(x,	0);
	set_cmt	(0X9FDE,	"- VIDEO - ",	0);
	create_insn	(x=0X9FDE);
	op_hex		(x,	0);
	create_insn	(x=0X9FE0);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9FE3,	"is interactive mode on?",	0);
	create_insn	(x=0X9FE3);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0X9FE8,	"no",	0);
	create_insn	(x=0X9FEA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0X9FEF,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)",	0);
	create_insn	(x=0X9FEF);
	op_hex		(x,	0);
	set_cmt	(0X9FF1,	"restore original cursor position",	0);
	set_cmt	(0X9FF4,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ",	0);
	create_insn	(x=0X9FF4);
	op_hex		(x,	0);
	set_cmt	(0X9FF8,	"advances ES:SI/CX past the current token",	0);
	create_insn	(0X9FF8);
	set_name	(0X9FF8,	"skip_token");
	set_cmt	(0XA002,	"CR",	0);
	set_name	(0XA002,	"skip_check_eol");
	set_cmt	(0XA006,	"LF",	0);
	create_insn	(0XA00D);
	set_name	(0XA00E,	"skip_token_done");
	set_cmt	(0XA00F,	"advances ES:SI/CX past the current delimiter",	0);
	create_insn	(0XA00F);
	set_name	(0XA00F,	"skip_delim");
	set_cmt	(0XA01E,	"LF",	0);
	create_insn	(0XA01E);
	set_name	(0XA01E,	"skip_opt_line");
	create_insn	(0XA022);
	set_name	(0XA022,	"skip_line");
	set_cmt	(0XA027,	"skip_opt_line: (Erdogan Tan - 03/08/2023)\nLF",	0);
	set_name	(0XA027,	"_skip_opt_line:");
	set_name	(0XA02B,	"skip_line_done");
	set_cmt	(0XA02C,	"return binary equivalent of numeric string\nBX = result",	0);
	create_insn	(0XA02C);
	set_name	(0XA02C,	"get_number");
	set_cmt	(0XA033,	"convert to value",	0);
	set_cmt	(0XA035,	"no more number",	0);
	create_insn	(x=0XA03C);
	op_dec		(x,	1);
	create_insn	(0XA04D);
	set_cmt	(0XA04E,	"return next character,\nadvance ES:SI, and decrement CX\n(use SUB to set carry,zero)",	0);
	create_insn	(0XA04E);
	set_name	(0XA04E,	"get_char");
	set_cmt	(0XA051,	"out of data",	0);
	set_cmt	(0XA053,	"es\nlodsb",	0);
	set_cmt	(0XA058,	"restore CX to zero\nleave carry set, zero not set",	0);
	create_insn	(0XA058);
	set_name	(0XA05B,	"nearby_ret");
	set_cmt	(0XA05C,	"ask user whether to execute current config.sys command\nanswer no to everything?",	0);
	create_insn	(x=0XA05C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_name	(0XA05C,	"query_user");
	set_cmt	(0XA061,	"no",	0);
	set_cmt	(0XA063,	"yes",	0);
	set_cmt	(0XA066,	"answer yes to everything?",	0);
	create_insn	(x=0XA066);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0XA06B,	"yes (and return carry clear!)",	0);
	create_insn	(x=0XA06E);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA071,	"query every command?",	0);
	create_insn	(x=0XA071);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0XA076,	"yes",	0);
	set_cmt	(0XA078,	"CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0XA078);
	op_hex		(x,	1);
	set_cmt	(0XA07F,	"save pointer to rest of CONFIG.SYS line",	0);
	create_insn	(0XA07F);
	create_insn	(x=0XA080);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA083,	"~CONFIG_OPTION_QUERY",	0);
	create_insn	(x=0XA083);
	op_hex		(x,	1);
	set_cmt	(0XA085,	"config_cmd must have been 0",	0);
	set_cmt	(0XA087,	"save config_cmd in DH",	0);
	set_cmt	(0XA089,	"0",	0);
	create_insn	(x=0XA08B);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA08E,	"get size of current keyword",	0);
	set_cmt	(0XA092,	"end of table",	0);
	set_cmt	(0XA095,	"match?",	0);
	set_cmt	(0XA097,	"yes",	0);
	set_cmt	(0XA099,	"otherwise, skip this command code",	0);
	set_cmt	(0XA09C,	"loop",	0);
	create_insn	(0XA09E);
	set_cmt	(0XA0A3,	"STD_CON_OUTPUT",	0);
	set_cmt	(0XA0AA,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0XA0AA);
	op_hex		(x,	0);
	set_cmt	(0XA0AE,	"'=' looks funny on SET commands",	0);
	create_insn	(x=0XA0AE);
	op_chr		(x,	1);
	set_cmt	(0XA0B0,	"CONFIG_SET",	0);
	create_insn	(x=0XA0B0);
	op_chr		(x,	1);
	set_cmt	(0XA0B5,	"for SET commands, don't display a '='",	0);
	set_cmt	(0XA0B7,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0XA0B7);
	op_hex		(x,	0);
	set_cmt	(0XA0C1,	"control code?",	0);
	set_cmt	(0XA0C3,	"yes, assume end of line",	0);
	create_insn	(x=0XA0CF);
	op_hex		(x,	1);
	set_cmt	(0XA0D1,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0XA0D1);
	op_hex		(x,	0);
	create_insn	(x=0XA0D5);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA0DD,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character",	0);
	create_insn	(x=0XA0DD);
	op_hex		(x,	0);
	set_cmt	(0XA0DF,	"is it a function key?",	0);
	set_cmt	(0XA0E1,	"no",	0);
	set_cmt	(0XA0E3,	"F5 function key?",	0);
	create_insn	(x=0XA0E3);
	op_hex		(x,	1);
	set_cmt	(0XA0E6,	"no",	0);
	create_insn	(x=0XA0E8);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA0EB,	"no more queries",	0);
	create_insn	(x=0XA0EB);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0XA0F2,	"~20h ; converting to upper case\nconverting to upper case\nverify character is legal",	0);
	create_insn	(x=0XA0F2);
	op_hex		(x,	1);
	create_insn	(x=0XA0F4);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0XA0FA);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0XA100);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XA105,	"don't allow Esc on this query",	0);
	set_cmt	(0XA107,	"Esc?",	0);
	set_cmt	(0XA10B,	"no more interactive boot prompts",	0);
	create_insn	(x=0XA10B);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0XA110);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA116,	"restore pointer to rest of CONFIG.SYS line\nprocess line?",	0);
	create_insn	(x=0XA117);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA11B,	"no",	0);
	set_cmt	(0XA11E,	"just do the command",	0);
	create_insn	(0XA120);
	set_cmt	(0XA121,	"CONFIG_REM ; fake out the rest of sysinit's processing",	0);
	set_cmt	(0XA125,	"displays multi-config error conditions",	0);
	create_insn	(0XA125);
	set_name	(0XA125,	"print_error");
	create_insn	(x=0XA13A);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA140,	"flush input buffer, then wait for key",	0);
	create_insn	(x=0XA140);
	op_hex		(x,	1);
	set_cmt	(0XA143,	"DOS - CLEAR KEYBOARD BUFFER\nAL must be 01h, 06h, 07h, 08h, or 0Ah.",	0);
	create_insn	(x=0XA143);
	op_hex		(x,	0);
	set_cmt	(0XA145,	"extended key?",	0);
	set_cmt	(0XA147,	"no",	0);
	set_cmt	(0XA149,	"yes, eat it too",	0);
	create_insn	(x=0XA149);
	op_hex		(x,	1);
	set_cmt	(0XA14B,	"DOS - DIRECT STDIN INPUT, NO ECHO",	0);
	create_insn	(x=0XA14B);
	op_hex		(x,	0);
	create_insn	(x=0XA14D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA159,	"This function is very simple:\nit merely prepends a \"/D\" to the command-line for the shell;\nthis (undocumented) switch disables AUTOEXEC.BAT processing\nand the date/time prompt that is usually displayed\nwhen there's no AUTOEXEC.BAT.",	0);
	create_insn	(x=0XA159);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_name	(0XA159,	"disable_autoexec");
	create_insn	(x=0XA160);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0XA167);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0XA16C,	"[bDefBlock] = 1",	0);
	create_insn	(x=0XA16C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0XA172,	"2044h ; 'D ' (NASM syntax)",	0);
	create_insn	(x=0XA172);
	op_chr		(x,	1);
	set_cmt	(0XA175,	"get default switchchar",	0);
	create_insn	(x=0XA175);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0XA175,	"dae_1");
	create_insn	(x=0XA17C);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA180,	"BX == command-line length",	0);
	create_insn	(x=0XA187);
	op_dec		(x,	1);
	set_cmt	(0XA18A,	"\nupdate length",	0);
	create_insn	(x=0XA18C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XA190,	"\nmake sure we move the NULL too",	0);
	create_insn	(x=0XA190);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA194,	"(just for consistency sake)",	0);
	set_cmt	(0XA1A0,	"'D ' ; /D is stuffed into place now",	0);
	set_name	(0XA1A3,	"disable_exit");
	create_insn	(x=0XA1A4);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0XA1A4,	"CheckQueryOpt");
	create_insn	(x=0XA1AB);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	create_insn	(x=0XA1B2);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	op_hex		(x,	1);
	set_cmt	(0XA1B7,	"'Y ' ; 2059h",	0);
	create_insn	(x=0XA1B7);
	op_chr		(x,	1);
	set_cmt	(0XA1BC,	"cr",	0);
	create_insn	(0XA1BC);
	set_name	(0XA1BC,	"any_delim");
	set_cmt	(0XA1C0,	"lf",	0);
	create_insn	(x=0XA1C4);
	op_chr		(x,	1);
	create_insn	(x=0XA1C8);
	op_chr		(x,	1);
	set_cmt	(0XA1CC,	"ibm will assume \"/\" as an delimeter",	0);
	create_insn	(x=0XA1CC);
	op_chr		(x,	1);
	set_name	(0XA1CC,	"delim");
	set_cmt	(0XA1D0,	"special case for sysinit!",	0);
	set_cmt	(0XA1D4,	"space",	0);
	set_name	(0XA1D4,	"org_delim");
	set_cmt	(0XA1D8,	"tab",	0);
	create_insn	(x=0XA1DC);
	op_chr		(x,	1);
	create_insn	(x=0XA1E0);
	op_chr		(x,	1);
	create_insn	(x=0XA1E4);
	op_chr		(x,	1);
	set_name	(0XA1E7,	"delim_ret");
	set_cmt	(0XA1E8,	"skip non-control characters",	0);
	create_insn	(0XA1E8);
	set_name	(0XA1E8,	"newline");
	set_cmt	(0XA1EB,	"no char",	0);
	set_cmt	(0XA1ED,	"lf",	0);
	set_cmt	(0XA1F4,	"al = first character of next line (if cf=0)",	0);
	create_insn	(0XA1F5);
	set_name	(0XA1F5,	"mapcase");
	create_insn	(x=0XA1FD);
	op_chr		(x,	1);
	create_insn	(x=0XA201);
	op_chr		(x,	1);
	set_cmt	(0XA205,	"convert to upper-case (and al,0DFh)",	0);
	create_insn	(x=0XA205);
	op_hex		(x,	1);
	set_cmt	(0XA20A,	"CONFIG_SET ; preserve case for part of the line?",	0);
	create_insn	(x=0XA20A);
	op_chr		(x,	1);
	set_cmt	(0XA20D,	"no, just check for end-of-line",	0);
	set_cmt	(0XA20F,	"separator between SET var and value?",	0);
	create_insn	(x=0XA20F);
	op_chr		(x,	1);
	set_cmt	(0XA211,	"yes\n(we don't want to upper-case\nanything after the \"=\" in a SET)",	0);
	set_cmt	(0XA213,	"cr",	0);
	set_cmt	(0XA217,	"lf",	0);
	set_cmt	(0XA221,	"round the values in memlo and memhi\nto paragraph boundary.\nperform bounds check.",	0);
	create_insn	(0XA221);
	set_name	(0XA221,	"round");
	set_cmt	(0XA226,	"para round up",	0);
	set_cmt	(0XA235,	"ax = new memhi",	0);
	set_cmt	(0XA240,	"for_devmark",	0);
	create_insn	(x=0XA240);
	op_hex		(x,	1);
	set_cmt	(0XA254,	"mov [es:devmark.size],ax ; paragraph",	0);
	set_cmt	(0XA258,	"~2 ; not 2\nnot_for_devmark",	0);
	create_insn	(x=0XA258);
	op_hex		(x,	1);
	create_insn	(x=0XA263);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0XA263,	"mem_err");
	create_insn	(0XA26E);
	set_name	(0XA26E,	"calldev");
	set_cmt	(0XA273,	"do a little relocation",	0);
	create_insn	(x=0XA283);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0XA291);
	op_chr		(x,	1);
	set_name	(0XA291,	"todigit");
	create_insn	(0XA29B);
	set_cmt	(0XA29D,	"getnum parses a decimal number.\nreturns it in ax, sets zero flag if ax = 0\n(may be considered an error),\nif number is bad carry is set, zero is set, ax=0.\n;;",	0);
	create_insn	(0XA29D);
	set_name	(0XA29D,	"getnum");
	set_cmt	(0XA29E,	"running count is zero",	0);
	set_cmt	(0XA2A0,	"do we have a digit ?",	0);
	set_cmt	(0XA2A3,	"no, bomb",	0);
	set_cmt	(0XA2A5,	"put total in ax",	0);
	set_cmt	(0XA2A6,	"save digit (0 to 9)",	0);
	set_cmt	(0XA2A7,	"base of arithmetic",	0);
	create_insn	(x=0XA2A7);
	op_dec		(x,	1);
	set_cmt	(0XA2AA,	"shift by one decimal digit",	0);
	set_cmt	(0XA2AC,	"get back digit (0 to 9)",	0);
	set_cmt	(0XA2AD,	"get total",	0);
	set_cmt	(0XA2AF,	"make that 16 bits",	0);
	set_cmt	(0XA2B2,	"too big a number",	0);
	set_cmt	(0XA2B4,	"stash total",	0);
	set_cmt	(0XA2B5,	"get next digit",	0);
	set_cmt	(0XA2B8,	"no more characters",	0);
	set_cmt	(0XA2BA,	"space?",	0);
	create_insn	(x=0XA2BA);
	op_chr		(x,	1);
	set_cmt	(0XA2BC,	"then end of digits",	0);
	set_cmt	(0XA2BE,	"',' is a seperator!!!",	0);
	create_insn	(x=0XA2BE);
	op_chr		(x,	1);
	set_cmt	(0XA2C0,	"then end of digits.",	0);
	set_cmt	(0XA2C2,	"tab",	0);
	set_cmt	(0XA2C6,	"allow 0 or special separators",	0);
	set_cmt	(0XA2CD,	"see if another switch follows",	0);
	create_insn	(x=0XA2CD);
	op_chr		(x,	1);
	set_cmt	(0XA2CF,	"cas - remnant of old bad code",	0);
	set_cmt	(0XA2D0,	"(04/08/2023 - Erdogan Tan - 'nop,nop' is not neded)",	0);
	set_cmt	(0XA2D3,	"lf ; line-feed?",	0);
	set_cmt	(0XA2D7,	"cr ; carriage return?",	0);
	set_cmt	(0XA2DB,	"end of line separator?",	0);
	set_cmt	(0XA2DD,	"no, try as a valid char...",	0);
	set_cmt	(0XA2DF,	"one more character to s...",	0);
	set_cmt	(0XA2E4,	"clears carry, sets zero accordingly",	0);
	create_insn	(0XA2EF);
	set_cmt	(0XA2F5,	"set zero flag, and ax = 0",	0);
	set_cmt	(0XA2F8,	"and carry set",	0);
	set_cmt	(0XA2FA,	"input: \n  es:di -> pointer to dos_country_cdpg_info\n  ds:0  -> buffer.\n     si = 0\n     ax = country id\n     dx = code page id. (if 0, then use ccsyscodepage as a default.)\n     bx = file handle\n  this routine can handle maximum 438 country_data entries.\noutput:\n  dos_country_cdpg_info set.\n  carry set if any file read failure or wrong information in the file.\n  carry set and cx = -1 if cannot find the matching country_id, \n        codepage_id in the file.",	0);
	create_insn	(0XA2FA);
	set_name	(0XA2FA,	"setdoscountryinfo");
	set_cmt	(0XA301,	"read 512 bytes",	0);
	create_insn	(x=0XA301);
	op_dec		(x,	1);
	set_cmt	(0XA304,	"read the file header",	0);
	set_cmt	(0XA30D,	"db 0FFh,'COUNTRY'",	0);
	create_insn	(x=0XA30D);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA310,	"length of the signature",	0);
	set_cmt	(0XA317,	"signature mismatch",	0);
	create_insn	(x=0XA319);
	op_dec		(x,	1);
	set_cmt	(0XA31C,	"si -> county info type\nonly accept type 1 (currently only 1 header type)",	0);
	set_cmt	(0XA31F,	"cannot proceed. error return",	0);
	set_cmt	(0XA321,	"si -> file offset",	0);
	set_cmt	(0XA322,	"get the info file offset.",	0);
	set_cmt	(0XA327,	"read 6144 bytes.",	0);
	create_insn	(x=0XA327);
	op_dec		(x,	1);
	set_cmt	(0XA32A,	"read info",	0);
	set_cmt	(0XA32F,	"get the # of country, codepage combination entries",	0);
	set_cmt	(0XA331,	"cannot handle more than 438 entries.",	0);
	create_insn	(x=0XA331);
	op_dec		(x,	1);
	set_cmt	(0XA338,	"si -> entry information packet",	0);
	set_cmt	(0XA339,	"restore code page id",	0);
	set_cmt	(0XA33A,	"restore country id",	0);
	set_cmt	(0XA33B,	"search for desired country_id,codepage_id.",	0);
	set_cmt	(0XA33C,	"compare country_id",	0);
	set_cmt	(0XA341,	"no user specified code page ?",	0);
	set_cmt	(0XA344,	"then no need to match code page id.",	0);
	set_cmt	(0XA346,	"compare code page id",	0);
	set_cmt	(0XA34B,	"next entry",	0);
	set_cmt	(0XA34E,	"take a word for size of entry itself",	0);
	set_cmt	(0XA351,	"-1 ; signals that bad country id entered.",	0);
	create_insn	(0XA356);
	set_cmt	(0XA35B,	"use the code_page_id of the country_id found.",	0);
	create_insn	(0XA35B);
	set_cmt	(0XA35E,	"save code page id for this country.",	0);
	set_cmt	(0XA363,	"get the file offset of country data",	0);
	create_insn	(x=0XA363);
	op_dec		(x,	1);
	create_insn	(x=0XA366);
	op_dec		(x,	1);
	set_cmt	(0XA369,	"read 512 bytes",	0);
	create_insn	(x=0XA369);
	op_dec		(x,	1);
	set_cmt	(0XA371,	"get the number of entries to handle.",	0);
	set_cmt	(0XA374,	"si -> first entry",	0);
	set_cmt	(0XA375,	"es:di -> dos_country_cdpg_info",	0);
	set_cmt	(0XA376,	"save # of entry left",	0);
	set_cmt	(0XA377,	"si -> current entry in control buffer",	0);
	set_cmt	(0XA378,	"get data entry id",	0);
	set_cmt	(0XA37B,	"get the address of destination in es:di",	0);
	set_cmt	(0XA37E,	"no matching data entry id in dos",	0);
	set_cmt	(0XA380,	"get offset of data",	0);
	set_cmt	(0XA38A,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file",	0);
	create_insn	(x=0XA38A);
	op_hex		(x,	0);
	set_cmt	(0XA38C,	"\nread the country.sys data",	0);
	set_cmt	(0XA38E,	"start of data buffer",	0);
	create_insn	(x=0XA38E);
	op_dec		(x,	1);
	set_cmt	(0XA391,	"read 20 bytes only. we only need to",	0);
	create_insn	(x=0XA391);
	op_dec		(x,	1);
	set_cmt	(0XA394,	"look at the length of the data in the file.",	0);
	create_insn	(x=0XA394);
	op_hex		(x,	1);
	set_cmt	(0XA397,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer",	0);
	create_insn	(x=0XA397);
	op_hex		(x,	0);
	set_cmt	(0XA399,	"read failure",	0);
	set_cmt	(0XA39F,	"get offset of data again.",	0);
	set_cmt	(0XA3A5,	"move pointer back again",	0);
	set_cmt	(0XA3A9,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file",	0);
	create_insn	(x=0XA3A9);
	op_hex		(x,	0);
	set_cmt	(0XA3AE,	"(512+8) ; get length of the data from the file",	0);
	create_insn	(x=0XA3AE);
	op_dec		(x,	1);
	set_cmt	(0XA3B4,	"start of data buffer",	0);
	create_insn	(x=0XA3B4);
	op_dec		(x,	1);
	set_cmt	(0XA3B7,	"signature + a word for the length itself",	0);
	create_insn	(x=0XA3B7);
	op_dec		(x,	1);
	set_cmt	(0XA3BA,	"read the data from the file.",	0);
	create_insn	(x=0XA3BA);
	op_hex		(x,	1);
	set_cmt	(0XA3BD,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer",	0);
	create_insn	(x=0XA3BD);
	op_hex		(x,	0);
	set_cmt	(0XA3C5,	"save data id for future use.",	0);
	set_cmt	(0XA3C8,	"(512+8) ; si-> data buffer + id tag field",	0);
	create_insn	(x=0XA3C8);
	op_dec		(x,	1);
	set_cmt	(0XA3CB,	"get the length of the file",	0);
	set_cmt	(0XA3CD,	"take care of a word for lenght of tab itself.",	0);
	set_cmt	(0XA3CF,	"(2048-512-8) ; fit into the buffer?",	0);
	create_insn	(x=0XA3CF);
	op_dec		(x,	1);
	set_cmt	(0XA3D8,	"SetCountryInfo ; is the data for setcountryinfo table?",	0);
	set_cmt	(0XA3DA,	"no, don't worry",	0);
	set_cmt	(0XA3DC,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen]",	0);
	create_insn	(x=0XA3DC);
	op_dec		(x,	0);
	set_cmt	(0XA3E0,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen+2]\n\nat this time di -> cccountryinfolen",	0);
	create_insn	(x=0XA3E0);
	op_dec		(x,	0);
	set_cmt	(0XA3E6,	"do not use the code page info in country_info",	0);
	set_cmt	(0XA3EA,	"use the saved one for this !!!",	0);
	set_cmt	(0XA3EE,	"copy the table into dos",	0);
	set_cmt	(0XA3F0,	"SetCountryInfo ; was the ccmono_ptr saved?",	0);
	set_cmt	(0XA3F5,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen+2]",	0);
	create_insn	(x=0XA3F5);
	op_dec		(x,	0);
	set_cmt	(0XA3F9,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen]",	0);
	create_insn	(x=0XA3F9);
	op_dec		(x,	0);
	set_cmt	(0XA3FD,	"restore control buffer pointer",	0);
	set_cmt	(0XA3FE,	"restore # of entries left",	0);
	set_cmt	(0XA3FF,	"restore pointer to dso_country_cdpg",	0);
	set_cmt	(0XA400,	"try to get the next entry",	0);
	set_cmt	(0XA403,	"take a word of entry length itself",	0);
	create_insn	(0XA40D);
	set_cmt	(0XA40E,	"SetDBCS ; dbcs vector set?",	0);
	create_insn	(0XA40E);
	set_name	(0XA40E,	"setdbcs_before_copy");
	set_cmt	(0XA410,	"jump if not",	0);
	set_cmt	(0XA412,	"zero byte data block?",	0);
	set_cmt	(0XA416,	"jump if so",	0);
	set_cmt	(0XA41B,	"load block length",	0);
	set_cmt	(0XA41E,	"points actual data",	0);
	set_cmt	(0XA421,	"fill bytes",	0);
	set_cmt	(0XA423,	"clear data block",	0);
	set_cmt	(0XA429,	"get the destination address\n in the dos country info table.",	0);
	create_insn	(0XA429);
	set_name	(0XA429,	"getcountrydestination");
	set_cmt	(0XA42A,	"country_cdpg_info.ccNumber_of_entries\nskip the reserved area, syscodepage etc.",	0);
	create_insn	(x=0XA42A);
	op_dec		(x,	1);
	set_cmt	(0XA42D,	"get the number of entries",	0);
	set_cmt	(0XA431,	"si -> the first start entry id",	0);
	set_cmt	(0XA437,	"SetCountryInfo ; was it setcountryinfo entry?",	0);
	set_cmt	(0XA43D,	"next data id",	0);
	set_cmt	(0XA442,	"NEW_COUNTRY_SIZE+3 ; next data id",	0);
	create_insn	(x=0XA442);
	op_dec		(x,	1);
	set_cmt	(0XA44A,	"SetCountryInfo ; select country info?",	0);
	create_insn	(0XA44A);
	set_cmt	(0XA44E,	"now di -> cccountryinfolen",	0);
	set_cmt	(0XA451,	"get the destination in es:di",	0);
	create_insn	(0XA451);
	set_cmt	(0XA457,	"# of bytes to read",	0);
	create_insn	(0XA457);
	set_name	(0XA457,	"readincontrolbuffer");
	set_cmt	(0XA45C,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file",	0);
	create_insn	(x=0XA45C);
	op_hex		(x,	0);
	set_cmt	(0XA45E,	"# of bytes to read",	0);
	set_cmt	(0XA461,	"ds:dx -> control buffer",	0);
	set_cmt	(0XA465,	"read into the buffer\nshould be less than 1024 bytes.",	0);
	create_insn	(x=0XA465);
	op_hex		(x,	1);
	set_cmt	(0XA468,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer",	0);
	create_insn	(x=0XA468);
	op_hex		(x,	0);
	set_cmt	(0XA46B,	"! this procedure is not called from anywhere !\nErdogan Tan - 04/08/2023",	0);
	create_insn	(0XA46B);
	set_name	(0XA46B,	"set_country_path");
	create_insn	(x=0XA47B);
	op_hex		(x,	1);
	set_name	(0XA47B,	"scp_default_drv");
	set_cmt	(0XA47D,	"DOS - GET DEFAULT DISK NUMBER",	0);
	create_insn	(x=0XA47D);
	op_hex		(x,	0);
	create_insn	(x=0XA47F);
	op_chr		(x,	1);
	set_name	(0XA481,	"scp_setdrv");
	create_insn	(x=0XA485);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(x=0XA48A);
	op_chr		(x,	1);
	create_insn	(x=0XA48E);
	op_chr		(x,	1);
	create_insn	(0XA494);
	set_name	(0XA494,	"scp_root_dir");
	set_name	(0XA495,	"scp_path");
	create_insn	(x=0XA498);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	create_insn	(0XA4A1);
	set_name	(0XA4A1,	"chk_drive_letter");
	create_insn	(x=0XA4A2);
	op_chr		(x,	1);
	create_insn	(x=0XA4A7);
	op_chr		(x,	1);
	create_insn	(x=0XA4AC);
	op_chr		(x,	1);
	create_insn	(0XA4B4);
	create_insn	(0XA4B7);
	set_name	(0XA4B7,	"move_asciiz");
	set_cmt	(0XA4B8,	"was it 0?",	0);
	create_insn	(0XA4BF);
	set_name	(0XA4BF,	"badfil");
	create_insn	(x=0XA4C3);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0XA4C3,	"badload");
	create_insn	(x=0XA4C6);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_name	(0XA4C9,	"prnerr");
	create_insn	(x=0XA4D5);
	op_hex		(x,	1);
	set_cmt	(0XA4D7,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output",	0);
	create_insn	(x=0XA4D7);
	op_hex		(x,	0);
	create_insn	(0XA4DC);
	set_cmt	(0XA4E1,	"suppress line number when handling command.com",	0);
	create_insn	(x=0XA4ED);
	op_hex		(x,	1);
	set_name	(0XA4ED,	"print");
	set_cmt	(0XA4EF,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"",	0);
	create_insn	(x=0XA4EF);
	op_hex		(x,	0);
	create_insn	(0XA4F2);
	set_name	(0XA4F2,	"open_dev");
	create_insn	(x=0XA4F7);
	op_plain_offset	(x,	1,	0X5330);
	op_plain_offset	(x,	129,	0X5330);
	set_cmt	(0XA4FE,	"handle from open to bx",	0);
	create_insn	(0XA4FE);
	create_insn	(x=0XA502);
	op_hex		(x,	1);
	set_cmt	(0XA504,	"DOS - 2+ - IOCTL - GET DEVICE INFORMATION\nBX = file or device handle",	0);
	create_insn	(x=0XA504);
	op_hex		(x,	0);
	create_insn	(x=0XA506);
	op_hex		(x,	1);
	create_insn	(x=0XA50B);
	op_hex		(x,	1);
	set_cmt	(0XA50D,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle",	0);
	create_insn	(x=0XA50D);
	op_hex		(x,	0);
	set_cmt	(0XA511,	"OPEN",	0);
	create_insn	(x=0XA511);
	op_hex		(x,	1);
	set_name	(0XA511,	"open_file");
	set_cmt	(0XA514,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read, 1 - write, 2 - read & write",	0);
	create_insn	(x=0XA514);
	op_hex		(x,	0);
	set_cmt	(0XA517,	"fail the system call",	0);
	create_insn	(0XA517);
	set_name	(0XA517,	"int24");
	set_cmt	(0XA519,	"return back to dos.",	0);
	create_strlit	(0XA51A,	0XA58D);
	set_name	(0XA51A,	"IBMDOSV71COPYR");
	create_strlit	(0XA58D,	0XA591);
	set_name	(0XA58D,	"nuldev");
	create_strlit	(0XA591,	0XA595);
	set_name	(0XA591,	"condev");
	create_strlit	(0XA595,	0XA599);
	set_name	(0XA595,	"auxdev");
	create_strlit	(0XA599,	0XA59D);
	set_name	(0XA599,	"prndev");
	create_strlit	(0XA59D,	0XA5A9);
	set_name	(0XA59D,	"config");
	create_strlit	(0XA5A9,	0XA5AB);
	set_name	(0XA5A9,	"cntry_drv");
	create_byte	(x=0XA5AB);
	op_chr		(x,	0);
	set_name	(0XA5AB,	"cntry_root");
	create_strlit	(0XA5AC,	0XA5B8);
	set_name	(0XA5AC,	"cntry_path");
	create_byte	(x=0XA5B8);
	make_array	(x,	0X34);
	op_dec		(x,	0);
	create_strlit	(0XA5EC,	0XA5F4);
	set_name	(0XA5EC,	"country_file_signature");
	create_word	(0XA5F4);
	set_name	(0XA5F4,	"cntrycodepage_id");
	set_cmt	(0XA5F6,	"non-zero if non-std shell specified",	0);
	create_byte	(0XA5F6);
	set_name	(0XA5F6,	"newcmd");
	set_cmt	(0XA5F7,	"must precede commnd\nsize of commnd line (excl. null)\n5309h-52C9h = 40h = 64",	0);
	create_byte	(x=0XA5F7);
	make_array	(x,	0X2);
	op_dec		(x,	0);
	set_name	(0XA5F7,	"tmplate");
	set_cmt	(0XA5F8,	"must precede commnd\nsize of commnd line (excl. null)\n5309h-52C9h = 40h = 64",	0);
	create_strlit	(0XA5F9,	0XA606);
	set_name	(0XA5F9,	"commnd");
	create_byte	(x=0XA606);
	make_array	(x,	0X32);
	op_dec		(x,	0);
	create_byte	(0XA638);
	set_name	(0XA638,	"commnd_63");
	set_cmt	(0XA639,	"alternate commands to exec",	0);
	create_strlit	(0XA639,	0XA646);
	set_name	(0XA639,	"commnd2");
	set_cmt	(0XA646,	"followed by their respective alternate command lines",	0);
	create_strlit	(0XA646,	0XA64A);
	create_strlit	(0XA64A,	0XA65D);
	set_name	(0XA64A,	"commnd3");
	create_byte	(x=0XA65D);
	op_dec		(x,	0);
	create_strlit	(0XA65E,	0XA66A);
	create_strlit	(0XA66A,	0XA67B);
	set_name	(0XA66A,	"commnd4");
	create_byte	(0XA67B);
	create_strlit	(0XA67C,	0XA686);
	create_byte	(0XA686);
	set_name	(0XA686,	"def_swchr");
	create_strlit	(0XA687,	0XA68A);
	set_name	(0XA687,	"command_line");
	create_byte	(x=0XA68A);
	make_array	(x,	0X7B);
	op_dec		(x,	0);
	create_byte	(0XA705);
	set_name	(0XA705,	"command_line_126");
	create_byte	(0XA706);
	create_byte	(x=0XA707);
	make_array	(x,	0X40);
	op_dec		(x,	0);
	set_name	(0XA707,	"pathstring");
	create_byte	(0XA747);
	set_name	(0XA747,	"dae_flag");
	set_cmt	(0XA748,	"default fgnd/bgnd color",	0);
	create_byte	(0XA748);
	set_name	(0XA748,	"bMenuColor");
	set_cmt	(0XA749,	"menu video page (KEEP AFTER bMenuColor)",	0);
	create_byte	(0XA749);
	set_name	(0XA749,	"bMenuPage");
	set_cmt	(0XA74A,	"video page function # (KEEP AFTER bMenuPage)",	0);
	create_byte	(0XA74A);
	set_cmt	(0XA74B,	"ending column on status line",	0);
	create_byte	(0XA74B);
	set_name	(0XA74B,	"bLastCol");
	set_cmt	(0XA74C,	"row # of status line (KEEP AFTER bLastCol)",	0);
	create_byte	(x=0XA74C);
	op_dec		(x,	0);
	set_name	(0XA74C,	"bLastRow");
	set_cmt	(0XA74D,	"1=disable clean/interactive\n2=disable default 2-second delay",	0);
	create_byte	(0XA74D);
	set_name	(0XA74D,	"bDisableUI");
	set_cmt	(0XA74E,	"value saved from BIOS data area",	0);
	create_byte	(0XA74E);
	set_name	(0XA74E,	"bCRTPage");
	set_cmt	(0XA74F,	"value saved from BIOS data area",	0);
	create_word	(0XA74F);
	set_name	(0XA74F,	"wCRTStart");
	set_cmt	(0XA751,	"0=off, 1=prompt all, 2=prompt none, 4=skip all",	0);
	create_byte	(0XA751);
	set_name	(0XA751,	"bQueryOpt");
	set_cmt	(0XA752,	"default block #",	0);
	create_byte	(0XA752);
	set_name	(0XA752,	"bDefBlock");
	set_cmt	(0XA753,	"maximum block #",	0);
	create_byte	(0XA753);
	set_name	(0XA753,	"bMaxBlock");
	set_cmt	(0XA754,	"offset of name of default block (if any)",	0);
	create_word	(0XA754);
	set_name	(0XA754,	"offDefBlock");
	set_cmt	(0XA756,	"# of seconds for timeout (-1 == indefinite)",	0);
	create_byte	(0XA756);
	set_name	(0XA756,	"secTimeOut");
	set_cmt	(0XA757,	"# of seconds elapsed so far (KEEP AFTER secTimeOut)",	0);
	create_byte	(0XA757);
	set_name	(0XA757,	"secElapsed");
	set_cmt	(0XA758,	"times MAX_MULTI_CONFIG+1 db 0\narray of block types",	0);
	create_byte	(x=0XA758);
	make_array	(x,	0XA);
	op_dec		(x,	0);
	set_name	(0XA758,	"abBlockType");
	set_cmt	(0XA762,	"times MAX_MULTI_CONFIG+1 dw 0\narray of offsets of block names",	0);
	create_word	(x=0XA762);
	make_array	(x,	0XA);
	op_dec		(x,	0);
	set_name	(0XA762,	"aoffBlockName");
	set_cmt	(0XA776,	"times MAX_MULTI_CONFIG+1 dw 0\narray of offsets of block descriptions",	0);
	create_word	(x=0XA776);
	make_array	(x,	0XA);
	op_dec		(x,	0);
	set_name	(0XA776,	"aoffBlockDesc");
	create_strlit	(0XA78A,	0XA792);
	set_name	(0XA78A,	"szBoot");
	create_strlit	(0XA792,	0XA797);
	set_name	(0XA792,	"szMenu");
	create_strlit	(0XA797,	0XA79E);
	set_name	(0XA797,	"szCommon");
	set_cmt	(0XA79E,	"CONFIG.SYS Command Table\nCONFIG_BEGIN",	0);
	create_strlit	(0XA79E,	0XA7A1);
	set_name	(0XA79E,	"comtab");
	set_cmt	(0XA7A1,	"CONFIG_BREAK",	0);
	create_strlit	(0XA7A1,	0XA7A8);
	set_name	(0XA7A1,	"aBreak");
	set_cmt	(0XA7A8,	"CONFIG_BUFFERS",	0);
	create_strlit	(0XA7A8,	0XA7B1);
	set_name	(0XA7A8,	"aBuffers");
	set_cmt	(0XA7B1,	"CONFIG_COMMENT",	0);
	create_strlit	(0XA7B1,	0XA7BA);
	set_name	(0XA7B1,	"aComment");
	set_cmt	(0XA7BA,	"CONFIG_COUNTRY",	0);
	create_strlit	(0XA7BA,	0XA7C3);
	set_name	(0XA7BA,	"aCountry");
	set_cmt	(0XA7C3,	"CONFIG_DEVICE",	0);
	create_strlit	(0XA7C3,	0XA7CB);
	set_name	(0XA7C3,	"aDevice");
	set_cmt	(0XA7CB,	"CONFIG_DEVICEHIGH",	0);
	create_strlit	(0XA7CB,	0XA7D7);
	set_name	(0XA7CB,	"aDevicehigh");
	set_cmt	(0XA7D7,	"CONFIG_DOS",	0);
	create_strlit	(0XA7D7,	0XA7DC);
	set_name	(0XA7D7,	"aDos");
	set_cmt	(0XA7DC,	"CONFIG_DRIVPARM",	0);
	create_strlit	(0XA7DC,	0XA7E6);
	set_name	(0XA7DC,	"aDrivparm");
	set_cmt	(0XA7E6,	"CONFIG_FCBS",	0);
	create_strlit	(0XA7E6,	0XA7EC);
	set_name	(0XA7E6,	"aFcbs");
	set_cmt	(0XA7EC,	"CONFIG_FILES",	0);
	create_strlit	(0XA7EC,	0XA7F3);
	set_name	(0XA7EC,	"aFiles");
	set_cmt	(0XA7F3,	"CONFIG_INCLUDE",	0);
	create_strlit	(0XA7F3,	0XA7FC);
	set_name	(0XA7F3,	"aInclude");
	set_cmt	(0XA7FC,	"CONFIG_INSTALL",	0);
	create_strlit	(0XA7FC,	0XA805);
	set_name	(0XA7FC,	"aInstall");
	set_cmt	(0XA805,	"CONFIG_INSTALLHIGH",	0);
	create_strlit	(0XA805,	0XA812);
	set_name	(0XA805,	"aInstallhigh");
	set_cmt	(0XA812,	"CONFIG_LASTDRIVE",	0);
	create_strlit	(0XA812,	0XA81D);
	set_name	(0XA812,	"aLastdrive");
	set_cmt	(0XA81D,	"CONFIG_SUBMENU",	0);
	create_strlit	(0XA81D,	0XA826);
	set_name	(0XA81D,	"aSubmenu");
	set_cmt	(0XA826,	"CONFIG_MENUCOLOR",	0);
	create_strlit	(0XA826,	0XA831);
	set_name	(0XA826,	"aMenucolor");
	set_cmt	(0XA831,	"CONFIG_MENUDEFAULT",	0);
	create_strlit	(0XA831,	0XA83E);
	set_name	(0XA831,	"aMenudefault");
	set_cmt	(0XA83E,	"CONFIG_MENUITEM",	0);
	create_strlit	(0XA83E,	0XA848);
	set_name	(0XA83E,	"aMenuitem");
	set_cmt	(0XA848,	"CONFIG_MULTITRACK",	0);
	create_strlit	(0XA848,	0XA854);
	set_name	(0XA848,	"aMultitrack");
	set_cmt	(0XA854,	"CONFIG_NUMLOCK",	0);
	create_strlit	(0XA854,	0XA85D);
	set_name	(0XA854,	"aNumlock");
	set_cmt	(0XA85D,	"CONFIG_REM",	0);
	create_strlit	(0XA85D,	0XA862);
	set_name	(0XA85D,	"aRem");
	set_cmt	(0XA862,	"CONFIG_SET",	0);
	create_strlit	(0XA862,	0XA867);
	set_name	(0XA862,	"aSet");
	set_cmt	(0XA867,	"CONFIG_SHELL",	0);
	create_strlit	(0XA867,	0XA86E);
	set_name	(0XA867,	"aShell");
	set_cmt	(0XA86E,	"CONFIG_STACKS",	0);
	create_strlit	(0XA86E,	0XA876);
	set_name	(0XA86E,	"aStacks");
	set_cmt	(0XA876,	"CONFIG_SWITCHES",	0);
	create_strlit	(0XA876,	0XA880);
	set_name	(0XA876,	"aSwitches");
	set_cmt	(0XA880,	"CONFIG_DOSDATA",	0);
	create_strlit	(0XA880,	0XA889);
	set_name	(0XA880,	"aDosdata");
	set_cmt	(0XA889,	"end of command table",	0);
	create_byte	(0XA889);
	set_cmt	(0XA88A,	"deviceparameters",	0);
	create_byte	(0XA88A);
	set_name	(0XA88A,	"devp_specialfunc");
	create_byte	(0XA88B);
	set_name	(0XA88B,	"devp_devtype");
	create_word	(0XA88C);
	set_name	(0XA88C,	"devp_devattr");
	create_word	(x=0XA88E);
	op_dec		(x,	0);
	set_name	(0XA88E,	"devp_cylinders");
	create_byte	(0XA890);
	set_cmt	(0XA891,	"A_DEVICEPARAMETERS.DP_BPB\nbytes per sectors",	0);
	create_word	(0XA891);
	set_name	(0XA891,	"devp_bps");
	create_byte	(0XA893);
	set_name	(0XA893,	"devp_secperclus");
	create_word	(0XA894);
	create_byte	(0XA896);
	create_word	(0XA897);
	set_cmt	(0XA899,	"total sectors",	0);
	create_word	(0XA899);
	set_name	(0XA899,	"devp_totalsecs");
	create_byte	(0XA89B);
	set_name	(0XA89B,	"devp_mediaid");
	create_word	(0XA89C);
	create_word	(0XA89E);
	set_name	(0XA89E,	"devp_spt");
	create_word	(0XA8A0);
	set_name	(0XA8A0,	"devp_heads");
	create_byte	(x=0XA8A2);
	make_array	(x,	0X44);
	op_dec		(x,	0);
	create_word	(0XA8E6);
	set_name	(0XA8E6,	"devp_trktblents");
	create_byte	(x=0XA8E8);
	make_array	(x,	0XFC);
	op_dec		(x,	0);
	create_word	(0XA9E4);
	set_name	(0XA9E4,	"hlim");
	create_word	(0XA9E6);
	set_name	(0XA9E6,	"slim");
	create_byte	(0XA9E8);
	set_name	(0XA9E8,	"drive");
	create_word	(0XA9E9);
	set_name	(0XA9E9,	"switches");
	set_cmt	(0XA9EB,	"48 tpi diskettes",	0);
	create_word	(x=0XA9EB);
	op_dec		(x,	0);
	set_name	(0XA9EB,	"_bpb48t");
	create_byte	(0XA9ED);
	create_word	(0XA9EE);
	create_byte	(0XA9F0);
	create_word	(x=0XA9F1);
	op_dec		(x,	0);
	set_cmt	(0XA9F3,	"2*9*40",	0);
	create_word	(x=0XA9F3);
	op_dec		(x,	0);
	create_byte	(0XA9F5);
	create_word	(0XA9F6);
	create_word	(0XA9F8);
	create_word	(0XA9FA);
	create_dword	(0XA9FC);
	create_dword	(0XAA00);
	set_cmt	(0XAA04,	"96tpi diskettes",	0);
	create_word	(x=0XAA04);
	op_dec		(x,	0);
	set_name	(0XAA04,	"_bpb96t");
	create_byte	(0XAA06);
	create_word	(0XAA07);
	create_byte	(0XAA09);
	create_word	(x=0XAA0A);
	op_dec		(x,	0);
	set_cmt	(0XAA0C,	"2*15*80",	0);
	create_word	(x=0XAA0C);
	op_dec		(x,	0);
	create_byte	(0XAA0E);
	create_word	(0XAA0F);
	create_word	(x=0XAA11);
	op_dec		(x,	0);
	create_word	(0XAA13);
	create_dword	(0XAA15);
	create_dword	(0XAA19);
	set_cmt	(0XAA1D,	"3 1/2 inch diskette bpb",	0);
	create_word	(0XAA1D);
	set_name	(0XAA1D,	"_bpb35");
	create_byte	(0XAA1F);
	create_word	(0XAA20);
	create_byte	(0XAA22);
	create_word	(x=0XAA23);
	op_dec		(x,	0);
	set_cmt	(0XAA25,	"2*9*80",	0);
	create_word	(x=0XAA25);
	op_dec		(x,	0);
	create_byte	(0XAA27);
	create_word	(0XAA28);
	create_word	(0XAA2A);
	create_word	(0XAA2C);
	create_dword	(0XAA2E);
	create_dword	(0XAA32);
	create_word	(x=0XAA36);
	op_dec		(x,	0);
	set_name	(0XAA36,	"_bpb35h");
	create_byte	(0XAA38);
	create_word	(0XAA39);
	create_byte	(0XAA3B);
	create_word	(x=0XAA3C);
	op_dec		(x,	0);
	set_cmt	(0XAA3E,	"2*18*80",	0);
	create_word	(x=0XAA3E);
	op_dec		(x,	0);
	create_byte	(0XAA40);
	create_word	(0XAA41);
	create_word	(x=0XAA43);
	op_dec		(x,	0);
	create_word	(0XAA45);
	create_dword	(0XAA47);
	create_dword	(0XAA4B);
	create_word	(x=0XAA4F);
	op_dec		(x,	0);
	set_name	(0XAA4F,	"_bpb288");
	create_byte	(0XAA51);
	create_word	(0XAA52);
	create_byte	(0XAA54);
	create_word	(x=0XAA55);
	op_dec		(x,	0);
	set_cmt	(0XAA57,	"2*36*80",	0);
	create_word	(x=0XAA57);
	op_dec		(x,	0);
	create_byte	(0XAA59);
	create_word	(0XAA5A);
	create_word	(x=0XAA5C);
	op_dec		(x,	0);
	create_word	(0XAA5E);
	create_dword	(0XAA60);
	create_dword	(0XAA64);
	set_cmt	(0XAA68,	"48tpi drives",	0);
	create_word	(x=0XAA68);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_name	(0XAA68,	"_bpbtable");
	set_cmt	(0XAA6A,	"96tpi drives",	0);
	create_word	(x=0XAA6A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA6C,	"3.5\" drives",	0);
	create_word	(x=0XAA6C);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA6E,	"not used - 8\" drives - default to 3.5\"",	0);
	create_word	(x=0XAA6E);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA70,	"not used - 8\" drives - default to 3.5\"",	0);
	create_word	(x=0XAA70);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA72,	"not used - hard files - default to 3.5\"",	0);
	create_word	(x=0XAA72);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA74,	"not used - tape drives - default to 3.5\"",	0);
	create_word	(x=0XAA74);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA76,	"3-1/2\" 1.44mb drive",	0);
	create_word	(x=0XAA76);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA78,	"ERIMO",	0);
	create_word	(x=0XAA78);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA7A,	"2.88 MB diskette drives",	0);
	create_word	(x=0XAA7A);
	op_plain_offset	(x,	0,	0X5330);
	op_plain_offset	(x,	128,	0X5330);
	set_cmt	(0XAA7C,	"preserve the positions of n and c",	0);
	create_strlit	(0XAA7C,	0XAA85);
	set_name	(0XAA7C,	"switchlist");
	create_byte	(0XAA85);
	create_strlit	(0XAA86,	0XAAAA);
	set_name	(0XAA86,	"badopm");
	create_strlit	(0XAAAA,	0XAAAD);
	set_name	(0XAAAA,	"crlfm");
	create_strlit	(0XAAAD,	0XAACC);
	set_name	(0XAAAD,	"badparm");
	create_strlit	(0XAACC,	0XAAED);
	set_name	(0XAACC,	"badsiz_pre");
	create_strlit	(0XAAED,	0XAAFF);
	set_name	(0XAAED,	"badld_pre");
	create_strlit	(0XAAFF,	0XAB13);
	set_name	(0XAAFF,	"badcom");
	create_strlit	(0XAB13,	0XAB39);
	set_name	(0XAB13,	"badcountry");
	create_strlit	(0XAB39,	0XAB56);
	set_name	(0XAB39,	"badcountrycom");
	create_strlit	(0XAB56,	0XAB83);
	set_name	(0XAB56,	"insufmemory");
	create_strlit	(0XAB83,	0XABAA);
	set_name	(0XAB83,	"badmem");
	create_strlit	(0XABAA,	0XABC5);
	set_name	(0XABAA,	"badblock");
	create_strlit	(0XABC5,	0XABE2);
	set_name	(0XABC5,	"badstack");
	create_strlit	(0XABE2,	0XAC08);
	set_name	(0XABE2,	"badorder");
	create_strlit	(0XAC08,	0XAC22);
	set_name	(0XAC08,	"errorcmd");
	create_strlit	(0XAC22,	0XAC24);
	set_name	(0XAC22,	"OnOff");
	create_strlit	(0XAC24,	0XAC27);
	set_name	(0XAC24,	"OnOff2");
	create_strlit	(0XAC27,	0XAC3D);
	set_name	(0XAC27,	"StartMsg");
	create_strlit	(0XAC3D,	0XAC5C);
	set_name	(0XAC3D,	"_$PauseMsg");
	create_strlit	(0XAC5C,	0XAC9A);
	set_name	(0XAC5C,	"_$CleanMsg");
	create_strlit	(0XAC9A,	0XACD7);
	set_name	(0XAC9A,	"_$InterMsg");
	create_strlit	(0XACD7,	0XACF6);
	set_name	(0XACD7,	"_$MenuHeader");
	set_cmt	(0XACF6,	"'═' ; ASCII code 205",	0);
	create_strlit	(0XACF6,	0XAD0E);
	create_strlit	(0XAD0E,	0XAD10);
	create_strlit	(0XAD11,	0XAD24);
	set_name	(0XAD11,	"_$MenuPrmpt");
	create_strlit	(0XAD24,	0XAD74);
	set_name	(0XAD24,	"_$StatusLine");
	create_strlit	(0XAD74,	0XAD80);
	set_name	(0XAD74,	"_$InterPrmpt");
	create_strlit	(0XAD80,	0XAD84);
	set_name	(0XAD80,	"_$YES");
	create_strlit	(0XAD84,	0XAD88);
	set_name	(0XAD84,	"_$NO");
	create_strlit	(0XAD88,	0XAD99);
	set_name	(0XAD88,	"_$TimeOut");
	create_strlit	(0XAD99,	0XADE3);
	set_name	(0XAD99,	"badcomprmpt");
	create_strlit	(0XADE3,	0XADFF);
	set_name	(0XADE3,	"_$AutoPrmpt");
	create_strlit	(0XADFF,	0XAE3B);
	set_name	(0XADFF,	"TooManyDrivesMsg");
	create_strlit	(0XAE3B,	0XAE69);
	set_name	(0XAE3B,	"baddblspace");
	create_byte	(0XAE69);
	make_array	(0XAE69,	0X7);
}

static Functions_0(void) {

	add_func    (0X36B,0X39B);
	set_func_flags(0X36B,0x4400);
	set_frame_size(0X36B, 0, 0, 0);
	set_name(0X38C, "not_hard_disk", SN_LOCAL);
	set_name(0X398, "int13h_ext_err", SN_LOCAL);
	add_func    (0X39B,0X49C);
	set_func_flags(0X39B,0x4400);
	set_frame_size(0X39B, 0, 0, 0);
	add_func    (0X49C,0X54C);
	set_func_flags(0X49C,0x4400);
	set_frame_size(0X49C, 0, 0, 0);
	add_func    (0X54C,0X5A8);
	set_func_flags(0X54C,0x4400);
	set_frame_size(0X54C, 0X6, 0, 0);
	set_name(0X56D, "not_same_fat_sector", SN_LOCAL);
	set_name(0X59F, "SplitChk", SN_LOCAL);
	add_func    (0XC53,0XC72);
	set_func_flags(0XC53,0x400);
	set_name(0XC68, "ce_enter_codeseg", SN_LOCAL);
	set_name(0XC6D, "not_from_dos", SN_LOCAL);
	add_func    (0XC72,0XC98);
	set_func_flags(0XC72,0x402);
	set_frame_size(0XC72, 0XA, 0, 0);
	add_func    (0XC9F,0XCDD);
	set_func_flags(0XC9F,0x402);
	add_func    (0XCDD,0XCFB);
	set_func_flags(0XCDD,0x4402);
	set_frame_size(0XCDD, 0, 0, 0X2);
	add_func    (0XCFB,0XD1A);
	set_func_flags(0XCFB,0x4402);
	set_frame_size(0XCFB, 0, 0, 0);
	add_func    (0XD1A,0XD2B);
	set_func_flags(0XD1A,0x4400);
	set_frame_size(0XD1A, 0, 0, 0);
	set_name(0XD2A, "enable_A20_ok", SN_LOCAL);
	add_func    (0XD2B,0XD49);
	set_func_flags(0XD2B,0x4400);
	set_frame_size(0XD2B, 0, 0, 0);
	add_func    (0XDB1,0XDC7);
	set_func_flags(0XDB1,0x4400);
	set_frame_size(0XDB1, 0X4, 0, 0);
	add_func    (0X1D4A,0X1DA2);
	set_func_flags(0X1D4A,0x401);
	set_frame_size(0X1D4A, 0, 0, 0);
	set_name(0X1D5C, "setc1", SN_LOCAL);
	add_func    (0X1DA2,0X1DE0);
	set_func_flags(0X1DA2,0x401);
	set_frame_size(0X1DA2, 0, 0, 0);
	set_name(0X1DAA, "doc1", SN_LOCAL);
	set_name(0X1DB8, "rsct_loop", SN_LOCAL);
	set_name(0X1DD3, "doc2", SN_LOCAL);
	add_func    (0X1DE0,0X1DE8);
	set_func_flags(0X1DE0,0x401);
	add_func    (0X1DE8,0X1DF0);
	set_func_flags(0X1DE8,0x401);
	add_func    (0X1DF0,0X1DF8);
	set_func_flags(0X1DF0,0x401);
	add_func    (0X1DF8,0X1E00);
	set_func_flags(0X1DF8,0x401);
	add_func    (0X1E00,0X1E08);
	set_func_flags(0X1E00,0x401);
	add_func    (0X1E08,0X1E10);
	set_func_flags(0X1E08,0x401);
	add_func    (0X1E5C,0X1F0C);
	set_func_flags(0X1E5C,0x4400);
	set_frame_size(0X1E5C, 0, 0, 0);
	set_name(0X1E79, "read_ok", SN_LOCAL);
	set_name(0X1EB6, "century_19", SN_LOCAL);
	set_name(0X1EDA, "leap_year", SN_LOCAL);
	set_name(0X1EE1, "leap_adjustment", SN_LOCAL);
	set_name(0X1EE5, "no_leap_adjustment", SN_LOCAL);
	set_name(0X1EFC, "r_d_sum_loop", SN_LOCAL);
	set_name(0X1F03, "r_d_ret", SN_LOCAL);
	add_func    (0X1F12,0X1F4B);
	set_func_flags(0X1F12,0x4400);
	set_frame_size(0X1F12, 0, 0, 0);
	set_name(0X1F0C, "r_t_retj", SN_LOCAL);
	set_name(0X1F4A, "r_t_ret", SN_LOCAL);
	add_func    (0X1F4B,0X1F70);
	set_func_flags(0X1F4B,0x4400);
	set_frame_size(0X1F4B, 0, 0, 0);
	add_func    (0X1F70,0X1F7B);
	set_func_flags(0X1F70,0x4400);
	set_frame_size(0X1F70, 0, 0, 0);
	add_func    (0X1F7B,0X1FB9);
	set_func_flags(0X1F7B,0x4400);
	set_frame_size(0X1F7B, 0, 0, 0);
	set_name(0X1F92, "century_20", SN_LOCAL);
	set_name(0X1FB7, "date_error", SN_LOCAL);
	add_func    (0X1FB9,0X1FD2);
	set_func_flags(0X1FB9,0x4400);
	set_frame_size(0X1FB9, 0, 0, 0);
	set_name(0X1FD0, "time_error", SN_LOCAL);
	add_func    (0X1FD2,0X1FFB);
	set_func_flags(0X1FD2,0x4400);
	set_frame_size(0X1FD2, 0, 0, 0);
	set_name(0X1FD8, "bv_loop", SN_LOCAL);
	set_name(0X1FF9, "bv_error", SN_LOCAL);
	add_func    (0X2A54,0X2AB9);
	set_func_flags(0X2A54,0x4400);
	set_frame_size(0X2A54, 0, 0, 0);
	set_name(0X2A59, "drive_loop", SN_LOCAL);
	set_name(0X2A68, "fdrv_found", SN_LOCAL);
	set_name(0X2A6A, "fdrv_loop", SN_LOCAL);
	set_name(0X2A85, "remap_loop1", SN_LOCAL);
	set_name(0X2AA3, "remap_boot_flop", SN_LOCAL);
	set_name(0X2AA8, "remap_change_boot_drv", SN_LOCAL);
	set_name(0X2AB8, "rmap_exit", SN_LOCAL);
	add_func    (0X2AB9,0X2AD9);
	set_func_flags(0X2AB9,0x4400);
	set_frame_size(0X2AB9, 0, 0, 0);
	add_func    (0X2AD9,0X2DE6);
	set_func_flags(0X2AD9,0x4400);
	set_frame_size(0X2AD9, 0X4, 0, 0);
	set_name(0X2B0F, "setret_j", SN_LOCAL);
	set_name(0X2B2B, "act_part", SN_LOCAL);
	set_name(0X2B5C, "no_act", SN_LOCAL);
	set_name(0X2B99, "not_prim", SN_LOCAL);
	set_name(0X2BA2, "setret", SN_LOCAL);
	set_name(0X2BE1, "okdrive_1", SN_LOCAL);
	set_name(0X2BFF, "set_lba_flag", SN_LOCAL);
	set_name(0X2C03, "set3", SN_LOCAL);
	set_name(0X2C3B, "set3_read", SN_LOCAL);
	set_name(0X2CA7, "set3_lba_read_ok", SN_LOCAL);
	set_name(0X2CB7, "oknotmini", SN_LOCAL);
	set_name(0X2CD5, "set3_read_ok", SN_LOCAL);
	set_name(0X2CFE, "check_1", SN_LOCAL);
	set_name(0X2D11, "check_2", SN_LOCAL);
	set_name(0X2D2D, "ck_power_of_two", SN_LOCAL);
	set_name(0X2D33, "invalid_boot_record", SN_LOCAL);
	set_name(0X2D38, "valid_boot_record", SN_LOCAL);
	set_name(0X2D4B, "unknown3_0_j", SN_LOCAL);
	set_name(0X2D4E, "try5", SN_LOCAL);
	set_name(0X2D66, "no_os2", SN_LOCAL);
	set_name(0X2D77, "copybpb", SN_LOCAL);
	set_name(0X2D87, "check_3", SN_LOCAL);
	set_name(0X2D8D, "check_4", SN_LOCAL);
	set_name(0X2DCD, "already_nonz", SN_LOCAL);
	add_func    (0X2DE6,0X2FE5);
	set_func_flags(0X2DE6,0x4400);
	set_frame_size(0X2DE6, 0, 0, 0);
	set_name(0X2E01, "copy_totsec", SN_LOCAL);
	set_name(0X2E07, "fat_big_small", SN_LOCAL);
	set_name(0X2E67, "fat_16bit", SN_LOCAL);
	set_name(0X2E6E, "fat_32bit", SN_LOCAL);
	set_name(0X2EA6, "fat32_clust_limit", SN_LOCAL);
	set_name(0X2EB2, "fat16_clust_limit", SN_LOCAL);
	set_name(0X2EBB, "chk_clnum_hw", SN_LOCAL);
	set_name(0X2EC3, "fat12_clust_limit", SN_LOCAL);
	set_name(0X2ECD, "copymediaid", SN_LOCAL);
	set_name(0X2EDF, "toobig_ret", SN_LOCAL);
	set_name(0X2EF5, "scan", SN_LOCAL);
	set_name(0X2F02, "scan_next", SN_LOCAL);
	set_name(0X2F07, "gotparm", SN_LOCAL);
	set_name(0X2F47, "dobig", SN_LOCAL);
	set_name(0X2F7F, "dobig1", SN_LOCAL);
	set_name(0X2FAA, "dobig2", SN_LOCAL);
	add_func    (0X2FE5,0X302D);
	set_func_flags(0X2FE5,0x4400);
	set_frame_size(0X2FE5, 0, 0, 0);
	set_name(0X3007, "cfb_chk_totalsecs", SN_LOCAL);
	set_name(0X3029, "cfb_retit", SN_LOCAL);
	add_func    (0X3033,0X30EE);
	set_func_flags(0X3033,0x4400);
	set_frame_size(0X3033, 0, 0, 0);
	set_name(0X3039, "_next_bds", SN_LOCAL);
	set_name(0X3056, "get_ccyl", SN_LOCAL);
	set_name(0X3077, "no_cyl_rnd", SN_LOCAL);
	set_name(0X3082, "nothardff", SN_LOCAL);
	set_name(0X30A2, "_again", SN_LOCAL);
	set_name(0X30AD, "_@@", SN_LOCAL);
	set_name(0X30B7, "__@@", SN_LOCAL);
	set_name(0X30D1, "not_process_other", SN_LOCAL);
	set_name(0X30D8, "set_recbpb", SN_LOCAL);
	set_name(0X30E0, "go_to_next_bds", SN_LOCAL);
	set_name(0X30ED, "got_end_of_bds_chain", SN_LOCAL);
	add_func    (0X30EE,0X30F6);
	set_func_flags(0X30EE,0x4400);
	set_frame_size(0X30EE, 0, 0, 0);
	add_func    (0X30F6,0X3100);
	set_func_flags(0X30F6,0x4400);
	set_frame_size(0X30F6, 0, 0, 0);
	add_func    (0X3100,0X314C);
	set_func_flags(0X3100,0x4400);
	set_frame_size(0X3100, 0, 0, 0);
	set_name(0X310B, "domini_loop", SN_LOCAL);
	set_name(0X3143, "domininext", SN_LOCAL);
	set_name(0X314B, "dominiret", SN_LOCAL);
	add_func    (0X314C,0X3282);
	set_func_flags(0X314C,0x4400);
	set_frame_size(0X314C, 0, 0, 0);
	set_name(0X3156, "fmpnext", SN_LOCAL);
	set_name(0X3178, "fmpnextfound", SN_LOCAL);
	set_name(0X317B, "fmpgot", SN_LOCAL);
	set_name(0X31BC, "fmpgot1", SN_LOCAL);
	set_name(0X31F7, "fmpgot2", SN_LOCAL);
	set_name(0X321D, "fmpgot_lba_rd", SN_LOCAL);
	set_name(0X3253, "fmpgot_chs_rd", SN_LOCAL);
	set_name(0X3267, "fmpgot3", SN_LOCAL);
	set_name(0X327E, "fmpnextchain", SN_LOCAL);
	set_name(0X3281, "_fmpnextfound", SN_LOCAL);
	add_func    (0X3282,0X32BC);
	set_func_flags(0X3282,0x4400);
	set_frame_size(0X3282, 0X4, 0, 0);
	set_name(0X3286, "setmini_1", SN_LOCAL);
	set_name(0X32B9, "setmini_2", SN_LOCAL);
	add_func    (0X32BC,0X32D1);
	set_func_flags(0X32BC,0x4400);
	set_frame_size(0X32BC, 0, 0, 0);
	set_name(0X32D0, "dmax_ok", SN_LOCAL);
	add_func    (0X32D1,0X3307);
	set_func_flags(0X32D1,0x4400);
	set_frame_size(0X32D1, 0X4, 0, 0);
	set_name(0X32D7, "xinstall_bds_1", SN_LOCAL);
	set_name(0X32E0, "xinstall_bds_2", SN_LOCAL);
	add_func    (0X3307,0X3345);
	set_func_flags(0X3307,0x4400);
	set_frame_size(0X3307, 0X8, 0, 0);
	set_name(0X330D, "loop_clock", SN_LOCAL);
	set_name(0X3328, "delay", SN_LOCAL);
	set_name(0X332C, "clock_present", SN_LOCAL);
	set_name(0X3340, "no_readdate", SN_LOCAL);
	add_func    (0X3345,0X3375);
	set_func_flags(0X3345,0x4400);
	set_frame_size(0X3345, 0, 0, 0);
	set_name(0X335E, "cmosck4", SN_LOCAL);
	set_name(0X3373, "cmosck9", SN_LOCAL);
	add_func    (0X3375,0X3394);
	set_func_flags(0X3375,0x4400);
	set_frame_size(0X3375, 0, 0, 0);
	add_func    (0X3394,0X3395);
	set_func_flags(0X3394,0x402);
	add_func    (0X3395,0X33B2);
	set_func_flags(0X3395,0x4400);
	set_frame_size(0X3395, 0, 0, 0);
	add_func    (0X33B4,0X34CA);
	set_func_flags(0X33B4,0x4400);
	set_frame_size(0X33B4, 0X4, 0, 0);
	set_name(0X33E8, "unpack", SN_LOCAL);
	set_name(0X3412, "not_32bit_cluster", SN_LOCAL);
	set_name(0X3444, "even_odd", SN_LOCAL);
	set_name(0X3452, "havclus", SN_LOCAL);
	set_name(0X345A, "unpack16", SN_LOCAL);
	set_name(0X3468, "unpackx", SN_LOCAL);
	set_name(0X346A, "getcl1", SN_LOCAL);
	set_name(0X3482, "not_consenquental", SN_LOCAL);
	set_name(0X348E, "getcl2", SN_LOCAL);
	set_name(0X34AC, "getcl3", SN_LOCAL);
	add_func    (0X34CA,0X3530);
	set_func_flags(0X34CA,0x4400);
	set_frame_size(0X34CA, 0, 0, 0);
	set_name(0X3524, "gfs_split_chk", SN_LOCAL);
	add_func    (0X3605,0X3613);
	set_func_flags(0X3605,0x4400);
	set_frame_size(0X3605, 0, 0, 0);
	add_func    (0X368C,0X3696);
	set_func_flags(0X368C,0x4400);
	set_frame_size(0X368C, 0, 0, 0);
	add_func    (0X3696,0X36CF);
	set_func_flags(0X3696,0x4000);
	set_frame_size(0X3696, 0, 0, 0);
	set_name(0X36B3, "alt_ext_chk", SN_LOCAL);
	set_name(0X36C6, "not_ext", SN_LOCAL);
	set_name(0X36CA, "alt_save", SN_LOCAL);
	set_name(0X36CE, "keyret", SN_LOCAL);
	add_func    (0X36CF,0X372D);
	set_func_flags(0X36CF,0x4400);
	set_frame_size(0X36CF, 0, 0, 0);
	add_func    (0X372D,0X3737);
	set_func_flags(0X372D,0x400);
	add_func    (0X3739,0X374A);
	set_func_flags(0X3739,0x400);
	set_frame_size(0X3739, 0, 0, 0);
	add_func    (0X378E,0X3790);
	set_func_flags(0X378E,0x400);
	add_func    (0X3790,0X37C7);
	set_func_flags(0X3790,0x4400);
	set_frame_size(0X3790, 0, 0, 0);
	set_name(0X37B2, "NextTest", SN_LOCAL);
	set_name(0X37C0, "ret1", SN_LOCAL);
	set_name(0X37C1, "checknotready", SN_LOCAL);
	add_func    (0X3896,0X3898);
	set_func_flags(0X3896,0x400);
	add_func    (0X3898,0X38AB);
	set_func_flags(0X3898,0x4400);
	set_frame_size(0X3898, 0, 0, 0);
	add_func    (0X38CC,0X38D5);
	set_func_flags(0X38CC,0x4400);
	set_frame_size(0X38CC, 0, 0, 0);
	add_func    (0X3970,0X3A1A);
	set_func_flags(0X3970,0x4400);
	set_frame_size(0X3970, 0, 0, 0);
	set_name(0X3984, "century20", SN_LOCAL);
	set_name(0X3990, "years", SN_LOCAL);
	set_name(0X39BF, "regularyear", SN_LOCAL);
	set_name(0X39E5, "months", SN_LOCAL);
	set_name(0X39F2, "month_done", SN_LOCAL);
	add_func    (0X3A1A,0X3A1F);
	set_func_flags(0X3A1A,0x400);
	set_frame_size(0X3A1A, 0, 0, 0);
	add_func    (0X3A6C,0X3A86);
	set_func_flags(0X3A6C,0x4400);
	set_frame_size(0X3A6C, 0, 0, 0);
	set_name(0X3A7D, "inc_case", SN_LOCAL);
	set_name(0X3A85, "no_rollover", SN_LOCAL);
	add_func    (0X3ADE,0X3AF2);
	set_func_flags(0X3ADE,0x4400);
	set_frame_size(0X3ADE, 0, 0, 0);
	set_name(0X3AE2, "X_Scan_Loop", SN_LOCAL);
	set_name(0X3AF1, "X_SetDrv", SN_LOCAL);
	add_func    (0X3B64,0X3B93);
	set_func_flags(0X3B64,0x4400);
	set_frame_size(0X3B64, 0, 0, 0);
	set_name(0X3B89, "timepassed", SN_LOCAL);
	set_name(0X3B8E, "timecheck_unk", SN_LOCAL);
	set_name(0X3B8F, "timecheck_ret", SN_LOCAL);
	add_func    (0X3B95,0X3BDB);
	set_func_flags(0X3B95,0x4400);
	set_frame_size(0X3B95, 0, 0, 0);
	add_func    (0X3BDB,0X3C14);
	set_func_flags(0X3BDB,0x4400);
	set_frame_size(0X3BDB, 0X2, 0, 0);
	set_name(0X3C0A, "ci_bigfat", SN_LOCAL);
	add_func    (0X3C14,0X3CF6);
	set_func_flags(0X3C14,0x4000);
	set_frame_size(0X3C14, 0, 0, 0);
	set_name(0X3C2D, "getbp_err_ret_brdg", SN_LOCAL);
	set_name(0X3C30, "dofatbpb", SN_LOCAL);
	set_name(0X3C3F, "bpb_nochangeline", SN_LOCAL);
	set_name(0X3C5B, "is_floppy", SN_LOCAL);
	set_name(0X3C63, "chk_160K", SN_LOCAL);
	set_name(0X3C78, "has8", SN_LOCAL);
	set_name(0X3CDE, "getret", SN_LOCAL);
	set_name(0X3CE2, "getbp_err_ret", SN_LOCAL);
	set_name(0X3CEC, "got_unknown_medium", SN_LOCAL);
	add_func    (0X3CF6,0X3D44);
	set_func_flags(0X3CF6,0x4400);
	set_frame_size(0X3CF6, 0, 0, 0);
	set_name(0X3D18, "check_bpb_mediabyte", SN_LOCAL);
	set_name(0X3D41, "invalidbootsec", SN_LOCAL);
	set_name(0X3D43, "err_ret", SN_LOCAL);
	add_func    (0X3D44,0X3D95);
	set_func_flags(0X3D44,0x4400);
	set_frame_size(0X3D44, 0X2, 0, 0);
	set_name(0X3D61, "movbpb_bigdisk", SN_LOCAL);
	set_name(0X3D77, "movbpb_fat32", SN_LOCAL);
	set_name(0X3D89, "movbpb_conv", SN_LOCAL);
	set_name(0X3D93, "movbpb_ret", SN_LOCAL);
	add_func    (0X3D95,0X3DF0);
	set_func_flags(0X3D95,0x4400);
	set_frame_size(0X3D95, 0, 0, 0);
	set_name(0X3DA3, "mmi_chk_fat", SN_LOCAL);
	set_name(0X3DA8, "mmi_chk_fat32", SN_LOCAL);
	set_name(0X3DC2, "mmi_fat", SN_LOCAL);
	set_name(0X3DCC, "mmi_do", SN_LOCAL);
	set_name(0X3DEE, "mmi_not_ext", SN_LOCAL);
	add_func    (0X3DF0,0X3DFD);
	set_func_flags(0X3DF0,0x4400);
	set_frame_size(0X3DF0, 0, 0, 0);
	set_name(0X3DFC, "bad_fat_ret", SN_LOCAL);
	add_func    (0X3DFD,0X3E72);
	set_func_flags(0X3DFD,0x4400);
	set_frame_size(0X3DFD, 0X2, 0, 0);
	set_name(0X3E08, "rd_ret", SN_LOCAL);
	set_name(0X3E13, "rd_rty", SN_LOCAL);
	set_name(0X3E38, "rd_skip1_dpt", SN_LOCAL);
	set_name(0X3E57, "rd_skip2_dpt", SN_LOCAL);
	set_name(0X3E5C, "err_rd_ret", SN_LOCAL);
	set_name(0X3E5F, "okret2", SN_LOCAL);
	add_func    (0X3E72,0X3E82);
	set_func_flags(0X3E72,0x4400);
	set_frame_size(0X3E72, 0, 0, 0);
	add_func    (0X3E82,0X3E99);
	set_func_flags(0X3E82,0x4400);
	set_frame_size(0X3E82, 0, 0, 0);
	add_func    (0X3E99,0X3EA7);
	set_func_flags(0X3E99,0x4400);
	set_frame_size(0X3E99, 0, 0, 0);
	add_func    (0X3EC2,0X3F43);
	set_func_flags(0X3EC2,0x4400);
	set_frame_size(0X3EC2, 0X4, 0, 0);
	set_name(0X3EDC, "scan_list", SN_LOCAL);
	set_name(0X3F12, "not_fsetowner", SN_LOCAL);
	set_name(0X3F30, "ignore_sdsb", SN_LOCAL);
	set_name(0X3F35, "scan_skip", SN_LOCAL);
	set_name(0X3F40, "singleret", SN_LOCAL);
	add_func    (0X3F5B,0X3F60);
	set_func_flags(0X3F5B,0x4400);
	set_frame_size(0X3F5B, 0, 0, 0);
	add_func    (0X3F60,0X40E7);
	set_func_flags(0X3F60,0x4400);
	set_frame_size(0X3F60, 0, 0, 0);
	set_name(0X3F43, "baddrive", SN_LOCAL);
	set_name(0X3F47, "unformatteddrive", SN_LOCAL);
	set_name(0X3F49, "baddrive_ret", SN_LOCAL);
	set_name(0X3F9C, "sanity32", SN_LOCAL);
	set_name(0X3FAE, "sanityok", SN_LOCAL);
	set_name(0X3FE4, "diskio_nochangeline", SN_LOCAL);
	set_name(0X3FE7, "chk_13h_ext_flag", SN_LOCAL);
	set_name(0X3FF1, "set_lbarw_1", SN_LOCAL);
	set_name(0X400A, "set_lbarw_2", SN_LOCAL);
	set_name(0X4031, "set_lbarw_3", SN_LOCAL);
	set_name(0X4051, "set_lbarw_4", SN_LOCAL);
	set_name(0X405B, "set_lbarw_5", SN_LOCAL);
	set_name(0X4061, "set_lbarw_6", SN_LOCAL);
	set_name(0X4063, "set_lbarw_7", SN_LOCAL);
	set_name(0X407E, "set_lbarw_8", SN_LOCAL);
	set_name(0X4091, "set_lbarw_9", SN_LOCAL);
	set_name(0X409B, "set_lbarw_10", SN_LOCAL);
	set_name(0X40A1, "set_lbarw_11", SN_LOCAL);
	set_name(0X40A3, "set_lbarw_12", SN_LOCAL);
	set_name(0X40A6, "skip_setup", SN_LOCAL);
	set_name(0X40E4, "baddrive_brdg", SN_LOCAL);
	add_func    (0X40E7,0X4130);
	set_func_flags(0X40E7,0x4400);
	set_frame_size(0X40E7, 0, 0, 0);
	set_name(0X411F, "motor_start_ok", SN_LOCAL);
	set_name(0X412F, "skip_dpt_setting", SN_LOCAL);
	add_func    (0X4130,0X4167);
	set_func_flags(0X4130,0x4400);
	set_frame_size(0X4130, 0, 0, 0);
	set_name(0X4165, "nodiddleback", SN_LOCAL);
	add_func    (0X4167,0X41A1);
	set_func_flags(0X4167,0x4400);
	set_frame_size(0X4167, 0, 0, 0);
	set_name(0X417F, "block_floppy", SN_LOCAL);
	set_name(0X4190, "gotmin", SN_LOCAL);
	add_func    (0X41A4,0X42E9);
	set_func_flags(0X41A4,0x4400);
	set_frame_size(0X41A4, 0, 0, 0);
	set_name(0X41A1, "dskerr_brdg", SN_LOCAL);
	set_name(0X41B6, "GetRdWrInd", SN_LOCAL);
	set_name(0X41C2, "_retry", SN_LOCAL);
	set_name(0X41D9, "disk_not_mini", SN_LOCAL);
	set_name(0X4205, "do_fast", SN_LOCAL);
	set_name(0X4208, "testerr", SN_LOCAL);
	set_name(0X4214, "testerror", SN_LOCAL);
	set_name(0X4224, "noverify", SN_LOCAL);
	set_name(0X4233, "its_removable", SN_LOCAL);
	set_name(0X425F, "noxor", SN_LOCAL);
	set_name(0X4263, "disk_ret", SN_LOCAL);
	set_name(0X4265, "do_write", SN_LOCAL);
	set_name(0X4271, "do_norm", SN_LOCAL);
	set_name(0X4276, "doverify", SN_LOCAL);
	set_name(0X428F, "not_softecc_err", SN_LOCAL);
	set_name(0X4298, "dskerr", SN_LOCAL);
	set_name(0X42A2, "dskerr_nochangeline", SN_LOCAL);
	set_name(0X42B1, "dochkagain", SN_LOCAL);
	set_name(0X42B4, "dskerr0", SN_LOCAL);
	set_name(0X42C2, "skip_timeout_chk", SN_LOCAL);
	set_name(0X42CD, "diskerr1", SN_LOCAL);
	set_name(0X42D1, "write_fault_err", SN_LOCAL);
	add_func    (0X42E9,0X430D);
	set_func_flags(0X42E9,0x4400);
	set_frame_size(0X42E9, 0, 0, 0);
	add_func    (0X430D,0X431A);
	set_func_flags(0X430D,0x4400);
	set_frame_size(0X430D, 0, 0, 0);
	add_func    (0X431A,0X4333);
	set_func_flags(0X431A,0x4400);
	set_frame_size(0X431A, 0, 0, 0);
	add_func    (0X4333,0X4353);
	set_func_flags(0X4333,0x4400);
	set_frame_size(0X4333, 0, 0, 0);
	set_name(0X4343, "setaccess", SN_LOCAL);
	set_name(0X4350, "done_set", SN_LOCAL);
	add_func    (0X4353,0X4360);
	set_func_flags(0X4353,0x4400);
	set_frame_size(0X4353, 0, 0, 0);
	set_name(0X435D, "dont_dec_retry_count", SN_LOCAL);
	add_func    (0X4361,0X4369);
	set_func_flags(0X4361,0x4400);
	set_frame_size(0X4361, 0, 0, 0);
	add_func    (0X4743,0X47CB);
	set_func_flags(0X4743,0x4400);
	set_frame_size(0X4743, 0, 0, 0);
	set_name(0X4758, "Dptalreadyset", SN_LOCAL);
	set_name(0X476E, "ionextsector", SN_LOCAL);
	set_name(0X4793, "IoRemovable", SN_LOCAL);
	set_name(0X47C9, "NoNeedDone", SN_LOCAL);
	add_func    (0X47CB,0X482B);
	set_func_flags(0X47CB,0x4400);
	set_frame_size(0X47CB, 0, 0, 0);
	set_name(0X47E0, "DoSetDasd", SN_LOCAL);
	set_name(0X480A, "DoSet", SN_LOCAL);
	set_name(0X4822, "DasdHasBeenSet", SN_LOCAL);
	add_func    (0X482B,0X48C8);
	set_func_flags(0X482B,0x4400);
	set_frame_size(0X482B, 0, 0, 0);
	set_name(0X4840, "DoSetMediaForFormat", SN_LOCAL);
	set_name(0X485A, "SkipSaveDskAdr", SN_LOCAL);
	set_name(0X48A6, "skip_disk_base_setting", SN_LOCAL);
	set_name(0X48AD, "FormaStatErr", SN_LOCAL);
	set_name(0X48BB, "FormatStatIllegalComb", SN_LOCAL);
	set_name(0X48BF, "FormatStatTimeOut", SN_LOCAL);
	set_name(0X48C1, "PopStatRet", SN_LOCAL);
	set_name(0X48C5, "SetMediaRet", SN_LOCAL);
	add_func    (0X48C8,0X48DE);
	set_func_flags(0X48C8,0x4400);
	set_frame_size(0X48C8, 0, 0, 0);
	set_name(0X48D5, "ResetDisk_cont", SN_LOCAL);
	add_func    (0X48DE,0X4934);
	set_func_flags(0X48DE,0x4400);
	set_frame_size(0X48DE, 0X4, 0, 0);
	set_name(0X4919, "MotorStrtOK", SN_LOCAL);
	set_name(0X491B, "GotValidDpt", SN_LOCAL);
	add_func    (0X4934,0X4979);
	set_func_flags(0X4934,0x4400);
	set_frame_size(0X4934, 0, 0, 0);
	set_name(0X4970, "ExitNoMult", SN_LOCAL);
	add_func    (0X4979,0X49A8);
	set_func_flags(0X4979,0x4400);
	set_frame_size(0X4979, 0, 0, 0);
	set_name(0X49A5, "DontRestore", SN_LOCAL);
	add_func    (0X49A8,0X49E9);
	set_func_flags(0X49A8,0x4400);
	set_frame_size(0X49A8, 0, 0, 0);
	add_func    (0X4A48,0X4A60);
	set_func_flags(0X4A48,0x4400);
	set_frame_size(0X4A48, 0, 0, 0);
	add_func    (0X4A60,0X4A8B);
	set_func_flags(0X4A60,0x4400);
	set_frame_size(0X4A60, 0, 0, 0);
	set_name(0X4A8A, "ChangeLnChkRet", SN_LOCAL);
	add_func    (0X4A8B,0X4AA1);
	set_func_flags(0X4A8B,0x4400);
	set_frame_size(0X4A8B, 0, 0, 0);
	add_func    (0X4AA1,0X4ABB);
	set_func_flags(0X4AA1,0x4400);
	set_frame_size(0X4AA1, 0, 0, 0);
	add_func    (0X4ABB,0X4AE4);
	set_func_flags(0X4ABB,0x4400);
	set_frame_size(0X4ABB, 0, 0, 0);
	add_func    (0X4B22,0X4B47);
	set_func_flags(0X4B22,0x4400);
	set_frame_size(0X4B22, 0, 0, 0);
	set_name(0X4B44, "setlockst_ret", SN_LOCAL);
	add_func    (0X4B47,0X4B61);
	set_func_flags(0X4B47,0x4400);
	set_frame_size(0X4B47, 0, 0, 0);
	add_func    (0X4B61,0X4B77);
	set_func_flags(0X4B61,0x4400);
	set_frame_size(0X4B61, 0X2, 0, 0);
	set_name(0X4B75, "exts_notsupported", SN_LOCAL);
	set_name(0X4B76, "exts_supported", SN_LOCAL);
	add_func    (0X4CD7,0X4CF0);
	set_func_flags(0X4CD7,0x400);
	add_func    (0X4CF0,0X4CF5);
	set_func_flags(0X4CF0,0x4400);
	set_frame_size(0X4CF0, 0, 0, 0);
	add_func    (0X4CF5,0X4D10);
	set_func_flags(0X4CF5,0x4400);
	set_frame_size(0X4CF5, 0, 0, 0);
	set_name(0X4D0A, "movsec_bytes", SN_LOCAL);
	add_func    (0X4D10,0X4D87);
	set_func_flags(0X4D10,0x4400);
	set_frame_size(0X4D10, 0X4, 0, 0);
	set_name(0X4D38, "not_on_bound", SN_LOCAL);
	set_name(0X4D5F, "no_head_bound", SN_LOCAL);
	set_name(0X4D7B, "no_wrap", SN_LOCAL);
	set_name(0X4D81, "no_wrap_head", SN_LOCAL);
	add_func    (0X4D87,0X4D9B);
	set_func_flags(0X4D87,0x4400);
	set_frame_size(0X4D87, 0, 0, 0);
	set_name(0X4D8B, "fbds_1", SN_LOCAL);
	set_name(0X4D9A, "fdbs_2", SN_LOCAL);
	add_func    (0X4D9B,0X4DB9);
	set_func_flags(0X4D9B,0x4400);
	set_frame_size(0X4D9B, 0, 0, 0);
	set_name(0X4DB8, "dointdone", SN_LOCAL);
	add_func    (0X5004,0X5010);
	set_func_flags(0X5004,0x4400);
	set_frame_size(0X5004, 0, 0, 0);
	add_func    (0X5010,0X5055);
	set_func_flags(0X5010,0x4400);
	set_frame_size(0X5010, 0, 0, 0);
	set_name(0X5014, "loop_next_bds", SN_LOCAL);
	set_name(0X5037, "next_bds", SN_LOCAL);
	set_name(0X5054, "_eot_ok", SN_LOCAL);
	add_func    (0X5055,0X5097);
	set_func_flags(0X5055,0x4400);
	set_frame_size(0X5055, 0, 0, 0);
	set_name(0X5061, "no_win386", SN_LOCAL);
	set_name(0X5084, "wrmsg_loop", SN_LOCAL);
	set_name(0X5094, "swpdsk9", SN_LOCAL);
	add_func    (0X50D6,0X5120);
	set_func_flags(0X50D6,0x4400);
	set_frame_size(0X50D6, 0, 0, 0);
	set_name(0X5112, "mediaret", SN_LOCAL);
	set_name(0X5113, "mediadovolid", SN_LOCAL);
	add_func    (0X5120,0X5146);
	set_func_flags(0X5120,0x4400);
	set_frame_size(0X5120, 0, 0, 0);
	set_name(0X5140, "checklatchret", SN_LOCAL);
	set_name(0X5143, "ret_no_error_map", SN_LOCAL);
	add_func    (0X5146,0X514D);
	set_func_flags(0X5146,0x400);
	add_func    (0X514D,0X51AF);
	set_func_flags(0X514D,0x400);
	set_frame_size(0X514D, 0, 0, 0);
	set_name(0X515B, "chk_vid_1", SN_LOCAL);
	set_name(0X5160, "chk_vid_2", SN_LOCAL);
	set_name(0X517E, "vid_no_changed", SN_LOCAL);
	set_name(0X518A, "do_ext_check_id", SN_LOCAL);
	set_name(0X5199, "chk_vid_3", SN_LOCAL);
	set_name(0X51A1, "chk_vid_4", SN_LOCAL);
	add_func    (0X51AF,0X51D5);
	set_func_flags(0X51AF,0x4400);
	set_frame_size(0X51AF, 0, 0, 0);
	set_name(0X51CB, "checkioerr", SN_LOCAL);
	set_name(0X51CE, "checkioret", SN_LOCAL);
	set_name(0X51D2, "no_error_map", SN_LOCAL);
	add_func    (0X51D5,0X51DF);
	set_func_flags(0X51D5,0x4400);
	set_frame_size(0X51D5, 0, 0, 0);
	add_func    (0X51DF,0X51F4);
	set_func_flags(0X51DF,0x400);
	set_frame_size(0X51DF, 0, 0, 0);
	add_func    (0X51F4,0X5227);
	set_func_flags(0X51F4,0x4400);
	set_frame_size(0X51F4, 0, 0, 0);
	set_name(0X5223, "Is720K", SN_LOCAL);
	add_func    (0X5227,0X5242);
	set_func_flags(0X5227,0x4400);
	set_frame_size(0X5227, 0, 0, 0);
	set_name(0X5237, "get_next_bds", SN_LOCAL);
	add_func    (0X5242,0X5248);
	set_func_flags(0X5242,0x4400);
	set_frame_size(0X5242, 0, 0, 0);
	add_func    (0X5248,0X524F);
	set_func_flags(0X5248,0x4400);
	set_frame_size(0X5248, 0, 0, 0);
	add_func    (0X524F,0X5268);
	set_func_flags(0X524F,0x4400);
	set_frame_size(0X524F, 0, 0, 0);
	set_name(0X5261, "setvret", SN_LOCAL);
	set_name(0X5265, "seterr", SN_LOCAL);
	add_func    (0X526A,0X52FF);
	set_func_flags(0X526A,0x4400);
	set_frame_size(0X526A, 0, 0, 0);
	set_name(0X529B, "next_sec", SN_LOCAL);
	set_name(0X52BF, "fvid_loop", SN_LOCAL);
	set_name(0X52CD, "ent_loop", SN_LOCAL);
	set_name(0X52DA, "notfound", SN_LOCAL);
	set_name(0X52DE, "found_vid", SN_LOCAL);
	set_name(0X52F2, "fvid_ret", SN_LOCAL);
	set_name(0X52F4, "rvidret", SN_LOCAL);
	set_name(0X52F8, "no_vid", SN_LOCAL);
	set_name(0X52FB, "readviderr", SN_LOCAL);
	add_func    (0X52FF,0X530A);
	set_func_flags(0X52FF,0x4400);
	set_frame_size(0X52FF, 0, 0, 0);
	add_func    (0X5316,0X531F);
	set_func_flags(0X5316,0x400);
	set_frame_size(0X5316, 0X2, 0, 0);
	set_name(0X5313, "chk_volid_ok", SN_LOCAL);
	add_func    (0X531F,0X532E);
	set_func_flags(0X531F,0x4400);
	set_frame_size(0X531F, 0, 0, 0);
	set_name(0X532C, "okret1", SN_LOCAL);
	add_func    (0X5477,0X54FC);
	set_func_flags(0X5477,0x402);
	set_frame_size(0X5477, 0X4, 0, 0);
	set_name(0X5494, "found02", SN_LOCAL);
	set_name(0X54DF, "notfree02", SN_LOCAL);
	set_name(0X54E7, "findnext02", SN_LOCAL);
	set_name(0X54EC, "foundbad02", SN_LOCAL);
	add_func    (0X54FC,0X556B);
	set_func_flags(0X54FC,0x4400);
	set_frame_size(0X54FC, 0, 0, 0);
	set_name(0X5501, "lploopp", SN_LOCAL);
	set_name(0X551A, "inuse", SN_LOCAL);
	set_name(0X5526, "found", SN_LOCAL);
	set_name(0X5527, "fatal", SN_LOCAL);
	set_name(0X555C, "fatal_loop", SN_LOCAL);
	add_func    (0X57FE,0X5823);
	set_func_flags(0X57FE,0x4400);
	set_frame_size(0X57FE, 0, 0, 0);
	set_name(0X581D, "cpu_286", SN_LOCAL);
	set_name(0X581E, "cpu_8086", SN_LOCAL);
	add_func    (0X5DE5,0X5DF9);
	set_func_flags(0X5DE5,0x4400);
	set_frame_size(0X5DE5, 0, 0, 0);
	add_func    (0X5E74,0X5E8D);
	set_func_flags(0X5E74,0x4400);
	set_frame_size(0X5E74, 0, 0, 0);
	set_name(0X5E8C, "ttldhx", SN_LOCAL);
	add_func    (0X5E8D,0X5EA7);
	set_func_flags(0X5E8D,0x4400);
	set_frame_size(0X5E8D, 0, 0, 0);
	set_name(0X5EA6, "mdhx", SN_LOCAL);
	add_func    (0X5EA7,0X5EB8);
	set_func_flags(0X5EA7,0x4400);
	set_frame_size(0X5EA7, 0, 0, 0);
	add_func    (0X5EB8,0X5EDB);
	set_func_flags(0X5EB8,0x4400);
	set_frame_size(0X5EB8, 0, 0, 0);
	add_func    (0X5EDB,0X5EF7);
	set_func_flags(0X5EDB,0x4400);
	set_frame_size(0X5EDB, 0, 0, 0);
	add_func    (0X5EF7,0X5F71);
	set_func_flags(0X5EF7,0x4400);
	set_frame_size(0X5EF7, 0, 0, 0);
	set_name(0X5F28, "update_arena", SN_LOCAL);
	set_name(0X5F65, "FatalErr", SN_LOCAL);
	add_func    (0X5F71,0X5FC7);
	set_func_flags(0X5F71,0x4400);
	set_frame_size(0X5F71, 0, 0, 0);
	set_name(0X5F9E, "allocHMA_1", SN_LOCAL);
	set_name(0X5FC4, "grabhma_error", SN_LOCAL);
	add_func    (0X5FC7,0X5FCF);
	set_func_flags(0X5FC7,0x4400);
	set_frame_size(0X5FC7, 0, 0, 0);
	add_func    (0X6040,0X609A);
	set_func_flags(0X6040,0x4400);
	set_frame_size(0X6040, 0, 0, 0);
	add_func    (0X60EA,0X612D);
	set_func_flags(0X60EA,0x4400);
	set_frame_size(0X60EA, 0, 0, 0);
	set_name(0X6102, "ClrVDISKno", SN_LOCAL);
	set_name(0X6103, "ClrVDISKok", SN_LOCAL);
	add_func    (0X612D,0X6151);
	set_func_flags(0X612D,0x4400);
	set_frame_size(0X612D, 0, 0, 0);
	add_func    (0X6151,0X6179);
	set_func_flags(0X6151,0x4400);
	set_frame_size(0X6151, 0, 0, 0);
	set_name(0X6178, "ivdins_retn", SN_LOCAL);
	add_func    (0X6179,0X6191);
	set_func_flags(0X6179,0x4400);
	set_frame_size(0X6179, 0, 0, 0);
	add_func    (0X6191,0X619A);
	set_func_flags(0X6191,0x4400);
	set_frame_size(0X6191, 0, 0, 0);
	add_func    (0X619A,0X61CA);
	set_func_flags(0X619A,0x400);
	add_func    (0X61CA,0X622E);
	set_func_flags(0X61CA,0x4400);
	set_frame_size(0X61CA, 0, 0, 0);
	set_name(0X61FD, "fooset_zero", SN_LOCAL);
	set_name(0X6204, "normcds", SN_LOCAL);
	set_name(0X620E, "setnormcds", SN_LOCAL);
	set_name(0X6215, "get_next_dpb", SN_LOCAL);
	add_func    (0X622E,0X6244);
	set_func_flags(0X622E,0x4400);
	set_frame_size(0X622E, 0, 0, 0);
	set_name(0X6237, "get_dpb_for_drive_1", SN_LOCAL);
	set_name(0X6243, "got_dpb_for_drive", SN_LOCAL);
	add_func    (0X6244,0X66DD);
	set_func_flags(0X6244,0x4000);
	set_frame_size(0X6244, 0, 0, 0);
	set_name(0X6257, "multrk_flag_done", SN_LOCAL);
	set_name(0X6272, "dosfts", SN_LOCAL);
	set_name(0X62CF, "dofcbs", SN_LOCAL);
	set_name(0X632A, "fillloop", SN_LOCAL);
	set_name(0X6350, "dodefaultbuff", SN_LOCAL);
	set_name(0X6369, "nextdpb", SN_LOCAL);
	set_name(0X63A6, "setbuf", SN_LOCAL);
	set_name(0X63AE, "nosetbuf", SN_LOCAL);
	set_name(0X63BB, "chk_memsize_for_buffers", SN_LOCAL);
	set_name(0X63E5, "bufset", SN_LOCAL);
	set_name(0X63E7, "dobuff", SN_LOCAL);
	set_name(0X6441, "xif16", SN_LOCAL);
	set_name(0X6461, "gotncds", SN_LOCAL);
	set_name(0X64AF, "doinstallstack", SN_LOCAL);
	set_name(0X6520, "skipstack", SN_LOCAL);
	set_name(0X659D, "dosdata_umb_done", SN_LOCAL);
	set_name(0X65A9, "dosdata_noumb", SN_LOCAL);
	set_name(0X65B9, "rcclloop", SN_LOCAL);
	set_name(0X65D1, "goaux", SN_LOCAL);
	set_name(0X65E4, "goaux2", SN_LOCAL);
	set_name(0X6622, "startrearm", SN_LOCAL);
	set_name(0X6631, "finishrearm", SN_LOCAL);
	add_func    (0X66DD,0X6752);
	set_func_flags(0X66DD,0x400);
	set_frame_size(0X66DD, 0X2, 0, 0);
	set_name(0X66F0, "installfilename", SN_LOCAL);
	set_name(0X66F7, "got_installparm", SN_LOCAL);
	set_name(0X6704, "done_installparm", SN_LOCAL);
	set_name(0X6714, "install_seg_set", SN_LOCAL);
	set_name(0X672C, "no_envdata2", SN_LOCAL);
	add_func    (0X675F,0X676B);
	set_func_flags(0X675F,0x4400);
	set_frame_size(0X675F, 0, 0, 0);
	add_func    (0X67A0,0X67CD);
	set_func_flags(0X67A0,0x4400);
	set_frame_size(0X67A0, 0, 0, 0);
	set_name(0X67B4, "sum1", SN_LOCAL);
	set_name(0X67BA, "sum_sys_code", SN_LOCAL);
	set_name(0X67C4, "sum2", SN_LOCAL);
	add_func    (0X67EC,0X6847);
	set_func_flags(0X67EC,0x4400);
	set_frame_size(0X67EC, 0, 0, 0);
	set_name(0X67F5, "set_buff_1", SN_LOCAL);
	set_name(0X6807, "nxt_buff", SN_LOCAL);
	set_name(0X6838, "set_buff_2", SN_LOCAL);
	add_func    (0X6847,0X6884);
	set_func_flags(0X6847,0x4400);
	set_frame_size(0X6847, 0X2, 0, 0);
	set_name(0X6857, "gba_1", SN_LOCAL);
	set_name(0X687A, "got_hma", SN_LOCAL);
	set_name(0X687D, "gba_2", SN_LOCAL);
	add_func    (0X6884,0X68AC);
	set_func_flags(0X6884,0x4400);
	set_frame_size(0X6884, 0, 0, 0);
	add_func    (0X68AC,0X6C35);
	set_func_flags(0X68AC,0x4400);
	set_frame_size(0X68AC, 0X12, 0, 0);
	set_name(0X690F, "buildloop", SN_LOCAL);
	set_name(0X694D, "skip_disablenmis", SN_LOCAL);
	set_name(0X69BE, "int_0A_not_first", SN_LOCAL);
	set_name(0X69CD, "int_0A_first", SN_LOCAL);
	set_name(0X69CE, "stkinit_0B", SN_LOCAL);
	set_name(0X69FE, "int_0B_not_first", SN_LOCAL);
	set_name(0X6A0D, "int_0B_first", SN_LOCAL);
	set_name(0X6A0E, "stkinit_0C", SN_LOCAL);
	set_name(0X6A3E, "int_0C_not_first", SN_LOCAL);
	set_name(0X6A4D, "int_0C_first", SN_LOCAL);
	set_name(0X6A4E, "stkinit_0D", SN_LOCAL);
	set_name(0X6A7E, "int_0D_not_first", SN_LOCAL);
	set_name(0X6A8D, "int_0D_first", SN_LOCAL);
	set_name(0X6A8E, "stkinit_0E", SN_LOCAL);
	set_name(0X6ABE, "int_0E_not_first", SN_LOCAL);
	set_name(0X6ACD, "int_0E_first", SN_LOCAL);
	set_name(0X6ACE, "stkinit_72", SN_LOCAL);
	set_name(0X6AFE, "int_72_not_first", SN_LOCAL);
	set_name(0X6B0D, "int_72_first", SN_LOCAL);
	set_name(0X6B0E, "stkinit_73", SN_LOCAL);
	set_name(0X6B3E, "int_73_not_first", SN_LOCAL);
	set_name(0X6B4D, "int_73_first", SN_LOCAL);
	set_name(0X6B4E, "stkinit_74", SN_LOCAL);
	set_name(0X6B7E, "int_74_not_first", SN_LOCAL);
	set_name(0X6B8D, "int_74_first", SN_LOCAL);
	set_name(0X6B8E, "stkinit_76", SN_LOCAL);
	set_name(0X6BBE, "int_76_not_first", SN_LOCAL);
	set_name(0X6BCD, "int_76_first", SN_LOCAL);
	set_name(0X6BCE, "stkinit_77", SN_LOCAL);
	set_name(0X6BFE, "int_77_not_first", SN_LOCAL);
	set_name(0X6C0D, "int_77_first", SN_LOCAL);
	set_name(0X6C0E, "int_77_end", SN_LOCAL);
	set_name(0X6C20, "skip_enablenmis", SN_LOCAL);
	add_func    (0X6C35,0X6C74);
	set_func_flags(0X6C35,0x4400);
	set_frame_size(0X6C35, 0, 0, 0);
	set_name(0X6C4D, "new_init_loop_1st", SN_LOCAL);
	add_func    (0X6C74,0X6C94);
	set_func_flags(0X6C74,0x4400);
	set_frame_size(0X6C74, 0, 0, 0);
	add_func    (0X6CC7,0X6ECF);
	set_func_flags(0X6CC7,0x4400);
	set_frame_size(0X6CC7, 0, 0, 0);
	set_name(0X6D4A, "fail_driver_load", SN_LOCAL);
	set_name(0X6D56, "pre_exit_err", SN_LOCAL);
	set_name(0X6D5A, "no_driver_version_fail", SN_LOCAL);
	set_name(0X6DE0, "_ok_block", SN_LOCAL);
	set_name(0X6DF4, "_scandpb", SN_LOCAL);
	set_name(0X6E01, "_foundpb", SN_LOCAL);
	set_name(0X6E58, "_setdpb", SN_LOCAL);
	set_name(0X6E73, "_iblk_1", SN_LOCAL);
	set_name(0X6E8E, "_linkit", SN_LOCAL);
	add_func    (0X6ECF,0X6F38);
	set_func_flags(0X6ECF,0x4400);
	set_frame_size(0X6ECF, 0, 0, 0);
	set_name(0X6F37, "no_magic", SN_LOCAL);
	add_func    (0X6F38,0X6F77);
	set_func_flags(0X6F38,0x4000);
	set_frame_size(0X6F38, 0, 0, 0);
	set_name(0X6F56, "magic_set_cdss_1", SN_LOCAL);
	set_name(0X6F6F, "magic_set_cdss_2", SN_LOCAL);
	set_name(0X6F76, "magic_set_exit", SN_LOCAL);
	add_func    (0X6F77,0X6F81);
	set_func_flags(0X6F77,0x4400);
	set_frame_size(0X6F77, 0, 0, 0);
	add_func    (0X7038,0X7136);
	set_func_flags(0X7038,0x400);
	set_name(0X708A, "_$P_Fin", SN_LOCAL);
	set_name(0X708E, "_$P_Start", SN_LOCAL);
	set_name(0X70A2, "_$P_Pack_Loop", SN_LOCAL);
	set_name(0X70BF, "_$P_Pack_End_backup_si", SN_LOCAL);
	set_name(0X70CA, "_$P_PL01", SN_LOCAL);
	set_name(0X70D7, "_$P_PL00", SN_LOCAL);
	set_name(0X70E4, "_$P_Pack_End_BY_EOL", SN_LOCAL);
	set_name(0X70E5, "_$P_Pack_End", SN_LOCAL);
	set_name(0X710E, "_$P_Positional_Manager", SN_LOCAL);
	set_name(0X712D, "_$P_Too_Many_Error", SN_LOCAL);
	set_name(0X7142, "_$P_SW_Manager", SN_LOCAL);
	set_name(0X714D, "_$P_SW_Mgr_Loop", SN_LOCAL);
	set_name(0X715B, "_$P_SW_Not_Found", SN_LOCAL);
	set_name(0X7164, "_$P_Key_Manager", SN_LOCAL);
	set_name(0X7179, "_$P_Key_Mgr_Loop", SN_LOCAL);
	set_name(0X7187, "_$P_Key_Not_Found", SN_LOCAL);
	set_name(0X718E, "_$P_Return_to_Caller", SN_LOCAL);
	set_name(0X71A9, "_$P_Single_Exit", SN_LOCAL);
	add_func    (0X7136,0X7142);
	set_func_flags(0X7136,0x4400);
	set_frame_size(0X7136, 0, 0, 0);
	add_func    (0X71AB,0X71DC);
	set_func_flags(0X71AB,0x4400);
	set_frame_size(0X71AB, 0, 0, 0);
	set_name(0X71B9, "_$P_CPC00", SN_LOCAL);
	set_name(0X71CD, "_$P_CPC02", SN_LOCAL);
	set_name(0X71D7, "_$P_CPC01", SN_LOCAL);
	set_name(0X71DA, "_$P_CPC_Exit", SN_LOCAL);
	add_func    (0X71DC,0X71DE);
	set_func_flags(0X71DC,0x4400);
	set_frame_size(0X71DC, 0, 0, 0);
	add_func    (0X71DE,0X7201);
	set_func_flags(0X71DE,0x4400);
	set_frame_size(0X71DE, 0X2, 0, 0);
	set_name(0X71EB, "_$P_KEYorSW_Loop", SN_LOCAL);
	set_name(0X71F5, "_$P_KEYorSW_Not_Found", SN_LOCAL);
	set_name(0X71F8, "_$P_KEYorSW_Found", SN_LOCAL);
	set_name(0X71FE, "_$P_KEYorSW_Exit", SN_LOCAL);
	add_func    (0X7201,0X720D);
	set_func_flags(0X7201,0x4400);
	set_frame_size(0X7201, 0, 0, 0);
	set_name(0X720B, "_$P_MBP_Exit", SN_LOCAL);
	add_func    (0X720D,0X726E);
	set_func_flags(0X720D,0x4400);
	set_frame_size(0X720D, 0, 0, 0);
	set_name(0X7246, "_$P_Chk_if_data_required", SN_LOCAL);
	set_name(0X725C, "_$P_CSW00", SN_LOCAL);
	set_name(0X7262, "_$P_Chk_SW_Err0", SN_LOCAL);
	set_name(0X7264, "_$P_Chk_SW_Exit", SN_LOCAL);
	set_name(0X726D, "_$P_Chk_SW_Single_Exit", SN_LOCAL);
	add_func    (0X726E,0X72F3);
	set_func_flags(0X726E,0x4400);
	set_frame_size(0X726E, 0X2, 0, 0);
	set_name(0X728D, "_$P_RLT02", SN_LOCAL);
	set_name(0X7297, "_$P_RLT00", SN_LOCAL);
	set_name(0X72A1, "_$P_RLT01", SN_LOCAL);
	set_name(0X72B3, "_$P_RLT03", SN_LOCAL);
	set_name(0X72C6, "_$P_RLT05", SN_LOCAL);
	set_name(0X72DA, "_$P_RLT_CAP00", SN_LOCAL);
	set_name(0X72E3, "_$P_RLT_CAP02", SN_LOCAL);
	set_name(0X72E6, "_$P_RLT_CAP01", SN_LOCAL);
	set_name(0X72F1, "_$P_RLT_Exit", SN_LOCAL);
	add_func    (0X72F3,0X73A4);
	set_func_flags(0X72F3,0x4000);
	set_frame_size(0X72F3, 0, 0, 0);
	set_name(0X7318, "_$P_Mat", SN_LOCAL);
	set_name(0X731A, "_$P_Bridge", SN_LOCAL);
	set_name(0X731D, "_$P_Match03", SN_LOCAL);
	set_name(0X734B, "_$P_Match05", SN_LOCAL);
	set_name(0X7365, "_$P_Match06", SN_LOCAL);
	set_name(0X737C, "_$P_Match07", SN_LOCAL);
	set_name(0X738B, "_$P_Match_Exit", SN_LOCAL);
	set_name(0X73A2, "_$P_Match2_Exit", SN_LOCAL);
	add_func    (0X73A4,0X73CA);
	set_func_flags(0X73A4,0x4400);
	set_frame_size(0X73A4, 0X4, 0, 0);
	set_name(0X73A6, "_$P_RCOL_Loop", SN_LOCAL);
	set_name(0X73BE, "_$P_RCOL00", SN_LOCAL);
	set_name(0X73C4, "_$P_RCOL01", SN_LOCAL);
	set_name(0X73C7, "_$P_RCOL_Exit", SN_LOCAL);
	add_func    (0X73CA,0X73E9);
	set_func_flags(0X73CA,0x4400);
	set_frame_size(0X73CA, 0X2, 0, 0);
	set_name(0X73CE, "_$P_DCS_Loop", SN_LOCAL);
	set_name(0X73E2, "_$P_DCS00", SN_LOCAL);
	set_name(0X73E3, "_$P_DCS01", SN_LOCAL);
	set_name(0X73E6, "_$P_DCS_Exit", SN_LOCAL);
	add_func    (0X73E9,0X7427);
	set_func_flags(0X73E9,0x4400);
	set_frame_size(0X73E9, 0, 0, 0);
	set_name(0X73F8, "_$P_DCC_Go", SN_LOCAL);
	set_name(0X7419, "_$P_DCC01", SN_LOCAL);
	set_name(0X7426, "_$P_CAPS_Ret", SN_LOCAL);
	add_func    (0X7427,0X744B);
	set_func_flags(0X7427,0x4400);
	set_frame_size(0X7427, 0, 0, 0);
	set_name(0X7445, "_$P_SVal00", SN_LOCAL);
	set_name(0X7446, "_$P_Sval01", SN_LOCAL);
	add_func    (0X744B,0X7530);
	set_func_flags(0X744B,0x400);
	set_frame_size(0X744B, 0, 0, 0);
	set_name(0X7454, "_$P_Value_Loop", SN_LOCAL);
	set_name(0X7483, "_$P_Value_2x_OVF", SN_LOCAL);
	set_name(0X7487, "_$P_Value_Chk_Add_OVF", SN_LOCAL);
	set_name(0X748D, "_$P_Value_OVF", SN_LOCAL);
	set_name(0X748F, "_$P_Value_Err0", SN_LOCAL);
	set_name(0X74A6, "_$P_Value01", SN_LOCAL);
	set_name(0X74B7, "_$P_Value02", SN_LOCAL);
	set_name(0X74C0, "_$P_Val02_Loop", SN_LOCAL);
	set_name(0X74D6, "_$P_Val_In", SN_LOCAL);
	set_name(0X74E6, "_$P_Val02_Sign", SN_LOCAL);
	set_name(0X74F4, "_$P_SVal_In", SN_LOCAL);
	set_name(0X7504, "_$P_Val02_Next", SN_LOCAL);
	set_name(0X7517, "_$P_Val_Found", SN_LOCAL);
	set_name(0X751E, "_$P_Value_Err", SN_LOCAL);
	set_name(0X7528, "_$P_Value_Exit", SN_LOCAL);
	add_func    (0X7530,0X7542);
	set_func_flags(0X7530,0x4400);
	set_frame_size(0X7530, 0, 0, 0);
	set_name(0X753B, "_$P_COVF", SN_LOCAL);
	set_name(0X7540, "_$P_COVF00", SN_LOCAL);
	add_func    (0X7542,0X7550);
	set_func_flags(0X7542,0x4400);
	set_frame_size(0X7542, 0, 0, 0);
	set_name(0X754E, "_$P_0099Err", SN_LOCAL);
	add_func    (0X7550,0X75B9);
	set_func_flags(0X7550,0x4400);
	set_frame_size(0X7550, 0X4, 0, 0);
	set_name(0X7563, "_$P_Sim00", SN_LOCAL);
	set_name(0X7581, "_$P_Sim_Loop", SN_LOCAL);
	set_name(0X759B, "_$P_Sim_Found", SN_LOCAL);
	set_name(0X75A6, "_$P_Sim01", SN_LOCAL);
	set_name(0X75AF, "_$P_Sim_Exit", SN_LOCAL);
	set_name(0X75B1, "_$P_Sim_Exit0", SN_LOCAL);
	add_func    (0X75B9,0X765C);
	set_func_flags(0X75B9,0x4400);
	set_frame_size(0X75B9, 0X4, 0, 0);
	set_name(0X75BF, "_$P_SCOM_Loop", SN_LOCAL);
	set_name(0X75DF, "_$P_SCOM04", SN_LOCAL);
	set_name(0X75F2, "_$P_SCOM05", SN_LOCAL);
	set_name(0X75F5, "_$P_SCOM03", SN_LOCAL);
	set_name(0X7603, "_$P_SCOM00", SN_LOCAL);
	set_name(0X7616, "_$P_SCOM01", SN_LOCAL);
	set_name(0X7618, "_$P_SCOM_Differ0", SN_LOCAL);
	set_name(0X762F, "_$P_not_applicable", SN_LOCAL);
	set_name(0X7643, "_$P_SCOM02", SN_LOCAL);
	set_name(0X764E, "_$P_SCOM_Differ", SN_LOCAL);
	set_name(0X7651, "_$P_SCOM_Same", SN_LOCAL);
	set_name(0X7657, "_$P_SCOM_Exit", SN_LOCAL);
	add_func    (0X765C,0X76CC);
	set_func_flags(0X765C,0x4400);
	set_frame_size(0X765C, 0X6, 0, 0);
	set_name(0X767E, "_$P_FileF_Err", SN_LOCAL);
	set_name(0X7694, "_$P_FileF03", SN_LOCAL);
	set_name(0X7696, "_$P_FileF_Loop1", SN_LOCAL);
	set_name(0X76A9, "_$P_FileF01", SN_LOCAL);
	set_name(0X76AD, "_$P_FileF00", SN_LOCAL);
	set_name(0X76BB, "_$P_FileF_RLT", SN_LOCAL);
	set_name(0X76BD, "_$P_FileF02", SN_LOCAL);
	set_name(0X76CB, "_$P_Drv_Only_Exit", SN_LOCAL);
	add_func    (0X76CC,0X76E1);
	set_func_flags(0X76CC,0x4400);
	set_frame_size(0X76CC, 0X2, 0, 0);
	set_name(0X76D5, "_$P_FileSp_Loop", SN_LOCAL);
	set_name(0X76DE, "_$P_FileSp_Exit", SN_LOCAL);
	add_func    (0X76E1,0X7725);
	set_func_flags(0X76E1,0x4400);
	set_frame_size(0X76E1, 0, 0, 0);
	set_name(0X7704, "_$P_DrvF00", SN_LOCAL);
	set_name(0X771B, "_$P_Drv_Err", SN_LOCAL);
	set_name(0X7722, "_$P_Drv_Exit", SN_LOCAL);
	add_func    (0X7725,0X774B);
	set_func_flags(0X7725,0x4400);
	set_frame_size(0X7725, 0, 0, 0);
	set_name(0X7743, "_$P_Skip_Delim_CY", SN_LOCAL);
	set_name(0X7746, "_$P_Skip_Delim_NCY", SN_LOCAL);
	set_name(0X7747, "_$P_Skip_Delim_Exit", SN_LOCAL);
	set_name(0X7749, "_$P_Exit_At_Extra", SN_LOCAL);
	add_func    (0X774B,0X7781);
	set_func_flags(0X774B,0x4400);
	set_frame_size(0X774B, 0X2, 0, 0);
	set_name(0X7774, "_$P_Chk_EOL_Loop", SN_LOCAL);
	set_name(0X777C, "_$P_Chk_EOL_NZ", SN_LOCAL);
	set_name(0X777E, "_$P_Chk_EOL_Exit", SN_LOCAL);
	add_func    (0X7781,0X77E0);
	set_func_flags(0X7781,0x4400);
	set_frame_size(0X7781, 0X2, 0, 0);
	set_name(0X77AB, "_$P_Chk_Delim01", SN_LOCAL);
	set_name(0X77BD, "_$P_Chk_Delim_Loop", SN_LOCAL);
	set_name(0X77C5, "_$P_Chk_Delim_NZ", SN_LOCAL);
	set_name(0X77C7, "_$P_Chk_Delim_Exit", SN_LOCAL);
	set_name(0X77CA, "_$P_Chk_Delim_Exit0", SN_LOCAL);
	set_name(0X77DC, "_$P_No_Set_Extra", SN_LOCAL);
	add_func    (0X77E0,0X77FC);
	set_func_flags(0X77E0,0x4400);
	set_frame_size(0X77E0, 0, 0, 0);
	set_name(0X77EE, "_$P_STRUC_L5", SN_LOCAL);
	set_name(0X77F0, "_$P_STRUC_L2", SN_LOCAL);
	set_name(0X77FA, "_$P_STRUC_L12", SN_LOCAL);
	add_func    (0X77FC,0X784D);
	set_func_flags(0X77FC,0x4400);
	set_frame_size(0X77FC, 0, 0, 0);
	set_name(0X782E, "_$P_DBCS00", SN_LOCAL);
	set_name(0X7833, "_$P_DBCS_LOOP", SN_LOCAL);
	set_name(0X7844, "_$P_DBCS01", SN_LOCAL);
	set_name(0X7848, "_$P_NON_DBCS", SN_LOCAL);
	set_name(0X7849, "_$P_DBCS_EXIT", SN_LOCAL);
	add_func    (0X7B0E,0X7BAC);
	set_func_flags(0X7B0E,0x4000);
	set_frame_size(0X7B0E, 0, 0, 0);
	set_name(0X7B31, "noprob", SN_LOCAL);
	set_name(0X7B86, "puteol", SN_LOCAL);
	set_name(0X7BA5, "conferr", SN_LOCAL);
	set_name(0X7BD1, "getcom", SN_LOCAL);
	set_name(0X7C30, "coff", SN_LOCAL);
	set_name(0X7C37, "blank_line", SN_LOCAL);
	set_name(0X7C3E, "tryi", SN_LOCAL);
	set_name(0X7C48, "not_init_pass", SN_LOCAL);
	set_name(0X7C65, "multi_pass_coff2", SN_LOCAL);
	set_name(0X7C67, "precheck_installhigh", SN_LOCAL);
	set_name(0X7C73, "multi_try_i", SN_LOCAL);
	set_name(0X7C82, "multi_try_n", SN_LOCAL);
	set_name(0X7CBF, "multi_pass_filter", SN_LOCAL);
	set_name(0X7CCE, "multi_pass_adjust", SN_LOCAL);
	set_name(0X7CD6, "multi_pass_coff", SN_LOCAL);
	set_name(0X7CD9, "tryb", SN_LOCAL);
	set_name(0X7CEF, "do7", SN_LOCAL);
	set_name(0X7CF9, "if7", SN_LOCAL);
	set_name(0X7D08, "if11", SN_LOCAL);
	set_name(0X7D15, "if13", SN_LOCAL);
	set_name(0X7D18, "en11", SN_LOCAL);
	set_name(0X7D1A, "en7", SN_LOCAL);
	set_name(0X7D2C, "if18", SN_LOCAL);
	set_name(0X7D3E, "sr7", SN_LOCAL);
	set_name(0X7D41, "tryc", SN_LOCAL);
	set_name(0X7D52, "do22", SN_LOCAL);
	set_name(0X7D5C, "if22", SN_LOCAL);
	set_name(0X7D6F, "if26", SN_LOCAL);
	set_name(0X7D74, "en26", SN_LOCAL);
	set_name(0X7D76, "en22", SN_LOCAL);
	set_name(0X7D80, "sr22", SN_LOCAL);
	set_name(0X7D83, "trym", SN_LOCAL);
	set_name(0X7D94, "do31", SN_LOCAL);
	set_name(0X7D9E, "if31", SN_LOCAL);
	set_name(0X7DB1, "if35", SN_LOCAL);
	set_name(0X7DB6, "en35", SN_LOCAL);
	set_name(0X7DB8, "en31", SN_LOCAL);
	set_name(0X7DCE, "if39", SN_LOCAL);
	set_name(0X7DD4, "en39", SN_LOCAL);
	set_name(0X7DD5, "sr31", SN_LOCAL);
	set_name(0X7DD8, "multi_try_doshi", SN_LOCAL);
	set_name(0X7DDD, "skip_it", SN_LOCAL);
	set_name(0X7DE0, "it_is_h", SN_LOCAL);
	set_name(0X7DEC, "h_do_parse", SN_LOCAL);
	set_name(0X7DF6, "h_parse_ok", SN_LOCAL);
	set_name(0X7E00, "h_end", SN_LOCAL);
	set_name(0X7E03, "tryu", SN_LOCAL);
	set_name(0X7E0B, "tryu_0", SN_LOCAL);
	set_name(0X7E28, "tryu_1", SN_LOCAL);
	set_name(0X7E45, "tryu_2", SN_LOCAL);
	set_name(0X7E47, "tryu_3", SN_LOCAL);
	set_name(0X7E5A, "tryu_4", SN_LOCAL);
	set_name(0X7E60, "tryu_5", SN_LOCAL);
	set_name(0X7E77, "NrmTst", SN_LOCAL);
	set_name(0X7E8D, "tryd", SN_LOCAL);
	set_name(0X7E92, "skip_it2", SN_LOCAL);
	set_name(0X7E95, "gotd", SN_LOCAL);
	set_name(0X7EAD, "LoadDevice", SN_LOCAL);
	set_name(0X7EF3, "tryd_1", SN_LOCAL);
	set_name(0X7EF9, "DevConvLoad", SN_LOCAL);
	set_name(0X7F0B, "NoMem", SN_LOCAL);
	set_name(0X7F0E, "BadFile", SN_LOCAL);
	set_name(0X7F1A, "tryd_2", SN_LOCAL);
	set_name(0X7F20, "LoadDev", SN_LOCAL);
	set_name(0X7F2D, "goodld", SN_LOCAL);
	set_name(0X7F59, "got_device_com_cont", SN_LOCAL);
	set_name(0X7F7A, "skip_pass_limit", SN_LOCAL);
	set_name(0X7FCE, "tryd_3", SN_LOCAL);
	set_name(0X7FD9, "tryd_4", SN_LOCAL);
	set_name(0X7FE2, "badnumblock", SN_LOCAL);
	set_name(0X7FEA, "erase_dev_do", SN_LOCAL);
	set_name(0X8000, "no_error_line_msg", SN_LOCAL);
	set_name(0X8003, "was_device_com", SN_LOCAL);
	set_name(0X8013, "breakok", SN_LOCAL);
	set_name(0X8030, "jc_edd", SN_LOCAL);
	set_name(0X803F, "tryclk", SN_LOCAL);
	set_name(0X804C, "golink", SN_LOCAL);
	set_name(0X804F, "isblock", SN_LOCAL);
	set_name(0X8074, "ok_block", SN_LOCAL);
	set_name(0X808D, "perunit", SN_LOCAL);
	set_name(0X8096, "scandpb", SN_LOCAL);
	set_name(0X80A3, "foundpb", SN_LOCAL);
	set_name(0X80F8, "setdpb", SN_LOCAL);
	set_name(0X8112, "iblk_1", SN_LOCAL);
	set_name(0X812C, "iblk_2", SN_LOCAL);
	set_name(0X8131, "linkit", SN_LOCAL);
	set_name(0X8166, "coffj3", SN_LOCAL);
	set_name(0X818A, "set_magichomeflag", SN_LOCAL);
	set_name(0X8193, "magic_not_yet_home", SN_LOCAL);
	set_name(0X81B0, "no_more_magic_calls", SN_LOCAL);
	set_name(0X81B3, "bad_bpb_size_sector", SN_LOCAL);
	set_name(0X81C1, "tryq", SN_LOCAL);
	set_name(0X81C6, "skip_it3", SN_LOCAL);
	set_name(0X81C9, "tryq_cont", SN_LOCAL);
	set_name(0X81E2, "do52", SN_LOCAL);
	set_name(0X81F3, "if52", SN_LOCAL);
	set_name(0X820F, "if57", SN_LOCAL);
	set_name(0X8213, "en57", SN_LOCAL);
	set_name(0X8215, "if56", SN_LOCAL);
	set_name(0X822A, "en56", SN_LOCAL);
	set_name(0X822C, "sr52", SN_LOCAL);
	set_name(0X8237, "tryqbad", SN_LOCAL);
	set_name(0X823E, "tryq_open", SN_LOCAL);
	set_name(0X824B, "tryq_def", SN_LOCAL);
	set_name(0X824E, "tryq_openit", SN_LOCAL);
	set_name(0X827F, "tryq_set_for_dos", SN_LOCAL);
	set_name(0X829F, "tryqfilebad", SN_LOCAL);
	set_name(0X82AE, "tryqdefbad", SN_LOCAL);
	set_name(0X82B1, "tryqbadload", SN_LOCAL);
	set_name(0X82BD, "tryqmemory", SN_LOCAL);
	set_name(0X82C0, "tryqchkerr", SN_LOCAL);
	set_name(0X82D1, "coffj4", SN_LOCAL);
	set_name(0X82F1, "tryf", SN_LOCAL);
	set_name(0X8302, "do67", SN_LOCAL);
	set_name(0X830C, "if67", SN_LOCAL);
	set_name(0X831B, "en67", SN_LOCAL);
	set_name(0X8323, "sr67", SN_LOCAL);
	set_name(0X8326, "tryl", SN_LOCAL);
	set_name(0X8337, "do73", SN_LOCAL);
	set_name(0X8341, "if73", SN_LOCAL);
	set_name(0X8350, "en73", SN_LOCAL);
	set_name(0X8358, "badparm_p_coff", SN_LOCAL);
	set_name(0X835B, "tryp", SN_LOCAL);
	set_name(0X8373, "trypbad", SN_LOCAL);
	set_name(0X8376, "tryk", SN_LOCAL);
	set_name(0X837B, "skip_it4", SN_LOCAL);
	set_name(0X837E, "do_tryk", SN_LOCAL);
	set_name(0X838A, "do79", SN_LOCAL);
	set_name(0X839B, "if79", SN_LOCAL);
	set_name(0X83AF, "if83", SN_LOCAL);
	set_name(0X83B3, "en83", SN_LOCAL);
	set_name(0X83B5, "en79", SN_LOCAL);
	set_name(0X83CD, "ll88", SN_LOCAL);
	set_name(0X83D4, "if88", SN_LOCAL);
	set_name(0X83D6, "if87", SN_LOCAL);
	set_name(0X83E5, "en87", SN_LOCAL);
	set_name(0X840D, "if94", SN_LOCAL);
	set_name(0X8424, "sr79", SN_LOCAL);
	set_name(0X8427, "trys", SN_LOCAL);
	set_name(0X8444, "storeshell", SN_LOCAL);
	set_name(0X845A, "getshparms", SN_LOCAL);
	set_name(0X8460, "parmloop", SN_LOCAL);
	set_name(0X8470, "endofparms", SN_LOCAL);
	set_name(0X847B, "endofshell", SN_LOCAL);
	set_name(0X847E, "skipline", SN_LOCAL);
	set_name(0X8487, "endofline", SN_LOCAL);
	set_name(0X848A, "tryx", SN_LOCAL);
	set_name(0X849B, "do98", SN_LOCAL);
	set_name(0X84A5, "if98", SN_LOCAL);
	set_name(0X84B9, "if102", SN_LOCAL);
	set_name(0X84BD, "en102", SN_LOCAL);
	set_name(0X84BF, "en98", SN_LOCAL);
	set_name(0X84CD, "sr98", SN_LOCAL);
	set_name(0X84D0, "try1", SN_LOCAL);
	set_name(0X84D5, "skip_it5", SN_LOCAL);
	set_name(0X84D8, "do_try1", SN_LOCAL);
	set_name(0X84E4, "do110", SN_LOCAL);
	set_name(0X84EF, "if110", SN_LOCAL);
	set_name(0X8505, "if115", SN_LOCAL);
	set_name(0X8516, "if118", SN_LOCAL);
	set_name(0X8527, "if116", SN_LOCAL);
	set_name(0X8538, "en110", SN_LOCAL);
	set_name(0X8550, "if117", SN_LOCAL);
	set_name(0X856D, "if119", SN_LOCAL);
	set_name(0X8583, "skip_dos_flag", SN_LOCAL);
	set_name(0X8584, "sr110", SN_LOCAL);
	set_name(0X8587, "tryv", SN_LOCAL);
	set_name(0X8596, "err", SN_LOCAL);
	set_name(0X859B, "tryn", SN_LOCAL);
	set_name(0X85AC, "tryt", SN_LOCAL);
	set_name(0X85BD, "do120", SN_LOCAL);
	set_name(0X85C7, "if120", SN_LOCAL);
	set_name(0X85DA, "if121", SN_LOCAL);
	set_name(0X85DF, "sr120", SN_LOCAL);
	set_name(0X85E1, "en120", SN_LOCAL);
	set_name(0X85E4, "tryy", SN_LOCAL);
	set_name(0X85E9, "donothing", SN_LOCAL);
	set_name(0X85F4, "try0", SN_LOCAL);
	set_name(0X8656, "badop", SN_LOCAL);
	add_func    (0X7BAC,0X7BD1);
	set_func_flags(0X7BAC,0x4400);
	set_frame_size(0X7BAC, 0, 0, 0);
	add_func    (0X82DD,0X82F1);
	set_func_flags(0X82DD,0x4400);
	set_frame_size(0X82DD, 0, 0, 0);
	set_name(0X82E7, "if64", SN_LOCAL);
	set_name(0X82EA, "en64", SN_LOCAL);
	add_func    (0X8608,0X8623);
	set_func_flags(0X8608,0x4400);
	set_frame_size(0X8608, 0, 0, 0);
	set_name(0X8621, "CheckProtmanDone", SN_LOCAL);
	add_func    (0X8623,0X864A);
	set_func_flags(0X8623,0x4400);
	set_frame_size(0X8623, 0, 0, 0);
	set_name(0X8643, "ll4", SN_LOCAL);
	set_name(0X8646, "if4", SN_LOCAL);
	set_name(0X8647, "en4", SN_LOCAL);
	add_func    (0X8662,0X868E);
	set_func_flags(0X8662,0x4400);
	set_frame_size(0X8662, 0, 0, 0);
	set_name(0X8671, "do1", SN_LOCAL);
	set_name(0X867F, "en1", SN_LOCAL);
	add_func    (0X868E,0X86AA);
	set_func_flags(0X868E,0x4400);
	set_frame_size(0X868E, 0, 0, 0);
	set_name(0X86A5, "get_ret", SN_LOCAL);
	set_name(0X86A7, "nochar", SN_LOCAL);
	add_func    (0X86B4,0X86C0);
	set_func_flags(0X86B4,0x4400);
	set_frame_size(0X86B4, 0, 0, 0);
	add_func    (0X86C0,0X86EF);
	set_func_flags(0X86C0,0x4400);
	set_frame_size(0X86C0, 0, 0, 0);
	set_name(0X86D1, "sln_loop", SN_LOCAL);
	set_name(0X86E2, "sln_last", SN_LOCAL);
	add_func    (0X86EF,0X871A);
	set_func_flags(0X86EF,0x4400);
	set_frame_size(0X86EF, 0, 0, 0);
	set_name(0X8705, "pd_umb", SN_LOCAL);
	set_name(0X870C, "pd_lo", SN_LOCAL);
	set_name(0X8713, "pd_hi", SN_LOCAL);
	add_func    (0X871A,0X8733);
	set_func_flags(0X871A,0x4400);
	set_frame_size(0X871A, 0, 0, 0);
	set_name(0X872F, "lim_set", SN_LOCAL);
	set_name(0X8732, "limx", SN_LOCAL);
	add_func    (0X8733,0X8751);
	set_func_flags(0X8733,0x4400);
	set_frame_size(0X8733, 0, 0, 0);
	add_func    (0X8751,0X876E);
	set_func_flags(0X8751,0x4400);
	set_frame_size(0X8751, 0, 0, 0);
	set_name(0X876D, "timx", SN_LOCAL);
	add_func    (0X876E,0X8787);
	set_func_flags(0X876E,0x4400);
	set_frame_size(0X876E, 0, 0, 0);
	add_func    (0X8787,0X8799);
	set_func_flags(0X8787,0x4400);
	set_frame_size(0X8787, 0, 0, 0);
	add_func    (0X8799,0X87CD);
	set_func_flags(0X8799,0x4400);
	set_frame_size(0X8799, 0, 0, 0);
	add_func    (0X87CD,0X8824);
	set_func_flags(0X87CD,0x4400);
	set_frame_size(0X87CD, 0X4, 0, 0);
	set_name(0X87E1, "fm10", SN_LOCAL);
	set_name(0X8806, "fm30", SN_LOCAL);
	set_name(0X881B, "fmX", SN_LOCAL);
	add_func    (0X8824,0X883A);
	set_func_flags(0X8824,0x4400);
	set_frame_size(0X8824, 0, 0, 0);
	add_func    (0X883A,0X884A);
	set_func_flags(0X883A,0x4400);
	set_frame_size(0X883A, 0, 0, 0);
	add_func    (0X884A,0X888D);
	set_func_flags(0X884A,0x4400);
	set_frame_size(0X884A, 0X2, 0, 0);
	set_name(0X8850, "pv10", SN_LOCAL);
	set_name(0X885E, "pv20", SN_LOCAL);
	set_name(0X8874, "pv30", SN_LOCAL);
	set_name(0X8883, "pvE1", SN_LOCAL);
	set_name(0X8886, "pvErr", SN_LOCAL);
	set_name(0X8889, "pvX", SN_LOCAL);
	add_func    (0X888D,0X88EA);
	set_func_flags(0X888D,0x4400);
	set_frame_size(0X888D, 0, 0, 0);
	set_name(0X8892, "pl10", SN_LOCAL);
	set_name(0X88DC, "plE1", SN_LOCAL);
	set_name(0X88E2, "plE2", SN_LOCAL);
	set_name(0X88E7, "plSwX", SN_LOCAL);
	set_name(0X88E8, "plX", SN_LOCAL);
	add_func    (0X88EA,0X88FE);
	set_func_flags(0X88EA,0x4400);
	set_frame_size(0X88EA, 0, 0, 0);
	add_func    (0X88FE,0X8909);
	set_func_flags(0X88FE,0x4400);
	set_frame_size(0X88FE, 0, 0, 0);
	set_name(0X8908, "ieX", SN_LOCAL);
	add_func    (0X8909,0X8914);
	set_func_flags(0X8909,0x4400);
	set_frame_size(0X8909, 0, 0, 0);
	set_name(0X8913, "iwX", SN_LOCAL);
	add_func    (0X8914,0X8936);
	set_func_flags(0X8914,0x4400);
	set_frame_size(0X8914, 0X6, 0, 0);
	set_name(0X8931, "umu10", SN_LOCAL);
	add_func    (0X8936,0X896A);
	set_func_flags(0X8936,0x4400);
	set_frame_size(0X8936, 0, 0, 0);
	set_name(0X893C, "su10", SN_LOCAL);
	set_name(0X894F, "su20", SN_LOCAL);
	set_name(0X8964, "su30", SN_LOCAL);
	add_func    (0X896A,0X897E);
	set_func_flags(0X896A,0x4400);
	set_frame_size(0X896A, 0X4, 0, 0);
	add_func    (0X8980,0X89B4);
	set_func_flags(0X8980,0x4400);
	set_frame_size(0X8980, 0, 0, 0);
	set_name(0X8996, "td20", SN_LOCAL);
	set_name(0X89A4, "td10", SN_LOCAL);
	set_name(0X89B2, "tdE", SN_LOCAL);
	add_func    (0X89B4,0X8A09);
	set_func_flags(0X89B4,0x4400);
	set_frame_size(0X89B4, 0X2, 0, 0);
	set_name(0X89E1, "gxn10", SN_LOCAL);
	set_name(0X89EA, "gxn20", SN_LOCAL);
	set_name(0X8A00, "gxnE", SN_LOCAL);
	set_name(0X8A03, "gxnQ", SN_LOCAL);
	set_name(0X8A05, "gxnX", SN_LOCAL);
	add_func    (0X8A09,0X8A26);
	set_func_flags(0X8A09,0x4400);
	set_frame_size(0X8A09, 0, 0, 0);
	set_name(0X8A24, "m32E", SN_LOCAL);
	add_func    (0X8A26,0X8A34);
	set_func_flags(0X8A26,0x4400);
	set_frame_size(0X8A26, 0, 0, 0);
	add_func    (0X8A34,0X8A4C);
	set_func_flags(0X8A34,0x4400);
	set_frame_size(0X8A34, 0X2, 0, 0);
	set_name(0X8A47, "uhE", SN_LOCAL);
	set_name(0X8A48, "uhX", SN_LOCAL);
	add_func    (0X8A4C,0X8A66);
	set_func_flags(0X8A4C,0x4400);
	set_frame_size(0X8A4C, 0, 0, 0);
	set_name(0X8A5D, "ism10", SN_LOCAL);
	set_name(0X8A64, "ismX", SN_LOCAL);
	add_func    (0X8A66,0X8AA8);
	set_func_flags(0X8A66,0x4400);
	set_frame_size(0X8A66, 0, 0, 0);
	set_name(0X8A74, "atu10", SN_LOCAL);
	set_name(0X8A80, "atu20", SN_LOCAL);
	set_name(0X8A94, "atu30", SN_LOCAL);
	set_name(0X8A9F, "atuE", SN_LOCAL);
	set_name(0X8AA2, "atuX", SN_LOCAL);
	add_func    (0X8AA8,0X8ABA);
	set_func_flags(0X8AA8,0x4400);
	set_frame_size(0X8AA8, 0, 0, 0);
	set_name(0X8AB9, "cu10", SN_LOCAL);
	add_func    (0X8ADA,0X8B1F);
	set_func_flags(0X8ADA,0x4400);
	set_frame_size(0X8ADA, 0, 0, 0);
	set_name(0X8AFC, "hus10", SN_LOCAL);
	set_name(0X8B10, "hus20", SN_LOCAL);
	set_name(0X8B1A, "husX", SN_LOCAL);
	add_func    (0X8B1F,0X8B27);
	set_func_flags(0X8B1F,0x4400);
	set_frame_size(0X8B1F, 0, 0, 0);
	add_func    (0X8B27,0X8B3F);
	set_func_flags(0X8B27,0x4400);
	set_frame_size(0X8B27, 0X4, 0, 0);
	add_func    (0X8B3F,0X8B54);
	set_func_flags(0X8B3F,0x4400);
	set_frame_size(0X8B3F, 0X4, 0, 0);
	add_func    (0X8B5D,0X8B70);
	set_func_flags(0X8B5D,0x4400);
	set_frame_size(0X8B5D, 0, 0, 0);
	set_name(0X8B6E, "sls10", SN_LOCAL);
	add_func    (0X8B70,0X8B9B);
	set_func_flags(0X8B70,0x4400);
	set_frame_size(0X8B70, 0, 0, 0);
	set_name(0X8B77, "hu10", SN_LOCAL);
	set_name(0X8B84, "hu20", SN_LOCAL);
	set_name(0X8B98, "huX", SN_LOCAL);
	add_func    (0X8B9B,0X8BA7);
	set_func_flags(0X8B9B,0x4400);
	set_frame_size(0X8B9B, 0, 0, 0);
	add_func    (0X8BA7,0X8BAE);
	set_func_flags(0X8BA7,0x4400);
	set_frame_size(0X8BA7, 0, 0, 0);
	add_func    (0X8BAE,0X8BD2);
	set_func_flags(0X8BAE,0x4400);
	set_frame_size(0X8BAE, 0, 0, 0);
	add_func    (0X8BD2,0X8BEF);
	set_func_flags(0X8BD2,0x4400);
	set_frame_size(0X8BD2, 0, 0, 0);
	add_func    (0X8BEF,0X8C20);
	set_func_flags(0X8BEF,0x4400);
	set_frame_size(0X8BEF, 0, 0, 0);
	set_name(0X8BFD, "fu10", SN_LOCAL);
	set_name(0X8C07, "fu20", SN_LOCAL);
	set_name(0X8C1B, "fuE", SN_LOCAL);
	set_name(0X8C1C, "fuX", SN_LOCAL);
	add_func    (0X8C20,0X8C63);
	set_func_flags(0X8C20,0x4400);
	set_frame_size(0X8C20, 0X2, 0, 0);
	set_name(0X8C2B, "bf10", SN_LOCAL);
	set_name(0X8C43, "bf20", SN_LOCAL);
	set_name(0X8C57, "bf30", SN_LOCAL);
	set_name(0X8C60, "bfX", SN_LOCAL);
	add_func    (0X8C63,0X8C74);
	set_func_flags(0X8C63,0x4400);
	set_frame_size(0X8C63, 0, 0, 0);
	add_func    (0X8C74,0X8CD1);
	set_func_flags(0X8C74,0x4400);
	set_frame_size(0X8C74, 0X2, 0, 0);
	set_name(0X8CCC, "smE", SN_LOCAL);
	set_name(0X8CCD, "smX", SN_LOCAL);
	add_func    (0X8CD1,0X8D21);
	set_func_flags(0X8CD1,0x4400);
	set_frame_size(0X8CD1, 0X2, 0, 0);
	set_name(0X8CF8, "hu_10", SN_LOCAL);
	set_name(0X8D06, "hu_20", SN_LOCAL);
	set_name(0X8D0F, "hu_30", SN_LOCAL);
	set_name(0X8D1D, "hu_X", SN_LOCAL);
	add_func    (0X8D21,0X8D49);
	set_func_flags(0X8D21,0x4400);
	set_frame_size(0X8D21, 0, 0, 0);
	set_name(0X8D2A, "uf10", SN_LOCAL);
	set_name(0X8D32, "uf20", SN_LOCAL);
	set_name(0X8D46, "ufX", SN_LOCAL);
	add_func    (0X8D49,0X8D77);
	set_func_flags(0X8D49,0x4400);
	set_frame_size(0X8D49, 0, 0, 0);
	set_name(0X8D75, "ifmX", SN_LOCAL);
	add_func    (0X8D77,0X8D9B);
	set_func_flags(0X8D77,0x4400);
	set_frame_size(0X8D77, 0, 0, 0);
	add_func    (0X8D9B,0X8DD8);
	set_func_flags(0X8D9B,0x4400);
	set_frame_size(0X8D9B, 0, 0, 0);
	set_name(0X8DAD, "fum10", SN_LOCAL);
	set_name(0X8DB3, "fum20", SN_LOCAL);
	set_name(0X8DBF, "fum30", SN_LOCAL);
	set_name(0X8DD3, "fumX", SN_LOCAL);
	add_func    (0X8DD8,0X8DEC);
	set_func_flags(0X8DD8,0x4400);
	set_frame_size(0X8DD8, 0X4, 0, 0);
	add_func    (0X8DEC,0X8E16);
	set_func_flags(0X8DEC,0x4400);
	set_frame_size(0X8DEC, 0X4, 0, 0);
	set_name(0X8DF9, "um10", SN_LOCAL);
	set_name(0X8E0D, "um20", SN_LOCAL);
	add_func    (0X8E16,0X8E26);
	set_func_flags(0X8E16,0x4400);
	set_frame_size(0X8E16, 0, 0, 0);
	add_func    (0X8E26,0X8E4B);
	set_func_flags(0X8E26,0x4400);
	set_frame_size(0X8E26, 0, 0, 0);
	set_name(0X8E35, "uhu10", SN_LOCAL);
	add_func    (0X8E4B,0X8E5B);
	set_func_flags(0X8E4B,0x4400);
	set_frame_size(0X8E4B, 0, 0, 0);
	add_func    (0X8E5B,0X8E81);
	set_func_flags(0X8E5B,0x4400);
	set_frame_size(0X8E5B, 0, 0, 0);
	set_name(0X8E62, "fus10", SN_LOCAL);
	set_name(0X8E6C, "fus20", SN_LOCAL);
	set_name(0X8E7E, "fusX", SN_LOCAL);
	add_func    (0X8E81,0X8EAE);
	set_func_flags(0X8E81,0x4400);
	set_frame_size(0X8E81, 0, 0, 0);
	set_name(0X8EAC, "ihm_x", SN_LOCAL);
	add_func    (0X8EAE,0X8EC9);
	set_func_flags(0X8EAE,0x4400);
	set_frame_size(0X8EAE, 0, 0, 0);
	add_func    (0X8EC9,0X8EDD);
	set_func_flags(0X8EC9,0x4400);
	set_frame_size(0X8EC9, 0, 0, 0);
	set_name(0X8EDA, "xhu_e", SN_LOCAL);
	set_name(0X8EDB, "xhu_x", SN_LOCAL);
	add_func    (0X8EDD,0X8EEF);
	set_func_flags(0X8EDD,0x4400);
	set_frame_size(0X8EDD, 0, 0, 0);
	set_name(0X8EEE, "lumbX", SN_LOCAL);
	add_func    (0X8EEF,0X8F58);
	set_func_flags(0X8EEF,0x4400);
	set_frame_size(0X8EEF, 0, 0, 0);
	set_name(0X8F14, "InitForConv", SN_LOCAL);
	set_name(0X8F21, "InitForHi", SN_LOCAL);
	set_name(0X8F31, "InitForLo", SN_LOCAL);
	set_name(0X8F40, "idl1", SN_LOCAL);
	add_func    (0X8F58,0X8F73);
	set_func_flags(0X8F58,0x4400);
	set_frame_size(0X8F58, 0, 0, 0);
	set_name(0X8F6C, "spcinumb1", SN_LOCAL);
	add_func    (0X8F73,0X8F92);
	set_func_flags(0X8F73,0x4400);
	set_frame_size(0X8F73, 0, 0, 0);
	add_func    (0X8F92,0X8FC4);
	set_func_flags(0X8F92,0x4400);
	set_frame_size(0X8F92, 0, 0, 0);
	set_name(0X8FB4, "gufd_err", SN_LOCAL);
	add_func    (0X8FC4,0X9013);
	set_func_flags(0X8FC4,0x4400);
	set_frame_size(0X8FC4, 0, 0, 0);
	set_name(0X8FDE, "dsm_again", SN_LOCAL);
	set_name(0X8FE7, "isit_slash", SN_LOCAL);
	set_name(0X8FEF, "isit_null", SN_LOCAL);
	set_name(0X8FFB, "dsm_next_char", SN_LOCAL);
	set_name(0X9007, "blankout", SN_LOCAL);
	set_name(0X900D, "dsm_exit", SN_LOCAL);
	add_func    (0X9013,0X9059);
	set_func_flags(0X9013,0x4400);
	set_frame_size(0X9013, 0, 0, 0);
	set_name(0X9041, "sd_ctp", SN_LOCAL);
	set_name(0X9050, "sd_close", SN_LOCAL);
	set_name(0X9057, "sd_err", SN_LOCAL);
	add_func    (0X9059,0X9076);
	set_func_flags(0X9059,0x4400);
	set_frame_size(0X9059, 0, 0, 0);
	add_func    (0X9076,0X908A);
	set_func_flags(0X9076,0x4400);
	set_frame_size(0X9076, 0, 0, 0);
	set_name(0X9088, "rfUM1", SN_LOCAL);
	add_func    (0X908A,0X909D);
	set_func_flags(0X908A,0x4400);
	set_frame_size(0X908A, 0, 0, 0);
	set_name(0X9094, "rn_gotnull", SN_LOCAL);
	add_func    (0X909D,0X90BF);
	set_func_flags(0X909D,0x4400);
	set_frame_size(0X909D, 0, 0, 0);
	set_name(0X90BE, "rba_ok", SN_LOCAL);
	add_func    (0X90BF,0X90E4);
	set_func_flags(0X90BF,0x4400);
	set_frame_size(0X90BF, 0, 0, 0);
	set_name(0X90DB, "set_break_continue", SN_LOCAL);
	set_name(0X90E1, "break_failed", SN_LOCAL);
	add_func    (0X90E4,0X9116);
	set_func_flags(0X90E4,0x4400);
	set_frame_size(0X90E4, 0, 0, 0);
	set_name(0X9108, "db_lo", SN_LOCAL);
	set_name(0X9114, "db_exit", SN_LOCAL);
	add_func    (0X9116,0X915E);
	set_func_flags(0X9116,0x4400);
	set_frame_size(0X9116, 0X2, 0, 0);
	set_name(0X9156, "ps_no_size", SN_LOCAL);
	set_name(0X915B, "ps_err", SN_LOCAL);
	add_func    (0X915E,0X916A);
	set_func_flags(0X915E,0x4400);
	set_frame_size(0X915E, 0, 0, 0);
	set_name(0X9169, "sd_ret", SN_LOCAL);
	add_func    (0X916A,0X91B1);
	set_func_flags(0X916A,0x4400);
	set_frame_size(0X916A, 0, 0, 0);
	set_name(0X916E, "ghn_next", SN_LOCAL);
	set_name(0X918C, "ghn_shift1", SN_LOCAL);
	set_name(0X9197, "ghn_into_paras", SN_LOCAL);
	set_name(0X91A6, "ghn_shift2", SN_LOCAL);
	set_name(0X91AF, "ghn_err", SN_LOCAL);
	add_func    (0X91B1,0X91CF);
	set_func_flags(0X91B1,0x4400);
	set_frame_size(0X91B1, 0, 0, 0);
	set_name(0X91BF, "is_it_hex", SN_LOCAL);
	set_name(0X91CD, "gnib_err", SN_LOCAL);
	add_func    (0X91CF,0X91E2);
	set_func_flags(0X91CF,0x4400);
	set_frame_size(0X91CF, 0, 0, 0);
	set_name(0X91D4, "au_next", SN_LOCAL);
	set_name(0X91DE, "au_coalesce", SN_LOCAL);
	set_name(0X91E1, "au_exit", SN_LOCAL);
	add_func    (0X91E2,0X9216);
	set_func_flags(0X91E2,0x4400);
	set_frame_size(0X91E2, 0, 0, 0);
	set_name(0X9212, "ia_1", SN_LOCAL);
	set_name(0X9214, "iau_err", SN_LOCAL);
	add_func    (0X9216,0X9237);
	set_func_flags(0X9216,0x4400);
	set_frame_size(0X9216, 0, 0, 0);
	set_name(0X9232, "ua_done", SN_LOCAL);
	set_name(0X9234, "ua_err", SN_LOCAL);
	add_func    (0X9237,0X92F6);
	set_func_flags(0X9237,0x4400);
	set_frame_size(0X9237, 0, 0, 0);
	set_name(0X9245, "ui_next", SN_LOCAL);
	set_name(0X9258, "ui_insert", SN_LOCAL);
	set_name(0X92AD, "ui_append", SN_LOCAL);
	set_name(0X92F4, "ui_done", SN_LOCAL);
	add_func    (0X92F6,0X9332);
	set_func_flags(0X92F6,0x4400);
	set_frame_size(0X92F6, 0, 0, 0);
	set_name(0X9302, "uc_nextfree", SN_LOCAL);
	set_name(0X9314, "uc_again", SN_LOCAL);
	set_name(0X9331, "uc_done", SN_LOCAL);
	add_func    (0X9332,0X9346);
	set_func_flags(0X9332,0x4400);
	set_frame_size(0X9332, 0, 0, 0);
	set_name(0X9344, "gn_err", SN_LOCAL);
	add_func    (0X9346,0X93BE);
	set_func_flags(0X9346,0x4400);
	set_frame_size(0X9346, 0, 0, 0);
	set_name(0X939C, "scannext", SN_LOCAL);
	set_name(0X93AE, "got_last", SN_LOCAL);
	set_name(0X93BC, "lfu_er", SN_LOCAL);
	add_func    (0X93BE,0X93EB);
	set_func_flags(0X93BE,0x4400);
	set_frame_size(0X93BE, 0, 0, 0);
	set_name(0X93EA, "su_exit", SN_LOCAL);
	add_func    (0X93EB,0X9419);
	set_func_flags(0X93EB,0x4400);
	set_frame_size(0X93EB, 0, 0, 0);
	set_name(0X9404, "ulu_next", SN_LOCAL);
	set_name(0X9411, "ulu_found", SN_LOCAL);
	set_name(0X9416, "ulu_x", SN_LOCAL);
	add_func    (0X941B,0X9465);
	set_func_flags(0X941B,0x4400);
	set_frame_size(0X941B, 0, 0, 0);
	set_name(0X9452, "not_ec35", SN_LOCAL);
	set_name(0X945F, "eot_ok", SN_LOCAL);
	add_func    (0X9465,0X9481);
	set_func_flags(0X9465,0x4400);
	set_frame_size(0X9465, 0, 0, 0);
	add_func    (0X9481,0X94D3);
	set_func_flags(0X9481,0x4400);
	set_frame_size(0X9481, 0, 0, 0);
	set_name(0X9484, "nextswtch", SN_LOCAL);
	set_name(0X9497, "getparm", SN_LOCAL);
	set_name(0X94A0, "getnext", SN_LOCAL);
	set_name(0X94A7, "swterr", SN_LOCAL);
	set_name(0X94A9, "done_line", SN_LOCAL);
	set_name(0X94B4, "okay", SN_LOCAL);
	set_name(0X94C7, "exitpl", SN_LOCAL);
	set_name(0X94C9, "put_back", SN_LOCAL);
	add_func    (0X94D3,0X952B);
	set_func_flags(0X94D3,0x4400);
	set_frame_size(0X94D3, 0, 0, 0);
	set_name(0X9525, "done_swtch", SN_LOCAL);
	set_name(0X9527, "err_swtch", SN_LOCAL);
	set_name(0X9529, "err_chk", SN_LOCAL);
	add_func    (0X952B,0X9566);
	set_func_flags(0X952B,0x4400);
	set_frame_size(0X952B, 0, 0, 0);
	set_name(0X953C, "try_f", SN_LOCAL);
	set_name(0X9547, "try_t", SN_LOCAL);
	set_name(0X9556, "try_s", SN_LOCAL);
	set_name(0X9561, "try_h", SN_LOCAL);
	set_name(0X9564, "done_ret", SN_LOCAL);
	add_func    (0X9566,0X9609);
	set_func_flags(0X9566,0x4400);
	set_frame_size(0X9566, 0, 0, 0);
	set_name(0X9598, "see_heads", SN_LOCAL);
	set_name(0X95A6, "heads_not_altered", SN_LOCAL);
	set_name(0X95CC, "not_144m", SN_LOCAL);
	set_name(0X95DE, "only_one_head", SN_LOCAL);
	set_name(0X95F0, "got_one_secperclus_drive", SN_LOCAL);
	set_name(0X95F5, "got_correct_mediaid", SN_LOCAL);
	add_func    (0X9609,0X97E1);
	set_func_flags(0X9609,0x4400);
	set_frame_size(0X9609, 0, 0, 0);
	set_name(0X961C, "org1", SN_LOCAL);
	set_name(0X962E, "end_commd_line", SN_LOCAL);
	set_name(0X9637, "nochar1", SN_LOCAL);
	set_name(0X9639, "findit", SN_LOCAL);
	set_name(0X9644, "findcom", SN_LOCAL);
	set_name(0X9651, "loopcom", SN_LOCAL);
	set_name(0X9681, "semicolon", SN_LOCAL);
	set_name(0X9685, "no_query", SN_LOCAL);
	set_name(0X968B, "gotcom0", SN_LOCAL);
	set_name(0X9690, "nocom", SN_LOCAL);
	set_name(0X9696, "_skipline", SN_LOCAL);
	set_name(0X969F, "gotcom", SN_LOCAL);
	set_name(0X96BD, "org2", SN_LOCAL);
	set_name(0X96D3, "org21", SN_LOCAL);
	set_name(0X96D5, "org3", SN_LOCAL);
	set_name(0X9705, "org31", SN_LOCAL);
	set_name(0X9708, "org_switch", SN_LOCAL);
	set_name(0X9719, "org_file", SN_LOCAL);
	set_name(0X9727, "org_copy_file", SN_LOCAL);
	set_name(0X973F, "get_cmt_token", SN_LOCAL);
	set_name(0X977C, "get_cmt_end", SN_LOCAL);
	set_name(0X9783, "end_commd_line_brdg", SN_LOCAL);
	set_name(0X9786, "org_put_zero", SN_LOCAL);
	set_name(0X978E, "end_file_slash", SN_LOCAL);
	set_name(0X9796, "end_copy_file", SN_LOCAL);
	set_name(0X97A1, "org4", SN_LOCAL);
	set_name(0X97B0, "org5", SN_LOCAL);
	set_name(0X97B8, "org51", SN_LOCAL);
	set_name(0X97C7, "org1_brdg", SN_LOCAL);
	set_name(0X97CA, "at_quote", SN_LOCAL);
	set_name(0X97DA, "up_level", SN_LOCAL);
	add_func    (0X97FE,0X9839);
	set_func_flags(0X97FE,0x4400);
	set_frame_size(0X97FE, 0, 0, 0);
	set_name(0X982D, "skip_cmmt", SN_LOCAL);
	set_name(0X9838, "no_commt", SN_LOCAL);
	add_func    (0X9839,0X98C2);
	set_func_flags(0X9839,0x4400);
	set_frame_size(0X9839, 0, 0, 0);
	set_name(0X9845, "kbd_loop", SN_LOCAL);
	set_name(0X9860, "kbd_loopdone", SN_LOCAL);
	set_name(0X9861, "kbd_nodelay", SN_LOCAL);
	set_name(0X9872, "kbd_notshift", SN_LOCAL);
	set_name(0X9886, "kbd_cfg_bypass", SN_LOCAL);
	set_name(0X9893, "kbd_notf5", SN_LOCAL);
	set_name(0X989D, "kbd_cfg_confirm", SN_LOCAL);
	set_name(0X98A9, "kbd_eat", SN_LOCAL);
	set_name(0X98B6, "kbd_test", SN_LOCAL);
	set_name(0X98BB, "kbd_clean", SN_LOCAL);
	set_name(0X98C0, "kbd_exit", SN_LOCAL);
	add_func    (0X98C2,0X98EF);
	set_func_flags(0X98C2,0x4400);
	set_frame_size(0X98C2, 0, 0, 0);
	set_name(0X98DF, "not_off", SN_LOCAL);
	set_name(0X98EC, "set_done", SN_LOCAL);
	add_func    (0X98EF,0X9C4B);
	set_func_flags(0X98EF,0x4400);
	set_frame_size(0X98EF, 0, 0, 0);
	set_name(0X98F3, "swchk_loop", SN_LOCAL);
	set_name(0X98FF, "swchk_next1", SN_LOCAL);
	set_name(0X9911, "swchk_next2", SN_LOCAL);
	set_name(0X9915, "swchk_scan", SN_LOCAL);
	set_name(0X9918, "swchk_scan1", SN_LOCAL);
	set_name(0X9932, "swchk_scan2", SN_LOCAL);
	set_name(0X993F, "swchk_nextline", SN_LOCAL);
	set_name(0X9944, "swchk_end", SN_LOCAL);
	set_name(0X9955, "menu_search", SN_LOCAL);
	set_name(0X9967, "menu_color", SN_LOCAL);
	set_name(0X998F, "check_color", SN_LOCAL);
	set_name(0X9996, "set_color", SN_LOCAL);
	set_name(0X999F, "menu_found", SN_LOCAL);
	set_name(0X99B9, "menu_process", SN_LOCAL);
	set_name(0X99E7, "menu_numlock", SN_LOCAL);
	set_name(0X99EC, "to_menu_getdefault", SN_LOCAL);
	set_name(0X99EE, "menu_default", SN_LOCAL);
	set_name(0X9A0F, "timeout_ok", SN_LOCAL);
	set_name(0X9A13, "timeout_skip", SN_LOCAL);
	set_name(0X9A15, "menu_item", SN_LOCAL);
	set_name(0X9A27, "menu_itemfound", SN_LOCAL);
	set_name(0X9A4A, "menu_nextitem", SN_LOCAL);
	set_name(0X9A50, "menu_getdefault", SN_LOCAL);
	set_name(0X9A59, "menu_valid", SN_LOCAL);
	set_name(0X9A68, "menu_chkdefault", SN_LOCAL);
	set_name(0X9A83, "menu_nodefault", SN_LOCAL);
	set_name(0X9A85, "menu_setdefault", SN_LOCAL);
	set_name(0X9A9A, "menu_display", SN_LOCAL);
	set_name(0X9AD8, "menu_clear", SN_LOCAL);
	set_name(0X9B0B, "menu_nostatus", SN_LOCAL);
	set_name(0X9B0E, "menu_disploop", SN_LOCAL);
	set_name(0X9B46, "menu_autoselect", SN_LOCAL);
	set_name(0X9B4E, "menu_abort", SN_LOCAL);
	set_name(0X9B53, "normal_boot", SN_LOCAL);
	set_name(0X9B61, "not_topmenu", SN_LOCAL);
	set_name(0X9B78, "not_submenu", SN_LOCAL);
	set_name(0X9B7E, "no_selection", SN_LOCAL);
	set_name(0X9B8F, "copyblock_loop", SN_LOCAL);
	set_name(0X9B96, "copyblock_begin", SN_LOCAL);
	set_name(0X9BB9, "copyblock_check", SN_LOCAL);
	set_name(0X9BC2, "copyblock_skip", SN_LOCAL);
	set_name(0X9BD2, "move_config", SN_LOCAL);
	set_name(0X9BDC, "copy_boot", SN_LOCAL);
	set_name(0X9BF5, "l1", SN_LOCAL);
	set_name(0X9C03, "l2", SN_LOCAL);
	set_name(0X9C42, "menu_exit", SN_LOCAL);
	add_func    (0X9C4B,0X9CD0);
	set_func_flags(0X9C4B,0x4400);
	set_frame_size(0X9C4B, 0X4, 0, 0);
	set_name(0X9C57, "copy_varlen", SN_LOCAL);
	set_name(0X9C75, "copy_varsrch", SN_LOCAL);
	set_name(0X9C9F, "copy_envprep", SN_LOCAL);
	set_name(0X9CAB, "copy_varnext", SN_LOCAL);
	set_name(0X9CB4, "copy_envloop", SN_LOCAL);
	set_name(0X9CC0, "copy_envdone", SN_LOCAL);
	set_name(0X9CC3, "copy_envdel", SN_LOCAL);
	set_name(0X9CCB, "copy_envexit", SN_LOCAL);
	add_func    (0X9CD0,0X9D45);
	set_func_flags(0X9CD0,0x4400);
	set_frame_size(0X9CD0, 0, 0, 0);
	set_name(0X9D14, "copy_skip", SN_LOCAL);
	set_name(0X9D15, "copy_error", SN_LOCAL);
	set_name(0X9D1B, "copy_line", SN_LOCAL);
	set_name(0X9D33, "copy_loop", SN_LOCAL);
	set_name(0X9D3B, "copy_next", SN_LOCAL);
	set_name(0X9D3F, "copy_nextline", SN_LOCAL);
	set_name(0X9D44, "copy_done", SN_LOCAL);
	add_func    (0X9D45,0X9D61);
	set_func_flags(0X9D45,0x4400);
	set_frame_size(0X9D45, 0, 0, 0);
	set_name(0X9D53, "get_linenum_loop", SN_LOCAL);
	set_name(0X9D5D, "get_linenum_done", SN_LOCAL);
	add_func    (0X9D61,0X9D7A);
	set_func_flags(0X9D61,0x4400);
	set_frame_size(0X9D61, 0, 0, 0);
	add_func    (0X9D7A,0X9DA2);
	set_func_flags(0X9D7A,0x4400);
	set_frame_size(0X9D7A, 0, 0, 0);
	set_name(0X9D91, "check_line", SN_LOCAL);
	set_name(0X9D9C, "next_line", SN_LOCAL);
	set_name(0X9DA1, "find_exit", SN_LOCAL);
	add_func    (0X9DA2,0X9DC3);
	set_func_flags(0X9DA2,0x4400);
	set_frame_size(0X9DA2, 0X2, 0, 0);
	set_name(0X9DA3, "comp_loop", SN_LOCAL);
	set_name(0X9DB8, "comp_exit", SN_LOCAL);
	set_name(0X9DBA, "comp_almost", SN_LOCAL);
	add_func    (0X9DC3,0X9DD1);
	set_func_flags(0X9DC3,0x4400);
	set_frame_size(0X9DC3, 0, 0, 0);
	add_func    (0X9DD1,0X9E69);
	set_func_flags(0X9DD1,0x4400);
	set_frame_size(0X9DD1, 0X4, 0, 0);
	set_name(0X9E08, "print_other", SN_LOCAL);
	set_name(0X9E3A, "print_loop", SN_LOCAL);
	set_name(0X9E44, "print_nontab", SN_LOCAL);
	set_name(0X9E5D, "print_done", SN_LOCAL);
	add_func    (0X9E69,0X9F94);
	set_func_flags(0X9E69,0x4400);
	set_frame_size(0X9E69, 0, 0, 0);
	set_name(0X9E82, "check_time", SN_LOCAL);
	set_name(0X9E98, "show_time", SN_LOCAL);
	set_name(0X9ECE, "input_key", SN_LOCAL);
	set_name(0X9EEB, "got_time", SN_LOCAL);
	set_name(0X9EF5, "got_key", SN_LOCAL);
	set_name(0X9F0F, "timeout_disabled", SN_LOCAL);
	set_name(0X9F2C, "not_up", SN_LOCAL);
	set_name(0X9F3E, "print1", SN_LOCAL);
	set_name(0X9F40, "print2", SN_LOCAL);
	set_name(0X9F46, "to_input_key", SN_LOCAL);
	set_name(0X9F48, "not_down", SN_LOCAL);
	set_name(0X9F5E, "not_f8", SN_LOCAL);
	set_name(0X9F6E, "normal_key", SN_LOCAL);
	set_name(0X9F7A, "not_backspace", SN_LOCAL);
	set_name(0X9F8E, "select_done", SN_LOCAL);
	add_func    (0X9F94,0X9FA9);
	set_func_flags(0X9F94,0x4400);
	set_frame_size(0X9F94, 0, 0, 0);
	set_name(0X9F9B, "disp_ok", SN_LOCAL);
	add_func    (0X9FA9,0X9FB9);
	set_func_flags(0X9FA9,0x4400);
	set_frame_size(0X9FA9, 0X2, 0, 0);
	add_func    (0X9FB9,0X9FF8);
	set_func_flags(0X9FB9,0x4400);
	set_frame_size(0X9FB9, 0X2, 0, 0);
	set_name(0X9FDE, "show_onoff", SN_LOCAL);
	set_name(0X9FED, "show_noton", SN_LOCAL);
	set_name(0X9FF1, "show_done", SN_LOCAL);
	add_func    (0X9FF8,0XA00F);
	set_func_flags(0X9FF8,0x4400);
	set_frame_size(0X9FF8, 0, 0, 0);
	set_name(0XA00D, "skip_token_eol", SN_LOCAL);
	add_func    (0XA00F,0XA01E);
	set_func_flags(0XA00F,0x4400);
	set_frame_size(0XA00F, 0, 0, 0);
	add_func    (0XA01E,0XA022);
	set_func_flags(0XA01E,0x400);
	add_func    (0XA022,0XA02C);
	set_func_flags(0XA022,0x4400);
	set_frame_size(0XA022, 0, 0, 0);
	add_func    (0XA02C,0XA04E);
	set_func_flags(0XA02C,0x4400);
	set_frame_size(0XA02C, 0, 0, 0);
	set_name(0XA02E, "num_loop", SN_LOCAL);
	set_name(0XA04D, "num_done", SN_LOCAL);
	add_func    (0XA04E,0XA05C);
	set_func_flags(0XA04E,0x4400);
	set_frame_size(0XA04E, 0, 0, 0);
	set_name(0XA058, "get_fail", SN_LOCAL);
	add_func    (0XA05C,0XA125);
	set_func_flags(0XA05C,0x4400);
	set_frame_size(0XA05C, 0, 0, 0);
	set_name(0XA066, "qu_1", SN_LOCAL);
	set_name(0XA07F, "query_all", SN_LOCAL);
	set_name(0XA08E, "find_match", SN_LOCAL);
	set_name(0XA09E, "cmd_match", SN_LOCAL);
	set_name(0XA0A5, "cmd_print", SN_LOCAL);
	set_name(0XA0B7, "cmd_notset", SN_LOCAL);
	set_name(0XA0B9, "line_print", SN_LOCAL);
	set_name(0XA0C1, "non_null", SN_LOCAL);
	set_name(0XA0CD, "non_space", SN_LOCAL);
	set_name(0XA0D5, "prompt_user", SN_LOCAL);
	set_name(0XA0D8, "generic_prompt", SN_LOCAL);
	set_name(0XA0DB, "input_loop", SN_LOCAL);
	set_name(0XA0F2, "not_func", SN_LOCAL);
	set_name(0XA113, "legal_char", SN_LOCAL);
	set_name(0XA11D, "do_cmd", SN_LOCAL);
	set_name(0XA120, "skip_cmd", SN_LOCAL);
	set_name(0XA121, "skip_all", SN_LOCAL);
	add_func    (0XA125,0XA159);
	set_func_flags(0XA125,0x4400);
	set_frame_size(0XA125, 0X4, 0, 0);
	set_name(0XA14D, "pe_1", SN_LOCAL);
	set_name(0XA153, "pe_ret", SN_LOCAL);
	add_func    (0XA159,0XA1A4);
	set_func_flags(0XA159,0x4400);
	set_frame_size(0XA159, 0, 0, 0);
	set_name(0XA195, "disable_loop", SN_LOCAL);
	add_func    (0XA1A4,0XA1BC);
	set_func_flags(0XA1A4,0x4400);
	set_frame_size(0XA1A4, 0, 0, 0);
	add_func    (0XA1BC,0XA1CC);
	set_func_flags(0XA1BC,0x4400);
	set_frame_size(0XA1BC, 0, 0, 0);
	add_func    (0XA1CC,0XA1E8);
	set_func_flags(0XA1CC,0x4400);
	set_frame_size(0XA1CC, 0, 0, 0);
	add_func    (0XA1E8,0XA1F5);
	set_func_flags(0XA1E8,0x4400);
	set_frame_size(0XA1E8, 0, 0, 0);
	set_name(0XA1F4, "nl_ret", SN_LOCAL);
	add_func    (0XA1F5,0XA221);
	set_func_flags(0XA1F5,0x4400);
	set_frame_size(0XA1F5, 0X4, 0, 0);
	set_name(0XA1FC, "convloop", SN_LOCAL);
	set_name(0XA20A, "noconv", SN_LOCAL);
	set_name(0XA213, "check_eol", SN_LOCAL);
	set_name(0XA21D, "convdone", SN_LOCAL);
	add_func    (0XA221,0XA26E);
	set_func_flags(0XA221,0x4400);
	set_frame_size(0XA221, 0, 0, 0);
	set_name(0XA260, "skip_set_devmarksize", SN_LOCAL);
	add_func    (0XA26E,0XA291);
	set_func_flags(0XA26E,0x4400);
	set_frame_size(0XA26E, 0, 0, 0);
	add_func    (0XA291,0XA29D);
	set_func_flags(0XA291,0x4400);
	set_frame_size(0XA291, 0, 0, 0);
	set_name(0XA29B, "notdig", SN_LOCAL);
	add_func    (0XA29D,0XA2FA);
	set_func_flags(0XA29D,0x4400);
	set_frame_size(0XA29D, 0X2, 0, 0);
	set_name(0XA2A0, "b2", SN_LOCAL);
	set_name(0XA2DF, "b15", SN_LOCAL);
	set_name(0XA2E9, "b1", SN_LOCAL);
	set_name(0XA2EF, "badnum", SN_LOCAL);
	add_func    (0XA2FA,0XA40E);
	set_func_flags(0XA2FA,0x4400);
	set_frame_size(0XA2FA, 0X2, 0, 0);
	set_name(0XA33C, "setdoscntry_find", SN_LOCAL);
	set_name(0XA34B, "setdoscntry_next", SN_LOCAL);
	set_name(0XA354, "setdoscntry_fail", SN_LOCAL);
	set_name(0XA356, "setdosdata_fail", SN_LOCAL);
	set_name(0XA35B, "setdoscntry_any_codepage", SN_LOCAL);
	set_name(0XA35E, "setdoscntry_got_it", SN_LOCAL);
	set_name(0XA375, "setdoscntry_data", SN_LOCAL);
	set_name(0XA3EE, "setdoscntry_mov", SN_LOCAL);
	set_name(0XA3FD, "setdoscntry_data_next", SN_LOCAL);
	set_name(0XA40D, "setdoscntry_ok", SN_LOCAL);
	add_func    (0XA40E,0XA429);
	set_func_flags(0XA40E,0x4400);
	set_frame_size(0XA40E, 0, 0, 0);
	set_name(0XA428, "sdbcsbc", SN_LOCAL);
	add_func    (0XA429,0XA457);
	set_func_flags(0XA429,0x4400);
	set_frame_size(0XA429, 0, 0, 0);
	set_name(0XA432, "getcntrydest", SN_LOCAL);
	set_name(0XA442, "getcntrydest_1", SN_LOCAL);
	set_name(0XA445, "getcntrydest_loop", SN_LOCAL);
	set_name(0XA44A, "getcntrydest_ok", SN_LOCAL);
	set_name(0XA451, "getcntrydest_ok1", SN_LOCAL);
	set_name(0XA455, "getcntrydest_exit", SN_LOCAL);
	add_func    (0XA457,0XA46B);
	set_func_flags(0XA457,0x4400);
	set_frame_size(0XA457, 0, 0, 0);
	set_name(0XA46A, "ricb_exit", SN_LOCAL);
	add_func    (0XA4A1,0XA4B7);
	set_func_flags(0XA4A1,0x4400);
	set_frame_size(0XA4A1, 0, 0, 0);
	set_name(0XA4B4, "cdletter_no", SN_LOCAL);
	set_name(0XA4B5, "cdletter_exit", SN_LOCAL);
	add_func    (0XA4B7,0XA4BF);
	set_func_flags(0XA4B7,0x4400);
	set_frame_size(0XA4B7, 0, 0, 0);
	add_func    (0XA4BF,0XA4ED);
	set_func_flags(0XA4BF,0x4400);
	set_frame_size(0XA4BF, 0, 0, 0);
	set_name(0XA4CE, "prn1", SN_LOCAL);
	set_name(0XA4DC, "prn2", SN_LOCAL);
	set_name(0XA4EC, "prnexit", SN_LOCAL);
	add_func    (0XA4ED,0XA4F2);
	set_func_flags(0XA4ED,0x4400);
	set_frame_size(0XA4ED, 0, 0, 0);
	add_func    (0XA4F2,0XA511);
	set_func_flags(0XA4F2,0x4400);
	set_frame_size(0XA4F2, 0, 0, 0);
	set_name(0XA4F7, "open_dev1", SN_LOCAL);
	set_name(0XA4FD, "of_retn", SN_LOCAL);
	set_name(0XA4FE, "open_dev3", SN_LOCAL);
	add_func    (0XA511,0XA517);
	set_func_flags(0XA511,0x4400);
	set_frame_size(0XA511, 0, 0, 0);
}

//------------------------------------------------------------------------
// Information about functions

static Functions(void) {

	Functions_0();
}

//------------------------------------------------------------------------
// Information about segment registers

static SegRegs(void) {
	split_sreg_range(0,"es",0,3);
	split_sreg_range(0X6D,"es",0,3);
	split_sreg_range(0X198,"es",0,3);
	split_sreg_range(0X2B6,"es",0,3);
	split_sreg_range(0X2DD,"es",0X70,3);
	split_sreg_range(0X33C,"es",0X70,3);
	split_sreg_range(0X402,"es",0,3);
	split_sreg_range(0X4A2,"es",0,3);
	split_sreg_range(0X54B,"es",0,3);
	split_sreg_range(0X5F0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD34,"es",0,3);
	split_sreg_range(0XD47,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD4F,"es",0,3);
	split_sreg_range(0XDBA,"es",0XFFFF,3);
	split_sreg_range(0XDC4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XE0B,"es",0,3);
	split_sreg_range(0XE26,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1D21,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1D42,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1D94,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X21DB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2241,"es",0X5F,3);
	split_sreg_range(0X2266,"es",0,3);
	split_sreg_range(0X22EB,"es",0X5F,3);
	split_sreg_range(0X2406,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2474,"es",0XFFFF,3);
	split_sreg_range(0X24C1,"es",0,3);
	split_sreg_range(0X257F,"es",0X544,3);
	split_sreg_range(0X25B9,"es",0X5F,3);
	split_sreg_range(0X26B5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2705,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2759,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2858,"es",0X5F,3);
	split_sreg_range(0X286D,"es",0XF000,3);
	split_sreg_range(0X2888,"es",0XF000,3);
	split_sreg_range(0X28D8,"es",0X5F,3);
	split_sreg_range(0X28E6,"es",0X5F,3);
	split_sreg_range(0X2945,"es",0X5F,3);
	split_sreg_range(0X2951,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2A19,"es",0X544,3);
	split_sreg_range(0X2A1E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2ABF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2C73,"es",0X5F,3);
	split_sreg_range(0X2CCB,"es",0X5F,3);
	split_sreg_range(0X2D9B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2DD7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2DE3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2ED0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2EDC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2FAD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2FE1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3039,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X30E2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X30E5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3144,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3279,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X32B5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X32C9,"es",0X544,3);
	split_sreg_range(0X32D0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X34F3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3511,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X352B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3530,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3567,"es",0X70,3);
	split_sreg_range(0X358C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3599,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X35DA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X35F1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X360B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X36E9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3727,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X37FA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3809,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X382D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3AE2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3AEB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3B44,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3B49,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3BD8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E0B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E11,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E3B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E41,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3EDC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3EF0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F0B,"es",0,3);
	split_sreg_range(0X3F10,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F25,"es",0,3);
	split_sreg_range(0X3F2B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F38,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3F40,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3FC2,"es",0,3);
	split_sreg_range(0X3FC7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3FD0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4148,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4164,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X42F9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X42FF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4312,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4319,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X431E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4330,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X437E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4382,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X444D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4463,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44E4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X45CE,"es",0X70,3);
	split_sreg_range(0X4720,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4724,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X473E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4743,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4846,"es",0,3);
	split_sreg_range(0X484B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X485A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4886,"es",0,3);
	split_sreg_range(0X488B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4897,"es",0,3);
	split_sreg_range(0X48C5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X48F2,"es",0,3);
	split_sreg_range(0X48F7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X491A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X492E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4931,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X493F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4950,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4993,"es",0X70,3);
	split_sreg_range(0X4998,"es",0,3);
	split_sreg_range(0X49A3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X49D7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X49DB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A09,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A1E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A31,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A4D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A5F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AC0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4ACE,"es",0X353,3);
	split_sreg_range(0X4ADE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AE1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4BB4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4BB9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4BD4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C13,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C41,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C4B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C89,"es",0X70,3);
	split_sreg_range(0X4C98,"es",0XFFFF,3);
	split_sreg_range(0X4CAD,"es",0XFFFF,3);
	split_sreg_range(0X4D7E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4D8B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4D94,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4DE9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4DF3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4EB7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4EC1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F24,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F2E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F39,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F5C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F9F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4FB8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4FC0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4FD0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X500D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X522D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X523A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5241,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5272,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5280,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X52E5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X52F2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5330,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X534D,"es",0XF000,3);
	split_sreg_range(0X5354,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X547F,"es",0,3);
	split_sreg_range(0X54AC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X54B7,"es",0,3);
	split_sreg_range(0X54D9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X578B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X57AD,"es",0,3);
	split_sreg_range(0X57B7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X57F1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5836,"es",0X70,3);
	split_sreg_range(0X5848,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X585D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5886,"es",0XAFF,3);
	split_sreg_range(0X58A7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X58F6,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5910,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X592D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5951,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X595A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X59E1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X59F2,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A11,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A29,"es",0X523,3);
	split_sreg_range(0X5A72,"es",0X533,3);
	split_sreg_range(0X5B18,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B26,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B34,"es",0XFFFFFFFFFFFFFFFE,3);
	split_sreg_range(0X5B60,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B76,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5BCE,"es",0X70,3);
	split_sreg_range(0X5C06,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5C1A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5C28,"es",0XFFFFFFFFFFFFFFFE,3);
	split_sreg_range(0X5C38,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5C8F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5D06,"es",0X533,3);
	split_sreg_range(0X5DAF,"es",0X533,3);
	split_sreg_range(0X5E66,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E7E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5E97,"es",0XFFFF,3);
	split_sreg_range(0X5EAC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5EDA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F19,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F35,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5FB1,"es",0XFFFF,3);
	split_sreg_range(0X5FE3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X605C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X606D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X608C,"es",0XFFFF,3);
	split_sreg_range(0X6099,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6124,"es",0X533,3);
	split_sreg_range(0X612C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6161,"es",0X533,3);
	split_sreg_range(0X617F,"es",0XFFFF,3);
	split_sreg_range(0X619E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X61C8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X62A4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6304,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6363,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6367,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X63B9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6451,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6495,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X64C3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6588,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X660D,"es",0XF000,3);
	split_sreg_range(0X6632,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X664C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6689,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6695,"es",0XFFFFFFFFFFFFFFFE,3);
	split_sreg_range(0X66A4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X66BA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X66D8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X66E1,"es",0X533,3);
	split_sreg_range(0X6756,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6783,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X687A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X687F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6908,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6951,"es",0,3);
	split_sreg_range(0X69B5,"es",0XF000,3);
	split_sreg_range(0X69BC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69F5,"es",0XF000,3);
	split_sreg_range(0X69FC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A35,"es",0XF000,3);
	split_sreg_range(0X6A3C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A75,"es",0XF000,3);
	split_sreg_range(0X6A7C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AB5,"es",0XF000,3);
	split_sreg_range(0X6ABC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AF5,"es",0XF000,3);
	split_sreg_range(0X6AFC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B35,"es",0XF000,3);
	split_sreg_range(0X6B3C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B75,"es",0XF000,3);
	split_sreg_range(0X6B7C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BB5,"es",0XF000,3);
	split_sreg_range(0X6BBC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BF5,"es",0XF000,3);
	split_sreg_range(0X6BFC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C32,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C82,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C8E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6CD2,"es",0X533,3);
	split_sreg_range(0X6CFE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6D14,"es",0X533,3);
	split_sreg_range(0X6D95,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DC5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DF0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DF4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DFF,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E16,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E68,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E6D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E98,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F05,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F15,"es",0X1,3);
	split_sreg_range(0X7409,"es",0X533,3);
	split_sreg_range(0X741D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7425,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X781C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7B6B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7BBA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7E69,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F29,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F36,"es",0X533,3);
	split_sreg_range(0X7F53,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FEC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8010,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X801F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8092,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8096,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80A1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X80B8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8108,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X810D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8136,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8158,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X81B0,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X81B5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X821B,"es",0X533,3);
	split_sreg_range(0X8229,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8284,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X82A1,"es",0X533,3);
	split_sreg_range(0X82BB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X82C7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X856D,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8583,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8610,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8622,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8629,"es",0X533,3);
	split_sreg_range(0X8649,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X86C5,"es",0X533,3);
	split_sreg_range(0X86EE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X877B,"es",0X533,3);
	split_sreg_range(0X8785,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X879F,"es",0X533,3);
	split_sreg_range(0X87C9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X87DC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X87F5,"es",0,3);
	split_sreg_range(0X8817,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X881F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X882C,"es",0X533,3);
	split_sreg_range(0X8831,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X886B,"es",0X533,3);
	split_sreg_range(0X8872,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X888A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X88F7,"es",0X533,3);
	split_sreg_range(0X88FC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X891A,"es",0X533,3);
	split_sreg_range(0X8932,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8943,"es",0X533,3);
	split_sreg_range(0X8965,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X896F,"es",0X533,3);
	split_sreg_range(0X897B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8A49,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8A72,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8A92,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8AA5,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8AEC,"es",0X533,3);
	split_sreg_range(0X8AF3,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B09,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B1B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B57,"es",0X533,3);
	split_sreg_range(0X8B5C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B96,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B99,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8BFB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C19,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C55,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C59,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8CA1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8CCE,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D1A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D1E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D2A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D44,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8D47,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DAB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DD1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DD4,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DE8,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DF9,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E0B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E13,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E3E,"es",0X533,3);
	split_sreg_range(0X8E45,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E64,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E7F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8EDC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8FCA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9012,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X906C,"es",0X533,3);
	split_sreg_range(0X9245,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9276,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9290,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92C7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92E1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92FD,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9302,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9342,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X935C,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9376,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X938E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X939A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X93AC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X93D7,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X93E1,"es",0XFFFFFFFFFFFFFFFE,3);
	split_sreg_range(0X93EA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X93FA,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9417,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X94E5,"es",0X533,3);
	split_sreg_range(0X94F1,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9569,"es",0X533,3);
	split_sreg_range(0X958A,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9AA8,"es",0X40,3);
	split_sreg_range(0X9ADB,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9BF2,"es",0X533,3);
	split_sreg_range(0X9C07,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C1B,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C26,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C33,"es",0X40,3);
	split_sreg_range(0X9C42,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C54,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9CCC,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9E5E,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA251,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA260,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA30D,"es",0X533,3);
	split_sreg_range(0XA317,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA455,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA470,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA49F,"es",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA4C1,"es",0X533,3);
	split_sreg_range(0,"ss",0,3);
	split_sreg_range(0X1AC,"ss",0XFFFFFFFFFFFFFFC0,3);
	split_sreg_range(0X5F0,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X244A,"ss",0,3);
	split_sreg_range(0X3530,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5330,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X54B3,"ss",0,3);
	split_sreg_range(0X54CA,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X58B6,"ss",0X533,3);
	split_sreg_range(0X677C,"ss",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0,"ds",0,3);
	split_sreg_range(0X5A,"ds",0,3);
	split_sreg_range(0X5C,"ds",0,3);
	split_sreg_range(0X6B,"ds",0,3);
	split_sreg_range(0X75,"ds",0,3);
	split_sreg_range(0X80,"ds",0,3);
	split_sreg_range(0X160,"ds",0,3);
	split_sreg_range(0X168,"ds",0,3);
	split_sreg_range(0X19A,"ds",0,3);
	split_sreg_range(0X1B4,"ds",0,3);
	split_sreg_range(0X2DB,"ds",0X70,3);
	split_sreg_range(0X2EA,"ds",0,3);
	split_sreg_range(0X35D,"ds",0,3);
	split_sreg_range(0X385,"ds",0XFFFFFFFFFFFFFFC0,3);
	split_sreg_range(0X38D,"ds",0,3);
	split_sreg_range(0X3C8,"ds",0XFFFFFFFFFFFFFFC0,3);
	split_sreg_range(0X3CB,"ds",0,3);
	split_sreg_range(0X3E5,"ds",0,3);
	split_sreg_range(0X3FD,"ds",0,3);
	split_sreg_range(0X5F0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XC81,"ds",0,3);
	split_sreg_range(0XC92,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCF8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XCFF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD0C,"ds",0X5F,3);
	split_sreg_range(0XD3A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD48,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XD4B,"ds",0X5F,3);
	split_sreg_range(0XD99,"ds",0,3);
	split_sreg_range(0XDAE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1D02,"ds",0X40,3);
	split_sreg_range(0X1D43,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1E23,"ds",0X40,3);
	split_sreg_range(0X1E2A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X1E3D,"ds",0X5F,3);
	split_sreg_range(0X2186,"ds",0X5F,3);
	split_sreg_range(0X219B,"ds",0X40,3);
	split_sreg_range(0X21DC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2200,"ds",0X5F,3);
	split_sreg_range(0X225F,"ds",0X5F,3);
	split_sreg_range(0X2272,"ds",0,3);
	split_sreg_range(0X22DA,"ds",0,3);
	split_sreg_range(0X22F6,"ds",0,3);
	split_sreg_range(0X236F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2381,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X24BF,"ds",0,3);
	split_sreg_range(0X252D,"ds",0,3);
	split_sreg_range(0X2535,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X254D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2561,"ds",0X544,3);
	split_sreg_range(0X2583,"ds",0,3);
	split_sreg_range(0X25A0,"ds",0,3);
	split_sreg_range(0X25B7,"ds",0X5F,3);
	split_sreg_range(0X25D7,"ds",0XF000,3);
	split_sreg_range(0X25FF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X260F,"ds",0X5F,3);
	split_sreg_range(0X2684,"ds",0,3);
	split_sreg_range(0X26B4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X26B9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X26CB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2709,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X275D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X28FC,"ds",0,3);
	split_sreg_range(0X2905,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X290F,"ds",0X5F,3);
	split_sreg_range(0X2935,"ds",0X5F,3);
	split_sreg_range(0X2947,"ds",0X5F,3);
	split_sreg_range(0X2950,"ds",0X5F,3);
	split_sreg_range(0X297C,"ds",0,3);
	split_sreg_range(0X2986,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2AB4,"ds",0X544,3);
	split_sreg_range(0X2AB8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2C92,"ds",0,3);
	split_sreg_range(0X2CA4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2CAC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2CEF,"ds",0X5F,3);
	split_sreg_range(0X2CFE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2D9D,"ds",0X5F,3);
	split_sreg_range(0X2DD3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2DD9,"ds",0X5F,3);
	split_sreg_range(0X2DE2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2ED2,"ds",0X5F,3);
	split_sreg_range(0X2EDB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2FAF,"ds",0X5F,3);
	split_sreg_range(0X2FB7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X2FE2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X307D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3084,"ds",0X5F,3);
	split_sreg_range(0X3244,"ds",0,3);
	split_sreg_range(0X3251,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X32B6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X33F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3484,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X34B6,"ds",0X5F,3);
	split_sreg_range(0X34BE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X34E0,"ds",0X5F,3);
	split_sreg_range(0X34F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3516,"ds",0X5F,3);
	split_sreg_range(0X351E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X352A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3530,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X358A,"ds",0X70,3);
	split_sreg_range(0X35E8,"ds",0X70,3);
	split_sreg_range(0X35EC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X35F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X379A,"ds",0,3);
	split_sreg_range(0X37A2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X38A2,"ds",0,3);
	split_sreg_range(0X38AA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X394D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3950,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3BCD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3BD9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3C87,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3CDE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3DBA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3DC6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3DD7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E2C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E34,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E52,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3E56,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4041,"ds",0X353,3);
	split_sreg_range(0X4047,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4070,"ds",0X353,3);
	split_sreg_range(0X4073,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X40FD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4107,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4113,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4127,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4307,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X430C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4486,"ds",0X70,3);
	split_sreg_range(0X4491,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4494,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44BF,"ds",0X70,3);
	split_sreg_range(0X44C6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44E3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44F4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X44F7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X451C,"ds",0X70,3);
	split_sreg_range(0X4522,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4541,"ds",0X70,3);
	split_sreg_range(0X4553,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4584,"ds",0X70,3);
	split_sreg_range(0X4588,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X459D,"ds",0X70,3);
	split_sreg_range(0X45A2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X45EB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X45EE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X45F9,"ds",0X70,3);
	split_sreg_range(0X45FD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X460D,"ds",0X70,3);
	split_sreg_range(0X461E,"ds",0X70,3);
	split_sreg_range(0X46B2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X46B5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X46C1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47A0,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X47A8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4810,"ds",0,3);
	split_sreg_range(0X4814,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X481A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X48C4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4974,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X498E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X49A4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A24,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A27,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A2F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A8F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4A92,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AA5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AA8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AE8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4AEB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B26,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B29,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B7D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4B80,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4BFB,"ds",0X70,3);
	split_sreg_range(0X4C14,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C2F,"ds",0X70,3);
	split_sreg_range(0X4C38,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C46,"ds",0X70,3);
	split_sreg_range(0X4C4A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C51,"ds",0X70,3);
	split_sreg_range(0X4C55,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4C5C,"ds",0X70,3);
	split_sreg_range(0X4C8A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4CA2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4CBF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4CD6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4CDC,"ds",0X70,3);
	split_sreg_range(0X4E15,"ds",0X70,3);
	split_sreg_range(0X4E35,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F3A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F43,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4F9E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X4FAC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5016,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5047,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X51E7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X51F3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5330,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X552D,"ds",0XF000,3);
	split_sreg_range(0X5533,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5544,"ds",0X533,3);
	split_sreg_range(0X554E,"ds",0X70,3);
	split_sreg_range(0X5554,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X576B,"ds",0XF000,3);
	split_sreg_range(0X57A8,"ds",0X533,3);
	split_sreg_range(0X5828,"ds",0X70,3);
	split_sreg_range(0X5866,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X588D,"ds",0X364,3);
	split_sreg_range(0X58AC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A13,"ds",0X533,3);
	split_sreg_range(0X5A1B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A3E,"ds",0X533,3);
	split_sreg_range(0X5A54,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5A68,"ds",0,3);
	split_sreg_range(0X5A6C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5ABF,"ds",0,3);
	split_sreg_range(0X5ADB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5B4C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5C45,"ds",0X533,3);
	split_sreg_range(0X5D27,"ds",0X533,3);
	split_sreg_range(0X5E54,"ds",0X533,3);
	split_sreg_range(0X5EBD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5EE2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F31,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F4B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F64,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5F67,"ds",0X533,3);
	split_sreg_range(0X5F77,"ds",0X70,3);
	split_sreg_range(0X5FC3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5FC6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5FE4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6044,"ds",0,3);
	split_sreg_range(0X6081,"ds",0X533,3);
	split_sreg_range(0X6146,"ds",0X70,3);
	split_sreg_range(0X6150,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6155,"ds",0,3);
	split_sreg_range(0X6159,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X616D,"ds",0XFFFF,3);
	split_sreg_range(0X6183,"ds",0,3);
	split_sreg_range(0X6190,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X61C6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6233,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6235,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X623E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X624A,"ds",0X70,3);
	split_sreg_range(0X6258,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6262,"ds",0X533,3);
	split_sreg_range(0X6295,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6298,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X629F,"ds",0X533,3);
	split_sreg_range(0X62D1,"ds",0X533,3);
	split_sreg_range(0X62EE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6300,"ds",0X533,3);
	split_sreg_range(0X6369,"ds",0X533,3);
	split_sreg_range(0X63E6,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X63EC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X63FD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X640C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6491,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X649A,"ds",0X533,3);
	split_sreg_range(0X64C5,"ds",0X533,3);
	split_sreg_range(0X64DB,"ds",0X70,3);
	split_sreg_range(0X650C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6522,"ds",0X533,3);
	split_sreg_range(0X66E2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6757,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6782,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6793,"ds",0X533,3);
	split_sreg_range(0X67A7,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X67CC,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6904,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6941,"ds",0XF000,3);
	split_sreg_range(0X6947,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6995,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69BF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69CE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69D5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X69FF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A0E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A15,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A3F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A4E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A55,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A7F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A8E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6A95,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6ABF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6ACE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AD5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6AFF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B0E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B15,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B3F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B4E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B55,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B7F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B8E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6B95,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BBF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BCE,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BD5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6BFF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C0E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C14,"ds",0XF000,3);
	split_sreg_range(0X6C1A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C26,"ds",0X70,3);
	split_sreg_range(0X6C33,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C43,"ds",0X70,3);
	split_sreg_range(0X6C45,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C4D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6C5F,"ds",0X70,3);
	split_sreg_range(0X6C6C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6CEF,"ds",0X533,3);
	split_sreg_range(0X6D44,"ds",0X533,3);
	split_sreg_range(0X6DBB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6DE9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E79,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E82,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6E90,"ds",0X533,3);
	split_sreg_range(0X6EA5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F42,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F45,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X6F64,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7812,"ds",0,3);
	split_sreg_range(0X7821,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7833,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X784C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7B10,"ds",0X533,3);
	split_sreg_range(0X7B69,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7B98,"ds",0X533,3);
	split_sreg_range(0X7BAE,"ds",0X533,3);
	split_sreg_range(0X7C32,"ds",0X533,3);
	split_sreg_range(0X7C3E,"ds",0X533,3);
	split_sreg_range(0X7DBE,"ds",0X70,3);
	split_sreg_range(0X7DD5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7EAF,"ds",0X533,3);
	split_sreg_range(0X7F22,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F2B,"ds",0X533,3);
	split_sreg_range(0X7F3D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F49,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F51,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F5B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F80,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7F8E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FA9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FAD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FDB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X7FE0,"ds",0X533,3);
	split_sreg_range(0X7FE4,"ds",0X533,3);
	split_sreg_range(0X7FEE,"ds",0X533,3);
	split_sreg_range(0X8018,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X808D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8119,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8123,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X812E,"ds",0X533,3);
	split_sreg_range(0X8143,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8220,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X822A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8293,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X82C9,"ds",0X533,3);
	split_sreg_range(0X8544,"ds",0X70,3);
	split_sreg_range(0X8584,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8627,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8648,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X864C,"ds",0X533,3);
	split_sreg_range(0X8667,"ds",0X533,3);
	split_sreg_range(0X8671,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8681,"ds",0X533,3);
	split_sreg_range(0X868D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X86B6,"ds",0X533,3);
	split_sreg_range(0X86C7,"ds",0X533,3);
	split_sreg_range(0X86ED,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8739,"ds",0X40,3);
	split_sreg_range(0X8750,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8765,"ds",0X40,3);
	split_sreg_range(0X876D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8776,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8786,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X878E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8798,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X883F,"ds",0X533,3);
	split_sreg_range(0X8844,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X884F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X888B,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X88EE,"ds",0X533,3);
	split_sreg_range(0X88F2,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8945,"ds",0X533,3);
	split_sreg_range(0X8966,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8A06,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8A4A,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8AC5,"ds",0X533,3);
	split_sreg_range(0X8AD9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B1C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B22,"ds",0X533,3);
	split_sreg_range(0X8B26,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B2C,"ds",0X533,3);
	split_sreg_range(0X8B3C,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B44,"ds",0X533,3);
	split_sreg_range(0X8B51,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B61,"ds",0X533,3);
	split_sreg_range(0X8B66,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8B9F,"ds",0X533,3);
	split_sreg_range(0X8BA3,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8C6B,"ds",0X533,3);
	split_sreg_range(0X8C70,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8DE9,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E1B,"ds",0X533,3);
	split_sreg_range(0X8E20,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E2A,"ds",0X533,3);
	split_sreg_range(0X8E2E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8E50,"ds",0X533,3);
	split_sreg_range(0X8E55,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F76,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8F83,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X8FDB,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9010,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9016,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9058,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X90F1,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9115,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X923D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9241,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9253,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X92F5,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9306,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X93FF,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X940F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9418,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9422,"ds",0X533,3);
	split_sreg_range(0X943C,"ds",0X70,3);
	split_sreg_range(0X9464,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9468,"ds",0X533,3);
	split_sreg_range(0X9480,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9484,"ds",0X533,3);
	split_sreg_range(0X94C8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9845,"ds",0,3);
	split_sreg_range(0X9861,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X98CE,"ds",0,3);
	split_sreg_range(0X98ED,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9A75,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9A79,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9B8D,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9BA0,"ds",0X533,3);
	split_sreg_range(0X9BA4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9BB4,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9BB8,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C18,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9C55,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9CCD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9D6E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9D76,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X9DC9,"ds",0X533,3);
	split_sreg_range(0X9DCD,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA12C,"ds",0X533,3);
	split_sreg_range(0XA154,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA1FA,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA21E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA268,"ds",0X533,3);
	split_sreg_range(0XA273,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA46F,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA49E,"ds",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0XA4CB,"ds",0X533,3);
	split_sreg_range(0,"fs",0,3);
	split_sreg_range(0X5F0,"fs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3530,"fs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5330,"fs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0,"gs",0,3);
	split_sreg_range(0X5F0,"gs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X3530,"gs",0XFFFFFFFFFFFFFFFF,3);
	split_sreg_range(0X5330,"gs",0XFFFFFFFFFFFFFFFF,3);
}

//------------------------------------------------------------------------
// Information about all patched bytes:

static Patches(void) {
}

//------------------------------------------------------------------------
// Call all byte feature functions:

static Bytes(void) {
	Bytes_0();
	Bytes_1();
	Bytes_2();
	Bytes_3();
	Bytes_4();
	Bytes_5();
	Bytes_6();
        end_type_updating(UTP_STRUCT);
}

// End of file.
